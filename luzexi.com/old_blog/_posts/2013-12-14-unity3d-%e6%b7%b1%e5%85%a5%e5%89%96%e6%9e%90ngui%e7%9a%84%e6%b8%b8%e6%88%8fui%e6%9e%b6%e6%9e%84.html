---
layout: post
status: publish
published: true
title: Unity3D-深入剖析NGUI的游戏UI架构
author:
  display_name: 陆泽西
  login: luzexi
  email: jesse_luzexi@163.com
  url: http://www.luzexi.com
author_login: luzexi
author_email: jesse_luzexi@163.com
author_url: http://www.luzexi.com
wordpress_id: 182
wordpress_url: http://www.luzexi.com/?p=182
date: !binary |-
  MjAxMy0xMi0xNCAxMzowMDo1NCArMDgwMA==
date_gmt: !binary |-
  MjAxMy0xMi0xNCAwNTowMDo1NCArMDgwMA==
categories:
- Unity3D
- 游戏通用模块
tags:
- NGUI
- UI
- Unity3D
- 客户端架构
- 服务器架构设计
- 游戏架构
---
<p>Unity3D-NGUI分析，使用NGUI做UI需要注意的几个要点在此我想罗列一下，对我在U3D上做UI的一些总结，最后解剖一下NGUI的源代码，它是如果架构和运作的。</p>
<p>在此前我介绍了自己项目的架构方式，所以在NGUI的利用上也是同样的做法，UI逻辑的程序不被绑定在物体上。那么如何做到GUI输入消息的传递呢，答案是：我封装了一个关于NGUI输入消息的类，由于NGUI的输入消息传递方式是U3D中的SendMessage方式，所以在每个需要接入输入的物体上动态的绑定该封装脚本。在这个消息封装类中，加入消息传递的委托方法后，所有关于该物体的输入消息将通过封装类直接传递到方法上，再通过消息类型的识别就可以脱离传统脚本绑定的束缚了。源码地址：<a href="http:&#47;&#47;114.215.202.83&#47;blog&#47;wp-content&#47;uploads&#47;2013&#47;12&#47;GUIComponentEvent.rar" rel="attachment wp-att-184">GUIComponentEvent<&#47;a></p>
<p>在用NGUI制作UI时需要注意的几点：</p>
<p>1.每个GUI以1各UIPanel为标准，过多的UIPanel首先会导致DrawCall的增多，其次是导致UI逻辑的混乱。</p>
<p>2.UITexture不能使用的过于平凡，因为每个UITexture都会增加1各DrawCall，所以一般会作为背景图出现在UI上，小背景，大背景都可以。</p>
<p>3.图集不宜过大，过大的图集，不要把很多个GUI都放在一个图集里，在UI显示时加载资源IO速度会非常慢。我尝试了各种方式来管理图集，例如每个GUI一个图集，大雨300*100宽度的图不做图集，抑或一个系统模块2个图集，甚至我有尝试过以整个游戏为单位划分公共图集，按钮图集，头像图集，问题图集，但这种方式最终以图集过大IO过慢而放弃，这些图集的管理方式都是应项目而适应的，并没有固定的方式，最主要是你怎么理解程序读取资源时的IO操作时间。</p>
<p>4.在开发中，尽量用Free分辨率来测试项目的适配效果，不要到上线才发现适配问题。</p>
<p>适配源码：</p>
<div class="dp-highlighter">
<div class="bar"><&#47;div></p>
<ol class="dp-c" start="1">
<li class="alt"><span class="keyword">float<&#47;span>&nbsp;defaultWHRate&nbsp;=&nbsp;800f&nbsp;&#47;&nbsp;480f;<&#47;li>
<li><span class="keyword">float<&#47;span>&nbsp;ScreenWHRate&nbsp;=&nbsp;(<span class="keyword">float<&#47;span>)Screen.width&nbsp;&#47;&nbsp;(<span class="keyword">float<&#47;span>)Screen.height;<&#47;li>
<li class="alt"><span class="keyword">bool<&#47;span>&nbsp;isUseHResize&nbsp;=&nbsp;defaultWHRate&nbsp;>=&nbsp;ScreenWHRate&nbsp;?&nbsp;<span class="keyword">false<&#47;span>&nbsp;:&nbsp;<span class="keyword">true<&#47;span>;<&#47;li>
<li>UIRoot&nbsp;root&nbsp;=&nbsp;GameObject.Find(<span class="string">"ROOT"<&#47;span>).GetComponent<UIRoot>();<&#47;li>
<li class="alt"><span class="keyword">if<&#47;span>&nbsp;(!isUseHResize)<&#47;li>
<li>{<&#47;li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">float<&#47;span>&nbsp;curScreenH&nbsp;=&nbsp;(<span class="keyword">float<&#47;span>)Screen.width&nbsp;&#47;&nbsp;defaultWHRate;<&#47;li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">float<&#47;span>&nbsp;Hrate&nbsp;=&nbsp;curScreenH&nbsp;&#47;&nbsp;Screen.height;<&#47;li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;root.manualHeight&nbsp;=(<span class="keyword">int<&#47;span>)(480f&nbsp;&#47;&nbsp;Hrate);<&#47;li>
<li>}<&#47;li>
<li class="alt"><span class="keyword">else<&#47;span><&#47;li>
<li>{<&#47;li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;root.manualHeight&nbsp;=&nbsp;480;<&#47;li>
<li>}<&#47;li><br />
<&#47;ol><br />
<&#47;div><br />
5.拆分以及固定各个锚点，上，左上，右上，中，左中，右中，下，左下，右下</p>
<p>6.拆分GUI层级，层级越高，显示越靠前。层级的正确拆分能有效管理GUI的显示方式。</p>
<div class="dp-highlighter">
<div class="bar"><&#47;div></p>
<ol class="dp-c" start="1">
<li class="alt"><span class="comment">&#47;&#47;&#47;&nbsp;<br />
<summary><&#47;span><&#47;li></p>
<li><span class="comment">&#47;&#47;&#47;&nbsp;GUI层级<&#47;span><&#47;li>
<li class="alt"><span class="comment">&#47;&#47;&#47;&nbsp;<&#47;summary><&#47;span><&#47;li>
<li><span class="keyword">public<&#47;span>&nbsp;<span class="keyword">enum<&#47;span>&nbsp;GUILAYER<&#47;li>
<li class="alt">{<&#47;li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;GUI_BACKGROUND&nbsp;=&nbsp;0,&nbsp;<span class="comment">&#47;&#47;背景层<&#47;span><&#47;li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;GUI_MENU,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">&#47;&#47;菜单层0<&#47;span><&#47;li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;GUI_MENU1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">&#47;&#47;菜单层1<&#47;span><&#47;li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;GUI_PANEL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">&#47;&#47;面板层<&#47;span><&#47;li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;GUI_PANEL1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">&#47;&#47;面板1层<&#47;span><&#47;li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;GUI_PANEL2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">&#47;&#47;面板2层<&#47;span><&#47;li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;GUI_PANEL3,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">&#47;&#47;面板3层<&#47;span><&#47;li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;GUI_FULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">&#47;&#47;满屏层<&#47;span><&#47;li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;GUI_MESSAGE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">&#47;&#47;消息层<&#47;span><&#47;li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;GUI_MESSAGE1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">&#47;&#47;消息层<&#47;span><&#47;li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;GUI_GUIDE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">&#47;&#47;引导层<&#47;span><&#47;li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;GUI_LOADING,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">&#47;&#47;加载层<&#47;span><&#47;li>
<li>}<&#47;li><br />
<&#47;ol><br />
<&#47;div><br />
8.要充分的管理GUI，不然过多的GUI会导致内存加速增长，而每次都销毁不用的GUI则会让IO过于频繁降低运行速度。我的方法是找到两者间的中间态，给予隐藏的GUI一个缓冲带,当每次某各GUI进行隐藏时判断是否有需要销毁的GUI。或者也可以这么做，每时每刻去监控隐藏的GUI，哪些GUI内存时间驻留过长就销毁。关于内存优化问题，可以参考<a href="http:&#47;&#47;www.luzexi.com&#47;unity3d-texture%E5%9B%BE%E7%89%87%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%88%86%E6%9E%90&#47;" target="_blank">《unity3d-texture图片空间和内存占用分析》<&#47;a>和 <a href="http:&#47;&#47;www.luzexi.com&#47;unity3d%E4%BC%98%E5%8C%96%E4%B9%8B%E8%B7%AF&#47;" target="_blank">《unity3d优化之路》<&#47;a></p>
<p>9.另外关于图标，像头像，物品，数量过多的，可以用打成几个图集，按一定规则进行排列，减小文件大小减少一次性读取的IO时间。</p>
<p>10.尽量减少不必要的UI更改，NGUI一旦有UI进行更改，它就得重新绘制MESH和贴图，比起cocos2d耗得CPU大的多。</p>
<p>11.如果可以不用动态字体就不要用动态字体，因为动态字体每次都会做IO操作读取相应的图片，这个是NGUI一个问题，费cpu，费内存。</p>
<p>12.设置脚本执行次序，在U3D的Project setting->Script Execution Order 中。由于NGUI以UIPanel为主要渲染入口，所以，所有关于游戏渲染处理的程序最好放在渲染之后，也就是UIPanel之后。UIPanel以LateUpdate为接口入口，所以关于渲染方面的程序还得斟酌是否方在LateUpdate里。</p>
<p>13.NGUI对于动态的移动旋转等的UI操作支持性很差，当有这种操作过多的时候，会使得屏幕很卡。解决办法就是，自己用程序生成面片，面片的渲染不再受到NGUI的控制。</p>
<p>&nbsp;</p>
<p>以上是我能想起来的注意点，若有没想起来的，在以后的时间想到的也将补充进去。口无遮拦的说了这么多，不剖析一下源码怎么说的过去，之前对NGUI输入消息进行了封装，对2D动画序列帧进行了封装，却一直没能完整剖析它的底层源码，着实遗憾。</p>
<p><span style="color: #ff0000;">NGUI中UIPanel是渲染的关键，他承载了在他下面的子物体的所有渲染工作，每个渲染元素都是由UIWidget继承而来，每个UI物体的渲染都是由面片、材质球、UV点组成，每个种材质由一个UIDrawCall完成渲染工作，UIDrawCall中自己创建Mesh和MeshRender来进行统一的渲染工作。这些都是对NGUI底层的简单的介绍，下面将进行更加细致的分析。<&#47;span></p>
<p>首先我们来看UIWidget这个组件基类，从它拥有的类内部变量就能知道它承担得怎样的责任:</p>
<div class="dp-highlighter">
<div class="bar"><&#47;div></p>
<ol class="dp-c" start="1">
<li class="alt"><span class="comment">&#47;&#47;&nbsp;Cached&nbsp;and&nbsp;saved&nbsp;values<&#47;span><&#47;li>
<li>[HideInInspector][SerializeField]&nbsp;<span class="keyword">protected<&#47;span>&nbsp;Material&nbsp;mMat;<span class="comment">&#47;&#47;材质<&#47;span><&#47;li>
<li class="alt">[HideInInspector][SerializeField]&nbsp;<span class="keyword">protected<&#47;span>&nbsp;Texture&nbsp;mTex;<span class="comment">&#47;&#47;贴图<&#47;span><&#47;li>
<li>[HideInInspector][SerializeField]&nbsp;Color&nbsp;mColor&nbsp;=&nbsp;Color.white;<span class="comment">&#47;&#47;颜色<&#47;span><&#47;li>
<li class="alt">[HideInInspector][SerializeField]&nbsp;Pivot&nbsp;mPivot&nbsp;=&nbsp;Pivot.Center;<span class="comment">&#47;&#47;对齐位置<&#47;span><&#47;li>
<li>[HideInInspector][SerializeField]&nbsp;<span class="keyword">int<&#47;span>&nbsp;mDepth&nbsp;=&nbsp;0;<span class="comment">&#47;&#47;深度<&#47;span><&#47;li>
<li class="alt"><span class="keyword">protected<&#47;span>&nbsp;Transform&nbsp;mTrans;<span class="comment">&#47;&#47;坐标转换<&#47;span><&#47;li>
<li><span class="keyword">protected<&#47;span>&nbsp;UIPanel&nbsp;mPanel;<span class="comment">&#47;&#47;相应的UIPanel<&#47;span><&#47;li>
<li class="alt"><&#47;li>
<li><span class="keyword">protected<&#47;span>&nbsp;<span class="keyword">bool<&#47;span>&nbsp;mChanged&nbsp;=&nbsp;<span class="keyword">true<&#47;span>;<span class="comment">&#47;&#47;是否更改<&#47;span><&#47;li>
<li class="alt"><span class="keyword">protected<&#47;span>&nbsp;<span class="keyword">bool<&#47;span>&nbsp;mPlayMode&nbsp;=&nbsp;<span class="keyword">true<&#47;span>;<span class="comment">&#47;&#47;模式<&#47;span><&#47;li>
<li><&#47;li>
<li class="alt">Vector3&nbsp;mDiffPos;<span class="comment">&#47;&#47;位置差异<&#47;span><&#47;li>
<li>Quaternion&nbsp;mDiffRot;<span class="comment">&#47;&#47;旋转差异<&#47;span><&#47;li>
<li class="alt">Vector3&nbsp;mDiffScale;<span class="comment">&#47;&#47;缩放差异<&#47;span><&#47;li>
<li><span class="keyword">int<&#47;span>&nbsp;mVisibleFlag&nbsp;=&nbsp;-1;<span class="comment">&#47;&#47;可见标志<&#47;span><&#47;li>
<li class="alt"><&#47;li>
<li><span class="comment">&#47;&#47;&nbsp;Widget's&nbsp;generated&nbsp;geometry<&#47;span><&#47;li>
<li class="alt">UIGeometry&nbsp;mGeom&nbsp;=&nbsp;<span class="keyword">new<&#47;span>&nbsp;UIGeometry();<span class="comment">&#47;&#47;多变形实例<&#47;span><&#47;li><br />
<&#47;ol><br />
<&#47;div><br />
<span style="background-color: #ffff00;">UIWidget承担了存储显示内容，颜色调配，显示深度，显示位置，显示大小，显示角度，显示的多边形形状，归属哪个UIPanel。<&#47;span>这就是UIWidget所要承担的内容，在UIWidget的所有子类中都具有以上相同的属性和任务。UIWidget和UIPanel的关系非常密切，因为UIPanel承担了UIWidget的所有渲染工作，而UIWidget只是承担了存储需要渲染数据。所以，在UIWidget在更换贴图，材质球，甚至更换UIPanel父节点时它会及时通知UIPanel说："我更变配置了，你得重新获取我的渲染数据"。</p>
<p>UIWidget中最重要的虚方法为 virtual public void OnFill(BetterList<Vector3> verts, BetterList<Vector2> uvs, BetterList<Color32> cols) { } 它是区分子类的显示内容的重要方法。它的工作就是填写如何显示，显示什么。</p>
<p>UIWidget中在使用OnFill方法的重要的方法是 更新渲染多边型方法：</p>
<div class="dp-highlighter">
<div class="bar"><&#47;div></p>
<ol class="dp-c" start="1">
<li class="alt"><span class="keyword">public<&#47;span>&nbsp;<span class="keyword">bool<&#47;span>&nbsp;UpdateGeometry&nbsp;(<span class="keyword">ref<&#47;span>&nbsp;Matrix4x4&nbsp;worldToPanel,&nbsp;<span class="keyword">bool<&#47;span>&nbsp;parentMoved,&nbsp;<span class="keyword">bool<&#47;span>&nbsp;generateNormals)<&#47;li>
<li>{<&#47;li>
<li class="alt"><span class="keyword">if<&#47;span>&nbsp;(material&nbsp;==&nbsp;<span class="keyword">null<&#47;span>)&nbsp;<span class="keyword">return<&#47;span>&nbsp;<span class="keyword">false<&#47;span>;<&#47;li>
<li><&#47;li>
<li class="alt"><span class="keyword">if<&#47;span>&nbsp;(OnUpdate()&nbsp;||&nbsp;mChanged)<&#47;li>
<li>{<&#47;li>
<li class="alt">mChanged&nbsp;=&nbsp;<span class="keyword">false<&#47;span>;<&#47;li>
<li>mGeom.Clear();<&#47;li>
<li class="alt">OnFill(mGeom.verts,&nbsp;mGeom.uvs,&nbsp;mGeom.cols);<&#47;li>
<li><&#47;li>
<li class="alt"><span class="keyword">if<&#47;span>&nbsp;(mGeom.hasVertices)<&#47;li>
<li>{<&#47;li>
<li class="alt">Vector3&nbsp;offset&nbsp;=&nbsp;pivotOffset;<&#47;li>
<li>Vector2&nbsp;scale&nbsp;=&nbsp;relativeSize;<&#47;li>
<li class="alt">offset.x&nbsp;*=&nbsp;scale.x;<&#47;li>
<li>offset.y&nbsp;*=&nbsp;scale.y;<&#47;li>
<li class="alt"><&#47;li>
<li>mGeom.ApplyOffset(offset);<&#47;li>
<li class="alt">mGeom.ApplyTransform(worldToPanel&nbsp;*&nbsp;cachedTransform.localToWorldMatrix,&nbsp;generateNormals);<&#47;li>
<li>}<&#47;li>
<li class="alt"><span class="keyword">return<&#47;span>&nbsp;<span class="keyword">true<&#47;span>;<&#47;li>
<li>}<&#47;li>
<li class="alt"><span class="keyword">else<&#47;span>&nbsp;<span class="keyword">if<&#47;span>&nbsp;(mGeom.hasVertices&nbsp;&amp;amp;&amp;amp;&nbsp;parentMoved)<&#47;li>
<li>{<&#47;li>
<li class="alt">mGeom.ApplyTransform(worldToPanel&nbsp;*&nbsp;cachedTransform.localToWorldMatrix,&nbsp;generateNormals);<&#47;li>
<li>}<&#47;li>
<li class="alt"><span class="keyword">return<&#47;span>&nbsp;<span class="keyword">false<&#47;span>;<&#47;li>
<li>}<&#47;li><br />
<&#47;ol><br />
<&#47;div><br />
它的作用就是，当需要重新组织多边型展示内容时，进行多边型的重新规划。</p>
<p>&nbsp;</p>
<p>接着，我们来看看UINode，这个类很容易被人忽视，而他的作用也很重要。它是在UIPanel被告知有新的UIWidget显示元素时被创建的，它的创建主要是为了监视被创建的UIWidget的位置，旋转，大小是否被更改，若被更改，将由UIPanel进行重新的渲染工作。</p>
<p>HasChanged这是UINode唯一重要的方法之一，它的作用就是被UIPanel用来监视每个元素是否改变了进而进行重新渲染。</p>
<div class="dp-highlighter">
<div class="bar"><&#47;div></p>
<ol class="dp-c" start="1">
<li class="alt"><span class="keyword">public<&#47;span>&nbsp;<span class="keyword">bool<&#47;span>&nbsp;HasChanged&nbsp;()<&#47;li>
<li>{<&#47;li>
<li class="alt"><span class="preprocessor">#if&nbsp;UNITY_3&nbsp;||&nbsp;UNITY_4_0<&#47;span><&#47;li>
<li><span class="keyword">bool<&#47;span>&nbsp;isActive&nbsp;=&nbsp;NGUITools.GetActive(mGo)&nbsp;&amp;amp;&amp;amp;&nbsp;(widget&nbsp;==&nbsp;<span class="keyword">null<&#47;span>&nbsp;||&nbsp;(widget.enabled&nbsp;&amp;amp;&amp;amp;&nbsp;widget.isVisible));<&#47;li>
<li class="alt"><&#47;li>
<li><span class="keyword">if<&#47;span>&nbsp;(lastActive&nbsp;!=&nbsp;isActive&nbsp;||&nbsp;(isActive&nbsp;&amp;amp;&amp;amp;<&#47;li>
<li class="alt">(lastPos&nbsp;!=&nbsp;trans.localPosition&nbsp;||<&#47;li>
<li>lastRot&nbsp;!=&nbsp;trans.localRotation&nbsp;||<&#47;li>
<li class="alt">lastScale&nbsp;!=&nbsp;trans.localScale)))<&#47;li>
<li>{<&#47;li>
<li class="alt">lastActive&nbsp;=&nbsp;isActive;<&#47;li>
<li>lastPos&nbsp;=&nbsp;trans.localPosition;<&#47;li>
<li class="alt">lastRot&nbsp;=&nbsp;trans.localRotation;<&#47;li>
<li>lastScale&nbsp;=&nbsp;trans.localScale;<&#47;li>
<li class="alt"><span class="keyword">return<&#47;span>&nbsp;<span class="keyword">true<&#47;span>;<&#47;li>
<li>}<&#47;li>
<li class="alt"><span class="preprocessor">#else<&#47;span><&#47;li>
<li><span class="keyword">if<&#47;span>&nbsp;(widget&nbsp;!=&nbsp;<span class="keyword">null<&#47;span>&nbsp;&amp;amp;&amp;amp;&nbsp;widget.finalAlpha&nbsp;!=&nbsp;mLastAlpha)<&#47;li>
<li class="alt">{<&#47;li>
<li>mLastAlpha&nbsp;=&nbsp;widget.finalAlpha;<&#47;li>
<li class="alt">trans.hasChanged&nbsp;=&nbsp;<span class="keyword">false<&#47;span>;<&#47;li>
<li><span class="keyword">return<&#47;span>&nbsp;<span class="keyword">true<&#47;span>;<&#47;li>
<li class="alt">}<&#47;li>
<li><span class="keyword">else<&#47;span>&nbsp;<span class="keyword">if<&#47;span>&nbsp;(trans.hasChanged)<&#47;li>
<li class="alt">{<&#47;li>
<li>trans.hasChanged&nbsp;=&nbsp;<span class="keyword">false<&#47;span>;<&#47;li>
<li class="alt"><span class="keyword">return<&#47;span>&nbsp;<span class="keyword">true<&#47;span>;<&#47;li>
<li>}<&#47;li>
<li class="alt"><span class="preprocessor">#endif<&#47;span><&#47;li>
<li><span class="keyword">return<&#47;span>&nbsp;<span class="keyword">false<&#47;span>;<&#47;li>
<li class="alt">}<&#47;li><br />
<&#47;ol><br />
<&#47;div><br />
接着，来看UIDrawCall，它是被NGUI隐藏起来的类。他的内部变量来看看：</p>
<div class="dp-highlighter">
<div class="bar"><&#47;div></p>
<ol class="dp-c" start="1">
<li class="alt">Transform&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mTrans;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">&#47;&#47;坐标转换类<&#47;span><&#47;li>
<li>Material&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSharedMat;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">&#47;&#47;&nbsp;渲染材质<&#47;span><&#47;li>
<li class="alt">Mesh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mMesh0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">&#47;&#47;首个MESH<&#47;span><&#47;li>
<li>Mesh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mMesh1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">&#47;&#47;用于更换的Mesh<&#47;span><&#47;li>
<li class="alt">MeshFilter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mFilter;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">&#47;&#47;绘制的MeshFilter<&#47;span><&#47;li>
<li>MeshRenderer&nbsp;&nbsp;&nbsp;&nbsp;mRen;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">&#47;&#47;渲染MeshRender组件<&#47;span><&#47;li>
<li class="alt">Clipping&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mClipping;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">&#47;&#47;裁剪类型<&#47;span><&#47;li>
<li>Vector4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mClipRange;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">&#47;&#47;裁剪范围<&#47;span><&#47;li>
<li class="alt">Vector2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mClipSoft;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">&#47;&#47;裁剪缓冲方位<&#47;span><&#47;li>
<li>Material&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mMat;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">&#47;&#47;实例化材质<&#47;span><&#47;li>
<li class="alt"><span class="keyword">int<&#47;span>[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mIndices;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">&#47;&#47;做为Mesh三角型索引点<&#47;span><&#47;li><br />
<&#47;ol><br />
<&#47;div><br />
由这些内部变量可知，UIDrawCall是负责NGUI的最重要的渲染类。他制造Mesh制造Material，设置裁剪范围，为NGUI提供渲染底层。</p>
<p>他最重要的方法是：</p>
<div class="dp-highlighter">
<div class="bar"><&#47;div></p>
<ol class="dp-c" start="1">
<li class="alt"><span class="keyword">public<&#47;span>&nbsp;<span class="keyword">void<&#47;span>&nbsp;Set&nbsp;(BetterList&amp;lt;Vector3&amp;gt;&nbsp;verts,&nbsp;BetterList&amp;lt;Vector3&amp;gt;&nbsp;norms,&nbsp;BetterList&amp;lt;Vector4&amp;gt;&nbsp;tans,&nbsp;BetterList&amp;lt;Vector2&amp;gt;&nbsp;uvs,&nbsp;BetterList&amp;lt;Color32&amp;gt;&nbsp;cols)<&#47;li>
<li>{<&#47;li>
<li class="alt"><span class="keyword">int<&#47;span>&nbsp;count&nbsp;=&nbsp;verts.size;<&#47;li>
<li><&#47;li>
<li class="alt"><span class="comment">&#47;&#47;&nbsp;Safety&nbsp;check&nbsp;to&nbsp;ensure&nbsp;we&nbsp;get&nbsp;valid&nbsp;values<&#47;span><&#47;li>
<li><span class="keyword">if<&#47;span>&nbsp;(count&nbsp;&amp;gt;&nbsp;0&nbsp;&amp;amp;&amp;amp;&nbsp;(count&nbsp;==&nbsp;uvs.size&nbsp;&amp;amp;&amp;amp;&nbsp;count&nbsp;==&nbsp;cols.size)&nbsp;&amp;amp;&amp;amp;&nbsp;(count&nbsp;%&nbsp;4)&nbsp;==&nbsp;0)<&#47;li>
<li class="alt">{<&#47;li>
<li><span class="comment">&#47;&#47;&nbsp;Cache&nbsp;all&nbsp;components<&#47;span><&#47;li>
<li class="alt"><span class="keyword">if<&#47;span>&nbsp;(mFilter&nbsp;==&nbsp;<span class="keyword">null<&#47;span>)&nbsp;mFilter&nbsp;=&nbsp;gameObject.GetComponent&amp;lt;MeshFilter&amp;gt;();<&#47;li>
<li><span class="keyword">if<&#47;span>&nbsp;(mFilter&nbsp;==&nbsp;<span class="keyword">null<&#47;span>)&nbsp;mFilter&nbsp;=&nbsp;gameObject.AddComponent&amp;lt;MeshFilter&amp;gt;();<&#47;li>
<li class="alt"><span class="keyword">if<&#47;span>&nbsp;(mRen&nbsp;==&nbsp;<span class="keyword">null<&#47;span>)&nbsp;mRen&nbsp;=&nbsp;gameObject.GetComponent&amp;lt;MeshRenderer&amp;gt;();<&#47;li>
<li><&#47;li>
<li class="alt"><span class="keyword">if<&#47;span>&nbsp;(mRen&nbsp;==&nbsp;<span class="keyword">null<&#47;span>)<&#47;li>
<li>{<&#47;li>
<li class="alt">mRen&nbsp;=&nbsp;gameObject.AddComponent&amp;lt;MeshRenderer&amp;gt;();<&#47;li>
<li><span class="preprocessor">#if&nbsp;UNITY_EDITOR<&#47;span><&#47;li>
<li class="alt">mRen.enabled&nbsp;=&nbsp;isActive;<&#47;li>
<li><span class="preprocessor">#endif<&#47;span><&#47;li>
<li class="alt">UpdateMaterials();<&#47;li>
<li>}<&#47;li>
<li class="alt"><span class="keyword">else<&#47;span>&nbsp;<span class="keyword">if<&#47;span>&nbsp;(mMat&nbsp;!=&nbsp;<span class="keyword">null<&#47;span>&nbsp;&amp;amp;&amp;amp;&nbsp;mMat.mainTexture&nbsp;!=&nbsp;mSharedMat.mainTexture)<&#47;li>
<li>{<&#47;li>
<li class="alt">UpdateMaterials();<&#47;li>
<li>}<&#47;li>
<li class="alt"><&#47;li>
<li><span class="keyword">if<&#47;span>&nbsp;(verts.size&nbsp;&amp;lt;&nbsp;65000)<&#47;li>
<li class="alt">{<&#47;li>
<li><span class="keyword">int<&#47;span>&nbsp;indexCount&nbsp;=&nbsp;(count&nbsp;&amp;gt;&amp;gt;&nbsp;1)&nbsp;*&nbsp;3;<&#47;li>
<li class="alt"><span class="keyword">bool<&#47;span>&nbsp;rebuildIndices&nbsp;=&nbsp;(mIndices&nbsp;==&nbsp;<span class="keyword">null<&#47;span>&nbsp;||&nbsp;mIndices.Length&nbsp;!=&nbsp;indexCount);<&#47;li>
<li><&#47;li>
<li class="alt"><span class="comment">&#47;&#47;&nbsp;Populate&nbsp;the&nbsp;index&nbsp;buffer<&#47;span><&#47;li>
<li><span class="keyword">if<&#47;span>&nbsp;(rebuildIndices)<&#47;li>
<li class="alt">{<&#47;li>
<li><span class="comment">&#47;&#47;&nbsp;It&nbsp;takes&nbsp;6&nbsp;indices&nbsp;to&nbsp;draw&nbsp;a&nbsp;quad&nbsp;of&nbsp;4&nbsp;vertices<&#47;span><&#47;li>
<li class="alt">mIndices&nbsp;=&nbsp;<span class="keyword">new<&#47;span>&nbsp;<span class="keyword">int<&#47;span>[indexCount];<&#47;li>
<li><span class="keyword">int<&#47;span>&nbsp;index&nbsp;=&nbsp;0;<&#47;li>
<li class="alt"><&#47;li>
<li><span class="keyword">for<&#47;span>&nbsp;(<span class="keyword">int<&#47;span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&amp;lt;&nbsp;count;&nbsp;i&nbsp;+=&nbsp;4)<&#47;li>
<li class="alt">{<&#47;li>
<li>mIndices[index++]&nbsp;=&nbsp;i;<&#47;li>
<li class="alt">mIndices[index++]&nbsp;=&nbsp;i&nbsp;+&nbsp;1;<&#47;li>
<li>mIndices[index++]&nbsp;=&nbsp;i&nbsp;+&nbsp;2;<&#47;li>
<li class="alt"><&#47;li>
<li>mIndices[index++]&nbsp;=&nbsp;i&nbsp;+&nbsp;2;<&#47;li>
<li class="alt">mIndices[index++]&nbsp;=&nbsp;i&nbsp;+&nbsp;3;<&#47;li>
<li>mIndices[index++]&nbsp;=&nbsp;i;<&#47;li>
<li class="alt">}<&#47;li>
<li>}<&#47;li>
<li class="alt"><&#47;li>
<li><span class="comment">&#47;&#47;&nbsp;Set&nbsp;the&nbsp;mesh&nbsp;values<&#47;span><&#47;li>
<li class="alt">Mesh&nbsp;mesh&nbsp;=&nbsp;GetMesh(<span class="keyword">ref<&#47;span>&nbsp;rebuildIndices,&nbsp;verts.size);<&#47;li>
<li>mesh.vertices&nbsp;=&nbsp;verts.ToArray();<&#47;li>
<li class="alt"><span class="keyword">if<&#47;span>&nbsp;(norms&nbsp;!=&nbsp;<span class="keyword">null<&#47;span>)&nbsp;mesh.normals&nbsp;=&nbsp;norms.ToArray();<&#47;li>
<li><span class="keyword">if<&#47;span>&nbsp;(tans&nbsp;!=&nbsp;<span class="keyword">null<&#47;span>)&nbsp;mesh.tangents&nbsp;=&nbsp;tans.ToArray();<&#47;li>
<li class="alt">mesh.uv&nbsp;=&nbsp;uvs.ToArray();<&#47;li>
<li>mesh.colors32&nbsp;=&nbsp;cols.ToArray();<&#47;li>
<li class="alt"><span class="keyword">if<&#47;span>&nbsp;(rebuildIndices)&nbsp;mesh.triangles&nbsp;=&nbsp;mIndices;<&#47;li>
<li>mesh.RecalculateBounds();<&#47;li>
<li class="alt">mFilter.mesh&nbsp;=&nbsp;mesh;<&#47;li>
<li>}<&#47;li>
<li class="alt"><span class="keyword">else<&#47;span><&#47;li>
<li>{<&#47;li>
<li class="alt"><span class="keyword">if<&#47;span>&nbsp;(mFilter.mesh&nbsp;!=&nbsp;<span class="keyword">null<&#47;span>)&nbsp;mFilter.mesh.Clear();<&#47;li>
<li>Debug.LogError(<span class="string">"Too&nbsp;many&nbsp;vertices&nbsp;on&nbsp;one&nbsp;panel:&nbsp;"<&#47;span>&nbsp;+&nbsp;verts.size);<&#47;li>
<li class="alt">}<&#47;li>
<li>}<&#47;li>
<li class="alt"><span class="keyword">else<&#47;span><&#47;li>
<li>{<&#47;li>
<li class="alt"><span class="keyword">if<&#47;span>&nbsp;(mFilter.mesh&nbsp;!=&nbsp;<span class="keyword">null<&#47;span>)&nbsp;mFilter.mesh.Clear();<&#47;li>
<li>Debug.LogError(<span class="string">"UIWidgets&nbsp;must&nbsp;fill&nbsp;the&nbsp;buffer&nbsp;with&nbsp;4&nbsp;vertices&nbsp;per&nbsp;quad.&nbsp;Found&nbsp;"<&#47;span>&nbsp;+&nbsp;count);<&#47;li>
<li class="alt">}<&#47;li>
<li>}<&#47;li><br />
<&#47;ol><br />
<&#47;div><br />
在这个方法里，它制造Mesh,MeshFilter,MeshRender,Materials。</p>
<p>&nbsp;</p>
<p><span style="background-color: #ffff00;">最后，我们来说说最重要的UI渲染入口UIPanel。<&#47;span></p>
<p><span style="background-color: #ffff00;">&nbsp;&nbsp;&nbsp; UIPanel的渲染步骤：<&#47;span></p>
<p><span style="background-color: #ffff00;">&nbsp;&nbsp;&nbsp; 1.当有任何形式的UI组件启动渲染时加入UIPanel的渲染队列，当有新的渲染组件需要有新的UIDrawCall时，进行生成新的UIDrawCall.<&#47;span></p>
<p><span style="background-color: #ffff00;">&nbsp;&nbsp;&nbsp; 2.对所有UIPanel的渲染队列进行检查，是否队列中渲染组件需要重新渲染，包括位移，缩放，更改图片，启用，关闭.<&#47;span></p>
<p><span style="background-color: #ffff00;">&nbsp;&nbsp;&nbsp; 3.获取渲染组件对应的UIDrawCall，更新Mesh,贴图,UV，位置，大小<&#47;span></p>
<p><span style="background-color: #ffff00;">&nbsp;&nbsp;&nbsp; 4.对需要更新的UIDrawCall进行重新渲染<&#47;span></p>
<p><span style="background-color: #ffff00;">&nbsp;&nbsp;&nbsp; 5.最后标记已经渲染的渲染组件，告诉他们已经渲染，为下次判断更新做好准备。删除不再需要渲染的UIDrawCall，销毁渲染冗余。<&#47;span></p>
<p><span style="background-color: #ffff00;">&nbsp;&nbsp;&nbsp; 注意：所有的渲染都是在LateUpdate下进行，也就是它是进行的延迟渲染。<&#47;span></p>
<p>接口源码：</p>
<div class="dp-highlighter">
<div class="bar"><&#47;div></p>
<ol class="dp-c" start="1">
<li class="alt"><span class="keyword">void<&#47;span>&nbsp;LateUpdate&nbsp;()<&#47;li>
<li>{<&#47;li>
<li class="alt"><span class="comment">&#47;&#47;&nbsp;Only&nbsp;the&nbsp;very&nbsp;first&nbsp;panel&nbsp;should&nbsp;be&nbsp;doing&nbsp;the&nbsp;update&nbsp;logic<&#47;span><&#47;li>
<li><span class="keyword">if<&#47;span>&nbsp;(list[0]&nbsp;!=&nbsp;<span class="keyword">this<&#47;span>)&nbsp;<span class="keyword">return<&#47;span>;<&#47;li>
<li class="alt"><&#47;li>
<li><span class="comment">&#47;&#47;&nbsp;Update&nbsp;all&nbsp;panels<&#47;span><&#47;li>
<li class="alt"><span class="keyword">for<&#47;span>&nbsp;(<span class="keyword">int<&#47;span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&amp;lt;&nbsp;list.size;&nbsp;++i)<&#47;li>
<li>{<&#47;li>
<li class="alt">UIPanel&nbsp;panel&nbsp;=&nbsp;list[i];<&#47;li>
<li>panel.mUpdateTime&nbsp;=&nbsp;RealTime.time;<&#47;li>
<li class="alt">panel.UpdateTransformMatrix();<&#47;li>
<li>panel.UpdateLayers();<&#47;li>
<li class="alt">panel.UpdateWidgets();<&#47;li>
<li>}<&#47;li>
<li class="alt"><&#47;li>
<li><span class="comment">&#47;&#47;&nbsp;Fill&nbsp;the&nbsp;draw&nbsp;calls&nbsp;for&nbsp;all&nbsp;of&nbsp;the&nbsp;changed&nbsp;materials<&#47;span><&#47;li>
<li class="alt"><span class="keyword">if<&#47;span>&nbsp;(mFullRebuild)<&#47;li>
<li>{<&#47;li>
<li class="alt">UIWidget.list.Sort(UIWidget.CompareFunc);<&#47;li>
<li>Fill();<&#47;li>
<li class="alt">}<&#47;li>
<li><span class="keyword">else<&#47;span><&#47;li>
<li class="alt">{<&#47;li>
<li><span class="keyword">for<&#47;span>&nbsp;(<span class="keyword">int<&#47;span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&amp;lt;&nbsp;UIDrawCall.list.size;&nbsp;)<&#47;li>
<li class="alt">{<&#47;li>
<li>UIDrawCall&nbsp;dc&nbsp;=&nbsp;UIDrawCall.list[i];<&#47;li>
<li class="alt"><&#47;li>
<li><span class="keyword">if<&#47;span>&nbsp;(dc.isDirty)<&#47;li>
<li class="alt">{<&#47;li>
<li><span class="keyword">if<&#47;span>&nbsp;(!Fill(dc))<&#47;li>
<li class="alt">{<&#47;li>
<li>DestroyDrawCall(dc,&nbsp;i);<&#47;li>
<li class="alt"><span class="keyword">continue<&#47;span>;<&#47;li>
<li>}<&#47;li>
<li class="alt">}<&#47;li>
<li>++i;<&#47;li>
<li class="alt">}<&#47;li>
<li>}<&#47;li>
<li class="alt"><&#47;li>
<li><span class="comment">&#47;&#47;&nbsp;Update&nbsp;the&nbsp;clipping&nbsp;rects<&#47;span><&#47;li>
<li class="alt"><span class="keyword">for<&#47;span>&nbsp;(<span class="keyword">int<&#47;span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&amp;lt;&nbsp;list.size;&nbsp;++i)<&#47;li>
<li>{<&#47;li>
<li class="alt">UIPanel&nbsp;panel&nbsp;=&nbsp;list[i];<&#47;li>
<li>panel.UpdateDrawcalls();<&#47;li>
<li class="alt">}<&#47;li>
<li>mFullRebuild&nbsp;=&nbsp;<span class="keyword">false<&#47;span>;<&#47;li>
<li class="alt">}<&#47;li><br />
<&#47;ol><br />
<&#47;div><br />
Fill()接口源码：</p>
<div class="dp-highlighter">
<div class="bar"><&#47;div></p>
<ol class="dp-c" start="1">
<li class="alt"><span class="comment">&#47;&#47;&#47;&nbsp;&amp;lt;summary&amp;gt;<&#47;span><&#47;li>
<li><span class="comment">&#47;&#47;&#47;&nbsp;Fill&nbsp;the&nbsp;geometry&nbsp;fully,&nbsp;processing&nbsp;all&nbsp;widgets&nbsp;and&nbsp;re-creating&nbsp;all&nbsp;draw&nbsp;calls.<&#47;span><&#47;li>
<li class="alt"><span class="comment">&#47;&#47;&#47;&nbsp;&amp;lt;&#47;summary&amp;gt;<&#47;span><&#47;li>
<li><&#47;li>
<li class="alt"><span class="keyword">static<&#47;span>&nbsp;<span class="keyword">void<&#47;span>&nbsp;Fill&nbsp;()<&#47;li>
<li>{<&#47;li>
<li class="alt"><span class="keyword">for<&#47;span>&nbsp;(<span class="keyword">int<&#47;span>&nbsp;i&nbsp;=&nbsp;UIDrawCall.list.size;&nbsp;i&nbsp;&amp;gt;&nbsp;0;&nbsp;)<&#47;li>
<li>DestroyDrawCall(UIDrawCall.list[--i],&nbsp;i);<&#47;li>
<li class="alt"><&#47;li>
<li><span class="keyword">int<&#47;span>&nbsp;index&nbsp;=&nbsp;0;<&#47;li>
<li class="alt">UIPanel&nbsp;pan&nbsp;=&nbsp;<span class="keyword">null<&#47;span>;<&#47;li>
<li>Material&nbsp;mat&nbsp;=&nbsp;<span class="keyword">null<&#47;span>;<&#47;li>
<li class="alt">UIDrawCall&nbsp;dc&nbsp;=&nbsp;<span class="keyword">null<&#47;span>;<&#47;li>
<li><&#47;li>
<li class="alt"><span class="keyword">for<&#47;span>&nbsp;(<span class="keyword">int<&#47;span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&amp;lt;&nbsp;UIWidget.list.size;&nbsp;)<&#47;li>
<li>{<&#47;li>
<li class="alt">UIWidget&nbsp;w&nbsp;=&nbsp;UIWidget.list[i];<&#47;li>
<li><&#47;li>
<li class="alt"><span class="keyword">if<&#47;span>&nbsp;(w&nbsp;==&nbsp;<span class="keyword">null<&#47;span>)<&#47;li>
<li>{<&#47;li>
<li class="alt">UIWidget.list.RemoveAt(i);<&#47;li>
<li><span class="keyword">continue<&#47;span>;<&#47;li>
<li class="alt">}<&#47;li>
<li><&#47;li>
<li class="alt"><span class="keyword">if<&#47;span>&nbsp;(w.isVisible&nbsp;&amp;amp;&amp;amp;&nbsp;w.hasVertices)<&#47;li>
<li>{<&#47;li>
<li class="alt"><span class="keyword">if<&#47;span>&nbsp;(pan&nbsp;!=&nbsp;w.panel&nbsp;||&nbsp;mat&nbsp;!=&nbsp;w.material)<&#47;li>
<li>{<&#47;li>
<li class="alt"><span class="keyword">if<&#47;span>&nbsp;(pan&nbsp;!=&nbsp;<span class="keyword">null<&#47;span>&nbsp;&amp;amp;&amp;amp;&nbsp;mat&nbsp;!=&nbsp;<span class="keyword">null<&#47;span>&nbsp;&amp;amp;&amp;amp;&nbsp;mVerts.size&nbsp;!=&nbsp;0)<&#47;li>
<li>{<&#47;li>
<li class="alt">pan.SubmitDrawCall(dc);<&#47;li>
<li>dc&nbsp;=&nbsp;<span class="keyword">null<&#47;span>;<&#47;li>
<li class="alt">}<&#47;li>
<li><&#47;li>
<li class="alt">pan&nbsp;=&nbsp;w.panel;<&#47;li>
<li>mat&nbsp;=&nbsp;w.material;<&#47;li>
<li class="alt">}<&#47;li>
<li><&#47;li>
<li class="alt"><span class="keyword">if<&#47;span>&nbsp;(pan&nbsp;!=&nbsp;<span class="keyword">null<&#47;span>&nbsp;&amp;amp;&amp;amp;&nbsp;mat&nbsp;!=&nbsp;<span class="keyword">null<&#47;span>)<&#47;li>
<li>{<&#47;li>
<li class="alt"><span class="keyword">if<&#47;span>&nbsp;(dc&nbsp;==&nbsp;<span class="keyword">null<&#47;span>)&nbsp;dc&nbsp;=&nbsp;pan.GetDrawCall(index++,&nbsp;mat);<&#47;li>
<li>w.drawCall&nbsp;=&nbsp;dc;<&#47;li>
<li class="alt"><span class="keyword">if<&#47;span>&nbsp;(pan.generateNormals)&nbsp;w.WriteToBuffers(mVerts,&nbsp;mUvs,&nbsp;mCols,&nbsp;mNorms,&nbsp;mTans);<&#47;li>
<li><span class="keyword">else<&#47;span>&nbsp;w.WriteToBuffers(mVerts,&nbsp;mUvs,&nbsp;mCols,&nbsp;<span class="keyword">null<&#47;span>,&nbsp;<span class="keyword">null<&#47;span>);<&#47;li>
<li class="alt">}<&#47;li>
<li>}<&#47;li>
<li class="alt"><span class="keyword">else<&#47;span>&nbsp;w.drawCall&nbsp;=&nbsp;<span class="keyword">null<&#47;span>;<&#47;li>
<li>++i;<&#47;li>
<li class="alt">}<&#47;li>
<li><&#47;li>
<li class="alt"><span class="keyword">if<&#47;span>&nbsp;(mVerts.size&nbsp;!=&nbsp;0)<&#47;li>
<li>pan.SubmitDrawCall(dc);<&#47;li>
<li class="alt">}<&#47;li><br />
<&#47;ol><br />
<&#47;div><br />
转载请注明出处：http:&#47;&#47;www.luzexi.com</p>
