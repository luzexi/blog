<!DOCTYPE html><html lang="en" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title> 《Unity3D高级编程之进阶主程》第四章，UI(三) - 剖析UGUI源码中的输入与事件模块 - 技术人生</title><link rel="shortcut icon" href="/public/favicon.ico"><link rel="alternate" type="application/atom+xml" title="技术人生" href="/atom.xml"><link rel="alternate" type="application/json" title="技术人生" href="http://www.luzexi.com/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /><style> *,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0;padding:0}body{font-family:STHeiti, system-ui, sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.5;font-size:1rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}code,pre{background:#ecedee}code{padding:.1rem}pre code{border:none}pre{padding:1rem;overflow-x:auto}img{max-width:100%}hr{background:#000;height:1px;border:0}header{flex-basis:12rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{font-style:italic;border-left:5px solid #ececec;padding-left:1rem}h1,h2,h3,h4,h5{line-height:1;margin:1rem 0;font-weight:600}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:0.5rem}.posts ul,header ul{list-style:none}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}main{display:flex;flex-wrap:wrap;max-width:60rem;margin:2rem auto;padding:1rem}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:0.5rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}figcaption{font-size:smaller}</style></head><body><main role="main"><header role="banner"> <!--<h1 class="logo">技术人生</h1>--><nav role="navigation"><ul><li><a href="/" >主页</a></li><li><a href="/about" >关于我</a></li><li><a href="/search" >文章搜索</a></li><li><a href="/tag/书籍著作/" >书籍著作</a></li><li><a href="/tag/Unity3D/" >Unity3D</a></li><li><a href="/tag/游戏通用模块/" >游戏通用模块</a></li><li><a href="/tag/前端技术/" >前端技术</a></li><li><a href="/tag/后端技术/" >后端技术</a></li><li><a href="/tag/其他技术/" >其他技术</a></li><li><a href="/tag/金融投资/" >金融投资</a></li><li><a href="/tag/life/" >思路探讨</a></li><li><a href="/tag/英文文章/" >英文文章</a></li><li><a href="/tag/读书笔记/" >读书笔记</a></li><li><a href="/engineer-shopping" >成长必需品</a></li><li><a href="/friendlink" >友情链接</a></li><li><a href="/atom.xml" >Rss</a></li><li><a href="https://github.com/luzexi" >GitHub</a></li></ul></nav></header><section class="post"><h2>《Unity3D高级编程之进阶主程》第四章，UI(三) - 剖析UGUI源码中的输入与事件模块</h2><p>前面几节对 NGUI 和 UGUI 进行了比较，也阐述了一些UGUI的组件的用途和原理，不过这些都仅仅只是停留在系统的表面，对系统深层次的原理和实现方式我们并不了解，接下来我们就从 UGUI 的源码入手，逐步为揭开它的神秘面纱。</p><p>===</p><p>在了解整个 UGUI 源码之前，我们在此篇来从输入事件下手，对 UGUI 源码中输入事件模块进行剖析。</p><h3>UGUI源码剖析</h3><p>UGUI的源码是Unity3D官方公开的，这里我们来剖析的是 UGUI 在 Unity2017 中的公开源码。</p><p><img src="/assets/book/4/ugui1.png" alt="ugui文件夹"></p><p>上图为 UGUI 内核源码的文件夹结构图。它把UGUI分成了三块，输入事件，动画，核心渲染。</p><p>其中动画部分相对比较简单，用了tween补间动画的形式，对颜色，位置，大小做了渐进的操作。tween的原理是在启动一个协程，在协程里对元素的属性渐进式的修改，除了修改属性数值，tween还有多种曲线可以选择，比如内番曲线，外翻曲线等，一个数值从起点到终点的过程可以由曲线来控制。举个例子，数字从 0 到 100 的变化，在3秒里完成，如果是线性的话，则在第2秒时的数值，应该是</p><div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    (100 - 0) * (2f/3f) = 200f/3f = 66.666
</code></pre></div><p>而如果使用内番曲线就不是这个结果了，不过它们最终都会到达100，只是过程有点‘曲折’罢了，曲线也体现了动画的‘有趣’。</p><p>下面我们重点来剖析下输入事件和核心渲染这两块。</p><h3>输入事件源码</h3><p>输入事件源码的文件结构图如下：</p><p><img src="/assets/book/4/ugui2.png" alt="ugui事件文件夹结构"></p><p>图中，UGUI 把输入事件模块有四部分，事件数据模块，输入事件捕获模块，射线碰撞检测模块，事件逻辑处理及回调模块。我们把每部分的核心源码都拉出来分析一下。</p><h6>事件数据模块</h6><p>事件数据模块部分对整个事件系统的作用来说，它主要定义并且存储了事件发生时的位置、和事件对应的物体，事件的位移大小，触发事件的输入类型，以及事件的设备信息等。事件数据模块在逻辑上没有做过多的内容，而主要为了获取数据，提供数据服务。</p><p>它有三个类 PointerEventData、AxisEventData、BaseEventData，分别为点位事件数据类，滚轮事件数据类，事件基础数据类。PointerEventData和AxisEventData 继承自 BaseEventData，且 AxisEventData 的代码量非常少，因为它只需要提供滚轮的方向信息。即如下:</p><div class="highlight"><pre><code class="language-c#" data-lang="c#"><span></span><span class="k">namespace</span> <span class="nn">UnityEngine.EventSystems</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">AxisEventData</span> <span class="p">:</span> <span class="n">BaseEventData</span>
    <span class="p">{</span>
        <span class="c1">//移动方向</span>
        <span class="k">public</span> <span class="n">Vector2</span> <span class="n">moveVector</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">public</span> <span class="n">MoveDirection</span> <span class="n">moveDir</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">public</span> <span class="nf">AxisEventData</span><span class="p">(</span><span class="n">EventSystem</span> <span class="n">eventSystem</span><span class="p">)</span>
            <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">eventSystem</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">moveVector</span> <span class="p">=</span> <span class="n">Vector2</span><span class="p">.</span><span class="n">zero</span><span class="p">;</span>
            <span class="n">moveDir</span> <span class="p">=</span> <span class="n">MoveDirection</span><span class="p">.</span><span class="n">None</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>BaseEventData 定义了几个常用的接口，其子类 PointerEventData 是最常用的事件数据，我们来看看它是如何编写的，代码量并不多基本全是数据定义:</p><div class="highlight"><pre><code class="language-c#" data-lang="c#"><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">PointerEventData</span> <span class="p">:</span> <span class="n">BaseEventData</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">GameObject</span> <span class="n">pointerEnter</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// 接收OnPointerDown事件的物体</span>
    <span class="k">private</span> <span class="n">GameObject</span> <span class="n">m_PointerPress</span><span class="p">;</span>
    <span class="c1">// 上一下接收OnPointerDown事件的物体</span>
    <span class="k">public</span> <span class="n">GameObject</span> <span class="n">lastPress</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// 接收按下事件的无法响应处理的物体</span>
    <span class="k">public</span> <span class="n">GameObject</span> <span class="n">rawPointerPress</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// 接收OnDrag事件的物体</span>
    <span class="k">public</span> <span class="n">GameObject</span> <span class="n">pointerDrag</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="n">RaycastResult</span> <span class="n">pointerCurrentRaycast</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">RaycastResult</span> <span class="n">pointerPressRaycast</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">GameObject</span><span class="p">&gt;</span> <span class="n">hovered</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">GameObject</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">eligibleForClick</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="kt">int</span> <span class="n">pointerId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// 鼠标或触摸时的点位</span>
    <span class="k">public</span> <span class="n">Vector2</span> <span class="n">position</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// 滚轮的移速</span>
    <span class="k">public</span> <span class="n">Vector2</span> <span class="n">delta</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// 按下时的点位</span>
    <span class="k">public</span> <span class="n">Vector2</span> <span class="n">pressPosition</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// 为双击服务的上次点击时间</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">clickTime</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// 为双击服务的点击次数</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">clickCount</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="n">Vector2</span> <span class="n">scrollDelta</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="n">useDragThreshold</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="n">dragging</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="n">InputButton</span> <span class="n">button</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>上述代码中为数据类的核心类 PointerEventData，它存储了大部分的事件系统逻辑需要的数据，包括按下时的位置，松开与按下的时间差，拖动的位移差，点击到的物体等等，承载了所有输入事件需要的数据。事件数据模块的意义所在便是存储数据并为逻辑部分做好准备。</p><h6>事件数据模块，主要作用为在各种事件发生时，为事件逻辑做好数据工作。</h6><h3>输入事件捕获模块源码</h3><div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>缺图UGUI的时间捕获模块文件夹结构
</code></pre></div><p>输入事件捕获模块由四个类组成，BaseInputModule，PointerInputModule，StandaloneInputModule，TouchInputModule。</p><p>BaseInputModule 是抽象(abstract)基类，提供必须的空接口和基本变量。</p><p>PointerInputModule 继承了BaseInputModule，并且在他基础上扩展了关于点位的输入逻辑，也增加了输入的类型和状态。</p><p>StandaloneInputModule 和 TouchInputModule 又继承了 PointerInputModule，它们从父类开始延展向不同的方向。</p><p>StandaloneInputModule 向标准键盘鼠标输入方向拓展，而 TouchInputModule 向触控板输入方向拓展。</p><p>下面我们来看看他们的核心部分的代码：</p><div class="highlight"><pre><code class="language-c#" data-lang="c#"><span></span><span class="c1">/// &lt;summary&gt;</span>
<span class="c1">/// 处理所有的鼠标事件</span>
<span class="c1">/// &lt;/summary&gt;</span>
<span class="k">protected</span> <span class="k">void</span> <span class="nf">ProcessMouseEvent</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">mouseData</span> <span class="p">=</span> <span class="n">GetMousePointerEventData</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">leftButtonData</span> <span class="p">=</span> <span class="n">mouseData</span><span class="p">.</span><span class="n">GetButtonState</span><span class="p">(</span><span class="n">PointerEventData</span><span class="p">.</span><span class="n">InputButton</span><span class="p">.</span><span class="n">Left</span><span class="p">).</span><span class="n">eventData</span><span class="p">;</span>

    <span class="c1">// Process the first mouse button fully</span>
    <span class="c1">// 处理鼠标左键相关的事件</span>
    <span class="n">ProcessMousePress</span><span class="p">(</span><span class="n">leftButtonData</span><span class="p">);</span>
    <span class="n">ProcessMove</span><span class="p">(</span><span class="n">leftButtonData</span><span class="p">.</span><span class="n">buttonData</span><span class="p">);</span>
    <span class="n">ProcessDrag</span><span class="p">(</span><span class="n">leftButtonData</span><span class="p">.</span><span class="n">buttonData</span><span class="p">);</span>

    <span class="c1">// Now process right / middle clicks</span>
    <span class="c1">// 处理鼠标右键和中建的点击事件</span>
    <span class="n">ProcessMousePress</span><span class="p">(</span><span class="n">mouseData</span><span class="p">.</span><span class="n">GetButtonState</span><span class="p">(</span><span class="n">PointerEventData</span><span class="p">.</span><span class="n">InputButton</span><span class="p">.</span><span class="n">Right</span><span class="p">).</span><span class="n">eventData</span><span class="p">);</span>
    <span class="n">ProcessDrag</span><span class="p">(</span><span class="n">mouseData</span><span class="p">.</span><span class="n">GetButtonState</span><span class="p">(</span><span class="n">PointerEventData</span><span class="p">.</span><span class="n">InputButton</span><span class="p">.</span><span class="n">Right</span><span class="p">).</span><span class="n">eventData</span><span class="p">.</span><span class="n">buttonData</span><span class="p">);</span>
    <span class="n">ProcessMousePress</span><span class="p">(</span><span class="n">mouseData</span><span class="p">.</span><span class="n">GetButtonState</span><span class="p">(</span><span class="n">PointerEventData</span><span class="p">.</span><span class="n">InputButton</span><span class="p">.</span><span class="n">Middle</span><span class="p">).</span><span class="n">eventData</span><span class="p">);</span>
    <span class="n">ProcessDrag</span><span class="p">(</span><span class="n">mouseData</span><span class="p">.</span><span class="n">GetButtonState</span><span class="p">(</span><span class="n">PointerEventData</span><span class="p">.</span><span class="n">InputButton</span><span class="p">.</span><span class="n">Middle</span><span class="p">).</span><span class="n">eventData</span><span class="p">.</span><span class="n">buttonData</span><span class="p">);</span>

    <span class="c1">//滚轮事件处理</span>
    <span class="k">if</span> <span class="p">(!</span><span class="n">Mathf</span><span class="p">.</span><span class="n">Approximately</span><span class="p">(</span><span class="n">leftButtonData</span><span class="p">.</span><span class="n">buttonData</span><span class="p">.</span><span class="n">scrollDelta</span><span class="p">.</span><span class="n">sqrMagnitude</span><span class="p">,</span> <span class="m">0.0f</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">scrollHandler</span> <span class="p">=</span> <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">GetEventHandler</span><span class="p">&lt;</span><span class="n">IScrollHandler</span><span class="p">&gt;(</span><span class="n">leftButtonData</span><span class="p">.</span><span class="n">buttonData</span><span class="p">.</span><span class="n">pointerCurrentRaycast</span><span class="p">.</span><span class="n">gameObject</span><span class="p">);</span>
        <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">ExecuteHierarchy</span><span class="p">(</span><span class="n">scrollHandler</span><span class="p">,</span> <span class="n">leftButtonData</span><span class="p">.</span><span class="n">buttonData</span><span class="p">,</span> <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">scrollHandler</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>以上代码为 StandaloneInputModule 的主函数 ProcessMouseEvent，它从鼠标键盘输入事件上扩展了输入的逻辑，处理了鼠标的按下，移动，滚轮，拖拽的操作事件。其中比较重要的函数为 ProcessMousePress、ProcessMove、ProcessDrag 这三个函数，我们来重点看下他们处理的内容。</p><div class="highlight"><pre><code class="language-c#" data-lang="c#"><span></span><span class="c1">/// &lt;summary&gt;</span>
<span class="c1">/// Process the current mouse press.</span>
<span class="c1">/// 处理鼠标按下事件</span>
<span class="c1">/// &lt;/summary&gt;</span>
<span class="k">protected</span> <span class="k">void</span> <span class="nf">ProcessMousePress</span><span class="p">(</span><span class="n">MouseButtonEventData</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">pointerEvent</span> <span class="p">=</span> <span class="n">data</span><span class="p">.</span><span class="n">buttonData</span><span class="p">;</span>
    <span class="kt">var</span> <span class="n">currentOverGo</span> <span class="p">=</span> <span class="n">pointerEvent</span><span class="p">.</span><span class="n">pointerCurrentRaycast</span><span class="p">.</span><span class="n">gameObject</span><span class="p">;</span>

    <span class="c1">// PointerDown notification</span>
    <span class="c1">// 按下通知</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">PressedThisFrame</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">pointerEvent</span><span class="p">.</span><span class="n">eligibleForClick</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="n">pointerEvent</span><span class="p">.</span><span class="n">delta</span> <span class="p">=</span> <span class="n">Vector2</span><span class="p">.</span><span class="n">zero</span><span class="p">;</span>
        <span class="n">pointerEvent</span><span class="p">.</span><span class="n">dragging</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="n">pointerEvent</span><span class="p">.</span><span class="n">useDragThreshold</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="n">pointerEvent</span><span class="p">.</span><span class="n">pressPosition</span> <span class="p">=</span> <span class="n">pointerEvent</span><span class="p">.</span><span class="n">position</span><span class="p">;</span>
        <span class="n">pointerEvent</span><span class="p">.</span><span class="n">pointerPressRaycast</span> <span class="p">=</span> <span class="n">pointerEvent</span><span class="p">.</span><span class="n">pointerCurrentRaycast</span><span class="p">;</span>

        <span class="n">DeselectIfSelectionChanged</span><span class="p">(</span><span class="n">currentOverGo</span><span class="p">,</span> <span class="n">pointerEvent</span><span class="p">);</span>

        <span class="c1">// 搜索元件中按下事件的句柄，并执行按下事件句柄</span>
        <span class="kt">var</span> <span class="n">newPressed</span> <span class="p">=</span> <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">ExecuteHierarchy</span><span class="p">(</span><span class="n">currentOverGo</span><span class="p">,</span> <span class="n">pointerEvent</span><span class="p">,</span> <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">pointerDownHandler</span><span class="p">);</span>

        <span class="c1">// didnt find a press handler... search for a click handler</span>
        <span class="c1">// 搜索后找不到句柄，就设置一个自己的</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">newPressed</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
            <span class="n">newPressed</span> <span class="p">=</span> <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">GetEventHandler</span><span class="p">&lt;</span><span class="n">IPointerClickHandler</span><span class="p">&gt;(</span><span class="n">currentOverGo</span><span class="p">);</span>

        <span class="c1">// Debug.Log(&quot;Pressed: &quot; + newPressed);</span>

        <span class="kt">float</span> <span class="n">time</span> <span class="p">=</span> <span class="n">Time</span><span class="p">.</span><span class="n">unscaledTime</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">newPressed</span> <span class="p">==</span> <span class="n">pointerEvent</span><span class="p">.</span><span class="n">lastPress</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">diffTime</span> <span class="p">=</span> <span class="n">time</span> <span class="p">-</span> <span class="n">pointerEvent</span><span class="p">.</span><span class="n">clickTime</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">diffTime</span> <span class="p">&lt;</span> <span class="m">0.3f</span><span class="p">)</span>
                <span class="p">++</span><span class="n">pointerEvent</span><span class="p">.</span><span class="n">clickCount</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">pointerEvent</span><span class="p">.</span><span class="n">clickCount</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>

            <span class="n">pointerEvent</span><span class="p">.</span><span class="n">clickTime</span> <span class="p">=</span> <span class="n">time</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">pointerEvent</span><span class="p">.</span><span class="n">clickCount</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">pointerEvent</span><span class="p">.</span><span class="n">pointerPress</span> <span class="p">=</span> <span class="n">newPressed</span><span class="p">;</span>
        <span class="n">pointerEvent</span><span class="p">.</span><span class="n">rawPointerPress</span> <span class="p">=</span> <span class="n">currentOverGo</span><span class="p">;</span>

        <span class="n">pointerEvent</span><span class="p">.</span><span class="n">clickTime</span> <span class="p">=</span> <span class="n">time</span><span class="p">;</span>

        <span class="c1">// Save the drag handler as well</span>
        <span class="c1">// 保存拖拽信息</span>
        <span class="n">pointerEvent</span><span class="p">.</span><span class="n">pointerDrag</span> <span class="p">=</span> <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">GetEventHandler</span><span class="p">&lt;</span><span class="n">IDragHandler</span><span class="p">&gt;(</span><span class="n">currentOverGo</span><span class="p">);</span>

        <span class="c1">// 执行拖拽启动事件句柄</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pointerEvent</span><span class="p">.</span><span class="n">pointerDrag</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
            <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">pointerEvent</span><span class="p">.</span><span class="n">pointerDrag</span><span class="p">,</span> <span class="n">pointerEvent</span><span class="p">,</span> <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">initializePotentialDrag</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// PointerUp notification</span>
    <span class="c1">// 抬起通知</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">ReleasedThisFrame</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="c1">//执行抬起事件的句柄</span>
        <span class="c1">// Debug.Log(&quot;Executing pressup on: &quot; + pointer.pointerPress);</span>
        <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">pointerEvent</span><span class="p">.</span><span class="n">pointerPress</span><span class="p">,</span> <span class="n">pointerEvent</span><span class="p">,</span> <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">pointerUpHandler</span><span class="p">);</span>

        <span class="c1">// Debug.Log(&quot;KeyCode: &quot; + pointer.eventData.keyCode);</span>

        <span class="kt">var</span> <span class="n">pointerUpHandler</span> <span class="p">=</span> <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">GetEventHandler</span><span class="p">&lt;</span><span class="n">IPointerClickHandler</span><span class="p">&gt;(</span><span class="n">currentOverGo</span><span class="p">);</span>

        <span class="c1">// 如果抬起时与按下时为同一个元素，那就是点击</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pointerEvent</span><span class="p">.</span><span class="n">pointerPress</span> <span class="p">==</span> <span class="n">pointerUpHandler</span> <span class="p">&amp;&amp;</span> <span class="n">pointerEvent</span><span class="p">.</span><span class="n">eligibleForClick</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">pointerEvent</span><span class="p">.</span><span class="n">pointerPress</span><span class="p">,</span> <span class="n">pointerEvent</span><span class="p">,</span> <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">pointerClickHandler</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// 否则也可能是拖拽的释放</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">pointerEvent</span><span class="p">.</span><span class="n">pointerDrag</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">pointerEvent</span><span class="p">.</span><span class="n">dragging</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">ExecuteHierarchy</span><span class="p">(</span><span class="n">currentOverGo</span><span class="p">,</span> <span class="n">pointerEvent</span><span class="p">,</span> <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">dropHandler</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">pointerEvent</span><span class="p">.</span><span class="n">eligibleForClick</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="n">pointerEvent</span><span class="p">.</span><span class="n">pointerPress</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
        <span class="n">pointerEvent</span><span class="p">.</span><span class="n">rawPointerPress</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>

        <span class="c1">// 如果正在拖拽则抬起事件等于拖拽结束事件</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pointerEvent</span><span class="p">.</span><span class="n">pointerDrag</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">pointerEvent</span><span class="p">.</span><span class="n">dragging</span><span class="p">)</span>
            <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">pointerEvent</span><span class="p">.</span><span class="n">pointerDrag</span><span class="p">,</span> <span class="n">pointerEvent</span><span class="p">,</span> <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">endDragHandler</span><span class="p">);</span>

        <span class="n">pointerEvent</span><span class="p">.</span><span class="n">dragging</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="n">pointerEvent</span><span class="p">.</span><span class="n">pointerDrag</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>

        <span class="c1">// 如果当前接收事件的物体和事件的刚开始的物体不一致，则对两个物体做进和出的事件处理</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">currentOverGo</span> <span class="p">!=</span> <span class="n">pointerEvent</span><span class="p">.</span><span class="n">pointerEnter</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">HandlePointerExitAndEnter</span><span class="p">(</span><span class="n">pointerEvent</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
            <span class="n">HandlePointerExitAndEnter</span><span class="p">(</span><span class="n">pointerEvent</span><span class="p">,</span> <span class="n">currentOverGo</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>上面展示了 ProcessMousePress 处理鼠标按下事件的代码，虽然比较多但并不复杂，我在代码上做了详尽的注解。其实它不仅仅处理的是按下的操作，也同时处理鼠标抬起的操作，以及处理了拖拽启动和拖拽抬起与结束的事件。在调用处理相关句柄的前后，事件数据都会被保存在 pointerEvent 中，然后被传递给业务层中设置的输入事件句柄。</p><p>我们再来看看 ProcessDrag 拖拽处理函数:</p><div class="highlight"><pre><code class="language-c#" data-lang="c#"><span></span><span class="k">protected</span> <span class="k">virtual</span> <span class="k">void</span> <span class="nf">ProcessDrag</span><span class="p">(</span><span class="n">PointerEventData</span> <span class="n">pointerEvent</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">moving</span> <span class="p">=</span> <span class="n">pointerEvent</span><span class="p">.</span><span class="n">IsPointerMoving</span><span class="p">();</span>

    <span class="c1">// 如果已经在移动，且还没开始拖拽启动事件，则调用拖拽启动句柄，并设置拖拽中标记为true</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">moving</span> <span class="p">&amp;&amp;</span> <span class="n">pointerEvent</span><span class="p">.</span><span class="n">pointerDrag</span> <span class="p">!=</span> <span class="k">null</span>
        <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="n">pointerEvent</span><span class="p">.</span><span class="n">dragging</span>
        <span class="p">&amp;&amp;</span> <span class="n">ShouldStartDrag</span><span class="p">(</span><span class="n">pointerEvent</span><span class="p">.</span><span class="n">pressPosition</span><span class="p">,</span> <span class="n">pointerEvent</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="n">eventSystem</span><span class="p">.</span><span class="n">pixelDragThreshold</span><span class="p">,</span> <span class="n">pointerEvent</span><span class="p">.</span><span class="n">useDragThreshold</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">pointerEvent</span><span class="p">.</span><span class="n">pointerDrag</span><span class="p">,</span> <span class="n">pointerEvent</span><span class="p">,</span> <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">beginDragHandler</span><span class="p">);</span>
        <span class="n">pointerEvent</span><span class="p">.</span><span class="n">dragging</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 拖拽时的句柄处理</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pointerEvent</span><span class="p">.</span><span class="n">dragging</span> <span class="p">&amp;&amp;</span> <span class="n">moving</span> <span class="p">&amp;&amp;</span> <span class="n">pointerEvent</span><span class="p">.</span><span class="n">pointerDrag</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 如果按下的物体和拖拽的物体不是同一个则视为抬起拖拽，并清除前面按下时的标记</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pointerEvent</span><span class="p">.</span><span class="n">pointerPress</span> <span class="p">!=</span> <span class="n">pointerEvent</span><span class="p">.</span><span class="n">pointerDrag</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">pointerEvent</span><span class="p">.</span><span class="n">pointerPress</span><span class="p">,</span> <span class="n">pointerEvent</span><span class="p">,</span> <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">pointerUpHandler</span><span class="p">);</span>

            <span class="n">pointerEvent</span><span class="p">.</span><span class="n">eligibleForClick</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
            <span class="n">pointerEvent</span><span class="p">.</span><span class="n">pointerPress</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
            <span class="n">pointerEvent</span><span class="p">.</span><span class="n">rawPointerPress</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 执行拖拽中句柄</span>
        <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">pointerEvent</span><span class="p">.</span><span class="n">pointerDrag</span><span class="p">,</span> <span class="n">pointerEvent</span><span class="p">,</span> <span class="n">ExecuteEvents</span><span class="p">.</span><span class="n">dragHandler</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>上面展示了 ProcessDrag 拖拽句柄处理函数，与ProcessMousePress类似对拖拽事件逻辑做了判断，包括拖拽开始事件处理，判断结束拖拽事件，以及拖拽句柄的调用。</p><p>ProcessMove 则相对简单点，每帧都会直接调用处理句柄。</p><div class="highlight"><pre><code class="language-c#" data-lang="c#"><span></span><span class="k">protected</span> <span class="k">virtual</span> <span class="k">void</span> <span class="nf">ProcessMove</span><span class="p">(</span><span class="n">PointerEventData</span> <span class="n">pointerEvent</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">targetGO</span> <span class="p">=</span> <span class="n">pointerEvent</span><span class="p">.</span><span class="n">pointerCurrentRaycast</span><span class="p">.</span><span class="n">gameObject</span><span class="p">;</span>
    <span class="n">HandlePointerExitAndEnter</span><span class="p">(</span><span class="n">pointerEvent</span><span class="p">,</span> <span class="n">targetGO</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>除了鼠标事件外，我们再来看看触屏事件的处理方式，即 TouchInputModule 的核心函数。如下:</p><div class="highlight"><pre><code class="language-c#" data-lang="c#"><span></span><span class="c1">/// &lt;summary&gt;</span>
<span class="c1">/// Process all touch events.</span>
<span class="c1">/// 处理所有触屏事件</span>
<span class="c1">/// &lt;/summary&gt;</span>
<span class="k">private</span> <span class="k">void</span> <span class="nf">ProcessTouchEvents</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">Input</span><span class="p">.</span><span class="n">touchCount</span><span class="p">;</span> <span class="p">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Touch</span> <span class="n">input</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="n">GetTouch</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

        <span class="kt">bool</span> <span class="n">released</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">pressed</span><span class="p">;</span>
        <span class="kt">var</span> <span class="n">pointer</span> <span class="p">=</span> <span class="n">GetTouchPointerEventData</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="k">out</span> <span class="n">pressed</span><span class="p">,</span> <span class="k">out</span> <span class="n">released</span><span class="p">);</span>

        <span class="n">ProcessTouchPress</span><span class="p">(</span><span class="n">pointer</span><span class="p">,</span> <span class="n">pressed</span><span class="p">,</span> <span class="n">released</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(!</span><span class="n">released</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">ProcessMove</span><span class="p">(</span><span class="n">pointer</span><span class="p">);</span>
            <span class="n">ProcessDrag</span><span class="p">(</span><span class="n">pointer</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
            <span class="nf">RemovePointerData</span><span class="p">(</span><span class="n">pointer</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>从代码中我们看到 ProcessMove 和 ProcessDrag 与前面鼠标事件处理时一样的，只是按下的时间处理不同，而且它对每个触点都做了相同的操作处理。其实 ProcessTouchPress 和鼠标按下处理函数 ProcessMousePress 非常相似，可以说基本上一模一样，只是传入时的数据类型不同而已，由于篇幅有限这里不再重复展示长串代码。</p><p>这里大量用到了 ExecuteEvents.ExecuteHierarchy，ExecuteEvents.Execute 之类的静态函数来执行句柄，它是怎么工作的呢，其实很简单:</p><div class="highlight"><pre><code class="language-c#" data-lang="c#"><span></span><span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Transform</span><span class="p">&gt;</span> <span class="n">s_InternalTransformList</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Transform</span><span class="p">&gt;(</span><span class="m">30</span><span class="p">);</span>

<span class="k">public</span> <span class="k">static</span> <span class="n">GameObject</span> <span class="n">ExecuteHierarchy</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">GameObject</span> <span class="n">root</span><span class="p">,</span> <span class="n">BaseEventData</span> <span class="n">eventData</span><span class="p">,</span> <span class="n">EventFunction</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">callbackFunction</span><span class="p">)</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">IEventSystemHandler</span>
<span class="p">{</span>
    <span class="c1">// 获取物体的所有父节点，包括它自己</span>
    <span class="n">GetEventChain</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">s_InternalTransformList</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">s_InternalTransformList</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">transform</span> <span class="p">=</span> <span class="n">s_InternalTransformList</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="c1">// 对每个父节点包括自己依次执行句柄响应</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Execute</span><span class="p">(</span><span class="n">transform</span><span class="p">.</span><span class="n">gameObject</span><span class="p">,</span> <span class="n">eventData</span><span class="p">,</span> <span class="n">callbackFunction</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">transform</span><span class="p">.</span><span class="n">gameObject</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>解释下上述代码，对所有父节点都调用句柄函数。也就是说，当前节点的事件会通知给它上面的父节点。</p><h6>到这里我们基本清楚事件处理的基本逻辑了，下面我们来看看碰撞测试模块是如何运作的</h6><h6>射线碰撞检测模块源码</h6><p>射线碰撞检测模块主要工作是从摄像机的屏幕位置上，做射线碰撞检测并获取碰撞结果，把结果返回给事件处理逻辑类，交由事件处理模块处理事件。</p><p>射线碰撞检测模块主要为3个类，分别作用于 2D射线碰撞检测，3D射线碰撞检测，GraphicRaycaster图形射线碰撞测试。</p><p>2D、3D射线碰撞测试相对比较简单，用射线的形式做碰撞测试，区别在2D碰撞结果里预留了2D的层级次序以便在后面的碰撞结果排序时，以这个层级次序为依据做排序，而3D的碰撞检测结果则是以距离大小为依据排序的。</p><p>GraphicRaycaster 为UGUI元素点位检测的类，它被放在了 Core 渲染块里。它主要针对 ScreenSpaceOverlay 模式下输入点位做碰撞检测，因为这个模式下的检测并不依赖于射线碰撞，而是遍历所有可点击的UGUI元素来检测比较，从而判断是该响应哪个UI元素。因此 GraphicRaycaster 是比较特殊的。</p><p>我们来着重看下 GraphicRaycaster 的核心源码如下：</p><div class="highlight"><pre><code class="language-c#" data-lang="c#"><span></span><span class="c1">/// &lt;summary&gt;</span>
<span class="c1">/// Perform a raycast into the screen and collect all graphics underneath it.</span>
<span class="c1">/// &lt;/summary&gt;</span>
<span class="na">[NonSerialized]</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Graphic</span><span class="p">&gt;</span> <span class="n">s_SortedGraphics</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Graphic</span><span class="p">&gt;();</span>
<span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Raycast</span><span class="p">(</span><span class="n">Canvas</span> <span class="n">canvas</span><span class="p">,</span> <span class="n">Camera</span> <span class="n">eventCamera</span><span class="p">,</span> <span class="n">Vector2</span> <span class="n">pointerPosition</span><span class="p">,</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Graphic</span><span class="p">&gt;</span> <span class="n">results</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Debug.Log(&quot;ttt&quot; + pointerPoision + &quot;:::&quot; + camera);</span>
    <span class="c1">// Necessary for the event system</span>
    <span class="kt">var</span> <span class="n">foundGraphics</span> <span class="p">=</span> <span class="n">GraphicRegistry</span><span class="p">.</span><span class="n">GetGraphicsForCanvas</span><span class="p">(</span><span class="n">canvas</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">foundGraphics</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span> <span class="p">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Graphic</span> <span class="n">graphic</span> <span class="p">=</span> <span class="n">foundGraphics</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

        <span class="c1">// -1 means it hasn&#39;t been processed by the canvas, which means it isn&#39;t actually drawn</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">graphic</span><span class="p">.</span><span class="n">depth</span> <span class="p">==</span> <span class="p">-</span><span class="m">1</span> <span class="p">||</span> <span class="p">!</span><span class="n">graphic</span><span class="p">.</span><span class="n">raycastTarget</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(!</span><span class="n">RectTransformUtility</span><span class="p">.</span><span class="n">RectangleContainsScreenPoint</span><span class="p">(</span><span class="n">graphic</span><span class="p">.</span><span class="n">rectTransform</span><span class="p">,</span> <span class="n">pointerPosition</span><span class="p">,</span> <span class="n">eventCamera</span><span class="p">))</span>
            <span class="k">continue</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">graphic</span><span class="p">.</span><span class="n">Raycast</span><span class="p">(</span><span class="n">pointerPosition</span><span class="p">,</span> <span class="n">eventCamera</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">s_SortedGraphics</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">graphic</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">s_SortedGraphics</span><span class="p">.</span><span class="n">Sort</span><span class="p">((</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">g2</span><span class="p">.</span><span class="n">depth</span><span class="p">.</span><span class="n">CompareTo</span><span class="p">(</span><span class="n">g1</span><span class="p">.</span><span class="n">depth</span><span class="p">));</span>
    <span class="c1">//      StringBuilder cast = new StringBuilder();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">s_SortedGraphics</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span> <span class="p">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">results</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">s_SortedGraphics</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="c1">//      Debug.Log (cast.ToString());</span>

    <span class="n">s_SortedGraphics</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><p>上述代码中，GraphicRaycaster 对每个可以点击的元素(raycastTarget是否为true，并且 depth 不为-1，为可点击元素)进行计算，判断点位是否落在该元素上。再通过 depth 变量排序，判断最先该落在哪个元素上，从而确定哪个元素响应输入事件。</p><p>所有检测碰撞的结果数据结构为 RaycastResult 类，它承载了所有碰撞检测结果的依据，包括了距离，世界点位，屏幕点位，2D层级次序，碰撞物体等，为后面事件处理提供了数据上的依据。</p><h6>事件逻辑处理模块</h6><p>事件主逻辑处理模块，主要的逻辑都集中在 EventSystem 类中，其余的类都是对它起辅助作用的。</p><p>EventInterfaces，EventTrigger，EventTriggerType 定义了事件回调函数，ExecuteEvents 编写了所有执行事件的回调接口。</p><p>EventSystem 主逻辑里只有300行代码基本上都在处理由射线碰撞检测后引起的各类事件。判断事件是否成立，成立则发起事件回调，不成立则继续轮询检查，等待事件的发生。</p><p>EventSystem 是事件处理模块中唯一继承 MonoBehavior 并且有在 Update 帧循环中做轮询的。也就是说，所有UI事件的发生都是通过 EventSystem 轮询监测到的并且实施的。EventSystem 通过调用输入事件检测模块，检测碰撞模块，来形成自己主逻辑部分。因此可以说 EventSystem 是主逻辑类，是整个事件模块的入口。</p><h6>架构者在设计时将整个事件层各自的职能拆分的很清楚，使得我们看源代码时也并没有那么难。输入监测由输入事件捕捉模块完成，碰撞检测由碰撞检测模块完成，事件的数据类都有各自的定义，EventSystem 主要作用是把这些模块拼装起来成为主逻辑块。</h6><p><a href="https://bitbucket.org/Unity-Technologies/ui/downloads/?tab=downloads">UGUI源码地址</a></p><span class="meta"><time datetime="2018-07-26T00:00:00+08:00">July 26, 2018</time> &middot; <a href="/tag/书籍著作">书籍著作</a>, <a href="/tag/Unity3D">Unity3D</a>, <a href="/tag/前端技术">前端技术</a></span> <!--<span class="meta"><time datetime="2018-07-26T00:00:00+08:00">July 26, 2018</time> &middot; <a class="post" href="/tag/书籍著作">书籍著作</a>, <a class="post" href="/tag/Unity3D">Unity3D</a>, <a class="post" href="/tag/前端技术">前端技术</a></span> --></section></main></body></html>
