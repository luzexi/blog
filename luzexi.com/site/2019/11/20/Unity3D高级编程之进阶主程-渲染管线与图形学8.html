<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta content="unity3d 高级编程 主程 shader 漫反射 镜面反射 自发光 球面反射" name="description">


  <title>
    
      《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(三) - 渲染原理与知识3
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css?version=20180701">
  <!-- <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface"> -->

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

  	<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h2>
        <a href="/">
          技术人生
        </a>
      </h2>
      <p class="lead">技术，哲学，金融</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>

      

      <a class="sidebar-nav-item" href="/书籍著作/index.html">书籍著作</a>
      <a class="sidebar-nav-item" href="/Unity3D/index.html">Unity3D</a>
      <a class="sidebar-nav-item" href="/游戏通用模块/index.html">游戏通用模块</a>
      <a class="sidebar-nav-item" href="/前端技术/index.html">前端技术</a>
      <a class="sidebar-nav-item" href="/后端技术/index.html">后端技术</a>
      <a class="sidebar-nav-item" href="/其他技术/index.html">其他技术</a>
      <a class="sidebar-nav-item" href="/金融投资/index.html">金融投资</a>
      <a class="sidebar-nav-item" href="/life/index.html">思路探讨</a>
      <a class="sidebar-nav-item" href="/英文文章/index.html">英文文章</a>

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/Util-page.html">常用页面工具</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about.html">我的简介</a>
          
        
      
        
      
        
          
            <a class="sidebar-nav-item" href="/engineer-shopping.html">程序员必需品</a>
          
        
      
        
      
        
          
            <a class="sidebar-nav-item" href="/friendlink.html">友情链接</a>
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
      
        
      
      
      <a class="sidebar-nav-item" href="https://github.com/luzexi">GitHub project</a>
      <a href="http://www.luzexi.com/assets/feed.xml">RSS feed</a>
      <!-- <span class="sidebar-nav-item">Currently v2.1.0</span> -->
    </nav>

    <p>&copy; 2020. All rights reserved. </p>
    <p><a href="http://www.beian.miit.gov.cn" target="_blank">浙ICP备13028172号</a></p>
  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(三) - 渲染原理与知识3</h1>
  <span class="post-date">20 Nov 2019</span>

  <h3>GPU Instancing 的来龙去脉</h3>

<p>GPU Instancing 初次听到这个名词时还有点疑惑，其实翻译过来应该是GPU多实例化渲染，它本身是GPU的一个功能接口，Unity3D将它变得更简单实用。</p>

<p>===</p>

<p>前面讲过一些关于Unity3D的动态合批(Dynamic batching)与静态合批(Static batching)的功能，GPU Instancing 实际上与他们一样都是为了减少Drawcall而存在。</p>

<p>有了动态合批和静态合批为什么还需要 GPU Instancing 呢，究竟他们之间有什么区别呢，我们不妨来简单回顾一下Unity3D动态合批(Dynamic batching)与静态合批(Static batching)。</p>

<h6>开启动态合批(Dynamic batching)时，Unity3D引擎检测视野范围内的非动画物体(通过遍历所有渲染模型，计算包围盒在视锥体中的位置，如果完全不在视锥体中则抛弃)，如果在视锥体内并且符合条件的就进行合批操作，将他们的网格合并后与材质球一并传给GPU去绘制。</h6>

<p>需要符合什么条件呢：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    1，900个顶点以下的模型。

    2，如果我们使用了顶点坐标，法线，UV，那么就只能最多300个顶点。

    3，如果我们使用了UV0，UV1，和切线，又更少了，只能最多150个顶点。

    4，如果两个模型缩放大小不同，不能被合批的，即模型之间的缩放必须一致。

    5，如果是不同的材质球实例同样不能被合批，即使他们一模一样。即材质球属性不能被修改，材质球对象实例必须是同一个。

    6，如果他们有lightmap的数据，必须是相同的才有机会合批。

    7，多个pass的Shader是绝对不会被合批。

    8，延迟渲染是无法被合批。
</code></pre></div>
<p>条件比较苛刻，一不小心就无法达到合并条件。为什么它要使用这么苛刻的条件呢，我们来了解下设计动态合批这个功能的意图。</p>

<h6>动态合批(Dynamic batching)这个功能的目标是以最小的代价合并小型网格模型，减少Drawcall调用。</h6>

<p>很多人会想既然合并了为什么不把所有的模型都合并呢，这样不是更减少Drawcall的开销。如果把各种情况的中大型网格都合并进来，就需要消耗巨大的CPU资源，而且在摄像机移动过程中，每帧都要进行合并网格的消耗，CPU算力消耗太大，得不偿失。于是Unity3D就对这种极其消耗CPU算力的功能做了如此多的的限制，就是为了让它在运作时性价比更高。</p>

<p>与动态合批不同，静态合批(Static batching)并不实时合并网格，而是会在离线状态下生成合并的网格，所有被标记为静态物体的模型，只要拥有相同实例的材质球都会被一并合并成网格。</p>

<p>静态合批有诸多优点，但也存在不少弊端。被合批的是静态物体，它们是不能被移动旋转和缩放的，也只有这样我们在离线状态下生成的网格才是有效的（离线的网格数据不需要重新计算），生成的离线数据被放在Vertex buffer和Index buffer中。</p>

<h6>静态合批生成的离线网格将导致存放在内存的网格数据量剧增，因为在静态合批中每个模型都会独立生成一份网格数据，无论他们所使用的网格是否相同，也就是说场景中有多少个静态模型就有多少个网格，与原本只需要一个网格就能渲染所有相同模型的情况不一样了。</h6>

<p>好处是静态合批后同一材质球实例(材质球实例必须相同，因为材质球的参数要一致)调用Drawcall的数量合并了，另外合批也不会额外消耗CPU算力因为它们是在离线时生成的合批数据(也就是网格数据)，在实时渲染时如果该模型在视锥体范围内，三角形索引被部分提取出来合并后提交，而那些早就被生成的网格将被整体提交(整体网格过大时则会导致CPU和GPU的带宽消耗过大)，最后再一并发送给GPU进行渲染。</p>

<h6>简而言之，动态合批为了平衡CPU消耗和GPU性能优化，将实时合批条件限制在比较狭窄的范围内。静态合批则牺牲了大量的内存和带宽，以使得合批工作能够快速有效的进行。</h6>

<p>GPU Instancing 没有动态合批对网格数量的限制，也没有静态网格需要这么大的内存，很好的弥补了这两者的缺陷，但也有存在着比较大的优缺点，我们下面来逐一阐述。</p>

<p>GPU Instancing 并不像动态和静态合批那样通过对网格的合并操作进行优化，GPU Instancing 的目标是只用一个模型网格绘制很多个地方，这些地方绘制的网格缩放大小，旋转角度和坐标可以不一样，材质球虽然相同但材质球属性可以各自有各自的区别。</p>

<p>本质上来说 GPU Instancing 调用的是 OpenGL 和 DirectX 里的多实例渲染接口。我们拿 OpenGL 来说:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="kt">void</span> <span class="nf">glDrawArraysInstanced</span><span class="p">(</span><span class="n">GLenum</span> <span class="n">mode</span><span class="p">,</span> <span class="n">GLint</span> <span class="n">first</span><span class="p">,</span> <span class="n">GLsizei</span> <span class="n">count</span><span class="p">,</span> <span class="n">Glsizei</span> <span class="n">primCount</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">glDrawElementsInstanced</span><span class="p">(</span><span class="n">GLenum</span> <span class="n">mode</span><span class="p">,</span> <span class="n">GLsizei</span> <span class="n">count</span><span class="p">,</span> <span class="n">GLenum</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">indices</span><span class="p">,</span> <span class="n">GLsizei</span> <span class="n">primCount</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">glDrawElementsInstancedBaseVertex</span><span class="p">(</span><span class="n">GLenum</span> <span class="n">mode</span><span class="p">,</span> <span class="n">GLsizei</span> <span class="n">count</span><span class="p">,</span> <span class="n">GLenum</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">indices</span><span class="p">,</span> <span class="n">GLsizei</span> <span class="n">instanceCount</span><span class="p">,</span> <span class="n">GLuint</span> <span class="n">baseVertex</span><span class="p">);</span>
</code></pre></div>
<p>这三个接口正是 GPU Instancing 调用多实例渲染的接口，第一个是无索引的顶点网格集多实例渲染，第二个是索引网格的多实例渲染，第三个是索引基于偏移的网格多实例渲染。调用这三个接口会向GPU传入渲染数据并开启渲染，与平时渲染多次要多次执行整个渲染管线不同的是，这三个接口会分别将模型渲染多次，并且是在一个渲染管线内。</p>

<p>如果只是一个坐标上渲染多次模型是没有意义的，我们需要将一个模型渲染到不同的多个地方，并且以不同的缩放大小和旋转角度，以及不同的材质球参数，这才是我们真正需要的。</p>

<p>GPU Instancing 正我们提供这个功能，上面三个渲染接口告知Shader着色器开启一个叫 InstancingID 的变量，这个变量可以确定在着色计算时使用哪个实例的属性。</p>

<p>有了这个 InstancingID 就能使得我们在多实例渲染中，辨识到底使用哪个属性参数。Shader的顶点着色器和片元着色器可以通过这个变量来获取模型矩阵、颜色等不同变化的参数。</p>

<p>我们来看看Unity3D是怎么做的:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">Shader</span> <span class="s">&quot;SimplestInstancedShader&quot;</span>
<span class="p">{</span>
    <span class="n">Properties</span>
    <span class="p">{</span>
        <span class="n">_Color</span> <span class="p">(</span><span class="s">&quot;Color&quot;</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">SubShader</span>
    <span class="p">{</span>
        <span class="n">Tags</span> <span class="p">{</span> <span class="s">&quot;RenderType&quot;</span><span class="o">=</span><span class="s">&quot;Opaque&quot;</span> <span class="p">}</span>
        <span class="n">LOD</span> <span class="mi">100</span>

        <span class="n">Pass</span>
        <span class="p">{</span>
            <span class="n">CGPROGRAM</span>
            <span class="cp">#pragma vertex vert</span>
            <span class="cp">#pragma fragment frag</span>
            <span class="cp">#pragma multi_compile_instancing</span>
            <span class="cp">#include</span> <span class="cpf">&quot;UnityCG.cginc&quot;</span><span class="cp"></span>

            <span class="k">struct</span> <span class="n">appdata</span>
            <span class="p">{</span>
                <span class="n">float4</span> <span class="nl">vertex</span> <span class="p">:</span> <span class="n">POSITION</span><span class="p">;</span>
                <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span> <span class="c1">//顶点着色器的 InstancingID定义</span>
            <span class="p">};</span>

            <span class="k">struct</span> <span class="n">v2f</span>
            <span class="p">{</span>
                <span class="n">float4</span> <span class="nl">vertex</span> <span class="p">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
                <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span> <span class="c1">//片元着色器的 InstancingID定义</span>
            <span class="p">};</span>

            <span class="n">UNITY_INSTANCING_BUFFER_START</span><span class="p">(</span><span class="n">Props</span><span class="p">)</span> <span class="c1">// 定义多实例变量数组</span>
                <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="n">float4</span><span class="p">,</span> <span class="n">_Color</span><span class="p">)</span>
            <span class="n">UNITY_INSTANCING_BUFFER_END</span><span class="p">(</span><span class="n">Props</span><span class="p">)</span>

            <span class="n">v2f</span> <span class="n">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>

                <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="c1">//装配 InstancingID</span>
                <span class="n">UNITY_TRANSFER_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">o</span><span class="p">);</span> <span class="c1">//输入到结构中传给片元着色器</span>

                <span class="n">o</span><span class="p">.</span><span class="n">vertex</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">fixed4</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
            <span class="p">{</span>
                <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">//装配 InstancingID</span>
                <span class="k">return</span> <span class="nf">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">Props</span><span class="p">,</span> <span class="n">_Color</span><span class="p">);</span> <span class="c1">//提取多实例中的当前实例的Color属性变量值</span>
            <span class="p">}</span>
            <span class="n">ENDCG</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>上述是一个很普通的调用 Instancing 的Shader，其中<em>Color 和 unity</em>ObjectToWorld (模型矩阵)是多实例化的，他们通过 InstancingID 索引来确定取数组中的哪个变量。</p>

<p>为什么这么说呢？我们来看看Shader中这些包含有 INSTANCE 字样的宏定义。</p>

<p>首先编译命令 multi<em>compile</em>instancing 会告知着色器我们将会使用多实例变量。</p>

<p>其次在顶点着色器和片元着色的输入输出结构中，加入 UNITY<em>VERTEX</em>INPUT<em>INSTANCE</em>ID 告知结构中多一个变量即：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    uint instanceID : SV_InstanceID;
</code></pre></div>
<p>每个顶点和片元数据结构中都定义了 instanceID 这个变量，这个变量将被用于确定使用多实例数据数组中的哪个实例参数，很关键。</p>

<p>接着Shader中要把需要用到的多实例变量参数定义起来:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span>        <span class="n">UNITY_INSTANCING_BUFFER_START</span><span class="p">(</span><span class="n">Props</span><span class="p">)</span>
            <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="n">float4</span><span class="p">,</span> <span class="n">_Color</span><span class="p">)</span>
        <span class="n">UNITY_INSTANCING_BUFFER_END</span><span class="p">(</span><span class="n">Props</span><span class="p">)</span>
</code></pre></div>
<p>上述中的宏很容易从字面看出它们为&quot;开始多实例宏定义&quot;，&quot;对多实例宏属性定义参数&quot;，以及&quot;结束多实例宏定义&quot;。</p>

<p>这三个宏定义我们可以在 UnityInstancing.cginc 中看到，即:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span>        <span class="cp">#define UNITY_INSTANCING_BUFFER_START(buf)      UNITY_INSTANCING_CBUFFER_SCOPE_BEGIN(UnityInstancing_##buf)</span>
        <span class="cp">#define UNITY_INSTANCING_BUFFER_END(arr)        UNITY_INSTANCING_CBUFFER_SCOPE_END</span>
        <span class="cp">#define UNITY_DEFINE_INSTANCED_PROP(type, var)  type var[UNITY_INSTANCED_ARRAY_SIZE];</span>
</code></pre></div>
<p>我们可以上述的宏定义中理解到，这三个宏可以对多实例的多属性数组进行定义。</p>

<p>于是在顶点着色器与片元着色中，我们对 InstancingID 进行装配，即宏定义：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    UNITY_SETUP_INSTANCE_ID(v) 和 UNITY_SETUP_INSTANCE_ID(i);

    装配过程其实就是从基数偏移的过程 unity_InstanceID = inputInstanceID + unity_BaseInstanceID;
</code></pre></div>
<p>最终我们通过 UNITY<em>SETUP</em>INSTANCE<em>ID 装配得到了 unity</em>InstanceID 即当前渲染的多实例索引ID。</p>

<p>有了多实例的索引ID，我们就可以通过这个变量获取对应的当前实例的属性值，于是就有了以下的宏定义 UNITY<em>ACCESS</em>INSTANCED_PROP 以及通过这个宏定义获取变量的代码。</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="cp">#define UNITY_ACCESS_INSTANCED_PROP(arr, var)   var[unity_InstanceID]</span>

<span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">Props</span><span class="p">,</span> <span class="n">_Color</span><span class="p">);</span> <span class="c1">//提取多实例中的当前实例的Color属性变量值</span>
</code></pre></div>
<h6>有了类似_Color的多实例属性操作，在模型矩阵变化中也需要具备同样的操作，我们没看到模型矩阵多实例是因为Unity在Shader编写时用宏定义把它们隐藏起来了，它就是 UnityObjectToClipPos。</h6>

<p>UnityObjectToClipPos 其实是一个宏定义，当多实例渲染开启时，它被定义成了如下:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="cp">#define unity_ObjectToWorld     UNITY_ACCESS_INSTANCED_PROP(unity_Builtins0, unity_ObjectToWorldArray)</span>

<span class="kr">inline</span> <span class="n">float4</span> <span class="nf">UnityObjectToClipPosInstanced</span><span class="p">(</span><span class="n">in</span> <span class="n">float3</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">mul</span><span class="p">(</span><span class="n">UNITY_MATRIX_VP</span><span class="p">,</span> <span class="n">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">float4</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)));</span>
<span class="p">}</span>
<span class="kr">inline</span> <span class="n">float4</span> <span class="nf">UnityObjectToClipPosInstanced</span><span class="p">(</span><span class="n">float4</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">UnityObjectToClipPosInstanced</span><span class="p">(</span><span class="n">pos</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#define UnityObjectToClipPos UnityObjectToClipPosInstanced</span>
</code></pre></div>
<p>这个定义也同样可以在 UnityInstancing.cginc 中找到，其中unity_ObjectToWorld是关键，它从多实例数组中取出了当前实例的模型矩阵，再与坐标相乘后计算投影空间的坐标。也就是说当开启 Instancing 多实例渲染时，UnityObjectToClipPos 会从多实例数据数组中取模型矩阵来做模型到投影空间的转换。而当不开启 Instancing 时，UnityObjectToClipPos 则只是用当前独有的模型矩阵来计算顶点坐标投影空间的位置。</p>

<p>到此我们就从着色器中获取了多实例的属性变量，根据不同实例的不同索引获取不同属性变量包括模型矩阵，从而渲染不同位置，不同的旋转角度，不同的缩放大小，以及更多比如_Color的其他属性，整个过程都是围绕着 InstancingID 来做索引操作。</p>

<h6>知道了 GPU Instancing 是如何渲染还不够，我们还要知道数据是怎么传进去的。</h6>

<p>我们还是拿 OpenGL 接口编程来分析。</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="c1">//获取各属性的索引</span>
<span class="kt">int</span> <span class="n">position_loc</span> <span class="o">=</span> <span class="n">glGetAttribLocation</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="s">&quot;position&quot;</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">normal_loc</span> <span class="o">=</span> <span class="n">glGetAttribLocation</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="s">&quot;normal&quot;</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">color_loc</span> <span class="o">=</span> <span class="n">glGetAttribLocation</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="s">&quot;color&quot;</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">matrix_loc</span> <span class="o">=</span> <span class="n">glGetAttribLocation</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="s">&quot;model_matrix&quot;</span><span class="p">);</span>

<span class="c1">//按正常流程配置顶点和法线</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">position_buffer</span><span class="p">);</span> <span class="c1">//绑定顶点数组</span>
<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="n">position_loc</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <span class="c1">//定义顶点数据规范</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="n">position_loc</span><span class="p">);</span> <span class="c1">//按上述规范，将坐标数组应用到顶点属性中去</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">normal_buffer</span><span class="p">);</span> <span class="c1">//绑定发现数组</span>
<span class="n">glBertexAttribPointer</span><span class="p">(</span><span class="n">normal_loc</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <span class="c1">//定义发现数据规范</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="n">normal_loc</span><span class="p">);</span> <span class="c1">//按上述规范，将法线数组应用到顶点属性中去</span>

<span class="c1">//开始多实例化配置</span>
<span class="c1">//设置颜色的数组。我们希望几何体的每个实例都有一个不同的颜色，</span>
<span class="c1">//将颜色值置入缓存对象中，然后设置一个实例化的顶点属性</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">color_buffer</span><span class="p">);</span> <span class="c1">//绑定颜色数组</span>
<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="n">color_loc</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <span class="c1">//定义颜色数据在color_loc索引位置的数据规范</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="n">color_loc</span><span class="p">);</span> <span class="c1">//按照上述的规范，将color_loc数据应用到顶点属性上去</span>

<span class="n">glVertexattribDivisor</span><span class="p">(</span><span class="n">color_loc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">//开启颜色属性的多实例化，1表示每隔1个实例时共用一个数据</span>

<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">model_matrix_buffer</span><span class="p">);</span> <span class="c1">//绑定矩阵数组</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//设置矩阵第一行的数据规范</span>
    <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="n">matrix_loc</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mat4</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">vec4</span><span class="p">)</span><span class="o">*</span><span class="n">i</span><span class="p">));</span>

    <span class="c1">//将第一行的矩阵数据应用到顶点属性上去</span>
    <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="n">matrix_loc</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

    <span class="c1">//开启第一行矩阵数据的多实例化，1表示每隔1个实例时共用一个数据</span>
    <span class="n">glVertexattribDivisor</span><span class="p">(</span><span class="n">matrix_loc</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>这个示例很精准的表达了数据是如何从CPU应用层传输到GPU上再进行实例化的过程。</p>

<p>我在代码上做了比较详尽的注释，首先获取需要推入顶点属性的数据的索引，再将数组数据与OpenGL
缓存进行绑定，这样才能注入到OpenGL里去，接着告诉 OpenGL 每个数据对应的格式，然后再根据前一步描述的格式应用到顶点属性中去，最后如果做的是 GPU Instancing 多实例的属性数据则开启多实例化属性接口，让 InstancingID 起效。</p>

<h6>总结，我们解析了 GPU Instancing 在 Unity3D 中的工作方式，得知了它能用同一个模型同一个材质球渲染不同的位置、角度、缩放大小、以及不同颜色等属性。这种没有对模型网格数量限制，没有占用大量内存的性能优化来说，很好的弥补了动态合批(Dynamic batching)与静态合批(Static batching)的不足。</h6>

<p>但是它毕竟是只能围绕一个模型来操作，只有相同网格(Mesh)和相同的材质球实例(参数可以不同，但必须使用API来设置不同参数)的情况下才能做到多个实例在同一个渲染管线中一次性渲染的优化操作，而动态合批和静态合批却只需要材质球实例一致，网格是可以有差别的。</p>

<h6>三者利弊各不同，有互相弥补的地方，各自本身也存在着不同程度的限制和优缺点。从整体上来看，GPU Instancing 更适合同一个模型渲染多次的情况，而动态合批(Dynamic batching)更适合同一个材质球并且模型面数小的情况，静态合批(Static batching)更适合当我们能容忍内存扩大的情况。</h6>

  <p>感谢您的耐心阅读</p>
  <p>Thanks for your reading</p>
</div>
<div>
  
<!-- 代码1：放在页面需要展示的位置  -->
<!-- 如果您配置过sourceid，建议在div标签中配置sourceid、cid(分类id)，没有请忽略  -->
<!-- <div id="cyReward" role="cylabs" data-use="reward" align="center" ></div> -->

<script type="text/javascript" src="/assets/js/tctip-1.0.3.min.js"></script>
<script>
  new tctip({
    top: '50%',
    button: {
      id: 9,
      type: 'zanzhu'
    },
    list: [
      {
        type: 'alipay',
        qrImg: '/assets/common/alipay.jpg'
      }, {
        type: 'wechat',
        qrImg: '/assets/common/wechatpay.jpg'
      }, {
        type: 'bitcoin',
        qrContent: '1ErCFmtoQY2KDctjgPALZri3USsMqdSvqh'
      }
    ]
  }).init()
</script>

  <li>
<p><strong><font color="red">版权申明</font></strong></p>
<!-- <p>本文为博主原创文章，未经允许不得转载: <a href = "http://www.luzexi.com">http://www.luzexi.com</a></p> -->
<p><strong><font color="red">本文为博主原创文章，未经允许不得转载:</font></strong></p>
<p><a href = "http://www.luzexi.com/2019/11/20/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A68.html">《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(三) - 渲染原理与知识3</a></p>
<!-- <p>本文为博主原创文章，未经允许不得转载: <a href = "http://www.luzexi.com/2019/11/20/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A68.html">《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(三) - 渲染原理与知识3</a></p> -->
<p><strong><font color="red">Copyright attention</font></strong></p>
<p><strong><font color="red">Please don't reprint without authorize.</font></strong></p>

</li>
  <li>
<p></p>
<p></p>
<p><image src="/public/qrcode_for_gzh.jpg" /></p>
<p><strong>微信公众号，文章同步推送，致力于分享一个资深程序员在北上广深拼搏中对世界的理解</strong></p>
<p></p>
<p></p>
<p><image src="/public/shipinghao.JPG" /></p>
<p><strong>微信视频号，用视觉听觉上的感官促进你的思考</strong></p>
<p></p>
<p></p>
<p>QQ交流群: 777859752 (高级程序书友会)</p>
</li>
</div>
<div class="related">
    
<div class="bshare-custom icon-medium-plus"><div class="bsPromo bsPromo2"></div><a title="分享到微信" class="bshare-weixin" href="javascript:void(0);"></a><a title="分享到新浪微博" class="bshare-sinaminiblog"></a><a title="分享到QQ好友" class="bshare-qqim" href="javascript:void(0);"></a><a title="分享到QQ空间" class="bshare-qzone" href="javascript:void(0);"></a><a title="分享到Twitter" class="bshare-twitter" href="javascript:void(0);"></a><a title="分享到Facebook" class="bshare-facebook" href="javascript:void(0);"></a><a title="更多平台" class="bshare-more bshare-more-icon more-style-addthis"></a></div><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/buttonLite.js#style=-1&amp;uuid=36b4f383-d948-41a3-acd5-31ae604e3ad8&amp;pophcol=2&amp;lang=zh"></script><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/bshareC0.js"></script>


</div>



<script type="text/javascript">
	if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))
    { //移动端
        /*mobile-20:5*/
    	var cpro_id = "u3493987";
		document.write("\<script type=\"text\/javascript\" src=\"//cpro.baidustatic.com/cpro/ui/cm.js\"\>\<\/script\>");
    }
    else
    {
        /*760*90 创建于 2016-02-02*/
    	var cpro_id = "u2514412";
        document.write("\<script type=\"text/javascript\" src=\"//cpro.baidustatic.com/cpro/ui/c.js\"\>\<\/script\>");
	}
</script>





<div class="related">
  <h2>最新发表的文章</h2>
  <ul class="related-posts">

    
      <li>
        <h3>
          <a href="/2020/03/07/%E5%8A%B1%E5%BF%97%E8%8B%B1%E6%96%875.html">
            励志英文(五) 永不屈服 Unbroken
            <small>07 Mar 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2020/02/29/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A837.html">
            思路探讨(三十七) 良性循环的建立与恶性循环的改善
            <small>29 Feb 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2020/02/27/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A840.html">
            思路探讨(四十) 对赚钱和学习的一些思考(下)
            <small>27 Feb 2020</small>
          </a>
        </h3>
      </li>
    

  </ul>

  <h2>之后发表的文章</h2>

  <ul class="related-posts">
    

    

      
      

      

    

      
      

      

    

      
      

      

    

      
      

      

    

      
      

      

    

      
      

      

    

      
      

      

    

      
      

      

    

      
      

      

    

      
      

      

    

      
      

      

    

      
      

      

    

      
      

      

    

      
      

      

    

      
      

      

    

      
      

      
        
          <li>
            <h3>
              <a href="/2020/01/05/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A835.html">
                思路探讨(三十五) 合作带来自信
                <small>05 Jan 2020</small>
              </a>
            </h3>
          </li>
        
          <li>
            <h3>
              <a href="/2020/01/02/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A834.html">
                思路探讨(三十四) 纠正错误观念
                <small>02 Jan 2020</small>
              </a>
            </h3>
          </li>
        
          <li>
            <h3>
              <a href="/2019/12/28/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A833.html">
                思路探讨(三十三) 2019年我做了什么
                <small>28 Dec 2019</small>
              </a>
            </h3>
          </li>
        
          <li>
            <h3>
              <a href="/2019/12/10/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A610.html">
                《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(五) - Projector投影原理
                <small>10 Dec 2019</small>
              </a>
            </h3>
          </li>
        
          <li>
            <h3>
              <a href="/2019/12/04/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A69.html">
                《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(四) - 多重采样以及着色器编译原理
                <small>04 Dec 2019</small>
              </a>
            </h3>
          </li>
        

        
  <!-- </ul> -->

  <h2>之前发表的文章</h2>

  <ul class="related-posts">
    

    

      

      

    

      

      

    

      

      

    

      

      

    

      

      

    

      

      

    

      

      

    

      

      

    

      

      

    

      

      

    

      

      

    

      

      

    

      

      

    

      

      

    

      

      

    

      

      
        
          <li>
            <h3>
              <a href="/2019/11/09/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A831.html">
                思路探讨(三十一) 钱、才、运
                <small>09 Nov 2019</small>
              </a>
            </h3>
          </li>
        
          <li>
            <h3>
              <a href="/2019/11/04/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A830.html">
                思路探讨(三十) 改变自己才能改变孩子
                <small>04 Nov 2019</small>
              </a>
            </h3>
          </li>
        
          <li>
            <h3>
              <a href="/2019/11/02/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E8%B5%84%E6%BA%90%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E9%87%8A%E6%94%BE.html">
                《Unity3D高级编程之进阶主程》第五章，资源的加载与释放
                <small>02 Nov 2019</small>
              </a>
            </h3>
          </li>
        
          <li>
            <h3>
              <a href="/2019/10/26/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A67.html">
                《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(三) - 渲染原理与知识2
                <small>26 Oct 2019</small>
              </a>
            </h3>
          </li>
        
          <li>
            <h3>
              <a href="/2019/10/13/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A829.html">
                思路探讨(二十九) 有没有可能是我们理解错了
                <small>13 Oct 2019</small>
              </a>
            </h3>
          </li>
        

        
  </ul>
</div>




<!--PC和WAP自适应版-->
<div id="SOHUCS" ></div> 
<script type="text/javascript"> 
(function(){ 
var appid = 'cys17tiy3'; 
var conf = 'prod_3b20e80a06c760385d4781c30f8ebf5c'; 
var width = window.innerWidth || document.documentElement.clientWidth; 
if (width < 960) {
var head = document.getElementsByTagName('head')[0]||document.head||document.documentElement;
var script = document.createElement('script');
script.type = 'text/javascript';
script.charset = 'utf-8';
script.id = 'changyan_mobile_js';
script.src = 'https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf;
head.appendChild(script);
} else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>




<script type="text/javascript">
	if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))
    { //移动端
        /*mobile-悬浮20:3*/
    	var cpro_id = "u3495898";
		document.write("\<script type=\"text\/javascript\" src=\"//cpro.baidustatic.com/cpro/ui/cm.js\"\>\<\/script\>");
    }
    else
    {
        /*500*200-1*/
        var cpro_id = "u3486033";
        document.write("\<script type=\"text/javascript\" src=\"//cpro.baidustatic.com/cpro/ui/c.js\"\>\<\/script\>");
	}
</script>
 



    </div>

    
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?f3d58556a7396e715b3602ef6754cd91";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


    <script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

  </body>
  
</html>
