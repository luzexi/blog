<!DOCTYPE html><html lang="en" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title> 《Unity3D高级编程之进阶主程》第八章 AI(2)-用行为树构建AI - 技术人生</title><link rel="shortcut icon" href="/public/favicon.ico"><link rel="alternate" type="application/atom+xml" title="技术人生" href="/atom.xml"><link rel="alternate" type="application/json" title="技术人生" href="http://www.luzexi.com/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /><style> *,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0;padding:0}body{font-family:"Arial","Microsoft YaHei","黑体","宋体",sans-serif, system-ui, sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.5;font-size:1.4rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}code,pre{background:#ecedee}code{padding:.1rem}pre code{border:none}pre{padding:1rem;overflow-x:auto}img{max-width:100%}hr{background:#000;height:1px;border:0}header{flex-basis:13rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{font-style:italic;border-left:5px solid #ececec;padding-left:1rem}h1,h2,h3,h4,h5,h6{margin-bottom:.5rem;font-weight:bold;line-height:1.25;color:#313131;text-rendering:optimizeLegibility}h1{font-size:3rem}h2{margin-top:1rem;font-size:1.9rem}h3{margin-top:1.5rem;font-size:1.6rem}h4,h5,h6{margin-top:1rem;font-size:1.4rem}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:0.5rem}.posts ul,header ul{list-style:none}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}main{display:flex;flex-wrap:wrap;max-width:100rem;margin:2rem auto;padding:1rem}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:0.5rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}figcaption{font-size:smaller}</style></head><body><main role="main"><header role="banner"> <!--<h1 class="logo">技术人生</h1>--><nav role="navigation"><ul><li><a href="/" >主页</a></li><li><a href="/about" >关于我</a></li><li><a href="/search" >文章搜索</a></li><li><a href="/tag/书籍著作/" >书籍著作</a></li><li><a href="/tag/Unity3D/" >Unity3D</a></li><li><a href="/tag/游戏通用模块/" >游戏通用模块</a></li><li><a href="/tag/前端技术/" >前端技术</a></li><li><a href="/tag/后端技术/" >后端技术</a></li><li><a href="/tag/其他技术/" >其他技术</a></li><li><a href="/tag/金融投资/" >金融投资</a></li><li><a href="/tag/life/" >思路探讨</a></li><li><a href="/tag/英文文章/" >英文文章</a></li><li><a href="/tag/读书笔记/" >读书笔记汇总</a></li><li><a href="/tag/每日读书笔记/" >每日读书笔记</a></li><li><a href="/tag/给女儿写信/" >给女儿写信</a></li><li><a href="/engineer-shopping" >成长必需品</a></li><li><a href="/friendlink" >友情链接</a></li><li><a href="/atom.xml" >Rss</a></li><li><a href="https://github.com/luzexi" >GitHub</a></li></ul></nav></header><section class="post"><h2>《Unity3D高级编程之进阶主程》第八章 AI(2)-用行为树构建AI</h2><p>前面讲了用状态机来构建游戏中的怪物AI，由于它易于理解，容易被人类接受，扩展性和耦合性都很好，所以状态机的用途很广泛。但是状态机也有很大的缺点，就是不能处理和模仿太复杂的智能行为，比如模拟一个人类奔赴一场大型战役中，对战场中的各种繁多的突发事件做出符合人类模式的处理，这种方式状态机就无能为力，由于突发情况太多，组合起来的突发情况更多，做出反应的方式也变化多端，用人类思维逻辑去编写每个状态，状态的数量就会如指数级攀升无法应付，不止人类大脑无法应付这么复杂的逻辑编写，这样复杂的逻辑也很难有效维护。</p><p>===</p><p>行为树很好的弥补了状态机的缺点，它简化了逻辑拼凑的方式，让脑容量有限的人类能更容易编写和控制机器人的智能行为。这也是AI架构的关键点，能够让人更加简单容易的制作复杂的人工智能的行为，可以说是‘化繁为简’。</p><p>‘化繁为简’是我们的大部分编程时的重点，尤其在AI设计上，人工智能的行为方式大都是由人类头脑指定的行为方式，是人类头脑所预期的行为。制作出人类所预期的AI行为逻辑，并且制作的方式和过程又在人类大脑的承受范围内的是我们所预期的。状态机的方式制作AI理论上可以实现任何AI，但复杂到一定程度人脑无法承受，其实就是低效的或者说低阶的AI。行为树的优势就在这里，能够通过一些简单的操作制作出达到人类所预期的足够复杂的机器人行为方式。</p><p>行为树的本质是树状节点，每个节点可以选择某种类型的功能节点，也可以选择某个叶子节点即没有子节点功能，功能节点以各种逻辑顺序来选择继续访问下面的子节点或者直接停止并返回结果给父节点，子节点的结果将给父节点作为参考以便继续运行相关逻辑，因此行为树本身就是一种树形的父子节点之间的逻辑结构，我们可以理解为节点逻辑，通过扩展节点的功能来实现复杂的行为逻辑。</p><p>下面我们来详细介绍行为树的组成。</p><p>行为树(Behavior Tree)具有如下的特性，它有4大类型的节点：</p><h6 id="1composite-node-复合节点">1，Composite Node 复合节点</h6><p>复合节点可详细的分为3种：</p><p>一种是Selector Node，即选择节点，它的节点规则是当执行本类型节点时，它将从头到尾迭代执行自己的子节点，如果遇到一个子节点执行后返回True则停止迭代，本节点向自己的上层父节点也返回True，否则所有子节点都返回False，那么本节点才向自己的父节点返回False。</p><p>另一种是Sequence Node，即顺序节点，它的节点规则是当执行本类型节点时，它将从头到尾依次迭代执行自己的子节点，如果其中一个子节点执行后返回False那么就立即停止迭代，同时本节点向自己的父节点也返回False，相反如果所有子节点都返回True，则本节点就向自己的父节点返回True。</p><p>还有一种是Parallel Node，即并发节点，它的节点规则是并发执行它的所有子节点。并发节点又分为三种策略，这与它们向父节点返回的值和并行节点所采取的具体策略有关即如下：</p><p>Parallel Selector Node，即并行选择节点，它的节点规则为执行完所有子节点，如果有一个子节点返回False则自己向父节点返回False，只有当所有子节点全返回True时自己才向父节点返回True。</p><p>Parallel Sequence Node，即并行顺序节点，它的节点规则为执行完所有子节点，如果有一个子节点返回True则自己向父节点返回True，否则只有当全部子节点返回False时自己才向父节点返回False。</p><p>Parallel Hybird Node，即并行混合节点，它的节点规则为执行完所有子节点，按指定数量的节点返回True或False后才决定返回结果。</p><p>并行节点提供了并发性，由于它可以在线程或协程级别提供并发操作，所以在性能上面有能够充分利用CPU提高性能。通常情况下，Parallel Node下会并行挂多个Action子树，或者挂多个条件节点以提供实时性。并行节点增加性能和方便性的同时，也增加了维护的复杂度。</p><p>除此以外为了进一步提高AI的复杂度和随机性，Selector 和 Sequence可以进一步提供非线性迭代的加权随机变种。比如，Weight Random Selector 即随机权重选择节点，每次执行不同的起点，提供了每次执行不同的First True Child Node的可能。而Weight Random Sequence 即随机权重顺序节点，则每次执行顺序不同，以提供了不同的随机迭代顺序，能使AI避免总出现可预期的结果让结果更加的随机化。</p><h6 id="2decorator-node-修饰节点">2，Decorator Node 修饰节点</h6><p>Decorator Node，即修饰节点，修饰节点的功能为将它的子节点执行后返回的结果值做额外修饰处理后再返回给它的父节点。</p><p>这里举几个修饰节点的例子便于读书者们理解，下面这些修饰节点都可以自定义创造出来，节点功能可以为五花八门，它们共同点为修饰子节点的结果，或者通过子节点的结果来运行逻辑。</p><pre><code>	反向修饰 Decorator Not，它的节点功能为将结果反置后返回上级处理，即当子节点为True时返回给自己父节点的则为False，反之子节点返回False时自己返回给父节点为True。

	直到失败修饰 Decorator FailureUntil，它的节点功能为子节点运行在指定的次数到达前一直向上级返回失败，指定次数后一直向上级返回成功。

	总是失败修饰 Decorator Fail，它的节点功能为无论子节点返回的结果是否为True都向上级返回False。

	计数修饰 Decorator Counter，它的节点功能为只运行子节点n次，运行计数超过n次后不再运行。

	时间修饰 Decorator Time，它的节点功能为在指定时间内运行子节点后都返回True，超出这个时间范围无论子节点返回什么结果都向上级返回False。		

	甚至Decorator Nothing 它的功能就是什么都不干，用来提前占个位置为后面的功能预留。
</code></pre><p>除了以上这些我们还可以创造出来更多种类型的节点，例如用来调试的日志(log)节点，告知开发者当前节点的位置及相关信息，或者循环修饰节点，循环执行子节点n次等等，我们可以根据项目的需求来增加必要的修饰节点逻辑。</p><h6 id="3condition-node-条件节点">3，Condition Node 条件节点</h6><p>Condition Node相对比较简单，条件满足则返回Ture，否则返回False。</p><p>各式各样的条件节点，都继承基础条件节点并且返回Ture或False。比较常用的条件节点例如，大于，小于，等于，与，或，判断True或False。由这些条件节点可以与变量组合成，判断血量的条件，距离判断的条件，状态判断的条件，时间间隔判断条件等，可以用于行为树AI中。</p><h6 id="4action-node-行为节点">4，Action Node 行为节点</h6><p>Action Node，通常都是最后的叶子节点，它完成具体的一次(或一小步)行为并视需求返回值。行为节点可以是执行一次得到的结果，也可以视为分步执行很多次的行为。例如向前行走这个行为可以一直被执行直到走出某个范围。</p><p>我们可以通过扩展行为节点让AI行为变得更为丰富多彩，行为节点也是自主定义角色行为的关键，它通常涉及角色行为的具体行为。常用的行为节点的例如，行走到目标地点的行为节点，追击目标的行为节点，使用物品的行为节点，撤退的行为节点，攻击目标的行为节点，防御动作的行为节点，释放某技能的行为节点等等。这些行为节点都可以根据我们项目的需要从基础的行为节点扩展而来的，行为节点是最丰富的节点库，大部分时间我们程序员也一直在修改和扩容行为节点以向AI行为提供更多丰富的可编辑行为内容。</p><h6 id="在行为树中任何节点被执行后必须向其上层的父节点报告执行结果成功true或失败false或running正在运行还在执行并未执行完毕例如行走到某目的地角色行走正在途中这简单的成功或失败或运行中的汇报原则被很巧妙地用于控制整棵树的决策方向">在行为树中任何节点被执行后，必须向其上层的父节点报告执行结果：成功True或失败False或Running正在运行(还在执行并未执行完毕，例如行走到某目的地，角色行走正在途中)，这简单的成功或失败或运行中的汇报原则被很巧妙地用于控制整棵树的决策方向。</h6><p>整棵行为树中，只有条件节点和行为节点才能成为叶子节点，也只有叶子节点才是需要特别定制的节点，而复合节点和修饰节点均用于控制行为树中的决策走向，所以有些资料中也统称条件节点和行为节点为Behavior Node 即表现节点，而复合节点和修饰节点为Decider Node 即决策节点。</p><p>行为树能够支撑起对复杂逻辑的AI的原因就是由于我们可以使用这些简单的节点去搭建一个庞大的AI行为树(也可以说是一个AI模型)。我们程序员很容易的扩展节点来丰富AI节点库，无论是复合节点、修饰节点、条件节点、还是行为节点在扩展时都是相对容易的且有良好的耦合性的，这使得我们在壮大AI行为时节点的功能性扩展变得很容易，而拼装这些节点形成一个完整的AI行为就如同是一个搭积木的过程，人脑能搭建多复杂的积木就能搭建起多复杂的行为树AI。</p><p>决策树也是与行为树相似的AI解决方案。决策树和行为树一样都是树形结构叶都是由节点构成。在决策树中决策的构成是由树形结构的头部开始，从上往下一路判断下去决策该往哪走，最后一定会执行到叶子节点，进而确定当次行为的动作。在决策树中只有叶子节点才决定了如何行动，而且在决定后的行动中无法中途退出，必须等到当次行为执行完毕或者被打断后才能开始下一次决策。从理念上讲，决策树就是为了制定决策，而行为树是为了控制行为，它们是两个不同的理念。行为树更加注重变化，而决策树则更加注重选择。因此行为树可以定制比决策树更加复杂的AI逻辑，而实现的难易程度上比较行为树并没有增加多少。</p><h6 id="行为树比状态机更容易编写复杂的ai逻辑很大程度上是得益于单个节点的易扩展性状态机的每个状态的扩展难度相对比较难从人们拼装节点组合的角度看ai树的可搭建更加丰富多彩的ai行为而且它的搭建行为需要的能力也都是在人脑的可及范围内而状态机对于稍微复杂点的ai行为搭建则非常费力不仅需要更多的硬编码支撑而且状态间的连线也容易让人陷入困惑">行为树比状态机更容易编写复杂的AI逻辑很大程度上是得益于单个节点的易扩展性，状态机的每个状态的扩展难度相对比较难。从人们拼装节点组合的角度看，AI树的可搭建更加丰富多彩的AI行为，而且它的搭建行为需要的能力也都是在人脑的可及范围内，而状态机对于稍微复杂点的AI行为搭建则非常费力，不仅需要更多的硬编码支撑而且状态间的连线也容易让人陷入困惑。</h6><p>不过再厉害的人脑在搭建行为树AI时也有极限的搭建复杂度，无论你对搭建行为树这项技能有多么熟练多么精通都有到一个极限的状态。当搭建的复杂度超出人类大脑的时候我们就会陷入混乱，或者说无法完成更加复杂的AI行为。例如如果想完全模拟人类的思维判断逻辑，对不同的人，对不同的事，对不同的景色，对不同的物体，不同的路面，以及以上混合组合的不同组合作出应对策略，就完全超出了人类大脑搭建的极限。像这种特别复杂，完全不能由人类大脑通过搭建的方式形成的AI，我们就需要引入‘机器学习’技术，它不再由人来制定行为方式而是通过对案例的学习，从而获得更多更复杂的环境应对方式。</p><p>参考:</p><p>《使用行为树(Behavior Tree)实现游戏AI》by AKara 2010</p><span class="meta"><time datetime="2019-03-28T00:00:00+08:00">March 28, 2019</time> &middot; <a href="/tag/书籍著作">书籍著作</a>, <a href="/tag/Unity3D">Unity3D</a>, <a href="/tag/前端技术">前端技术</a></span> <!--<span class="meta"><time datetime="2019-03-28T00:00:00+08:00">March 28, 2019</time> &middot; <a class="post" href="/tag/书籍著作">书籍著作</a>, <a class="post" href="/tag/Unity3D">Unity3D</a>, <a class="post" href="/tag/前端技术">前端技术</a></span> --><div><p /><p>感谢您的耐心阅读</p><p>Thanks for your reading</p><p /> <script type="text/javascript" src="/assets/js/tctip-1.0.3.min.js"></script> <script> new tctip({ top: '50%', button: { id: 9, type: 'zanzhu' }, list: [ { type: 'alipay', qrImg: '/assets/common/alipay.jpg' }, { type: 'wechat', qrImg: '/assets/common/wechatpay.jpg' }, { type: 'bitcoin', qrContent: '1ErCFmtoQY2KDctjgPALZri3USsMqdSvqh' } ] }).init() </script><li><p><strong><font color="red">版权申明</font></strong></p><p><strong><font color="red">本文为博主原创文章，未经允许不得转载:</font></strong></p><p><a href = "http://www.luzexi.com/2019/03/28/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-AI2">《Unity3D高级编程之进阶主程》第八章 AI(2)-用行为树构建AI</a></p><p><strong><font color="red">Copyright attention</font></strong></p><p><strong><font color="red">Please don't reprint without authorize.</font></strong></p></li><li><p></p><p></p><p><image src="/public/qrcode_for_gzh.jpg" /></p><p><strong>微信公众号，文章同步推送，致力于分享一个资深程序员在北上广深拼搏中对世界的理解</strong></p><p></p><p></p><p>QQ交流群: 777859752 (高级程序书友会)</p></li></div><p /><div class="related"><div class="bshare-custom icon-medium-plus"><div class="bsPromo bsPromo2"></div><a title="分享到微信" class="bshare-weixin" href="javascript:void(0);"></a><a title="分享到新浪微博" class="bshare-sinaminiblog"></a><a title="分享到QQ好友" class="bshare-qqim" href="javascript:void(0);"></a><a title="分享到QQ空间" class="bshare-qzone" href="javascript:void(0);"></a><a title="分享到Twitter" class="bshare-twitter" href="javascript:void(0);"></a><a title="分享到Facebook" class="bshare-facebook" href="javascript:void(0);"></a><a title="更多平台" class="bshare-more bshare-more-icon more-style-addthis"></a></div><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/buttonLite.js#style=-1&amp;uuid=36b4f383-d948-41a3-acd5-31ae604e3ad8&amp;pophcol=2&amp;lang=zh"></script><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/bshareC0.js"></script></div><p /><div class="related"><h2>最新发表的文章</h2><ul class="related-posts"><li><h3> <a href="/2020/11/21/%E5%90%91%E5%86%85%E7%9C%8B%E8%87%AA%E5%B7%B110"> 向内看自己(十) 反思自己的行为带给人的感觉 <small>21 Nov 2020</small> </a></h3></li><li><h3> <a href="/2020/11/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B014"> 读书笔记(十二) 《深度探索C++对象模型》 <small>20 Nov 2020</small> </a></h3></li><li><h3> <a href="/2020/11/13/%E5%AE%89%E5%8D%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7Simpleperf%E8%AF%A6%E8%A7%A3"> 安卓性能分析工具Simpleperf详解与应用 <small>13 Nov 2020</small> </a></h3></li></ul><h2 color='blue' >之后发表的文章</h2><ul class="related-posts"><li><h3> <a href="/2019/04/27/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB5"> 《Unity3D高级编程之进阶主程》第五章，3D模型与动画(四) - 3D模型的变与换2 <small>27 Apr 2019</small> </a></h3></li><li><h3> <a href="/2019/04/21/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB4"> 《Unity3D高级编程之进阶主程》第五章，3D模型与动画(四) - 3D模型的变与换1 <small>21 Apr 2019</small> </a></h3></li><li><h3> <a href="/2019/04/13/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A823"> 思路探讨(二十三) 997成就世界 <small>13 Apr 2019</small> </a></h3></li><li><h3> <a href="/2019/04/07/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-AI3"> 《Unity3D高级编程之进阶主程》第八章 AI(3) 非典型性AI <small>07 Apr 2019</small> </a></h3></li><li><h3> <a href="/2019/03/31/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A822"> 思路探讨(二十二) 人为什么做不出最正确的选择 <small>31 Mar 2019</small> </a></h3></li><h2>之前发表的文章</h2><ul class="related-posts"><li><h3> <a href="/2019/03/17/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A821"> 思路探讨(二十一) 生存之战 <small>17 Mar 2019</small> </a></h3></li><li><h3> <a href="/2019/03/10/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-AI1"> 《Unity3D高级编程之进阶主程》第八章 AI(1)-状态机构架机器人行为 <small>10 Mar 2019</small> </a></h3></li><li><h3> <a href="/2019/02/19/you-can-live-your-dream"> YOU CAN LIVE YOUR DREAM! <small>19 Feb 2019</small> </a></h3></li><li><h3> <a href="/2019/02/17/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-CSharp%E8%A6%81%E7%82%B9%E6%8A%80%E6%9C%AF6"> 《Unity3D高级编程之进阶主程》第一章，C#要点技术(六) 搜索算法 <small>17 Feb 2019</small> </a></h3></li><li><h3> <a href="/2019/02/04/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A820"> 思路探讨(二十) 如何将你的家庭与普通人拉开差距 <small>04 Feb 2019</small> </a></h3></li></ul></div></section></main><script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "//hm.baidu.com/hm.js?f3d58556a7396e715b3602ef6754cd91"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script></body></html>
