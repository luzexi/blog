<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta content="" name="description">


  <title>
    
      技术人生 &middot; www.luzexi.com
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css?version=20180701">
  <!-- <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface"> -->

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

  	<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          技术人生
        </a>
      </h1>
      <p class="lead">漫漫人生,记录点滴技术,始于2013</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item active" href="/">Home</a>

      

      <a class="sidebar-nav-item" href="/书籍著作/index.html">书籍著作</a>
      <a class="sidebar-nav-item" href="/Unity3D/index.html">Unity3D</a>
      <a class="sidebar-nav-item" href="/游戏通用模块/index.html">游戏通用模块</a>
      <a class="sidebar-nav-item" href="/前端技术/index.html">前端技术</a>
      <a class="sidebar-nav-item" href="/后端技术/index.html">后端技术</a>
      <a class="sidebar-nav-item" href="/其他技术/index.html">其他技术</a>
      <a class="sidebar-nav-item" href="/金融投资/index.html">金融投资</a>
      <a class="sidebar-nav-item" href="/life/index.html">Life</a>

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/Util-page.html">常用页面工具</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about.html">About Me</a>
          
        
      
        
      
        
          
            <a class="sidebar-nav-item" href="/engineer-shopping.html">程序员必需品</a>
          
        
      
        
      
        
          
            <a class="sidebar-nav-item" href="/friendlink.html">友情链接</a>
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
      
        
      
      
      <a class="sidebar-nav-item" href="https://github.com/luzexi">GitHub project</a>
      <a href="http://www.luzexi.com/assets/feed.xml">RSS feed</a>
      <!-- <span class="sidebar-nav-item">Currently v2.1.0</span> -->
    </nav>

    <p>&copy; 2019. All rights reserved.</p>
    <p>浙ICP备13028172号-1</p>
  </div>
</div>


    <div class="content container">
      <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2019/09/01/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A61.html">
        《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(一) - 图形学基础1
      </a>
    </h1>

    <span class="post-date">01 Sep 2019</span>

    <p>游戏项目除了逻辑，模块，框架，架构，算法，还需要图形学的支撑，很多人在业务层面打拼了很多年也始终无法突破的原因就是对图形学研究还不够深。</p>

<p>最终我们还是要面对图形的绘制和计算的，所以这块也是非常重要的部分，只是在使用了现代图形引擎之后，特别是使用了Unity3D之后，它为我们包装了很多工具和接口，用起来很方便，但就因为方便往往忘了图形学知识的重大意义。</p>

<p>其实缺哪块都不行，没有逻辑，不懂得各个模块的编写手法，不懂得框架的搭建，不懂架构，或者不懂算法，不懂图形学，都是在无法完整的体现一个优秀程序员的知识面的，特别是对于那些需要在一个项目中当起顶梁柱的主程同学，对于每个部分的都需要了如指掌，特别是图形学部分，因为它很容易被忽视，也特别需要我们静下心来学习、理解、掌握。</p>

<p>非常想从最最基本的讲起，但我们毕竟是一本面向中高级程序员的书，所以不在将更多篇幅用在对点，线，面，向量，坐标系等的文字说明和介绍上了。</p>

<p>我们特别挑出了比较重要部分与Unity3D结合的来细致讲解一下。</p>

<h3>Vector3 的意义</h3>

<p>Vector3 有，x，y，z三个变量，我们一眼就识别它是个代表坐标的数据。</p>

<p>不仅如此，其实它还可以代表 距离，速度，位移，加速度，还有方向。</p>

<p>两个Vector3变量a，b的相减，就能得到一个从b点到a点的向量c。</p>

<p>这个c是一个长度为a到b的距离并且具备b到a的方向的向量，c也同样是一个Vector3，那么为什么a，b就是坐标，c就是向量呢。</p>

<p>其实任何一个Vector3变量，确定它是坐标还是向量，全靠我们如何定义它。</p>

<p>我们可以定义a是坐标，也可以定义a是速度，至于如何定义怎么计算，全靠我们在后面的程序中怎么对待它。</p>

<p>速度，位移，加速度，也是同样的道理。我们再举个例子。</p>

<p>还是a，b定义为Vector3的坐标点，a减去b，除以1，可以认为我们向量除以了一个时间1秒得到了我们需要的有方向的速度。</p>

<p>再比如，a点减去b点，得到c向量，那么任意坐标加上c就会得到与a和b同样的相对位置的d点，那么c就成了位移。</p>

<p>如果现在是四个坐标a，b，c，d，当a减去b除以1秒得到了a到b的时的速度，那么b减去c除以1秒得到也是b到c时的速度，如果这两个速度再相减，依然是Vector3，而此时这个Vector3已经不再代表坐标和速度，而是一个由两个Vector3的速度得到的加速度了。</p>

<h6>赋予给Vector3什么样的意义全靠我们用它们来计算什么。</h6>

<p>我们挑选了几个Vector3比较重要的几何意义。</p>

<h3>Vector3点乘的几何意义</h3>

<p>向量a，与，向量b点乘的计算公式为</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    a·b = (x1,y1,z1)·(x2,y2,z2) = x1*x2 + y1*y2 + z1*z2
</code></pre></div>
<p>而点乘又有另外一个计算公式即为</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    a·b = ||a||*||b||*cos(β)
</code></pre></div>
<p>即用更直观的如图所示：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    脑补图片
</code></pre></div>
<p>图中a向量与b向量的夹角为β，a向量和b向量长度不变的情况下，计算出来的值越大，也就是β值越小，说明a和b的夹角越小。</p>

<p>相反，当计算出来的值越小，也就是β值越小，说明a和b的夹角越大。</p>

<p>当β大于90度时，计算出来的是一个负数，也就是b指向的方向其实与a指向的方向是相反的。</p>

<p>我们用这种方式可以用点乘得到一个判断依据，即当a和b点乘得到的数为正数时，两者的方向比较一致，并且在长度相同的情况下结果越大越一致，而当点乘结果为负数时，a和b两者的方向则是相反的，在长度相同的情况下，数值负得越厉害，相反的程度越一致。</p>

<p>除了方向判断外，我们还可以用点乘来计算出β的角度，即：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    β = arcos( (a·b) / (|a|*|b|) )
</code></pre></div>
<h3>Vector3叉乘的几何意义</h3>

<p>与Vector3点乘一样，Vector3的叉乘也是类似的向量与向量之间的计算公式，不同的是，叉乘的结果不再是一个数值，而是一个同样维度的向量。即：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    a x b = (a1, a2, a3) x (b1, b2, b3) = (a2*b3 - a3*b3, a3*b1 - a1*b3, a1*b2 - a2*b1)
</code></pre></div>
<p>两个向量a，b的叉乘，得到的是与a，b向量形成的平面垂直的向量c。</p>

<p>那么c的长度多少呢，其实a x b的长度等于向量的大小与向量的夹角sin值的积，即</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    |a x b| = |a|*|b|*sin(β)
</code></pre></div>
<p>即c的长度大小与a和b向量的夹角有关。这样看来，如果β为0时，即a和b是平行的，c就是0长度，当β为90度时，即a和b互相垂直时，a和b的叉乘长度就是a的模乘以b的模。</p>

<p>此外，|a x b|得到的|a|<em>|b|</em>sin(β)这个公式，就是a和b形成的四边形的面积值，即如图所示</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    脑补图片
</code></pre></div>
<p>图中四边形的体积公式其实是，|b| * h，那么h怎么得到呢，我们可以用|a| * sin(β) 得到，因此就有了这个公式的演变，即：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    四边形面积 = |b| * h

    由于 h = |a| * sin(β) 代入后 =&gt; 四边形面积 = |b| * |a| * sin(β)

    =&gt; 四边形面积 = |b| * |a| * sin(β) = |a x b|
</code></pre></div>
<p>经过几个公式的转换，我们得到向量叉乘后的模就是四边形的面积。在3D中也是同样适用，因为两个向量确定一个平面，所以两个向量可以确定给一个对等边四边形的平面，从而可以用叉乘可以算出他们的面积。</p>

<h3>向量之间的投影</h3>

<p>在几何计算过程中，我们经常用到‘投影’这种方式，在向量中投影也是常用的技巧。如图：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    脑补图片
</code></pre></div>
<p>图中向量b 往 向量a投影得到 c，其实c就是向量a乘以某个系数得到的。这个系数可以认为是c的模除以a的模得到的。即</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    c = a * (|c|/|a|)
</code></pre></div>
<p>我们不知道|c|的值，但是c和b的夹角β又能得到计算cos的公式即：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    cos(β) = |c|/|b|
</code></pre></div>
<p>于是</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    |c| = |b| * cos(β)
</code></pre></div>
<p>再套入到计算投影向量c的公式上去时，就变成了：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    c = a * (|b| * cos(β)/|a|)

    进一步 =&gt; c = a * (|b| * cos(β) * |a|/ |a| * |a|)

    由于 |b| * cos(β) * |a| 等于 a与b的点乘公式，于是就有了

    投影向量c =&gt; c = a * (a · b) / |a|^2
</code></pre></div>
<p>至此经历了几个公式的转换，得到了b向量向a向量投影，得到c向量的公式。</p>

<h3>矩阵的意义</h3>

<p>矩阵看起来比较玄乎，很多人看到矩阵这个词就头疼，其实耐下心来研究，会发现矩阵是很可爱的。</p>

<p>矩阵五花八门，这些五花八门的矩阵使用频率非常低，我们常用矩阵其实没几种。</p>

<p>在图形学计算中，我们常用的矩阵大小是2x2，3x3，4x4 矩阵，这种行与列的数量相同的矩阵，我们称为‘方阵’矩阵。</p>

<p>在众多方阵矩阵中，常用到也是一些比较特殊的矩阵。如对角矩阵，即只有行列号相同的位置有数字，其他位置都是0的方阵矩阵。</p>

<p>以及单位矩阵，即行列号相同的对角线上的数字都为1，其他位置都为0的方阵矩阵。</p>

<p>这两种特殊的矩阵因它们简单易懂在图形学计算过程中也是非常常用的矩阵。</p>

<p>矩阵间的计算我们可以罗列一下其实并不多。</p>

<p>转置矩阵，就是把矩阵沿着对角线翻转一下，由于我们常用的是‘方阵’矩阵，所以转置矩阵后方阵矩阵还是同样的大小，只不过对角线两侧的数字对调了一下。</p>

<p>矩阵乘法，如果是数字和矩阵相乘则，直接带入矩阵中的所有变量即可，这种标量的乘法其实就是扩大矩阵中所有的数值。</p>

<p>如果矩阵与矩阵相乘则，A矩阵 x B矩阵，则需要一些附加条件，即矩阵A的列数必须与矩阵B的行数相等，否则无法相乘或者说相乘无意义。</p>

<p>矩阵相乘后得到的矩阵，里面每个位置Cij(即C矩阵的第i行第j列)都是A矩阵的第i行向量与B矩阵的第j列向量点乘的计算结果，如下我们拿2x2方阵相乘做示意：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    A x B = [a11, a12]  x  [b11, b12]
            [a21, a22]     [b21, b22]

    = [a11*b11 + a12*b21, a11*b12 + a12*b22]
      [a21*b11 + a22*b21, a21*b12 + a22*b22]
</code></pre></div>
<p>上图对矩阵乘法公式做出了很简单易懂的描述，即Cij = Ai1 * B1j + Ai2 * B2j + Ai3 * B3j ... 即A的i行向量与B的j列向量点乘的值。</p>

<p>逆矩阵，逆矩阵由运算矩阵相乘而来，由于矩阵与矩阵相乘也会得到标准的单位矩阵，即对角线都是1其余都是0的方阵矩阵，于是就有了一个矩阵与某个矩阵相乘等于单位矩阵时，这‘某个’矩阵就是该矩阵的‘逆矩阵’。</p>

<p>然而不是每个矩阵都有逆矩阵的，一个明显的例子是若矩阵的某一行或列上的元素都是0，用任何矩阵乘以该矩阵，结果都是一个零矩阵。因此我们通常称一个有逆矩阵的矩阵为这个矩阵可逆，相反如果这个矩阵没有逆矩阵，那么就称这个矩阵不可逆。</p>

<p>最后我们了解一下齐次矩阵，齐次矩阵也并没有什么神秘的，只不过是从我们认知的角度上划分了矩阵分量和w分量。</p>

<p>齐次矩阵由齐次空间而来，我们由浅入深来理解齐次矩阵会更加容易。</p>

<p>在二维空间中，(x,y)只能代表平面上的一个点，或平面上的向量，无法表达不同平面的点和向量，当如果需要表达不同平面的点就需要扩容维度，齐次向量就起到了这个作用。</p>

<p>齐次向量中有3个分量，即(x, y, w)，x，y分量和第三个神秘的w。</p>

<p>为了能更加容易的理解w分量存在的意义，我们可以把w分量想象是不同平面的代表，即当w = 1的平面是标准平面，即(x, y, 1)为标准平面中的x,y坐标点，这个点在w = 1的这个平面中。</p>

<p>当w不是1时，就是不同平面的上的点，如果想要将坐标投影到w = 1的平面上去，就需要除以w分量，即齐次坐标(x, y, w)映射在二维平面中标准坐标系中时为(x/w, y/w)。</p>

<p>同样的道理，在三维空间中(x, y, z)只能代表标准坐标系中的点和向量，无法表达非标准坐标系，齐次向量补充了它的缺陷，齐次向量坐标为(x, y, z, w)，当w = 1时，我们可以认为xyz坐标是在标准三维空间中，当w != 1时，则认为xyz是在其他空间当中的点，如果想要将它们坐标映射到标准三维空间中去，则只要除以w，即(x/w, y/w, z/w)，就是实际在标准空间上的点。那么当 w = 0时怎么办，我们则认为它是‘无限远的点’，它描述的是一个方向而不是一个坐标位置。</p>

<h3>由矩阵带来的旋转，缩放，投影，镜像，和仿射。</h3>

<p>很多人都难以理解，矩阵为什么能做到旋转和缩放，或者怎么理解矩阵的旋转和缩放，这节我们就来用最通俗易懂的方式讲讲如何理解矩阵的旋转和缩放。</p>

<h6>我们先来了解下，向量与矩阵的乘法。</h6>

<p>首先我们要明白，我们用的都是方阵矩阵，即2x2，3x3，4x4的矩阵。由于矩阵与矩阵相乘必须是前置的列与后置的行数要相等才有意义，向量与矩阵相乘也是一样，如果向量不是前置的那个即左乘矩阵，或者向量是以竖列表达方式右乘矩阵，对于向量与矩阵的乘法来说都是无意义的，即如下图所示：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    脑补图片
</code></pre></div>
<p>图中，第一个例子，当向量左乘矩阵，是无定义的结果，第二个例子，向量以竖列的表达方式右乘矩阵，也是无定义的结果，只有第三个例子和第四个例子，向量横向表达右乘矩阵，或竖向表达左乘矩阵，才有意义。</p>

<p>最终我们得出了向量与矩阵的乘法公式结果为：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    (x*m11 + y*m21 + z*m31, x*m12 + y*m22 + z*m32, x*m13 + y*m23 + z*m33)
</code></pre></div>
<p>至于向量的行向量的表达方式，和列向量的表达方式，其实都是可以行得通的，那么我们为什么要选择行向量呢，因为行向量表达更方便，无论是书写还是计算，行向量更加适合我们人类的习惯，因此我们选择了行向量来表达向量。</p>

<h6>如何理解旋转矩阵</h6>

<p>我们从 2x2 矩阵讲起，因为比起3x3矩阵2x2矩阵更加容易理解，而它们的原理一样。假设一个 2x2 的矩阵即</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    [2, 1]
    [-1,2]
</code></pre></div>
<p>我们可以认为它是由两个行向量a,b构成，a为(2,1)，b为(-1,2)，即</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    [2, 1]  等  [a]
    [-1,2]  于  [b]
</code></pre></div>
<p>在平面坐标系中，a和b的表达如图：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    脑补图片
</code></pre></div>
<p>图中a，b向量表达在2D坐标系中，是两个互相垂直的线段向量。</p>

<p>我们把这两个a,b向量可以看做是，从两个标准向量(1,0)和(0,1)旋转并且放大过来的向量，即如图下所示：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    脑补图片
</code></pre></div>
<p>图中，(1,0)和(0,1)向量，缓缓的旋转，并且放大，逐步变成了(2,1)和(-1,2)，即从原来的(1,0)和(0,1)向量上，旋转了β度并放大了2.236倍。</p>

<p>这就是矩阵的几何解释，其实从形象简单，对于标准矩阵来说，旋转多少缩放多少，最终形成了另一个矩阵，这个结果矩阵就是我们需要的‘变换矩阵’。</p>

<p>对于任何一个向量来说，乘以‘变换矩阵’就能得到‘变换矩阵’所要表达的旋转和缩放值，即</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    [2, 1]
    [-1,2]
</code></pre></div>
<p>如果这个矩阵表达了，向量旋转β度和2.236倍的缩放，那么任何二维向量乘以这个矩阵，就会得到在标准坐标系中以标准轴为基准旋转β度，并且以标准轴为基准放大2.236倍。</p>

<p>这样一个看起来无关紧要的矩阵还是不够直观，我们来看看更直观的表达方式，如果一个矩阵要表达旋转β度，那么它的a,b的向量该是如下图：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    脑补图片
</code></pre></div>
<p>a就是 [cosβ, sinβ]，b就是 [-sinβ, cosβ]，它们分辨表达了标准向量(1,0)和(0,1)旋转β度后的向量。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    [cosβ,  sinβ]
    [-sinβ, cosβ]
</code></pre></div>
<p>因此任何向量乘以这个这个旋转矩阵都会在标准坐标系中以标准轴为基准旋转β度。</p>

<h6>理解了二维空间的矩阵旋转原理，我们延伸到三维空间就容易多了。</h6>

<p>三维空间的矩阵也可以像二维空间一样理解，用三个向量来表示空间中的矩阵，即</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    [a]   [Ax, Ay, Az]
    [b] = [Bx, By, Bz]
    [c]   [Cx, Cy, Cz]
</code></pre></div>
<p>一个绕x轴旋转β度的旋转矩阵为：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    [1, 0,     0]
    [0, cosβ,  sinβ]
    [0, -sinβ, cosβ]
</code></pre></div>
<p>那么一个绕y轴旋转β度的旋转矩阵为：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    [cosβ, 0, -sinβ]
    [0, 1, 0]
    [sinβ, 0, cosβ]
</code></pre></div>
<p>于是一个绕z轴旋转β度的旋转矩阵为：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    [cosβ, sinβ, 0]
    [-sinβ, cosβ, 0]
    [0, 0, 1]
</code></pre></div>
<p>用β度所形成的向量来表达坐标空间中的旋转矩阵，这样的表达可以帮助我们更加清晰的理解旋转矩阵的几何表达意义。</p>

<p>上述只是对某一个轴进行旋转β度，如果我们要对某个向量做各个方向轴上的旋转，比如在x轴上旋转20度，再在y轴上旋转30度，最后在z轴上旋转15度，相当于这个向量在坐标系中旋转了20°,30°,15°，这时我们该怎么办？</p>

<p>有了上述对各轴的旋转矩阵，我们就能很容易计算出各方向上的矩阵，就如上面提的问题，在各轴上都有旋转角度，我们就可以用先旋转x轴，再旋转y轴，最后旋转z轴的方式，来计算最后的结果，如图：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    脑补
</code></pre></div>
<p>图中，c向量乘以x轴旋转矩阵，再乘以y轴旋转矩阵，最后乘以z轴旋转矩阵，即：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>c * Mx * My * Mz = c`(旋转后的结果)
</code></pre></div>
<p>其中Mx为以x轴为基准旋转20度的旋转矩阵，My为以y轴为基准旋转30度的旋转矩阵，Mz为以z轴为基准旋转15度的旋转矩阵。c乘以Mx得到旋转x轴后的向量，再乘以My得到旋转y轴后的向量，最后乘以Mz得到旋转z轴后的向量，最终得到结果。</p>

<h6>绕任意轴旋转</h6>

<p>绕标准轴即x轴，y轴，z轴旋转，得到的矩阵还远远不够我们需要的计算，很多时候我们需要计算绕任意向量或者说绕任意轴的计算公式。</p>

<p>让我们导出绕轴 N 旋转角度 β 的矩阵，即这个公式为 F(N, β)，也就是说这个公式满足:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    v * F(N, β) = v&#39; (v向量绕 N 轴，旋转β度后的结果v‘)
</code></pre></div>
<p>怎么解这个公式呢，其中v已知，N已知，β已知，还需要知道哪些变量，如图所示：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    脑补图片
</code></pre></div>
<p>图中，v 到 N 的投影分量可以计算得到 v1，进而可以计算得到 v 到 v1 的垂直向量 v2，最后用垂直向量 v2 与角度 β 可以计算得到 v’ 与 v 到 N 的投影分量的垂直向量 v‘’，最后由 v‘’ 和 v1 计算得到 v‘。</p>

<p>其中用到的计算方式有，向量投影计算公式，向量旋转计算公式，垂直向量计算公式，最后结果为：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>    脑补图片
</code></pre></div>
<p>一个看起来很复杂的，其实只要一步步推导就能得到的结果矩阵。</p>

<p>参考资料：</p>

<p>《3D数学基础:图形与游戏开发》</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2019/08/17/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E5%9C%B0%E5%9B%BE%E4%B8%8E%E5%AF%BB%E8%B7%AF4.html">
        《Unity3D高级编程之进阶主程》第十章，地图与寻路(四) 地图的制作与优化
      </a>
    </h1>

    <span class="post-date">17 Aug 2019</span>

    <h3>地图的制作与优化</h3>

<p>场景的制作占到所有项目制作中非常大的一块工作内容，这里我们不说场景制作在美术层面上的制作技巧，我们来说说技术层面的。上节把地图编辑器说了一遍，这节我们就在地图编辑器之外说说，地图场景的制作与优化。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2019/08/10/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A827.html">
        思路探讨(二十七) 如何应对30岁的躁动
      </a>
    </h1>

    <span class="post-date">10 Aug 2019</span>

    <p><img src="/assets/%E9%87%91%E8%9E%8D/idea-talk-27.jpeg" alt="idea-talk 27"></p>

<p>最近对自己影响比较深的一段话。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2019/08/05/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E5%9C%B0%E5%9B%BE%E4%B8%8E%E5%AF%BB%E8%B7%AF3.html">
        《Unity3D高级编程之进阶主程》第十章，地图与寻路(三) 地图编辑器
      </a>
    </h1>

    <span class="post-date">05 Aug 2019</span>

    <p>对于任何游戏来说，地图与场景的是比较重要的，特别是对于中大型游戏来说，在地图和场景上花费的时间和精力占去了大部分。而对于大部分游戏类型来说，布置场景，优化场景，甚至为场景写个编辑器是必不可少的，我们通常称他们为‘地图编辑器’。</p>

<p>地图编辑器有哪几种实现方式，该如何实现，顺便讲一讲从哪些方面下手优化场景，我们这节就来讲讲关于地图的事。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2019/07/26/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E5%9C%B0%E5%9B%BE%E4%B8%8E%E5%AF%BB%E8%B7%AF2.html">
        《Unity3D高级编程之进阶主程》第十章，地图与寻路(二) 寻路网格的构建
      </a>
    </h1>

    <span class="post-date">26 Jul 2019</span>

    <h3>寻路网格构建</h3>

<p>上一节我们了解了A星寻路的算法及其优化，A星寻路只是算法，需要配套的模块和工具链支撑，单独的一个A星无法运作因为它只是一个算法。</p>

<p>需要什么样的模块和工具链呢，我们这节就来讲一讲，最重要的配套模块‘寻路网格构建’。除了网格构建外，还有动态障碍物，以及地图和地形的构建，最后再配上A星寻路，才形成最终的地图和寻路。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2019/07/14/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%826.html">
        《Unity3D高级编程之进阶主程》第六章，网络层(六) - 网络同步解决方案
      </a>
    </h1>

    <span class="post-date">14 Jul 2019</span>

    <p>当前网络游戏中网络同步方案有三种，即状态同步，预测信息同步，帧同步。三种方式并不是完全互相排斥的，很多时候我们在开发的时候，为了能都让游戏显得更加逼真，会让多种的同步方案一起使用。例如魔兽世界这种开放世界的多人在线RPG游戏，就使用了状态同步和预测信息同步两种方案，绝地求生、和平精英等战地竞技类游戏，也同时使用了状态同步与预测信息同步方案，而传奇世界、热血传奇等传奇类游戏因为不需要预测信息就只使用状态同步，王者荣耀等一批5v5地图类竞技游戏则使用了帧同步方案。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2019/07/06/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A825.html">
        思路探讨(二十五) 困境中的中产
      </a>
    </h1>

    <span class="post-date">06 Jul 2019</span>

    <p>还是聊聊关于钱的事吧，人生哲学聊多了也没什么立竿见影的效果，能理解的瞬间就能懂，理解不了也只能等那灵光一现的时候。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2019/06/24/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A826.html">
        思路探讨(二十六) 我们真的聪明吗
      </a>
    </h1>

    <span class="post-date">24 Jun 2019</span>

    <h3>更多时候，我们不是败给了外界，而是败给了自己。</h3>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2019/06/22/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E5%9C%B0%E5%9B%BE%E4%B8%8E%E5%AF%BB%E8%B7%AF1.html">
        《Unity3D高级编程之进阶主程》第十章，地图与寻路(一) A星算法及优化
      </a>
    </h1>

    <span class="post-date">22 Jun 2019</span>

    <p>寻路一直是游戏项目中的热门功能，寻路算法用的最多的就是A星算法，其他也有，比如 Dijkstra算法 与 Floyd 算法，但是他们的在时间和空间上的复杂度都太高，Dijkstra算法时间复杂度为O(N^2)，空间复杂度也是O(N^2)，Floyd的时间复杂度更高有O(N^3)，空间复杂度也在O(N^2)，这种复杂度的算法寻路算法如果应用在游戏中稍微大一点的范围、大面积、稍微高一点的频率的寻路需求是CPU是无法承受的。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2019/06/16/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%825.html">
        《Unity3D高级编程之进阶主程》第六章，网络层(五) - 剖析数据协议原理
      </a>
    </h1>

    <span class="post-date">16 Jun 2019</span>

    <h6>协议包的格式，json, msgpack, protobuf 以及自定义格式</h6>

<p>项目的网路层在建设中，除了选择长短连接TCP，UDP，HTTP方式外，还需要选择在传输过程中使用什么样的协议格式。</p>

<p>前面分析了TCP，UDP，HTTP的原理与应用，现在我们来了解下在传输层和应用层之上的逻辑层中，信息传递格式的选择与利弊。</p>

<p>我们将深入剖析JSON，MessagePack，Protobuf的原理，包括它们都是由什么组成的，怎么序列化的，怎么反序列化的，数据格式究竟是由哪些元素构成的，使我们对网络数据协议的理解更加透彻清晰。</p>

<p>我们以最常见的JSON格式作为切入点，一步步深入了解更加有效却复杂的传递格式。</p>

  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page2">下一页</a>
  
  
    <span class="pagination-item newer">上一页</span>
  
</div>
    </div>

    
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?f3d58556a7396e715b3602ef6754cd91";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


    <script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

  </body>
  
</html>
