<!DOCTYPE html><html lang="en" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title> 游戏引擎架构#4 低阶渲染器（6） - 技术人生 - 编程技术 - JESSE人生</title><link rel="shortcut icon" href="/public/favicon.ico"><link rel="alternate" type="application/atom+xml" title="技术人生 - 编程技术 - JESSE人生" href="/atom.xml"><link rel="alternate" type="application/json" title="技术人生 - 编程技术 - JESSE人生" href="http://www.luzexi.com/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /><style> *,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0;padding:0}body{font-family:"Arial","Microsoft YaHei","黑体","宋体",sans-serif, system-ui, sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.5;font-size:1.4rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}code,pre{background:#ecedee}code{padding:.1rem}pre code{border:none}pre{padding:1rem;overflow-x:auto}img{max-width:100%}hr{background:#000;height:1px;border:0}header{flex-basis:13rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{font-style:italic;border-left:5px solid #ececec;padding-left:1rem}h1,h2,h3,h4,h5,h6{margin-bottom:.5rem;font-weight:bold;line-height:1.25;color:#313131;text-rendering:optimizeLegibility}h1{font-size:3rem}h2{margin-top:1rem;font-size:1.9rem}h3{margin-top:1.5rem;font-size:1.6rem}h4,h5,h6{margin-top:1rem;font-size:1.4rem}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:0.5rem}.posts ul,header ul{list-style:none}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}main{display:flex;flex-wrap:wrap;max-width:100rem;margin:2rem auto;padding:1rem}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:0.5rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}figcaption{font-size:smaller}.static_post{position:relative;padding-bottom:56.25%;padding-top:35px;height:0;overflow:hidden}.static_post iframe{position:absolute;top:0;left:0;width:100%;height:100%}</style></head><body><main role="main"><header role="banner"> <!--<h1 class="logo">技术人生 - 编程技术 - JESSE人生</h1>--><nav role="navigation"><ul><li><a href="/" >主页</a></li><li><a href="/about" >关于我</a></li><li><a href="/search" >文章搜索</a></li><li><a href="/tag/书籍著作/" >书籍著作</a></li><li><a href="/tag/Unity3D/" >Unity3D</a></li><li><a href="/tag/图解游戏引擎/" >图解游戏引擎</a></li><li><a href="/tag/游戏通用模块/" >游戏通用模块</a></li><li><a href="/tag/前端技术/" >前端技术</a></li><li><a href="/tag/后端技术/" >后端技术</a></li><li><a href="/tag/其他技术/" >其他技术</a></li><li><a href="/tag/金融投资/" >金融投资</a></li><li><a href="/tag/life/" >思路探讨</a></li><li><a href="/tag/英文文章/" >英文文章</a></li><li><a href="/tag/读书笔记/" >读书笔记汇总</a></li><li><a href="/tag/演讲/" >演讲</a></li><li><a href="/tag/给女儿写信/" >给女儿写信</a></li><li><a href="/engineer-shopping" >成长必需品</a></li><li><a href="/friendlink" >友情链接</a></li><li><a href="/atom.xml" >Rss</a></li><li><a href="https://github.com/luzexi" >GitHub</a></li></ul></nav></header><section class="post"><h2>游戏引擎架构#4 低阶渲染器（6）</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247485343&amp;idx=1&amp;sn=78ee7bce86f53c7ed5cb59d08a6a29f2&amp;chksm=fc226298cb55eb8e89b22caa781fa0ed21dbb196720d633f62855bfd4d3a4959b78c343ac54b&amp;token=39636778&amp;lang=zh_CN#rd">已发布在微信公众号上，点击跳转</a></p><h1 id="背景">背景：</h1><p>作为游戏开发从业者，从业务到语言到框架到引擎，积累了一些知识和经验，特别是在看了几遍《游戏引擎架构》、《游戏引擎原理与实践》后对引擎架构的理解又深入了些。近段时间有对引擎剖析的想法，正好借这两本书对游戏引擎的架构做一个完整的分析。</p><p>《游戏引擎架构》用简明、清楚的方式阐述引擎架构，知识覆盖了游戏引擎架构的庞大领域，巧妙地平衡了广度与深度，并且提供了足够的细节。《游戏引擎原理与实践》有两册内容比较详尽，代码示例展示比较多，内容比较丰富。</p><p>我结合这两本书以及自己的经验，写一些自己的知识总结以帮助自己学习引擎知识，文章中我会深入分析游戏引擎的历史、架构、模块，并通过引擎开发实践来完成对引擎知识的掌握。</p><p>游戏引擎知识面深而广，所以对这系列的文章书编写范围做个保护，不对细节进行过多的阐述，重点剖析的是架构、流程以及模块的运作原理。</p><h1 id="概述">概述：</h1><p>本系列文章对引擎中的重要的模块和库进行详细的分析，我挑选了十五个库和模块来分析：</p><ul><li>时间库</li><li>自定义容器库</li><li>字符串散列库</li><li>内存管理框架</li><li>RTTI与反射模块</li><li>图形计算库</li><li>资产管理模块</li><li>低阶渲染器</li><li>剔除与合批模块</li><li>动画模块</li><li>物理模块</li><li>UI底层框架</li><li>性能剖析器的核心部分</li><li>脚本系统</li><li>视觉效果模块</li></ul><p>本篇内容为列表中的第8个部分的第6节。</p><h1 id="正文">正文：</h1><p>简单回顾下前文</p><p>前几篇文章我们聊了GPU在计算机硬件主板中的位置与结构，知道了CPU、GPU的通信介质，手机上的主板结构。然后聊了下显卡的历史，图形驱动的历史，知道了GPU和图形接口在历史长河汇总的来龙去脉。接着聊了CPU的硬件架构，GPU硬件架构，以及GPU软件架构中的各个细节，其中还对比了GPU与CPU的相似与差异，大体明白了GPU是如何工作的。</p><p>下面我们开始这篇内容</p><p>本次内容会围绕GPU来写，从硬件架构到软件驱动再到引擎架构，目标是帮大家理解GPU硬件的运作原理，理解图形接口的架构，理解引擎低阶渲染器的架构。</p><p>目录：</p><ul><li>主板结构中的显卡</li><li>GPU功能发展史</li><li>GPU与CPU的差异</li><li>GPU硬件特点</li><li>图形驱动程序架构</li><li>引擎渲染架构</li><li>封装关系</li><li>图形API分类</li><li>引擎渲染流程拆解</li><li>渲染器的设计结构</li></ul><p>上篇聊了下图形驱动程序架构，它封装了各类显卡的驱动程序，根据描述的GPU指令和数据的流程图，我们能更好的理解驱动程序与GPU之间的责任划分与配合。接着为了能更好的理解低阶渲染器，先以统计和描述OpenGL接口的方式来了解和熟悉图形接口，本篇就继上一篇内容。</p><h2 id="二引擎渲染架构">二、引擎渲染架构</h2><p>本节重点介绍引擎中低阶渲染器的架构，包括渲染的封装关系、图形API的分类、引擎渲染流程的拆解、以及渲染器的设计结构，层层理解渲染架构是如何设计的。</p><h2 id="一封装关系">一、封装关系</h2><p>游戏的渲染从业务到引擎到图形API到操作系统到驱动程序到硬件经过层层的封装，每一层封装都是有意义的，每一层的封装的目的都有相通之处，都是更好的为上层提供服务。</p><p>游戏引擎需要封装图形API，让引擎开发者不用关心底层的图形API，图形API则要封装硬件驱动API，让引擎渲染器开发者不需要关心底层的硬件驱动API。如下图：</p><p>（渲染API层层封装图）</p><p>从上图中，我们看到每种硬件都有自己的驱动程序，因此操作系统中有很多硬件的驱动程序，图形API就封装了所有的硬件驱动接口，为引擎调用提供了方便。而图形驱动程序又有很多种，这使得图形API在调用时也会遇到不同平台带来的麻烦，因此引擎封装了所有平台的图形API，为引擎其他模块使用图形API时提供了方便。就这样层层封装，图形驱动程序封装了硬件驱动，引擎封装了图形驱动，最终更方便了开发者使用游戏引擎开发游戏。</p><h2 id="二图形api分类">二、图形API分类</h2><p>前文中我们描述了很多OpenGL的接口，我们可以通过对OpenGL接口的统计和描述，可以将所有的图形API可以划分成四部分：</p><p>（图形API模块划分图）</p><p>上图展示了四部分的内容，四部分包括：资源、状态、缓冲、接口</p><p>资源： 1.Shader着色器，相关图形接口 2.纹理贴图，相关图形接口 3.采样器，相关图形接口</p><p>状态： 1.视口，相关图形接口 2.光栅化，相关图形接口 3.Blend混合，相关图形接口</p><p>缓冲： 1.缓冲区，包括颜色缓冲、深度缓冲、模板缓冲，相关图形接口 2.顶点，相关图形接口 3.帧缓冲区对象（FBO），相关图形接口</p><p>接口： 1.图元绘制，相关图形接口 2.开关、查询、判断等通用接口，相关图形接口 3.其他非通用特殊接口</p><p>对其精简后可理解为如下：</p><ul><li>资源：Shader着色器、纹理贴图、采样器</li><li>状态：视口、光栅化、Blend混合</li><li>缓冲：顶点、缓冲区、帧缓冲对象（FBO）</li><li>接口：图元绘制、通用接口（开关、查询、判断等）、其他特殊接口</li></ul><p>现在，我们大致了解了图形API接口以及这些接口的分类，这样我们就能知道它到底可以做哪些事情，又是怎么去封装和定义驱动程序接口的。接着下面我们就来拆解下渲染流程以及渲染器。</p><h2 id="三引擎渲染流程拆解">三、引擎渲染流程拆解</h2><p>渲染流程是整个引擎的核心，使用UE4可以轻松实现好的渲染效果，但它的架构较封闭难以实现自定义光照模型，而Unity渲染架构比较开放，但默认渲染效果一般，用户需要按照Unity的规则自己去实现一套好的效果。对于渲染流程和材质上的设计两个引擎都有优缺点，如果我们想得到希望的结果，还要看我们对游戏引擎的掌握程度。</p><p>首先，我们来拆解下渲染的简易流程，对一个物体从加入渲染到最终渲染的过程进行拆解。</p><p>(引擎中简易的渲染流程拆解示意图)</p><p>如上图所示，一个物体的传统渲染流程如下： 1.渲染前置裁剪 2.前期数据整理 3.裁剪相机外物体 4.渲染准备工作 5.提交渲染指令</p><p>人们常说GPU中的渲染管线，实际上在GPU之前，引擎中的渲染管线非常重要，它就是引擎的渲染程序的执行过程。在引擎代码执行过程中，一个物体从加入渲染到最终提交渲染，这中间要经过以上5个阶段，包括前置裁剪，前期数据整理，裁剪相机外物体，渲染准备工作，提交渲染指令。</p><h3 id="渲染前置裁剪有很多方法包括遮挡剔除裁剪九宫格剔除裁剪远距离物体剔除裁剪等这些裁剪算法的应用可以根据业务场景不同而有所选择">渲染前置裁剪有很多方法，包括遮挡剔除裁剪，九宫格剔除裁剪，远距离物体剔除裁剪等。这些裁剪算法的应用可以根据业务场景不同而有所选择。</h3><p>前置数据整理，包括视口参数，节点整理，物体排序等。</p><h3 id="裁剪相机外物体引擎一般用aabb包剔除因为这是最快的剔除方法而且还可以多线程计算剔除每个要渲染的物体都会计算一个长方体aabb范围与相机的正交或透视范围进行相交计算">裁剪相机外物体，引擎一般用AABB包剔除，因为这是最快的剔除方法而且还可以多线程计算剔除，每个要渲染的物体都会计算一个长方体AABB范围，与相机的正交或透视范围进行相交计算。</h3><h3 id="渲染准备工作为渲染做准备包括数据检查shader解析深度图准备色彩空间设置相机设置等在真正渲染场景内物体前做好准备工作">渲染准备工作，为渲染做准备，包括数据检查，Shader解析，深度图准备，色彩空间设置，相机设置等，在真正渲染场景内物体前做好准备工作。</h3><h3 id="提交渲染指令把所有渲染的指令提交给gpu这里有两种情况一种是立即调用图形api设置渲染状态并最后告诉gpu指令提交完毕另一种是开线程提交">提交渲染指令，把所有渲染的指令提交给GPU，这里有两种情况，一种是立即调用图形API设置渲染状态并最后告诉GPU指令提交完毕，另一种是开线程提交。</h3><p>（引擎逻辑渲染流程图）</p><p>上图为商业引擎中的逻辑渲染管线（实际上还有很多节点为了编辑和展示场景服务的，我暂时忽略它们），这里我用红色标出了3个关键节点，包括剔除相机外物体，渲染ShowMaps，调用渲染指令，它们在这个逻辑渲染管线中是比较重要的。</p><h3 id="引擎会从循环总入口开始执行逻辑管线先检查数据与参数防止后面的逻辑执行出现异常接着针对每个视口做渲染多视口通常用于编辑器中多个窗口的渲染然后由于收集了所有camera对每个camera都执行一次渲染逻辑紧接着是ui渲染由于ui的特殊结构设计它会与普通物体分开渲染这里主要涉及到ui的渲染合批以及合批算法会在后面的章节中详细展开分析最后渲染结束清理数据">引擎会从循环总入口开始执行逻辑管线，先检查数据与参数防止后面的逻辑执行出现异常，接着针对每个视口做渲染（多视口通常用于编辑器中多个窗口的渲染），然后由于收集了所有Camera，对每个Camera都执行一次渲染逻辑，紧接着是UI渲染，由于UI的特殊结构设计，它会与普通物体分开渲染（这里主要涉及到UI的渲染合批以及合批算法，会在后面的章节中详细展开分析），最后渲染结束清理数据。</h3><p>（逻辑渲染管线分两种的图）</p><p>这里我着重提一下渲染Camera这个节点，它有两条线路可走。</p><h3 id="条是我们自定义的渲染管线这在unity商业引擎中就有这样的可编程逻辑渲染管线通过可编程逻辑渲染管线我们可以制定包括渲染物体的顺序针对某些特殊物体的渲染各种渲染效果的自定义处理这么做的结果可以让我们去除掉多余的渲染操作提高性能增加定制的渲染功能让逻辑渲染管线更符合我们当下的项目同时unity引擎在此基础上打造了更加方便更加易于使用的逻辑渲染管线即urp和hdrp当然可编程渲染管线不是万能因为引擎没有完全放手这块逻辑它保留了通用的和固定逻辑的功能模块从而减轻大家的编程负担如果要重写整个管线工作量就太大了">条是我们自定义的渲染管线，这在Unity商业引擎中就有这样的可编程逻辑渲染管线，通过可编程逻辑渲染管线，我们可以制定包括渲染物体的顺序、针对某些特殊物体的渲染、各种渲染效果的自定义处理，这么做的结果可以让我们去除掉多余的渲染操作提高性能，增加定制的渲染功能，让逻辑渲染管线更符合我们当下的项目。同时Unity引擎在此基础上打造了更加方便更加易于使用的逻辑渲染管线，即URP和HDRP。当然可编程渲染管线不是万能，因为引擎没有完全放手这块逻辑，它保留了通用的和固定逻辑的功能模块，从而减轻大家的编程负担（如果要重写整个管线工作量就太大了）。</h3><p>另一条是引擎固定的逻辑渲染管线，这条管线上包含了渲染需要的所有操作，包括数据准备、节点整理、相机外物体裁剪、渲染参数设置、深度图渲染、阴影图渲染、渲染状态提交等，通常是引擎根据所有渲染功能汇总编写的一套通用逻辑渲染管线。</p><p>(渲染管线中的三个要点图)</p><p>这里的逻辑渲染管线都有三个要点，第一个是剔除相机外物体，引擎会根据物体大小计算一个AABB包围盒，通过包围盒与相机正交或透视的计算得出它是否需要渲染。第二个是ShdowMaps绘制，在渲染物体前我们需要知道物体之间的遮挡关系才能计算出阴影，所以先让GPU跑一遍渲染管线计算每个像素点上物体的遮挡关系（这里简单介绍一下，后面在渲染效果章节再详细说明）。</p><p>第三个是设置和提交渲染状态，引擎把物体归类为不透明物体、半透明物体、以及天空盒和其他，把相同的几何物体放在一起渲染减少了渲染指令重复提交的开销，提高了运行效率。在提交渲染指令时有两个方法，两个方法最终都是调用相应平台的图形API，一是直接调用图形API，每当需要设置渲染状态、提交渲染指令时，直接调用相应平台的图形API，将操作立即告诉GPU（GPU中也有自己的队列）。二是将要改变的渲染状态和指令推入进线程队列中，再在另一个线程里取出队列中的渲染状态和指令，接着调用图形API通知GPU，这样做就是为了不阻塞主线程。</p><p>通常渲染引擎会把渲染线程和引擎主线程拆分开来，渲染线程单独处理渲染状态改变的指令，主线程和渲染线程之间则用队列通信，这个逻辑功能在Unity和Unreal中都有使用。</p><h2 id="四渲染器的设计结构">四、渲染器的设计结构</h2><p>前面我们介绍了逻辑渲染管线，主要说明的是逻辑渲染管线中做了什么事情，有哪些关键点，逻辑渲染管线最终都会嗲用图形API去提交渲染指令，这些都是引擎中渲染器要做的事情，下面我们来介绍下渲染器的封装与结构设计。</p><p>不同硬件通过不同驱动程序进行管理，图形API封装了很多驱动程序让开发者不必关心硬件驱动程序。引擎也是同样的作用，由于平台有很多种，图形API也有很多种，因此引擎需要封装图形API为渲染器，让开发者不用关心底层的图形API，这样引擎制作的游戏都可以发布到多个平台。</p><p>（图形API封装图）</p><p>为了拥有一个易用的多平台的可扩展的渲染器，引擎必须将图形API封装，也就是用对象的方式将部分渲染数据存储起来，在执行时立即使用并能减少不少渲染指令。</p><p>由于每个平台的API不同，因此封装时首先将不同平台的API封装成统一的接口，这要求我们在封装时不仅仅只是检查参数这么简单，还需要我们针对性的用面向对象的方式去设计图形API封装结构。其次每个平台都有自己特殊的功能和接口，需要额外做一些封装提供给引擎使用。</p><p>其中所有封装都可以归纳分类为4种类型，资源、缓冲、状态、接口。</p><h3 id="渲染资源属于api层的资源类型原始的api使用起来比较繁琐为了简化它的使用游戏引擎都会再封装一次资源类型的接口包括创建资源设置资源加载资源销毁资源">渲染资源属于API层的资源类型，原始的API使用起来比较繁琐，为了简化它的使用，游戏引擎都会再封装一次。资源类型的接口包括创建资源、设置资源、加载资源、销毁资源。</h3><h3 id="缓冲对象的目的是更方便开发者把内存数据复制到显存中状态对象的目的是为了记录当前状态并保留一份在主存中以减少同一个绘制管线中的重复设置接口的目的就是为了更方便开发者调用图形api">缓冲对象的目的是更方便开发者把内存数据复制到显存中，状态对象的目的是为了记录当前状态并保留一份在主存中，以减少同一个绘制管线中的重复设置，接口的目的就是为了更方便开发者调用图形API。</h3><p>（渲染指令的对象设计图）</p><p>渲染器是对图形API的进一步封装，用于提高资源的使用效率。通常我们用图形API实现一个功能要经过多个步骤。经过整合的渲染器接口，可以通过一两个步骤就可以实现原本需要多个步骤的功能。渲染器功能一般包括渲染窗口相关信息、创建资源、设置资源、销毁资源、获得显卡信息、完成渲染流程等。因此渲染器需要抽象出各种接口，以供子类去实现，这样就可以兼容各种渲染API。</p><p>上图中详细举例了渲染状态、渲染缓冲、渲染资源、逻辑状态信息。将他们在引擎中封装成对象，就是为了更好的加快渲染器中处理资源的速度，减少设置资源时耗费的CPU时间。同时为了达到这个目标，我们就需要管理这些资源对象。</p><p>额外话题，前面说到不同图形API不同平台设备有很多差异，这里就举个例子，简单介绍下DX12中的指令队列原理。</p><p>（DX12与GPU引擎协作原理）</p><h3 id="现在大部分新式gpu都包含多个功能的独立引擎例如复制引擎计算引擎3d引擎把原本提交的gpu指令大杂烩拆分并交给不同的引擎这样各大引擎可以根据自身情况做优化从而使得执行效率变得更高而且拆分后引擎可以并行执行指令也使得整体指令执行效率变高">现在大部分新式GPU都包含多个功能的独立引擎，例如复制引擎、计算引擎、3D引擎，把原本提交的GPU指令大杂烩拆分并交给不同的引擎，这样各大引擎可以根据自身情况做优化从而使得执行效率变得更高，而且拆分后引擎可以并行执行指令也使得整体指令执行效率变高。</h3><p>在使用DX12时，每个线程都会填入复制、计算和3D队列这三个队列，其中3D队列可以驱动另外两个GPU引擎，计算队列可以驱动计算和复制引擎，而复制队列只能驱动复制引擎。</p><p>（GPU中三大引擎工作原理，来源：微软官网）</p><p>上图说明了DX中的多引擎队列设计是如何跨多个GPU引擎协同工作的。它包括在必要时进行引擎间同步处理，因为引擎间有相互依赖的情况。 复制引擎会复制转译所需的几何，3D引擎会等候这些复本完成，并透过几何呈现预先传递。计算引擎会使用此结果并分派结果，同时复制引擎上一直在拷贝需要的资源，最终被3d引擎使用并进行最终绘制。</p><h2 id="参考资料">参考资料：</h2><p>《OpenGL ES3.0 编程指南》作者：金斯伯格</p><p>《游戏引擎架构》作者：杰森.格雷戈瑞</p><p>《游戏引擎原理与实践》作者：程东</p><p>《GPU 引擎》</p><p>https://docs.microsoft.com/zh-tw/windows/win32/direct3d12/user-mode-heap-synchronization</p><p>《CPU体系结构》</p><p>https://my.oschina.net/fileoptions/blog/1633021</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247485343&amp;idx=1&amp;sn=78ee7bce86f53c7ed5cb59d08a6a29f2&amp;chksm=fc226298cb55eb8e89b22caa781fa0ed21dbb196720d633f62855bfd4d3a4959b78c343ac54b&amp;token=39636778&amp;lang=zh_CN#rd">已发布在微信公众号上，点击跳转</a></p><span class="meta"><time datetime="2022-05-03T00:00:00+08:00">May 3, 2022</time> &middot; <a href="/tag/读书笔记">读书笔记</a>, <a href="/tag/图解游戏引擎">图解游戏引擎</a>, <a href="/tag/前端技术">前端技术</a></span> <!--<span class="meta"><time datetime="2022-05-03T00:00:00+08:00">May 3, 2022</time> &middot; <a class="post" href="/tag/读书笔记">读书笔记</a>, <a class="post" href="/tag/图解游戏引擎">图解游戏引擎</a>, <a class="post" href="/tag/前端技术">前端技术</a></span> --><div><p /><p>感谢您的耐心阅读</p><p>Thanks for your reading</p><p /> <script type="text/javascript" src="/assets/js/tctip-1.0.3.min.js"></script> <script> new tctip({ top: '50%', button: { id: 9, type: 'zanzhu' }, list: [ { type: 'alipay', qrImg: '/assets/common/alipay.jpg' }, { type: 'wechat', qrImg: '/assets/common/wechatpay.jpg' }, { type: 'bitcoin', qrContent: '1ErCFmtoQY2KDctjgPALZri3USsMqdSvqh' } ] }).init() </script><li><p><strong><font color="red">版权申明</font></strong></p><p><strong><font color="red">本文为博主原创文章，未经允许不得转载:</font></strong></p><p><a href = "http://www.luzexi.com/2022/05/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B059">游戏引擎架构#4 低阶渲染器（6）</a></p><p><strong><font color="red">Copyright attention</font></strong></p><p><strong><font color="red">Please don't reprint without authorize.</font></strong></p></li><li><p></p><p></p><p><image src="/public/qrcode_for_gzh.jpg" width="344" height="344" /></p><p><strong>微信公众号，文章同步推送，致力于分享一个资深程序员在北上广深拼搏中对世界的理解</strong></p><p></p><p></p><p>QQ交流群: 777859752 (高级程序书友会)</p></li></div><p /><div class="related"><div class="bshare-custom icon-medium-plus"><div class="bsPromo bsPromo2"></div><a title="分享到微信" class="bshare-weixin" href="javascript:void(0);"></a><a title="分享到新浪微博" class="bshare-sinaminiblog"></a><a title="分享到QQ好友" class="bshare-qqim" href="javascript:void(0);"></a><a title="分享到QQ空间" class="bshare-qzone" href="javascript:void(0);"></a><a title="分享到Twitter" class="bshare-twitter" href="javascript:void(0);"></a><a title="分享到Facebook" class="bshare-facebook" href="javascript:void(0);"></a><a title="更多平台" class="bshare-more bshare-more-icon more-style-addthis"></a></div><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/buttonLite.js#style=-1&amp;uuid=36b4f383-d948-41a3-acd5-31ae604e3ad8&amp;pophcol=2&amp;lang=zh"></script><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/bshareC0.js"></script></div><p /><div class="related"><h2>最新发表的文章</h2><ul class="related-posts"><li><h3> <a href="/2024/09/11/WUADay%E6%B8%B8%E6%88%8F%E8%A1%8C%E4%B8%9A%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A%E5%85%AC%E5%BC%80%E6%BC%94%E8%AE%B2"> UWADay游戏行业开发者大会公开演讲 - 游戏性能分析与挖掘 <small>11 Sep 2024</small> </a></h3></li><li><h3> <a href="/2024/07/29/%E5%9B%BE%E8%A7%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%A1%E7%90%86%E4%B8%8E%E5%AE%B9%E5%99%A8"> 图解游戏引擎 - 引擎基础知识（5）字符串管理与容器 <small>29 Jul 2024</small> </a></h3></li><li><h3> <a href="/2024/07/22/%E5%9B%BE%E8%A7%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%864%E4%BF%AE%E9%A5%B0%E7%AC%A6-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"> 图解游戏引擎 - 引擎基础知识（4）修饰符、原子操作与内存屏障 <small>22 Jul 2024</small> </a></h3></li></ul><h2 color='blue' >之后发表的文章</h2><ul class="related-posts"><li><h3> <a href="/2022/07/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B063"> 读书笔记(六十三) 如何做软件分析2 - 分析的模型 <small>10 Jul 2022</small> </a></h3></li><li><h3> <a href="/2022/07/03/%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%9B%98%E6%80%BB%E7%BB%93"> 《如何精彩演讲》#4 演讲比赛复盘总结 <small>03 Jul 2022</small> </a></h3></li><li><h3> <a href="/2022/06/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B061"> 读书笔记(六十一) 如何更好的沟通 - 沟通风格 <small>15 Jun 2022</small> </a></h3></li><li><h3> <a href="/2022/06/12/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A125"> 给女儿写信(二十五) 面对变化 <small>12 Jun 2022</small> </a></h3></li><li><h3> <a href="/2022/05/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B060"> 读书笔记(六十) 如何做软件分析1 - 建模 <small>18 May 2022</small> </a></h3></li><h2>之前发表的文章</h2><ul class="related-posts"><li><h3> <a href="/2022/05/02/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A124"> 给女儿写信(二十四) 沟通 <small>02 May 2022</small> </a></h3></li><li><h3> <a href="/2022/04/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B058"> 读书笔记(五十八) 如何讲好一个故事 - 点燃观众的想象力 <small>22 Apr 2022</small> </a></h3></li><li><h3> <a href="/2022/04/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B057"> 读书笔记(五十七) 如何讲好一个故事 - 识别与释放倾听障碍 <small>11 Apr 2022</small> </a></h3></li><li><h3> <a href="/2022/04/06/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A123"> 给女儿写信(二十三) 调整 <small>06 Apr 2022</small> </a></h3></li><li><h3> <a href="/2022/04/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B056"> 读书笔记(五十六) 如何讲好一个故事 - 挖掘与倾听 <small>05 Apr 2022</small> </a></h3></li></ul></div></section></main><script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "//hm.baidu.com/hm.js?f3d58556a7396e715b3602ef6754cd91"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script></body></html>
