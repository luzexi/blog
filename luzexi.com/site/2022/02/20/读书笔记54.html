<!DOCTYPE html><html lang="en" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title> 读书笔记(五十四) 《游戏引擎架构》#4 低阶渲染器（5） - 技术人生</title><link rel="shortcut icon" href="/public/favicon.ico"><link rel="alternate" type="application/atom+xml" title="技术人生" href="/atom.xml"><link rel="alternate" type="application/json" title="技术人生" href="http://www.luzexi.com/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /><style> *,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0;padding:0}body{font-family:"Arial","Microsoft YaHei","黑体","宋体",sans-serif, system-ui, sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.5;font-size:1.4rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}code,pre{background:#ecedee}code{padding:.1rem}pre code{border:none}pre{padding:1rem;overflow-x:auto}img{max-width:100%}hr{background:#000;height:1px;border:0}header{flex-basis:13rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{font-style:italic;border-left:5px solid #ececec;padding-left:1rem}h1,h2,h3,h4,h5,h6{margin-bottom:.5rem;font-weight:bold;line-height:1.25;color:#313131;text-rendering:optimizeLegibility}h1{font-size:3rem}h2{margin-top:1rem;font-size:1.9rem}h3{margin-top:1.5rem;font-size:1.6rem}h4,h5,h6{margin-top:1rem;font-size:1.4rem}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:0.5rem}.posts ul,header ul{list-style:none}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}main{display:flex;flex-wrap:wrap;max-width:100rem;margin:2rem auto;padding:1rem}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:0.5rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}figcaption{font-size:smaller}.static_post{position:relative;padding-bottom:56.25%;padding-top:35px;height:0;overflow:hidden}.static_post iframe{position:absolute;top:0;left:0;width:100%;height:100%}</style></head><body><main role="main"><header role="banner"> <!--<h1 class="logo">技术人生</h1>--><nav role="navigation"><ul><li><a href="/" >主页</a></li><li><a href="/about" >关于我</a></li><li><a href="/search" >文章搜索</a></li><li><a href="/tag/书籍著作/" >书籍著作</a></li><li><a href="/tag/Unity3D/" >Unity3D</a></li><li><a href="/tag/游戏通用模块/" >游戏通用模块</a></li><li><a href="/tag/前端技术/" >前端技术</a></li><li><a href="/tag/后端技术/" >后端技术</a></li><li><a href="/tag/其他技术/" >其他技术</a></li><li><a href="/tag/金融投资/" >金融投资</a></li><li><a href="/tag/life/" >思路探讨</a></li><li><a href="/tag/英文文章/" >英文文章</a></li><li><a href="/tag/读书笔记/" >读书笔记汇总</a></li><li><a href="/tag/演讲/" >演讲</a></li><li><a href="/tag/给女儿写信/" >给女儿写信</a></li><li><a href="/engineer-shopping" >成长必需品</a></li><li><a href="/friendlink" >友情链接</a></li><li><a href="/atom.xml" >Rss</a></li><li><a href="https://github.com/luzexi" >GitHub</a></li></ul></nav></header><section class="post"><h2>读书笔记(五十四) 《游戏引擎架构》#4 低阶渲染器（5）</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247485174&amp;idx=1&amp;sn=b8321c77f937537ce74fed145268f6c2&amp;chksm=fc2263f1cb55eae7d64f1343f6a8298e520cad81b574283dbd543970d59d60fb29716817d9aa&amp;token=537319754&amp;lang=zh_CN#rd">已发布在微信公众号上，点击跳转</a></p><h1 id="背景">背景：</h1><p>作为游戏开发从业者，从业务到语言到框架到引擎，积累了一些知识和经验，特别是在看了几遍《游戏引擎架构》后对引擎架构的理解又深入了些。</p><p>近段时间有对引擎剖析的想法，正好借这书本对游戏引擎架构做一个完整分析。</p><p>此书用简明、清楚的方式覆盖了游戏引擎架构的庞大领域，巧妙地平衡了广度与深度，并且提供了足够的细节。</p><p>借助《游戏引擎架构》这本书、结合引擎源码和自己的经验，深入分析游戏引擎的历史、架构、模块，最后通过实践简单引擎开发来完成对引擎知识的掌握。</p><p>游戏引擎知识面深而广，所以对这系列的文章书编写范围做个保护，即不对细节进行过多的阐述，重点剖析的是架构、流程以及模块的运作原理。</p><p>同时《游戏引擎架构》中部分知识太过陈旧的部分，会重新深挖后总结出自己的观点。</p><h1 id="概述">概述：</h1><p>本系列文章对引擎中的重要的模块和库进行详细的分析，我挑选了十五个库和模块来分析：</p><p>1.时间库 2.自定义容器库 3.字符串散列库 4.内存管理框架 5.RTTI与反射模块 6.图形计算库 7.资产管理模块 8.低阶渲染器 9.剔除与合批模块 10.动画模块 11.物理模块 12.UI底层框架 13.性能剖析器的核心部分 14.脚本系统 15.视觉效果模块</p><p>本篇内容为列表中的第8个部分的第5、6节。</p><h1 id="正文">正文：</h1><p>简单回顾下前文</p><p>前文我们聊了下显卡在计算机硬件主板中的位置与结构，知道了CPU、GPU的通信介质，并简单介绍了手机上的主板结构。本篇开头对上一篇做一些内容补充，PC和手机的不同硬件组织，以及CPU与其他芯片的通信过程。</p><p>下面我们开始这篇内容</p><p>本次内容会围绕GPU来写，从硬件架构到软件驱动再到引擎架构，目标是帮大家理解GPU硬件的运作原理，理解图形接口的架构，理解引擎低阶渲染器的架构。</p><p>目录：</p><p>主板结构中的显卡</p><p>GPU功能发展史</p><p>GPU与CPU的差异</p><p>GPU硬件特点</p><p>图形驱动程序架构</p><p>引擎低阶渲染架构</p><p>前面我们说了关于GPU硬件上的原理和运作机制，下面我们来讲一讲软件上的架构，尤其是渲染架构。</p><p>指令和数据从CPU到GPU最终到帧缓冲的这个过程中，有三种类型的架构，第一种是图形驱动程序的架构，第二种是引擎上的低阶渲染器架构，第三种是GPU上的软件架构。</p><p>这三种架构在互相配合，同时也是三个模块互相调用的过程。这也是为什么前面要提到这么多CPU与GPU硬件交互过程的原因。</p><p>为了更好的了解这三者，我又研读了一遍《OpenGL ES3.0 编程指南》，通过对OpenGL接口的解读和分析，逐步剖析图形驱动程序架构、引擎低阶渲染器架构、以及GPU软件架构，我认为这种方式是最合适的。</p><h2 id="一图形驱动程序架构">一、图形驱动程序架构</h2><p>我们使用的图形接口如OpenGL、Metal、DX的原理是基于驱动程序接口做的封装。因此，图形驱动调用接口有三步骤： 检查调用参数、检查硬件是否支持 接着调用硬件驱动程序接口 将数据推入缓冲Buffer</p><p>数据被推入缓冲，后续的详细路线如下图：</p><p>（GPU中的数据流向图）</p><p>GPU有线程来执行程序，线程通过Core来执行指令，每个线程的程序都是一样的，只是数据不同。 因此很好理解，GPU中有许多线程，每个线程执行的指令是一样的，从三角形处理到光栅化以及片元处理，都是顺序执行的指令。因此数据流也跟着顺序的指令走。最后到达帧缓存。</p><p>图形API适配了许多GPU驱动程序的接口，驱动程序先检查参数，再将指令推入队列，再刷新时将队列地址发送给GPU，GPU开始处理队列，由线程处理队列中的每个指令，每个线程拥有同样的程序，数据不断被处理，最后到达帧缓存。</p><p>在最上层的图形接口之上，引擎低阶渲染器会调用很多不同类型的图形接口，将数据塞入到缓冲中。下面就来详细描述下，引擎低阶渲染器的架构是怎样的。</p><h2 id="二引擎低阶渲染器架构">二、引擎低阶渲染器架构</h2><p>前面我们说，图形API封装了硬件驱动程序，会先检查再调用。</p><p>实际上，低阶渲染器也是一个封装图形API接口的程序，不同的是它封装的更适合渲染对象。</p><p>其封装的目的是让散乱的图形API变得更方便使用，同时还能够优化掉重复的计算。</p><p>这里首先我们来看下OpenGL ES图形API中的接口类型，通过了解图形API接口，能够想象出如果是我们自己来做低阶渲染器架构我们应该如何封装。所以，了解熟悉图形API对于低阶渲染器的架构非常重要。</p><p>下面是一些OpenGL的接口描述和统计，有些枯燥，如已熟悉可以直接跳到描述架构部分。</p><p>OpengGL接口描述与统计：</p><pre><code>状态开启和关闭，包括开启三角绘制、开启混合、开启模板等
glEnableXXX、glDisableXXX
</code></pre><pre><code>获取或查询某数据，包括获取数据，获取日志，获取结果等
glGetXXX
</code></pre><pre><code>绑定数据，包括绑定数据到着色器等
glBindXXX
</code></pre><pre><code>开始和结束某处理，包括开始变换反馈，查询数据等
glBeginXXX
glEndXXX
</code></pre><pre><code>清除缓冲
glClearXXX
</code></pre><pre><code>创建某对象，包括缓冲，数组，纹理，采样器对象等等
glGenXXX，glCreateXXX
</code></pre><pre><code>删除某对象，包括着色器对象，数组，纹理对象，采样器对象等等
glDeleteXXX
</code></pre><pre><code>还有其他的如:
glDrawXXX，绘制相关
glCopyXXX，拷贝复制相关
glCheckXXX，检查相关
glIsXXX，判断是否有效
......
</code></pre><p>下面按相关性划分为：</p><p>（着色器相关接口图）</p><pre><code>着色器相关：
创建着色器：glCreateShader
加载着色器代码：glShaderSource
编译着色器：glCompileShader
创建着色器程序：glCreateProgram
绑定着色器：glAttachShader
解绑着色器：glDetachShader
链接着色器程序：glLinkProgram
使用着色器程序：glUseProgram
删除着色器程序：glDeleteProgram
</code></pre><p>（视口相关接口图）</p><pre><code>视口相关：
设置视口：glViewport
设置视口裁剪深度：glDepthRangef
清除颜色缓冲：glClear
置换缓冲区：eglSwapBuffers
</code></pre><p>（顶点相关接口图）</p><pre><code>顶点相关：
通过创建缓冲区，可以把顶点数据加载到缓冲区，从而绘制顶点。

加载顶点属性：glVertexAttribXXX
绘制三角形：glDrawArrays，glDrawElements
启用/禁用顶点属性数组：glEnable/DisableVertexAttribArray
申请缓冲：glGenBuffers
指定缓冲：glBindBuffer
向缓冲填入数据：glBufferData，glBufferSubData
删除缓冲：glDeleteBuffers
创建顶点数组对象：glGenVertexArrays
绑定顶点数组：glBindVertexArray
删除顶点数组：glDeleteVertexArrays
映射并返回缓冲区数据：glMapBufferRange
取消映射缓冲区：glUnmapBuffer
刷新映射缓冲区：glFlushMappeBufferRange
复制缓冲区数据：glCopyBufferSubData
</code></pre><p>（图元绘制相关接口图）</p><pre><code>图元绘制相关：
绘制几何形状对象：glDrawArrays, glDrawElements, glDrawRangeElements,
绘制几何Instance：glDrawArraysInstanced, glDrawElementsInstanced
绘制线段：glLineWidth
</code></pre><p>（光栅化相关接口图）</p><pre><code>光栅化相关：
指定正面顺序：glFrontFace
剔除反面：glCullFace
多边形偏移：glPolygonOffset
</code></pre><pre><code>遮挡查询：glBeginQuery, glEndQuery, glGenQueries, glDeleteQueries, glGetQueryObjectuiv
遮挡查询用查询对象来跟踪通过深度测试的片段或样本。
</code></pre><p>顶点着色器相关：</p><pre><code>内建特殊变量：
gl_VertexID，当前顶点整数索引
gl_InstanceID，当前图元实例编号
gl_Position，输出顶点
gl_PointSize，点精灵尺寸
gl_FrontFacing，是否正面的布尔值
</code></pre><pre><code>内建常量：
gl_MaxVertexAttribs，顶点属性最大数量
gl_MaxVertexUniformVectors，使用vec4统一变量的最大数量
gl_MaxVertexOutputVectors，输出向量的最大数量
gl_MaxVertexTextureImageUnits，可用纹理单元的最大数量
gl_MaxCombinedTextureImageUnits，顶点和片元着色器中可用纹理单元的最大数量总和
</code></pre><p>（变换反馈相关接口图）</p><pre><code>变换反馈TransformFeedback相关：
glTransformFeedbackVaryings，指定变换反馈时捕捉的顶点属性
glBeginTransformFeedback，开始变换反馈（需先创建变换反馈缓冲区，再绑定到顶点索引）
glEndTransformFeedback，结束变换反馈
</code></pre><p>（纹理相关接口图）</p><pre><code>纹理相关：
4种纹理类型：2D纹理、2D纹理数组、3D纹理、立方图纹理
其中2D纹理数组和3D纹理有点相似，2D纹理数组常用于帧动画。两者区别为过滤和mipmap不同。

glGenTextures，创建纹理对象
glDeleteTextures，删除纹理对象
glBindTexture，绑定到一个特定的纹理目标
glTexImage2D，加载2D和立方图的纹理数据
glTexSubImageXXX，加载部分纹理图像数据
glTexImage3D，加载3D纹理数据
glPixelStorei，设置解包对齐
glTexParameteri，设置贴图的过滤模式
glGenerateMipmap，自动生成mip贴图
glActiveTexture，设置当前的纹理单元，以便后续将纹理绑定该单元
glCompressedTexImageXXX，加载2D、立方图、3D等纹理的压缩图像数据（ETC、ASTC等压缩格式）
glCompressedTexSubImageXXX，加载部分压缩纹理图像

glReadBuffer，设置拷贝图像数据来源的颜色缓冲区
glCopyTexImageXXX，从颜色缓冲区拷贝数据到纹理
glCopyTexSubImageXXX，拷贝部分颜色缓冲区的数据到纹理
</code></pre><p>（采样器相关接口图）</p><pre><code>采样器相关：
glGenSamplers，生成采样器对象
glDeleteSamplers，删除采样器对象
glBindSampler，绑定纹理到采样器对象
glSamplerParameterXXX，设置采样器对象参数
glTexStorageXXX，分配纹理内存
</code></pre><p>片段着色器相关：</p><p>很久以前在固定功能管线中，使用3种输入：顶点颜色插值、纹理颜色、常量颜色，再使用一些公式的组合实现有趣的特效，包括：A<em>B、A+B、A+B-0.5、A</em>C+B*(1-C)、A-B等等。</p><p>支持可编程管线后，我们可以通过可编程管线来实现固定功能管线的效果。</p><pre><code>现在的可编程管线的输入由四部分构成：
顶点属性插值（顶点上的颜色、uv、法线等）
统一变量（全局常量）
采样纹理
代码常量
</code></pre><pre><code>内建特殊变量：
gl_FragCoord，片段的窗口相对坐标（可用于噪声贴图计算）
gl_FrontFacing，是否正面朝向
gl_PointCoord，点精灵的纹理坐标
gl_FragDepth，输出变量，覆盖片段的固定功能深度值（会导致深度测试优化失效）
</code></pre><pre><code>内建常量：
gl_MaxFragmentInputVectors，输入的最大数量
gl_MaxTextureImageUnits，可用纹理图像单元的最大数量
gl_MaxFragmentUniformVectors，使用vec4统一变量项目的最大数量
gl_MaxDrawBuffers，多重渲染目标（MRT）的最大支持数量
gl_(Min/Max)ProgramTexelOffset，通过内建ESSL函数texture*Offset()偏移参数支持的最大和最小偏移量
</code></pre><p>（缓冲区相关接口图）</p><p>缓冲区相关：</p><p>缓冲区有三种，颜色缓冲区，深度缓冲区，模板缓冲区。</p><pre><code>缓冲清除相关：
glClear，清除指定缓冲区
glClearColor，清除颜色缓冲区中的指定颜色
glClearDepth，清除深度缓冲区中的指定深度
glClearStencil，清除模板缓冲区中的指定掩码
glClearBufferXXX，清除指定缓冲区中的部分区域
</code></pre><pre><code>缓冲写入相关：
glColorMask，像素写入颜色缓冲区时，哪些分量会被更新
glDepthMask，深度写入深度缓冲区时，哪些深度可以修改
glStencilMask，掩码写入模板缓冲区时，哪些掩码可以被修改
glStencilMaskSeparate，根据正面和背面的图元使用不同的掩码
glDrawBuffers，渲染指定颜色数组到多重渲染目标中
（多重渲染目标允许一次渲染多个颜色缓冲区，从而实现高级渲染算法，如延迟渲染）
</code></pre><p>（裁剪与测试相关图）</p><pre><code>模板缓冲裁剪与测试：
glScissor，指定裁剪矩形区域
glStencilFuncXXX，用指定公式指定值指定掩码测试比较模板缓冲
glStencilOpXXX，将测试结果用于深度缓冲区的操作

深度缓冲测试：glDepthFunc，设置深度测试的运算公式
</code></pre><p>（混合相关接口图）</p><pre><code>混合相关：
glBlendFuncXXX，设置混合系数
glBlendColor，设置常量颜色
glBlendEquationXXX，设置运算公式
</code></pre><pre><code>颜色缓冲区中读写像素：
glReadPixels，从颜色缓冲区中取出数据返回到指定数组中，
数据传输时会启动DMA传输，此时CPU会空出来。
</code></pre><p>（帧缓冲区对象相关接口图）</p><pre><code>帧缓冲区对象（FBO）相关：
可用于颜色、深度、模板纹理或渲染目标。
glGenRenderbuffers，分配n个渲染缓冲区对象，返回到指针中。
glBindRenderbuffer，绑定渲染缓冲区对象
glRenderbufferStorageXXX，指定渲染缓冲区对象大小和格式
glBindFramebuffer，设置当前帧缓冲区对象（渲染目标）
glFramebufferRenderbuffer，将一个渲染缓冲区对象连接到帧缓冲区附着点
glFramebufferTextureXXX，将纹理的某个mip级别连接到帧缓冲附着点
glCheckFramebufferStatus，验证帧缓冲区对象是否完整

glBlitFramebuffer，高效的将矩形区域的像素从一个帧缓冲区复制到另一个
glInvalidate(Sub)Framebuffer，让整个帧缓冲区或子区域失效
glDeleteRenderbuffers，删除指定渲染缓冲区对象，先断开缓冲区对象才能删除
glDeleteFramebuffers，删除指定帧缓冲对象
</code></pre><p>未完，最近忙新书和工作以及演讲训练，后续继续写……</p><h2 id="参考资料">参考资料：</h2><p>《OpenGL ES3.0 编程指南》DanGinsburg等著</p><p>《GPU 引擎》 https://docs.microsoft.com/zh-tw/windows/win32/direct3d12/user-mode-heap-synchronization 《CPU体系结构》 https://my.oschina.net/fileoptions/blog/1633021</p><span class="meta"><time datetime="2022-02-20T00:00:00+08:00">February 20, 2022</time> &middot; <a href="/tag/读书笔记">读书笔记</a>, <a href="/tag/前端技术">前端技术</a></span> <!--<span class="meta"><time datetime="2022-02-20T00:00:00+08:00">February 20, 2022</time> &middot; <a class="post" href="/tag/读书笔记">读书笔记</a>, <a class="post" href="/tag/前端技术">前端技术</a></span> --><div><p /><p>感谢您的耐心阅读</p><p>Thanks for your reading</p><p /> <script type="text/javascript" src="/assets/js/tctip-1.0.3.min.js"></script> <script> new tctip({ top: '50%', button: { id: 9, type: 'zanzhu' }, list: [ { type: 'alipay', qrImg: '/assets/common/alipay.jpg' }, { type: 'wechat', qrImg: '/assets/common/wechatpay.jpg' }, { type: 'bitcoin', qrContent: '1ErCFmtoQY2KDctjgPALZri3USsMqdSvqh' } ] }).init() </script><li><p><strong><font color="red">版权申明</font></strong></p><p><strong><font color="red">本文为博主原创文章，未经允许不得转载:</font></strong></p><p><a href = "http://www.luzexi.com/2022/02/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B054">读书笔记(五十四) 《游戏引擎架构》#4 低阶渲染器（5）</a></p><p><strong><font color="red">Copyright attention</font></strong></p><p><strong><font color="red">Please don't reprint without authorize.</font></strong></p></li><li><p></p><p></p><p><image src="/public/qrcode_for_gzh.jpg" /></p><p><strong>微信公众号，文章同步推送，致力于分享一个资深程序员在北上广深拼搏中对世界的理解</strong></p><p></p><p></p><p>QQ交流群: 777859752 (高级程序书友会)</p></li></div><p /><div class="related"><div class="bshare-custom icon-medium-plus"><div class="bsPromo bsPromo2"></div><a title="分享到微信" class="bshare-weixin" href="javascript:void(0);"></a><a title="分享到新浪微博" class="bshare-sinaminiblog"></a><a title="分享到QQ好友" class="bshare-qqim" href="javascript:void(0);"></a><a title="分享到QQ空间" class="bshare-qzone" href="javascript:void(0);"></a><a title="分享到Twitter" class="bshare-twitter" href="javascript:void(0);"></a><a title="分享到Facebook" class="bshare-facebook" href="javascript:void(0);"></a><a title="更多平台" class="bshare-more bshare-more-icon more-style-addthis"></a></div><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/buttonLite.js#style=-1&amp;uuid=36b4f383-d948-41a3-acd5-31ae604e3ad8&amp;pophcol=2&amp;lang=zh"></script><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/bshareC0.js"></script></div><p /><div class="related"><h2>最新发表的文章</h2><ul class="related-posts"><li><h3> <a href="/2023/03/09/%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E4%BA%9A%E5%86%9B%E6%80%BB%E7%BB%933"> 《如何精彩演讲》#7 - 复赛亚军复盘（第三次亚军） <small>09 Mar 2023</small> </a></h3></li><li><h3> <a href="/2023/02/21/%E7%9D%A1%E7%9C%A0%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E6%8A%80%E5%B7%A73"> 睡眠的原理和技巧#3 - 技巧和策略 <small>21 Feb 2023</small> </a></h3></li><li><h3> <a href="/2023/02/14/%E7%9D%A1%E7%9C%A0%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E6%8A%80%E5%B7%A72"> 睡眠的原理和技巧#2 - 影响睡眠的因素 <small>14 Feb 2023</small> </a></h3></li></ul><h2 color='blue' >之后发表的文章</h2><ul class="related-posts"><li><h3> <a href="/2022/04/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B058"> 读书笔记(五十八) 如何讲好一个故事 - 点燃观众的想象力 <small>22 Apr 2022</small> </a></h3></li><li><h3> <a href="/2022/04/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B057"> 读书笔记(五十七) 如何讲好一个故事 - 识别与释放倾听障碍 <small>11 Apr 2022</small> </a></h3></li><li><h3> <a href="/2022/04/06/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A123"> 给女儿写信(二十三) 调整 <small>06 Apr 2022</small> </a></h3></li><li><h3> <a href="/2022/04/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B056"> 读书笔记(五十六) 如何讲好一个故事 - 挖掘与倾听 <small>05 Apr 2022</small> </a></h3></li><li><h3> <a href="/2022/03/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B055"> 读书笔记(五十五) 如何做好PPT - PPT内容策略 <small>09 Mar 2022</small> </a></h3></li><h2>之前发表的文章</h2><ul class="related-posts"><li><h3> <a href="/2022/02/12/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A122"> 给女儿写信(二十二) 专注于技巧 <small>12 Feb 2022</small> </a></h3></li><li><h3> <a href="/2022/01/23/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A121"> 给女儿写信(二十一) 早上运动的力量 <small>23 Jan 2022</small> </a></h3></li><li><h3> <a href="/2022/01/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B053"> 读书笔记(五十三) 《如何做好PPT》- PPT设计的艺术 <small>10 Jan 2022</small> </a></h3></li><li><h3> <a href="/2022/01/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B052"> 读书笔记(五十二) 《如何精彩演讲》#3 如何即兴演讲 <small>06 Jan 2022</small> </a></h3></li><li><h3> <a href="/2022/01/03/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A120"> 给女儿写信(二十) 观察自己的情绪 <small>03 Jan 2022</small> </a></h3></li></ul></div></section></main><script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "//hm.baidu.com/hm.js?f3d58556a7396e715b3602ef6754cd91"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script></body></html>
