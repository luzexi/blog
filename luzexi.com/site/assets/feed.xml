<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title></title>
        <description>漫漫人生,记录点滴技术,始于2013</description>
        <link>http://www.luzexi.com</link>
        <atom:link href="http://www.luzexi.com/assets/feed.xml" rel="self" type="application/rss+xml" />
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(二) - 渲染管线2</title>
               <description>&lt;p&gt;继上篇讲解了渲染管线的应用阶段、几何阶段和光栅化阶段，这一节我们来讲讲最后的逐片元操作阶段，以及着色器中我们常见的一些概念和原理。&lt;/p&gt;

&lt;h6&gt;逐片元操作(Per-Fragment Operations)是OpenGL的说法，在DirectX称为输出合并阶段(Output-Merger)，其实只是说法不同而已包含的内容都是相同的，包括了，剪切测试(Scissor test)，多重采样的片元操作，模板测试(Stencil Test)、深度测试(Depth Test)、混合(blending)、以及最后的逻辑操作。&lt;/h6&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;这几个节点都是以片元为基础的元素操作动作，它们都决定了片元的去留问题。所以逐片元操作阶段是解决片元的可见性问题的一个重要阶段，如果片元在这几个节点上任意一个节点没有通过测试，那么它就会被丢弃并且之后的测试或操作都不会被执行，如果执行全部通过就会进入帧缓存。每个节点实际测试的过程是个比较复杂的过程，而且不同的图形接口实现的细节也不一样，但我们要理解到它们的基本原理和大致的过程相对简单一些。&lt;/p&gt;

&lt;p&gt;所有这些测试和操作其实都可以看做是以开关形式存在，因为他们的操作命令大都包含了On和Off操作指令，在OpenGL里以glEnable()和glDisable()来表示功能是否被开启或关闭。&lt;/p&gt;

&lt;p&gt;第一个可见性测试就是剪切测试(Scissor)，它主要针对的是片元是否在窗口范围内的测试判断，如果片元不在窗口范围内则被丢弃。&lt;/p&gt;

&lt;p&gt;这个窗口范围是一个矩形的区域，我们称它为剪切盒。实际上有很多个剪切盒存在，只是默认情况下所有渲染测试都在第一个剪切盒上完成，要访问其他剪切盒就需要几何着色器。&lt;/p&gt;

&lt;p&gt;Unity3D并没有开放这个剪切测试的功能，它的实际应用比较少我们在这里也只是简单介绍一下，至少大家知道了有这种测试的存在。&lt;/p&gt;

&lt;p&gt;第二步是多重采样的片元操作。&lt;/p&gt;

&lt;p&gt;普通采样只采一个样本或者说一个像素，而多重采样泽是分散取得多个样本，这些样本可能是附近的几个位置也可能是其他算法。因此在多重采样中，每个片元都有多种颜色，多个深度值和多组纹理坐标，而不是只有一种（具体有多少个取决于子像素的样本数目）。&lt;/p&gt;

&lt;p&gt;如果没有开启多重采样的片元操作，多重采样在计算片元的覆盖比例时，不会考虑alpha值的影响。&lt;/p&gt;

&lt;p&gt;一旦开启多重采样的片元操作，我们就可以用片元的alpha值来影响采样的覆盖率计算。&lt;/p&gt;

&lt;p&gt;Unity3D的没有开放自定义设置多重采样的片元操作功能，至少我们知道了有多重采样的存在，像素不是单单只是它本身的颜色和深度，而是由附近的像素一起决定的。&lt;/p&gt;

&lt;p&gt;前两步可能并没有引起我们足够的重视，但后面几步需要我们着重学习。&lt;/p&gt;

&lt;p&gt;第三步模板测试(Stencil Test)，模板测试说的简单点，其实和比大小无异，关键就是怎么比，与谁比，这又能玩出很多花样。&lt;/p&gt;

&lt;p&gt;在模板测试中模板缓存是必要的内存块，因为每个片元在通过测试后都会被写入到模板缓存中。&lt;/p&gt;

&lt;p&gt;开发者需要指定一个引用参考值(Reference value)，这个参考值代表了当前物体所有片元的参考值，这个参考值会与模板缓存(Stencil Buffer)中当前位置片元的模板值进行比较，比较时模板缓存中当前位置片元的参考值是被前面的物体通过测试时写入的一个值，比较两个值后会根据比较的结果做判断是否抛弃片元，判断可以是大于、等于、小于等，一旦判断失败片元将被抛弃反之则继续向下传递，只是判断成功后也可以有相应对模板缓存做其他操作，操作可以有，替换旧的片元，增加一定的参考值，参考值置零等等。&lt;/p&gt;

&lt;p&gt;我们来看看到底有多少种判断，和，多少种对模板缓存的操作。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Greater 大于模板缓存时判断通过
    GEqual  大于等于模板缓存时判断通过
    Less    小于模板缓存时判断通过
    LEqual  小于等于模板缓存时判断通过
    Equal   等于模板缓存时判断通过
    NotEqual    不等于模板缓存时判断通过
    Always  总是通过
    Never   总是不通过
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述这些都是对于是否通过测试的判断种类，看上去就像是简单的比大小。在Unity3D的Shader中的完整的模板测试写法如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Stencil {
        Ref 2 //指定的引用参考值
        Comp Equal //比较操作
        ReadMask 255 //读取模板缓存时的掩码
        WriteMask 255 //写入模板缓存是的掩码
        Pass Keep //通过后对模板缓存的操作
        ZFail IncrSat //如果深度测试失败时对模板缓存的操作
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模板测试的步骤简单明了，当前值与模板缓冲比较，通过的做一个指定的操作替换或者增加或者减少等，不通过的片元被抛弃。&lt;/p&gt;

&lt;p&gt;上述Unity3D模板命令中 Pass 的操作就是通过测试后的操作种类，它有如下几种方式可选：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Keep    不做任何改变，保留当前缓存中的参考值
    Zero    当前Buffer中置零
    Replace 将当前的参考值写入缓存中
    IncrSat 增加当前的参考值到缓存中，最大为255
    DecrSat 减少当前的参考值到缓存中，最小为0
    Invert  翻转当前缓存中的值
    IncrWrap    增加当前的参考值到缓存中，如果到最值255时则变为0
    DecrWrap    减少当前的参考值到缓存中，如果到最小为0时则变为255
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不同的物体有不同的引用值，每个比较操作都可以不一样，包括掩码值、成功后的操作动作，一个简简单单的比大小其实也能玩出这么多花样来。不止如此，除了比较和通过后的操作指令外，深度测试失败时还可以影响模板缓存中的值。我们用一幅图就能理解模板测试的美妙：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺图
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中三个球一起叠加在一起，却只显示了一个球的，并且在这个球上显示了三个球叠加的部分。因为其他两个球的模板测试并没有通过，但叠加部分则通过了模板测试。&lt;/p&gt;

&lt;h6&gt;如果片元幸运的通过了模板测试，则会来到第四步，深度测试。有没觉得这个片元很像某生理教课书上描述精子通过重重困难终于来到了卵子的的位置那样，课本上总是这么介绍，刚好片元也是如此。&lt;/h6&gt;

&lt;p&gt;深度测试主要目的是将被覆盖的片元丢弃，或者说将需要覆盖的片元绘制在屏幕上，其实这两个操作都是根据物体渲染的前后关系操作的。&lt;/p&gt;

&lt;p&gt;深度测试工作分为两块，一块是比较即ZTest，一块是写入即ZWrite，只有比较并被判定通过的才有写入的资格，我们也可以把写入关了，让物体无法写入，这就会导致它片元深度无法与其他物体比较，这种写法在半透明中很常用，其他时候大部分都是默认开启深度值写入即ZWrite On。&lt;/p&gt;

&lt;p&gt;深度测试是怎么比较的呢？还记得前面介绍的模板测试么，重点就是“比大小”，比完判定通过的就写入缓存，深度测试的方法和模板测试的流程和方法简直就是一个妈生出的俩个孩子。深度测试的 ZTest 对应模板测试的 Comp指令，深度测试的 ZWrite 对应模板测试的 Pass指令，先拿当前片元比较缓存中的值再操作缓存，两者简直一模一样。&lt;/p&gt;

&lt;p&gt;与模板测试不同的是深度测试用的是深度值，而不是固定某个值，写入缓存也不没有那么多花样。&lt;/p&gt;

&lt;p&gt;那么什么是深度值？这个深度值是从哪来的？&lt;/p&gt;

&lt;p&gt;还记得前面顶点着色器中介绍的，顶点在变化坐标空间后z轴被翻转成为了视口前方的轴么。整个锥视体变成了立方体，x、y轴则成为了视口平面上的平面方向轴，原来的z轴转换成了顶点前后关系的深度值。我们再来看看这幅图片：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺图
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是的，正是因为那次坐标系的转换和后面的归一化，使得所有顶点的坐标都在一个立方体的空间内，且这个立方体的大小被限制在了-1到1的大小，x、y成为了屏幕相对参考坐标，而z则成为了前后关系的深度参考值。&lt;/p&gt;

&lt;p&gt;虽然这只是顶点上的坐标，但在后面的步骤中三角面被光栅化，并对每个像素背后形成了片元，每个片元根据三角形顶点信息的插值后z坐标也进入了片元中，这就是我们需要的片元的深度值。&lt;/p&gt;

&lt;p&gt;深度值在片元中成为了片元在深度测试中判断的依据，如果输入片元的深度值即z值可以通过制定的深度测试环节，那么它就可以替换当前深度缓存中已经有的深度值(如果ZWrite 没有被关闭的话)。&lt;/p&gt;

&lt;p&gt;深度测试的判断依据也有很多种，我们来看下它有多少中判断种类:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    ZTest Less | Greater | LEqual | GEqual | Equal | NotEqual | Always
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述中表达了所有判断种类，从左到右为，小于缓存中的就通过，大于缓存中的就通过，小于等于缓存中的就通过，大于等于缓存中的就通过，等于缓存中的就通过，不等于缓存中的就通过，以及总是通过与缓存无关。其中LEqual 最为常用，即越接近摄像机的越需要覆盖其他面片，越远离摄像机的越容易被覆盖或者说越容易通不过深度测试。&lt;/p&gt;

&lt;h6&gt;我们可以更加白话一点表达深度测试，一般情况下都是用LEqual 作为深度测试判断依据，即哪个片元离摄像机越近就用哪个，其他种类的类型判断类型也可以解释的类似与摄像机距离有关。&lt;/h6&gt;

&lt;p&gt;如果片元很幸运冲破前面这么多种测试终于来到了第五步混合阶段，这一步从测试上来说其实是最后一个阶段。&lt;/p&gt;

&lt;h6&gt;混合阶段实质上并没有丢弃任何片元，但却可以让片元消失不见。&lt;/h6&gt;

&lt;p&gt;如果一个片元通过了上面的测试，那么它就有资格与当前颜色缓冲中的内容进行混合了。最简单的混合方式就是直接覆盖已有的颜色缓冲中的值，实际上这样不算混合，只是覆盖而已，我们需要两个片元的真正混合。&lt;/p&gt;

&lt;p&gt;那么什么叫混合？为什么要混合？&lt;/p&gt;

&lt;p&gt;混合是两个片元的从颜色上和alpha值上相加或相乘的算法过程，通过我们自己指定的数学公式来确定混合后的像素颜色，这个公式不复杂，其实就是颜色和因子的加减乘的基本运算，通过这种运算我们能得到想要的效果。&lt;/p&gt;

&lt;p&gt;由于物体都是一个接一个的被渲染在缓冲中的，当前物体被光栅化成为片元后要写入缓存时，面临着前面渲染的物体已经被铺在缓冲中的情况，如果没有开启混合，当前的片元则会直接覆盖掉当前所在的缓冲中的像素，两个片元并没有做任何关联性的操作，但如果这时开启混合则可以对这两个片元在颜色上做更多的操作，这可能是我们所期望的。&lt;/p&gt;

&lt;p&gt;大多数情况混合与片元的 alpha 值有关，但不是硬性要求一定要与alpha有关，也可以只与颜色有关，只是这种类型比较多而已。&lt;/p&gt;

&lt;p&gt;alpha 是颜色的第四个分量，OpenGL中片元的颜色都会带有 alpha 无论你是否需要它，无论是否你显性地设置了它，alpha默认为1不透明。&lt;/p&gt;

&lt;p&gt;但是 alpha 太抽象，我们无法从肉眼看到它，只能在脑袋中想象它。alpha 代表了片元的透明程度，是颜色的第四个分量，我们可以用它实现各种半透明物体的模拟就像有色玻璃那样。&lt;/p&gt;

&lt;p&gt;说白了，混合就是当前物体的片元与前面渲染过的物体的片元之间的颜色与alpha上的操作，那么混合有哪些操作呢？我们来看下Unity3D中的混合指令：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Blend SrcFactor DstFactor

    Blend SrcFactor DstFactor, SrcFactorA DstFactorA
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有两种操作方式，第一种是混合颜色包括alpha，第二种是分开混合即，RGB颜色和RGB颜色混合(alpha不参与)用一种方式，alpha和alpha混合则用另一种方式(颜色不参与)。&lt;/p&gt;

&lt;p&gt;其中 SrcFactor 这个因子(变量)会与刚刚通过测试的物体片元(即当前物体片元)上的颜色相乘。&lt;/p&gt;

&lt;p&gt;DstFactor 这个因子(变量)会与前面已经渲染过的物体的片元(即缓存中的像素)的颜色相乘。&lt;/p&gt;

&lt;p&gt;SrcFactorA 这个因子(变量)会与刚刚通过测试的物体片元(即当前物体片元)上的 alpha 相乘。&lt;/p&gt;

&lt;p&gt;DstFactorA 这个因子(变量)会与已经渲染过的物体(即缓存中的像素)片元上的 alpha相乘。&lt;/p&gt;

&lt;h6&gt;这个过程有两个步骤，第一步是相乘操作，第二步是相乘后的两个结果再相加(还可以选相减等)。我们称为混合方程&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    即 Src * SrcFactor + Dst * DstFactor

    或 SrcColor * SrcFactor + DstColor * DstFactor, SrcAlpha * SrcFactorA + DstAlpha * DstFactorA
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常情况下相乘的结果再相加得到最终的混合片元。但我们可以改变这种方程式，用减号，或者调换位置的减号，最大值函数，最小值函数，来代替源数据与目标数据之间的操作符。即&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    BlendOp Add 加法
    BlendOp Sub 减法
    BlendOp RevSub 置换后相减
    BlendOp Min 最小值
    BlendOp Max 最大值
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述5种操作符的修改就分别代表了因子相乘后会相加，会相减，会置换后相减，会取得最小值，会取得最大值。拿Sub，Max来举例子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    当写入BlendOp Sub时，方程式就变成了：

    Src * SrcFactor - Dst * DstFactor

    当写入BlendOp Max时，方程式就变成了：

    Max(Src * SrcFactor, Dst * DstFactor)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了操作符可以变化外，SrcFactor、DstFactor、SrcFactorA、DstFactorA 这四个变量的可以选择为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    One     代表1，就相当于完整的一个数据
    Zero    代表0，就相当于抹去了整个数据
    SrcColor    代表当前刚通过测试的片元上的颜色(即当前物体片元)，相当于乘以当前物体片元的颜色
    SrcAlpha    代表当前刚通过测试的片元上的alpha(即当前物体片元)，相当于乘以当前物体片元的alpha
    DstColor    代表已经在缓存中的颜色，相当于乘以当前缓存颜色
    DstAlpha    代表已经在缓存中的alpha，相当于乘以当前缓存alhpa
    OneMinusSrcColor    代表缓存上的片元做了 1 - SrcColor 的操作，再相乘
    OneMinusSrcAlpha    代表缓存上的片元做了 1 - SrcAlpha 的操作，再相乘
    OneMinusDstColor    代表当前刚通过测试的片元上的颜色做了 1 - DstColor 的操作，再相乘
    OneMinusDstAlpha    代表当前刚通过测试的片元上的颜色做了 1 - DstAlpha 的操作，再相乘
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上述举的几个例子，并列出了所有变量的选择，我们可以知道其实Blend混合可以玩出很多花样来。&lt;/p&gt;

&lt;p&gt;这4个变量选择，和操作符的选择决定了混合后的效果，我们来看看其常用的混合方法：&lt;/p&gt;

&lt;h6&gt;1， 透明度混合Blend SrcAlpha OneMinusSrcAlpha，即常用半透明物体的混合方式。&lt;/h6&gt;

&lt;p&gt;这是最常用的半透明混合，首先要保证半透明绘制的顺序比实体的要后面，所以Queue标签是必要的Tags {&amp;quot;Queue&amp;quot; = &amp;quot;Transparent&amp;quot;}。Queue标签告诉着色器此物体是透半透明物体排序。至于渲染排序Queue的前因后果将在后面的文章介绍。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader36.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;Blend SrcAlpha OneMinusSrcAlpha 我们来解释下，以上图为例，图中油桶是带此Shader的混合目标。&lt;/p&gt;

&lt;p&gt;当绘制油桶时，后面的实体BOX已经绘制好并且放入屏幕里了，所以ScrAlpha与油桶渲染完的图像相乘，部分区域Alpha为0即相乘后为无(颜色)，这时正好另一部分由OneMinusSrcAlpha(也就是1-ScrAlpha)为1即相乘后原色不变，两个颜色相加后就相当于油桶的透明部分叠加后面实体Box的画面，于是就形成了上面的这幅画面。&lt;/p&gt;

&lt;p&gt;反过来也是一样，当ScrAlpha为1时，源图像为不透明状态，则两个颜色在相加前最终变成了，源图像颜色+无颜色=源图像颜色，于是就有了上图中油桶覆盖实体Box的图像部分。&lt;/p&gt;

&lt;h6&gt;2，加白加亮叠加混合 Blend One One，即在原有的颜色上叠加屏幕颜色更加白或亮。&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader37.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;第一参数One代表本物体的颜色。第二个参数代表缓存上的颜色。两种颜色没有任何改变并相加，导致形成的图像更加亮白。这样我们就看到了一个图像加亮加白的图像。&lt;/p&gt;

&lt;h6&gt;3，保留原图色彩Blend One Zero，即只显示自身的图像色彩不加任何其他效果。&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader38.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;本物体颜色，加上，零，就是本物体颜色。&lt;/p&gt;

&lt;h6&gt;4，自我叠加（加深）混合Blend SrcColor Zero，即源图像与源图像自我叠加。&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader39.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;与上面相比，加深了本物体的颜色。先是本物体的颜色与本物体的颜色相乘，加深了颜色，第二个参数为零，使得缓冲中的颜色不被使用。所以形成的图像为颜色加色的图像。&lt;/p&gt;

&lt;h6&gt;5，目标源叠加（正片叠底）混合Blend DstColor  SrcColor，即把目标图像和源图像叠加显示。&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader40.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;第一个参数，本物体颜色与缓存颜色相乘，颜色叠加。第二个参数，缓存颜色与本问题颜色相乘，颜色叠加。两种颜色相加，加亮加白。这个混合效果就如同两张图像颜色叠加后的效果。&lt;/p&gt;

&lt;h6&gt;6，软叠加混合Blend DstColor  Zero，即把刚测试通过的图像与缓存中的图像叠加。&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader41.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;与前面的叠加混合效果相似，这个只做一次叠加，并不做颜色相加操作，使得图像看起来在叠加部分并没有那么亮白的突出。因为第二个参数为零，表示后面的屏幕颜色与零相乘即为零。&lt;/p&gt;

&lt;h6&gt;7，差值混合BlendOp Sub，Blend One One，即注重黑白通道的差值。&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader42.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;在这个混合中使用了混合操作改变，从默认的加法改成了减法，使得两个颜色从加法变为了减法，不再是变白变亮的操作，而是反其道成为了色差的操作。&lt;/p&gt;

&lt;h6&gt;除了对源片元和目标片元，相乘再相加的操作，还可以改变相乘后的加法操作。比如减法，取最大值，取最小值等。&lt;/h6&gt;

&lt;h6&gt;Blend混合很像 Photoshop 中对图层操作，Photoshop中每个图层都可以选择混合模式，混合模式决定了该层与下层图层的混合结果，而我们看到的都是是混合后的图片。&lt;/h6&gt;

&lt;h3&gt;逻辑操作&lt;/h3&gt;

&lt;p&gt;在混合结束后，片元将被写入缓存中去，在写入缓冲中去时，还有一步逻辑操作，这是片元的最后一个操作。&lt;/p&gt;

&lt;p&gt;它作用于当前刚通过测试的片元数据以及当前颜色缓存中的数据，在它们之间进行一次操作，再写入到缓存中覆盖原来的数据。&lt;/p&gt;

&lt;p&gt;由于这个过程的实现代价对于硬件来说是非常低廉的，因此很多系统都允许这种做法。这种逻辑操作的方式很像上面的混合(Blend)，但是更加简单，不再有因子，只是两种颜色之间的数字操作，例如，XOR异或操作，AND与操作，OR或操作等。&lt;/p&gt;

&lt;p&gt;Unity3D中并不能自定义设置逻辑操作，这里不重点讲解。&lt;/p&gt;

&lt;h6&gt;双缓冲机制&lt;/h6&gt;

&lt;p&gt;片元最后都会以像素颜色的形式写入缓冲中，但是如果只有一个缓冲，那么我们会时常见到绘制的中间状态即图形的形成过程，这对画面呈现效果很不友好，所以GPU通常采用双缓冲机制，即前置缓存用于呈现画面，而后置缓存则继续由GPU继续工作。&lt;/p&gt;

&lt;p&gt;当整个画面绘制完成时，后置缓冲与前置缓冲进行调换，这时后置缓存可以成为了前置缓冲并呈现在屏幕上，而原来的前置缓存则成为后置缓冲交由GPU作为缓冲内存继续绘制下一帧，由此我们可以保证看到的图像是连续的最终状态。&lt;/p&gt;

&lt;h6&gt;整个渲染管线已经全部呈现在这里了，我们来总结一下。&lt;/h6&gt;

&lt;p&gt;整个渲染管线从大体上分，应用阶段，几何阶段，光栅化阶段。渲染数据从应用阶段生成开始。&lt;/p&gt;

&lt;p&gt;数据在应用阶段被记录、筛选(或者也可以叫裁剪)、合并，这个筛选和合并有些运用了算法来达到裁剪的目的，有些放大了颗粒度用少量的消耗来加速筛选(裁剪)，有些利用了GPU工作原理合并了渲染数据提高了GPU工作效率。&lt;/p&gt;

&lt;p&gt;几何阶段着重于处理顶点的数据，顶点着色器是其中最为重要的一个着色器，它不但需要计算顶点在空间上的转换，还要为下一个阶段光栅化阶段做准备。&lt;/p&gt;

&lt;p&gt;在顶点着色器中，计算和记录了片元着色器计算颜色需要的数据，这些数据都会被放入顶点(图元)数据内，这些数据在下一个阶段会被做插值后放入片元中。&lt;/p&gt;

&lt;p&gt;光栅化阶段主要任务是将三角形面转化为实实在在的像素，并且根据顶点上的数据做插值得到片元信息，一个片元就相当于一个像素附带了很多插值过的顶点信息。&lt;/p&gt;

&lt;p&gt;片元着色器在光栅化阶段起了重要的作用，它为我们提供了自定义计算片元颜色的可编程节点，不但如此，我们还可以根据自己的喜好抛弃某些片元。&lt;/p&gt;

&lt;p&gt;除了片元着色器外，片元在片元着色器后还需要经过好几道测试才能最终呈现在画面上，包括判断片元前后顺序的深度测试，可以自定义条件的模板测试，以及常用来做半透明的像素混合，片元只有经过这几道关卡才最终被写入缓存中。&lt;/p&gt;

&lt;h6&gt;我们讲解了很多，但还是有很多很多细节被忽略，我们会在后面的章节中详细为大家解剖，这些细节可能在各个图形编程接口(OpenGL和DirectX)的实现中不尽相同，但大体上都是运用了同一种原理和概念。&lt;/h6&gt;

&lt;p&gt;Unity3D为我们封装了很多东西，使得我们能很快的上手去运用，但也屏蔽了很多原理上的知识，使得我们在面对底层原理时感到迷茫。本书虽然不是致力于Shader的教学，但也将尽最大的努力使读者们从根本上理解GPU的工作原理，从而在面对工作上的困难时能一眼看透问题的本质，从根本上解决麻烦并优化效率。&lt;/p&gt;
</description>
               <pubDate>Sat, 28 Sep 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/09/28/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A65.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/09/28/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A65.html</guid>
            </item>
        
            <item>
               <title>杭州景点体验概览</title>
               <description>&lt;p&gt;1.西湖--西湖音乐喷泉--三潭印月--断桥残雪--苏堤--白堤--西湖游船--曲院风荷--六和塔--花港观鱼--梅家坞--云栖竹径--龙井路与满觉陇路--孤山公园--虎跑公园--杨公堤&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;2.灵隐寺（飞来峰）景区----北高峰索道&lt;/p&gt;

&lt;p&gt;3.宋城景区--宋城千古情演出&lt;/p&gt;

&lt;p&gt;4.杭州动物园&lt;/p&gt;

&lt;p&gt;5.吴山广场，河坊街&lt;/p&gt;

&lt;p&gt;6.雷峰塔&lt;/p&gt;

&lt;p&gt;7.杭州长乔极地海洋公园 -- 好，贵，大&lt;/p&gt;

&lt;p&gt;8.杭州野生动物世界 -- 良好，停车难，略贵，不大&lt;/p&gt;

&lt;p&gt;9.西溪国家湿地公园 -- 差，管理无章法，太大以至于找不到重点&lt;/p&gt;

&lt;p&gt;10.九溪&lt;/p&gt;

&lt;p&gt;11.南宋御街&lt;/p&gt;

&lt;p&gt;12.杭州乐园&lt;/p&gt;

&lt;p&gt;13.太子湾公园&lt;/p&gt;

&lt;p&gt;14.千岛湖中心湖区--千岛湖景区--千岛湖森林氧吧--千岛湖东南湖区景区--千岛湖游船&lt;/p&gt;

&lt;p&gt;16.大明山景区&lt;/p&gt;

&lt;p&gt;17.杭州烂苹果乐园 -- 游乐园&lt;/p&gt;

&lt;p&gt;18.杭州海底世界&lt;/p&gt;

&lt;p&gt;19.浙西大峡谷&lt;/p&gt;

&lt;p&gt;20.钱塘江观赏堤坝&lt;/p&gt;

&lt;p&gt;21.浙江省科技馆--西湖文化广场&lt;/p&gt;

&lt;p&gt;22.杭州浪浪浪水公园&lt;/p&gt;

&lt;p&gt;23.杭州Hello Kitty乐园&lt;/p&gt;

&lt;p&gt;24.桐庐县雅鲁激流探险漂流----临安市龙井峡漂流----淳安县九龙溪漂流----桐庐县虎啸峡激流探险漂流----余杭区双溪漂流景区&lt;/p&gt;

&lt;p&gt;25.桐庐县瑶琳仙境，垂云通天河景区&lt;/p&gt;

&lt;p&gt;26.杭州DO都城，亚洲最大的少年儿童体验类教育场馆&lt;/p&gt;

&lt;p&gt;27.桐庐县大奇山国家森林公园&lt;/p&gt;

&lt;p&gt;28.临安太湖源&lt;/p&gt;

&lt;p&gt;29.良渚，彻天彻地童玩中心，让孩子训练协调能力，培养冒险精神&lt;/p&gt;

&lt;p&gt;30.江干区江和美海洋公园&lt;/p&gt;

&lt;p&gt;31.临安大明山景区&lt;/p&gt;

&lt;p&gt;32.慈溪杭州湾国家湿地公园&lt;/p&gt;

&lt;p&gt;33.胡雪岩故居&lt;/p&gt;

&lt;p&gt;34.京杭大运河，余杭塘栖&lt;/p&gt;

&lt;p&gt;35.杭州国际博览中心，萧山区&lt;/p&gt;

&lt;p&gt;36.多乐岛蹦床公园杭州馆，江干区&lt;/p&gt;

&lt;p&gt;37.桐庐县大奇山疯狂森林主题乐园，冒险探险&lt;/p&gt;

&lt;p&gt;38.城西银泰，娱乐场--滑冰--玩具店 -- 逛买逛买&lt;/p&gt;

&lt;p&gt;39.浙江大学紫金港校区 -- 好风景好环境&lt;/p&gt;

&lt;p&gt;40.塘西古镇  -- 逛吃逛吃，小&lt;/p&gt;

&lt;p&gt;41.杭州北高峰 -- 交通不方便&lt;/p&gt;
</description>
               <pubDate>Sat, 21 Sep 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/09/21/%E6%9D%AD%E5%B7%9E%E6%99%AF%E7%82%B9%E4%BD%93%E9%AA%8C%E6%A6%82%E8%A7%88.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/09/21/%E6%9D%AD%E5%B7%9E%E6%99%AF%E7%82%B9%E4%BD%93%E9%AA%8C%E6%A6%82%E8%A7%88.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(二) - 渲染管线1</title>
               <description>&lt;p&gt;计算机的世界里其实是很纯粹的，没有什么高深的技术，无非就是进程、线程、内存、硬盘、CPU。&lt;/p&gt;

&lt;p&gt;在现代社会的实际编程中，很多时候引擎或者框架帮我们屏蔽了底层上的操作使得程序员只需要将所有精力放在上层应用就可以了，因此数学和算法很多时候成了重点，这是符合社会进步规律的，我们需要站在巨人的肩膀上才能走得比巨人更快更远。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;Unity3D就是帮助我们快速建立程序结构的好引擎，有了Unity3D我们才能在较低门槛的情况下，创造出自己的想法和创意，让’我‘里面有的内在才能快速和有效的得到放大。&lt;/p&gt;

&lt;p&gt;除了进程、线程、内存、硬盘、CPU这些通常我们程序员在编程时都要接触的因素外，对于我们前端程序员来说又多了一个GPU的技术范畴，因此我们需要学习和考虑的问题比其他程序员会更加多一些也更加高阶一些，Unity3D虽然封装了所有引擎需要的GPU接口功能但我们还是必须要了解渲染管线是如何处理的，最终是如何将渲染数据渲染要屏幕上的等等这些底层的知识和原理。&lt;/p&gt;

&lt;h3&gt;OpenGL、DirectX究竟是什么&lt;/h3&gt;

&lt;p&gt;OpenGL 和 DirectX 其实是一回事，它们都是图形渲染的应用程序编程接口，它们都是一种可以对图形硬件设备特性进行访问的软件库。它们的区别只是接口名字不一样，并且，分别由不同的两个开发群体开发出来的两套程序。&lt;/p&gt;

&lt;p&gt;为什么会是两个不同群体开发出来的两套差不多功能的软件，并且还同时运行在现有的世界中呢？&lt;/p&gt;

&lt;p&gt;OpenGL是由SGI(Silicon Graphics 美国硅图公司)开发的，而DirectX是由微软开发的，由于市场竞争的关系两家公司做了同样的事，最后导致现在的局面。从现在的局面看，我们可以想象的到，在当初还没有形成统一的硬件渲染接口时，各家公司的编程方式有多混乱，情况有多复杂，对标准统一接口的标准竞争有多激烈。在这种严峻的情况下才使得两家公司为了各自的利益，一直在不断维护和升级着各自的驱动接口直到今天。&lt;/p&gt;

&lt;p&gt;幸运的是 Unity3D 已经帮我们封装好了 OpenGL 和 DirectX 的接口，我们无需关心到底是调用 OpenGL 还是 DirectX。我们这里会以OpenGL为例来讲解Unity3D与OpenGL的关系，暂时免去DirectX的麻烦。&lt;/p&gt;

&lt;h6&gt;OpenGL究竟处在哪个位置&lt;/h6&gt;

&lt;p&gt;Unity3D通过调用 OpenGL 来渲染图像，OpenGL 定义各种标准接口就是为了让像 Unity3D 这样的应用程序在面对不同类型的显卡硬件时可以不必慌张，也就是说由于 OpenGL 的存在，Unity3D完全不需要去关心硬件到底是哪个厂家生产的，它的驱动是什么。其实与其说OpenGL在标准接口中适配了硬件厂商的驱动程序，不如说硬件厂商的驱动程序适配了OpenGL，事实上确实是这样。&lt;/p&gt;

&lt;p&gt;当Unity3D在渲染调用时去设置OpenGL的渲染状态，OpenGL就会去检查显卡驱动程序里是否有该功能，如果有就会调用，如果是那些比较特殊的渲染接口，有些硬件驱动是没有的则不调用。&lt;/p&gt;

&lt;p&gt;如果把GPU硬件看做是最底层的那个模块的话，显卡驱动就是在硬件之上的模块，它是用来将指令翻译成机器语言并调用硬件的那个程序。&lt;/p&gt;

&lt;p&gt;显然OpenGL是在驱动程序之上的应用程序，我们可以把它看做是适配不同驱动程序的中间件。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/render-pipeline1.png&quot; alt=&quot;opengl&quot;&gt;&lt;/p&gt;

&lt;p&gt;上图中很清晰的表达OpenGL所处的位置，应用程序(如Unity3D)向OpenGL发送渲染指令，告诉OpenGL我的某个模型数据需要渲染或者说某个状态要设置，OpenGL发送指令给显卡驱动程序，显卡驱动程序将指令翻译为机器码后，将指令机器码发送到GPU，GPU先从显存中获得需要的数据再根据指令做处理。&lt;/p&gt;

&lt;p&gt;我们看到这个过程中显卡驱动程序只是做了传递指令消息的工作，指令从OpenGL那里发起到GPU接受到指令，显卡驱动只是起到了翻译的作用。因此我们在平常的讨论中，常常将显卡驱动程序的工作忽略掉，而用 OpenGL 与 GPU 的互动代替之。甚至有时会将OpenGL也忽略掉用GPU代替，或把GPU忽略掉用OpenGL代替，因为GPU的工作是机械式的它俩的工作完全可以看做一个整体。&lt;/p&gt;

&lt;p&gt;当然这里GPU不只会处理一次，OpenGL会通过显卡驱动发送很多次指令给GPU，让它处理一连串的操作，每次指令都有可能不一样，经过一系列的处理过程后，最终形成了一张屏幕大小的图像存放在缓存中，这时GPU才向屏幕输出最终画面。&lt;/p&gt;

&lt;p&gt;下面我们就来详细介绍一下渲染管线。&lt;/p&gt;

&lt;h3&gt;究竟渲染管线是什么？&lt;/h3&gt;

&lt;p&gt;上面所说的 OpenGL 通过驱动程序向 GPU 发送很多个指令，其实为了渲染很多个模型每一帧都会发送很多个指令，这一系列指令加起来，才形成一整个渲染过程，拥有完整的一个画面。&lt;/p&gt;

&lt;p&gt;渲染管线就是指令中完成一个绘制命令(drawcall)的流水线。这条流水线中有很多个环节，每个环节都自己干自己的事，就像工厂里的流水作业一样，每个节点的工人都会拧属于自己的螺丝，完全不会去管前面节点发生了什么事情，不过在现代GPU中也会做些流程上的优化，比如调整节点的顺序，但节点还是自顾自的工作，这部分会在后面的文章中提到。&lt;/p&gt;

&lt;p&gt;从严肃的理论描述来说渲染管线：是一系列数据处理的过程，这个过程最终的目的是将应用程序的数据转换到最终输出的缓存上最后输出到屏幕。&lt;/p&gt;

&lt;p&gt;我们说的再白话一点。渲染管线从接受到渲染命令后开始，分几个阶段处理了这些数据，这几个阶段分别是应用阶段，几何阶段，光栅化阶段，经过这几个阶段处理最终输出到屏幕上。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中每个阶段都有各自细分的流程，我们来一一讲述下。&lt;/p&gt;

&lt;h6&gt;应用阶段&lt;/h6&gt;

&lt;p&gt;应用阶段其实就是我们执行Unity3D引擎和代码的过程，在逻辑代码过程中，我们实例化了很多个模型或者UI（UGUI的UI也是网格，跟渲染场景中的3d模型从根本上是没有区别的），这些模型有贴图，有材质球，有网格，对于引擎来说，这个阶段在代码执行完毕后它知道了哪些模型需要被渲染，有哪些光源存在，摄像头的位置大小，于是就知道该如何通知GPU去渲染，总的来说这个阶段是准备渲染数据的阶段，为调用渲染准备。&lt;/p&gt;

&lt;p&gt;引擎除了知道有哪些东西(数据)需要被提交到GPU渲染外，在提交前还会对这些数据做很多优化工作，从而提高渲染性能。&lt;/p&gt;

&lt;p&gt;优化工作有很多种，从具体业务逻辑上做优化的方案，前面的章节中我们也讲到了很多很多关于在逻辑端上优化的工作，现在我们来重点说一下引擎的‘剔除’优化部分。&lt;/p&gt;

&lt;p&gt;Unity3D引擎会对不需要渲染的物体进行剔除，原本这是在GPU中做的事搬到了CPU上做。为什么要搬到CPU上做呢？因为在引擎端掌握的是第一手数据信息，如果从粗颗粒上下手做剔除工作，CPU会更快更方便，如果放到GPU去剔除，则更可能是三角形级别的裁剪，会浪费很多计算同时降低了功效。&lt;/p&gt;

&lt;p&gt;引擎在粗颗粒上是怎么剔除的呢，引擎当然不会像GPU那样去计算每个面是否可展示，因为这个操作对GPU来说更快，而是去计算更粗的颗粒，即整个模型的包围盒是否需要被剔除。&lt;/p&gt;

&lt;h6&gt;引擎会计算一个模型的包围盒，这个包围盒就是Unity3D的Mesh.bounds变量，这个包围盒为AABB包围盒，即一个顶点与最大最小长宽高，我们可以理解为包围盒是个立方体有8个顶点，这8个顶点决定了这个模型是否会被剔除，即只要有一个顶点在摄像机可视范围内(锥视体内或正交范围)，就不会被剔除，否则将被剔除。&lt;/h6&gt;

&lt;p&gt;引擎通过这种快速的判断包围盒与锥视体的关系来剔除不需要渲染的物体，以达到对粗颗粒的渲染优化。&lt;/p&gt;

&lt;p&gt;除此之外，对粗颗粒的剔除判断还有 occlusion culling 即遮挡剔除，也是属于应用阶段的优化剔除，它其实也是属于业务逻辑层的优化方案并不是所有项目都会使用，而通常只在第一人称视角的游戏上使用这种剔除方式，即被遮挡的物体不进入渲染队列。&lt;/p&gt;

&lt;p&gt;除了得到和优化需要渲染的数据外，应用阶段的最后时刻就是向GPU提交需要渲染的数据，即拷贝数据到显存中、设置渲染状态、渲染调用(Draw call)。&lt;/p&gt;

&lt;p&gt;在PC端中显存是最接近GPU的内存设备，将数据拷贝到显存中会加速GPU的工作效率，但在移动端里并没有显存，安卓和IOS的架构决定了它们只能用内存来为GPU提供服务，因此在手机端中没有拷贝数据到显存的这个说法，使用的都是同一个内存地址，除非我们需要读写这块内存内容才将它们另外复制一份。&lt;/p&gt;

&lt;h6&gt;那么什么是渲染状态？很多人都很困惑，其实就是一连串的开关或方法以及方法的地址指向。&lt;/h6&gt;

&lt;p&gt;比如：要不要开启混合，使用哪张纹理，使用哪个顶点着色器，使用哪个片元着色器，剔除背面还是剔除前面亦或都不剔除，使用哪些光源等等。&lt;/p&gt;

&lt;p&gt;通俗的来说，设置渲染状态，就是设置并决定接下来的网格如何渲染，有了渲染的具体方法，至于具体的渲染工作则是由GPU来执行。&lt;/p&gt;

&lt;p&gt;有了渲染的具体方法，就要调用渲染的具体对象，这就是渲染调用即 Draw call 做的工作。实际上 Draw call 就是一个命令，它的发起方是CPU，接收方是GPU，这个命令仅仅指向了一连串的图元（即点,线,面，我们可以理解为网格被拆分后的状态），并不会包含其他任何材质信息。&lt;/p&gt;

&lt;p&gt;每个 Draw call 前面都伴随着一个渲染状态的设置，因此整个渲染命令队列中都是一对对出现的，并且都是由CPU向GPU提交。&lt;/p&gt;

&lt;h6&gt;那么为什么要有这个渲染命令队列呢？&lt;/h6&gt;

&lt;p&gt;因为CPU和GPU相当于是两个大脑，它们是分离的，如果没有很好的协调机制，它们无法正常梳理自己的工作。一个命令缓冲队列就是用来协调CPU与GPU的，CPU只管向命令缓冲队列中推数据，GPU只管取数据并且处理数据，取一个处理一个，其他时间的都自顾自的忙自己的事。这个命令缓冲队列成了CPU与GPU的关系纽带。&lt;/p&gt;

&lt;p&gt;这条关系纽带(命令缓冲队列)很好的连接了CPU与GPU，但也成了它们之间交互的瓶颈，即我们通常所说的 Draw call 太多时GPU的工作效率比较差。其根本原因就是 CPU 发送了很多渲染命令后，只是空转的等待GPU完成这些渲染操作。&lt;/p&gt;

&lt;h6&gt;几何阶段&lt;/h6&gt;

&lt;p&gt;CPU准备好数据后，向GPU发送了渲染状态的设置命令和渲染调用命令后，接下来的工作就完全属于GPU了。&lt;/p&gt;

&lt;p&gt;接下来进入的是几何阶段的工作。几何阶段最终的工作目标是将需要绘制的图元转化到屏幕空间中，所以它决定了哪些图元要绘制，怎么绘制。&lt;/p&gt;

&lt;p&gt;图元即点、线、面。我们可以理解为网格的拆分状态，是着色器中的基础数据，在几何阶段作用最大。&lt;/p&gt;

&lt;h6&gt;几何阶段会经过几个节点，按顺序排列为，顶点着色器，曲面细分着色器，细分计算着色器，几何着色器，图元装配，裁减和剪切。如下图所示：&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺图
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中几何阶段分拆成了，顶点着色器、曲面细分着色器、细分计算着色器、几何着色器、图元装配、裁剪和剪切，6个节点。&lt;/p&gt;

&lt;p&gt;顶点着色器会对每个顶点进行逐一的计算，OpenGL会调用一个顶点处理函数来处理顶点数据。&lt;/p&gt;

&lt;p&gt;这个顶点处理函数就是我们可编程的部分，它可以很简单，只是数据复制并传递到下一个节点，也可以很复杂，例如变换矩阵的方式来得到顶点在屏幕上的位置，或者通过光照计算来判断顶点的颜色，或者记录和计算其他下一个阶段需要的信息。具体我们将在后面的章节中详细讲解。&lt;/p&gt;

&lt;p&gt;曲面细分着色器，细分计算着色器，几何着色器，都是可选的着色器。细分着色器包括曲面细分着色器和细分计算着色器会使用面片来描述一个物体的形状，并且增加面片数量使得模型外观更加平顺。几何着色器则允许增加和创建新的图元，这是唯一一个能自定义增加新图元的着色器。&lt;/p&gt;

&lt;p&gt;前面几个着色器节点处理的都是顶点数据，到了图元装配节点，它将这些顶点与相关的几何图元之间组织起来为下一步的裁剪和剪切工作做准备。&lt;/p&gt;

&lt;h6&gt;经历过前面几个阶段的变换，特别是在顶点着色器中的顶点空间转换，从模型空间到世界空间再到视口空间再到投影空间，Unity3D的Shader中常见的UNITY_MVP就是这个坐标空间转换的矩阵，再经过硬件上透视除法后得到了归一化的设备坐标，这使得到裁剪和剪切节点时，这个归一化的设备坐标使得裁剪会更加容易，不仅如此还对后面的深度缓冲和测试有很大的帮助。&lt;/h6&gt;

&lt;p&gt;归一化后的设备坐标(Normalized Device Coordinates, NDC)可以看做是一个矩形内的坐标体系，这个坐标体系是一个立方体的坐标体系，所有在这个坐标体系内的顶点的坐标都不会超过1到-1之间，无论x、y、z。&lt;/p&gt;

&lt;p&gt;为了能更好的理解经过空间转换后的顶点在后面几个阶段上应用的数据，有必要在这里来理解一下空间坐标系转换前后的样子，如下图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺图1

    缺图2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述图1中我们看到原本在视锥体上的物体，在经过空间矩阵转换后，视口从锥体变为了立方体，而原本在视锥体中的物体则从长方体变成了锥体，这是空间坐标系转化后的结果。&lt;/p&gt;

&lt;h6&gt;其中需要特别注意的是原本在视锥体坐标系上向前方向(forward)的X坐标轴变为了Z轴方向，整个立方体平面由x、y组成二维坐标体系。&lt;/h6&gt;

&lt;h6&gt;相当于，x、y坐标成为了可以映射到屏幕上的相对坐标，z坐标则被用来作为离屏幕有多远的数值参考，这是因为归一化后的NDC坐标系与原本视锥体坐标系相比其Z轴方向发生了翻转。&lt;/h6&gt;

&lt;p&gt;归一化坐标让坐标范围固定在1到-1之间，使得后续对图元数据的处理变得更加简单。不过归一化坐标范围在OpenGL和DirectX上有所不同，在OpenGL上x、y、z坐标范围在[-1,1]之间，而在DirectX上则是[0,1]之间，但这并不影响最终在屏幕上的表达，只是规则不同而已。最终他们都会进行简单的线性变换映射到屏幕的平面矩形范围内。虽然在屏幕映射时，OpenGL和DirectX两者的差异有出现了，OpenGL以左下角为(0,0)点，而DirectX则以左上角为(0,0)点，显然是两个商家因为竞争而故意造成的，还好主流的图形编程接口并不多，不管怎样差异已经存在了我们只能小心留意。&lt;/p&gt;

&lt;p&gt;说了这么多就是为了更好的理解几何阶段最后一步裁剪和剪切。我们将顶点转化到了归一化的坐标空间后，裁剪就容易多了，再通过图元装配，又有了线段和三角形数据，剪切就可以开始了。&lt;/p&gt;

&lt;p&gt;一个图元和可视范围关系，要么完全在范围内，要么完全在范围外，要么就是部分在里面部分在外面。完全在范围内的图元继续向下传递，不做任何操作，完全在范围外的图元则被剔除掉不再进入到后面的阶段，部分在视野内的图元则需要进一步剪切处理，把在范围外的部分剔除掉并在边界处生成新的顶点来连接没有被剔除的顶点。如下图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺图
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中一个完整的三角形两个顶点在范围内，一个顶点在范围外，剪切后在边界上增加了两个顶点，这是比较复杂的情况，另一个中比较简单的情况时一个顶点在范围里，两个顶点在范围外，剪切后形成新的两个顶点与范围内的顶点结合后替换了原来的三角形。&lt;/p&gt;

&lt;h6&gt;我们来分析下那种复杂的情况，因为经过裁剪后三角形由3个顶点变成了4个顶点，成为了4边形，所以需要对这个四边形进行切割。切割的方法其实很简单，选一个新增的顶点与原本的两个顶点替换原来的三角形，另一个新增的顶点与前一个新增的顶点再加上一个旧顶点(这个旧顶点一定是剪切后新增的这个顶点的线段里的)形成新的三角形。&lt;/h6&gt;

&lt;p&gt;不仅如此，裁剪不仅仅是视口的裁剪，还有会有背面裁剪(Back-Face Culling)，即剔除面朝视口反方向的面片，将在后面的Shader编写中详细讲述。&lt;/p&gt;

&lt;p&gt;至此所有几何阶段的操作都结束了，总体来说几何阶段处理的是顶点，以及计算和准备下一个阶段需要用到的数据。&lt;/p&gt;

&lt;h6&gt;光栅化阶段&lt;/h6&gt;

&lt;p&gt;光栅化阶段分为三个节点，光栅化、片元着色器、逐片元操作。&lt;/p&gt;

&lt;p&gt;其中光栅化可以分成，三角形设置、三角形遍历两个节点。&lt;/p&gt;

&lt;p&gt;三角形设置即Triangle Setup，由于前面阶段都是空间意义上的顶点和三角形，到了光栅化阶段我们更加需要的屏幕上的像素，于是三角形设置可以认为是将所有三角形都铺在屏幕坐标平面上，这样就知道了每个三角形片面在屏幕上的范围，它用三角形边界的形式表达了这个覆盖面。&lt;/p&gt;

&lt;p&gt;知道覆盖面还不够，因为屏幕中展示的画面都是以像素为单位计算的，所以一个三角形覆盖哪些像素需要依靠扫描变换(Scan Conversion)得到，这个像素扫描阶段就是三角形遍历(Triangle Traversal)。如下图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺图
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中，在三角形遍历节点中像素依据三角形三条边计算得到像素覆盖范围，即哪些像素被认为是这个三角形内的覆盖范围，再通过三个顶点中信息的插值得到每个像素的信息，信息包括坐标，深度，颜色，法线，纹理坐标等都是顶点上的信息经过插值得到。&lt;/p&gt;

&lt;h6&gt;经过光栅化的节点，我们得到了三角形内每个像素上的信息，我们称它们为片元，每个片元包含了诸多信息。这个片元将被传递到下一个阶段即片元着色器。&lt;/h6&gt;

&lt;p&gt;片元着色器(Fragment Shader)就如字面意思那样，是处理片元的地方，它是可编程的阶段，我们在这里可以编写很多我们喜欢操作来改变片元的颜色，或者也可以丢弃该片元(discard 或者 clip)。&lt;/p&gt;

&lt;p&gt;每个片元就相当于一个像素，只是比起像素，片元装载了很多的信息，这些信息都是通过前面三角形遍历时对三个顶点中的信息插值得到的。&lt;/p&gt;

&lt;p&gt;经过片元着色器的处理，也就是我们编写的片元着色程序的处理后，最终输出的也是片元，我们通常都在片元着色器中计算改变片元的颜色，最终得到一个我们想要的输出到屏幕的片元。&lt;/p&gt;

&lt;h6&gt;这里有一个重点，每次片元着色器处理片元的只是单个片元，也就是单个一个像素，对于片元着色器来说它并不知道相邻的片元是什么样，因此每个片元在处理时无法得到邻近的片元的信息。&lt;/h6&gt;

&lt;p&gt;得不到邻近的片元信息不代表我们就不可以受到邻近的片元影响，虽然每次片元着色器传入的和处理的都是单个片元，但GPU在跑片元着色器时并不是只跑一个片元着色器，而是将其组织成2x2的一组片元块同时跑4个片元着色器。如下图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺图
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上图中，描绘了4个片元组成的片元组，以及偏导数函数对它们的计算过程。我们可以通过ddx和ddy这两个偏导数函数来求得邻近片元的差值。偏导数函数可以用于片元着色器中的任何变量。对于向量和矩阵类型的变量，该函数会计算变量的每一个元素的偏导数。&lt;/p&gt;

&lt;p&gt;偏导数函数是纹理Mipmaps实现的基础，我们将在后面的章节中详细讲解。&lt;/p&gt;

&lt;p&gt;除了计算片元的颜色，我们还可以在片元着色器中丢弃某些片元(discard 或者 clip)，我们常说的Alpha Test就是一个应用丢弃片元来实现的效果，我们将在后面的章节中详细讲解 Alpha Test的原理与利弊。&lt;/p&gt;

&lt;h6&gt;片元着色器和顶点着色器是我们在着色器编程时最重要的两个节点，如果我们想要更通俗简单的理解顶点着色器和片元着色器的区别的话，可以认为：顶点着色器(包括细分着色器和几何着色器)决定了一个三角形应该放在屏幕的什么位置，而片元着色器则用这个三角形包括它的顶点和线段来决定三角形范围内的像素拥有什么样的颜色。&lt;/h6&gt;

&lt;p&gt;片元着色器输出片元后，进入了逐片元操作阶段，也是渲染管线的最后一步。&lt;/p&gt;

&lt;h6&gt;下一节继续讲解剩余的逐片元操作阶段。&lt;/h6&gt;
</description>
               <pubDate>Sat, 21 Sep 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/09/21/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A64.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/09/21/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A64.html</guid>
            </item>
        
            <item>
               <title>思路探讨(二十八) 如何应对彷徨</title>
               <description>&lt;p&gt;人时不时的总会彷徨的，每个人都一样。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;经常性的会迷失方向，看不清未来。无论我们前面有过多少清晰的认识，或者说多少深刻的觉悟，总是会在某个时刻感受到无法言语的痛苦。&lt;/p&gt;

&lt;p&gt;痛苦从何而来？是前面未知的道路吗，有可能，是疲劳吗，也有，是周遭向我们袭来的负能量吗，肯定有的，是因为没有计划使得自己总感觉是在胡乱的东奔西跑吗，是的。&lt;/p&gt;

&lt;p&gt;精神上和身体上的疲惫，说实在的无论怎么样都会累的，疲劳了就休息一下么，可能太久没有回家了，好想家，那就回家，感受下家的温暖。&lt;/p&gt;

&lt;p&gt;不工作也会累，工作也会累，说实在的其实很多时候精神力是要运作的，我们怎么运作有限的精力和时间，让最饱满的精力用在最重要的事情上，让零星的时间能变得更加充实，这是门学问，这一年多时间我一直在学习时间管理和自律，现在顿悟到精力管理也很重要。&lt;/p&gt;

&lt;p&gt;周遭的负能量能不能屏蔽掉，可以的，人很容易被周遭的环境打乱自己的节奏，我们需要更强大屏蔽能力，闭屏掉所有负能量。这一点我认为明星们做的很好，作为大众的明星，对他/她褒贬不一的评价从全国四面八方袭来，如果没有强大的屏蔽负能量的能力，人很容易就崩溃，但他们做的很好，可以做到自然的屏蔽掉负能量全力做自己。&lt;/p&gt;

&lt;p&gt;能不能为自己提早制定计划，计划确实赶不上变化，至少制定了计划可以让自己知道后面会遇到哪些困难，我需要制定每周的计划，每个月的计划，这样才能有效预知未来前进过程中可能遇到的问题、瓶颈、障碍、困难。&lt;/p&gt;

&lt;p&gt;彷徨无法避免，但我想能不能减少彷徨的频率？怎样才能减少彷徨的频率呢，我可不可以，自己给自己一点多一些安全感，这样就会少一点彷徨。&lt;/p&gt;

&lt;p&gt;怎么给自己多一些安全感？&lt;/p&gt;

&lt;p&gt;为未来优秀的自己积累知识、能力、财富。如果我足够优秀，知识量足够多，能力足够强大，财富足够多，我彷徨的频率肯定就少一些，对未来和当前肯定更加坚定一些，专注力也会更加好一些。&lt;/p&gt;

&lt;p&gt;我要怎样才能达到这个目标？&lt;/p&gt;

&lt;p&gt;关键在于，’积累‘！每天几页书，每天抽出时间学习一下，每天运动一下保持精力充沛，少一些娱乐把精力用在更加重要的事情上，每天这样做，每天。&lt;/p&gt;

&lt;p&gt;只有你肯执行下去、坚持下去，无论现在处于什么样的状态，5年后你一定就是人才，10年后你将是名人，20年后你将是巨星。&lt;/p&gt;

&lt;p&gt;有一次看到一个公众号发的一个消息，上面标题写着“如果一个人20岁开始自律20年会如何”，好奇的点进去一看，三个大字刻进我心中，“曾国藩”。&lt;/p&gt;

&lt;p&gt;于是我阅读了曾国藩的书，我并没有要成为曾国藩，但我明白了自律的重要性。&lt;/p&gt;

&lt;p&gt;从那一刻开始，我想，他自律20年，我能不能自律10年，我想试试，我要挑战自己，要突破自己的瓶颈。&lt;/p&gt;

&lt;h6&gt;良好的心态是人生的重要组成部分&lt;/h6&gt;

&lt;p&gt;保持一种辛苦的感觉才是正确的，辛苦表明你正在努力突破自己，当你感觉不到辛苦时，很有可能你正在慢慢向下滑坡，只是现在外在表象还没发生任何变化，所以无法让你引起足够的重视，一旦表象上发生了什么变化，说明量变已经造成了质变，这时已经来不及了，能做的也只有补救，如果也没有做什么及时补救的行动那么可能前面自己所建立的优势也就会像过往云烟那样消散而去，自己重新回到了被动和劣势的位置。&lt;/p&gt;

&lt;p&gt;不过只有辛苦的感觉其实是还不够的，在辛苦的基础上，每天都要感觉自己活得很充实，活得很对得起昨天的感觉，只有这样一步步往前走下去才是正确的道路。&lt;/p&gt;

&lt;p&gt;人在生命中的道路上行走，犹如在黑暗中行走那样，是看不到前方清楚的道路的，只有当你主动积极的去做一些事情时才能看清前面几米距离的道路，就这样每次看见的都只是前方几米距离的道路，永远都是这种状况。&lt;/p&gt;

&lt;h6&gt;如果不努力我们会一直处于这种看不清前方道路的处境中。&lt;/h6&gt;

&lt;p&gt;只有当你很努力并且持续不断的努力，其实也只有持续不断的努力才能让你渐渐的看清前方的道路，让你更少的时间处于焦虑之中，也只有在我们不断努力下才能强大自我，才能在如此残酷的社会竞争中找到自己的定位。&lt;/p&gt;

&lt;p&gt;我们自己是很难找到自己的问题的，愚蠢的人是不知道自己愚蠢的，但其实我们自己也不知道自己是不是愚蠢。&lt;/p&gt;

&lt;p&gt;有没这种可能，其实我们是愚蠢的，但在自己看自己是聪明的，自己看别人是愚蠢的。每个人确实是这样认为的。&lt;/p&gt;

&lt;p&gt;几乎所有人都这么认为，’我是聪明的，别人是愚蠢的‘，就因为这种盲目乐观的思维方式根深蒂固，我们才难以察觉和发现自己的问题。&lt;/p&gt;

&lt;h6&gt;不努力，我们是看不到自己的问题的。我很确信。不努力学习，不努力工作，不努力地去克制自己，我们可能永远都无法发现自己的问题。所谓的突破自我，也是因为在努力很久的情况下看清了自己的问题，从而解决了自己身上的问题，才最终得到了进阶和升华。&lt;/h6&gt;

&lt;h6&gt;人永远都是处于‘坏’环境下&lt;/h6&gt;

&lt;p&gt;刚工作那几年我一直以为是因为我个人的命途多舛才造就的这么多阻碍和困境，也一直以抱怨的态度对待环境，但渐渐的我发现，其实不只是我，天底下所有的人都处于这种‘坏’环境下，我们永远都感觉被束缚，被阻碍，被捆绑，被遏制，无论这个环境在外人看来有多好有多向往有多羡慕。&lt;/p&gt;

&lt;p&gt;其实最理智的方法是不去抱怨环境，环境永远是受限的，资源永远是缺少的，做好自己，解决自己身上的毛病才是最重要的。如果环境实在差的离谱，有更好的环境就直接去更好的环境，那里会更专注，努力的效果可能会更好，如果没有机会去更好的环境，那么就做好自己。&lt;/p&gt;
</description>
               <pubDate>Mon, 09 Sep 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/09/09/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A828.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/09/09/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A828.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(一) - 图形学基础2</title>
               <description>&lt;h3&gt;理解矩阵表达缩放的几何意义&lt;/h3&gt;

&lt;p&gt;缩放矩阵和旋转矩阵在几何意义上有着异曲同工之妙，我们同样用二维坐标系来表达缩放矩阵的两个 a,b 向量。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;举例来说，二维标准轴的旋转矩阵：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [1.5,  0]  等  [a]
    [0, 0.75]  于  [b]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们把 a和b 表现在二维坐标系中，即如图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中a，b两个向量可以形成了一个矩形，我们就假设这个矩形图像表达了a，b向量的缩放关系。当a，b被拉长时，这个矩形图像被也同样被拉长。&lt;/p&gt;

&lt;p&gt;其原理为向量与矩阵的乘法，我们知道&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    二维向量与二维矩阵相乘 = (x * m11 + y * m21, x * m12 + y * m22)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于我们上图中标准坐标系上的缩放矩阵来说的到的结果是 (1.5&lt;em&gt;x, 0.75&lt;/em&gt;y)，即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    (x*m11 + y*m21, x*m12 + y*m22) = (x*1.5 + y*0, x*0 + y*0.75) = (1.5*x, 0.75*y)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个结果表达了，缩放矩阵对向量缩放时非常直观易懂，因为除了对角线上的数字，其他位置的数字都是0。&lt;/p&gt;

&lt;p&gt;不过这种简单易懂的旋转矩阵，也仅限于标准坐标系中对标准轴的缩放。如果只有标准坐标系上的缩放计算，是远远满足不了我们的需求的。&lt;/p&gt;

&lt;p&gt;那么怎么计算对任意轴方向上的缩放呢？我们来看如下图所示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;沿 N 方向缩放 v 向量，其实和前一节中绕 N 轴旋转 v 向量有异曲同工之妙。&lt;/p&gt;

&lt;p&gt;我们需要根据所知道的推导这个公式，即我们已知v，已知 N，已知缩放因子k (k是一个单纯的数字) ，要求得v’。&lt;/p&gt;

&lt;p&gt;可以通过 N 和 v 求得投影 v1，通过 v 和 v1 求得他们的垂直向量 v2，再通过缩放因子 k 求得v1和v2缩放后的向量 v1‘ 和 v2’，最后通过 v1‘ 和 v2’ 求得缩放后的结果向量 v‘，即如下图公式。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样的，三维空间中，如果是标准坐标系上缩放，则缩放矩阵可以是很简单的对角线矩阵，即。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [scale-x, 0, 0]
    [0, scale-y, 0]
    [0, 0, scale-z]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也同样的，这种标准坐标系上的缩放完全满足不了我们的需求，我们需要沿任意向量上的缩放矩阵。&lt;/p&gt;

&lt;p&gt;同样的向量，同样的变化，同样的推导，最终结果为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终我们获得了，沿任意方向缩放的矩阵。&lt;/p&gt;

&lt;p&gt;这里不再重复叙述推导的过程，我们只要理解缩放矩阵的由来和推导的方式就可以了，我们最终的目的通过是解释原理来理解缩放矩阵的几何意义。&lt;/p&gt;

&lt;h3&gt;平行投影，镜像，切变的理解和几何意义&lt;/h3&gt;

&lt;h6&gt;平行投影&lt;/h6&gt;

&lt;p&gt;在上述几节中我们了解到了可以用矩阵去缩放任意点和向量，那么如果在缩放时某个轴上的缩放因子为零会变成是什么样的呢，如图所示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中模型所有的点都被’挤‘到了一个平面上，这种所有点都被拉平至垂直轴或平面上的做法就叫，平行投影，或者也可以叫正交投影。&lt;/p&gt;

&lt;p&gt;在标准坐标轴上的平行投影是一个很简单的矩阵，只要把那个投影轴上的缩放因子置零就可以，即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    二维上x轴平行投影

    [1, 0]
    [0, 0]

    二维上y轴平行投影

    [0, 0]
    [0, 1]

    三维上xy平面上的平行投影

    [1, 0, 0]
    [0, 1, 0]
    [0, 0, 0]

    三维上xz平面上的平行投影

    [1, 0, 0]
    [0, 0, 0]
    [0, 0, 1]

    三维上yz平面上的平行投影

    [0, 0, 0]
    [0, 1, 0]
    [0, 0, 1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然只是标准坐标轴上的平行投影还不够用，我们也需要任意直线或任意平面的投影矩阵，不过这次我们不需要再次计算任意轴上的平行投影，只需要通过前面计算过的缩放矩阵在任意方向或任意轴上的缩放矩阵就可以得到平行投影的矩阵，即如下图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过使缩放方向上的缩放因子变为零的方式，来获得平行投影矩阵。三维中也是一样，只是在三维中要 N 方向为垂直平面的方向而不是平行于平面的方向。&lt;/p&gt;

&lt;h6&gt;镜像&lt;/h6&gt;

&lt;p&gt;镜像其实挺容易理解的，平行投影是将某个轴上的缩放因子变为零，镜像就是在某个轴上将缩放因子变为负1，这样在缩放时就形成了‘翻转’的局面。如图所示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;坐标轴的四个象限，右上角的图为正常的图案，左边为对x轴翻转后的图案，下边为y轴翻转后的图案，右下角为x轴和y轴同时翻转的图案。&lt;/p&gt;

&lt;p&gt;镜像矩阵也和平行投影矩阵一样，可以用任意缩放矩阵来计算出对任意方向和轴的镜像矩阵，如图所示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中为任意方向的缩放矩阵在当缩放因子为-1时的公式，我们很容易就明白，镜像不过是缩放的一种特殊形式。&lt;/p&gt;

&lt;h6&gt;切变&lt;/h6&gt;

&lt;p&gt;切变非常特殊和有趣，它其实是一种坐标系‘扭曲’变换。这种坐标系的‘扭曲’变换将会被运用到对次级空间的坐标平移上。切变的形式如图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中y轴方向的向量中的x坐标被平移了。这是切变在x轴上的变化，我们也可以让切变在y轴上发生变化，如图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两种形式的切变都是通过位移x轴方向上的坐标或y轴方向上的坐标来达到的，其实我们可以理解为对次级维度坐标系的‘扭曲’。&lt;/p&gt;

&lt;p&gt;为什么要这么理解呢，因为它在仿射变化中起到了非常关键的作用，我们将在下面几节内容中介绍。&lt;/p&gt;

&lt;p&gt;切变的矩阵为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    二维x轴方向的‘扭曲’
    [1, 0]
    [s, 1]

    二维y轴方向的‘扭曲’
    [1, s]
    [0, 1]

    三维x,y轴方向的的切变
    [1, 0, 0]
    [0, 1, 0]
    [s, t, 1]

    三维x,z轴方向的切变
    [1, 0, 0]
    [s, 1, t]
    [0, 0, 1]

    三维y,z轴方向的切变
    [1, s, t]
    [0, 1, 0]
    [0, 0, 1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这几个矩阵看起来好像很简单，具体代表什么意思呢。我们用向量与矩阵的乘法表示就知道了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    向量p与3x3矩阵M的乘法 p * M = [x * M11 + y * M21 + z * M31, x * M12 + y * M22 + z * M32, x * M13 + y * M23 + z * M33]

    由向量与矩阵的乘法得知上面5个矩阵，当向量乘以他们时：

    第一个切变矩阵为向量x轴方向的偏移，(x + y * s, y)

    第二个切变矩阵为向量y轴方向的偏移，(x, x * s + y)

    第三个切变矩阵为向量x、y轴方向的起偏移，(x + s * z, y + t * z, z)

    第四个切变矩阵为向量x、z轴方向的起偏移，(x + s * y, y, t * y + z)

    第五个切变矩阵为向量y、z轴方向的起偏移，(x, s * x + y, t * x + z)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述经过矩阵乘法后，向量得到了切变的偏移，如果乘的是矩阵的话，则会对矩阵产生切变。下面一节平移中就会应用到切变的变化。&lt;/p&gt;

&lt;h6&gt;齐次坐标的平移矩阵&lt;/h6&gt;

&lt;p&gt;我们知道了3x3矩阵的线性变换中不包括平移这个操作，为什么呢？&lt;/p&gt;

&lt;p&gt;因为矩阵乘法的性质，零向量乘法总是变换成零向量，任何相同维度的矩阵乘法都表达不了零偏移。&lt;/p&gt;

&lt;p&gt;矩阵乘法其实很强大，经过我们上面的介绍我们已经知道了矩阵乘法可以表达旋转，缩放，投影，镜像，切变，可惜的是无法表达平移，怎么办？&lt;/p&gt;

&lt;p&gt;齐次矩阵就恰好满足了我们的需求，齐次矩阵它在原来的维度上增加了一个维度，用多出来的那个维度来表达了平移操作。即如下图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [1, 0, 0, 0]
    [0, 1, 0, 0]
    [0, 0, 1, 0]
    [x, y, z, 1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上图中用增加一个维度的方式用x，y，z分别表示了在x，y，z轴上的偏移。&lt;/p&gt;

&lt;p&gt;为什么这种方式就能表达平移操作？&lt;/p&gt;

&lt;p&gt;我们回忆下上一节说的切变的原理和过程，在某个轴不变的情况下对其他轴进行偏移，这就是切变。&lt;/p&gt;

&lt;p&gt;我们无法对当前空间的矩阵进行偏移，却可以通过增加一个维度，用不动新增的维度情况下，再用切变的方式来偏移次级维度，这其实就是个用切变解决平移问题的解决方案。&lt;/p&gt;

&lt;p&gt;在上述的图中描述了4维矩阵在第四维空间上的切变。有了平移矩阵，我们可以通过用3x3矩阵增加一个维度的方式，把原来无法表达的操作全都可以表达出来了。&lt;/p&gt;

&lt;p&gt;比如，我们需要一个将向量 v 旋转后再平移得到 v‘ ，旋转矩阵为R，平移矩阵为T，就可以用向量与矩阵的乘法，以及矩阵与矩阵的乘法来表达：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    v&amp;#39; = vRT

    R为：
    [r11, r12, r13, 0]
    [r21, r22, r23, 0]
    [r31, r32, r33, 0]
    [0,     0,   0, 1]

    T为：
    [1, 0, 0, 0]
    [0, 1, 0, 0]
    [0, 0, 1, 0]
    [x, y, z, 1]

    通过结合律 v&amp;#39; = vRT = v(RT)

    R与T相乘的结果为
    [r11, r12, r13, 0]
    [r21, r22, r23, 0]
    [r31, r32, r33, 0]
    [x,     y,   z, 1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上图中通过乘以旋转矩阵和平移矩阵就可以得到最终结果，或者使用结合律先将矩阵相乘。对于矩阵结合的方式，如果这种系列操作方式比较频繁，可以建立一个固定的常量矩阵，通过常量矩阵来计算结果，这样就省去了很多频繁的重复计算矩阵的过程，顶点着色器中的顶点坐标空间转换就是这样做的，它在整个程序开始执行前就已经计算好了一个变化的矩阵，这个变化的矩阵就叫做 MVP，即Model，View，Projection，它是由模型空间矩阵、观察者空间矩阵、投影空间矩阵相乘得到的结果，乘以此矩阵就会从模型坐标系变换为世界坐标系，再变换为观察者坐标系，最后变化为视锥体的裁剪空间。&lt;/p&gt;

&lt;p&gt;有了平移矩阵我们能做的事更加多了，能运用的地方也更加多了。这次我们用到了齐次矩阵，即通过增加一个维度的方式来表达当前维度无法表达的计算，用高一个维度的切变来表达操作次级维度的平移。&lt;/p&gt;

&lt;h3&gt;如何理解 Quaternion 四元数&lt;/h3&gt;

&lt;h6&gt;为什么不是欧拉角&lt;/h6&gt;

&lt;p&gt;欧拉角的定义是，x,y,z 分别表达了x轴上的旋转角度，y轴上的旋转角度，z轴上的旋转角度，即(20,40,50) 表达了在x轴上旋转20度，y轴上旋转40度，z轴上旋转50度。&lt;/p&gt;

&lt;p&gt;看起来很简单易懂就能定义坐标系上的旋转角度，为什么就不能使用它来表达所有的旋转角度，却还要使用四元数呢？其实是有原因的。&lt;/p&gt;

&lt;p&gt;首先欧拉角存在别名，100度的旋转角度可以用-260度来表示，370度角与10度角以及-350度角是相同的旋转角度，这种表达方式在计算上特别难统一。&lt;/p&gt;

&lt;p&gt;其次欧拉角在插值上存在些问题，一个-260度的角度和一个50度的角度进行插值是需要先进行转换的，先将-260度转换成100度，再进行插值才可以得到正确的结果。简单的别名问题虽然讨厌，但是可以转换角度的方式解决，但转换角度这种方式并不是一个靠谱的方式，在计算过程中会遇到相当多的麻烦。&lt;/p&gt;

&lt;p&gt;欧拉角这种周期性和旋转之间的不独立性造成了欧拉角在线性变化的计算中比较困难。因此我们需要寻找在计算过程中更加便捷的方法，不需要转换，没有别名，统一规格。&lt;/p&gt;

&lt;p&gt;四元数恰好就满足了这些需求，它在线性变换中非常统一而且灵活。不过它有一个致命的缺陷，就是在表现上让你人比较难理解，普通人一眼看不出一个四元数想要表达的旋转的方向和角度。&lt;/p&gt;

&lt;h6&gt;四元数的由来&lt;/h6&gt;

&lt;p&gt;四元数其实是一个我们生活中的“异次元”，这也是为什么普通人难以理解它的原因，为什么说它是一个“异次元”呢？&lt;/p&gt;

&lt;p&gt;我们所有的向量，坐标，矩阵，旋转，缩放，平移，都是建立在使用坐标系和空间矩阵计算的那一套计算体系上的，而四元数则不是，它特立独行，它计算所用的公式，并不是建立在传统的坐标系矩阵上，而是拥有自己一套“自有”的公式体系，即复数体系。&lt;/p&gt;

&lt;p&gt;四元数有两种记法即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    向量v 加 w分量 (v, w) 和 四个分量都分开 (x, y, z, w)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;某些情况下v分量更方便，而在另一些情况下分开记会更清楚。但其实这个w分量和x,y,z的相关度有但不是很大，因此不要被迷惑了，以为他们的值越大或者越小会怎样怎样的，其实和我们肉眼看到的是有所差别的。&lt;/p&gt;

&lt;p&gt;最早数学家们是用复数系统来表达二维中的旋转的。&lt;/p&gt;

&lt;p&gt;我们来回忆下什么是复数？&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    我们把形如z=a+bi（a,b均为实数）的数称为复数，其中a称为实部，b称为虚部，i称为虚数单位。
    其中虚数 i * i = -1；
    当z的虚部等于零时，常称z为实数；
    当z的虚部不等于零时，实部等于零时，常称z为纯虚数。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;数学家使用复数对(a, b)来表达二维平面中的旋转，他们把向量也定义为复数对，如果(a,b)为向量的话，那么就定义了 a + b * i，i为虚数，满足 i * i = -1，a为实轴的坐标，b为虚轴坐标，我们可以理解为x，y轴上的坐标。&lt;/p&gt;

&lt;p&gt;对于定义一个旋转复数，则为 (cos(β), sin(β)) 表达式为 cos(β) + sin(β) * i，i为虚数，β为旋转的角度。&lt;/p&gt;

&lt;p&gt;他们发现从平面上求得某个向量旋转 β 的结果，可以用向量复数对乘以旋转复数对的方式来获得，即&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片

    v = x + y * i
    r = cos(β) + sin(β) * i
    v&amp;#39; = vr = (x + y * i)(cos(β) + sin(β) * i)
       = (x * cos(β) - y * sin(β)) + (x * sin(β) + y * cos(β)) * i
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述图中的公式推导，乘法的运算看起来是不是跟传统的计算有点差异。因为我们使用的是复数做运算，其中i满足 i * i = -1。&lt;/p&gt;

&lt;p&gt;这是最早发明的二维向量旋转运算法则，由十六世纪被意大利米兰学者卡当提出复数后，经过达朗贝尔、棣莫弗、欧拉、高斯等人的工作，最后成形的数学体系。&lt;/p&gt;

&lt;p&gt;不过二维的上的旋转公式很快就不够用，无法对三维的旋转操作，旋转复数局限性太大。爱尔兰数学家 William Hamilton 终于在1843年找到了一种表达三维旋转的复数表达方式，即四元数就此诞生。&lt;/p&gt;

&lt;h6&gt;四元数的几何意义&lt;/h6&gt;

&lt;p&gt;四元数扩展了复数系统，它使用了三个虚部，即i，j，k，因此四元数的表达复数表达方式为&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    q = w + i * x + j * y + k * z
    其中i，j，k为虚数，即满足
    i*i = j*j = k*k = -1
    i*j=k, ji=-k
    j*k=i, k*j=-i
    k*i=j, i*k=-j
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和复数能用来旋转二维中的向量类似，四元数也能用来旋转三维中的向量。&lt;/p&gt;

&lt;p&gt;四元数被解释为角位移的轴一角方式。什么是轴一角？&lt;/p&gt;

&lt;p&gt;就是绕某个单一轴旋转一个角位移就能表达旋转的方式就叫轴一角，这个角位移其实就是一个和向量类似的表达方式，即(x,y,z)，只不过四元组用4个元素来表达罢了。&lt;/p&gt;

&lt;p&gt;再通俗点，四元组可以理解为绕 某个轴N 旋转的角位移，和欧拉角用x,y,z表达绕标准坐标轴旋转是同样的道理，只不过这个轴不再是标准轴，而是任意轴。&lt;/p&gt;

&lt;p&gt;这也就说明了，四元组不再受到标准轴的限制，它可以表达绕任意轴旋转的角位移。&lt;/p&gt;

&lt;p&gt;四元组表示为对任意轴 N 的角位移即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    q = [cos(β/2), sin(β/2) * N]
      = [cos(β/2), sin(β/2) * Nx, sin(β/2) * Ny, sin(β/2) * Nz]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;利用上图的四元组表达方式，假设我们绕的是某个单轴旋转，也就是在x轴上旋转 A 度，或者在y轴上旋转 B 度，或者在z轴上旋转 C 度，根据上述的公式，我们可以得到三个供旋转的四元数，即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    A&amp;#39; = [cos(-A/2), sin(-A/2) * 1, 0, 0]

    B&amp;#39; = [cos(-B/2), 0, sin(-B/2) * 1, 0]

    C&amp;#39; = [cos(-C/2), 0, 0, sin(-C/2) * 1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上图中的角度为什么是负的，因为我们在旋转点时的角度，和在旋转坐标系时的角度恰恰是相反的，因此操作旋转点的角度，其实就是旋转坐标系反方向的角度，即负的角度。&lt;/p&gt;

&lt;p&gt;现在我们要计算绕x轴上旋转A角度，并且绕y轴上旋转B角度，并且绕z轴上旋转C角度的四元组时，可以把 A‘，B’，C‘，这三个四元组乘起来，即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    A&amp;#39;B&amp;#39;C&amp;#39; = (A&amp;#39;B&amp;#39;C&amp;#39;) 最终计算得到

    [x,]
    [y,]
    [z,]
    [w]

    等于

    [cos(B/2)sin(A/2)cos(C/2) + sin(B/2)cos(A/2)sin(C/2),]
    [sin(B/2)cos(A/2)cos(C/2) - cos(B/2)sin(A/2)sin(C/2),]
    [cos(B/2)cos(A/2)sin(C/2) - sin(B/2)sin(A/2)cos(C/2),]
    [cos(B/2)cos(A/2)cos(C/2) + sin(B/2)sin(A/2)sin(C/2)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上图中得到的最后公式就是从欧拉角转换到四元数的计算公式。&lt;/p&gt;

&lt;p&gt;四元数的虽然在计算上很方便且通用，但在辨识度上却存在着严重的缺陷，人肉眼很难分辨某个四元数的旋转情况。但是没关系，我们只要理解它的原理，并且已经知道了四元数的几何意义，我们在运用四元数过程中将更加自如。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;p&gt;《3D数学基础:图形与游戏开发》&lt;/p&gt;
</description>
               <pubDate>Sat, 07 Sep 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/09/07/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A62.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/09/07/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A62.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(一) - 图形学基础1</title>
               <description>&lt;p&gt;游戏项目除了逻辑，模块，框架，架构，算法，还需要图形学的支撑，很多人在业务层面打拼了很多年也始终无法突破的原因就是对图形学研究还不够深。&lt;/p&gt;

&lt;p&gt;最终我们还是要面对图形的绘制和计算的，所以这块也是非常重要的部分，只是在使用了现代图形引擎之后，特别是使用了Unity3D之后，它为我们包装了很多工具和接口，用起来很方便，但就因为方便往往忘了图形学知识的重大意义。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;其实缺哪块都不行，没有逻辑，不懂得各个模块的编写手法，不懂得框架的搭建，不懂架构，或者不懂算法，不懂图形学，都是在无法完整的体现一个优秀程序员的知识面的，特别是对于那些需要在一个项目中当起顶梁柱的主程同学，对于每个部分的都需要了如指掌，特别是图形学部分，因为它很容易被忽视，也特别需要我们静下心来学习、理解、掌握。&lt;/p&gt;

&lt;p&gt;非常想从最最基本的讲起，但我们毕竟是一本面向中高级程序员的书，所以不在将更多篇幅用在对点，线，面，向量，坐标系等的文字说明和介绍上了。&lt;/p&gt;

&lt;p&gt;我们特别挑出了比较重要部分与Unity3D结合的来细致讲解一下。&lt;/p&gt;

&lt;h3&gt;Vector3 的意义&lt;/h3&gt;

&lt;p&gt;Vector3 有，x，y，z三个变量，我们一眼就识别它是个代表坐标的数据。&lt;/p&gt;

&lt;p&gt;不仅如此，其实它还可以代表 距离，速度，位移，加速度，还有方向。&lt;/p&gt;

&lt;p&gt;两个Vector3变量a，b的相减，就能得到一个从b点到a点的向量c。&lt;/p&gt;

&lt;p&gt;这个c是一个长度为a到b的距离并且具备b到a的方向的向量，c也同样是一个Vector3，那么为什么a，b就是坐标，c就是向量呢。&lt;/p&gt;

&lt;p&gt;其实任何一个Vector3变量，确定它是坐标还是向量，全靠我们如何定义它。&lt;/p&gt;

&lt;p&gt;我们可以定义a是坐标，也可以定义a是速度，至于如何定义怎么计算，全靠我们在后面的程序中怎么对待它。&lt;/p&gt;

&lt;p&gt;速度，位移，加速度，也是同样的道理。我们再举个例子。&lt;/p&gt;

&lt;p&gt;还是a，b定义为Vector3的坐标点，a减去b，除以1，可以认为我们向量除以了一个时间1秒得到了我们需要的有方向的速度。&lt;/p&gt;

&lt;p&gt;再比如，a点减去b点，得到c向量，那么任意坐标加上c就会得到与a和b同样的相对位置的d点，那么c就成了位移。&lt;/p&gt;

&lt;p&gt;如果现在是四个坐标a，b，c，d，当a减去b除以1秒得到了a到b的时的速度，那么b减去c除以1秒得到也是b到c时的速度，如果这两个速度再相减，依然是Vector3，而此时这个Vector3已经不再代表坐标和速度，而是一个由两个Vector3的速度得到的加速度了。&lt;/p&gt;

&lt;h6&gt;赋予给Vector3什么样的意义全靠我们用它们来计算什么。&lt;/h6&gt;

&lt;p&gt;我们挑选了几个Vector3比较重要的几何意义。&lt;/p&gt;

&lt;h3&gt;Vector3点乘的几何意义&lt;/h3&gt;

&lt;p&gt;向量a，与，向量b点乘的计算公式为&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    a·b = (x1,y1,z1)·(x2,y2,z2) = x1*x2 + y1*y2 + z1*z2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而点乘又有另外一个计算公式即为&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    a·b = ||a||*||b||*cos(β)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即用更直观的如图所示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中a向量与b向量的夹角为β，a向量和b向量长度不变的情况下，计算出来的值越大，也就是β值越小，说明a和b的夹角越小。&lt;/p&gt;

&lt;p&gt;相反，当计算出来的值越小，也就是β值越小，说明a和b的夹角越大。&lt;/p&gt;

&lt;p&gt;当β大于90度时，计算出来的是一个负数，也就是b指向的方向其实与a指向的方向是相反的。&lt;/p&gt;

&lt;p&gt;我们用这种方式可以用点乘得到一个判断依据，即当a和b点乘得到的数为正数时，两者的方向比较一致，并且在长度相同的情况下结果越大越一致，而当点乘结果为负数时，a和b两者的方向则是相反的，在长度相同的情况下，数值负得越厉害，相反的程度越一致。&lt;/p&gt;

&lt;p&gt;除了方向判断外，我们还可以用点乘来计算出β的角度，即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    β = arcos( (a·b) / (|a|*|b|) )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;// todo Unity3D里的Vector3点乘API&lt;/p&gt;

&lt;h3&gt;Vector3叉乘的几何意义&lt;/h3&gt;

&lt;p&gt;与Vector3点乘一样，Vector3的叉乘也是类似的向量与向量之间的计算公式，不同的是，叉乘的结果不再是一个数值，而是一个同样维度的向量。即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    a x b = (a1, a2, a3) x (b1, b2, b3) = (a2*b3 - a3*b3, a3*b1 - a1*b3, a1*b2 - a2*b1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两个向量a，b的叉乘，得到的是与a，b向量形成的平面垂直的向量c。&lt;/p&gt;

&lt;p&gt;那么c的长度多少呢，其实a x b的长度等于向量的大小与向量的夹角sin值的积，即&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    |a x b| = |a|*|b|*sin(β)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即c的长度大小与a和b向量的夹角有关。这样看来，如果β为0时，即a和b是平行的，c就是0长度，当β为90度时，即a和b互相垂直时，a和b的叉乘长度就是a的模乘以b的模。&lt;/p&gt;

&lt;p&gt;此外，|a x b|得到的|a|&lt;em&gt;|b|&lt;/em&gt;sin(β)这个公式，就是a和b形成的四边形的面积值，即如图所示&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中四边形的体积公式其实是，|b| * h，那么h怎么得到呢，我们可以用|a| * sin(β) 得到，因此就有了这个公式的演变，即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    四边形面积 = |b| * h

    由于 h = |a| * sin(β) 代入后 =&amp;gt; 四边形面积 = |b| * |a| * sin(β)

    =&amp;gt; 四边形面积 = |b| * |a| * sin(β) = |a x b|
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经过几个公式的转换，我们得到向量叉乘后的模就是四边形的面积。在3D中也是同样适用，因为两个向量确定一个平面，所以两个向量可以确定给一个对等边四边形的平面，从而可以用叉乘可以算出他们的面积。&lt;/p&gt;

&lt;p&gt;// todo Unity3D里的Vector3叉乘API&lt;/p&gt;

&lt;h3&gt;向量之间的投影&lt;/h3&gt;

&lt;p&gt;在几何计算过程中，我们经常用到‘投影’这种方式，在向量中投影也是常用的技巧。如图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中向量b 往 向量a投影得到 c，其实c就是向量a乘以某个系数得到的。这个系数可以认为是c的模除以a的模得到的。即&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    c = a * (|c|/|a|)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们不知道|c|的值，但是c和b的夹角β又能得到计算cos的公式即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    cos(β) = |c|/|b|
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;于是&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    |c| = |b| * cos(β)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再套入到计算投影向量c的公式上去时，就变成了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    c = a * (|b| * cos(β)/|a|)

    进一步 =&amp;gt; c = a * (|b| * cos(β) * |a|/ |a| * |a|)

    由于 |b| * cos(β) * |a| 等于 a与b的点乘公式，于是就有了

    投影向量c =&amp;gt; c = a * (a · b) / |a|^2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此经历了几个公式的转换，得到了b向量向a向量投影，得到c向量的公式。&lt;/p&gt;

&lt;p&gt;// todo Unity3D里的Vector3投影API，以及其他API&lt;/p&gt;

&lt;h3&gt;矩阵的意义&lt;/h3&gt;

&lt;p&gt;矩阵看起来比较玄乎，很多人看到矩阵这个词就头疼，其实耐下心来研究，会发现矩阵是很可爱的。&lt;/p&gt;

&lt;p&gt;矩阵五花八门，这些五花八门的矩阵使用频率非常低，我们常用矩阵其实没几种。&lt;/p&gt;

&lt;p&gt;在图形学计算中，我们常用的矩阵大小是2x2，3x3，4x4 矩阵，这种行与列的数量相同的矩阵，我们称为‘方阵’矩阵。&lt;/p&gt;

&lt;p&gt;在众多方阵矩阵中，常用到也是一些比较特殊的矩阵。如对角矩阵，即只有行列号相同的位置有数字，其他位置都是0的方阵矩阵。&lt;/p&gt;

&lt;p&gt;以及单位矩阵，即行列号相同的对角线上的数字都为1，其他位置都为0的方阵矩阵。&lt;/p&gt;

&lt;p&gt;这两种特殊的矩阵因它们简单易懂在图形学计算过程中也是非常常用的矩阵。&lt;/p&gt;

&lt;p&gt;矩阵间的计算我们可以罗列一下其实并不多。&lt;/p&gt;

&lt;p&gt;转置矩阵，就是把矩阵沿着对角线翻转一下，由于我们常用的是‘方阵’矩阵，所以转置矩阵后方阵矩阵还是同样的大小，只不过对角线两侧的数字对调了一下。&lt;/p&gt;

&lt;p&gt;矩阵乘法，如果是数字和矩阵相乘则，直接带入矩阵中的所有变量即可，这种标量的乘法其实就是扩大矩阵中所有的数值。&lt;/p&gt;

&lt;p&gt;如果矩阵与矩阵相乘则，A矩阵 x B矩阵，则需要一些附加条件，即矩阵A的列数必须与矩阵B的行数相等，否则无法相乘或者说相乘无意义。&lt;/p&gt;

&lt;p&gt;矩阵相乘后得到的矩阵，里面每个位置Cij(即C矩阵的第i行第j列)都是A矩阵的第i行向量与B矩阵的第j列向量点乘的计算结果，如下我们拿2x2方阵相乘做示意：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    A x B = [a11, a12]  x  [b11, b12]
            [a21, a22]     [b21, b22]

    = [a11*b11 + a12*b21, a11*b12 + a12*b22]
      [a21*b11 + a22*b21, a21*b12 + a22*b22]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上图对矩阵乘法公式做出了很简单易懂的描述，即Cij = Ai1 * B1j + Ai2 * B2j + Ai3 * B3j ... 即A的i行向量与B的j列向量点乘的值。&lt;/p&gt;

&lt;p&gt;逆矩阵，逆矩阵由运算矩阵相乘而来，由于矩阵与矩阵相乘也会得到标准的单位矩阵，即对角线都是1其余都是0的方阵矩阵，于是就有了一个矩阵与某个矩阵相乘等于单位矩阵时，这‘某个’矩阵就是该矩阵的‘逆矩阵’。&lt;/p&gt;

&lt;p&gt;然而不是每个矩阵都有逆矩阵的，一个明显的例子是若矩阵的某一行或列上的元素都是0，用任何矩阵乘以该矩阵，结果都是一个零矩阵。因此我们通常称一个有逆矩阵的矩阵为这个矩阵可逆，相反如果这个矩阵没有逆矩阵，那么就称这个矩阵不可逆。&lt;/p&gt;

&lt;p&gt;最后我们了解一下齐次矩阵，齐次矩阵也并没有什么神秘的，只不过是从我们认知的角度上划分了矩阵分量和w分量。&lt;/p&gt;

&lt;p&gt;齐次坐标就是将一个原本是n维的向量用一个n+1维向量来表示，齐次矩阵也是同样的道理，n维表达不了的事情用n+1维来表达，我们由浅入深来理解齐次矩阵会更加容易。&lt;/p&gt;

&lt;p&gt;在二维空间中，(x,y)只能代表平面上的一个点，或平面上的向量，无法表达不同平面的点和向量，当如果需要表达不同平面的点就需要扩容维度，齐次向量就起到了这个作用。&lt;/p&gt;

&lt;p&gt;齐次向量中有3个分量，即(x, y, w)，x，y分量和第三个神秘的w。&lt;/p&gt;

&lt;p&gt;为了能更加容易的理解w分量存在的意义，我们可以把w分量想象是不同平面的代表，即当w = 1的平面是标准平面，即(x, y, 1)为标准平面中的x,y坐标点，这个点在w = 1的这个平面中。&lt;/p&gt;

&lt;p&gt;当w不是1时，就是不同平面的上的点，如果想要将坐标投影到w = 1的平面上去，就需要除以w分量，即齐次坐标(x, y, w)映射在二维平面中标准坐标系中时为(x/w, y/w)。&lt;/p&gt;

&lt;p&gt;同样的道理，在三维空间中(x, y, z)只能代表标准坐标系中的点和向量，无法表达非标准坐标系，齐次向量补充了它的缺陷，齐次向量坐标为(x, y, z, w)，当w = 1时，我们可以认为xyz坐标是在标准三维空间中，当w != 1时，则认为xyz是在其他空间当中的点，如果想要将它们坐标映射到标准三维空间中去，则只要除以w，即(x/w, y/w, z/w)，就是实际在标准空间上的点。那么当 w = 0时怎么办，我们则认为它是‘无限远的点’，它描述的是一个方向而不是一个坐标位置。&lt;/p&gt;

&lt;p&gt;向量在空间中的运用还不够广泛，矩阵可以表达空间中的缩放、旋转、切变，但无法表达偏移，因此我们需要增加一个维度的矩阵叫做齐次矩阵来表达当下维度的偏移，即齐次矩阵。&lt;/p&gt;

&lt;h3&gt;由矩阵带来的旋转，缩放，投影，镜像，和仿射。&lt;/h3&gt;

&lt;p&gt;很多人都难以理解，矩阵为什么能做到旋转和缩放，或者怎么理解矩阵的旋转和缩放，这节我们就来用最通俗易懂的方式讲讲如何理解矩阵的旋转和缩放。&lt;/p&gt;

&lt;h6&gt;我们先来了解下，向量与矩阵的乘法。&lt;/h6&gt;

&lt;p&gt;首先我们要明白，我们用的都是方阵矩阵，即2x2，3x3，4x4的矩阵。由于矩阵与矩阵相乘必须是前置的列与后置的行数要相等才有意义，向量与矩阵相乘也是一样，如果向量不是前置的那个即左乘矩阵，或者向量是以竖列表达方式右乘矩阵，对于向量与矩阵的乘法来说都是无意义的，即如下图所示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中，第一个例子，当向量左乘矩阵，是无定义的结果，第二个例子，向量以竖列的表达方式右乘矩阵，也是无定义的结果，只有第三个例子和第四个例子，向量横向表达右乘矩阵，或竖向表达左乘矩阵，才有意义。&lt;/p&gt;

&lt;p&gt;最终我们得出了向量与矩阵的乘法公式结果为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    (x*m11 + y*m21 + z*m31, x*m12 + y*m22 + z*m32, x*m13 + y*m23 + z*m33)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至于向量的行向量的表达方式，和列向量的表达方式，其实都是可以行得通的，那么我们为什么要选择行向量呢，因为行向量表达更方便，无论是书写还是计算，行向量更加适合我们人类的习惯，因此我们选择了行向量来表达向量。&lt;/p&gt;

&lt;h6&gt;如何理解旋转矩阵&lt;/h6&gt;

&lt;p&gt;我们从 2x2 矩阵讲起，因为比起3x3矩阵2x2矩阵更加容易理解，而它们的原理一样。假设一个 2x2 的矩阵即&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [2, 1]
    [-1,2]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以认为它是由两个行向量a,b构成，a为(2,1)，b为(-1,2)，即&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [2, 1]  等  [a]
    [-1,2]  于  [b]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在平面坐标系中，a和b的表达如图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中a，b向量表达在2D坐标系中，是两个互相垂直的线段向量。&lt;/p&gt;

&lt;p&gt;我们把这两个a,b向量可以看做是，从两个标准向量(1,0)和(0,1)旋转并且放大过来的向量，即如图下所示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中，(1,0)和(0,1)向量，缓缓的旋转，并且放大，逐步变成了(2,1)和(-1,2)，即从原来的(1,0)和(0,1)向量上，旋转了β度并放大了2.236倍。&lt;/p&gt;

&lt;p&gt;这就是矩阵的几何解释，其实从形象简单，对于标准矩阵来说，旋转多少缩放多少，最终形成了另一个矩阵，这个结果矩阵就是我们需要的‘变换矩阵’。&lt;/p&gt;

&lt;p&gt;对于任何一个向量来说，乘以‘变换矩阵’就能得到‘变换矩阵’所要表达的旋转和缩放值，即&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [2, 1]
    [-1,2]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果这个矩阵表达了，向量旋转β度和2.236倍的缩放，那么任何二维向量乘以这个矩阵，就会得到在标准坐标系中以标准轴为基准旋转β度，并且以标准轴为基准放大2.236倍。&lt;/p&gt;

&lt;p&gt;这样一个看起来无关紧要的矩阵还是不够直观，我们来看看更直观的表达方式，如果一个矩阵要表达旋转β度，那么它的a,b的向量该是如下图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;a就是 [cosβ, sinβ]，b就是 [-sinβ, cosβ]，它们分辨表达了标准向量(1,0)和(0,1)旋转β度后的向量。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [cosβ,  sinβ]
    [-sinβ, cosβ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此任何向量乘以这个这个旋转矩阵都会在标准坐标系中以标准轴为基准旋转β度。&lt;/p&gt;

&lt;h6&gt;理解了二维空间的矩阵旋转原理，我们延伸到三维空间就容易多了。&lt;/h6&gt;

&lt;p&gt;三维空间的矩阵也可以像二维空间一样理解，用三个向量来表示空间中的矩阵，即&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [a]   [Ax, Ay, Az]
    [b] = [Bx, By, Bz]
    [c]   [Cx, Cy, Cz]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个绕x轴旋转β度的旋转矩阵为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [1, 0,     0]
    [0, cosβ,  sinβ]
    [0, -sinβ, cosβ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么一个绕y轴旋转β度的旋转矩阵为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [cosβ, 0, -sinβ]
    [0, 1, 0]
    [sinβ, 0, cosβ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;于是一个绕z轴旋转β度的旋转矩阵为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [cosβ, sinβ, 0]
    [-sinβ, cosβ, 0]
    [0, 0, 1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用β度所形成的向量来表达坐标空间中的旋转矩阵，这样的表达可以帮助我们更加清晰的理解旋转矩阵的几何表达意义。&lt;/p&gt;

&lt;p&gt;上述只是对某一个轴进行旋转β度，如果我们要对某个向量做各个方向轴上的旋转，比如在x轴上旋转20度，再在y轴上旋转30度，最后在z轴上旋转15度，相当于这个向量在坐标系中旋转了20°,30°,15°，这时我们该怎么办？&lt;/p&gt;

&lt;p&gt;有了上述对各轴的旋转矩阵，我们就能很容易计算出各方向上的矩阵，就如上面提的问题，在各轴上都有旋转角度，我们就可以用先旋转x轴，再旋转y轴，最后旋转z轴的方式，来计算最后的结果，如图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中，c向量乘以x轴旋转矩阵，再乘以y轴旋转矩阵，最后乘以z轴旋转矩阵，即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;c * Mx * My * Mz = c`(旋转后的结果)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中Mx为以x轴为基准旋转20度的旋转矩阵，My为以y轴为基准旋转30度的旋转矩阵，Mz为以z轴为基准旋转15度的旋转矩阵。c乘以Mx得到旋转x轴后的向量，再乘以My得到旋转y轴后的向量，最后乘以Mz得到旋转z轴后的向量，最终得到结果。&lt;/p&gt;

&lt;h6&gt;绕任意轴旋转&lt;/h6&gt;

&lt;p&gt;绕标准轴即x轴，y轴，z轴旋转，得到的矩阵还远远不够我们需要的计算，很多时候我们需要计算绕任意向量或者说绕任意轴的计算公式。&lt;/p&gt;

&lt;p&gt;让我们导出绕轴 N 旋转角度 β 的矩阵，即这个公式为 F(N, β)，也就是说这个公式满足:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    v * F(N, β) = v&amp;#39; (v向量绕 N 轴，旋转β度后的结果v‘)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;怎么解这个公式呢，其中v已知，N已知，β已知，还需要知道哪些变量，如图所示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中，v 到 N 的投影分量可以计算得到 v1，进而可以计算得到 v 到 v1 的垂直向量 v2，最后用垂直向量 v2 与角度 β 可以计算得到 v’ 与 v 到 N 的投影分量的垂直向量 v‘’，最后由 v‘’ 和 v1 计算得到 v‘。&lt;/p&gt;

&lt;p&gt;其中用到的计算方式有，向量投影计算公式，向量旋转计算公式，垂直向量计算公式，最后结果为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个看起来很复杂的，只要一步步推导就能得到的结果矩阵。&lt;/p&gt;

&lt;p&gt;其实结果并不重要，我们也记不住，但推导的过程是比较重要的，因为推导的过程运用到了很多其他方面的知识，加深了理解，虽然’用进废退‘的我们也很容易忘记这些公式，但只要心里知道有这个公式的存在，只要模糊记忆依然存在，在需要用到时搜索一下很快就能进入状态了。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;p&gt;《3D数学基础:图形与游戏开发》&lt;/p&gt;
</description>
               <pubDate>Sun, 01 Sep 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/09/01/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A61.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/09/01/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A61.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第十章，地图与寻路(四) 地图的制作与优化</title>
               <description>&lt;h3&gt;地图的制作与优化&lt;/h3&gt;

&lt;p&gt;场景的制作占到所有项目制作中非常大的一块工作内容，这里我们不说场景制作在美术层面上的制作技巧，我们来说说技术层面的。上节把地图编辑器说了一遍，这节我们就在地图编辑器之外说说，地图场景的制作与优化。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;我们先来说说场景中的地图，准确的说应该说地形，地形是场景中比较关键的一部分，在项目中地形的制作分为几种：&lt;/p&gt;

&lt;h3&gt;一种是手动拼接的地图。&lt;/h3&gt;

&lt;p&gt;手动拼接的地形比较常见，由3D设计师制作出来的3D模型作为地面的地形放置在场景中，相当于是一个模型落在场景上一样，只是这个3D模型很可能是有碰撞体的，碰撞体即 Unity3D的 Mesh Collider 根据项目的需要而增加物理系统的组件，一般都会直接使用 Mesh Collider，除非是完全平面式的，不需要碰撞组件，而是自己开发的一套基于平面的2D地图障碍与寻路，完全脱离了传统的物理系统。&lt;/p&gt;

&lt;p&gt;也有可能会使用Unity3D内置的地形，也一样相当于一个3D模型放置在场景中，Unity3D的地形可以任意的改变起伏，但地形的渲染消耗比较大，因此我们并不建议使用Unity3D内置的地形，而是建议地图设计师和3D模型设计师用 Maya 和 3DMax 等模型软件来构建地形的起伏，这种做法能更加容易的被设计师掌控以及自由发挥，也更加节省资源，对程序来说在处理性能优化时也更加容易一些。&lt;/p&gt;

&lt;p&gt;其他3D物体，比如石头，小石块，草，树，动物等也用同种方式放置在场景中，只是放置的手法可能不同，有的可能通过嵌入到prefab的方式，而有的可能通过地图编辑器加入到地图数据文件中，再在加载的地图时，从文件数据中得到要加载的实体的资源位置，再实例化到场景中。&lt;/p&gt;

&lt;p&gt;手动拼接的好处在于地形和地图是可以完全表达美术风格的，地形设计师和场景制作人员能根据自己的喜好和想象中的画面来自由得定制场景，他们可以任意的移动、旋转、缩放，甚至更换、修整、完善等，这能让他们对场景画面的把控有很大的自由度。&lt;/p&gt;

&lt;p&gt;能自由发挥当然是好事，但也带来了诸多不可控性，由于场景内物件没有统一的标准，因此在场景制作时常常会大量使用，小块的地形，甚至带有动画的地形，特效，以及半透明效果来增强画面的效果，画面效果增强的同时导致性能急剧降低。地图上的小件就更不用说了，在给予场景制作团队自由发挥的同时，我们可以想象同时造成了性能无法承受的问题。&lt;/p&gt;

&lt;p&gt;虽然这本质是没有制定和规范场景制作的要求的问题，但无论怎么规范，毕竟不是每个团队的执行力都是完美的，大部分的执行力都是差强人意的，所以都会或多或少的在优化阶段发现很多糟糕的、令人头疼的性能开销问题。&lt;/p&gt;

&lt;h3&gt;另一种是地图地形的程序拼接方式。&lt;/h3&gt;

&lt;p&gt;用程序拼接地图的主旨意图是希望能更好的为设计人员自由设计更好的地图而选择的方式，不仅仅是美术设计人员，还包括策划设计人员，需要在设计和性能上求得平衡点，这样所有的地图都由程序而生成了一个或者几个模型的结构铺满整个地图。&lt;/p&gt;

&lt;p&gt;这种方式来制作地图最常见的要属2D的RPG游戏了，2D角色扮演类游戏中，几乎整个屏幕的地形都需要用地图编辑器来建立和拼合的，当需要这类地图出现时时，程序会将地图数据加载进来后，对每一块的地图都进行动态的拼合，这样一来，整个地图就只有一个drawcall，因为它只是同一个模型。&lt;/p&gt;

&lt;h6&gt;我们先来看看2D RPG游戏中，是如何动态拼合整个地图的&lt;/h6&gt;

&lt;p&gt;很多2D游戏都通过了Unity3D实现，其实2D也是有Mesh、顶点、UV的概念，和3D比起来只是少了1个维度而已。在2D游戏中的地图拼接的手法也都是通过生成顶点和三角来完成的。&lt;/p&gt;

&lt;p&gt;我们可以设想整个地图就是一个大的矩形，地图中每个方块是这个大矩形中的一个格子，而每个格子都由2个三角形构成，既然我们能计算出每个方块的位置，我们就能计算每个三角的顶点和位置。&lt;/p&gt;

&lt;p&gt;我们知道的是，整个地图有多大，也就是这个大矩形在什么位置、有多大，每个方块矩形有多大，也就是每个格子有多大。我们知道有多少格子，有多大的格子，就能计算出，总共有多少个顶点，每个顶点的位置在什么地方，也就能知道三角形该怎么拼接了。&lt;/p&gt;

&lt;p&gt;简单得说，地图是一个大矩形，横切竖切N刀，成了一个个大小一样的小矩形或者正方形，这种有规则、大小一样、位置可寻的网格，是可以通过程序生成的。&lt;/p&gt;

&lt;p&gt;我们利用三角形的拼接方式拼接完矩形，再把地图方块的UV接上去，因为每块地形的图都不一样，所以我们需要在离线时就把所有的地形图都拼成一张图，即以图集的方式存储地图的方块。当我们将图接到网格上时，我们需要将指定的方块图的UV数值赋值给顶点，对每个方块里的2个三角形做UV设置处理，让图集中的方块图显示在网格中。&lt;/p&gt;

&lt;p&gt;伪代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;//生成地图&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Generate_map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//遍历每块矩形的方块位置&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width_count&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height_count&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;generate_trangle_by_rectangle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texture_info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;CombineAdd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;//生成矩形方块所需要的，4个顶点，4个索引，2个三角形，2个三角形的顶点索引，以及三角形的uv位置。&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;generate_trangle_by_rectangle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texture_info&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//矩形的4个顶点&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;//顶点增加后的索引位置&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point_index1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point_index2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point_index3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point_index4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;//三角形的生成时的顶点&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;trangle1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;trangle2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;//三角形顶点的索引信息&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;trangle_index1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point_index1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point_index2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point_index3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;trangle_index2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point_index3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point_index4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point_index1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;//4个uv点位的信息&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point_uv1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uv_x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uv_y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point_uv2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uv_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uv_y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point_uv3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uv_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uv_y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point_uv4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uv_x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uv_y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;Mesh&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Mesh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;trangles&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trangle1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tangle2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;trangles_index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trangle_index1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trangle_index2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uvs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point_uv1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point_uv2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point_uv3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point_uv4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码中，对所有地图中的方块都进行遍历，在遍历中生成了每个方块所需要的顶点，顶点索引，uv点，进而生成三角形，三角形的索引。在生成完毕后，将这些生成的数据，与前面生成的数据进行合并，使得整个地图是一个一体化的网格，只产生一个drawcall。&lt;/p&gt;

&lt;p&gt;用程序拼接地图的好处是可以任意的通过地图编辑器来改变地形地貌，拼接完成的地图在渲染上的代价也相当的小，而且假如想换个地图的地形，只要更换贴图就可以了，什么样的贴图就可以产生什么样的地图。&lt;/p&gt;

&lt;p&gt;不过同时也带来了很多弊端，必须要有成形的地图编辑器支撑，前期工具的工作量比较大，稍微提高了点门槛，并且地图元素仅限于贴图中的元素，当地图元素增加到一定范围，就要扩大地图的贴图时就要重新排列地图信息。这一连套的工具链包括地图编辑器是必要的前提条件。&lt;/p&gt;

&lt;h6&gt;3D RPG角色扮演类游戏中，也时常常使用这种技巧来绘制游戏地图，曾经在日本风靡一时的《白猫计划》就是这样做的。&lt;/h6&gt;

&lt;p&gt;这种程序拼合的地图，策划设计师、关卡设计师可以在地图编辑器上，任意的绘制、拼接、同种类型的不同样式的地图（即在同一张贴图内容中的模型和地图元素），因此大大缩短了大量的场景试错时间。它能大量的生成出不同样式的地图，而不需要制作大量的不同类型的3D模型，大大缩短了项目时间进度，深受游戏制作人的喜爱。&lt;/p&gt;

&lt;p&gt;那么在3D地图中是怎么拼接方块地形的呢？看上去比2D更加复杂的事情，其实更加简单。&lt;/p&gt;

&lt;p&gt;首先，在3D地形模型制作时需要制定一下模型的规范。&lt;/p&gt;

&lt;p&gt;3D模型的长宽必须和地图切割后的方块长宽是一致的。3D地图中，不需要我们自己来拼接三角形了，因为已经有了固定的地形模型，但对每个地形模型就需要有规范。假如规定每块地形都是 1 x 1，那么在制作和拆分地形模型时就要按规定来，每个3D地形模型都必须以 1 x 1 的标准来定制，否则不可用。当然并不一定要 1 x 1，也可以是2 x 2、 3 x 3等等，只是当标准制定完毕后，地形模型的制作必须要按照标准来做，每个元素都相当于一个地图块。&lt;/p&gt;

&lt;p&gt;其次，所有地形模型的纹理贴图都必须并在一张贴图上制作。因为只有这样才能在合并模型才能合并，并且在合并后让这么多 1 x 1 的小方块只需要1个drawcall渲染调用就可以了绘制所有的地图。也只有这样，才能解决太多模型需要渲染导致的爆量drawcall问题。&lt;/p&gt;

&lt;p&gt;然后，在3D地形模型制作时也是需要相当的考量的，因为这个地图都被拆分成了N种类型的地形方块，所以在制作的初期需要对整个地形有哪些类型的需求，需要有一个设计、交流、探讨、决策、改进的过程。&lt;/p&gt;

&lt;p&gt;并且在读取地图编辑器编辑的数据后，实例化场景地图时也需要增加些许逻辑，这些逻辑是为了适应更好的模型拼合，比如当左边是某个模型时，为了能与它完美的拼接，当前这个格子上的模型必须是迎合它的那个，就像我们在制作和拆分城墙时那样，当城墙处于拐角处时，我们需要用拐角模型代替，还要判断它的左右前后有没有城墙，假设左边有城墙则应该选用带有连接左边城墙拐点的3D城墙模型，右边的、前面的、后面的、以及前后都有的，左右都有的，等等，总共9种情况都有不同的9种拐角城墙所代替，就是为了完美契合周围的环境而进行的额外的处理。&lt;/p&gt;

&lt;p&gt;最后的合并模型步骤就简单的多了，切分开来后的模型，按地图数据文件所描述的位置，放在指定的位置上，并向上面所说的选择好适配的模型，最后调用Unity3D的 Mesh.CombineMeshes 合并所有模型。&lt;/p&gt;

&lt;p&gt;在合并后可能发生衔接处的问题，用程序生成面片来补救很难做到完美的展示，我们还是建议调整3D模型在接缝处的面片与网格，只有这样才能调整出一个完美的或者说完全可掌控的地图造型。&lt;/p&gt;

&lt;h3&gt;常规场景的性能优化&lt;/h3&gt;

&lt;p&gt;上面几节阐述了地图的拼接方式，其中用程序拼接合并地图块的方式确实大大降低了 Drawcall 的数量，提升了渲染的性能，但只针对可拆分的地图类型项目，对大多数游戏类型来说地图是不可拆分成小块的。因此我们还是需要更多的针对常规场景讲解优化的方法和技巧。&lt;/p&gt;

&lt;p&gt;首先我们要清楚的是，是什么造成了场景的低渲染效率。我们在这里罗列一下主要的几个问题：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1.渲染面数太多，GPU压力太大。

    2.渲染管线调用次数太多，即drawcall太多，GPU排队渲染的队伍太长

    3.贴图太多太大，导致显存的带宽负荷太重

    4.动画太多，蒙皮的计算消耗的CPU太大

    5.实时光的GPU开销太大
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实还有很多很多问题需要解决，比如实时阴影导致的 Drawcall 太多，增大了渲染调用的排队长度，以及透贴太多，Overdraw 重绘问题比较严重，还有比如单个物体需要的Pass渲染太多，一个物体需要绘制多次才能完成等等。这些问题也是很重要的，但这节我们重点解决这最重要的5个问题。&lt;/p&gt;

&lt;h3&gt;1.渲染面数太多，GPU压力太大。&lt;/h3&gt;

&lt;p&gt;渲染面数太多分两种，一种是整个场景3D物体太多导致的面数多，一种是同屏展示的面数太多。&lt;/p&gt;

&lt;h6&gt;前一种Unity3D引擎会裁切掉在摄像头之外的物体，不让他们进入到渲染管线以减少消耗，虽然裁切也会消耗小部分CPU，但毕竟比起渲染整个物体要小的多。&lt;/h6&gt;

&lt;p&gt;在进入渲染管线前每个3D物体能计算出或者已经计算好了一个包围盒，即Bounds，这个包围盒由8个顶点组成，加上旋转矩阵就能计算出每个顶点是否在摄像头的锥形体范围内。&lt;/p&gt;

&lt;p&gt;裁切的算法简单说是这样的，如果有包围盒8个点中只要有一个点在锥形体内，就认为是需要渲染的不可被裁剪，如果8个顶点都不在摄像头的锥形体范围内，才认为是不需要被渲染的，然后Unity3D引擎会阻止这个模型渲染即在渲染调用前裁切掉。&lt;/p&gt;

&lt;p&gt;这种Unity3D引擎上的裁剪，帮助我们屏蔽掉了很多不需要渲染的物体，虽然裁剪也会花去些许CPU，但比起要绘制一个3D物体来说要少的多的多。&lt;/p&gt;

&lt;p&gt;这种裁剪的好处是，使得我们只要关心摄像头范围内的面片就可以了，但是如果是一个模型很大，或者常常我们项目中有合并的模型范围从南延伸到北贯穿整个场景，一旦这个模型很大，覆盖了整个场景，包围盒总有一段在摄像头内就不会被裁剪，这样就会浪费很多不必要的GPU计算。&lt;/p&gt;

&lt;p&gt;除了Unity3D引擎内的裁剪，OpenGL即渲染管线也会对每个三角形进行裁剪，不过三角形的裁剪要比8个顶点的包围盒裁剪要费的多。所以我们尽量还是能用包围盒裁剪就用包围盒裁剪方式，将更少的三角形面片带入渲染管线。&lt;/p&gt;

&lt;p&gt;传入渲染管线的所有三角形顶点管线对它们做的第一个动作就是裁剪，其次才是计算，网格根据摄像头锥形体进行裁剪，所有不在锥形体范围内的顶点都会被裁掉。但是这种裁切的效率比起8个顶点的包围盒效率要低得多。&lt;/p&gt;

&lt;p&gt;场景面数太多时，如果没有或者很少有这种从南到北的模型时，渲染的压力就取决于摄像头中可展示的物体的数量，但是如果单个模型通常会覆盖很多天南地北的网格，那么GPU对裁切计算的压力就会增大。&lt;/p&gt;

&lt;h6&gt;后一种同屏面数太多的情况，就是因为3D模型都在摄像头范围内，要么就是模型太多，要么就是模型面数太多，要么就是摄像头太远而显示距离太大造成的。&lt;/h6&gt;

&lt;p&gt;最简单直接的方法就是，拉近摄像头，或者拉近摄像头显示距离，让更少的模型进入视野内。当视野范围内的物体少了，需要渲染的模型面数也就少了，自然CPU和GPU的消耗也就少了。虽然这是最拙劣的办法，也是我们需要调整和调节的参数，让视线范围在一个合理的范围内。&lt;/p&gt;

&lt;p&gt;其次是减少模型面数，或者减少模型在场景中的数量，降低不必要的高品质。3D模型面数的降低，不是一两天就能完成的事，一个模型面数的降低也伴随着画面质量的降低，又要面数低又要品质高那是痴人做梦，所以我们找到一个平衡，也要制定一个容忍度，即前面几章提到的，要将模型面数在研发期间控制在一定范围内。模型数量在场景中的数量的降低，或者更直接的方式，去除了许许多多本来需要渲染的三角面，自然就省去了诸多CPU和GPU消耗，但也伴随着场景变得空旷不饱满不生动。&lt;/p&gt;

&lt;h6&gt;那么有没一种方法可以不更重制3D模型面数，不减少模型在场景里的数量，不缩短摄像头显示距离，也能优化性能的。有。&lt;/h6&gt;

&lt;p&gt;世上没有免费的午餐，想降低GPU的消耗，就得用增大内存来换。&lt;/p&gt;

&lt;p&gt;LOD，即Level of detail，就是此道。用内存换GPU。&lt;/p&gt;

&lt;p&gt;我们把每个3D模型，做成多个不同细节级别的模型，当摄像头拉远时，启用形状相似面数更少细节的模型，当摄像头拉近时，则启用形状相似面数更多细节的模型。&lt;/p&gt;

&lt;p&gt;这样即使众多的模型在摄像头范围内需要渲染，也只有几个模型在靠近摄像头的，而大部分都是远离摄像头的。&lt;/p&gt;

&lt;p&gt;远离摄像头的3D模型面数很少，即使数量众多，它们所展示的低等级的面数的总和也是可以接受的。&lt;/p&gt;

&lt;p&gt;我们常提到的 Mipmap 也是这种方式在运作，对于距离远的物体，启用更小的纹理贴图，而与摄像头距离近的物体则使用更大的纹理贴图。这样在渲染时就传送进渲染管线的贴图就更小了，宽带压力小了，GPU消耗自然少了。&lt;/p&gt;

&lt;p&gt;天下没有免费的午餐，提升了CPU和GPU的性能，就会增大内存的消耗，如果内存消耗太多也是得不偿失的，因此在考虑怎么分级、分多少级的细节级别上也需要一番考量，针对不同的项目分级的层数也是不同，拿大型MMORPG来说，那种可以在天上飞的游戏，看到的物体自然就很多，如果LOD分级少了画面则会显得突兀，而中小项目如果LOD分级太多，则加大了内存量和制作时间，得不偿失。&lt;/p&gt;

&lt;h3&gt;2.渲染管线太多，即 Drawcall 太多，渲染管线太多&lt;/h3&gt;

&lt;p&gt;除了面数带来的GPU计算压力，渲染管线太多也是造成GPU压力的一大问题。&lt;/p&gt;

&lt;p&gt;渲染管线太多的问题，大都是因为场景中的模型物体太多，或者使用的Shader中的管线太多，或者这两者同时造成的。&lt;/p&gt;

&lt;p&gt;其实这个问题是最好解决的，‘干掉’在场景中众多的模型物体，以及‘注释掉’Shader中不必要的管线。&lt;/p&gt;

&lt;p&gt;当然这是最粗暴的做法，无疑将美术设计师，场景设计师的辛勤工作的成果给抛弃了。但也不是不可为，适当的‘干掉’一部分不必要模型的其实是有助于场景制作的。&lt;/p&gt;

&lt;p&gt;那么我们能不能在不毁坏场景的前提下做些优化呢。可以的。&lt;/p&gt;

&lt;p&gt;关键点就在于‘合并’二字。&lt;/p&gt;

&lt;p&gt;为什么呢？因为一个屏幕内需要渲染的面片数量是一定的，即我们不减模型在场景中的数量，不减单个模型面数的情况下，一个画面上需要渲染的三角形面数是固定的数量。&lt;/p&gt;

&lt;p&gt;我们每次调用管线渲染（即drawcall）传给渲染管线的三角形数量却比较少，所以调用的次数比较多。&lt;/p&gt;

&lt;p&gt;我们能否合并这些面片数据，然后一次性得传递给管线，将原来需要很多次的管线调用变成一次，只有这样才能大大降低 Drawcall 的数量，降低渲染调用次数。&lt;/p&gt;

&lt;p&gt;那么减少渲染管线即减少 Drawcall 的数量究竟有什么好处？&lt;/p&gt;

&lt;p&gt;减少了渲染管线的数量，即降低了Drawcall的数量后，尽管并没有减少任何需要渲染的面片数量，只是每次传递给渲染管线的顶点和面片数增多了，传递的次数减少了，但是三角形数据进入渲染管线后，就可以开启GPU并行处理了，单行线变成了8车道甚至16车道单行线，速度加快8-16倍。&lt;/p&gt;

&lt;p&gt;原本调用一次渲染，就要在队列中等待管线渲染完毕后才进行下一次渲染，合并后就不同了。不再是像以前那样调用这么多次Drawcall，每次渲染一个画面时Drawcall的队伍都要排的老长老长的，都等在那排着队等待一个个的交给GPU处理，效率低下。&lt;/p&gt;

&lt;p&gt;合并后就不再是这样了，排队的数量少了，队伍短了，虽然每个排队的‘人’都很‘胖’（即数据量很多），但是一旦进入处理阶段，8-16条生产线并行处理这些数据，比前面排着老长得队伍一个个处理要来的高效的多。&lt;/p&gt;

&lt;p&gt;所以我们要想方设法的合并各种模型。怎么合并？&lt;/p&gt;

&lt;p&gt;其实Unity3D引擎自带有多种合批方式，前面几个章节有详细的介绍，这里我们简单提一下，Unity3D引擎中有动态合批、静态合批、GPU Instancing 三种合批方式，其中动态合批，合并的普通的模型，但要求比较高，包括模型面熟、Shader的Pass数等，静态合批也有自己的规则，它通过消耗的内存来换取CPU，而GPU Instancing 的原理是通过一次性传递更多的数据来达到合批Drawcall的目的。&lt;/p&gt;

&lt;p&gt;这里我们并不想通过Unity3D自动的方式来做‘合并’的操作，我们希望能够自己掌控‘合并’效率和效果。部分原因也是因为引擎自带的合批方式通常都是通用的合批方式，规则比较严格，合批率比较低。所以时常放弃它们而选择自己动手丰衣足食。&lt;/p&gt;

&lt;p&gt;‘合并’也分实时合并，与，非实时合并两种方法：&lt;/p&gt;

&lt;p&gt;其中实时合并也会消耗大量的CPU，因为它要读取多个模型，并创建新模型数据，不断的创建新模型数据，就会导致CPU的消耗。这里不再详细介绍，前面章节已经介绍过，这里简单点说一下，把相同材质球，相同贴图的模型，读取它们的模型数据，生成一个新的合并后的模型，然后隐藏原有的模型。如果很多模型材质球效果一样，但贴图不一样，我们可以在线下手动合并它们的贴图后再放到线上合并。&lt;/p&gt;

&lt;p&gt;非实时合并则全是线下的手动合并，即大家常说的静态合并。Unity3D静态批处理的规则比较严格，即要求相同材质球相同贴图还要形同模型，而且内存消耗比较大，因此我们还是建议使用自己手动合并的方式，即手动拼接场景中静态不动的、有相同材质球、相同贴图的模型，手动拼接成一个模型，也可以用插件来操作，比如 MeshBaker，通过 MeshBaker 来制作和合并模型与纹理贴图。&lt;/p&gt;

&lt;p&gt;静态合并Mesh的好处就是，游戏中不需要实时消耗CPU去合并模型，节省了不少CPU，也降低了很多Drawcall的数量。&lt;/p&gt;

&lt;p&gt;当然过犹不及么，如果把所有的在场景内的物体全部合成为一个模型，整个地图，无论摄像头能不能看到的地方都合并了，那么GPU的压力也同样很大，因为这样的话我们前面提到的引擎自身做的第一层包围盒裁剪就不生效了。渲染时会一股脑的将整个模型数据塞进渲染管线中，GPU在裁剪时的压力就会很大，因为它要裁剪整个地图的所有模型面片，计算量也是巨大的。&lt;/p&gt;

&lt;p&gt;因此我们在静态合并时也要适度，即合并周围距离不太远的、可以合并的模型。这样即减少 Drawcall 次数，也同时降低了GPU裁剪的压力。&lt;/p&gt;

&lt;h3&gt;3.贴图太多太大，显存的带宽负荷太重&lt;/h3&gt;

&lt;p&gt;贴图太多，宽带压力太大，导致的问题，主要是因为GPU在渲染时，需要将内存的纹理拷贝到显存中去才能使用在GPU中。所以拷贝的消耗和显存的消耗也是很大的。不过，显存只存在于主机和PC游戏中，在手机中没有显存的概念，只有内存，因此都是内存和内存的拷贝。&lt;/p&gt;

&lt;p&gt;在手机中只有内存与内存的拷贝，那么岂不是内存中的贴图纹理有两份？是的，如果引擎没有做额外处理的话，按照常理GPU的工作流程确实会是拷贝一份纹理到另外一段内存中，导致一份纹理占用了两份内存。但是毕竟引擎还是做了很多优化的，Unity3D就做了这方面的优化，当贴图没有勾选Read/Write 时Unity3D就认为该贴图是不会被改变的，当GPU需要该贴图时只是把原来在内存中的值传进去，而不是拷贝整个纹理，而当我们 勾选了 Read/Write 后Unity3D就认为该贴图是会被改变的，因此当GPU需要该贴图去渲染的时候，则会重新拷贝一份纹理贴图，这份纹理贴图专门给GPU渲染使用，避免GPU的纹理贴图随时被更改。&lt;/p&gt;

&lt;p&gt;因此我们在贴图设置时，首先要注意 Read/Write 选项是否需要被开启，绝大部分贴图是不需要被开启的，这些贴图被开启后造成的2倍内存也是不必要的。&lt;/p&gt;

&lt;p&gt;贴图太大太多，最好的办法是缩小贴图和压缩贴图。&lt;/p&gt;

&lt;p&gt;看起来挺简单的，其实我们在实际项目中，我们不可能随意的去缩小和压缩贴图，这样很容易导致项目因贴图质量太糟糕而影响画面效果。&lt;/p&gt;

&lt;p&gt;我们需要针对每个部分的贴图逐一去了解和设置，其实每个功能部分的贴图都有其用途。比如UI中的贴图分，图集和Icon图片，图集一般都是无损质量，因为要保障画面，也不需要 Mipmap采样，Icon图也是一样。虽然也不是不能压缩，不过压缩后确实UI的质量会遭到比较显著的降低，针对低端机时确实可以这样去做，因为无损的贴图在内存上和压缩的贴图通常有5-10倍的差距。&lt;/p&gt;

&lt;p&gt;又比如3D模型的贴图，这些模型纹理贴图，通常都是2的幂次存在，因为2的幂次的纹理在GPU中处理起来比较顺手，而他们也通常是可以压缩的，并且带有 Mipmap 采样生成标记的。要压缩多少，压缩到什么比例才适合，每个项目都不一样，因人而异，大部分时候我们都是指压缩到中位数即Normal Compress普通压缩。&lt;/p&gt;

&lt;p&gt;贴图的大小确实比较重要，每个项目在开始时都要好好的规范一下，因为只有遵守良好的规范，项目才能将内存限制在可控范围内。&lt;/p&gt;

&lt;p&gt;幸运的是，美术设计师无论将贴图做的多大，我们都可以在Unity3D里重新设置成我们需要的大小，Unity3D会将所有贴图都重新制作导出成用户指定大小的贴图和格式。因此即使前期贴图太大而导致的问题，也可以在Unity3D的项目中将贴图设置回我们想要的大小。&lt;/p&gt;

&lt;h3&gt;4.动画太多，蒙皮的计算量太大&lt;/h3&gt;

&lt;p&gt;动画确实是最令人头疼的，因为它是动态的，而且时时刻刻都是动态的，不像3D物件，虽然它们会出现消失，但大部分情况下还是静止不同的。而动画则不同，它们时时刻刻都在你眼前动来动去，即使不再屏幕上，大部分时候也需要一直保持动的状态。&lt;/p&gt;

&lt;p&gt;对于动画的优化，其实上几个章节中有讲的比较详细，这里只是简单的点一下。&lt;/p&gt;

&lt;p&gt;动画的消耗点最大的地方是CPU的蒙皮计算，如果有100个动画在屏幕中播放，由于每帧对蒙皮的计算都是全局性的，因此CPU会极大的消耗在蒙皮计算上。&lt;/p&gt;

&lt;p&gt;蒙皮计算，其实质就是骨骼与顶点的计算，骨骼动画用骨骼点去影响顶点，每帧都需要计算骨骼点与顶点的偏移、缩放与旋转。&lt;/p&gt;

&lt;p&gt;如果动画模型的顶点数量很多，骨骼数量很多，顶点关联着骨骼点，骨骼点影响着顶点，那么计算量就会很大，消耗的CPU自然就会很多。&lt;/p&gt;

&lt;p&gt;为了能节省计算量，我们可以减少顶点数，又或者减少骨骼点的数量，抑或两者都进行削减，就能使得CPU降低消耗。&lt;/p&gt;

&lt;p&gt;让3D模型设计师和动画师去减面和减动画骨骼，工作量毕竟是比较大的，涉及到所有3D模型和动画。在削减的时候还需要顾及画面，不能太糟糕，所以时间会比较长。这是我们程序无法控制的，我们能做的就是从程序上尽量的降低开销。&lt;/p&gt;

&lt;p&gt;由于每帧都要计算，所以很费CPU，如果能把计算好的每帧顶点偏移量存起来，播放的时候直接偏移过去就好了，于是就有了 Animation Instancing。它就是把所有动画文件中的数据都导出放入贴图中，由可编程的顶点着色器来完成顶点的偏移。这样我们就不需要计算了，在设置顶点的位置就可以了，省去了大量的CPU计算消耗。&lt;/p&gt;

&lt;p&gt;但是毕竟一个会动的模型，是无法合并Mesh，理论上说应该说每帧都合并一次对CPU消耗的代价太大，所以每个动画模型都需要至少一个Drawcall来支撑，如果Shader中有多个Pass管线，就有更多，比如描边，实时阴影等。&lt;/p&gt;

&lt;p&gt;假设有100个这样的动画，就需要至少100个Drawcall来支撑。消耗还是太大，能不能合并Drawcall，就像合并Mesh一样，相同的材质球合并成为一个Drawcall呢？&lt;/p&gt;

&lt;p&gt;Unity3D的 GPU Instancing 为我们提供了合并的可能。它可以合并相同材质球，相同模型的Drawcall。它原理是将多个模型的相同顶点，相同贴图，相同材质球，在不同位置的物体一次性提交给GPU，让它只绘制一次就能将所有物体都绘制在帧缓存中，进而体现在屏幕上。&lt;/p&gt;

&lt;p&gt;这种方式的条件虽然有点苛刻，但恰好能和 Animation Instancing 配合的很好，Animation Instancing 并没有改变3D模型，贴图，材质球，能与 GPU Instancing 能很好的结合，两者使用起来能减掉很多有用相同模型和材质球的动画物体，还能将计算蒙皮的CPU消耗省去，可以说是绝佳的搭档。&lt;/p&gt;

&lt;p&gt;与之相似的还有，另外一些场景中的草和树的摇动，我们可以用顶点动画和 GPU Instancing 结合来省去Drawcall和蒙皮计算的CPU消耗。&lt;/p&gt;

&lt;p&gt;其实和 Animation Instancing 一样的原来，只是草和树是纯顶点算法计算出来的摇动，而3D模型动画的 Animation Instancing 则是在离线下将动画数据导进纹理贴图中在顶点着色器中偏移顶点罢了。&lt;/p&gt;

&lt;p&gt;前者用了算法计算出顶点，而后者用纹理贴图当做数据载体直接偏移顶点。前者消耗了GPU来代替CPU计算，后者消耗了内存和少量GPU代替CPU，前者更加灵活但也受到算法的局限性，后者则死板一些但性能开销更少。各有利弊，在实际项目中也需要根据实际情况做选择和混用，我们在使用时应该衡量他们在项目中的限制和作用，尽量做最适合的选择。&lt;/p&gt;

&lt;h6&gt;5.实时光的GPU开销太大&lt;/h6&gt;

&lt;p&gt;烘培是解决实时灯光太多，GPU开销太大时比较好的解决手段。对于场景制作与优化，烘培是永远绕不过去的技巧，它能帮助我们省去很多灯光的实时开销，以及实时阴影的巨大开销。&lt;/p&gt;

&lt;p&gt;下一节我们就来专门来讲讲，烘培及其优化。&lt;/p&gt;
</description>
               <pubDate>Sat, 17 Aug 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/08/17/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E5%9C%B0%E5%9B%BE%E4%B8%8E%E5%AF%BB%E8%B7%AF4.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/08/17/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E5%9C%B0%E5%9B%BE%E4%B8%8E%E5%AF%BB%E8%B7%AF4.html</guid>
            </item>
        
            <item>
               <title>思路探讨(二十七) 如何应对30岁的躁动</title>
               <description>&lt;p&gt;&lt;img src=&quot;/assets/%E9%87%91%E8%9E%8D/idea-talk-27.jpeg&quot; alt=&quot;idea-talk 27&quot;&gt;&lt;/p&gt;

&lt;p&gt;最近对自己影响比较深的一段话。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;台风日没带电脑，只能在手机上打字。&lt;/p&gt;

&lt;p&gt;一整天只在小小房子里原地看看书，原地跑步。&lt;/p&gt;

&lt;p&gt;我依然坚持着自己独有一套理论，即，&lt;/p&gt;

&lt;p&gt;首先要想方设法每天都保持充沛的体力和旺盛的精力，即保持健身、正常的饮食、规律的作息。&lt;/p&gt;

&lt;p&gt;然后，每天必须看几页书以丰富自己的知识、看法、见解和视野，&lt;/p&gt;

&lt;p&gt;其他时间专注于工作，在工作中历练，在工作中积累经验和财富。&lt;/p&gt;

&lt;p&gt;无论处在什么样的状态下，开始努力都为时不晚。&lt;/p&gt;

&lt;p&gt;人只要一直努力下去，肯定比他不努力的强百倍。&lt;/p&gt;

&lt;h6&gt;“努力”应该被称为一种特质，是自驱力的体现，如果你拥有这种特质，总有一天你会发现，所有你所拥有的都因“努力”而得，不管你最终有没有成功，“努力”这两个字将成了你的优势。&lt;/h6&gt;

&lt;p&gt;最近难得平静下来能安安静静的度过一天。也可以梳理下最近的生活和工作。&lt;/p&gt;

&lt;p&gt;30几岁依然是躁动的年纪，只是相比于20几岁，更加让我们躁动的是事业和家庭，比起40几岁，30几岁的我们还不够沉稳，心力还不够强大，经受的狂风暴雨还不够多，这种局面是无法改变，只有我们熬过30岁来到了40岁时，回头看才会知道这一切就是个“轮回”，只是40几岁又有了新的烦恼和痛苦。60后下去了70后起来了，70后下去了80后起来了，80后下去了90后起来了，世界从没因任何人停止过潮汐潮落。我们所感受到的只是我们以自我为中心的视角所看到的和感受到的情景罢了，其实并非我们所想象的那样美好或者那样糟糕，世界就这样悄无声息又平静的路过你，我，他身边，继续向前。&lt;/p&gt;

&lt;h6&gt;如果说世界上有什么办法能够掌控未来，也只有“努力”，并且是持续的长时间的努力，也只有这样才能在下一个阶段来临前打好结实的基础。&lt;/h6&gt;

&lt;p&gt;当下一个阶段来临时，才有足够强的实力，足够多的经验，足够大的视野，足够强壮的身体应对更加复杂的局面。&lt;/p&gt;

&lt;p&gt;也只有我们在当前阶段持续不断的努力，才能在下一个阶段来临时拥有足够多的优势，到那时才能更加从容一点。&lt;/p&gt;

&lt;p&gt;但也同样的，我们会不断面临再下一个阶段的挑战，努力永远都不可能停下来，我们一生都是艰苦而又美好的。&lt;/p&gt;

&lt;h3&gt;我们在“努力”中寻找苦涩的快乐，在“汗水”中绽放疲惫的笑容。&lt;/h3&gt;

&lt;h3&gt;我们一起：苦中作乐&lt;/h3&gt;
</description>
               <pubDate>Sat, 10 Aug 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/08/10/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A827.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/08/10/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A827.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第十章，地图与寻路(三) 地图编辑器</title>
               <description>&lt;p&gt;对于任何游戏来说，地图与场景的是比较重要的，特别是对于中大型游戏来说，在地图和场景上花费的时间和精力占去了大部分。而对于大部分游戏类型来说，布置场景，优化场景，甚至为场景写个编辑器是必不可少的，我们通常称他们为‘地图编辑器’。&lt;/p&gt;

&lt;p&gt;地图编辑器有哪几种实现方式，该如何实现，顺便讲一讲从哪些方面下手优化场景，我们这节就来讲讲关于地图的事。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h3&gt;地图编辑器的基本功能&lt;/h3&gt;

&lt;p&gt;什么是地图编辑器？Unity3D本身的编辑器就是属于场景编辑器，但它没有达地图编辑器的功能，只是能添加场景，添加场景里的物件，移动，旋转，缩放模型物件而已，并不能帮助我们将这些物件变成自定义的具体数据然后存储下来成为文件。&lt;/p&gt;

&lt;p&gt;对于一张完整的地图来说，我们需要的是能生成一个包含地图中所有元素数据的文件，并且我们可以通过这个文件还原整个地图。&lt;/p&gt;

&lt;p&gt;这个文件不只是可以在视觉上还原地图，还要还原我们已经设定好的地图中的逻辑，包括碰撞的逻辑，触发逻辑，关卡逻辑，事件逻辑，以及游戏逻辑。&lt;/p&gt;

&lt;p&gt;说白了，为了能让地图还原成我们编辑的那个模式，并且可以继续持续的编辑，我们需要创造一个地图编辑器来完成这个功能。&lt;/p&gt;

&lt;p&gt;下面就让我们来说说地图编辑器是怎么实现的。&lt;/p&gt;

&lt;p&gt;地图的元素都是以坐标，旋转角度，缩放大小为基准形成的数据，大部分元素都是节点，模型，特效，因此大部分地图编辑器都需要有，元素的坐标，角度，缩放大小，至少有这三样的数据记录。其他的数据，也会有包括配置表ID，物件类型，范围大小，脚本名字等，是为了配合不同游戏系统的需要而构建的。&lt;/p&gt;

&lt;p&gt;即通常每个元素的数据为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    class map_unit
    {
        position, //坐标
        rotation, //旋转角度
        scale, //缩放
        type, //类型
        table_id, //配置表ID
        size, //大小
        function_name, //功能名
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中position, rotation, scale 是基础的数据类型，它记录了需要被展示在场景中的位置，角度，缩放大小。而其他的数据，例如 type 可以用来表示这个物件的类型，是人，是怪，是门，是机关，还是不会动的静态场景物件。&lt;/p&gt;

&lt;p&gt;而 talbe&lt;em&gt;id 可以用来表达这个前面这个 type 类型所对应的配置表ID，用这个 table&lt;/em&gt;id 可以映射到具体数据表里或者说Excel表里的某一行数据，因此各种type下的展示效果可以根据这个 talbe&lt;em&gt;id 的不同而不同，例如 怪物有很多种，每个talbe&lt;/em&gt;id 都代表了怪物表里的一种怪物，因此怪物的形状和怪物AI都可以用这个 table_id 映射。&lt;/p&gt;

&lt;p&gt;size 大小则可以认为是该物体所触发事件的一个范围，比如当角色进入5 * 5 这个size大小范围时将触发机关，或者触发剧情，或者触发任务，或者触发生成一堆怪物。&lt;/p&gt;

&lt;p&gt;function&lt;em&gt;name 一般都会指向某个功能性逻辑。当某个物件size范围内被触发时，功能性逻辑就执行操作，使用它的意图是通过它指向的是某个具体的功能，因为每个物件都有可能具有不同类型的操作指令，因此指令可能是纷繁复杂的。 例如，function&lt;/em&gt;name里填上make&lt;em&gt;new&lt;/em&gt;task 可以定义为，触发时制造新的任务，或者 play&lt;em&gt;animation 触发时播放某个动画，或者 generate&lt;/em&gt;master 生成一堆怪物等等诸如此类。 &lt;/p&gt;

&lt;p&gt;有了数据就需要对数据保存和读取，包括地图数据文件的保存和读取，这两个是最基本的功能。&lt;/p&gt;

&lt;h3&gt;数据协议格式在编辑器中应用的选择&lt;/h3&gt;

&lt;p&gt;关于数据的存储与解析，我们在前面的数据协议章节中专门做了详细讲解，这里我们做一些应用，该怎么选择地图数据的数据格式和存储协议。各类协议在这里也能体现其不同的优势。&lt;/p&gt;

&lt;p&gt;我们把数据都存储到文件中，存储数据就需要格式，我们选定一种协议格式来存储后，就得用相同的协议读取，假设我们用最方便的Json协议格式存储所有数据，并放入文件中，那么我们在读取数据的时候也需要从Json数据中解析出每个元素存储到内存中。&lt;/p&gt;

&lt;p&gt;假设说我们在众多协议中选择了使用Json协议，我们选择Json协议的意义是什么呢，乍一眼看来Json占用的空间又大，解析又慢，导致很多人都摒弃它，这样的情况下我们为什么还用它。肯定是因为简单，快速，易上手，只要有一点点编程知识的人都知道Json的格式，即使不知道也只需要花几分钟就能明白其原理，这对于众多新手来说是适合的门槛线，他们能快速上手快速融入团队。这种团队执行效率，对于一些技术力量参差不齐的团队（资深只有1，2个，其他都是新人）来说是好的选择，大家能很容易达成一个比较高的共识，协作起来也没有太多障碍。&lt;/p&gt;

&lt;p&gt;我们可不要小看达成共识的好处，我们必须认识到我们独自一个人是完不成任务的，这一点很多人虽然清楚明白，但实际中总是犯个人主义的毛病，忍不住靠自己，而不是靠团队，最后事情太多弄得自己手忙脚乱。产品要靠大家一起完成每个人都出尽所有的本事而非一个英雄搞定一切，团队在协作时没有共识或者共识比较差，将发生许许多多怪异的问题，最终都会导致团队执行效率下降，产品的质量降低。假设有一种解决方案能让团队所有成员都能达成共识，即使这种解决方案的效率并不高，在团队执行效率面前我们都需要重点考虑一下。&lt;/p&gt;

&lt;p&gt;有很多协议比Json空间占用小，解析快，效率高，自定义格式的数据协议就是其中一种，那么我们为什么又非要抛弃Json来使用自定义格式的数据协议呢？&lt;/p&gt;

&lt;p&gt;假设说我们使用自定义格式的协议，把每个变量都转换成byte流形式存储，这种形式的存储是最能掌控的，也是最能够节省空间的。因此用自定义协议做存储格式的人，可能非常想要掌控这个存储过程，而不想让其他第三方的插件干扰。不过，自定义协议在使用时也有很大的缺陷，当数据格式变化时，对变化协议格式的适应能力比较弱，虽然也不是没办法，但确实有点代价。&lt;/p&gt;

&lt;p&gt;代价是什么呢？代价就是要为每个版本的数据格式各自写一个完整的数据读取和存储的程序。每增加一个版本，为了维护旧的数据，都要在原有的数据解析的程序外，增加一个新的数据解析程序。就如下面的伪代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    void ReadData(io_stream)
    {
        version = io_stream.read_int();
        if( version == 1 )
        {
            Read_version1(io_stream);
        }
        else if(version == 2)
        {
            Read_version2(io_stream);
        }
    }

    voi Read_version(io_stream)
    {
        id = io_stream.read_int();
        level = io_stream.read_int();
    }

    voi Read_version(io_stream)
    {
        id = io_stream.read_int();
        name = io_stream.read_str();
        gold = io_stream.read_int();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码中读取数据时考虑了多种版本的兼容，使用了不同函数应对不同版本的办法，为每个版本写一个特有的读取顺序，在读取开头，用一个int元素来代表是应该使用哪个版本来读取数据，得到数据版本号后就能对应到不同版本的读取方法。&lt;/p&gt;

&lt;p&gt;自定义方式确实压缩了数据，提高了效率，但也同时增加了维护的复杂度，而Proto Buffer就没有这样的缺点。&lt;/p&gt;

&lt;p&gt;再假设说，我们使用Proto Buffer协议来作为存储格式，原本自定义协议的弊端被大大的削减，即使是数据格式升级和改变，都能轻松的应对，确实是一个比较好的选择，协议数据小，解析速度快，协议升级方便。&lt;/p&gt;

&lt;p&gt;但不要忘了，在看似优秀的协议下的同时我们也被被束缚在了Proto Buffer里，即不得不依赖于Proto Buffer。在未来假设的某一天，我们需要使用其他工具或语言来读取数据文件时，必须被要求使用Proto Buffer来得到数据格式的转换。其实，Proto Buffer在学习门槛上也提高了不少，对于新手来说理解Proto Buffer并使用，虽然我们自己并不觉得有多大的难度，但对于新人来说可是个大门槛，在他们的角度上看，Json是比Proto Buffer更适合。&lt;/p&gt;

&lt;p&gt;上面是我们在编写和创作地图编辑器中对数据部分的了解，接下来我们来看看地图数据对整个游戏的作用。&lt;/p&gt;

&lt;h3&gt;地图编辑器所带来的加载方式的改变&lt;/h3&gt;

&lt;p&gt;我们说地图编辑器主要的作用是将场景地图的编辑功能和地图数据再利用功能结合起来，让可视化的地图编辑器更多的帮助策划设计者或者场景美术人员编辑他们觉得更好看，更舒适，更绚丽的场景地图，并且这些编辑完的场景能随时保存成游戏中需要的数据格式。&lt;/p&gt;

&lt;p&gt;也正因为有了地图数据，我们才能在游戏中正确的还原原本编辑好的地图场景，而且在加载地图时有更明确的目标。&lt;/p&gt;

&lt;p&gt;其中数据到场景的还原是通过加载的方式进行的，这里我们不得不说一下地图的加载形式。地图加载的形式有三种，我们可以选择一次性加载全部地图（即阻塞式的加载所有地图元素），也可以选择流式的动态加载，也可以选择按需分批加载地图中的元素模型。&lt;/p&gt;

&lt;p&gt;一次性加载显然是最容易和方便的，只要把所有数据读取进来，针对每个元素的数据，加载它所指定的模型或效果到指定的位置，并设置旋转和缩放，再对挂上对应的脚本如果需要的话。&lt;/p&gt;

&lt;p&gt;一次性加载这么容易和方便，我们有时可以完全不需要地图编辑器，一个prefab搞定整个场景。这样说来话为什么还需要地图编辑器？&lt;/p&gt;

&lt;p&gt;随着功能和需要的扩大，当游戏开始时，很多物件并不需要加载到场景中，而是根据个人玩家的游戏进度来判断是否需要加载。这时如果还是按一个prefab搞定一个场景，一下子把所有物件都加载进来，内存势必浪费很多，这是我们不希望看到的。在一次性加载地图的方式中，地图编辑器就能帮助我们根据需要加载物件，帮助我们节省不必要的开销。&lt;/p&gt;

&lt;p&gt;然后，游戏越做越大，场景不断扩大，场景中物体的种类和数量越来越多，一次性加载需要消耗的CPU和时间也越来越大。原本只要加载几个面片当做地形的prefab，发展成了带有众多山，路，草，石头，路，桥，人，房子等的一整个大场景。这时，即使是按需加载也可能会在加载整个场景的阻塞中卡住很长时间，体验越来越差。流式加载就在这时体现了更加好的体验。&lt;/p&gt;

&lt;p&gt;根据地图编辑器的数据，进行流式的动态加载，让人能有逐步出现的视觉体验，而不是画面卡住的糟糕体验。这里不深入扩展开去说明如何使用Unity3D的API做流式加载，而是将这些内容放“资源加载的多种方式”的章节中进行讲解。&lt;/p&gt;

&lt;p&gt;流式加载缓解了瞬间的CPU消耗，把CPU消耗按时间平摊开来了，所以画面看起来不那么硬板。但是还不够，RPG的大世界中少有切换场景的时候，大都是整个地图无缝连接，这样才能体会到真实世界无缝的行走和旅行的体验。随着地图的继续扩大，整个世界都被容纳进了地图，我们不可能把整个世界都加载进内存里，因此分块分批加载成了最迫切的需求。&lt;/p&gt;

&lt;p&gt;分批和分块的方法其实很多，比如可以用距离来判断加载和卸载的内容，这里我们介绍一个比较常用的方法，即九宫格分块加载方式。&lt;/p&gt;

&lt;p&gt;我们可以把一整个世界横竖切N和M刀，这样就有了分成 (N+1) * (M+1) 个块，每个块之间的地形也是被拆分开来的，因此可以说每块都是独立的，完全可以被独立加载或独立卸载。&lt;/p&gt;

&lt;p&gt;在游戏场景中，其实我们只能看到一部分的画面，即周围的800-1200米范围内的画面，越远的地形和风景意义越来越少，因此当前在所的分割块，加上周围的八个分割块足以能展示我们需要的画面，即九块的地图内容足以成为我们展示的画面内容。即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [-][-][-][-][-][-][-]
    [-][-][-][-][-][-][-]
    [-][-][2][2][2][-][-]
    [-][-][2][1][2][-][-]
    [-][-][2][2][2][-][-]
    [-][-][-][-][-][-][-]
    [-][-][-][-][-][-][-]
    [-][-][-][-][-][-][-]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中1为角色所在的地图块，2位周围8块已经被加载进来的地图内容。&lt;/p&gt;

&lt;p&gt;我们的角色不断向前行进，穿越了我们当前的地图块的边界，进入了另一个地图块，这时九块内容发生了变化，以我们角色为中心点的地图块周围的八块与原先我们所在的八块内容发生了变化。我们需要加载周围八块内容中，没有被加载进来的那三块内容，即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [-][-][-][-][-][-][-]
    [-][-][-][-][-][-][-]
    [-][3][2][2][2][-][-]
    [-][3][1][1][2][-][-]
    [-][3][2][2][2][-][-]
    [-][-][-][-][-][-][-]
    [-][-][-][-][-][-][-]
    [-][-][-][-][-][-][-]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中1为角色所在块，向前进了1块，原来所在的地块不再是角色的中心块了，转移到了新的地图块，那么周围的8块地图的也发生了变化。&lt;/p&gt;

&lt;p&gt;我们必须加载新的地图块，来确保我们展示的内容是完整的，即标记为3的内容块，并且我们还需要卸载被废弃的三块内容，即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [-][-][-][-][-][-][-]
    [-][-][-][-][-][-][-]
    [-][3][3][3][2][-][-]
    [-][3][1][3][2][-][-]
    [-][3][3][3][2][-][-]
    [-][-][-][-][-][-][-]
    [-][-][-][-][-][-][-]
    [-][-][-][-][-][-][-]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中标记为2的内容块是被废弃的内容块，是需要我们卸载的内容块，卸载不必要的内存贴图，模型等数据。&lt;/p&gt;

&lt;p&gt;根据九宫格的加载和卸载规则，角色不断前进或后退，不同方向上的前进或者后退，不断的跨越不同区块的内容，地图模块不断的加载需要的地图内容块并卸载不需要的内容块，角色能始终看到完整的地图内容，而不需要大量的内存支持，因为我们在不断的卸载那些不需要的地图块。&lt;/p&gt;

&lt;p&gt;当然，我们可以把它划分的更细致一些，将地图分的更细，然后再采用25宫格，49宫格等等，在玩家不断行走的同时，加载那些进入范围内的地图模型，而舍弃那些离开我们的地图方块。&lt;/p&gt;

&lt;p&gt;我们也可以将一次性加载和流式加载结合使用，在加载地图块时，把最关键部分一次性阻塞式的加载，比如地形和碰撞体，而其他的物件则用流式加载方式，使得加载不会瞬间消耗大量CPU，平滑的过度到加载完整个场景，所带来的游戏体验将是绝佳的。&lt;/p&gt;
</description>
               <pubDate>Mon, 05 Aug 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/08/05/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E5%9C%B0%E5%9B%BE%E4%B8%8E%E5%AF%BB%E8%B7%AF3.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/08/05/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E5%9C%B0%E5%9B%BE%E4%B8%8E%E5%AF%BB%E8%B7%AF3.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第十章，地图与寻路(二) 寻路网格的构建</title>
               <description>&lt;h3&gt;寻路网格构建&lt;/h3&gt;

&lt;p&gt;上一节我们了解了A星寻路的算法及其优化，A星寻路只是算法，需要配套的模块和工具链支撑，单独的一个A星无法运作因为它只是一个算法。&lt;/p&gt;

&lt;p&gt;需要什么样的模块和工具链呢，我们这节就来讲一讲，最重要的配套模块‘寻路网格构建’。除了网格构建外，还有动态障碍物，以及地图和地形的构建，最后再配上A星寻路，才形成最终的地图和寻路。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h6&gt;1.用二维数组构建虚拟的方形网格&lt;/h6&gt;

&lt;p&gt;最最简单的也是最最易于理解的网格构建方式要属二维数组网格，它是一个二维数组，每个元素就代表一个方格，方格中数字0代表无障碍，1代表有障碍，或者也可以是数字1代表障碍难度为1，比1大的数字代表更高的障碍难度，数字越大障碍难度越大，到达某个数字比如999，则认为该障碍难度完全无法跨越。&lt;/p&gt;

&lt;p&gt;举个二维网格的例子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [0][0][0][0][0][0]
    [1][1][0][0][1][1]
    [1][1][0][1][1][1]
    [0][1][0][0][1][1]
    [0][0][0][1][1][1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一个 5 * 6 的二维数组，0代表无障碍，1代表有障碍。我们很清晰的看到这张地图中有哪些是障碍点，在这张地图中，我们从任意一个无障碍点出发都能到达任意一个无障碍点，因为所有的0都是联通的。&lt;/p&gt;

&lt;p&gt;用二维数组代表地图是比较抽象的，那么怎么和地图匹配，怎么与地图真正的关联起来呢？&lt;/p&gt;

&lt;p&gt;我们在脑海中需要把地图也切成 5 * 6 这样30块地，比如这个张地图总共大小为 50米 * 60米 的大小，假如左下角为[0,0]位置，我们从0，0点开始，10，10点到0，0点为一个方块与[0,0]这个点关联，坐标10，10到坐标20，20为一个方块与[1,1]这个点关联，0，10点开始，10，20点到0，10点的方块与[0,1]这个点关联，依次类推。&lt;/p&gt;

&lt;p&gt;每个在地图上的10 * 10大小的一个块正方形的区域，都与数组关联。这样我们在用A星寻路在数组中寻路后的结果都可以一一对应到地图上。&lt;/p&gt;

&lt;p&gt;比如，我们寻路到从[0,0]点开始，到[1,4]点的路径为，[0,0]-&amp;gt;[1,0]-&amp;gt;[2,0]-&amp;gt;[2,1]-&amp;gt;[2,2]-&amp;gt;[2,3]-&amp;gt;[2,4]-&amp;gt;[1,4]，反应到地图上时，是0，0点开始移动，先移动到第一个方块也就是(0,0)到(10,10)这个方块的中点，也就是坐标(5,5)的点位上，再移动到(10,0)与(20，10)这个方块区域的中点上，即(15,5)坐标点位上，再移动到(20,0)与(30,10)这个方块区域的中点上，即(25,5)坐标点位上，依次类推，直到移动到最后一个点位，即(10,40)与(20,50)这个方块区域的中点上，即(15,45)这个坐标上，到达终点。&lt;/p&gt;

&lt;p&gt;因此A星寻路结束后，给出了[0,0]-&amp;gt;[1,0]-&amp;gt;[2,0]-&amp;gt;[2,1]-&amp;gt;[2,2]-&amp;gt;[2,3]-&amp;gt;[2,4]-&amp;gt;[1,4]，即数组上的坐标路径，在实际地图中则移动的路径为(5,5)-&amp;gt;(15,5)-&amp;gt;(25,5)-&amp;gt;(25,15)-&amp;gt;(25,25)-&amp;gt;(25,35)-&amp;gt;(25,45)-&amp;gt;(15,45)的坐标点位顺序。&lt;/p&gt;

&lt;p&gt;相当于把整个地图想象成一个矩形，把矩形横切N刀，竖切N刀，成了一个与二维数组匹配的方块地图，每个方块与数组中的一个元素相关联，当我们使用A星算法从数组中算出一个具体的路径时，可以根据这个数组中的路径，来匹配地图上的点位，即方块的中点。&lt;/p&gt;

&lt;p&gt;如果这个地图很大，但数组的大小很小，就无法实现细腻的碰撞体，所以我们需要在内存占用量与地图寻路细节之间权衡，即多大的数组与当前的地图才能匹配的更好，数组不能过大，因为过大的数组会造成内存的浪费，又不能过小，因为过小的数组使得地图的障碍细节无法得到完美的体现。所以我们在决定数组多少的时候，需要考虑的是整个地图的大小，以及最小障碍物为多大，来决策究竟需要用多大的数组。&lt;/p&gt;

&lt;p&gt;这些切割与关联都是由我们的脑袋想象出来的，过于抽象，毕竟我们在做游戏项目的时候，抽象的东西如果无法可视化的话，就会变得难以运用，至少是难以灵活的编辑和扩展。&lt;/p&gt;

&lt;p&gt;那么如何将这个抽象的方块可视化呢，最简单的方法就是用Excel方式，建立一个Excel，在Excel表中填入一个与数组相等大小的矩形方格块，在方格内填入颜色与数字，绿色代表可行区域，并填入0，红色代表不可行区域，并填入1。这样在Excel内就可以设置地图的障碍物，以及障碍物的大小，一眼就能知道，因为那些标记为红色的方格是障碍物，那里是不可通行的，那些标记绿色的地方为空地，那地方是可通行的，整个地图下来哪些地方不可通行，哪些地方可通行，一目了然。最后我们把这个Excel里的数据导出到文件，再在游戏开始时读取文件中的数据，得到地图的二维数组的障碍数据。&lt;/p&gt;

&lt;p&gt;除了Excel，我们还可以使用UnityEditor UI编写的地图编辑窗口，把地图大小，方格大小，障碍物等以可视化的形式放在 UnityEditor UI编辑窗口中，并编写保存数据到文件，和从文件读取地图数据的功能和按钮，这样一个地图编辑窗口就能更形象的体现地图的元素。&lt;/p&gt;

&lt;p&gt;如果这种可视化还不够，就得在具体的3D场景中的地图上做文章，把具体的整个地图加载并渲染在画面上，然后在地图上用颜色方块的方式画出不同颜色的块状，以具体地图为背景，来编辑地图障碍还是可通行块。当然这也带来更加多的编写和维护工作，但也同时是非常值得的可视化网格编辑器。&lt;/p&gt;

&lt;p&gt;如果嫌做一个地图编辑器作为可视化太麻烦，也可以用类似地形贴图的形式来做为可行走点的依据。用一整张1024 * 1024图代表一整个地形的大小，或者也可以为 2048 * 256等不同需求规格的大小，每个像素点代表二维数组的一个元素，比如白色为可行走区域，黑色为不可行走区域，那么这张图就可以压缩成只有R通道的8比特的图，图片像素中0就是黑色，1就是白色，或者加入更多元素2就是泥潭，3就是沼泽等等，这样就可以用图片代替了Excel的数据。当需要加载二维数组作为可行走数据时，则加载该图片读取像素中的每个元素录入到内存中，然后就可以依据内存中的二维数组来判定是否是可行走区域，以及相邻的格子是否是障碍物的判断。&lt;/p&gt;

&lt;p&gt;由于一维数组在分配内存块时的紧凑度往往比二维数组要来的好，用一维数组来读取索引中的数值会更加的快，因此我们常常使用一维数组来代替二维数组，在调用索引时也只是多了一个简单的乘法和加法的操作，即 二维数组 [a, b] 等于 一维数组 [a * width + b]，这样一来只是消耗很小的CPU就能在一维数组中索引到数值，而不再需要内存地址的跳转。&lt;/p&gt;

&lt;h3&gt;2.用路点系统构建寻路路线图&lt;/h3&gt;

&lt;p&gt;用二维数组的方式来构建寻路的基础数据有一定的局限性。当场景特别大，我们就要存储特别大的一个数组，编辑场景的工作量也有所提高，如果一个2048 * 2048 的数组的场景，我们要把所有的障碍点都设置一遍工作量比较大。&lt;/p&gt;

&lt;p&gt;除了数组太大和需要编辑的工作量扩大外，二维数组下的寻路路径最多是8方向的，上，下，左，右，左上，左下，右上，右下，寻路后的行走时会比较不真实，感觉是直来直去行走方向，要么90度方向行走，要么180度方向行走，要么45度方向行走，没有其他角度的行走姿势，让人感觉不真实，在像素游戏上还感觉不出什么来，但在3D地形中则会感觉明显的怪异。&lt;/p&gt;

&lt;p&gt;路点系统弥补了一些二维数组形式的缺点。路点系统也是一个易于理解的系统，它由很多个点构成，这些点我们称它们为路点，即路上的点，这些路点需要我们手动在地图上放进去，每个路点中都存储了坐标，ID，以及与哪些路点相连的数据。&lt;/p&gt;

&lt;p&gt;我们在地图中，放入了很多个路点，并且为这些路点配置了连线，于是就有了这幅画面：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;地图中每个路点都会有与其他某些路点相连接的线，我们可以称它们为路线，由路点与路点之间连线而成。&lt;/p&gt;

&lt;p&gt;如果把地图里的路点和路线铺设的更加复杂一点时，所有的点和线都拼成了一张网：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这张网中，只要我们得到某个点，就能根据这些路点和路线，用A星的算法来寻路到目的地。即，起点为，与起点最近的路点，寻路到，与终点最近的路点，的一条路径。如图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;路点系统很容易理解，但也需要一些可视化的编辑器的支撑，因为所有的路点都需要在既有的地图上编辑，所以编写一个专门的地图编辑器是必不可少的，没有地图编辑器至少也需要路点编辑器，可保存路点数据到文件，和从文件加载路点数据，以及增加路点，减少路点，添加和减少路点连接信息。&lt;/p&gt;

&lt;p&gt;路点系统的缺点也是比较严重的，它任然需要大量的工作量来编辑可寻路的路点信息与连线。另外，它的寻路方式无法识别碰撞而只能用路点的形式来绕过障碍。&lt;/p&gt;

&lt;p&gt;当在大块空地上做寻路时，需要在这个大块空地上手动添加很多的路点，才能平滑的适应各种寻路，虽然没什么难度，但对人来说重复的工作量比较大。&lt;/p&gt;

&lt;h3&gt;3.平面三角形网格的构建 -- Navigation Mesh&lt;/h3&gt;

&lt;p&gt;路点系统虽然直观，门槛低，上手简单，而且一般情况下路点的数量相对比其他方式的网格少很多，因此内存消耗和CPU消耗都比较少。但是人工手动的重复工作量比较大，更糟糕的是它无法识别障碍区域，行走的路线也依赖路点之间的连线。&lt;/p&gt;

&lt;p&gt;三角形网格就很好的解决了路点系统的缺陷，三角形网格是用生成算法自动生成的网格，无需手动编辑，而且还能识别障碍区域。&lt;/p&gt;

&lt;p&gt;Navmesh(即 Navigation mesh)是最耳熟能详的寻路解决方案，其实质是三角形网格生成算法 + 多边形之间的合并与裁切算法 + 寻路算法（A星算法 或 射线算法），这个解决方案在2D和3D游戏上的都得到了普遍使用。&lt;/p&gt;

&lt;p&gt;尽管Unity3D提供了内置的Navmesh寻路插件，以及Unity3D的Asset Store里也提供了众多的类似的不同种类的插件，但如果我们只是停留在插件使用的表层上，无法更深入理解到原理与底层的算法，那么我们在决策和定制寻路解决方案时仍然将始终无法得心应手，当遇到难题或瓶颈时也无法得到彻底有效的解决。&lt;/p&gt;

&lt;p&gt;三角形网格是怎么生成的呢，这个问题在计算机图形学里叫做 “平面多边形的三角剖分问题”，意思是说“怎么将一个平面多边形分解为由许多三角形组成的多边形”。&lt;/p&gt;

&lt;p&gt;平面多边形的三角形剖分问题是计算几何研究的一个基本问题，它广泛应用于模式识别、图像处理、计算机图形学以及机器人领域。一方面，三角形作为最简单的平面图形，较其他平面图形在计算机表示、分析及处理时方便得多；另一方面，三角剖分是研究其他许多问题的前提。&lt;/p&gt;

&lt;p&gt;其中Delaunay三角剖分算法是一种三角剖分的标准，实现它有多种算法。这些算法都是基于已经拥有多个点位的数据之上来建立一个三角形网格的。&lt;/p&gt;

&lt;p&gt;Delaunay三角剖分有其特点，剖分后的多边形里的三角形必须满足：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1.除了端点，三角形的边不包含其他任何点。

    2.除了在点上的连接，没有任何一条边是相交的。

    3.所有的面都是三角形，且所有三角形的合集是所有点集合的凸包。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一、二点很好理解，要求三角形的边上没有任何其他点，以及没有任何一条边有中间斩断式的相交情况，但最后一点说的是凸包，说明Delaunay三角剖分算法只适用于凸包形式的三角剖分。但实际情况时，凹形区域占到了大量的面积和数量。&lt;/p&gt;

&lt;p&gt;实际中我们需要的不只是凸多边形和凹多边形的三角形剖分，也需要考虑凹凸多边形中含有‘洞’(即不规则多边形阻挡物)的情况，甚至还有更复杂的‘洞’中有孤岛的情况，因此单单是凸多边形的三角形剖分不能满足我们实际的需求。&lt;/p&gt;

&lt;p&gt;2002年 David Eberly 在《Triangulation by Ear Clipping》论文中提出了用切耳法构建简单多边形的三角化。&lt;/p&gt;

&lt;h6&gt;什么是简单多边形呢，简单多边形是，所有顶点都是顺时针或者逆时针排列的顶点，每个顶点只连接两条边，边与边之间没有交叉的多边形，就叫做简单多边形。&lt;/h6&gt;

&lt;h3&gt;切耳算法&lt;/h3&gt;

&lt;p&gt;Ear Clipping 切耳算法是一个简单实用的三角形分割算法，其步骤可以简单的分为三步：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    在解释三步骤之前，我们先解释下几个名词的意思。

    1.耳点，耳点的意思是，多边形中相邻的三个顶点V0,V1,V2形成的三角形里，不包含任何的其他顶点，并且如果V1点是凸点，即V0-V1的连线与V1-V2的连线之间形成的夹角小于180度，则认为V1是耳点。所以一个由4个顶点组成的多边形中，至少有2个耳点。

    2.耳朵三角形，三角形顶点中有耳点的就叫耳朵三角形。

    第一，找到一个耳点。

    第二，记录这个耳朵三角形，然后去掉这个耳朵点，在剩余的顶点中，继续回到第一步

    第三，直到剩下最后3个点形成一个三角形并记录下来，把所有记录的三角形拼接起来就形成了三角化网格。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经过这三个步骤的计算，所有的耳点都被切掉后，再把所有记录的三角形拼装成三角形网格，就完成了整个三角形剖分步骤。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;多边形含‘洞’的情况&lt;/h6&gt;

&lt;p&gt;除了普通的简单多边形(包括凹凸多边形)的三角剖分外，如果简单多边形中有‘洞’的情况怎么办。论文中也给出了解决方案，即，依旧使用上述三步骤来做三角形剖分，只是剖分之前定把‘洞’并入外围的简单多边形，即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1，用外围的简单多边形上的点，连接‘洞’的简单多边形，因此为了保持所有点的一致性，‘洞’必须是与外围的多边形的点的顺序是相反的。即外围如果是逆时针的顺序，‘洞’则需要顺时针的顺序。

    2，在连接处，产生两个一模一样的点，即连接点。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用这种方式来将‘洞’并入成为一个单独的简单多边形，如果有多个洞，则先并入的洞为，拥有x轴方向最大的点的‘洞’，依次并入。&lt;/p&gt;

&lt;p&gt;也就是说，最终计算的还是一个单独的简单多边形，只是在计算之前，将‘洞’以凹形形态并入最外围的简单多边形。&lt;/p&gt;

&lt;p&gt;我们以图为例，可以看的更加清楚一点：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中展示了，如何将一个‘洞’以凹形形态的方式并入外围简单多边形的，就如同从外围简单多边形上，修了一条小小的通路到‘洞’中那样，其实我们完全可以理解为，下图那样：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中从外围简单多边形的点上延伸出一条路径来连接‘洞’，使得‘洞’的空白与外围的空白联通，就像贴膜里的气泡开了个口把空气放出去了那样。&lt;/p&gt;

&lt;p&gt;如果’洞‘并不是完全包含在外围简单多边形下，有可能是一半在外面，一半在里面，这时只要做多边形裁剪就可以了，将原来外围的简单多边形根据这个’洞‘裁剪成一个凹形，就与’洞‘彻底分离开来了，形成了新的简单多边形。&lt;/p&gt;

&lt;h6&gt;‘洞’中的’岛‘&lt;/h6&gt;

&lt;p&gt;除了有’洞‘，以及’洞‘包含在里面和’洞‘一半在里面一半在外面的情况，还有种情况是‘洞’中有’岛‘。这个‘岛’就像是湖中的‘孤岛’，虽然它也是需要三角剖分，但与外界是无法取得连接的，也就没有与最外围的简单多边形连接的需求。&lt;/p&gt;

&lt;p&gt;因此’洞‘中有’岛‘，这个’岛‘就相当于另一个独立的简单多边形范围，可以另外单独拎出来，自己计算自己的三角化部分。&lt;/p&gt;

&lt;h6&gt;到此，这样就形成了一整个算法，即，如果有‘洞’则先合并‘洞’，如果有岛，则拎出来作为与外围的简单多边形同级别的简单多边形自行计算。所有三角化的计算过程可简单描述为，找耳朵，去耳朵，记录耳朵三角形，最后得到了所有三角形，这四个步骤。&lt;/h6&gt;

&lt;p&gt;应用到实际项目中，最外层的简单多边形，就是我们在地图中定义的可行走的多边形范围。而‘洞’则是地图上的那些静态的障碍区域，而‘洞’中的‘岛’，则是不可行走范围内的可行走的‘孤岛’。&lt;/p&gt;

&lt;p&gt;实际项目中，构建三角寻路网格，我们首先需要找出这个最外围的简单多边形，以及孤岛，再根据切耳算法来构建三角形网格。因此我们需要根据地形来生成相应的可行走三角形网格，通过读取地图中的可行走区域的Mesh，以及读取障碍物Mesh，将它们的竖直方向y轴的值忽略后，再通过多边形合并算法来合并成为最外层的多边形，操作还包括裁切‘洞’一半在里面的情况，最后可以得到需要三角化的简单多边形，以及‘洞’的数据。最后将这些数据用切耳算法得到一个具体的三角网格。&lt;/p&gt;

&lt;h3&gt;4.拥有高度的3D三角形网格构建&lt;/h3&gt;

&lt;p&gt;前面讲了2D平面上的寻路网格构建，在实际项目中大部分时候，2D平面上的寻路就已经够用了，即使是有起伏的地面寻路，也可以用 2D寻路 + y轴射线碰撞的形式 获得位置坐标，在服务器端保存和运算的数据为2D平面数据，在客户端上展示时则加入了y轴碰撞后的数据，这样即满足了寻路的需求，也满足了高低起伏的地形。&lt;/p&gt;

&lt;p&gt;现实项目中有一种解决方案可以用多层级的2D网格做3D寻路的，这是种古老的做法，曾在PC端的RPG网络游戏中非常流行，但在现代的网络游戏中，相对比较少见，因为现代高度网格构建算法有比较成熟和方便的解决方案，但这种多层级2D网格代替3D网格的做法任然有比较好的借鉴的意义。&lt;/p&gt;

&lt;p&gt;我们暂且称它为‘分层平面寻路网格’，‘分层平面寻路网格’需要把所有可行走的区域分成多个层级，第一层与第二层之间有一个连接层，第二层与第三层之间也有一个连接层，这就像我们在一个多层的有楼梯的古堡中，古堡很高有4层楼这么高，每一层都用楼梯连接着，这个楼梯就是连接层与层之间的中间层。&lt;/p&gt;

&lt;p&gt;我们任然使用2D三角形网格构建法构建每一层的可行走区域，这样构建出7层网格数据，第一层是地面三角形网格数据，Layout层级我们可以标记为1，第二层是1楼与2楼连接的楼梯层可行走区域的平面三角形网格数据，标记为2，第三层为古堡2楼的可行走三角形网格数据，标记为3，第4层为2楼与3楼连接处的楼梯的平面三角形网格数据，标记为4，依次类推，每一层包括楼梯层都有自己的可行走的平面三角形网格数据。&lt;/p&gt;

&lt;p&gt;这7层网格数据都是独立的，每一层自己走自己的路时都不需要依靠其他层的数据来寻路。但是，如果只是独立计算各自层级中的网格数据，是无法跨越层级去其他层级的，就比如我们从大厅一楼要去楼梯上看看，或者上到二楼去看看，或者去三楼四楼。&lt;/p&gt;

&lt;p&gt;在‘分层平面寻路网格’中，当要跨越层级寻路时，首先必须确定的是‘我’在哪一层，目的地是哪个层级，出发点是哪个层级，按次序一层层往上走或者往下走。&lt;/p&gt;

&lt;p&gt;比如我们去的目的地是二楼，所在的起点是大厅的一楼，那么我们就必须由标记为1的地面层级，先到标记为2的楼梯层级，最后到达标记为3的二层楼，到达标记为3的层级也就是所谓的二楼后，再根据二楼的三角形网格数据进行寻路到达目的地。&lt;/p&gt;

&lt;p&gt;每一层都有自己独立的数据网格，跨越层级的寻路就需要层与层之间的连接点或连接信息，比如第一层的某几个三角形与第二层是连接的，或者也可以是某个点的范围内，只要进入这个三角形或者圆圈的范围，就认为我们上升了一层，或者下降了一层，我们身上标记的自己所处的层级也变化了，用到的寻路网格数据也变成了当前层的数据。&lt;/p&gt;

&lt;p&gt;因此只要我们移动到该区域内，就认为我们进入了第二层级，于是就可以开始了第二层级的网格寻路，再从第二层级移动到与第三层级相交的区域，就等于我们进入到了第三层级，最后在第三层级的网格数据上寻路，直达目的地。&lt;/p&gt;

&lt;p&gt;下楼也是同样的道理，在每一层中都有那么一个范围是可以通往下一个层级的，只要到达这个范围以内就认为是进入了下一个层级，于是就可以在下一个层级的网格数据中寻路。所以每次跨层级寻路时，都要先寻找上楼，或下楼的那个点，先从当前层级到达那个点上下楼的点，再从该点到达其他地方，有点像瞬移，到了某个点上时，瞬移到了另外一层网格上，只是坐标不变，层级的信息和网格数据变了。&lt;/p&gt;

&lt;p&gt;这种伪3D高度寻路解决方案其实也挺好用的，只是现在知道的人不多，用的人也少了，大家都是要么2D寻路网格够用了，要么就直接 RecastNavigation Navmesh 这种第三方解决方案，很少有人使用这种中间态的技术了，但是这种中间态的技术不是没用，它也有很多值得思考和借鉴的意义。&lt;/p&gt;

&lt;p&gt;RecastNavigation Navmesh 解决方案在各大引擎上非常流行，虽然各自都对其本身做了相应的修改，但核心算法是不变的。&lt;/p&gt;

&lt;p&gt;在Unreal，Unity3D上也同样应用了 RecastNavigation Navmesh，下一节我们会专门讲一讲这个 RecastNavigation Navmesh 中的核心算法，因为它的内容比较多，所以我打算专门用了一节的内容来剖析它，让大家能深刻理解它的原理。&lt;/p&gt;

&lt;h3&gt;5.三角形网格中的A星寻路&lt;/h3&gt;

&lt;p&gt;网格构建完毕了，那么就要派A星上场了。怎样才能让A星与网格数据结合呢。前面一节讲了A星的具体方法，这节就不再具体讲方法了，而是从应用的角度来看待A星的特点。&lt;/p&gt;

&lt;p&gt;A星的特点是必须有邻近的节点可获取，并且邻近的节点与目的地是可以有距离比较的。&lt;/p&gt;

&lt;p&gt;在这种特点的情况下，二维数组下的A星寻路很好理解，邻近节点就是周围的4个点或者8个点，并且与目的地的距离可以直接用方块之间的距离来计算。&lt;/p&gt;

&lt;p&gt;在路点系统中，也有邻近节点，它的邻近节点就是与该节点有线条连接的点，并且与目的地的距离可以直接用点与点之间的距离计算。&lt;/p&gt;

&lt;p&gt;在平面三角形网格中，要从一个点到另一个点，则可以使用三角形的邻近三角形来计算路径，与目的地之间的距离也可以用点与点之间的距离来计算。&lt;/p&gt;

&lt;p&gt;在‘分层平面寻路网格’中，从一个点到另一个点的寻路，和平面三角形网格差不多的方式，也是用邻近三角形来计算路径，只是在计算过程中还需要根据关注网格的层级，每一层都有自己独立的网格。&lt;/p&gt;

&lt;p&gt;二维数组下，计算出来的路径是这样的，[0,0]-&amp;gt;[1,0]-&amp;gt;[2,0]-&amp;gt;[2,1]-&amp;gt;[2,2]-&amp;gt;[2,3]-&amp;gt;[2,4]-&amp;gt;[1,4]。&lt;/p&gt;

&lt;p&gt;路点系统中，计算出来的路径是这样的，(id=1)-&amp;gt;(id=3)-&amp;gt;(id=6)-&amp;gt;(id=12)-&amp;gt;(id=21)。&lt;/p&gt;

&lt;p&gt;平面三角形网格中，计算出来的路径是这样的，(trangle&lt;em&gt;id=1)-&amp;gt;(trangle&lt;/em&gt;id=4)-&amp;gt;(trangle&lt;em&gt;id=8)-&amp;gt;(trangle&lt;/em&gt;id=13)。&lt;/p&gt;

&lt;p&gt;‘分层平面寻路网格’中，计算出来的路径是这样的，(trangle&lt;em&gt;id=1, layout=1)-&amp;gt;(trangle&lt;/em&gt;id=3, layout=1)-&amp;gt;(trangle&lt;em&gt;id=5, layout=2)-&amp;gt;(trangle&lt;/em&gt;id=8, layout=2)-&amp;gt;(trangle&lt;em&gt;id=1, layout=3)，其中trangle&lt;/em&gt;id为layout层级上的三角形ID。&lt;/p&gt;

&lt;p&gt;在三角形网格寻路后，知道了路径上需要经过哪些三角形，那么问题来了。我们行走的路径是根据点来判断的，三角形怎么定点，三角形的大小不一，有可能是宽形三角形，也有可能是扁长的三角形，如果点位定在中心点，那么行走的时候就会很怪异，每次都要先到达三角形的中点才能去下一个三角形，所以中点与中点的连线可能会很怪异。怎么办？&lt;/p&gt;

&lt;p&gt;折中的办法我们可以考虑用边的中点来记录路径，因为相邻三角形之间的穿越都是靠邻边来穿越的，所以邻边的中点更符合三角形穿越，从ID为1的三角形穿越到ID位2的三角形上时，穿越的是ID 1与ID 2三角形的共同边，这种邻边中点计算出来的路径，有更好更平滑的路径效果。&lt;/p&gt;

&lt;p&gt;不过这种三角形进出领边的中点还是不够靠谱，因为三角大小不一，致使三角形边的进出边也会随着三角形而改变，路径同样看起来曲折怪异。那么有没有一种方法能够更好更平滑的计算出三角形网格的路径呢。&lt;/p&gt;

&lt;p&gt;这里就需要引入一个拐点路径算法来优化寻路后的路径。拐点算法有点像射线，所以也常常被称作为射线优化路径算法。&lt;/p&gt;

&lt;p&gt;拐点算法其实并不复杂：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1.从起始坐标点出发，往与下一个三角形的入口边的两个顶点v1,v2产生两个向量line1、line2，然后再往下一个三角形的入口边的两个顶点v3,v4产生两个向量line3、line4。

    2.通过计算这四个向量的叉乘，可以判定一个向量是在另一个向量的左边或者右边。我们可以计算出v3，v4是否在line1，line2形成的夹角。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里会出现几种情况：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1.下一组边与上一个路径点的向量全部在前一组边的范围内，直接把下一组边的两点替换前一组边的两点。

    2.下一组边的右边点与上一个路径点向量在上一组边的范围内，但左边的点不在范围内，把下一组边的右边点替换前一组边的右边点

    3.下一组边的左边点与上一个路径点向量在上一组边的范围内，但右边的点不在范围内，把下一组边的左边点替换前一组边的左边点

    4.下一组边两个点组成的向量都在上一组边的左边，那么上一组边的左边点成为拐点

    5.下一组边两个点组成的向量都在上一组边的右边，那么上一组边的右边点成为拐点

    6.假如下一组边左边的点和上一组边的左边点重合，则把上一组边的左边点成为拐点

    7.假如下一组边右边的点和上一组边的右边点重合，则把上一组边的右边点成为拐点

    8.当寻路达到最后一个多边形，直接判断终点和上一个路径点的向量是否在上一个边两点的中间，假如不是，再增加一个拐点
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举例说明：从右边的开始点往左边的结束点寻路&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;line3，line4在line1，line2夹角内，左右都缩进。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;v4在外面，左边缩进。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;v3,v4都在line1 左边，v1成为拐点&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从v1出发继续按上面步骤计算拐点&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后到达终点，收集所有拐点，加上起点和终点后就是正条经过优化后的路径节点。这种射线算法或者说拐点算法能将原本在三角形网格寻路后诡异的路径转化为更加平滑的直线路径。&lt;/p&gt;

&lt;h6&gt;下一节将重点来剖析一下Unity3D中嵌入的 RecastNavigation Navmesh 网格构建算法和寻路算法。&lt;/h6&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;p&gt;《Triangulation by Ear Clipping》David Eberly&lt;/p&gt;

&lt;p&gt;《Delaunay三角剖分的几种算法综述》吴莉莉&lt;/p&gt;

&lt;p&gt;《多边形寻路算法简单介绍》 liweizhaolili&lt;/p&gt;
</description>
               <pubDate>Fri, 26 Jul 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/07/26/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E5%9C%B0%E5%9B%BE%E4%B8%8E%E5%AF%BB%E8%B7%AF2.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/07/26/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E5%9C%B0%E5%9B%BE%E4%B8%8E%E5%AF%BB%E8%B7%AF2.html</guid>
            </item>
        
    </channel>
</rss>