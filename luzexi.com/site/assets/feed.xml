<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title></title>
        <description>漫漫人生,记录点滴技术,始于2013</description>
        <link>http://www.luzexi.com</link>
        <atom:link href="http://www.luzexi.com/assets/feed.xml" rel="self" type="application/rss+xml" />
        
            <item>
               <title>思路探讨(二十二) 为什么做不出最正确的选择</title>
               <description>&lt;p&gt;人这一生真的能在每个节点都做出最好的决策吗，肯定不能。这个比较理想化的美梦，大多数人都知道是不可能的。&lt;/p&gt;

&lt;p&gt;但人真的能在模棱两可的分岔路面前做出最正确的决策吗？我认为是不可能的。（需要明确一点是，模棱两可的选择是指两种或者几种选择都是朝着光明的方向去的，而不是一黑一白或者两种都是黑。）&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;为什么做不出最正确的选择？&lt;/p&gt;

&lt;p&gt;因为最好的决策通常都是事后分析才会知道，在当下是无法知道事情到底会如何发展，只有当事情变成了历史，我们再回过头来看这件事时才能真正找到最好的决策方向。&lt;/p&gt;

&lt;p&gt;比如，何时买股票，何时卖股票，何时买房，何时卖房，选择什么专业，该不该和这个人结婚，该不该下海去创业，该不该选择这个人合作，该不该送孩子出国，该报考哪所学校，以及该不该跳槽，应该去哪座城市工作和生活等等等。所有这些都会等你做出决策，并执行多年后，再回过头来梳理时，才能真正明白到底我做对了还是错了。&lt;/p&gt;

&lt;p&gt;为什么是要等事情成为了历史才能知道当时该如何决策，我就不能直接洞悉事情的发展方向做出相应的决策？&lt;/p&gt;

&lt;p&gt;不能。因为世界是变化的。&lt;/p&gt;

&lt;p&gt;我们所处的这个世界里每分每秒都在变化，在这个变化的世界里，我们永远无法知道事情会如何发展，永远无法知道别人到底怎么想（你以为你聪明到能知道所有人的想法时就已经代表你错了），他们到底会怎么做，有多少人会这么想并有多少人会那样做，这所有与之有关的人的行为会给这样事情产生多少影响，又有多少人会因为别人的行为而改变自己的行为方式，你认为就凭你聪明的脑袋能计算的过来么，不可能。&lt;/p&gt;

&lt;p&gt;更何况还有那些与事情有关联的人的关联人，以及与之相关联事情的事情，太多太多，甚至我们都无法知道究竟有多少与之相关联的事情在同时发生，何况在同一时刻这所有关联的人和事都在不断得产生着变化。&lt;/p&gt;

&lt;h6&gt;我们不得不敬畏这个世界，我们永远无法估量，到底有多少事情在影响着我们当下关心的这件事情。&lt;/h6&gt;

&lt;h6&gt;在这个变化的世界里，想做出最正确的选择，是不太可能的，正确的选择只有在回顾历史时才存在。而我们只能就自己的理解做出自己认为最正确的选择。&lt;/h6&gt;

&lt;p&gt;那么做出一个正确的选择真的那么重要吗？不是的。为什么？&lt;/p&gt;

&lt;p&gt;我们退一步说，即使从历史的角度看我们做出了正确的选择，就一定能成功吗？不是。&lt;/p&gt;

&lt;p&gt;首先，即使我们很幸运做出的选择，从历史角度看是最正确的选择，我们也不一定能执行到位。&lt;/p&gt;

&lt;p&gt;实际上，大部分时候连我们自己都不太相信自己做出的决策是对是错，总是在摇摆不定，虽然在表面上坚定的支持这种选择，但在心里还是持有一定的怀疑的态度。这种怀疑的态度，导致我们无法完全百分百的执行我们做出的决策。&lt;/p&gt;

&lt;p&gt;知行合一的难度就在这里，我们到底相信多少我们所知道的。由于人类思维的灵活性以及人性的弱点，我们很难百分百相信我们所知道的一切，永远都在怀疑是否有更好的我们所不知道的存在。&lt;/p&gt;

&lt;p&gt;其次，即使我们很幸运做出了正确的选择，并且很坚决的执行了决策，但成功并不是一个决策而导致的结果，而是由几百几千个决策共同组成的决策群，和，所有为之努力的执行方式的集合组合而成的结果。&lt;/p&gt;

&lt;p&gt;成功的难度就在这里，一个决策并不能决定一个人或一件事的成功与否，成功是由一群决策方向和一群行动方向组合而成，并经过多年累月得到的最终结果。&lt;/p&gt;

&lt;h6&gt;抢到门票就能赢吗？不是的，门票只是一个赛跑的起步优势点并不能决定整场比赛的输赢，别忘了拼命抢到的门票也有可能是一场灾难的开始。&lt;/h6&gt;

&lt;h6&gt;做出‘一个’正确的选择并没有那么重要。重要的是做出选择后的所有其他的选择，以及接下来的所有行动。&lt;/h6&gt;
</description>
               <pubDate>Sun, 31 Mar 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/03/31/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A822.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/03/31/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A822.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第八章 AI(2)-用行为树构建AI</title>
               <description>&lt;p&gt;前面讲了用状态机来构建游戏中的怪物AI，由于它易于理解，容易被人类接受，扩展性和耦合性都很好，所以状态机的用途很广泛。但是状态机也有很大的缺点，就是不能处理和模仿太复杂的智能行为，比如模拟一个人类奔赴一场大型战役中，对战场中的各种繁多的突发事件做出符合人类模式的处理，这种方式状态机就无能为力，由于突发情况太多，组合起来的突发情况更多，做出反应的方式也变化多端，用人类思维逻辑去编写每个状态，状态的数量就会如指数级攀升无法应付，说的直白点就是人类大脑无法应付这么复杂的逻辑编写。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;行为树很好的弥补了状态机的缺点，它简化了逻辑拼凑的方式，让简单头脑的人类能更容易编写和控制机器人的智能行为。这其实也是AI架构的关键点，能够让简单头脑的人类制作复杂的人工智能的行为方式，化繁为简。&lt;/p&gt;

&lt;p&gt;化繁为简是我们的重点，人工智能的行为方式，都是由人类头脑指定的行为方式，是人类头脑所预期的，而非不可控的。制作出人类所预期的AI行为逻辑，制作的方式和过程又在人类大脑的承受范围内的，才是我们需要的。状态机的方式制作AI理论上可以实现任何AI，但复杂到一定程度人脑无法承受，其实就是无效的，或者说失败的。&lt;/p&gt;

&lt;p&gt;行为树的优势就在这里，能够通过一些简单的人类能够应付的操作，制作出达到人类所预期的足够复杂的机器人行为方式。&lt;/p&gt;

&lt;p&gt;下面我们来详细介绍行为树的组成。&lt;/p&gt;

&lt;p&gt;行为树(Behavior Tree)具有如下的特性：&lt;/p&gt;

&lt;p&gt;它有4大类型的N节点：&lt;/p&gt;

&lt;h6&gt;1，Composite Node 复合节点&lt;/h6&gt;

&lt;p&gt;复合节点可详细的分为3种：&lt;/p&gt;

&lt;p&gt;一种是Selector Node，选择节点。当执行本类型节点时，它将从头到尾迭代执行自己的子节点，如果遇到一个子节点执行后返回True则停止迭代，本Node向自己的上层的父节点也返回True，否则所有子节点都返回False，那么本Node向自己的父节点返回False。&lt;/p&gt;

&lt;p&gt;一种是Sequence Node，顺序节点。当执行本类型Node时，它将从头到尾依次迭代执行自己的子节点，如遇到一个Child Node 子节点执行后返回False，那停止迭代，本Node向自己的Parent Node父节点也返回False；否则所有Child Node都返回True，那本Node向自己的Parent Node返回True。&lt;/p&gt;

&lt;p&gt;还有一种是Parallel Node，并发节点，并发执行它的所有Child Node子节点。&lt;/p&gt;

&lt;p&gt;向Parent Node父节点返回的值和Parallel Node所采取的具体策略相关：&lt;/p&gt;

&lt;p&gt;Parallel Selector Node: 执行完所有子节点，有一个False则返回False，全True才返回True。&lt;/p&gt;

&lt;p&gt;Parallel Sequence Node: 执行完所有子节点，有一个True则返回True，全False才返回False。&lt;/p&gt;

&lt;p&gt;Parallel Hybird Node: 执行完所有子节点，指定数量的Child Node返回True或False后才决定结果。&lt;/p&gt;

&lt;p&gt;并行节点提供了并发性，由于它可以在线程或协程级别提供并发操作，所以在性能上面有能够充分利用CPU提高性能。&lt;/p&gt;

&lt;p&gt;通常情况下，Parallel Node下会并行挂多个Action子树，或者挂多个Condition Node以提供实时性。&lt;/p&gt;

&lt;p&gt;Parallel Node增加性能和方便性的同时，也增加实现和维护复杂度。&lt;/p&gt;

&lt;p&gt;除此以外为了进一步提高AI的复杂度和随机性，Selector 和 Sequence可以进一步提供非线性迭代的加权随机变种。比如，Weight Random Selector，每次执行不同的起点，提供了每次执行不同的First True Child Node的可能。而Weight Random Sequence则每次执行顺序不同，提供了不同的迭代顺序的方式。这在AI术语中称为partial-order，能使AI避免总出现可预期的结果，让结果更加的随机化。&lt;/p&gt;

&lt;h6&gt;2，Decorator Node 修饰节点&lt;/h6&gt;

&lt;p&gt;Decorator Node，它的功能正如它的字面意思：它将它的Child Node执行后返回的结果值做额外修饰处理后，再返回给它的Parent Node。比如反向修饰Decorator Not：将结果反置后返回上级处理，失败修饰Decorator FailUtil：将失败修改后返回上级处理，计数修饰Decorator Counter：将结果计数后返回上级处理，时间修饰Decorator Time：将时间修改后返回上级处理。也可以作为日志处理Decorator Log，动画修饰处理Decorator Animation，甚至Decorator Nothing什么都不干。&lt;/p&gt;

&lt;h6&gt;3，Condition Node 条件节点&lt;/h6&gt;

&lt;p&gt;Condition Node相对比较简单，条件满足则返回Ture，否则返回False。&lt;/p&gt;

&lt;p&gt;各式各样的条件节点，都继承基础条件节点并且返回Ture或False。&lt;/p&gt;

&lt;p&gt;比较常用的条件节点例如，血量判断条件，距离判断条件，状态判断条件，时间间隔判断条件等。&lt;/p&gt;

&lt;h6&gt;4，Action Node 行动节点&lt;/h6&gt;

&lt;p&gt;Action Node，通常都是最后的叶子节点，它完成具体的一次(或一个step)的行为，视需求返回值。&lt;/p&gt;

&lt;p&gt;Action Node可以是执行一次的，也可以视为分步执行很多次的行为。例如，向前进这个行为，可以一直被执行，直到条件不满足。&lt;/p&gt;

&lt;p&gt;也就是说，通过扩展Action Node完全可以不需要借助外在程序或接口，自主定义角色行为。&lt;/p&gt;

&lt;p&gt;常用的Action Node节点的例如，行走到目标地点Action，跟踪目标Action，转换角色方向Action，撤退Action，攻击Action，防御Action，释放技能Action等等。&lt;/p&gt;

&lt;h6&gt;在行为树中任何Node被执行后，必须向其上层的父节点报告执行结果：成功True或失败False。这简单的成功或失败汇报原则被很巧妙地用于控制整棵树的决策方向。&lt;/h6&gt;

&lt;p&gt;行为树能够支撑起对复杂逻辑的AI的原因就是由于使用了这些简单的节点去搭建整个AI模型。由于人脑可以很容易的写出这些简单的单个节点的逻辑，使得节点的功能性扩展变得非常容易，而拼装这些节点，就像是一个搭积木的过程，人脑能搭建多复杂的积木，就能搭建起多复杂的AI。&lt;/p&gt;

&lt;p&gt;整棵行为树中，只有Condition Node和Action Node才能成为Leaf Node叶子节点，而也只有Leaf Node才是需要特别定制的Node。而Composite Node和Decorator Node均用于控制行为树中的决策走向。所以有些资料中也统称Condition Node和Action Node为Behavior Node行为节点，而Composite Node和Decorator Node为Decider Node决策节点。&lt;/p&gt;

&lt;p&gt;在行为树之前，还有决策树这个被遗忘了的AI解决方案。决策树和行为树一样都是树形结构，都是由节点构成。决策的构成是由树形结构的头部开始，从上往下一路判断该往哪走，最后一定会执行到叶子节点，在决策树中只有叶子节点才决定了如何行动，而且在决定后的行动中，无法中途退出，要等到档次行为执行完毕或者被打断后才能开始下一次决策。&lt;/p&gt;

&lt;p&gt;从理念上讲，决策树就是为了制定决策，而行为树是为了控制行为，是两个不同的理念，行为树更加注重变化，而决策树则注重选择。因此行为树可以定制比决策树更加复杂的AI逻辑，而实现的难易程度行为树并没有增加多少，所以决策树被冷落也是情理之中。&lt;/p&gt;

&lt;h6&gt;行为树比状态机更容易编写复杂的AI逻辑就是由于单一节点的易扩展性，以及整个AI树的可搭建能力都是在人脑的可及范围内。但是，再厉害的人脑也有搭建复杂度的极限，无论你对搭建行为树这项技能有多么精通，都有到一个极限的状态，也就是搭建的复杂度超出人类大脑的时候，人类就完全无法继续搭建了，或者说无法完成。例如，如果想完全模拟人类的思维判断逻辑，对不同的人，对不同的事，对不同的景色，对不同的物体，不同的路面，以及以上混合组合的不同组合，就完全超出了人类大脑搭建的极限。像这种特别复杂，完全不能由人类大脑自主搭建的方式形成的AI，就需要引入‘机器学习’这个概念了。由于情况太多，太复杂，唯有‘机器自主学习’才能适应这些复杂的情况时，‘Machine learning机器学习’，‘Deep learning深度学习’，‘Artificial Neural Network神经网络’，就成了解决这些问题的方案。&lt;/h6&gt;

&lt;p&gt;参考:&lt;/p&gt;

&lt;p&gt;《使用行为树(Behavior Tree)实现游戏AI》by AKara 2010&lt;/p&gt;
</description>
               <pubDate>Thu, 28 Mar 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/03/28/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-AI2.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/03/28/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-AI2.html</guid>
            </item>
        
            <item>
               <title>思路探讨(二十一) 生存之战</title>
               <description>&lt;p&gt;22周岁毕业，在杭州工作了4年，26岁带着不甘心独自去了上海，27岁结了婚，28岁有了第一个孩子，29岁第二个孩子降临，今年要32周岁了。从毕业到现在过去了10个年头，有时偶尔回头望去觉得是精彩的，不过精彩的并不是结果，而是这10年里拼搏的过程，那种奋力前行用尽全力突破自我的精神和逆流而上明知山有虎偏向虎山行的勇气。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;这种勇气和精神，来自于我的内心，不甘心成为一个平庸的人的意识形态，我不愿意自己每天妥协过着看不到尽头的无奈日子，我希望自己改变自己，改变成为自己心中的那个非常强大的人。&lt;/p&gt;

&lt;h6&gt;还没有孩子前我只为我自己奋斗，那时我觉得这样的动力已经很足够了，但我还是too young too naive，在有了孩子后，特别是有第二个孩子之后，我彻底清醒的认识到我过去的行动和能力都是小儿科级别的。&lt;/h6&gt;

&lt;p&gt;特别是最近我读了《富兰克林自传》、《居里夫人自传》、《稻盛和夫自传》、《韩信传》、《林肯传》这些名人传记后，生存的严肃性再次深刻的、深切的、深不见底的印在我记忆的肌肉里。&lt;/p&gt;

&lt;h6&gt;他们都是严肃生活的典范，他们专心，专业，努力，奋力，认真得经营着自己，包括身体、知识、思想、家庭。他们并不埋怨环境，而是改变自己，他们知识环境无法改变，只有改变自己。因此在恶劣的环境下他们任然保持自己前进的节奏，虽然偶尔被环境所打断，甚至被迫害，但他们依然能够不断调整自己回到最初的状态，尽管时常也陷入巨大的瓶颈，但多大的苦难和瓶颈都没能挡得住他们突破自己的步伐。&lt;/h6&gt;

&lt;p&gt;对比我自己，我还是太稚嫩，严肃的不够严肃，认真得不够认真，对生活没有一个清醒的彻底的完全的认识，时常有’休息一下也没事‘、’一天不努力也可以‘、’明天再学也不迟‘的行为和想法，导致原本制定的计划，或者良好的生活习惯，或者良好的学习习惯被一点点侵蚀，最终导致自律能力彻底丧失，彻底沦为浪费时间浪费生命的大懒虫。&lt;/p&gt;

&lt;p&gt;我再次回忆我这年轻的岁月里，浪费了有多少的时日时，时常感叹如果我能早点知道该有多好。&lt;/p&gt;

&lt;h6&gt;每次有这种’早点知道该有多好‘的感叹时，我知道为时还不晚，因为有很多智者提醒过我，任何时候只要你意识到正确的道路在个方向时都不晚。虽然这些智者我都没见过，他们存在于书中，电视中，视频中，但却时常能够起到提醒我的作用。&lt;/h6&gt;

&lt;p&gt;正确的道路确实难走，所以人才会跟随人性弱点去选择舒适的但错误的道路。&lt;/p&gt;

&lt;h6&gt;生存之战就是谁能长时间的、长期的、长久的、更长时间的、更长期的、更长久的走在正确道路上的无形的战争。&lt;/h6&gt;

&lt;p&gt;每个人在战争中都走的是自己的路并平行于他人，从来都不跟别人碰撞，但每一步都有好有坏，而每个步都有他们自己来决策。&lt;/p&gt;

&lt;p&gt;让人感到意外又不十分惊奇的是，很多人并不知道他们已经决策了自己的路，他们甚至以为生活的决策是有个缓冲期的，会给到具体的问题和正确的答案。&lt;/p&gt;

&lt;h6&gt;生存之战的残酷性就在这里，它的决策之路很少有具体的标志性的事件或者缓冲期，甚至连问题和答案都没有，所有的人生道路的决策都是由生活中的一言一行，一举一动拼凑而成的。&lt;/h6&gt;

&lt;p&gt;你是怎么生活的，你就是怎么决策着你的道路，容不得我们半点侥幸。根本不会出现，例如有个决策能一下子完全彻底的改变你的人生道路的东西出来，所有你走出来的道路都是由你生活的点滴组合而成，所有导致事件发生的都是由你先前的生活中一举一动的决策积累导致的量变引起的质变。&lt;/p&gt;

&lt;p&gt;人们口中时常说的残酷是由于人多或者需求多而供应少导致的，我觉得生存之战的残酷比它这种残酷要残酷一百倍。&lt;/p&gt;

&lt;p&gt;生存之战的残酷是没有硝烟的，是看不见摸不着的，但却时时刻刻在战斗，更残酷的是，并不是战斗一年两年就结束的，而是10年，20年，30年，40年，50年，一辈子。直接说一辈子太突兀，所以用前面的数字来做铺垫会让人好受些。&lt;/p&gt;

&lt;p&gt;一辈子持久战的残酷性，我想是我们这个和平年代下最最残酷的残酷战争了吧。&lt;/p&gt;

&lt;h6&gt;提高警惕并且奋斗，这是场最长的持久战，记得身体是第一关键因素哦，谁在持久战中身体先垮掉谁就第一个败下阵，每天运动保持身体免疫系统正常工作是第一要素。有了身体还不够，还要有知识、技能、思维方式、育人技巧、沟通能力、经验等等等，等着我们去征服它们。&lt;/h6&gt;

&lt;h6&gt;别放弃，别太多沮丧，哭完了我们继续上！&lt;/h6&gt;
</description>
               <pubDate>Sun, 17 Mar 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/03/17/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A821.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/03/17/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A821.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第八章 AI(1)-状态机构架机器人行为</title>
               <description>&lt;p&gt;AI机器人在游戏中非常普遍，它们常以模仿人类的行为在游戏中活动。游戏中的怪物的自动行为比较普遍，这种简单的人工智能方式可以用几种不同的方式进行编写，这里我们介绍两种方式，一种为容易被人类思维接受的状态机AI编程，另一种为特别为机器人思考方式编写的行为树AI编程。其实还有很多方式来编写AI，比如和行为树差不多的决策树，以及相对比较复杂的神经网络，以及更复杂的机器学习，在此不多做介绍，由于过于复杂甚至超过了项目的周期，研发和维护成本太高，所以在游戏中的应用并不太多，很少有人尝试。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h3&gt;AI-状态机&lt;/h3&gt;

&lt;p&gt;状态机虽然是个比较简单的概念，但在实际编程中花样也是繁多的，不过最终都是围绕着状态这个基础变量来做变化的。&lt;/p&gt;

&lt;p&gt;状态机最符合人类思考的方式，我们喜欢把事物以状态形式进行拆分成：当前状态，前置状态，下一个状态，状态变化需要的条件等。其中每个状态都有自己定义，比如行走，蹲下，躺下，攻击，防守，三连击，俯冲，左移，右移等。&lt;/p&gt;

&lt;p&gt;人们习惯把人或动物的某些连贯的行为定义为状态，所以状态其实不只是一个动作，它可以是好几个动作，或者好几段位移，也就是好几段执行程序。&lt;/p&gt;

&lt;p&gt;这种好几个动作和好几段位移一起组成的组合，在程序中用状态来表示最符合逻辑。每种状态下不只是一个动作或一种位移，而是由很多个动作多段位移组合而成。&lt;/p&gt;

&lt;p&gt;在游戏里，智能的机器人由于都是人设计出来的，行为方式也最符合人类的逻辑，所以状态机的方式制作AI最符合人类思维，也最容易被接受。&lt;/p&gt;

&lt;p&gt;从面向程序的角度来看，状态可以从父类构建开始，并且向不同的方向继承并衍生，最终再把所有的状态类集中到控制状态的状态控制器中。&lt;/p&gt;

&lt;p&gt;下面我们就以图和文的方式构建一个 AI 状态机：&lt;/p&gt;

&lt;p&gt;我们以 AIStateBase 为状态基础类，基础类中有一个识别状态类的变量，可以是整数，也可以是枚举，和三个必要的接口，更新函数 Update() ，进入状态事件引发的事件函数 OnEnter()，退出状态事件引发的事件函数 OnExit()。这三个函数足以概括状态的出、入、以及自我循环更新三个动作，状态机定义下也只有这三个动作可以做。&lt;/p&gt;

&lt;p&gt;接下来，我们开始扩展状态机的功能，以跑步动作状态为例：&lt;/p&gt;

&lt;p&gt;在进入跑步动作状态时，表现为，机器人有跑步动画，并且向前移动。&lt;/p&gt;

&lt;p&gt;实现跑步状态，首先继承父类 AIStateBase 并且把跑步状态类命名为 AIRunState。然后再对 AIRunState 进行编写，在进入状态时也就是 OnEnter 函数中编写机器人播放跑步的动画并让动画不断循环播放，然后在更新函数 Update 中开启不断向前移动的位置变化。当不再需要移动时，也就是退出跑步状态事件中，OnExit 里调用停止播放动画，也可以不停止播放，因为下一个状态肯定会播放其他动画，不如让他们插值过度下动画看起来会更顺滑。&lt;/p&gt;

&lt;p&gt;实现了跑步状态，可以引申出其他和它基本相同的状态，它们可以完全按照跑步状态的方式实现，比如后退，侧移，漫步，打坐，跳跃，攻击等，它们都是只用到播放自身动画和持续位移组合的方式完成状态。对其他复杂状态来说，算是比较基本的状态。&lt;/p&gt;

&lt;p&gt;现在我们来实现稍微复杂点的状态‘追击’状态。追击中有两个动作，一个是追，一个是攻击，不止是这些，我们还必须首先锁定目标，然后寻找追击的路径。当怪物进入‘追击’状态时，会锁定目标，然后不断向目标跑去，当跑到攻击范围内时，进行攻击。&lt;/p&gt;

&lt;p&gt;我们定义一个‘追击’状态类，AIAttackState 类同样继承 AIStateBase。当‘追击’状态开始时，进入 OnEnter 函数时先锁定目标，把目标保存下来，并且寻找追击目标的路径 Path Find，寻路解决方案会在地图与寻路章节中详细介绍。接下来就是‘追击状态’的更新函数，每帧都会调用更新函数 Update，在Update中，检查目标是否已在攻击范围内，如果是则立刻播放攻击动画，并且调用目标的伤害接口使目标受伤，如果不在范围内则检查锁定目标是否移动，如果有移动就重新寻找路径，并且根据路径来进行位移。整个追击状态，在追击中都是在 Update 函数中不断判断和位移的。&lt;/p&gt;

&lt;p&gt;追击状态以追和攻击为主要行为。与追击状态类似的，也比较常用的还有‘巡逻状态’，当怪物进入这个‘巡逻状态’时，怪物会在一个范围内到处行走以查看敌人是否在周围，如果在视野范围内查看到敌人，则退出巡逻状态，进而进入追击状态。&lt;/p&gt;

&lt;p&gt;我们来看看编写‘巡逻状态’的步骤。当进入‘巡逻状态’时，状态进入 OnEnter 函数，在 OnEnter 里找到最近的一个巡逻点，然后在更新函数 Update 中持续循环走向最近的巡逻点，当走到第一个最近的巡逻点后继续按照巡逻点的布置顺序继续往下一个巡逻点走，如此不断循环往复。同时更新每次移动时，都检查一下敌人是否在范围内，如果有敌人在检查范围内，当前‘巡逻状态’就结束，OnExit 被调用，转而进入‘追击状态’。&lt;/p&gt;

&lt;p&gt;至于‘追击状态’返回‘巡逻状态’的条件可以设置为，当追击太远时重新转入’巡逻状态‘，比如在进入’追击状态‘ OnEnter 函数里记录起始追击位置，每次移动时都判断下，与起始位置的距离是否太远，如果太远则退出当前的’追击状态‘转而进入’巡逻状态‘。&lt;/p&gt;

&lt;p&gt;游戏策划常设计Boss怪物进入‘疯狂状态’，例如，这个怪物突然变身，然后开始疯狂得从天空里召唤火球，这些火球像流星一般撞向地面，爆炸，并在爆炸范围内敌人受到伤害，结束后怪物又回到了普通的’追击状态‘。&lt;/p&gt;

&lt;p&gt;我们来分析下这个’疯狂状态‘如何编写。当进入’疯狂状态‘时，状态类被调用进入状态事件函数 OnEnter ，函数里播放立刻Boss怪物的变身动画，因为 OnEnter 只调用一次，所以所有检查都在更新函数 Update 里进行，Update 中检查变身动画结束时更换怪物的模型为变身后的新模型，因为需要新模型播放自己的动画所以必须更换。紧接着更换完变身后的模型后，就用新的模型播放施法动画，同时不断按次序调让火球出现在上空的某个位置，并持续移动向地面，当火球的物理引擎检测碰撞到地面时，销毁火球并生成爆炸特效，同时在爆炸位置范围内，查找到是否与爆炸位置距离小于某个值的敌人，如果有则调用敌人的受伤接口使其受伤。当检测到所有火球都已经爆炸完毕，则完成了此次’疯狂状态‘，退出并转向’追击状态‘。&lt;/p&gt;

&lt;p&gt;无论多少复杂的技能或者行为，都能在一个状态中体现出来，以状态形式的编写好用就在这里。有了众多复杂的状态还不够，我们还需要有控制这些状态的状态控制器。&lt;/p&gt;

&lt;p&gt;状态控制器就是记录，这些状态的状态管理类，我们可以命名为 StateControl类，所有状态都在 StateControl 里有一份实例，而且状态控制器记录了一个变量是当前是什么状态，由于所有状态都是继承与 AIStateBase，所以这个当前状态变量可以为 AIStateBase 以支持所有类型的状态类。又由于所有的状态类的对外接口都是统一，所以只需要基类就能操作所有状态，而且状态的转换也完全可以各自状态的本身来决定。状态控制器，只是起到了对状态实例管理和转换的工具，所以状态控制器没有太多了的逻辑，所有AI逻辑都放在了每个状态类里面，由每个从 AIStateBase 父类继承而来的AI子类来决定如何行动，这种做法大大降低了逻辑的耦合，让代码逻辑更加清晰，维护性强，扩展性强。&lt;/p&gt;

&lt;h6&gt;用状态机编写AI有诸多优点，诸如可维护性强，可扩展性强，逻辑耦合清晰，符合人类思维逻辑易上手。但缺点也很大，由于每个状态都必须由设计人亲自制定，所以在每个状态时编写时要考虑到所有情况，每种情况都要有自己的处理方式，这样就导致当需要设计的AI行为过于复杂的时候，编写的逻辑复杂度和工期长度也呈现指数级的增长，到最后有可能无法承受太复杂的AI行为逻辑，比如人类在战场中的随机应变能力，对于各种各样的爆炸，攻击，冲锋，防御的应变能力需要表现出各种不一样的行为方式时，如果任然用状态机来编写，就会很容易陷入超出人类逻辑的复杂度。&lt;/h6&gt;
</description>
               <pubDate>Sun, 10 Mar 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/03/10/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-AI1.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/03/10/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-AI1.html</guid>
            </item>
        
            <item>
               <title>YOU CAN LIVE YOUR DREAM!</title>
               <description>&lt;p&gt;I don’t know what that dream is that you have.&lt;/p&gt;

&lt;p&gt;I don’t care how disappointing it might have been, as you’ve been working towards that dream.&lt;/p&gt;

&lt;p&gt;That the dream that you’re holding in your mind … that it’s possible.&lt;/p&gt;

&lt;p&gt;That some of you already know that its hard… it’s not easy. Its hard changing your life.&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;That in the process of working on your dreams you are going to incur a lot of disappointment … a lot of failure … a lot of pain … there are moments when you’re going to doubt yourself … and say “ God why? why is this happening to me? I’m just trying to take care of my children and my mother I’m not trying to steal or rob from anybody. How did this have to happen to me ?”&lt;/p&gt;

&lt;p&gt;For those of you that have experienced some hardships, don’t give up on your dream.&lt;/p&gt;

&lt;p&gt;There are rough times that are gonna come but they have not come to stay, they have come to pass.&lt;/p&gt;

&lt;p&gt;Greatness is not this wonderful esoteric, elusive, god like feature that only the special among us will ever taste … it’s something that truly exists in all of us.&lt;/p&gt;

&lt;p&gt;It’s very important for you to believe, that you are the one.&lt;/p&gt;

&lt;p&gt;Most people, they raise a family, they earn a living and then they die.&lt;/p&gt;

&lt;p&gt;They stop growing… they stop working on themselves, they stop stretching, they stop pushing themselves.&lt;/p&gt;

&lt;p&gt;And a lot of people like to complain but they don’t want to do anything about their situation, and most people don’t work on their dreams.&lt;/p&gt;

&lt;p&gt;why? One is because of fear, the fear of failure… “what if things don’t work out?” And the fear of success… “what if they do and I can’t handle it?”. These are not risk takers.&lt;/p&gt;

&lt;p&gt;You spend so much time with other people, you spend so much time trying to get people to like you, you know other people more than you know yourself, you study them… you know about them, you wanna hang out with them, you wanna be just like them.&lt;/p&gt;

&lt;p&gt;And you know what you’ve invested so much time into being like them you don’t know who you are, I challenge you to spend time by yourself.&lt;/p&gt;

&lt;p&gt;It’s necessary that you get the losers out of your life, if you want to live your dream.&lt;/p&gt;

&lt;p&gt;For people who are running towards their dreams, life has a special kind of meaning.&lt;/p&gt;

&lt;p&gt;When you become the right person, what you do is you start separating yourself from other people, you begin to have a certain uniqueness.&lt;/p&gt;

&lt;p&gt;As long as you follow other people and as long as you’re being a copy cat you will never ever be the best copy cat in the world. But you will be the best you can be.&lt;/p&gt;

&lt;p&gt;I challenge you to find your value. That everybody won’t see it, that everybody won’t join you, that everybody won’t have the vision, it’s necessary to know that. That you are an uncommon breed.&lt;/p&gt;

&lt;p&gt;It’s necessary that you align yourself with people and attract people into your business who are hungry.&lt;/p&gt;

&lt;p&gt;People who are unstoppable and unreasonable, people who are refusing to live life just as it is and who want more.&lt;/p&gt;

&lt;p&gt;The people that are living their dream are finding winners to attach themselves to. The people that are living their dreams, are the people that know that if it’s gonna happen it’s up to them.&lt;/p&gt;

&lt;p&gt;If you wanna be more successful, if you wanna do and have stuff that you have never had before, I’m asking you to invest in you.&lt;/p&gt;

&lt;p&gt;Someone’s opinion of you does not have to become your reality … that you don’t have to go through life being a victim. And even if you have to face disappointment, you have to know within yourself, I can do this even if no one else sees this in me I must see it for myself.&lt;/p&gt;

&lt;p&gt;Because you’re still talking about your dream … you’re still talking about your goal …you’ve not done anything … just take the first step … you can touch millions of peoples ‘ lives … and the world will never be the same again … because you came this way.&lt;/p&gt;

&lt;p&gt;Don’t let nobody steal your dreams. If you face a rejection or a no, if you hold a meeting and nobody shows up, if someone says ” you can count on me ” and they don’t come through.&lt;/p&gt;

&lt;p&gt;What if we have that kind of attitude, a cause repossessed, nobody believes in you … you’ve lost again, and again, and again, the lights are cut off … but you’re still looking at your dream, renewing it every day and saying to yourself it’s not over… UNTIL I WIN !&lt;/p&gt;

&lt;p&gt;YOU CAN LIVE YOUR DREAM!&lt;/p&gt;

&lt;h3&gt;Copy from google&lt;/h3&gt;
</description>
               <pubDate>Tue, 19 Feb 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/02/19/you-can-live-your-dream.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/02/19/you-can-live-your-dream.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第一章，C#要点技术(六) 搜索算法</title>
               <description>&lt;h3&gt;搜索算法&lt;/h3&gt;

&lt;p&gt;广度优先搜索和深度优先搜索是最直接的搜索方式，但也效率最差，直接使用广度和深度算法，而不加以优化和改进，会浪费太多CPU，以至于整体效率差劲。&lt;/p&gt;

&lt;p&gt;好的搜索算法，大部分需要有数据结构的支撑，在数据结构里记录了信息的特征，搜索的记录，和当前搜索内容的环境，以达到裁剪优化的目的。&lt;/p&gt;

&lt;p&gt;搜索的目的一般有，一个数组中找出某元素，一个数组中找出某个范围的所有元素，一个2D或3D空间中找出某元素，2D或3D空间中找出某一个范围的所有元素，以及一堆相互连接的结构中找出两点的最短路径等等等。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h6&gt;二分查找算法&lt;/h6&gt;

&lt;p&gt;二分查找算法是搜索中用的最多，也是最简单易用的，效率也比较好。不过它有个先决条件，条件是查找的数组必须是有序的数组。&lt;/p&gt;

&lt;p&gt;也就是说，在使用二分算法查找前，必须对数组进行排序。而且在每次更改，插入，删除后都要进行排序以保证数组的有序状态。&lt;/p&gt;

&lt;p&gt;二分查找算法的步骤是：&lt;/p&gt;

&lt;p&gt;1，将数组分为三块，依次是前半部分，中间位，后半部分。&lt;/p&gt;

&lt;p&gt;2，将要查找的值和数组的中间位进行比较，若小于中间位则在前半部分查找，若大于中间位则在后半部分查找，等于中值时直接返回。&lt;/p&gt;

&lt;p&gt;3，下一个查找范围，跳入1步骤，依次进行递归过程，将当前的范围继续拆分成前半部分，后半部分，和中间位三部分，直到范围缩小到最小，如果还是没有找到，那说明元素并不在数组里面。&lt;/p&gt;

&lt;p&gt;二分查找的平均时间复杂度为O(logN)，算是一个比较好的时间复杂度了。不过前提是数组或序列是有序的，这个门槛比较高。&lt;/p&gt;

&lt;h6&gt;二叉树、二叉查找树、平衡二叉树、红黑树、B树&lt;/h6&gt;

&lt;p&gt;二叉树及其衍生的所有算法都是以节点有且只有至多两个节点为规则的，这种结构在一维数组上比较有效且容易理解。&lt;/p&gt;

&lt;p&gt;二叉查找树，在二叉树之上建立的查找树，主要目标是快速查找，它在构造时的特点是，左边的子节点一定比父节点小，右边的子节点一定比父节点大。算法的方式与二分查找算法有点类似，不一样在于，构建出来的树形结构，由于数据的排序不同有可能是深度很大的二叉树犹如直线连接的节点，因此它是个不稳定的查找方式，搜索的速度由构造元素的顺序决定，顺序不好，速度就不佳，不稳定。&lt;/p&gt;

&lt;p&gt;平衡二叉树，就是用来解决查找二叉树的问题的，它的规则是，父节点的左右两棵树的深度差的绝对值不能超过1，并且左右两棵子树叶同样遵循这个规则。二叉树的深度问题解决了，在查找时就不会出现不稳定的状况了。&lt;/p&gt;

&lt;p&gt;红黑树，就是实现平衡二叉树的算法，红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。&lt;/p&gt;

&lt;p&gt;红黑树虽然高效稳定，但实际项目中运用的还是少，首先算法复杂度高，普通的程序员还是要费点心思去研究的，时间成本、人力成本增加。另一方面，因为完全可以用“快速排序”+“二分查找”代替，效率一样而且更加稳定、简单、易用，如果使用优化后的快速排序效率时常会高于红黑树。至少在游戏项目中，是很难看到其应用场景的，但并不代表它没用，树形结构的好处就是有自带有更多的信息，节点中不止存放的是‘值’信息，还有很多与值相关与逻辑相关的数据可提供更好的服务。&lt;/p&gt;

&lt;p&gt;B树，是建立在平衡二叉查找树之上的，多叉树。它的节点上有多个值的，且多叉的，且平衡的，查找树。犹如在红黑树之上，建立了多叉的方式，并且比较方式由单一值比较，改为了多值比较。一个节点里的信息是个数组，且它们是有序的，可用二分查找比较和查找，找到中间节点继续往下搜索。&lt;/p&gt;

&lt;p&gt;B树会更快吗，从查找上来看与红黑树效率一样，从构建上来看，增加，删除会更复杂，算法上都是使用二分思想所以相差不多。其实B树在游戏里也很少能用到，因为能代替它的算法很多。不过它在文件存储结构上能发挥巨大作用，这也是它被发明的原因，包括B+和B*树都是从B树衍生而来。&lt;/p&gt;

&lt;h6&gt;无论用得到用不到，思考方式和思考角度是关键，知道了有这些多种角度的思考方式，在平时的算法编写时就有了更多的思路和想法，因为指不定什么时候就从这种思想角度里得出了你要的算法，毕竟需求和环境是多变的，我们需要找到适合的优秀的算法。&lt;/h6&gt;

&lt;h6&gt;四叉树搜索算法&lt;/h6&gt;

&lt;p&gt;四叉树搜索算法，有点像二叉树的多维度版本，有点类似一维数组上数组分成4块进行查找，但也仅限于此。&lt;/p&gt;

&lt;p&gt;四叉树的最重要的理念是空间划分，把一个二维空间划分成多个块来存放，它由树形结构支撑，每个点有四个子节点，这四个子节点代表父节点的四个象限区块，四个子节点加起来代表整个完整的父节点，以此类推下去，每个节点可以有子节点，一旦有就得四个一起有。&lt;/p&gt;

&lt;p&gt;在实际运用中，四叉树也是在2D平面空间上的搜索用的比较多，虽然其他领域也有用到，但在2D平面空间划分上更适合。我们可以把一个2D矩形平面想象成，一个分成相等四个大小的矩形，总共四块矩形方块，每块中又再次分成相等大小的四块，直到分到定义的最小块为止，每一块都有自己的父节点和子节点(除了最底部的节点)。&lt;/p&gt;

&lt;p&gt;当元素加入这个平面时，也就是加入到了这个四叉树的数据结构中去，从最大的四块开始依次往下推，一直到推到没有子区块的节点上，每个区块都有元素容量。当元素达到最大容量时，节点分裂。把需要搜索和查找的每个元素按这个步骤推入四个子节点。&lt;/p&gt;

&lt;p&gt;形成四叉树数据结构后，就可以根据这个数据结构进行查找元素了。比如，在某个位置上查找在相同块内的所有元素。给出坐标后，就能根据四叉树依次推下去最终找到没有子节点的那个节点，获取块上的所有信息。&lt;/p&gt;

&lt;p&gt;由于每次元素加入到四叉树时，在每个父节点都会留下相关的信息，所以在父节点上也能得到相关的信息列表。比如把地图分成3级，每一级四块矩形图上都存有相关元素的信息，可以快速得到1，2，3级地图上某块内的所有元素的信息。&lt;/p&gt;

&lt;p&gt;四叉树在游戏项目中的运用有，二维平面上的有效碰撞检测搜索范围，地形的有效展示范围，在地图上找人或事务或地点，在地图上找某范围的人或事务或地点，二维平面的寻路网格构建等。&lt;/p&gt;

&lt;h6&gt;由于四叉树的搜索是建立在元素不移动的状态下进行的，一旦移动就得进行先删除后再加入的操作，如果移动的操作比较频繁，效率将急剧下降。所以四叉树构建的搜索算法，不适合大量元素移动频繁的系统上。而对于那些固定或者说太变动的，如，地形，地块，网格，地点，物体，以及不动的人是比较有效的。&lt;/h6&gt;

&lt;h6&gt;八叉树搜索算法&lt;/h6&gt;

&lt;p&gt;八叉树与四叉树类似，但在理念上更关注三维空间上的划分。八叉树把一个立方体，纵向和横向各切一刀，分裂成八个相同大小的立方体，每个小立方体也就是子节点，也可以在适当的时候分裂成八个相同大小的小立方体，用树形结构表示每个大大小小的立方体形成了八叉树。&lt;/p&gt;

&lt;p&gt;经过树形结构构造，八叉树就很容易用在3D空间中的场景管理，可以很快地知道物体在3D场景中的位置，或测试与其它物体是否有碰撞以及是否在可视范围内。因此八叉树在实际游戏中用到的，有渲染中的渲染裁切，和物理引擎中的碰撞检测。&lt;/p&gt;

&lt;h6&gt;优秀的算法都是能找到事物特征并且利用好事物特征的算法，不同种类的算法有其自身的理念，混用或合用几个算法也是常有的事，理解和知晓是第一步，灵活运用真的不是一朝一夕的事，若非项目需要所驱动的算法研究通常也只是纸上谈兵，真搬上项目真刀实枪的干时，很多时候都是和底下读几篇文章、敲几个算法是完全两样的，所以我才常听到‘老兵们’常说的一句，适合的才是最好的，和交朋友、谈恋爱是一个道路。&lt;/h6&gt;
</description>
               <pubDate>Sun, 17 Feb 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/02/17/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-CSharp%E8%A6%81%E7%82%B9%E6%8A%80%E6%9C%AF6.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/02/17/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-CSharp%E8%A6%81%E7%82%B9%E6%8A%80%E6%9C%AF6.html</guid>
            </item>
        
            <item>
               <title>思路探讨(二十) 如何将你的家庭与普通人拉开差距</title>
               <description>&lt;p&gt;这个标题好刺激，说的好像很容易似的，假如拉开差距容易的话，也就不会在这里说了，我直接拉开了，还扯什么蛋。&lt;/p&gt;

&lt;h6&gt;实际上大部分人都知道怎么拉开差距，但知易行难啊，知道和执行是两码事。&lt;/h6&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;办法是，努力学习，努力工作，努力做人，努力保持健康。不可能是偷懒，投机，作弊，暴力，反社会。&lt;/p&gt;

&lt;p&gt;这属于正常思路的范畴。可是大部分人都不信啊，为什么不信，效果太慢，太枯燥乏味，需要5-10年甚至20年。于是他们一定要寻找另外一条路，从此踏上了寻找捷径的旅途。&lt;/p&gt;

&lt;p&gt;他们相信世界上有这么一条捷径，他们一定能找到，比别人用的时间少花的精力少就能夺得世界，不能夺得世界也能拥有自己一块领土，颐养天年。他们对这种想法的意志非常坚定。&lt;/p&gt;

&lt;p&gt;可是真的有么？弯弯绕，最后都要回到原地，回来后发现还是要按部就班得走，这时才发现差距已经拉开了。&lt;/p&gt;

&lt;p&gt;不可否认，有些人还真的是运气好到爆炸，真的被他找到一条路，通往世界的宝藏中心，财富和权利的交集处。&lt;/p&gt;

&lt;p&gt;但故事只是个开头，后面故事怎么发展，不能下定论，虽然我的观点是99%最后都灰飞烟灭了，但世界不会因为我怎么想而怎么走。&lt;/p&gt;

&lt;p&gt;无论如何，这个概率也是几十亿到几百亿分之一以下的概率，基本可以忽略不计，但人就是这样，永远认为自己会是那个幸运儿。&lt;/p&gt;

&lt;h6&gt;啊哈，看到没有，只要按正常人的正常思路走，就能击败大部分人，与普通人拉开差距。&lt;/h6&gt;

&lt;p&gt;为什么？因为普通人耐不住寂寞，受不了枯燥，行动不下去。&lt;/p&gt;

&lt;p&gt;那么真的有人能耐得住寂寞，受的了枯燥，沉着冷静吗？&lt;/p&gt;

&lt;p&gt;当然没有，别骗自己了，我们都是人，都是恒温动物，都有血有肉，都有感情，贪嗔痴慢疑一样不能少。&lt;/p&gt;

&lt;p&gt;每个人都是一样的，拥有完整的人性的弱点，谁都躲不过。&lt;/p&gt;

&lt;p&gt;一个拥有完整人性弱点的人，是不可能完完全全、彻彻底底反人性的。&lt;/p&gt;

&lt;p&gt;那什么样的人能够完完全全、彻彻底底反人性？疯子，神经病。无论什么原因病态彻底扰乱了人性的特点。&lt;/p&gt;

&lt;p&gt;我肯定不想成为疯子，我也意识到人性的弱点无法改变，但我又想抗拒人性弱点，怎么办？&lt;/p&gt;

&lt;h6&gt;1，在枯燥中寻找乐趣。不惜一切方式、方法，围绕目标消除枯燥，即使会暂时的退步，也是以退为进的一种战略战术。&lt;/h6&gt;

&lt;h6&gt;2，在痛苦中寻找欢乐。痛苦是必然的，疲惫也是必然的，要在痛苦中找到欢乐，在疲惫中找到精神支柱。就不会像表面上看起来那么苦了，虽然表面上还是苦的累的，但当事人心里却是甜的是兴奋的。&lt;/h6&gt;

&lt;h6&gt;3，迷茫时给自己打精神麻醉剂，告诉自己是金子总会发光的。不要忘了事业，财富，并不是直线向上的，而是一个波动的曲线。无论有多强大的心，生命中充斥着大部分的，都是失败。因此迷茫是必然的，而且大部分时候都在迷茫，真正看清前方道路的时间没几分钟，不一会又会再次陷入迷茫。不要在迷茫上浪费太多的时间，告诉自己是金子总会发光的，不要犹豫了，先冲上去拨开云雾。&lt;/h6&gt;
</description>
               <pubDate>Mon, 04 Feb 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/02/04/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A820.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/02/04/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A820.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第一章，C#要点技术(五) 排序算法</title>
               <description>&lt;p&gt;年纪越大，写程序写的越多，时间越长，就越觉得算法的重要性，基础能力决定你到底能走多远。&lt;/p&gt;

&lt;p&gt;我们不是写一两年就完事的，从毕业算起，我们可能要写20-30年的程序，这段漫长的长跑路程中，最终比的不是谁熟悉API比较多，也不是谁用插件用的有多熟练，更不是比谁更熟悉某软件，而是比谁的算法能力强，比谁对底层结构更加熟知于心，比谁能够解决的系统复杂度有多高。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;算法能力非常重要，在程序生涯中，算法是基础能力，很多时候程序的好坏，一方面看的是写程序的经验，另一方面看的是对计算机原理的理解程度，还有一方面看的是对算法的运用到如何程度。&lt;/p&gt;

&lt;p&gt;算法能力不仅仅是表面的算法熟知度，更是种精神高度，对所有经过自己手的程序效率负责的精神高度。某一处的算法有可能运用的很好，但如果其他地方都用烂算法，对于整体程序效率来说其实也没什么用，效率依然很烂。&lt;/p&gt;

&lt;p&gt;在平时的编程时，做到时刻关注算法的效率是区分中、高水平的一个大的关键点。&lt;/p&gt;

&lt;p&gt;其中排序和搜索算法最为常用。毫不夸张的说一个项目中有90%的算法都是排序和搜索算法，如果说我们把这90%的算法提高到一个很高效的程度，那么剩下的10%算法处理起来也没那么压力了。&lt;/p&gt;

&lt;h3&gt;快速排序算法&lt;/h3&gt;

&lt;p&gt;快速排序，也叫二分排序，是最最最常用，最最最好用，用的最最最多的排序算法。它的排序方式是：&lt;/p&gt;

&lt;p&gt;1.从序列中选一个元素作为基准元素&lt;/p&gt;

&lt;p&gt;2.把比基准元素小的元素移到基准元素的左边，把基准元素大的移到右边。&lt;/p&gt;

&lt;p&gt;3.对分开来的二个一大一小区块进行递归再筛选，对两个区块同样进行1、2的两个步骤处理。&lt;/p&gt;

&lt;p&gt;简单来说就是把一个区域的数字分成两半，一半比另一半大。然后继续对这两半做同样的操作。&lt;/p&gt;

&lt;p&gt;由于这是最常用的排序方法，几乎占据50%以上的排序算法编码量，所以我们要着重优化此算法，对大批量使用的算法和程序绝对不能忽视。&lt;/p&gt;

&lt;h3&gt;优化：&lt;/h3&gt;

&lt;h6&gt;1.随机选择中轴数&lt;/h6&gt;

&lt;p&gt;如果选中的数字不是中位数，而是一个比较偏左或者比较偏右的数字，那么排序的速度就会降低，比如选中的刚好是最大的或者最小的数字，左边完全没有数字可以排，而所有数字都在它的右边。&lt;/p&gt;

&lt;p&gt;我们肯定无法准确的找到中位数，但是我们可以随机一个列表上的元素来作为基准元素。&lt;/p&gt;

&lt;p&gt;随机是为了减小选到最大和最小值的概率，但随机也时常会选到坏的基准元素，实际上随机数并没有对排序提供多大的帮助。&lt;/p&gt;

&lt;h6&gt;2.三数取中&lt;/h6&gt;

&lt;p&gt;为了让选择的中轴数更加接近中位数，可以先选择头、中点、尾，三个数字先来次排序，把最小的放在头，中间的放在中，最大的放在尾。&lt;/p&gt;

&lt;p&gt;每次每个区间的头中尾的排序前都做这个操作，也就是说，每次排序前，中位数都不可能是最小的，起码是区间里第2小的或者第2大的，这样选出来的中轴数靠近中位数就的概率就大了。&lt;/p&gt;

&lt;p&gt;虽然可以把三个数扩大到M个数，但过多数字的选择就相当于多出了个一个排序算法，减慢的二分排序的效果。实际效果不如3个数字来的快。&lt;/p&gt;

&lt;p&gt;也可以用随机选取3个数字的方式来替代做选择，但实际上随机性并没有多大的帮助，况且伪随机数的计算也是需要消耗cpu的，而常用的头，中，尾的做法是选择接近中位数的比较有效的办法。&lt;/p&gt;

&lt;h6&gt;3，小区间使用插入排序&lt;/h6&gt;

&lt;p&gt;插入排序和二分排序一样都依赖于序列的有序性，如果是反序列效率最差，反之如果是有序序列效率最大。&lt;/p&gt;

&lt;p&gt;其中，插入排序当序列越长，效率越差，而短序列的排序效果则很好，序列长度在8左右。&lt;/p&gt;

&lt;p&gt;在排序中，当切分的区块小于等于8的个数时，就可以采用插入排序来替代二分排序，其他时候任然采用二分切割算法。&lt;/p&gt;

&lt;h6&gt;4，缩小分割范围，与中轴数相同的合并在一起&lt;/h6&gt;

&lt;p&gt;与中轴数相同的数可以立即合并到中轴数的位置，使得后面的分割范围变得小，范围越小，排序的速度越快。&lt;/p&gt;

&lt;p&gt;具体做法是，在二分比较中，当元素与中轴数相等时就移动到中轴数身边，移动完毕后，划分范围从中轴数变为最边上的相同元素的位置。&lt;/p&gt;

&lt;h6&gt;快速排序是最常用，使用范围最广的排序算法，铭记于心是有必要的。&lt;/h6&gt;

&lt;h3&gt;其他排序算法简要&lt;/h3&gt;

&lt;p&gt;其他排序虽然使用频率没有快速排序来的多，但提供了对解决问题的思路很有帮助。&lt;/p&gt;

&lt;p&gt;比如，桶排序，把所有的元素按一定大小范围分成N个组，对每个组进行快速排序，最终得到有序的数组，并且得到N个桶的记录，虽然第一次排序的速度不怎么样，但这N个桶的信息记录下来后对于后面的程序逻辑有非常大的帮助。比如我们需要进行模糊排序或模糊搜索，这种桶信息就会有很大帮助。&lt;/p&gt;

&lt;p&gt;又比如，堆排序，和快速排序一样用的是二分的方式，是一种近似完全二叉树的结构，速度上虽然没有快速排序来的快，但却能快速定位某元素，排序完成后，形成的有序最大堆或最小堆数据结构在后面程序逻辑需要插入新元素，找某元素时，效率比较高。&lt;/p&gt;

&lt;p&gt;再比如，基数排序，是针对元素的特性来实时的‘分配式排序’，利用数字的特性按个位数，十位数，百位数的性质放入0-9的桶中不用排序，几次合并后直接就是有序数组，利用元素特性排序的速度比任何其他排序方式都要快速。这就教会我们，在运用算法时，首先要从元素的特性和环境着手，找到更合适更快的算法。&lt;/p&gt;

&lt;h6&gt;基本的、常用的几种排序算法是我们需要了解的，当我们面对需要解决的难题时，我们的思路就更为广阔，算法在实际运用中并不是固定的，适合的才是最好的，我们应该随着问题环境的变化而变化，找到最佳的突破口。&lt;/h6&gt;
</description>
               <pubDate>Sun, 03 Feb 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/02/03/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-CSharp%E8%A6%81%E7%82%B9%E6%8A%80%E6%9C%AF5.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/02/03/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-CSharp%E8%A6%81%E7%82%B9%E6%8A%80%E6%9C%AF5.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第一章，C#要点技术(四) 委托、事件、装箱、拆箱</title>
               <description>&lt;h3&gt;委托(delegate)与事件(Event)的实质&lt;/h3&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;使用过C或C++的同学都对指针很清楚，指针是个需要谨慎对待的东西，它不仅仅可以指向变量的地址，还可以指向函数的地址，本质上它是指向内存的地址。&lt;/p&gt;

&lt;p&gt;在C#中，万物接是类，大部分时间里都没有指针的身影，因为指针被封闭在内部函数当中。可是回调函数却依然存在，它是以委托的方式来完成的。委托可以被视为一个更高级的指针，它不仅仅能把地址指向另一个函数，而且还能传递参数，返回值等多个信息。系统还为委托对象自动生成了同步、异步的调用方式，开发人员使用 BeginInvoke、EndInvoke 方法就可以抛开 Thread类 而直接使用多线程调用。&lt;/p&gt;

&lt;p&gt;创建委托其实就是创建了一个delegate类实例，创建委托时就相当于这个类继承了System.MulticastDelegate类，类实例里有，BeginInvoke、EndInvoke、Invoke三个函数，分别表示，异步开始调用，结束调用，直接调用。&lt;/p&gt;

&lt;p&gt;不过我们不能直接写个类来继承System.MulticastDelegate类，因为它不能被继承在明文上，它的父类Delegate类也同样有这个规则，官方文档中写的就是这么个规则：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    MulticastDelegate is a special class. Compilers and other tools can derive from this class, but you cannot derive from it explicitly. The same is true of the Delegate class.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;delegate类中有个变量是用来存储函数地址的，当变量操作 =(等号) 时，把函数地址赋值给变量存起来。不过这个存储函数地址的变量是个可变数组，你可以认为是个链表，每次直接赋值时会换一个链表。&lt;/p&gt;

&lt;p&gt;委托类还重写了 +=，-= 操作符，其实就是对应 MulticastDelegate 的 Combine 和 Remove 方法，当对函数操作 += 和 -= 时，相当于把函数地址推入了链表尾部，和移出了链表。&lt;/p&gt;

&lt;p&gt;当委托被调用时，委托实例会把所有链表里的函数依次按顺序用传进来的参数调用一遍。官方文档中写的就是如上述所说：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;A MulticastDelegate has a linked list of delegates, called an invocation list, consisting of one or more elements. When a multicast delegate is invoked, the delegates in the invocation list are called synchronously in the order in which they appear. If an error occurs during execution of the list then an exception is thrown.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以说，delegate关键字其实只是个修饰用的单词，背后都是由C#编译器来重写代码的，就相当于在编译时把delegate这一句换掉，变成class并继承System.MulticastDelegate的类。&lt;/p&gt;

&lt;p&gt;那么什么是event？&lt;/p&gt;

&lt;p&gt;event 很简单，它在委托delegate上，又做了一次封装，这次封装的意义是，限制用户直接操作委托变量的权限。&lt;/p&gt;

&lt;p&gt;封装后，用户不再能够直接用赋值(=等号操作符)操作来改变委托变量了，只能通过注册或者注销委托的方法来改变委托变量。也就是说被event声明的委托不再提供‘=’的操作符，但仍然有 += 和 -= 的操作符可供操作。&lt;/p&gt;

&lt;p&gt;为什么要限制？&lt;/p&gt;

&lt;p&gt;因为公开的委托会直接暴露在外，随时会被‘=’赋值而清空了前面累积起来的委托链表，造成不可预测的问题。申明 event 后，编译器内部重新封装了委托，让暴露在外面的委托不再担心随时被清空和重置的危险了。因为经过 event 封装后不再提供赋值操作来清空前面的累加，只能一个个注册或者一个个注销委托(或者说函数地址)。&lt;/p&gt;

&lt;h3&gt;装箱和拆箱&lt;/h3&gt;

&lt;p&gt;什么是装箱和拆箱。&lt;/p&gt;

&lt;p&gt;很简单，把值类型实例转换为引用类型实例，就是装箱。&lt;/p&gt;

&lt;p&gt;相反，把引用类型实例转换为值类型实例，就是拆箱。&lt;/p&gt;

&lt;p&gt;再简单点：&lt;/p&gt;

&lt;p&gt;int a = 5;&lt;/p&gt;

&lt;p&gt;object obj = a;&lt;/p&gt;

&lt;p&gt;就是装箱&lt;/p&gt;

&lt;p&gt;继续上面代码&lt;/p&gt;

&lt;p&gt;a = (int)obj;&lt;/p&gt;

&lt;p&gt;就是拆箱。&lt;/p&gt;

&lt;h6&gt;为何需要装箱。&lt;/h6&gt;

&lt;p&gt;值类型是在栈中分配内存，在声明时初始化才能使用，不能为null。 &lt;/p&gt;

&lt;p&gt;引用类型在堆中分配内存，初始化时默认为null。 &lt;/p&gt;

&lt;p&gt;值类型有，所有整数，浮点数，bool，以及 Struct 申明的结构&lt;/p&gt;

&lt;p&gt;引用类型有，类，接口，委托(委托也是类)，数组以及内置的object与string。&lt;/p&gt;

&lt;p&gt;这里又引申出来，为什么要分栈内存和堆内存，简单快速阐述下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    栈是本着先进后出的数据结构(LIFO)原则的存储机制, 对栈数据的定位比较快速, 而堆则是随机分配的空间, 处理的数据比较多, 无论如何, 至少要两次定位。堆内存的创建和删除节点的时间复杂度是O(logn)。栈创建和删除的时间复杂度则是O(1)，栈速度更快。

    既然栈速度这么快，全部用栈不就好了。这又涉及到生命周期问题，由于栈中的生命周期是必须确定的，创建后什么时候销毁是一个定量，所以在分配和销毁时不灵活，相反堆内存可以存放生命周期不确定的内存块，满足当需要删除时再删除的需求，所以堆内存相对于引用类型的内存块更适合。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此在当栈内存和堆内存相互转换时，有了装箱和拆箱的过程。大部分时候只有当程序、逻辑或接口需要更加通用的时候才会需要装箱。&lt;/p&gt;

&lt;p&gt;比如调用一个含类型为object的参数的方法，该object可支持任意为型，以便通用。当你需要将一个值类型(如Int32)传入时，就需要装箱。&lt;/p&gt;

&lt;p&gt;又比如一个非泛型的容器，同样是为了保证通用，而将元素类型定义为object。于是，要将值类型数据加入容器时，需要装箱。&lt;/p&gt;

&lt;p&gt;我们来看看装箱的内部操作。&lt;/p&gt;

&lt;p&gt;装箱： 对值类型在堆中分配一个对象实例，并将该值复制到新的对象中。按三步进行。 &lt;/p&gt;

&lt;p&gt;第一步：在堆内存中新分配一个内存块(大小为值类型实例大小加上一个方法表指针和一个SyncBlockIndex)。 &lt;/p&gt;

&lt;p&gt;第二步：将值类型的实例字段拷贝到新分配的内存块中。 &lt;/p&gt;

&lt;p&gt;第三步：返回内存堆中新分配对象的地址。这个地址就是一个指向对象的引用了。 &lt;/p&gt;

&lt;p&gt;拆箱：检查对象实例，确保它是给定值类型的一个装箱值。将该值从实例复制到值类型变量中。&lt;/p&gt;

&lt;h6&gt;装箱、拆箱对执行效率有哪些影响，如何优化。&lt;/h6&gt;

&lt;p&gt;由于装箱、拆箱时生成的是全新的对象，不断得分配内存会有时间损耗和CPU的消耗，降低性能。 那该如何做呢？&lt;/p&gt;

&lt;p&gt;这里提到的拆装箱优化，都是针对 Struct 结构类型的，由于整数、浮点数、布尔等数值型变量的变化手段很少，变不出什么花花来，但 Struct 不一样，它既是值类型存放在栈内存上，又可以像类一样继承，用途多，转换的途径多，可变的花花也多。稍不留神，花花就变成了麻烦，所以这里重点讲的是 Struct 变出花花后的优化方法。&lt;/p&gt;

&lt;p&gt;1、Struct 通过重载函数来避免拆箱、装箱。&lt;/p&gt;

&lt;p&gt;比如常用的ToString()，GetType()方法，如果 Struct 没有写重载ToString()和GetType()的方法，就会在 Struct 实例调用它们时先装箱再调用，导致内存块重新分配性能损耗。所以对于那些需要调用的引用方法，必须重载。&lt;/p&gt;

&lt;p&gt;2、通过泛型来避免拆箱、装箱。&lt;/p&gt;

&lt;p&gt;不要忘了 Struct 也是可以继承的，在不同的、相似的、父子关系的 Struct 之间可以用泛型来传递参数，这样就不用装箱后再传递了。&lt;/p&gt;

&lt;p&gt;比如B,C继承A，就可以有这个泛型方法 void Test&lt;T&gt;(T t) where T:A，以避免使用object引用类型形式传递参数。&lt;/p&gt;

&lt;p&gt;3、通过继承统一的接口提前拆箱、装箱，避免多次重复拆箱、装箱。&lt;/p&gt;

&lt;p&gt;多种 Struct 继承接口后，不同的 Struct 就可以有相同的接口了。把 Struct 传递到其他方法里去时就相当于提前进行了装箱操作，在方法中得到的是引用类型的值，并且有它需要的接口，避免了在方法中重复多次的拆装箱操作。&lt;/p&gt;

&lt;p&gt;比如 Struct A 和 Struct B 都继承接口 I，void Test(I i)。当调用Test方法时传进去的 Struct A 或 Struct B 的实例都相当于提前做了装箱操作，Test里拿到的参数就不用再担心装箱拆箱问题了。&lt;/p&gt;
</description>
               <pubDate>Sat, 26 Jan 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/01/26/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-CSharp%E8%A6%81%E7%82%B9%E6%8A%80%E6%9C%AF4.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/01/26/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-CSharp%E8%A6%81%E7%82%B9%E6%8A%80%E6%9C%AF4.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第一章，C#要点技术(三) 浮点数的精度问题</title>
               <description>&lt;p&gt;直接开门见山了。&lt;/p&gt;

&lt;h3&gt;浮点数的精度问题&lt;/h3&gt;

&lt;p&gt;平常极少使用double类型，因为浮点数计算我们也并没有使用到特别的科学计算部分，所以float基本都够用，而且double也同样有精度问题，无论怎么样都是无法避免精度问题在项目里的危害的。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;float 与 double 比较来看，占用的位数不同会导致精度不同，但也会引起计算效率不同，内存消耗也不一样，虽然在现代计算机中来看，对double的计算量和占用的内存量已经不太在意了，在单片机中会有所限制，手机设备中是肯定没有限制的，不过无论怎么样它都是无法避免精度问题。&lt;/p&gt;

&lt;p&gt;实际工作中想试图通过使用double替换float来解决精度问题的人数众多，最后基本都以失败告终。&lt;/p&gt;

&lt;p&gt;要认清精度这个问题的根源，我们先来看下浮点数在内存中到底是如何存储的。&lt;/p&gt;

&lt;p&gt;计算机只认识 0 和 1，所以数值都是以二进制的方式储存在内存中的。根据 IEEE 754 标准，任意一个二进制浮点数 V 均可表示为：V = (-1 ^ s) * M * (2 ^ e)。&lt;/p&gt;

&lt;p&gt;以 198903.19(10) 为例，&lt;/p&gt;

&lt;p&gt;先转成二进制的数值为：110000100011110111.0011000010100011(2)（截取 16 位小数），&lt;/p&gt;

&lt;p&gt;采用科学记数法等于 1.100001000111101110011000010100011 * (2 ^ 17)（整数位是 1），&lt;/p&gt;

&lt;p&gt;即 198903.19(10) = (-1 ^ 0) * 1.100001000111101110011000010100011 * (2 ^ 17)。&lt;/p&gt;

&lt;p&gt;整数部分可采用 &amp;quot;除2取余法&amp;quot;，小数部分可采用 &amp;quot;乘2取整法&amp;quot;。&lt;/p&gt;

&lt;p&gt;从结果可以看出，小数部分 0.19 转为二进制后，小数位数超过 16 位（已经手算到小数点后 32 位都还没算完，其实这个位数是无穷尽的）。&lt;/p&gt;

&lt;p&gt;由于无法得到完全精准正确的数值，所以浮点数在程序编程中就会遇到诸多的问题。&lt;/p&gt;

&lt;h6&gt;浮点数的精度问题，可不只是小数点的精度问题哦，当浮点数变大时，在整数部分也同样会有相同的问题，因为浮点数是一个X * Y的形式得到的数字，当数字放大时自然精度就会变小，无论是整数位还是小数位。&lt;/h6&gt;

&lt;p&gt;精度问题看起来好像很难碰到，但实际开发中碰到了很头疼。&lt;/p&gt;

&lt;p&gt;那么到底哪些地方会碰到？&lt;/p&gt;

&lt;h6&gt;1.数值比较不相等&lt;/h6&gt;

&lt;p&gt;比如某个变量，需要从0开始加，每次加0.01，加到刚好0.23时做某事，到0.34时做另外一件事，到0.56时再做另一件。&lt;/p&gt;

&lt;p&gt;这种精确定位的问题，就会遇到麻烦。因为浮点数在加减乘数时无法完全准确定位到某个值，就会在出现，要么比0.23小，要么比0.23大，永远不会刚刚与0.23相等的时候。&lt;/p&gt;

&lt;p&gt;因此比较时，需要有一个微小的浮动区间。比如 ABS(X-Y) &amp;lt; 0.0001 时认为 X 和 Y 是相等的。&lt;/p&gt;

&lt;h6&gt;2.数值计算不确定&lt;/h6&gt;

&lt;p&gt;比如 x = 1f，y = 2f，z = 1 * 2f，如果 x / y &amp;lt;= 0.5f 时做某事，那么理论上说 x / z 也能通过这个if，但实际上未必能通过。&lt;/p&gt;

&lt;p&gt;由于浮点数无法得到精确的数值而是一个浮动的数值。z 的计算结果有可能是0.4999999999991，当x / z 时，结果有可能得到大于0.5。&lt;/p&gt;

&lt;p&gt;这就很头疼了啊。在实际编码中，如果在外圈的if判断成立，而内圈的if判断却有可能不成立，整个程序就出现无法估计得问题，因为看起来同样的数值，可能得到的结果却不一样。&lt;/p&gt;

&lt;p&gt;这种情况下怎么办？&lt;/p&gt;

&lt;h6&gt;第一种解决方法是，只计算一次，认定这个值为准确值，只用这个变量结果做判断。&lt;/h6&gt;

&lt;p&gt;意识是说，用一次计算的结果，当做唯一确定性结果，而不再使用多次计算得到的结果。排除了多次结果不同导致的问题。&lt;/p&gt;

&lt;p&gt;由于多次看似相等的计算其实得到的结果有可能不同，使得问题变得更复杂，比如上面所说的，1f / 2f 的结果，却用 1f / (1f * 2f) 来表示导致问题变得不可控。不如只使用一次计算结果，不再进行多次计算，认定当前结果的数值为准确数值，用这个浮点数值当做判断的标准。&lt;/p&gt;

&lt;p&gt;我常用这种方法，因为其他方法涉及的代码量太多，情况也分不同种，限制太多，而项目需要快速推进，当前遗留的不是很重要的问题，完全可以推延到整体架构完成后，一步步细化，在前期的解决方案中，在考虑完整体架构的安全，负载能力，扩展能力，性能可优化性后，完全可以采用一些相对比较简单的解决方案，以快速达到前期的目标。&lt;/p&gt;

&lt;h6&gt;第二种解决办法是，改用int或long型来替代浮点数。&lt;/h6&gt;

&lt;p&gt;浮点数和整数的计算方式都是一样的，只是小数点部分不同而已，那么完全可以把浮点数乘以10的幂次，把自己需要的精度提上来用整数表示。&lt;/p&gt;

&lt;p&gt;比如保留3位精度，所有浮点数都乘以1万来存储(因为第四位不是很准确了)，1.5变成了15000的整数，9.9变成了99000整数存储。&lt;/p&gt;

&lt;p&gt;这样整数 15000 乘以 99000 得到的结果，与，整数30000 除以 2 再乘以 99000 得到的结果是完完全全相等的。&lt;/p&gt;

&lt;p&gt;再复杂点 原来 2.5 / 3.1 * 5.1 与 0.8064 * 5.1，两者约等于为 4.1126，用整数替代，2500 / 31 * 51 与 80 * 51，等于 4080，虽然精度出现问题，但前两者结果不一致，而后两者结果完全相同。&lt;/p&gt;

&lt;p&gt;用整数做计算精度问题，我们可以再扩大数值的幂次么，来看看，如果是 250000 / 31 * 51 就等于 411290，是不是精度提高了啊。&lt;/p&gt;

&lt;p&gt;但问题又来了，乘以10的幂次来提高精度时，当浮点数比较大时，就会超出了整数的最大上线2 ^ 32 - 1或者2 ^ 64 - 1。&lt;/p&gt;

&lt;h6&gt;第三种解决方法是，用字符串替代浮点数。&lt;/h6&gt;

&lt;p&gt;如果浮点数用途只有加减乘数，那么完全可以用字符串代替浮点数来计算结果。&lt;/p&gt;

&lt;p&gt;我记得以前在大学里做ACM题目时，就有这种方式来检验程序员的逻辑能力和考虑问题的全面性的题目，题目很简单A * B 或 A - B 或 A + B 或 A / B 输出结果，精度要求在小数点后10位。&lt;/p&gt;

&lt;p&gt;把中小学算术的计算方式，写入到程序里去，用整数计算当前位置的算算术问题，这样整数就完全不需要担心越界问题，而且能自由的控制精度。&lt;/p&gt;

&lt;p&gt;缺点是，很消耗CPU，比如123456.78912345 * 456789.2345678，这种类型的计算使用字符串代替浮点数，用一次相当于计算好几万次的普通浮点数计算。但是如果程序中对精度要求很高，且计算的次数不大，我觉得还是可以把这种方式放在考虑范围内的。&lt;/p&gt;

&lt;h6&gt;第四种解决办法是，提高期望值。&lt;/h6&gt;

&lt;p&gt;如果 10000 / 2 有可能等于 4999.9999 而无法达到5000的目标值时，我们不妨在计算前多加个1，使得 10001 / 2，这样就大概率保证超出 5000 的结果目标了。&lt;/p&gt;

&lt;p&gt;我们怎么想的？为什么能这么做？因为我们做了假设。&lt;/p&gt;

&lt;p&gt;我们脑袋中假设结果是模糊的，这个结果范围就是有可能是5000.0001，也有可能是5000.02，也有可能是4999.998，也有可能是4999.98。&lt;/p&gt;

&lt;p&gt;正常情况下，由计算机的寄存器和CPU决定到底会得到什么结果。但我们不想，我们的期望是，宁愿高一点点，跨过这道门槛，也不要少一点点，被门槛拦在外面。&lt;/p&gt;

&lt;p&gt;如果浮点数的精度不能给我们安全感，那么我们就自己给自己安全感。提高自己的数值，或者说，降低门槛，差不多了就差一点点了，就当做是跨过去了。&lt;/p&gt;

&lt;p&gt;于是就有了 (X + 1) / Y 或者 (X + 0.001) * Y 的写法来度过&amp;#39;精度危机&amp;#39;。&lt;/p&gt;
</description>
               <pubDate>Sat, 19 Jan 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/01/19/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-CSharp%E8%A6%81%E7%82%B9%E6%8A%80%E6%9C%AF3.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/01/19/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-CSharp%E8%A6%81%E7%82%B9%E6%8A%80%E6%9C%AF3.html</guid>
            </item>
        
    </channel>
</rss>