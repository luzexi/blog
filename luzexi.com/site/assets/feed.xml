<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title></title>
        <description>漫漫人生,记录点滴技术,始于2013</description>
        <link>http://www.luzexi.com</link>
        <atom:link href="http://www.luzexi.com/assets/feed.xml" rel="self" type="application/rss+xml" />
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(三) - 渲染原理与知识2</title>
               <description>&lt;p&gt;这节我们将继续补充前面渲染管线中没有讲到的渲染知识和原理。&lt;/p&gt;

&lt;h3&gt;Filter 滤波方式&lt;/h3&gt;

&lt;p&gt;Filter滤波其实在图形引擎中被用到的地方有很多，我们在做项目时却很少察觉到，它的重要性不容忽视。Filter 滤波到底是什么呢？下面我们来讲讲它的来龙去脉。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;一张纹理贴图可以是线性的，正方形的，长方形，甚至三维形式的，当它们被映射到网格表面，再变换到屏幕坐标系之后，纹理上的独立纹素(纹素)几乎不可能直接和屏幕上的最终画面像素直接对应起来。为什么呢？&lt;/p&gt;

&lt;p&gt;因为屏幕上的物体可能是放大后的效果，或者离摄像机很近导致物体需要被放大在屏幕上，这样就导致是屏幕上的一个像素只是对应纹理贴图上一个纹素的一部分（因为被放大了），或者也有可能物体被缩小了，或者离摄像机很远，这时一个像素可能包含很多纹素（因为被缩小了）。因此一个纹素与一个像素通常都是无法一一对应的。&lt;/p&gt;

&lt;p&gt;无论哪种情况我们都无法精确的知道应该使用哪些纹素值，以及如何对它们求平均值或插值。OpenGL就为我们提高了多种Filter 滤波方式，不同的滤波方式在速度和画质上做出了不同的权衡。&lt;/p&gt;

&lt;p&gt;滤波一般分两种，一种是最近采样即Nearest，一种是线性采样即Linear。在Unity3D中Point类型的采样就是最近采样(Nearest Point Sampling)，线性采样在Unity3D中又分为双线性采样(Bilinear)和三线性采样(Trilinear)。&lt;/p&gt;

&lt;p&gt;最近采样，即当纹素与像素大小不一致时，取最接近的纹素进行采样。虽然使用了Mipmap技术，但像素点与纹素仍然没有得到很好的匹配，所以这种方法在纹理需要进行放大或缩小时，结果会变形难看。于是就有了更好的双线性采样算法。&lt;/p&gt;

&lt;p&gt;双线性采样，是取离纹素最近的4个纹素，取得的纹素与中心点的纹素的距离就是参与计算的权重值，把所有采样得到的纹素进行加权平均后得到最终的像素颜色。&lt;/p&gt;

&lt;p&gt;双线性过滤是怎么计算的这4个纹素呢？假设源图像大小为m x n，目标图像为a x b。那么两幅图像的边长比分别为：m/a和n/b。目标图像的第（i,j）个像素点（i行j列）可以通过边长比对应到源图像。其对应坐标应该为（i&lt;em&gt;m/a,j&lt;/em&gt;n/b）。显然这个对应坐标一般来说不是整数，而非整数的坐标是无法在图像中使用。双线性插值通过寻找距离这个对应坐标最近的四个像素点，来计算该点的像素值。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    映射点计算方法:

    srcX=dstX* (srcWidth/dstWidth)+0.5*(srcWidth/dstWidth-1)

    srcY=dstY* (srcWidth/dstWidth)+0.5*(srcWidth/dstWidth-1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/book/7/g1.png&quot; alt=&quot;双线性过滤&quot;&gt;&lt;/p&gt;

&lt;p&gt;双线性过滤像素之间的过渡更加平滑，但是它只作用于一个MipMap Level,它选取纹素和像素之间大小最接近的那一层MipMap进行采样。当和像素大小匹配的纹素大小在两层Mipmap Level之间时，双线性过滤在有些情况效果就不太好。于是就有了三线性过滤。&lt;/p&gt;

&lt;p&gt;三线性过滤以双线性过滤为基础。对像素大小与纹素大小最接近的两层Mipmap Level分别再进行一次双线性过滤，然后再对两层得到的结果进行线性插值。&lt;/p&gt;

&lt;p&gt;上面的几种线性过滤外，还有各向异性过滤(Anisotropic Filtering)。什么是各向异性和同性呢：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    各向同性，当需要贴图的三维表面平行于屏幕就是各向同性。

    各向异性，当要贴图的三维表面与屏幕有一定角度的倾斜则是各向异性。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;各向异性过滤，除了会把Mipmap因素考虑进去外，还会把纹理与屏幕空间的角度这个因素考虑时去。它会考滤一个像素对应到纹理空间中在u和v方向上与u和v的比例关系，如果u:v不是1:1时，将会按比例在各方向上采样不同数量的点来计算最终的结果。&lt;/p&gt;

&lt;p&gt;各向异性采样的多少取决于Anisotropic Filtering的X值，所以在Unity3D的纹理图片设置上有一个Aniso Level的设置选项，用来设置Anisotropic Filtering的级别。&lt;/p&gt;

&lt;p&gt;采样方式从，最近采样，到双线性过滤，到三线性过滤，再到各向异性过滤，采样次数一级级提高，最近采样1次，双线性采样4次，三线性采样8次，各向异性采样随着等级不同各有不同，效果也是一级级的提高，随着采样次数的提高需要消耗的GPU也会逐级提高(这些都是在OpenGL或DirectX中完成的)，因此我们在设置图片过滤时需要权衡画质与性能。&lt;/p&gt;

&lt;h3&gt;光照阴影是如何生成的&lt;/h3&gt;

&lt;p&gt;前面讲了很多关于Mipmap和纹理采样的知识，对Mipmap和纹理采样的理解对底层画面渲染的理解有很大的帮助。这些所讲的内容也同样具有重大意义，阴影涉及到实际生活中的知识在渲染中是如何模拟的，让原本虚拟的计算机画面更加拟真现实生活。&lt;/p&gt;

&lt;p&gt;为了能让场景和人物看起来更加真实，光影效果是不可或缺的。我们经常能在画面中看到阴影跟随着物体摆动而变动，并且物体被光照遮挡的阴影投射在其他物体上，这样的效果十分动人，那么阴影是如何产生的呢？我们来细致的解析一下，通过解析我们能够更加深刻的理解阴影的生成原理，还可以通过对阴影原理的理解来有针对性的优化阴影对性能的消耗。&lt;/p&gt;

&lt;p&gt;我们可以首先考虑真实生活中阴影的产生流程，当一个光源发射一条光线遇到一个不透明物体时，这条光想不能再继续照亮它背后的物体。因此这个物体背后的物体就会产生阴影，这些阴影区域的产生是因为光线无法到达这些区域。&lt;/p&gt;

&lt;p&gt;在计算机的实时渲染中我们无法用表达出每条光照的射线，我们是如何做到阴影的投射的呢？&lt;/p&gt;

&lt;p&gt;其实可以很简单，假设，我们将摄像机放在光源的位置上，方向与光源照射的方向重合，那些看不到的地方就成了阴影产生的地方。不过，我们不可能真的将摄像机放在那里，但却可以用这种形式的方式，单独渲染一次在摄像机在该位置的图像。只有图像不行，我们需要的是阴影，刚好物体从该位置渲染出来的片元的深度值提供了我们需要的数据，将所有片元的深度值都写入深度缓存中后，我们就可以利用这个深度缓存做阴影的计算了，深度值越大的片元被遮挡的可能性越大，深度值最小的片元不会被遮挡。&lt;/p&gt;

&lt;p&gt;这就是阴影映射纹理(Shadow Map)技术，即在渲染中第一个渲染流程(pass)负责在光源点位置计算得到深度值，输出像素到阴影映射纹理(Shadow Map)。我们实质上得到是一张深度图，它记录了从该光源的位置出发，能看到的场景中距离它最近的表面位置的深度信息。&lt;/p&gt;

&lt;p&gt;只是这张阴影映射纹理对于我们人类来说不够直观，如果想要更好更直观的看到当前摄像机屏幕上的阴影图就更好了。屏幕空间的阴影投影技术(Screenspace Shadow Map)就产生了这种直观的效果，性能和效率也更高，不过它需要显卡支持MRT(Multiple Render Targets)，有些移动平台并不支持这种特性。&lt;/p&gt;

&lt;p&gt;当使用了屏幕空间阴影投射技术(Screenspace Shadow Map)时，Unity3D会让从光源出发的深度图与摄像机产生的深度图做比较，如果摄像机的深度图中记录的点的表面深度大于转化到光源出发生成的深度图的点的深度，那么就说明表面虽然是可见的但却处于该光源的阴影中。通过这样的方式，屏幕空间阴影投射技术(Screenspace Shadow Map)得到了当前摄像机屏幕空间中的阴影区域，即得到了当前摄像机屏幕的阴影图。&lt;/p&gt;

&lt;p&gt;到这里，我们已经得到了阴影映射纹理，不管是传统的阴影图还是屏幕空间阴影图，我们都可以根据这张阴影图来计算出投射到物体的阴影了，那么阴影图有了，应该怎么投射呢？&lt;/p&gt;

&lt;p&gt;主动计算投射到其他物体产生阴影是比较难的，但反过来，根据阴影图主动计算当前渲染物体上的片元是否被阴影是相对比较容易。我们会看到Unity3D在渲染物体上看到有生成阴影和接受阴影两个选项，即Cast Shadows 和 Receive Shadows。&lt;/p&gt;

&lt;p&gt;传统的接受阴影的方式，是将当前顶点的位置变换到光源点的空间下得到它在光源空间中的位置，再根据xy轴分量对阴影映射纹理(Shadow Map)进行采样，从而得到阴影映射纹理中该位置的深度值，如果这个深度值小于该顶点的深度值即z轴分量，那么说明该点位于阴影中，于是在片元颜色输出上加深阴影颜色，反之则没有被阴影遮盖。&lt;/p&gt;

&lt;p&gt;在屏幕空间阴影映射技术中(Screenspace Shadow Map)则可以更加方便一点，因为已经得到了当前摄像机整个屏幕的阴影图，不需要再进行额外的计算，只需要在当前屏幕位置对阴影图进行采样便能知道是否在阴影下，即将当前顶点坐标从模型空间变换到屏幕空间后使用这个坐标对阴影图进行采样即可。相对于传统的阴影渲染来说，屏幕空间阴影映射技术提高了更多的GPU性能效率。&lt;/p&gt;

&lt;p&gt;在Unity3D中使用 LightMode 为 ShadowCaster 的Pass标记为阴影生成管线。当Unity3D在渲染时会首先在当前Shader中找到LightMode为ShadowCaster的Pass，如果没有则会在Fallback指定的Shader中继续寻找，如果没有则无法产生阴影，无论传统的阴影投射还是屏幕空间阴影投射都需要第一步先产生阴影纹理图(Shadow Map)。当找到LightMode为ShadowCaster的Pass后，Unity3D会使用该Pass来制作光源的阴影映射纹理(Shadow Map)。&lt;/p&gt;

&lt;h3&gt;Lightmap烘培原理&lt;/h3&gt;

&lt;p&gt;随着硬件技术的发展，人们对场景的画质效果越来越高，实时光照早已经满足不了人们对画质的需求，想要更加细腻真实光照效果，只能通过离线的烘培技术才能达到理想画质的效果。&lt;/p&gt;

&lt;p&gt;全局光照，简称GI(Global Illumination)，是在真实的大自然中，光从太阳照射到物体和地面再经过无数次的反射和折射，使得地面的任何物体和地面都叠加着直接照射的光和许许多多物体反射过来的间接光(反射光)，导致我们从眼睛里看到画面是光亮又丰富的。&lt;/p&gt;

&lt;p&gt;这种无数次反射和折射形成的高质量画面，才是人们在3D游戏画面中真正想要看到的。但是即使今天硬件技术发展的如此迅速，也无法做到实时的进行全局光照(Realtime Global Illumination)，这样计算量太大，CPU和GPU都无法负担起这个重任。&lt;/p&gt;

&lt;p&gt;离线全局光照就担负起了这个丰富画面光照效果的重任，它不再需要这么多的实时计算的CPU和GPU算力，只要1张或几张光照图(Lightmap)就能将全局光照的效果复原到物体上，不过也仅限于场景静态物体的光照烘培。&lt;/p&gt;

&lt;p&gt;其实烘培这趟水很深，如果要具体深入到工程上的实现，涉及到的算法和图形学知识非常多，这里并不打算深究，而是讲讲我们能相对容易获得的关于Lightmap的原理和知识。根据这个原理，我们在项目的制作和优化中能起到很好的作用。&lt;/p&gt;

&lt;p&gt;什么是烘焙？个人认为从英文‘Bake’翻译过来有点偏差，导致很多工具按钮用‘Bake’表示时，很多人都同样把它理解成了烘培，其实更应该理解为‘制作’。&lt;/p&gt;

&lt;p&gt;烘培简单地说, 就是把物体光照的明暗信息保存到纹理上, 实时绘制时不再需要进行光照计算, 而是采用预先生成的光照纹理(Lightmap)来表示明暗效果。&lt;/p&gt;

&lt;p&gt;我们在渲染3D模型时用到的基本都是顶点，UV，纹理贴图等(这里不多展开)，在顶点上设置UV，形成片元后就成了顶点间的插值UV，用这个UV坐标去纹理贴图上取得颜色值，再填充到帧缓存中最后显示到画面上。&lt;/p&gt;

&lt;p&gt;光照纹理(Lightmap)的显示也是同样道理，用UV坐标来取得光照纹理(Lightmap)上的颜色，最后叠加到片元颜色上输出给缓存。&lt;/p&gt;

&lt;p&gt;这其中的UV有一点讲究。我们在制作模型时的UV数据可以有很多个，其中UV0主要是为了映射贴图纹理而用，在模型制作过程就在模型数据中制作好了，而UV1也就是我们程序中的uv2或俗称的2u，主要是为Lightmap做准备的，还有UV2即程序中的uv3，是为实时全局光照准备的，只有UV3即程序中的uv4开始才是我们程序可以自定义使用的UV数据，其实uv可以有很多个uv5，uv6，不过Unity3D的网格类(Mesh)暂时只提供到uv4的获取接口。&lt;/p&gt;

&lt;p&gt;既然光照纹理(Lightmap)存储的是光照信息，那么它到底存了哪些信息呢？我们先来看下这幅图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺图
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这幅图解释了烘培的简单模型，它分为三个部分，第一部分为光线射到墙壁后反射过来照到模型上，第二部分为光线照射过来时被其他模型挡住，导致当前的模型没有被光线照射到并且有阴影产生，第三部分为光线直接照射到模型上产生的颜色信息。&lt;/p&gt;

&lt;p&gt;这三者之和最终形成了完全的光照颜色。可以用一个简单的公式来说明这三者的结合方式：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    光照颜色 = 间接光照颜色 + 直接光照颜色 * 阴影系数(0到1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于直接光的计算代价比较少，在一些光照并不复杂的场景中不记录直接光信息，而是由Shader自己计算直接光照。因此我们能看到，很多项目并没有记录直接光，而只是记录间接光，即光照纹理中只记录了从其他物体反射过来的光产生颜色的总和，加上另一张阴影纹理记录产生阴影部位的信息。如果你希望记录在光照纹理中主要光的方向，则可以开启Directional Model的Directional来获得，这个文素上主要光的方向信息可以被用在Shader中作为计算的变量。&lt;/p&gt;

&lt;p&gt;现在我们知道了烘培(Bake)会最多产生3种贴图，一种是光照纹理图(可能是间接光照纹理图，也可能是间接光照+直接光照+阴影合并的纹理图，取决于你在Unity3D中Lighting Mode的设置)，一种是阴影纹理图，一种是主要光方向纹理图，以及模型的UV2数据。&lt;/p&gt;

&lt;p&gt;其中UV1(不是UV2，因为uv对应UV0，uv2对应UV1)会被加载到模型网格信息中去，也就是烘培后模型prefab的mesh.uv2的数据会被改写。因此我们在制作和导出模型时要注意，烘培需要用到模型的uv2数据，在导出模型时如果没有导出uv2数据，则无法得到正确的烘培。&lt;/p&gt;

&lt;h6&gt;那么烘培器是如何生成uv和贴图的呢？我们需要理解下UV Chart&lt;/h6&gt;

&lt;p&gt;在烘培时，烘培器会对所有场景中的静态物体上的Mesh网格进行扫描，按块大小和折线角度大小来制作和拆分Mesh上的对应的UV块，这个UV块就是UV Chart。&lt;/p&gt;

&lt;p&gt;UV Chart是静态物件在光照纹理(Lightmap)上某块Mesh的对应的UV区块，一个物体在烘培器预计算后会有很多个UV Chart。因此每个物件的UV Charts是由很多个UV Chart组成，每个UV Chart为一段连续的UV片段，UV Chart之间预留了0.5个像素的边缘来防止纹理的溢出。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/LightingGiUvs-2.png&quot; alt=&quot;UV Chart1&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    图1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/book/7/LightingGiUvs-4.png&quot; alt=&quot;UV Chart1&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    图2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/book/7/LightingGiUvs-0.png&quot; alt=&quot;UV Chart1&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    图3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中1描述了，当一个场景只有1个正方形物体时，这个正方体网格物体被烘培后，6个面上的UV Chart是如何映射到烘培纹理上的。图2描述了场景中当有多个简单的立方体时，每个物体被扫描后制成UV Chart的情况。图3描述了当烘培场景更加复杂时，扫描后UV Chart被制作的情况，不同规格的模型UV被映射到Lightmap纹理贴图上。&lt;/p&gt;

&lt;p&gt;我们很清晰的能从图中了解到，在烘培时，每个场景中的静态物体都会被扫描网格，并且将计算出来的UV Chart合起来制作成一张或几张(可能场景太大一张不够用)光照纹理贴图。&lt;/p&gt;

&lt;h6&gt;那么什么决定了烘培中扫描网格时形成的UV Chart大小和数量呢？相邻顶点间的最大简化距离和最大夹角值。&lt;/h6&gt;

&lt;p&gt;烘培器为了能更加快速的计算制作出UV Chart，烘培器需要对模型面的顶点扫描进行简化。简化方式为，将相邻顶点间距离小于某个数值的顶点归入一个UV Chart，当这个数值设置相对比较大时，UV Chart生成的速度就会加快。但是只是距离上的简化往往会出现很多问题，我们需要从相邻面的角度上进行约束，即当相邻面间的角度大于某个值时，不能简化成同一个UV Chart。这两个参数在Unity3D中都有设置，点击静态物体在右边的版面上就能看到。如图位置：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/LightingGiUvs-3.png&quot; alt=&quot;UV Chart1&quot;&gt;&lt;/p&gt;

&lt;p&gt;图中展示了静态物体Mesh Renderer中设置Lightmap UV生成参数，参数包括最大简化顶点距离，最大邻接面角度。&lt;/p&gt;

&lt;p&gt;当设置的最大简化距离和邻接面最大角度数值比较大时，计算生成UV Chart的数量就会比较少，相反如果设置的最大简化距离和最大邻接面角度比较少，则需要计算和生成的UV Chart会比较多，烘培的速度也会比较慢，因为在预计算实时全局光照(GI)时，每个UV Chart上的像素都会计算灯光，预计算的时间跟Chart的数量有很大关系。&lt;/p&gt;

&lt;h6&gt;上述描述了烘培的前置制作中Lightmap纹理分布和场景中物体的UV映射的原理，那么绘制Lightmap纹理贴图时纹理上颜色是怎么生成的呢？&lt;/h6&gt;

&lt;p&gt;我们知道如果不用烘培，在实时渲染中，因为算力的原因我们只能计算直接光对物体的明暗影响，如果想要在实时渲染中计算间接光的影响是非常消耗GPU的算力的，即使有足够强大的显卡支撑使用光线跟踪计算，也只能在带有RTX的显卡计算机上使用。暂时还没有做到普及的程度，因此离线烘培成了我们解决间接光的主要手段。&lt;/p&gt;

&lt;p&gt;在一个场景中如果这些物体只考虑直接光的影响，则会缺乏很多光影细节，导致视觉效果很“平”。而间接光则描述了光子在物体表面之间的反弹，增加了场景中明暗变化以及光线折射的细节，提高了真实感。&lt;/p&gt;

&lt;p&gt;光照纹理贴图的颜色主要是根据光的折射与反射现象来计算的，这里我们需要了解一下Unity3D中采用的Enlighten和Progressive Lightmapper算法解决方案。&lt;/p&gt;

&lt;p&gt;全局照明可以用一个称为渲染方程的复杂方程来描述：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/LightingGi-1.png&quot; alt=&quot;渲染方程&quot;&gt;&lt;/p&gt;

&lt;p&gt;这个渲染方程定义了光线是如何离开表面上某个点的。但是这个积分方程太复杂以至于无法快速计算出结果，Unity3D中Enlighten采用的近似方法即辐射算法，可以大大提高计算渲染方程式的速度。&lt;/p&gt;

&lt;p&gt;辐射算法假设了场景中存在一组有限的静态元素，以及仅有漫射光传输来简化计算。在计算过程中它把场景拆分成很细很细的面片，分别计算它们接受和发出的光能，逐次迭代直到每个面片的光能数据不再变化(或者到一定的阀值)为止，得到最终的光照图。&lt;/p&gt;

&lt;p&gt;场景拆分后的以及每个面片之间的作用，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/LightingGi-2.png&quot; alt=&quot;渲染方程&quot;&gt;&lt;/p&gt;

&lt;p&gt;Enlighten将场景切割成很多个面片我们称它们为Cluster(Cluster大小可以通过Unity3D的烘培设置数值大小)，这些Cluster会对其映射的静态物体的纹理中的反射系数进行采样，然后计算Cluster之间的关系，使得光在Cluster之间传递。&lt;/p&gt;

&lt;p&gt;Enlighten将渲染方程简化成了迭代公式即：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/LightingGi-3.png&quot; alt=&quot;渲染方程&quot;&gt;&lt;/p&gt;

&lt;h6&gt;其中Bi指的是在i点最终的光，Le是i点本身的光，而两个Cluster之间光的反弹系数有Fij来决定，Lj则是J点的光。这也是为什么Enlighten能够支持场景物体不变的情况下允许光源发生变化的原因：因为几何体素化和辐射系数计算代价比较大，需要离线计算，而迭代每个Cluster形成最终结果则计算量相对比较小可以实时进行。&lt;/h6&gt;

&lt;p&gt;Progressive Lightmapper即渐进式光照贴图，是Unity3D 2018版本后才能使用的烘培算法。&lt;/p&gt;

&lt;p&gt;Progressive Lightmapper是一种基于路径追踪（fast path-tracing-based）的光照贴图系统，它能在编辑器中逐步刷新的烘焙光照贴图（baked lightmaps）和光照探针（Light Probes）。&lt;/p&gt;

&lt;p&gt;Progressive Lightmapper主要的优势是能随着时间的推移逐步细化输出画面，及时逐步的看到画面效果，这样能够实现更完善的交互式照明工作流。另外Progressive Lightmapper还提供了一个预估的时间，所以烘焙时间更加可预测。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;p&gt;《Unity移动平台下的烘焙使用及优化》&lt;/p&gt;

&lt;p&gt;《浅析Unity中的Enlighten与混合光照》&lt;/p&gt;

&lt;p&gt;《Progressive CPU Lightmapper》&lt;/p&gt;

&lt;p&gt;《光照贴图Lightmap初探》&lt;/p&gt;

&lt;p&gt;《辐射度算法(radiosity)原理》&lt;/p&gt;
</description>
               <pubDate>Sat, 26 Oct 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/10/26/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A67.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/10/26/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A67.html</guid>
            </item>
        
            <item>
               <title>思路探讨(二十九) 有没有可能是我们理解错了</title>
               <description>&lt;h1&gt;有没有可能是我们理解错了&lt;/h1&gt;

&lt;p&gt;我经常这样问自己，有没有可能是我理解错了。有没有可能完全不是我理解的那么回事。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h6&gt;这个世界的真相总是在我们背后，但我们总认为自己的前方所见就是全世界。因此完全推翻自己的认知是有必要的。&lt;/h6&gt;

&lt;p&gt;“有没有可能是我们理解错了”，这个问题是来自于我们的反思，不过看起来似乎像是用好奇心来破解当前面对的困局。&lt;/p&gt;

&lt;h6&gt;当我们遇到困境，遇到疑惑，遇到迷茫时，不妨用好奇的口吻来表达我们渴望突破。&lt;/h6&gt;

&lt;p&gt;其实我们都是井底的那只蛙，我们弹跳力不够很难跳出这口井，就像我们无法用旁观者的角度看自己那样，在井中我们总是认为自己所思所想都是对的，以至于认为世界就是我们所认为的方式在运作。&lt;/p&gt;

&lt;p&gt;映射到实际生活中，比如像我一样的程序员编程技术工作者们，我们很难跳出这个技术视野去看事物。很多像我一样以为只要技术好就能升职加薪赢取白富美走上人生巅峰，这可能是程序员思维中最大的错误理解。因为我们身处在具体的工作细节中，这个具体工作本身就是那口井，我们无法跳出这口井去看外面的世界，就像我们无法用旁观者的角度看清问题的本质一样。&lt;/p&gt;

&lt;h6&gt;面对程序员的职业发展与事业道路，我对自己表达了好奇“有没可能是我理解错了”，我希望透过现象看本质。&lt;/h6&gt;

&lt;p&gt;就此我提出四个点来表达透过现象看到的本质：&lt;/p&gt;

&lt;h3&gt;技能可以用来打工，产品才能用来赚钱。&lt;/h3&gt;

&lt;p&gt;为什么说“只要技术好就能升职加薪赢取白富美走上人生巅峰”是错的呢？&lt;/p&gt;

&lt;p&gt;不是技术没用，而是只有技术还远远不够。口才和心理素质比技术有用的多。&lt;/p&gt;

&lt;p&gt;技术只不过是熟能生巧而已，可以理解为经验和知识在脑中的肌肉记忆。&lt;/p&gt;

&lt;p&gt;而口才是嘴巴和脸部肌肉的肌肉记忆，心理素质则是环境在脑中的肌肉记忆。&lt;/p&gt;

&lt;p&gt;只有这几个肌肉记忆联结起来才会产生实质性的效果。而产品其实就是这几个因素联结起来的结果。&lt;/p&gt;

&lt;p&gt;一个好的产品不只要有好的技术，还要有好的营销，好的运营，好的耐心和好的专注。&lt;/p&gt;

&lt;p&gt;如果只有技术，那就会什么都不是。&lt;/p&gt;

&lt;h3&gt;开源只是种学习的方式，并不能成为崛起财富的途径。&lt;/h3&gt;

&lt;p&gt;很多人都喜欢开源，因为他们弄不清目标，只是觉得开源很酷。&lt;/p&gt;

&lt;p&gt;开源是种精神，这种精神很多种，有的纯粹为了分享，虽然对世界有益，但对个人而言毫无益处。但有的开源就是为了锻炼自己，把自己的行为、希望、作品抛到全世界的平台上去让大家去检验去抨击你，（前提是这种行为是你这个领域一无所有或者投资太多关注太少的时候，如果你已经拥有很多，开源就会变成了一种浪费），那是真正对自己有益的行为。&lt;/p&gt;

&lt;h3&gt;技术驱动的企业必定失败，只有利益和市场才是财富的依靠。&lt;/h3&gt;

&lt;p&gt;世界上没有以技术为导向的公司，所有声称以技术导向的公司都死了，因为这并不符合市场的规律，不符合人类的天性。&lt;/p&gt;

&lt;p&gt;人类的天性是逐利的，技术并不能决定市场的逐利行为，技术不迎合市场一样遭遇淘汰。&lt;/p&gt;

&lt;h3&gt;市场是不道德的，遵循道德跟是否得到市场认可无关，但遵循道德可以让人安心踏实。&lt;/h3&gt;

&lt;p&gt;市场跟道德无关，很多现象看似不道德其实只是人们心里的偏见而已，其实并无他，即使站在道德的制高点也不会让市场回头。&lt;/p&gt;

&lt;p&gt;不过虽然道德跟很多逐利的事物无关，但跟人本身却有很大关系，它能让人安心踏实，人生在世，图的其实就是个安心，道德对人来说就是最好的抚慰剂，让人安心踏实。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;最后说说我自己。我有好奇的毛病，我想大多数人都和我一样，它时常让我陷入困境，比如我时常有奇思怪想，去体验一把没有体验过的人生旅途，最后发现没有人去体验不是因为他们不敢而是因为这条路体验很差或许还很受伤。不过好奇也同样时常让我豁然开朗，因为体验后自己就经历了比别人更多的遭遇，也有了更多人生体验和感悟。&lt;/p&gt;
</description>
               <pubDate>Sun, 13 Oct 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/10/13/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A829.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/10/13/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A829.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(三) - 渲染原理与知识1</title>
               <description>&lt;p&gt;前面的几篇非常详尽的讲述了渲染管线的整个流程以及渲染管线上的每个节点的来龙去脉。这节我们来说说，一些渲染概念和原理，以及上几章中对渲染管线上没有说到的细节，或者在现代GPU中已经被优化的流程。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h3&gt;为什么要有渲染顺序&lt;/h3&gt;

&lt;p&gt;前面章节中我们介绍了深度测试这个模块，它用片元的深度值与深度缓存中的值比较得到测试结果，再决定是否要写入深度缓存中，如果判断失败则抛弃片元不再继续下面的流程。这其中涉及到了 ZTest On/Off 状态开关，和，ZWrite On/Off 状态开关，其中ZTest 用于控制是否开启测试，ZWrite 用于控制是否写入深度缓存。&lt;/p&gt;

&lt;p&gt;渲染管线中的深度测试节点最大的好处是帮助我们尽早的发现不需要渲染的片元，并抛弃它们以节省GPU消耗提高效率。&lt;/p&gt;

&lt;p&gt;其实大部分情况下我们都使用 ZTest LEqual 做判断，即离摄像机越近的物体越容易遮挡住离得远的物体。&lt;/p&gt;

&lt;p&gt;从这个角度看渲染机制，如果能先把离屏幕近的物体放前面渲染，那么后面的物体虽然不能完全在CPU层面判定它是否被掩盖而剔除，但能在深度测试的机制下早早的抛弃掉很多片元，会提升不少的GPU效率。&lt;/p&gt;

&lt;p&gt;于是渲染顺序就成了关键，Unity3D引擎对所有不透明物体在渲染前做了排序工作，即离摄像机近的排在前面渲染，离的远的排在后面渲染，这个渲染队列又有了新的排序规则。&lt;/p&gt;

&lt;p&gt;那么半透明物体怎么办呢？因为半透明物体需要Blend混合，ZWrtie开关一般都是关的，因为如果开启来的话半透明部分在深度测试时就变成了完全的遮挡，从而没有了半透的效果。因此它需要在所有不透明物体渲染后再渲染才能真正发挥出它半透明的效果。&lt;/p&gt;

&lt;p&gt;在Unity3D引擎在提交渲染时增加了这么条规则，即对所有半透明物体的渲染都排在了不透明物体的后面，这样就确保了半透明物体能在不透明物体渲染完毕后才开始渲染，以保证半透明物体的渲染效果。&lt;/p&gt;

&lt;p&gt;那么怎么标记物体是不透明还是半透明呢，Unity3D引擎为了解决这个问题，将渲染顺序放在Shader中实现，即 Queue 标签来决定我们的模型将归于哪个渲染队列。&lt;/p&gt;

&lt;p&gt;Unity3D在内部使用了一系列整数索引来表示渲染的次序，且索引越小越表示排在前面被渲染。&lt;/p&gt;

&lt;p&gt;Queue 标签：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Background，索引号1000

    Geometry，索引号2000

    AlphaTest，索引号2450

    Transparent，索引号3000

    Overlay，索引号4000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Shader中我们选择任意Queue标签就会指定那个索引类型，Unity3D还有一个规则是2500以下的索引号，当多个物体拥有相同索引号时，排序规则以根据摄像机的距离由近到远顺序渲染，如果是2500索引号以上的包括2500，当多个物体拥有相同索引号时，则排序规则以根据摄像机的距离由远到近顺序渲染(与2500以下的物体相反)。&lt;/p&gt;

&lt;p&gt;为什么要这么排序呢？因为2500以下物体都是不透明物体，渲染在深度测试阶段越早剔除掉越好，所以对摄像机由近及远的渲染方式对早早的剔除不需要渲染的片元有莫大的帮助，提高GPU效率。而2500索引以上的物体，通常都是半透明物体或者置顶的物体(例如UI)，如果依然保持由近到远的渲染规则，半透明物体就无法混合被它覆盖的物体。因此2500索引及以后的物体与2500索引以前的物体，在相同索引号时渲染排序的规则是相反的。&lt;/p&gt;

&lt;p&gt;半透明的排序问题通常是头疼的，为什么呢？因为前面我们说的它是需要由blend混合完成半透明部分的操作，而blend操作必须在前面物体已经绘制好的条件下才能有blend混合后成为半透明或全透明效果。&lt;/p&gt;

&lt;p&gt;Queue在Transparent半透明索引号下，相同索引号是从远到近渲染的，在粗糙颗粒的排序上还是可以解决的，即两个物体模型没有相交部分，前后关系的blend混合是可以依靠模型中点离摄像机的远近做排序的，Unity3D引擎也是这么做的。但是如果两个物体相交，或者本物体中模型有前后叠加关系时则无法再区分片元的前后关系了。&lt;/p&gt;

&lt;p&gt;因此使用Blend混合做半透明物体，通常情况下很难做到前后关系有秩序，特别是当模型物体有交集的时候。而且通常都采用手动排序，例如在Queue上+1，即Tag{ Queue = &amp;quot;Transparent+1&amp;quot; } 的形式，这也是为什么很多特效Shader要有好几个一模一样Shader功能只是Queue不同。&lt;/p&gt;

&lt;p&gt;所有的渲染顺序都是引擎自主排列的，而不是由GPU排序的，GPU只知道渲染、测试、裁切，完全不会去管物体的前后次序，这也是为什么称它叫“流水线”的原因，它就像工厂里的作业流水线一样，每个工人都只是一个节点的螺丝钉，他们很多时候只要记住一个动作就可以“无脑”的重复劳动，GPU里也是一样。&lt;/p&gt;

&lt;h3&gt;Alpha Test&lt;/h3&gt;

&lt;p&gt;上面和前几章讲了好多关于半透明物体的知识，而Alpha Test其实也是属于半透明物体的特征，不过它不是混合，而是裁切。&lt;/p&gt;

&lt;p&gt;我们在制作模型过程中，很多模型的边角都需要极其细微的面片，比如树上的叶子，一堆乱糟糟的草，还有许许多多圆形的洞等，这些如果用网格模型来制作的话会多出很多很多面片，制作时间长，调整起来慢，同屏面数高，这些问题滚滚而来。&lt;/p&gt;

&lt;p&gt;怎么办呢，Alpha Test能很好的解决这些问题，Alpha Test 用纹理图片中的 Alpha 来测试判定该片元是否需要绘制，即当我们展示一些很细节的模型时，用一张图片和两三个面片就能代替巨量的面片制作方式。如果有需要调整的地方，也只是需要调整纹理图片和少量顶点就可以完成工作。&lt;/p&gt;

&lt;p&gt;这种方式被大量用在节省面片渲染数量上，因为它的制作简单，调整容易，被众多开发人员所喜爱。&lt;/p&gt;

&lt;p&gt;其渲染的过程也比较简单，在片元着色器中判断该片元 Alpha 值是否小于了某个阈值，一旦判定小于某个阈值就调用clip或者discard丢弃该片元，该片元流水线停止。&lt;/p&gt;

&lt;p&gt;我们来开如图所示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺图
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中这些小草都只是一个个面片，GPU在渲染片元时会先去判定该片元的 Alpha 是否小于某个阀值，如果小于则不渲染该片云，否则继续渲染。&lt;/p&gt;

&lt;p&gt;这种方式的裁剪片元对于只需要不透明和全透明的物体来说很好用，而且 Alpha Test 不需要混合，它完全可以开启 ZTest 的深度测试，和 ZWrite 的深度写入，在渲染遮挡问题上完全没有问题。&lt;/p&gt;

&lt;p&gt;不过它并不是万能的，也存在很多缺陷，我们下面就要讲讲在现代GPU中它的问题。&lt;/p&gt;

&lt;h3&gt;Early-Z GPU硬件优化技术&lt;/h3&gt;

&lt;p&gt;前面说了ZTest 深度测试在片元着色器之后做了片元(即像素带些信息)之间的前后遮挡测试，使得GPU对哪些片元需要绘制又有哪些片元被遮挡而不需要绘制有了依据。&lt;/p&gt;

&lt;p&gt;不过深度测试只是在所有片元都基本成型时才做的测试，使得大部分被遮挡的片元在被剔除时就已经经过一轮的着色器计算，这使得当片元重叠遮挡比较多时导致了大量的GPU算力的浪费。&lt;/p&gt;

&lt;p&gt;这种情况常常发生，特别是在摄像机需要渲染更多物体的时候，遮挡的情况会越来越严重，每个物体生成的片元无论是否被遮挡都会被经过一次差不多是一整个的渲染流程，那么这时的ZTest 深度测试前的渲染计算就几乎全部浪费掉了宝贵的GPU算力。&lt;/p&gt;

&lt;h6&gt;Early-Z 技术就专门为这种情况做了优化，我们可以称它为前置深度测试。由于渲染管线中，ZTest 深度测试其实发生在片元着色器之后，这时候再进行深度测试时，就是对所有渲染对象的像素都计算一遍，几乎没有性能提升，仅仅是为了得出正确的遮挡结果，造成大量的无用计算算力浪费，因为每个像素点上重叠了许许多多次计算。&lt;/h6&gt;

&lt;h6&gt;因此现代GPU中运用了Early-Z的技术，在几何阶段与片元着色器之间（光栅化之后，片元着色器之前）先进行一次ZTest 深度测试，如果深度测试失败，就跳过片元阶段的计算，节省了大量的GPU算力。&lt;/h6&gt;

&lt;p&gt;那么具体它是怎么个流程呢，我们来看看如下图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Early-Z--|
    |        |no
    |yes     |
    |    片元着色计算
    |        |
    |        |
    ZTest 深度测试 -- 抛弃
    |
    |
    屏幕像素缓冲
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上图中展示了Early-Z 前置深度测试的流程，当光栅化后的片元先进入Early-Z 前置深度测试阶段，如果片元测试被遮挡，则直接跳过片元着色计算，如果没有被遮挡则继续片元着色的计算，无论是否通过Early-Z 前置深度测试，最终都会汇集到ZTest 深度测试再测试一次，由ZTest来最终觉得是否抛弃该片云，由于前置测试已经测试完毕了片元的前后关系，因此所有跳过片元着色计算的片元都会在ZTest 节点被抛弃，反之则会继续渲染流程最终进入屏幕像素缓冲区。&lt;/p&gt;

&lt;p&gt;Early-Z的实现是GPU硬件自动调用的，它主要是通过两个pass来实现，即第一个是Z-pre-pass，对于所有写入深度数据的物体，先用一个超级简单的pass不写入像素缓存，只写深度缓存，第二个pass关闭深度写入，开启深度测试，用正常渲染流程进行渲染。&lt;/p&gt;

&lt;h6&gt;由于我们在片元着色器中可以自主的抛弃片元，因此问题又出现了。&lt;/h6&gt;

&lt;p&gt;片元在着色器中被主动抛弃后，Early-Z 前置深度测试的结果就会出现问题，因为如果可见片元被抛弃后，被它遮挡的片元就成为了可见片元，导致前置的深度测试结果失效。&lt;/p&gt;

&lt;p&gt;因此GPU在优化算法中，对片元着色器抛弃片元和修改深度值的操作做了检测，如果在片元着色器中存在抛弃片元和改写片元的操作，则Early-Z 将被放弃使用。&lt;/p&gt;

&lt;h6&gt;简单来说，Early-Z 对遮挡处理做了很大的优化，但是如果我们使用了Alpha Test 来渲染物体时要注意，Early-Z 的优化功能将被弃用。同样的在修改深度值时也要引起注意，Early-Z也同样会被关闭。&lt;/h6&gt;

&lt;h3&gt;Mipmap的原理&lt;/h3&gt;

&lt;p&gt;Mipmap是目前应用最为广泛的纹理映射技术之一。Mip来源于拉丁文中的multum in parvo，意思是“在一个小区域里的很多东西”。Mipmap技术与材质贴图技术结合，根据物体距摄像机远近距离的不同，以不同分辨率的纹理贴图，将单一的材质贴图以多重图像的形式表现出来。&lt;/p&gt;

&lt;p&gt;Mipmap功能在3D游戏中非常常见，但很多人还是不太了解Mipmap的来龙去脉，我们在这里详细的讲一讲。&lt;/p&gt;

&lt;p&gt;在我们为物体渲染纹理贴图时，经常会出现物体离摄像机很远的情况，屏幕像素与纹理之间的比率会变得非常低，因此纹理采样的频率也会变得非常低，这样会导致渲染图像上的瑕疵。我们举例来说：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    如果要渲染一面墙，假设这面墙纹理有 1024 x 1024 这样的大小，当摄像机距离墙很近时渲染的图像是没有问题的，因为每个像素都有各自对应的纹理贴图上合理的像素。但是当摄像机向这面墙渐渐远离，直到它在屏幕上变成一个像素点时就出现问题了，因为纹理采样的结果可能会在某个过度点上发生突然的变化导致图像产生瑕疵。

    特别是在屏幕上不断前后运动的物体可能会使得屏幕上渲染产生闪烁的问题。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Mipmap为了降低这个效果的影响，对纹理贴图进行了提前的滤波，并且将滤波后的图像存储为连续的不同分辨率的纹理贴图。OpenGL在开启Mipmap后会自动判断当前应当使用纹理贴图的哪层分辨率贴图，判断的依据是基于物体在屏幕上渲染的像素大小来决定的。&lt;/p&gt;

&lt;p&gt;除了能更好的平滑渲染远近物体像素上的瑕疵和闪烁问题外，Mipmap还能很好的提高采样的效率，由于采用从已经缓存的不同分辨率纹理的采样对象，那些远离摄像机的物体采用了更小分辨率的纹理贴图，使得采样时宽带的使用降低从而获得更高的效率，其实大部分物体都离摄像机较远，这使得Mipmap的采样效率提升在渲染中发挥了重要的作用。&lt;/p&gt;

&lt;p&gt;一般在使用Mipmap的时候，OpenGL会负责计算细节层次并得到Mipmap层级的结果，再将采样结果返回给用户。不过我们也可以自己取代这个计算过程再通过OpenGL纹理获取函数(textureLod)来选取指定的纹理层次。&lt;/p&gt;

&lt;p&gt;那么在OpenGL中到底 Mipmap 是怎么决定采用哪层分辨率的贴图的呢？我们来详细的讲解一下。&lt;/p&gt;

&lt;p&gt;这里有2个概念要复习一下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1.屏幕上的颜色点叫像素，纹理贴图上的颜色点叫纹素。

    2.屏幕坐标系我们用的是XY坐标系，纹理贴图坐标系用的是UV坐标系。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在片元着色器中，每个片元即屏幕空间XY上的像素都会找到对应的纹理贴图中的纹素来确定像素的颜色。&lt;/p&gt;

&lt;p&gt;这个查找纹素的过程就是一个从XY空间到UV空间的一个映射过程。我们可以通过分别求x和y偏导数来求屏幕单个像素宽度纹理坐标的变化率。&lt;/p&gt;

&lt;p&gt;在屏幕上，某区域上的像素，对应到实际的纹理贴图中可能是一个长方形的区域。&lt;/p&gt;

&lt;p&gt;那么x轴方向上的纹理贴图大小和屏幕上的像素区域大小有一个比例，y轴方向上的也同样有一个比例。&lt;/p&gt;

&lt;p&gt;例如，获取到的纹理贴图上的纹素大小为 64x64，屏幕上的像素区域大小为32x32，那么它们在x轴上的纹素和像素大小比例为 2.0 (即64/32)，y轴上的也同样是 2.0 (即64/32)。又比如，纹理贴图上的纹素大小为 64x32，屏幕上的像素区域大小为 8x16，那么它们在x轴上的纹素和像素大小比例为 8.0(即64/8)，在y轴上的纹素和像素大小比例为2.0(即32/16)。&lt;/p&gt;

&lt;p&gt;这个比例就是纹素的覆盖率，当物体离摄像机很远时，纹素的覆盖率就很大，当物体离摄像机很近时则很小，甚至小于1(当纹素覆盖率小于1时则会调用纹理放大滤波器，反之则用到了Mipmap，如果刚好等于1则使用原纹理)。&lt;/p&gt;

&lt;p&gt;在着色器中我们可以用ddx和ddy求偏导的方式分别求这个两个方向上的覆盖率，然后取较大的覆盖率。&lt;/p&gt;

&lt;p&gt;为什么ddx和ddy偏导函数就能计算覆盖率呢，这里稍微复习一下。我们知道在光栅化的时刻，GPU会在同一时刻并行运行很多片元着色器，但是并不是一个像素一个像素的去执行，而是将其组织成 2x2 为一组的像素块，再去并行执行。而偏导数就正好能计算这一块像素中的变化率。&lt;/p&gt;

&lt;p&gt;我们来看下偏导的真相：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    ddx(p(x,y)) = p(x+1,y) - p(x,y)

    ddy(p(x,y)) = p(x,y+1) - p(x,y)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;x轴上的偏导就是 2x2 像素块中 x轴方向上附近的数值之差。同理，y轴上的偏导就是 2x2 像素块中 y轴方向上附近的数值之差。&lt;/p&gt;

&lt;p&gt;因此MipMap层级的计算可以描述为&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MipmapLevel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;textureSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ddx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;textureSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ddy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;textureSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;  
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;log2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;求出x轴和y轴方向上的覆盖率后，取最大值d(dot(dx,dx)其实就是dx的平方)，再log2后获得Mipmap层级，这里0.5是技巧，本来应该是d的平方。&lt;/p&gt;

&lt;p&gt;大部分时候OpenGL已经帮我们做了Mipmap层级的计算，也就是说我们在Shader中使用tex2D(tex, uv)获取颜色的时候就相当于在GPU内部展开成了如下面所示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tex2D&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sampler2D&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lod&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CalcLod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ddx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ddy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tex2Dlod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的意思是uv所求的导数越大，在屏幕中占用的纹理范围就越大。简单来说就是我们在片元计算中发现uv导数很大时，就说明这个片元离摄像机很远，从这个方面来理解uv的在片元着色器中的求偏导就可以明白，我们只需要通过uv的求偏导就能间接计算出x轴和y轴方向的覆盖率。&lt;/p&gt;

&lt;h6&gt;在OpenGL中Mipmap的计算其实依赖于片元中的uv求偏导值，也就是说，片元所映射的uv范围越大，计算出来的Mipmap层级越高，纹理贴图选取的分辨率越小。&lt;/h6&gt;

&lt;h3&gt;显存的存在&lt;/h3&gt;

&lt;p&gt;显存经常被我们忽视，因为近几年流行的都是手机端的游戏项目，其实它在PC端存在的意义很大。一个显卡除了有图像传给处理单元GPU外，还拥有自己的内存，即显存VRAM(Video Random Access Memory)。&lt;/p&gt;

&lt;p&gt;GPU可以在显存中存储任何数据，例如图像缓存、深度缓存、模板缓存、着色器实例等。&lt;/p&gt;

&lt;p&gt;除了这几个必要的缓存外，显卡中还存放着渲染时需要用到的贴图纹理、顶点缓存等，这些内容都是需要从CPU内存中拷贝过来的，在调用渲染前，应用程序可以调用图形应用接口OpenGL将数据从普通内存中拷贝到显卡内存中，这个过程只存在于PC端和主机端，因为它们都拥有显卡的存在。&lt;/p&gt;

&lt;p&gt;因此PC端在渲染前还有进一步拷贝数据的过程，显存并不多即使现代显存成本变低的情况下仍然捉襟见肘。&lt;/p&gt;

&lt;p&gt;手机端就没有这样的拷贝过程。手机端大都是ARM架构，芯片中嵌入了各种各样的硬件系统，包括SoC(即芯片级系统，包含了完整系统并有嵌入软件的全部内容)、图像处理GPU、音频等。而显存由于种种限制没有被设计加入到ARM中去，因此在手机端中CPU和GPU共用同一个内存控制器，也就是说CPU和GPU是共用内存带宽的，没有独立显存只有普通内存，不过即便这样GPU也有自己的独立内存部分，例如上面的缓存和后面的可写数据的拷贝都需要一份独立的“共享显存”。&lt;/p&gt;

&lt;p&gt;手机端没有独立显存，因此OpenGL ES就设计了映射缓冲区对象，它在不需要拷贝内存的前提下可以通过共享内存来实现数据的提取。如果贴图或顶点数据是只读状态的话完全没有必要为渲染而重新拷贝一份，而是可以选择建立起映射缓冲区对象，直接读取内存来获取数据。不过也有不做建立映射缓冲区对象的时候，当数据、纹理被开启可写状态时则必须重新拷贝一份在GPU独立内存中，因为原数据随时会被CPU更改，而当时可能GPU还在渲染中，如果仍然并行处理同一个数据则会造成显示问题，因此两个并行的脑袋不能共享一份可写的数据。&lt;/p&gt;
</description>
               <pubDate>Sun, 13 Oct 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/10/13/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A66.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/10/13/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A66.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(二) - 渲染管线2</title>
               <description>&lt;p&gt;继上篇讲解了渲染管线的应用阶段、几何阶段和光栅化阶段，这一节我们来讲讲最后的逐片元操作阶段，以及着色器中我们常见的一些概念和原理。&lt;/p&gt;

&lt;h6&gt;逐片元操作(Per-Fragment Operations)是OpenGL的说法，在DirectX称为输出合并阶段(Output-Merger)，其实只是说法不同而已包含的内容都是相同的，包括了，剪切测试(Scissor test)，多重采样的片元操作，模板测试(Stencil Test)、深度测试(Depth Test)、混合(blending)、以及最后的逻辑操作。&lt;/h6&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;这几个节点都是以片元为基础的元素操作动作，它们都决定了片元的去留问题。所以逐片元操作阶段是解决片元的可见性问题的一个重要阶段，如果片元在这几个节点上任意一个节点没有通过测试，那么它就会被丢弃并且之后的测试或操作都不会被执行，如果执行全部通过就会进入帧缓存。每个节点实际测试的过程是个比较复杂的过程，而且不同的图形接口实现的细节也不一样，但我们要理解到它们的基本原理和大致的过程相对简单一些。&lt;/p&gt;

&lt;p&gt;所有这些测试和操作其实都可以看做是以开关形式存在，因为他们的操作命令大都包含了On和Off操作指令，在OpenGL里以glEnable()和glDisable()来表示功能是否被开启或关闭。&lt;/p&gt;

&lt;p&gt;第一个可见性测试就是剪切测试(Scissor)，它主要针对的是片元是否在矩形范围内的测试判断，如果片元不在矩形范围内则被丢弃。&lt;/p&gt;

&lt;p&gt;这个范围是一个矩形的区域，我们称它为剪切盒。实际上可以有很多个剪切盒存在，只是默认情况下所有渲染测试都在第一个剪切盒上完成，要访问其他剪切盒就需要几何着色器。&lt;/p&gt;

&lt;p&gt;Unity3D并没有开放这个剪切测试的功能，它的实际应用比较少。&lt;/p&gt;

&lt;p&gt;第二步是多重采样的片元操作。&lt;/p&gt;

&lt;p&gt;普通采样只采一个样本或者说一个像素，而多重采样泽是分散取得多个样本，这些样本可能是附近的几个位置也可能是其他算法。因此在多重采样中，每个片元都有多种颜色，多个深度值和多组纹理坐标，而不是只有一种（具体有多少个取决于子像素的样本数目）。&lt;/p&gt;

&lt;p&gt;如果没有开启多重采样的片元操作，多重采样在计算片元的覆盖比例时，不会考虑alpha值的影响。&lt;/p&gt;

&lt;p&gt;一旦开启多重采样的片元操作，我们就可以用片元的alpha值来影响采样的覆盖率计算。&lt;/p&gt;

&lt;p&gt;Unity3D的没有开放自定义设置多重采样的片元操作功能，但像素本身不是单单只是它本身的颜色和深度，而是由附近的像素一起决定的。具体的多重采样内容将在后面的章节中讲述。&lt;/p&gt;

&lt;p&gt;前两步可能并没有引起我们足够的重视，但后面几步需要我们着重学习。&lt;/p&gt;

&lt;p&gt;第三步模板测试(Stencil Test)，模板测试说的简单点，其实和比大小无异，关键就是怎么比，与谁比，这又能玩出很多花样。&lt;/p&gt;

&lt;p&gt;在模板测试中模板缓存是必要的内存块，因为每个片元在通过测试后都会被写入到模板缓存中。&lt;/p&gt;

&lt;p&gt;开发者需要指定一个引用参考值(Reference value)，这个参考值代表了当前物体所有片元的参考值，这个参考值会与模板缓存(Stencil Buffer)中当前位置片元的模板值进行比较，比较时模板缓存中当前位置片元的参考值是被前面的物体通过测试时写入的一个值，比较两个值后会根据比较的结果做判断是否抛弃片元，判断可以是大于、等于、小于等，一旦判断失败片元将被抛弃反之则继续向下传递，只是判断成功后也可以有相应对模板缓存做其他操作，操作可以有，替换旧的片元，增加一定的参考值，参考值置零等等。&lt;/p&gt;

&lt;p&gt;我们来看看到底有多少种判断，和，多少种对模板缓存的操作。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Greater 大于模板缓存时判断通过
    GEqual  大于等于模板缓存时判断通过
    Less    小于模板缓存时判断通过
    LEqual  小于等于模板缓存时判断通过
    Equal   等于模板缓存时判断通过
    NotEqual    不等于模板缓存时判断通过
    Always  总是通过
    Never   总是不通过
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述这些都是对于是否通过测试的判断种类，看上去就像是简单的比大小。在Unity3D的Shader中的完整的模板测试写法如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Stencil {
        Ref 2 //指定的引用参考值
        Comp Equal //比较操作
        ReadMask 255 //读取模板缓存时的掩码
        WriteMask 255 //写入模板缓存是的掩码
        Pass Keep //通过后对模板缓存的操作
        ZFail IncrSat //如果深度测试失败时对模板缓存的操作
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模板测试的步骤简单明了，当前值与模板缓冲比较，通过的做一个指定的操作替换或者增加或者减少等，不通过的片元被抛弃。&lt;/p&gt;

&lt;p&gt;上述Unity3D模板命令中 Pass 的操作就是通过测试后的操作种类，它有如下几种方式可选：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Keep    不做任何改变，保留当前缓存中的参考值
    Zero    当前Buffer中置零
    Replace 将当前的参考值写入缓存中
    IncrSat 增加当前的参考值到缓存中，最大为255
    DecrSat 减少当前的参考值到缓存中，最小为0
    Invert  翻转当前缓存中的值
    IncrWrap    增加当前的参考值到缓存中，如果到最值255时则变为0
    DecrWrap    减少当前的参考值到缓存中，如果到最小为0时则变为255
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不同的物体有不同的引用值，每个比较操作都可以不一样，包括掩码值、成功后的操作动作，一个简简单单的比大小其实也能玩出这么多花样来。不止如此，除了比较和通过后的操作指令外，深度测试失败时还可以影响模板缓存中的值。我们用一幅图就能理解模板测试的美妙：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺图
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中三个球一起叠加在一起，却只显示了一个球的，并且在这个球上显示了三个球叠加的部分。因为其他两个球的模板测试并没有通过，但叠加部分则通过了模板测试。&lt;/p&gt;

&lt;h6&gt;如果片元幸运的通过了模板测试，则会来到第四步，深度测试。有没觉得这个片元很像某生理教课书上描述精子通过重重困难终于来到了卵子的的位置那样，课本上总是这么介绍，刚好片元也是如此。&lt;/h6&gt;

&lt;p&gt;深度测试主要目的是将被覆盖的片元丢弃，或者说将需要覆盖的片元绘制在屏幕上，其实这两个操作都是根据物体渲染的前后关系操作的。&lt;/p&gt;

&lt;p&gt;深度测试工作分为两块，一块是比较即ZTest，一块是写入即ZWrite，只有比较并被判定通过的才有写入的资格，我们也可以把写入关了，让物体无法写入，这就会导致它片元深度无法与其他物体比较，这种写法在半透明中很常用，其他时候大部分都是默认开启深度值写入即ZWrite On。&lt;/p&gt;

&lt;p&gt;深度测试是怎么比较的呢？还记得前面介绍的模板测试么，重点就是“比大小”，比完判定通过的就写入缓存，深度测试的方法和模板测试的流程和方法简直就是一个妈生出的俩个孩子。深度测试的 ZTest 对应模板测试的 Comp指令，深度测试的 ZWrite 对应模板测试的 Pass指令，先拿当前片元比较缓存中的值再操作缓存，两者简直一模一样。&lt;/p&gt;

&lt;p&gt;与模板测试不同的是深度测试用的是深度值，而不是固定某个值，写入缓存也不没有那么多花样。&lt;/p&gt;

&lt;p&gt;那么什么是深度值？这个深度值是从哪来的？&lt;/p&gt;

&lt;p&gt;还记得前面顶点着色器中介绍的，顶点在变化坐标空间后z轴被翻转成为了视口前方的轴么。整个锥视体变成了立方体，x、y轴则成为了视口平面上的平面方向轴，原来的z轴转换成了顶点前后关系的深度值。我们再来看看这幅图片：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺图
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是的，正是因为那次坐标系的转换和后面的归一化，使得所有顶点的坐标都在一个立方体的空间内，且这个立方体的大小被限制在了-1到1的大小，x、y成为了屏幕相对参考坐标，而z则成为了前后关系的深度参考值。&lt;/p&gt;

&lt;p&gt;虽然这只是顶点上的坐标，但在后面的步骤中三角面被光栅化，并对每个像素背后形成了片元，每个片元根据三角形顶点信息的插值后z坐标也进入了片元中，这就是我们需要的片元的深度值。&lt;/p&gt;

&lt;p&gt;深度值在片元中成为了片元在深度测试中判断的依据，如果输入片元的深度值即z值可以通过制定的深度测试环节，那么它就可以替换当前深度缓存中已经有的深度值(如果ZWrite 没有被关闭的话)。&lt;/p&gt;

&lt;p&gt;深度测试的判断依据也有很多种，我们来看下它有多少中判断种类:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    ZTest Less | Greater | LEqual | GEqual | Equal | NotEqual | Always
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述中表达了所有判断种类，从左到右为，小于缓存中的就通过，大于缓存中的就通过，小于等于缓存中的就通过，大于等于缓存中的就通过，等于缓存中的就通过，不等于缓存中的就通过，以及总是通过与缓存无关。其中LEqual 最为常用，即越接近摄像机的越需要覆盖其他面片，越远离摄像机的越容易被覆盖或者说越容易通不过深度测试。&lt;/p&gt;

&lt;h6&gt;我们可以更加白话一点表达深度测试，一般情况下都是用LEqual 作为深度测试判断依据，即哪个片元离摄像机越近就用哪个，其他种类的类型判断类型也可以解释的类似与摄像机距离有关。&lt;/h6&gt;

&lt;p&gt;如果片元很幸运冲破前面这么多种测试终于来到了第五步混合阶段，这一步从测试上来说其实是最后一个阶段。&lt;/p&gt;

&lt;h6&gt;混合阶段实质上并没有丢弃任何片元，但却可以让片元消失不见。&lt;/h6&gt;

&lt;p&gt;如果一个片元通过了上面的测试，那么它就有资格与当前颜色缓冲中的内容进行混合了。最简单的混合方式就是直接覆盖已有的颜色缓冲中的值，实际上这样不算混合，只是覆盖而已，我们需要两个片元的真正混合。&lt;/p&gt;

&lt;p&gt;那么什么叫混合？为什么要混合？&lt;/p&gt;

&lt;p&gt;混合是两个片元的从颜色上和alpha值上相加或相乘的算法过程，通过我们自己指定的数学公式来确定混合后的像素颜色，这个公式不复杂，其实就是颜色和因子的加减乘的基本运算，通过这种运算我们能得到想要的效果。&lt;/p&gt;

&lt;p&gt;由于物体都是一个接一个的被渲染在缓冲中的，当前物体被光栅化成为片元后要写入缓存时，面临着前面渲染的物体已经被铺在缓冲中的情况，如果没有开启混合，当前的片元则会直接覆盖掉当前所在的缓冲中的像素，两个片元并没有做任何关联性的操作，但如果这时开启混合则可以对这两个片元在颜色上做更多的操作，这可能是我们所期望的。&lt;/p&gt;

&lt;p&gt;大多数情况混合与片元的 alpha 值有关，但不是硬性要求一定要与alpha有关，也可以只与颜色有关，只是这种类型比较多而已。&lt;/p&gt;

&lt;p&gt;alpha 是颜色的第四个分量，OpenGL中片元的颜色都会带有 alpha 无论你是否需要它，无论是否你显性地设置了它，alpha默认为1不透明。&lt;/p&gt;

&lt;p&gt;但是 alpha 太抽象，我们无法从肉眼看到它，只能在脑袋中想象它。alpha 代表了片元的透明程度，是颜色的第四个分量，我们可以用它实现各种半透明物体的模拟就像有色玻璃那样。&lt;/p&gt;

&lt;p&gt;说白了，混合就是当前物体的片元与前面渲染过的物体的片元之间的颜色与alpha上的操作，那么混合有哪些操作呢？我们来看下Unity3D中的混合指令：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Blend SrcFactor DstFactor

    Blend SrcFactor DstFactor, SrcFactorA DstFactorA
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有两种操作方式，第一种是混合颜色包括alpha，第二种是分开混合即，RGB颜色和RGB颜色混合(alpha不参与)用一种方式，alpha和alpha混合则用另一种方式(颜色不参与)。&lt;/p&gt;

&lt;p&gt;其中 SrcFactor 这个因子(变量)会与刚刚通过测试的物体片元(即当前物体片元)上的颜色相乘。&lt;/p&gt;

&lt;p&gt;DstFactor 这个因子(变量)会与前面已经渲染过的物体的片元(即缓存中的像素)的颜色相乘。&lt;/p&gt;

&lt;p&gt;SrcFactorA 这个因子(变量)会与刚刚通过测试的物体片元(即当前物体片元)上的 alpha 相乘。&lt;/p&gt;

&lt;p&gt;DstFactorA 这个因子(变量)会与已经渲染过的物体(即缓存中的像素)片元上的 alpha相乘。&lt;/p&gt;

&lt;h6&gt;这个过程有两个步骤，第一步是相乘操作，第二步是相乘后的两个结果再相加(还可以选相减等)。我们称为混合方程&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    即 Src * SrcFactor + Dst * DstFactor

    或 SrcColor * SrcFactor + DstColor * DstFactor, SrcAlpha * SrcFactorA + DstAlpha * DstFactorA
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常情况下相乘的结果再相加得到最终的混合片元。但我们可以改变这种方程式，用减号，或者调换位置的减号，最大值函数，最小值函数，来代替源数据与目标数据之间的操作符。即&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    BlendOp Add 加法
    BlendOp Sub 减法
    BlendOp RevSub 置换后相减
    BlendOp Min 最小值
    BlendOp Max 最大值
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述5种操作符的修改就分别代表了因子相乘后会相加，会相减，会置换后相减，会取得最小值，会取得最大值。拿Sub，Max来举例子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    当写入BlendOp Sub时，方程式就变成了：

    Src * SrcFactor - Dst * DstFactor

    当写入BlendOp Max时，方程式就变成了：

    Max(Src * SrcFactor, Dst * DstFactor)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了操作符可以变化外，SrcFactor、DstFactor、SrcFactorA、DstFactorA 这四个变量的可以选择为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    One     代表1，就相当于完整的一个数据
    Zero    代表0，就相当于抹去了整个数据
    SrcColor    代表当前刚通过测试的片元上的颜色(即当前物体片元)，相当于乘以当前物体片元的颜色
    SrcAlpha    代表当前刚通过测试的片元上的alpha(即当前物体片元)，相当于乘以当前物体片元的alpha
    DstColor    代表已经在缓存中的颜色，相当于乘以当前缓存颜色
    DstAlpha    代表已经在缓存中的alpha，相当于乘以当前缓存alhpa
    OneMinusSrcColor    代表缓存上的片元做了 1 - SrcColor 的操作，再相乘
    OneMinusSrcAlpha    代表缓存上的片元做了 1 - SrcAlpha 的操作，再相乘
    OneMinusDstColor    代表当前刚通过测试的片元上的颜色做了 1 - DstColor 的操作，再相乘
    OneMinusDstAlpha    代表当前刚通过测试的片元上的颜色做了 1 - DstAlpha 的操作，再相乘
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上述举的几个例子，并列出了所有变量的选择，我们可以知道其实Blend混合可以玩出很多花样来。&lt;/p&gt;

&lt;p&gt;这4个变量选择，和操作符的选择决定了混合后的效果，我们来看看其常用的混合方法：&lt;/p&gt;

&lt;h6&gt;1， 透明度混合Blend SrcAlpha OneMinusSrcAlpha，即常用半透明物体的混合方式。&lt;/h6&gt;

&lt;p&gt;这是最常用的半透明混合，首先要保证半透明绘制的顺序比实体的要后面，所以Queue标签是必要的Tags {&amp;quot;Queue&amp;quot; = &amp;quot;Transparent&amp;quot;}。Queue标签告诉着色器此物体是透半透明物体排序。至于渲染排序Queue的前因后果将在后面的文章介绍。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader36.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;Blend SrcAlpha OneMinusSrcAlpha 我们来解释下，以上图为例，图中油桶是带此Shader的混合目标。&lt;/p&gt;

&lt;p&gt;当绘制油桶时，后面的实体BOX已经绘制好并且放入屏幕里了，所以ScrAlpha与油桶渲染完的图像相乘，部分区域Alpha为0即相乘后为无(颜色)，这时正好另一部分由OneMinusSrcAlpha(也就是1-ScrAlpha)为1即相乘后原色不变，两个颜色相加后就相当于油桶的透明部分叠加后面实体Box的画面，于是就形成了上面的这幅画面。&lt;/p&gt;

&lt;p&gt;反过来也是一样，当ScrAlpha为1时，源图像为不透明状态，则两个颜色在相加前最终变成了，源图像颜色+无颜色=源图像颜色，于是就有了上图中油桶覆盖实体Box的图像部分。&lt;/p&gt;

&lt;h6&gt;2，加白加亮叠加混合 Blend One One，即在原有的颜色上叠加屏幕颜色更加白或亮。&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader37.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;第一参数One代表本物体的颜色。第二个参数代表缓存上的颜色。两种颜色没有任何改变并相加，导致形成的图像更加亮白。这样我们就看到了一个图像加亮加白的图像。&lt;/p&gt;

&lt;h6&gt;3，保留原图色彩Blend One Zero，即只显示自身的图像色彩不加任何其他效果。&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader38.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;本物体颜色，加上，零，就是本物体颜色。&lt;/p&gt;

&lt;h6&gt;4，自我叠加（加深）混合Blend SrcColor Zero，即源图像与源图像自我叠加。&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader39.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;与上面相比，加深了本物体的颜色。先是本物体的颜色与本物体的颜色相乘，加深了颜色，第二个参数为零，使得缓冲中的颜色不被使用。所以形成的图像为颜色加色的图像。&lt;/p&gt;

&lt;h6&gt;5，目标源叠加（正片叠底）混合Blend DstColor  SrcColor，即把目标图像和源图像叠加显示。&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader40.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;第一个参数，本物体颜色与缓存颜色相乘，颜色叠加。第二个参数，缓存颜色与本问题颜色相乘，颜色叠加。两种颜色相加，加亮加白。这个混合效果就如同两张图像颜色叠加后的效果。&lt;/p&gt;

&lt;h6&gt;6，软叠加混合Blend DstColor  Zero，即把刚测试通过的图像与缓存中的图像叠加。&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader41.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;与前面的叠加混合效果相似，这个只做一次叠加，并不做颜色相加操作，使得图像看起来在叠加部分并没有那么亮白的突出。因为第二个参数为零，表示后面的屏幕颜色与零相乘即为零。&lt;/p&gt;

&lt;h6&gt;7，差值混合BlendOp Sub，Blend One One，即注重黑白通道的差值。&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader42.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;在这个混合中使用了混合操作改变，从默认的加法改成了减法，使得两个颜色从加法变为了减法，不再是变白变亮的操作，而是反其道成为了色差的操作。&lt;/p&gt;

&lt;h6&gt;除了对源片元和目标片元，相乘再相加的操作，还可以改变相乘后的加法操作。比如减法，取最大值，取最小值等。&lt;/h6&gt;

&lt;h6&gt;Blend混合很像 Photoshop 中对图层操作，Photoshop中每个图层都可以选择混合模式，混合模式决定了该层与下层图层的混合结果，而我们看到的都是是混合后的图片。&lt;/h6&gt;

&lt;h3&gt;逻辑操作&lt;/h3&gt;

&lt;p&gt;在混合结束后，片元将被写入缓存中去，在写入缓冲中去时，还有一步逻辑操作，这是片元的最后一个操作。&lt;/p&gt;

&lt;p&gt;它作用于当前刚通过测试的片元数据以及当前颜色缓存中的数据，在它们之间进行一次操作，再写入到缓存中覆盖原来的数据。&lt;/p&gt;

&lt;p&gt;由于这个过程的实现代价对于硬件来说是非常低廉的，因此很多系统都允许这种做法。这种逻辑操作的方式很像上面的混合(Blend)，但是更加简单，不再有因子，只是两种颜色之间的数字操作，例如，XOR异或操作，AND与操作，OR或操作等。&lt;/p&gt;

&lt;p&gt;Unity3D中并不能自定义设置逻辑操作，这里不重点讲解。&lt;/p&gt;

&lt;h6&gt;双缓冲机制&lt;/h6&gt;

&lt;p&gt;片元最后都会以像素颜色的形式写入缓冲中，但是如果只有一个缓冲，那么我们会时常见到绘制的中间状态即图形的形成过程，这对画面呈现效果很不友好，所以GPU通常采用双缓冲机制，即前置缓存用于呈现画面，而后置缓存则继续由GPU继续工作。&lt;/p&gt;

&lt;p&gt;当整个画面绘制完成时，后置缓冲与前置缓冲进行调换，这时后置缓存可以成为了前置缓冲并呈现在屏幕上，而原来的前置缓存则成为后置缓冲交由GPU作为缓冲内存继续绘制下一帧，由此我们可以保证看到的图像是连续的最终状态。&lt;/p&gt;

&lt;h6&gt;整个渲染管线已经全部呈现在这里了，我们来总结一下。&lt;/h6&gt;

&lt;p&gt;整个渲染管线从大体上分，应用阶段，几何阶段，光栅化阶段。渲染数据从应用阶段生成开始。&lt;/p&gt;

&lt;p&gt;数据在应用阶段被记录、筛选(或者也可以叫裁剪)、合并，这个筛选和合并有些运用了算法来达到裁剪的目的，有些放大了颗粒度用少量的消耗来加速筛选(裁剪)，有些利用了GPU工作原理合并了渲染数据提高了GPU工作效率。&lt;/p&gt;

&lt;p&gt;几何阶段着重于处理顶点的数据，顶点着色器是其中最为重要的一个着色器，它不但需要计算顶点在空间上的转换，还要为下一个阶段光栅化阶段做准备。&lt;/p&gt;

&lt;p&gt;在顶点着色器中，计算和记录了片元着色器计算颜色需要的数据，这些数据都会被放入顶点(图元)数据内，这些数据在下一个阶段会被做插值后放入片元中。&lt;/p&gt;

&lt;p&gt;光栅化阶段主要任务是将三角形面转化为实实在在的像素，并且根据顶点上的数据做插值得到片元信息，一个片元就相当于一个像素附带了很多插值过的顶点信息。&lt;/p&gt;

&lt;p&gt;片元着色器在光栅化阶段起了重要的作用，它为我们提供了自定义计算片元颜色的可编程节点，不但如此，我们还可以根据自己的喜好抛弃某些片元。&lt;/p&gt;

&lt;p&gt;除了片元着色器外，片元在片元着色器后还需要经过好几道测试才能最终呈现在画面上，包括判断片元前后顺序的深度测试，可以自定义条件的模板测试，以及常用来做半透明的像素混合，片元只有经过这几道关卡才最终被写入缓存中。&lt;/p&gt;

&lt;h6&gt;我们讲解了很多，但还是有很多很多细节被忽略，我们会在后面的章节中详细为大家解剖，这些细节可能在各个图形编程接口(OpenGL和DirectX)的实现中不尽相同，但大体上都是运用了同一种原理和概念。&lt;/h6&gt;

&lt;p&gt;Unity3D为我们封装了很多东西，使得我们能很快的上手去运用，但也屏蔽了很多原理上的知识，使得我们在面对底层原理时感到迷茫。本书虽然不是致力于Shader的教学，但也将尽最大的努力使读者们从根本上理解GPU的工作原理，从而在面对工作上的困难时能一眼看透问题的本质，从根本上解决麻烦并优化效率。&lt;/p&gt;
</description>
               <pubDate>Sat, 28 Sep 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/09/28/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A65.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/09/28/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A65.html</guid>
            </item>
        
            <item>
               <title>杭州景点体验概览</title>
               <description>&lt;p&gt;1.西湖--西湖音乐喷泉--三潭印月--断桥残雪--苏堤--白堤--西湖游船--曲院风荷--六和塔--花港观鱼--梅家坞--云栖竹径--龙井路与满觉陇路--孤山公园--虎跑公园--杨公堤&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;2.灵隐寺（飞来峰）景区----北高峰索道&lt;/p&gt;

&lt;p&gt;3.宋城景区--宋城千古情演出&lt;/p&gt;

&lt;p&gt;4.杭州动物园&lt;/p&gt;

&lt;p&gt;5.吴山广场，河坊街&lt;/p&gt;

&lt;p&gt;6.雷峰塔&lt;/p&gt;

&lt;p&gt;7.杭州长乔极地海洋公园 -- 好，贵，大&lt;/p&gt;

&lt;p&gt;8.杭州野生动物世界 -- 良好，停车难，略贵，不大&lt;/p&gt;

&lt;p&gt;9.西溪国家湿地公园 -- 差，管理无章法，太大以至于找不到重点&lt;/p&gt;

&lt;p&gt;10.九溪&lt;/p&gt;

&lt;p&gt;11.南宋御街&lt;/p&gt;

&lt;p&gt;12.杭州乐园&lt;/p&gt;

&lt;p&gt;13.太子湾公园&lt;/p&gt;

&lt;p&gt;14.千岛湖中心湖区--千岛湖景区--千岛湖森林氧吧--千岛湖东南湖区景区--千岛湖游船&lt;/p&gt;

&lt;p&gt;16.大明山景区&lt;/p&gt;

&lt;p&gt;17.杭州烂苹果乐园 -- 游乐园&lt;/p&gt;

&lt;p&gt;18.杭州海底世界&lt;/p&gt;

&lt;p&gt;19.浙西大峡谷&lt;/p&gt;

&lt;p&gt;20.钱塘江观赏堤坝&lt;/p&gt;

&lt;p&gt;21.浙江省科技馆--西湖文化广场&lt;/p&gt;

&lt;p&gt;22.杭州浪浪浪水公园&lt;/p&gt;

&lt;p&gt;23.杭州Hello Kitty乐园&lt;/p&gt;

&lt;p&gt;24.桐庐县雅鲁激流探险漂流----临安市龙井峡漂流----淳安县九龙溪漂流----桐庐县虎啸峡激流探险漂流----余杭区双溪漂流景区&lt;/p&gt;

&lt;p&gt;25.桐庐县瑶琳仙境，垂云通天河景区&lt;/p&gt;

&lt;p&gt;26.杭州DO都城，亚洲最大的少年儿童体验类教育场馆&lt;/p&gt;

&lt;p&gt;27.桐庐县大奇山国家森林公园&lt;/p&gt;

&lt;p&gt;28.临安太湖源&lt;/p&gt;

&lt;p&gt;29.良渚，彻天彻地童玩中心，让孩子训练协调能力，培养冒险精神&lt;/p&gt;

&lt;p&gt;30.江干区江和美海洋公园&lt;/p&gt;

&lt;p&gt;31.临安大明山景区&lt;/p&gt;

&lt;p&gt;32.慈溪杭州湾国家湿地公园&lt;/p&gt;

&lt;p&gt;33.胡雪岩故居&lt;/p&gt;

&lt;p&gt;34.京杭大运河，余杭塘栖&lt;/p&gt;

&lt;p&gt;35.杭州国际博览中心，萧山区&lt;/p&gt;

&lt;p&gt;36.多乐岛蹦床公园杭州馆，江干区&lt;/p&gt;

&lt;p&gt;37.桐庐县大奇山疯狂森林主题乐园，冒险探险&lt;/p&gt;

&lt;p&gt;38.城西银泰，娱乐场--滑冰--玩具店 -- 逛买逛买&lt;/p&gt;

&lt;p&gt;39.浙江大学紫金港校区 -- 好风景好环境&lt;/p&gt;

&lt;p&gt;40.塘西古镇  -- 逛吃逛吃，小&lt;/p&gt;

&lt;p&gt;41.杭州北高峰 -- 交通不方便&lt;/p&gt;

&lt;p&gt;42.良储遗址 -- 大，美，便宜，自带食物，能游览大半天&lt;/p&gt;

&lt;p&gt;43.井山湖农耕文化公园(塘子堰，中小学生实践基地) -- 免费，向日葵基地，大片草地，搭帐篷，风景美，自带食物&lt;/p&gt;
</description>
               <pubDate>Sat, 21 Sep 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/09/21/%E6%9D%AD%E5%B7%9E%E6%99%AF%E7%82%B9%E4%BD%93%E9%AA%8C%E6%A6%82%E8%A7%88.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/09/21/%E6%9D%AD%E5%B7%9E%E6%99%AF%E7%82%B9%E4%BD%93%E9%AA%8C%E6%A6%82%E8%A7%88.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(二) - 渲染管线1</title>
               <description>&lt;p&gt;计算机的世界里其实是很纯粹的，没有什么高深的技术，无非就是进程、线程、内存、硬盘、CPU。&lt;/p&gt;

&lt;p&gt;在现代社会的实际编程中，很多时候引擎或者框架帮我们屏蔽了底层上的操作使得程序员只需要将所有精力放在上层应用就可以了，因此数学和算法很多时候成了重点，这是符合社会进步规律的，我们需要站在巨人的肩膀上才能走得比巨人更快更远。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;Unity3D就是帮助我们快速建立程序结构的好引擎，有了Unity3D我们才能在较低门槛的情况下，创造出自己的想法和创意，让’我‘里面有的内在才能快速和有效的得到放大。&lt;/p&gt;

&lt;p&gt;除了进程、线程、内存、硬盘、CPU这些通常我们程序员在编程时都要接触的因素外，对于我们前端程序员来说又多了一个GPU的技术范畴，因此我们需要学习和考虑的问题比其他程序员会更加多一些也更加高阶一些，Unity3D虽然封装了所有引擎需要的GPU接口功能但我们还是必须要了解渲染管线是如何处理的，最终是如何将渲染数据渲染要屏幕上的等等这些底层的知识和原理。&lt;/p&gt;

&lt;h3&gt;OpenGL、DirectX究竟是什么&lt;/h3&gt;

&lt;p&gt;OpenGL 和 DirectX 其实是一回事，它们都是图形渲染的应用程序编程接口，它们都是一种可以对图形硬件设备特性进行访问的软件库。它们的区别只是接口名字不一样，并且，分别由不同的两个开发群体开发出来的两套程序。&lt;/p&gt;

&lt;p&gt;为什么会是两个不同群体开发出来的两套差不多功能的软件，并且还同时运行在现有的世界中呢？&lt;/p&gt;

&lt;p&gt;OpenGL是由SGI(Silicon Graphics 美国硅图公司)开发的，而DirectX是由微软开发的，由于市场竞争的关系两家公司做了同样的事，最后导致现在的局面。从现在的局面看，我们可以想象的到，在当初还没有形成统一的硬件渲染接口时，各家公司的编程方式有多混乱，情况有多复杂，对标准统一接口的标准竞争有多激烈。在这种严峻的情况下才使得两家公司为了各自的利益，一直在不断维护和升级着各自的驱动接口直到今天。&lt;/p&gt;

&lt;p&gt;幸运的是 Unity3D 已经帮我们封装好了 OpenGL 和 DirectX 的接口，我们无需关心到底是调用 OpenGL 还是 DirectX。我们这里会以OpenGL为例来讲解Unity3D与OpenGL的关系，暂时免去DirectX的麻烦。&lt;/p&gt;

&lt;h6&gt;OpenGL究竟处在哪个位置&lt;/h6&gt;

&lt;p&gt;Unity3D通过调用 OpenGL 来渲染图像，OpenGL 定义各种标准接口就是为了让像 Unity3D 这样的应用程序在面对不同类型的显卡硬件时可以不必慌张，也就是说由于 OpenGL 的存在，Unity3D完全不需要去关心硬件到底是哪个厂家生产的，它的驱动是什么。其实与其说OpenGL在标准接口中适配了硬件厂商的驱动程序，不如说硬件厂商的驱动程序适配了OpenGL，事实上确实是这样。&lt;/p&gt;

&lt;p&gt;当Unity3D在渲染调用时去设置OpenGL的渲染状态，OpenGL就会去检查显卡驱动程序里是否有该功能，如果有就会调用，如果是那些比较特殊的渲染接口，有些硬件驱动是没有的则不调用。&lt;/p&gt;

&lt;p&gt;如果把GPU硬件看做是最底层的那个模块的话，显卡驱动就是在硬件之上的模块，它是用来将指令翻译成机器语言并调用硬件的那个程序。&lt;/p&gt;

&lt;p&gt;显然OpenGL是在驱动程序之上的应用程序，我们可以把它看做是适配不同驱动程序的中间件。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/render-pipeline1.png&quot; alt=&quot;opengl&quot;&gt;&lt;/p&gt;

&lt;p&gt;上图中很清晰的表达OpenGL所处的位置，应用程序(如Unity3D)向OpenGL发送渲染指令，告诉OpenGL我的某个模型数据需要渲染或者说某个状态要设置，OpenGL发送指令给显卡驱动程序，显卡驱动程序将指令翻译为机器码后，将指令机器码发送到GPU，GPU先从显存中获得需要的数据再根据指令做处理。&lt;/p&gt;

&lt;p&gt;我们看到这个过程中显卡驱动程序只是做了传递指令消息的工作，指令从OpenGL那里发起到GPU接受到指令，显卡驱动只是起到了翻译的作用。因此我们在平常的讨论中，常常将显卡驱动程序的工作忽略掉，而用 OpenGL 与 GPU 的互动代替之。甚至有时会将OpenGL也忽略掉用GPU代替，或把GPU忽略掉用OpenGL代替，因为GPU的工作是机械式的它俩的工作完全可以看做一个整体。&lt;/p&gt;

&lt;p&gt;当然这里GPU不只会处理一次，OpenGL会通过显卡驱动发送很多次指令给GPU，让它处理一连串的操作，每次指令都有可能不一样，经过一系列的处理过程后，最终形成了一张屏幕大小的图像存放在缓存中，这时GPU才向屏幕输出最终画面。&lt;/p&gt;

&lt;p&gt;下面我们就来详细介绍一下渲染管线。&lt;/p&gt;

&lt;h3&gt;究竟渲染管线是什么？&lt;/h3&gt;

&lt;p&gt;上面所说的 OpenGL 通过驱动程序向 GPU 发送很多个指令，其实为了渲染很多个模型每一帧都会发送很多个指令，这一系列指令加起来，才形成一整个渲染过程，拥有完整的一个画面。&lt;/p&gt;

&lt;p&gt;渲染管线就是指令中完成一个绘制命令(drawcall)的流水线。这条流水线中有很多个环节，每个环节都自己干自己的事，就像工厂里的流水作业一样，每个节点的工人都会拧属于自己的螺丝，完全不会去管前面节点发生了什么事情，不过在现代GPU中也会做些流程上的优化，比如调整节点的顺序，但节点还是自顾自的工作，这部分会在后面的文章中提到。&lt;/p&gt;

&lt;p&gt;从严肃的理论描述来说渲染管线：是一系列数据处理的过程，这个过程最终的目的是将应用程序的数据转换到最终输出的缓存上最后输出到屏幕。&lt;/p&gt;

&lt;p&gt;我们说的再白话一点。渲染管线从接受到渲染命令后开始，分几个阶段处理了这些数据，这几个阶段分别是应用阶段，几何阶段，光栅化阶段，经过这几个阶段处理最终输出到屏幕上。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中每个阶段都有各自细分的流程，我们来一一讲述下。&lt;/p&gt;

&lt;h6&gt;应用阶段&lt;/h6&gt;

&lt;p&gt;应用阶段其实就是我们执行Unity3D引擎和代码的过程，在逻辑代码过程中，我们实例化了很多个模型或者UI（UGUI的UI也是网格，跟渲染场景中的3d模型从根本上是没有区别的），这些模型有贴图，有材质球，有网格，对于引擎来说，这个阶段在代码执行完毕后它知道了哪些模型需要被渲染，有哪些光源存在，摄像头的位置大小，于是就知道该如何通知GPU去渲染，总的来说这个阶段是准备渲染数据的阶段，为调用渲染准备。&lt;/p&gt;

&lt;p&gt;引擎除了知道有哪些东西(数据)需要被提交到GPU渲染外，在提交前还会对这些数据做很多优化工作，从而提高渲染性能。&lt;/p&gt;

&lt;p&gt;优化工作有很多种，从具体业务逻辑上做优化的方案，前面的章节中我们也讲到了很多很多关于在逻辑端上优化的工作，现在我们来重点说一下引擎的‘剔除’优化部分。&lt;/p&gt;

&lt;p&gt;Unity3D引擎会对不需要渲染的物体进行剔除，原本这是在GPU中做的事搬到了CPU上做。为什么要搬到CPU上做呢？因为在引擎端掌握的是第一手数据信息，如果从粗颗粒上下手做剔除工作，CPU会更快更方便，如果放到GPU去剔除，则更可能是三角形级别的裁剪，会浪费很多计算同时降低了功效。&lt;/p&gt;

&lt;p&gt;引擎在粗颗粒上是怎么剔除的呢，引擎当然不会像GPU那样去计算每个面是否可展示，因为这个操作对GPU来说更快，而是去计算更粗的颗粒，即整个模型的包围盒是否需要被剔除。&lt;/p&gt;

&lt;h6&gt;引擎会计算一个模型的包围盒，这个包围盒就是Unity3D的Mesh.bounds变量，这个包围盒为AABB包围盒，即一个顶点与最大最小长宽高，我们可以理解为包围盒是个立方体有8个顶点，这8个顶点决定了这个模型是否会被剔除，即只要有一个顶点在摄像机可视范围内(锥视体内或正交范围)，就不会被剔除，否则将被剔除。&lt;/h6&gt;

&lt;p&gt;引擎通过这种快速的判断包围盒与锥视体的关系来剔除不需要渲染的物体，以达到对粗颗粒的渲染优化。&lt;/p&gt;

&lt;p&gt;除此之外，对粗颗粒的剔除判断还有 occlusion culling 即遮挡剔除，也是属于应用阶段的优化剔除，它其实也是属于业务逻辑层的优化方案并不是所有项目都会使用，而通常只在第一人称视角的游戏上使用这种剔除方式，即被遮挡的物体不进入渲染队列。&lt;/p&gt;

&lt;p&gt;除了得到和优化需要渲染的数据外，应用阶段的最后时刻就是向GPU提交需要渲染的数据，即拷贝数据到显存中、设置渲染状态、渲染调用(Draw call)。&lt;/p&gt;

&lt;p&gt;在PC端中显存是最接近GPU的内存设备，将数据拷贝到显存中会加速GPU的工作效率，但在移动端里并没有显存，安卓和IOS的架构决定了它们只能用内存来为GPU提供服务，因此在手机端中没有拷贝数据到显存的这个说法，使用的都是同一个内存地址，除非我们需要读写这块内存内容才将它们另外复制一份。&lt;/p&gt;

&lt;h6&gt;那么什么是渲染状态？很多人都很困惑，其实就是一连串的开关或方法以及方法的地址指向。&lt;/h6&gt;

&lt;p&gt;比如：要不要开启混合，使用哪张纹理，使用哪个顶点着色器，使用哪个片元着色器，剔除背面还是剔除前面亦或都不剔除，使用哪些光源等等。&lt;/p&gt;

&lt;p&gt;通俗的来说，设置渲染状态，就是设置并决定接下来的网格如何渲染，有了渲染的具体方法，至于具体的渲染工作则是由GPU来执行。&lt;/p&gt;

&lt;p&gt;有了渲染的具体方法，就要调用渲染的具体对象，这就是渲染调用即 Draw call 做的工作。实际上 Draw call 就是一个命令，它的发起方是CPU，接收方是GPU，这个命令仅仅指向了一连串的图元（即点,线,面，我们可以理解为网格被拆分后的状态），并不会包含其他任何材质信息。&lt;/p&gt;

&lt;p&gt;每个 Draw call 前面都伴随着一个渲染状态的设置，因此整个渲染命令队列中都是一对对出现的，并且都是由CPU向GPU提交。&lt;/p&gt;

&lt;h6&gt;那么为什么要有这个渲染命令队列呢？&lt;/h6&gt;

&lt;p&gt;因为CPU和GPU相当于是两个大脑，它们是分离的，如果没有很好的协调机制，它们无法正常梳理自己的工作。一个命令缓冲队列就是用来协调CPU与GPU的，CPU只管向命令缓冲队列中推数据，GPU只管取数据并且处理数据，取一个处理一个，其他时间的都自顾自的忙自己的事。这个命令缓冲队列成了CPU与GPU的关系纽带。&lt;/p&gt;

&lt;p&gt;这条关系纽带(命令缓冲队列)很好的连接了CPU与GPU，但也成了它们之间交互的瓶颈，即我们通常所说的 Draw call 太多时GPU的工作效率比较差。其根本原因就是 CPU 发送了很多渲染命令后，只是空转的等待GPU完成这些渲染操作。&lt;/p&gt;

&lt;h6&gt;几何阶段&lt;/h6&gt;

&lt;p&gt;CPU准备好数据后，向GPU发送了渲染状态的设置命令和渲染调用命令后，接下来的工作就完全属于GPU了。&lt;/p&gt;

&lt;p&gt;接下来进入的是几何阶段的工作。几何阶段最终的工作目标是将需要绘制的图元转化到屏幕空间中，所以它决定了哪些图元要绘制，怎么绘制。&lt;/p&gt;

&lt;p&gt;图元即点、线、面。我们可以理解为网格的拆分状态，是着色器中的基础数据，在几何阶段作用最大。&lt;/p&gt;

&lt;h6&gt;几何阶段会经过几个节点，按顺序排列为，顶点着色器，曲面细分着色器，细分计算着色器，几何着色器，图元装配，裁减和剪切。如下图所示：&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺图
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中几何阶段分拆成了，顶点着色器、曲面细分着色器、细分计算着色器、几何着色器、图元装配、裁剪和剪切，6个节点。&lt;/p&gt;

&lt;p&gt;顶点着色器会对每个顶点进行逐一的计算，OpenGL会调用一个顶点处理函数来处理顶点数据。&lt;/p&gt;

&lt;p&gt;这个顶点处理函数就是我们可编程的部分，它可以很简单，只是数据复制并传递到下一个节点，也可以很复杂，例如变换矩阵的方式来得到顶点在屏幕上的位置，或者通过光照计算来判断顶点的颜色，或者记录和计算其他下一个阶段需要的信息。具体我们将在后面的章节中详细讲解。&lt;/p&gt;

&lt;p&gt;曲面细分着色器，细分计算着色器，几何着色器，都是可选的着色器。细分着色器包括曲面细分着色器和细分计算着色器会使用面片来描述一个物体的形状，并且增加面片数量使得模型外观更加平顺。几何着色器则允许增加和创建新的图元，这是唯一一个能自定义增加新图元的着色器。&lt;/p&gt;

&lt;p&gt;前面几个着色器节点处理的都是顶点数据，到了图元装配节点，它将这些顶点与相关的几何图元之间组织起来为下一步的裁剪和剪切工作做准备。&lt;/p&gt;

&lt;h6&gt;经历过前面几个阶段的变换，特别是在顶点着色器中的顶点空间转换，从模型空间到世界空间再到视口空间再到投影空间，Unity3D的Shader中常见的UNITY_MVP就是这个坐标空间转换的矩阵，再经过硬件上透视除法后得到了归一化的设备坐标，这使得到裁剪和剪切节点时，这个归一化的设备坐标使得裁剪会更加容易，不仅如此还对后面的深度缓冲和测试有很大的帮助。&lt;/h6&gt;

&lt;p&gt;归一化后的设备坐标(Normalized Device Coordinates, NDC)可以看做是一个矩形内的坐标体系，这个坐标体系是一个立方体的坐标体系，所有在这个坐标体系内的顶点的坐标都不会超过1到-1之间，无论x、y、z。&lt;/p&gt;

&lt;p&gt;为了能更好的理解经过空间转换后的顶点在后面几个阶段上应用的数据，有必要在这里来理解一下空间坐标系转换前后的样子，如下图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺图1

    缺图2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述图1中我们看到原本在视锥体上的物体，在经过空间矩阵转换后，视口从锥体变为了立方体，而原本在视锥体中的物体则从长方体变成了锥体，这是空间坐标系转化后的结果。&lt;/p&gt;

&lt;h6&gt;其中需要特别注意的是原本在视锥体坐标系上向前方向(forward)的X坐标轴变为了Z轴方向，整个立方体平面由x、y组成二维坐标体系。&lt;/h6&gt;

&lt;h6&gt;相当于，x、y坐标成为了可以映射到屏幕上的相对坐标，z坐标则被用来作为离屏幕有多远的数值参考，这是因为归一化后的NDC坐标系与原本视锥体坐标系相比其Z轴方向发生了翻转。&lt;/h6&gt;

&lt;p&gt;归一化坐标让坐标范围固定在1到-1之间，使得后续对图元数据的处理变得更加简单。不过归一化坐标范围在OpenGL和DirectX上有所不同，在OpenGL上x、y、z坐标范围在[-1,1]之间，而在DirectX上则是[0,1]之间，但这并不影响最终在屏幕上的表达，只是规则不同而已。最终他们都会进行简单的线性变换映射到屏幕的平面矩形范围内。虽然在屏幕映射时，OpenGL和DirectX两者的差异有出现了，OpenGL以左下角为(0,0)点，而DirectX则以左上角为(0,0)点，显然是两个商家因为竞争而故意造成的，还好主流的图形编程接口并不多，不管怎样差异已经存在了我们只能小心留意。&lt;/p&gt;

&lt;p&gt;说了这么多就是为了更好的理解几何阶段最后一步裁剪和剪切。我们将顶点转化到了归一化的坐标空间后，裁剪就容易多了，再通过图元装配，又有了线段和三角形数据，剪切就可以开始了。&lt;/p&gt;

&lt;p&gt;一个图元和可视范围关系，要么完全在范围内，要么完全在范围外，要么就是部分在里面部分在外面。完全在范围内的图元继续向下传递，不做任何操作，完全在范围外的图元则被剔除掉不再进入到后面的阶段，部分在视野内的图元则需要进一步剪切处理，把在范围外的部分剔除掉并在边界处生成新的顶点来连接没有被剔除的顶点。如下图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺图
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中一个完整的三角形两个顶点在范围内，一个顶点在范围外，剪切后在边界上增加了两个顶点，这是比较复杂的情况，另一个中比较简单的情况时一个顶点在范围里，两个顶点在范围外，剪切后形成新的两个顶点与范围内的顶点结合后替换了原来的三角形。&lt;/p&gt;

&lt;h6&gt;我们来分析下那种复杂的情况，因为经过裁剪后三角形由3个顶点变成了4个顶点，成为了4边形，所以需要对这个四边形进行切割。切割的方法其实很简单，选一个新增的顶点与原本的两个顶点替换原来的三角形，另一个新增的顶点与前一个新增的顶点再加上一个旧顶点(这个旧顶点一定是剪切后新增的这个顶点的线段里的)形成新的三角形。&lt;/h6&gt;

&lt;p&gt;不仅如此，裁剪不仅仅是视口的裁剪，还有会有背面裁剪(Back-Face Culling)，即剔除面朝视口反方向的面片，将在后面的Shader编写中详细讲述。&lt;/p&gt;

&lt;p&gt;至此所有几何阶段的操作都结束了，总体来说几何阶段处理的是顶点，以及计算和准备下一个阶段需要用到的数据。&lt;/p&gt;

&lt;h6&gt;光栅化阶段&lt;/h6&gt;

&lt;p&gt;光栅化阶段分为三个节点，光栅化、片元着色器、逐片元操作。&lt;/p&gt;

&lt;p&gt;其中光栅化可以分成，三角形设置、三角形遍历两个节点。&lt;/p&gt;

&lt;p&gt;三角形设置即Triangle Setup，由于前面阶段都是空间意义上的顶点和三角形，到了光栅化阶段我们更加需要的屏幕上的像素，于是三角形设置可以认为是将所有三角形都铺在屏幕坐标平面上，这样就知道了每个三角形片面在屏幕上的范围，它用三角形边界的形式表达了这个覆盖面。&lt;/p&gt;

&lt;p&gt;知道覆盖面还不够，因为屏幕中展示的画面都是以像素为单位计算的，所以一个三角形覆盖哪些像素需要依靠扫描变换(Scan Conversion)得到，这个像素扫描阶段就是三角形遍历(Triangle Traversal)。如下图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺图
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中，在三角形遍历节点中像素依据三角形三条边计算得到像素覆盖范围，即哪些像素被认为是这个三角形内的覆盖范围，再通过三个顶点中信息的插值得到每个像素的信息，信息包括坐标，深度，颜色，法线，纹理坐标等都是顶点上的信息经过插值得到。&lt;/p&gt;

&lt;h6&gt;经过光栅化的节点，我们得到了三角形内每个像素上的信息，我们称它们为片元，每个片元包含了诸多信息。这个片元将被传递到下一个阶段即片元着色器。&lt;/h6&gt;

&lt;p&gt;片元着色器(Fragment Shader)就如字面意思那样，是处理片元的地方，它是可编程的阶段，我们在这里可以编写很多我们喜欢操作来改变片元的颜色，或者也可以丢弃该片元(discard 或者 clip)。&lt;/p&gt;

&lt;p&gt;每个片元就相当于一个像素，只是比起像素，片元装载了很多的信息，这些信息都是通过前面三角形遍历时对三个顶点中的信息插值得到的。&lt;/p&gt;

&lt;p&gt;经过片元着色器的处理，也就是我们编写的片元着色程序的处理后，最终输出的也是片元，我们通常都在片元着色器中计算改变片元的颜色，最终得到一个我们想要的输出到屏幕的片元。&lt;/p&gt;

&lt;h6&gt;这里有一个重点，每次片元着色器处理片元的只是单个片元，也就是单个一个像素，对于片元着色器来说它并不知道相邻的片元是什么样，因此每个片元在处理时无法得到邻近的片元的信息。&lt;/h6&gt;

&lt;p&gt;得不到邻近的片元信息不代表我们就不可以受到邻近的片元影响，虽然每次片元着色器传入的和处理的都是单个片元，但GPU在跑片元着色器时并不是只跑一个片元着色器，而是将其组织成2x2的一组片元块同时跑4个片元着色器。如下图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺图
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上图中，描绘了4个片元组成的片元组，以及偏导数函数对它们的计算过程。我们可以通过ddx和ddy这两个偏导数函数来求得邻近片元的差值。偏导数函数可以用于片元着色器中的任何变量。对于向量和矩阵类型的变量，该函数会计算变量的每一个元素的偏导数。&lt;/p&gt;

&lt;p&gt;偏导数函数是纹理Mipmaps实现的基础，我们将在后面的章节中详细讲解。&lt;/p&gt;

&lt;p&gt;除了计算片元的颜色，我们还可以在片元着色器中丢弃某些片元(discard 或者 clip)，我们常说的Alpha Test就是一个应用丢弃片元来实现的效果，我们将在后面的章节中详细讲解 Alpha Test的原理与利弊。&lt;/p&gt;

&lt;h6&gt;片元着色器和顶点着色器是我们在着色器编程时最重要的两个节点，如果我们想要更通俗简单的理解顶点着色器和片元着色器的区别的话，可以认为：顶点着色器(包括细分着色器和几何着色器)决定了一个三角形应该放在屏幕的什么位置，而片元着色器则用这个三角形包括它的顶点和线段来决定三角形范围内的像素拥有什么样的颜色。&lt;/h6&gt;

&lt;p&gt;片元着色器输出片元后，进入了逐片元操作阶段，也是渲染管线的最后一步。&lt;/p&gt;

&lt;h6&gt;下一节继续讲解剩余的逐片元操作阶段。&lt;/h6&gt;
</description>
               <pubDate>Sat, 21 Sep 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/09/21/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A64.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/09/21/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A64.html</guid>
            </item>
        
            <item>
               <title>思路探讨(二十八) 如何应对彷徨</title>
               <description>&lt;p&gt;人时不时的总会彷徨的，每个人都一样。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;经常性的会迷失方向，看不清未来。无论我们前面有过多少清晰的认识，或者说多少深刻的觉悟，总是会在某个时刻感受到无法言语的痛苦。&lt;/p&gt;

&lt;p&gt;痛苦从何而来？是前面未知的道路吗，有可能，是疲劳吗，也有，是周遭向我们袭来的负能量吗，肯定有的，是因为没有计划使得自己总感觉是在胡乱的东奔西跑吗，是的。&lt;/p&gt;

&lt;p&gt;精神上和身体上的疲惫，说实在的无论怎么样都会累的，疲劳了就休息一下么，可能太久没有回家了，好想家，那就回家，感受下家的温暖。&lt;/p&gt;

&lt;p&gt;不工作也会累，工作也会累，说实在的其实很多时候精神力是要运作的，我们怎么运作有限的精力和时间，让最饱满的精力用在最重要的事情上，让零星的时间能变得更加充实，这是门学问，这一年多时间我一直在学习时间管理和自律，现在顿悟到精力管理也很重要。&lt;/p&gt;

&lt;p&gt;周遭的负能量能不能屏蔽掉，可以的，人很容易被周遭的环境打乱自己的节奏，我们需要更强大屏蔽能力，闭屏掉所有负能量。这一点我认为明星们做的很好，作为大众的明星，对他/她褒贬不一的评价从全国四面八方袭来，如果没有强大的屏蔽负能量的能力，人很容易就崩溃，但他们做的很好，可以做到自然的屏蔽掉负能量全力做自己。&lt;/p&gt;

&lt;p&gt;能不能为自己提早制定计划，计划确实赶不上变化，至少制定了计划可以让自己知道后面会遇到哪些困难，我需要制定每周的计划，每个月的计划，这样才能有效预知未来前进过程中可能遇到的问题、瓶颈、障碍、困难。&lt;/p&gt;

&lt;p&gt;彷徨无法避免，但我想能不能减少彷徨的频率？怎样才能减少彷徨的频率呢，我可不可以，自己给自己一点多一些安全感，这样就会少一点彷徨。&lt;/p&gt;

&lt;p&gt;怎么给自己多一些安全感？&lt;/p&gt;

&lt;p&gt;为未来优秀的自己积累知识、能力、财富。如果我足够优秀，知识量足够多，能力足够强大，财富足够多，我彷徨的频率肯定就少一些，对未来和当前肯定更加坚定一些，专注力也会更加好一些。&lt;/p&gt;

&lt;p&gt;我要怎样才能达到这个目标？&lt;/p&gt;

&lt;p&gt;关键在于，’积累‘！每天几页书，每天抽出时间学习一下，每天运动一下保持精力充沛，少一些娱乐把精力用在更加重要的事情上，每天这样做，每天。&lt;/p&gt;

&lt;p&gt;只有你肯执行下去、坚持下去，无论现在处于什么样的状态，5年后你一定就是人才，10年后你将是名人，20年后你将是巨星。&lt;/p&gt;

&lt;p&gt;有一次看到一个公众号发的一个消息，上面标题写着“如果一个人20岁开始自律20年会如何”，好奇的点进去一看，三个大字刻进我心中，“曾国藩”。&lt;/p&gt;

&lt;p&gt;于是我阅读了曾国藩的书，我并没有要成为曾国藩，但我明白了自律的重要性。&lt;/p&gt;

&lt;p&gt;从那一刻开始，我想，他自律20年，我能不能自律10年，我想试试，我要挑战自己，要突破自己的瓶颈。&lt;/p&gt;

&lt;h6&gt;良好的心态是人生的重要组成部分&lt;/h6&gt;

&lt;p&gt;保持一种辛苦的感觉才是正确的，辛苦表明你正在努力突破自己，当你感觉不到辛苦时，很有可能你正在慢慢向下滑坡，只是现在外在表象还没发生任何变化，所以无法让你引起足够的重视，一旦表象上发生了什么变化，说明量变已经造成了质变，这时已经来不及了，能做的也只有补救，如果也没有做什么及时补救的行动那么可能前面自己所建立的优势也就会像过往云烟那样消散而去，自己重新回到了被动和劣势的位置。&lt;/p&gt;

&lt;p&gt;不过只有辛苦的感觉其实是还不够的，在辛苦的基础上，每天都要感觉自己活得很充实，活得很对得起昨天的感觉，只有这样一步步往前走下去才是正确的道路。&lt;/p&gt;

&lt;p&gt;人在生命中的道路上行走，犹如在黑暗中行走那样，是看不到前方清楚的道路的，只有当你主动积极的去做一些事情时才能看清前面几米距离的道路，就这样每次看见的都只是前方几米距离的道路，永远都是这种状况。&lt;/p&gt;

&lt;h6&gt;如果不努力我们会一直处于这种看不清前方道路的处境中。&lt;/h6&gt;

&lt;p&gt;只有当你很努力并且持续不断的努力，其实也只有持续不断的努力才能让你渐渐的看清前方的道路，让你更少的时间处于焦虑之中，也只有在我们不断努力下才能强大自我，才能在如此残酷的社会竞争中找到自己的定位。&lt;/p&gt;

&lt;p&gt;我们自己是很难找到自己的问题的，愚蠢的人是不知道自己愚蠢的，但其实我们自己也不知道自己是不是愚蠢。&lt;/p&gt;

&lt;p&gt;有没这种可能，其实我们是愚蠢的，但在自己看自己是聪明的，自己看别人是愚蠢的。每个人确实是这样认为的。&lt;/p&gt;

&lt;p&gt;几乎所有人都这么认为，’我是聪明的，别人是愚蠢的‘，就因为这种盲目乐观的思维方式根深蒂固，我们才难以察觉和发现自己的问题。&lt;/p&gt;

&lt;h6&gt;不努力，我们是看不到自己的问题的。我很确信。不努力学习，不努力工作，不努力地去克制自己，我们可能永远都无法发现自己的问题。所谓的突破自我，也是因为在努力很久的情况下看清了自己的问题，从而解决了自己身上的问题，才最终得到了进阶和升华。&lt;/h6&gt;

&lt;h6&gt;人永远都是处于‘坏’环境下&lt;/h6&gt;

&lt;p&gt;刚工作那几年我一直以为是因为我个人的命途多舛才造就的这么多阻碍和困境，也一直以抱怨的态度对待环境，但渐渐的我发现，其实不只是我，天底下所有的人都处于这种‘坏’环境下，我们永远都感觉被束缚，被阻碍，被捆绑，被遏制，无论这个环境在外人看来有多好有多向往有多羡慕。&lt;/p&gt;

&lt;p&gt;其实最理智的方法是不去抱怨环境，环境永远是受限的，资源永远是缺少的，做好自己，解决自己身上的毛病才是最重要的。如果环境实在差的离谱，有更好的环境就直接去更好的环境，那里会更专注，努力的效果可能会更好，如果没有机会去更好的环境，那么就做好自己。&lt;/p&gt;
</description>
               <pubDate>Mon, 09 Sep 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/09/09/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A828.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/09/09/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A828.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(一) - 图形学基础2</title>
               <description>&lt;h3&gt;理解矩阵表达缩放的几何意义&lt;/h3&gt;

&lt;p&gt;缩放矩阵和旋转矩阵在几何意义上有着异曲同工之妙，我们同样用二维坐标系来表达缩放矩阵的两个 a,b 向量。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;举例来说，二维标准轴的旋转矩阵：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [1.5,  0]  等  [a]
    [0, 0.75]  于  [b]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们把 a和b 表现在二维坐标系中，即如图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中a，b两个向量可以形成了一个矩形，我们就假设这个矩形图像表达了a，b向量的缩放关系。当a，b被拉长时，这个矩形图像被也同样被拉长。&lt;/p&gt;

&lt;p&gt;其原理为向量与矩阵的乘法，我们知道&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    二维向量与二维矩阵相乘 = (x * m11 + y * m21, x * m12 + y * m22)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于我们上图中标准坐标系上的缩放矩阵来说的到的结果是 (1.5&lt;em&gt;x, 0.75&lt;/em&gt;y)，即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    (x*m11 + y*m21, x*m12 + y*m22) = (x*1.5 + y*0, x*0 + y*0.75) = (1.5*x, 0.75*y)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个结果表达了，缩放矩阵对向量缩放时非常直观易懂，因为除了对角线上的数字，其他位置的数字都是0。&lt;/p&gt;

&lt;p&gt;不过这种简单易懂的旋转矩阵，也仅限于标准坐标系中对标准轴的缩放。如果只有标准坐标系上的缩放计算，是远远满足不了我们的需求的。&lt;/p&gt;

&lt;p&gt;那么怎么计算对任意轴方向上的缩放呢？我们来看如下图所示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;沿 N 方向缩放 v 向量，其实和前一节中绕 N 轴旋转 v 向量有异曲同工之妙。&lt;/p&gt;

&lt;p&gt;我们需要根据所知道的推导这个公式，即我们已知v，已知 N，已知缩放因子k (k是一个单纯的数字) ，要求得v’。&lt;/p&gt;

&lt;p&gt;可以通过 N 和 v 求得投影 v1，通过 v 和 v1 求得他们的垂直向量 v2，再通过缩放因子 k 求得v1和v2缩放后的向量 v1‘ 和 v2’，最后通过 v1‘ 和 v2’ 求得缩放后的结果向量 v‘，即如下图公式。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样的，三维空间中，如果是标准坐标系上缩放，则缩放矩阵可以是很简单的对角线矩阵，即。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [scale-x, 0, 0]
    [0, scale-y, 0]
    [0, 0, scale-z]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也同样的，这种标准坐标系上的缩放完全满足不了我们的需求，我们需要沿任意向量上的缩放矩阵。&lt;/p&gt;

&lt;p&gt;同样的向量，同样的变化，同样的推导，最终结果为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终我们获得了，沿任意方向缩放的矩阵。&lt;/p&gt;

&lt;p&gt;这里不再重复叙述推导的过程，我们只要理解缩放矩阵的由来和推导的方式就可以了，我们最终的目的通过是解释原理来理解缩放矩阵的几何意义。&lt;/p&gt;

&lt;h3&gt;平行投影，镜像，切变的理解和几何意义&lt;/h3&gt;

&lt;h6&gt;平行投影&lt;/h6&gt;

&lt;p&gt;在上述几节中我们了解到了可以用矩阵去缩放任意点和向量，那么如果在缩放时某个轴上的缩放因子为零会变成是什么样的呢，如图所示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中模型所有的点都被’挤‘到了一个平面上，这种所有点都被拉平至垂直轴或平面上的做法就叫，平行投影，或者也可以叫正交投影。&lt;/p&gt;

&lt;p&gt;在标准坐标轴上的平行投影是一个很简单的矩阵，只要把那个投影轴上的缩放因子置零就可以，即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    二维上x轴平行投影

    [1, 0]
    [0, 0]

    二维上y轴平行投影

    [0, 0]
    [0, 1]

    三维上xy平面上的平行投影

    [1, 0, 0]
    [0, 1, 0]
    [0, 0, 0]

    三维上xz平面上的平行投影

    [1, 0, 0]
    [0, 0, 0]
    [0, 0, 1]

    三维上yz平面上的平行投影

    [0, 0, 0]
    [0, 1, 0]
    [0, 0, 1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然只是标准坐标轴上的平行投影还不够用，我们也需要任意直线或任意平面的投影矩阵，不过这次我们不需要再次计算任意轴上的平行投影，只需要通过前面计算过的缩放矩阵在任意方向或任意轴上的缩放矩阵就可以得到平行投影的矩阵，即如下图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过使缩放方向上的缩放因子变为零的方式，来获得平行投影矩阵。三维中也是一样，只是在三维中要 N 方向为垂直平面的方向而不是平行于平面的方向。&lt;/p&gt;

&lt;h6&gt;镜像&lt;/h6&gt;

&lt;p&gt;镜像其实挺容易理解的，平行投影是将某个轴上的缩放因子变为零，镜像就是在某个轴上将缩放因子变为负1，这样在缩放时就形成了‘翻转’的局面。如图所示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;坐标轴的四个象限，右上角的图为正常的图案，左边为对x轴翻转后的图案，下边为y轴翻转后的图案，右下角为x轴和y轴同时翻转的图案。&lt;/p&gt;

&lt;p&gt;镜像矩阵也和平行投影矩阵一样，可以用任意缩放矩阵来计算出对任意方向和轴的镜像矩阵，如图所示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中为任意方向的缩放矩阵在当缩放因子为-1时的公式，我们很容易就明白，镜像不过是缩放的一种特殊形式。&lt;/p&gt;

&lt;h6&gt;切变&lt;/h6&gt;

&lt;p&gt;切变非常特殊和有趣，它其实是一种坐标系‘扭曲’变换。这种坐标系的‘扭曲’变换将会被运用到对次级空间的坐标平移上。切变的形式如图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中y轴方向的向量中的x坐标被平移了。这是切变在x轴上的变化，我们也可以让切变在y轴上发生变化，如图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两种形式的切变都是通过位移x轴方向上的坐标或y轴方向上的坐标来达到的，其实我们可以理解为对次级维度坐标系的‘扭曲’。&lt;/p&gt;

&lt;p&gt;为什么要这么理解呢，因为它在仿射变化中起到了非常关键的作用，我们将在下面几节内容中介绍。&lt;/p&gt;

&lt;p&gt;切变的矩阵为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    二维x轴方向的‘扭曲’
    [1, 0]
    [s, 1]

    二维y轴方向的‘扭曲’
    [1, s]
    [0, 1]

    三维x,y轴方向的的切变
    [1, 0, 0]
    [0, 1, 0]
    [s, t, 1]

    三维x,z轴方向的切变
    [1, 0, 0]
    [s, 1, t]
    [0, 0, 1]

    三维y,z轴方向的切变
    [1, s, t]
    [0, 1, 0]
    [0, 0, 1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这几个矩阵看起来好像很简单，具体代表什么意思呢。我们用向量与矩阵的乘法表示就知道了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    向量p与3x3矩阵M的乘法 p * M = [x * M11 + y * M21 + z * M31, x * M12 + y * M22 + z * M32, x * M13 + y * M23 + z * M33]

    由向量与矩阵的乘法得知上面5个矩阵，当向量乘以他们时：

    第一个切变矩阵为向量x轴方向的偏移，(x + y * s, y)

    第二个切变矩阵为向量y轴方向的偏移，(x, x * s + y)

    第三个切变矩阵为向量x、y轴方向的起偏移，(x + s * z, y + t * z, z)

    第四个切变矩阵为向量x、z轴方向的起偏移，(x + s * y, y, t * y + z)

    第五个切变矩阵为向量y、z轴方向的起偏移，(x, s * x + y, t * x + z)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述经过矩阵乘法后，向量得到了切变的偏移，如果乘的是矩阵的话，则会对矩阵产生切变。下面一节平移中就会应用到切变的变化。&lt;/p&gt;

&lt;h6&gt;齐次坐标的平移矩阵&lt;/h6&gt;

&lt;p&gt;我们知道了3x3矩阵的线性变换中不包括平移这个操作，为什么呢？&lt;/p&gt;

&lt;p&gt;因为矩阵乘法的性质，零向量乘法总是变换成零向量，任何相同维度的矩阵乘法都表达不了零偏移。&lt;/p&gt;

&lt;p&gt;矩阵乘法其实很强大，经过我们上面的介绍我们已经知道了矩阵乘法可以表达旋转，缩放，投影，镜像，切变，可惜的是无法表达平移，怎么办？&lt;/p&gt;

&lt;p&gt;齐次矩阵就恰好满足了我们的需求，齐次矩阵它在原来的维度上增加了一个维度，用多出来的那个维度来表达了平移操作。即如下图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [1, 0, 0, 0]
    [0, 1, 0, 0]
    [0, 0, 1, 0]
    [x, y, z, 1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上图中用增加一个维度的方式用x，y，z分别表示了在x，y，z轴上的偏移。&lt;/p&gt;

&lt;p&gt;为什么这种方式就能表达平移操作？&lt;/p&gt;

&lt;p&gt;我们回忆下上一节说的切变的原理和过程，在某个轴不变的情况下对其他轴进行偏移，这就是切变。&lt;/p&gt;

&lt;p&gt;我们无法对当前空间的矩阵进行偏移，却可以通过增加一个维度，用不动新增的维度情况下，再用切变的方式来偏移次级维度，这其实就是个用切变解决平移问题的解决方案。&lt;/p&gt;

&lt;p&gt;在上述的图中描述了4维矩阵在第四维空间上的切变。有了平移矩阵，我们可以通过用3x3矩阵增加一个维度的方式，把原来无法表达的操作全都可以表达出来了。&lt;/p&gt;

&lt;p&gt;比如，我们需要一个将向量 v 旋转后再平移得到 v‘ ，旋转矩阵为R，平移矩阵为T，就可以用向量与矩阵的乘法，以及矩阵与矩阵的乘法来表达：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    v&amp;#39; = vRT

    R为：
    [r11, r12, r13, 0]
    [r21, r22, r23, 0]
    [r31, r32, r33, 0]
    [0,     0,   0, 1]

    T为：
    [1, 0, 0, 0]
    [0, 1, 0, 0]
    [0, 0, 1, 0]
    [x, y, z, 1]

    通过结合律 v&amp;#39; = vRT = v(RT)

    R与T相乘的结果为
    [r11, r12, r13, 0]
    [r21, r22, r23, 0]
    [r31, r32, r33, 0]
    [x,     y,   z, 1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上图中通过乘以旋转矩阵和平移矩阵就可以得到最终结果，或者使用结合律先将矩阵相乘。对于矩阵结合的方式，如果这种系列操作方式比较频繁，可以建立一个固定的常量矩阵，通过常量矩阵来计算结果，这样就省去了很多频繁的重复计算矩阵的过程，顶点着色器中的顶点坐标空间转换就是这样做的，它在整个程序开始执行前就已经计算好了一个变化的矩阵，这个变化的矩阵就叫做 MVP，即Model，View，Projection，它是由模型空间矩阵、观察者空间矩阵、投影空间矩阵相乘得到的结果，乘以此矩阵就会从模型坐标系变换为世界坐标系，再变换为观察者坐标系，最后变化为视锥体的裁剪空间。&lt;/p&gt;

&lt;p&gt;有了平移矩阵我们能做的事更加多了，能运用的地方也更加多了。这次我们用到了齐次矩阵，即通过增加一个维度的方式来表达当前维度无法表达的计算，用高一个维度的切变来表达操作次级维度的平移。&lt;/p&gt;

&lt;h3&gt;如何理解 Quaternion 四元数&lt;/h3&gt;

&lt;h6&gt;为什么不是欧拉角&lt;/h6&gt;

&lt;p&gt;欧拉角的定义是，x,y,z 分别表达了x轴上的旋转角度，y轴上的旋转角度，z轴上的旋转角度，即(20,40,50) 表达了在x轴上旋转20度，y轴上旋转40度，z轴上旋转50度。&lt;/p&gt;

&lt;p&gt;看起来很简单易懂就能定义坐标系上的旋转角度，为什么就不能使用它来表达所有的旋转角度，却还要使用四元数呢？其实是有原因的。&lt;/p&gt;

&lt;p&gt;首先欧拉角存在别名，100度的旋转角度可以用-260度来表示，370度角与10度角以及-350度角是相同的旋转角度，这种表达方式在计算上特别难统一。&lt;/p&gt;

&lt;p&gt;其次欧拉角在插值上存在些问题，一个-260度的角度和一个50度的角度进行插值是需要先进行转换的，先将-260度转换成100度，再进行插值才可以得到正确的结果。简单的别名问题虽然讨厌，但是可以转换角度的方式解决，但转换角度这种方式并不是一个靠谱的方式，在计算过程中会遇到相当多的麻烦。&lt;/p&gt;

&lt;p&gt;欧拉角这种周期性和旋转之间的不独立性造成了欧拉角在线性变化的计算中比较困难。因此我们需要寻找在计算过程中更加便捷的方法，不需要转换，没有别名，统一规格。&lt;/p&gt;

&lt;p&gt;四元数恰好就满足了这些需求，它在线性变换中非常统一而且灵活。不过它有一个致命的缺陷，就是在表现上让你人比较难理解，普通人一眼看不出一个四元数想要表达的旋转的方向和角度。&lt;/p&gt;

&lt;h6&gt;四元数的由来&lt;/h6&gt;

&lt;p&gt;四元数其实是一个我们生活中的“异次元”，这也是为什么普通人难以理解它的原因，为什么说它是一个“异次元”呢？&lt;/p&gt;

&lt;p&gt;我们所有的向量，坐标，矩阵，旋转，缩放，平移，都是建立在使用坐标系和空间矩阵计算的那一套计算体系上的，而四元数则不是，它特立独行，它计算所用的公式，并不是建立在传统的坐标系矩阵上，而是拥有自己一套“自有”的公式体系，即复数体系。&lt;/p&gt;

&lt;p&gt;四元数有两种记法即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    向量v 加 w分量 (v, w) 和 四个分量都分开 (x, y, z, w)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;某些情况下v分量更方便，而在另一些情况下分开记会更清楚。但其实这个w分量和x,y,z的相关度有但不是很大，因此不要被迷惑了，以为他们的值越大或者越小会怎样怎样的，其实和我们肉眼看到的是有所差别的。&lt;/p&gt;

&lt;p&gt;最早数学家们是用复数系统来表达二维中的旋转的。&lt;/p&gt;

&lt;p&gt;我们来回忆下什么是复数？&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    我们把形如z=a+bi（a,b均为实数）的数称为复数，其中a称为实部，b称为虚部，i称为虚数单位。
    其中虚数 i * i = -1；
    当z的虚部等于零时，常称z为实数；
    当z的虚部不等于零时，实部等于零时，常称z为纯虚数。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;数学家使用复数对(a, b)来表达二维平面中的旋转，他们把向量也定义为复数对，如果(a,b)为向量的话，那么就定义了 a + b * i，i为虚数，满足 i * i = -1，a为实轴的坐标，b为虚轴坐标，我们可以理解为x，y轴上的坐标。&lt;/p&gt;

&lt;p&gt;对于定义一个旋转复数，则为 (cos(β), sin(β)) 表达式为 cos(β) + sin(β) * i，i为虚数，β为旋转的角度。&lt;/p&gt;

&lt;p&gt;他们发现从平面上求得某个向量旋转 β 的结果，可以用向量复数对乘以旋转复数对的方式来获得，即&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片

    v = x + y * i
    r = cos(β) + sin(β) * i
    v&amp;#39; = vr = (x + y * i)(cos(β) + sin(β) * i)
       = (x * cos(β) - y * sin(β)) + (x * sin(β) + y * cos(β)) * i
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述图中的公式推导，乘法的运算看起来是不是跟传统的计算有点差异。因为我们使用的是复数做运算，其中i满足 i * i = -1。&lt;/p&gt;

&lt;p&gt;这是最早发明的二维向量旋转运算法则，由十六世纪被意大利米兰学者卡当提出复数后，经过达朗贝尔、棣莫弗、欧拉、高斯等人的工作，最后成形的数学体系。&lt;/p&gt;

&lt;p&gt;不过二维的上的旋转公式很快就不够用，无法对三维的旋转操作，旋转复数局限性太大。爱尔兰数学家 William Hamilton 终于在1843年找到了一种表达三维旋转的复数表达方式，即四元数就此诞生。&lt;/p&gt;

&lt;h6&gt;四元数的几何意义&lt;/h6&gt;

&lt;p&gt;四元数扩展了复数系统，它使用了三个虚部，即i，j，k，因此四元数的表达复数表达方式为&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    q = w + i * x + j * y + k * z
    其中i，j，k为虚数，即满足
    i*i = j*j = k*k = -1
    i*j=k, ji=-k
    j*k=i, k*j=-i
    k*i=j, i*k=-j
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和复数能用来旋转二维中的向量类似，四元数也能用来旋转三维中的向量。&lt;/p&gt;

&lt;p&gt;四元数被解释为角位移的轴一角方式。什么是轴一角？&lt;/p&gt;

&lt;p&gt;就是绕某个单一轴旋转一个角位移就能表达旋转的方式就叫轴一角，这个角位移其实就是一个和向量类似的表达方式，即(x,y,z)，只不过四元组用4个元素来表达罢了。&lt;/p&gt;

&lt;p&gt;再通俗点，四元组可以理解为绕 某个轴N 旋转的角位移，和欧拉角用x,y,z表达绕标准坐标轴旋转是同样的道理，只不过这个轴不再是标准轴，而是任意轴。&lt;/p&gt;

&lt;p&gt;这也就说明了，四元组不再受到标准轴的限制，它可以表达绕任意轴旋转的角位移。&lt;/p&gt;

&lt;p&gt;四元组表示为对任意轴 N 的角位移即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    q = [cos(β/2), sin(β/2) * N]
      = [cos(β/2), sin(β/2) * Nx, sin(β/2) * Ny, sin(β/2) * Nz]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;利用上图的四元组表达方式，假设我们绕的是某个单轴旋转，也就是在x轴上旋转 A 度，或者在y轴上旋转 B 度，或者在z轴上旋转 C 度，根据上述的公式，我们可以得到三个供旋转的四元数，即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    A&amp;#39; = [cos(-A/2), sin(-A/2) * 1, 0, 0]

    B&amp;#39; = [cos(-B/2), 0, sin(-B/2) * 1, 0]

    C&amp;#39; = [cos(-C/2), 0, 0, sin(-C/2) * 1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上图中的角度为什么是负的，因为我们在旋转点时的角度，和在旋转坐标系时的角度恰恰是相反的，因此操作旋转点的角度，其实就是旋转坐标系反方向的角度，即负的角度。&lt;/p&gt;

&lt;p&gt;现在我们要计算绕x轴上旋转A角度，并且绕y轴上旋转B角度，并且绕z轴上旋转C角度的四元组时，可以把 A‘，B’，C‘，这三个四元组乘起来，即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    A&amp;#39;B&amp;#39;C&amp;#39; = (A&amp;#39;B&amp;#39;C&amp;#39;) 最终计算得到

    [x,]
    [y,]
    [z,]
    [w]

    等于

    [cos(B/2)sin(A/2)cos(C/2) + sin(B/2)cos(A/2)sin(C/2),]
    [sin(B/2)cos(A/2)cos(C/2) - cos(B/2)sin(A/2)sin(C/2),]
    [cos(B/2)cos(A/2)sin(C/2) - sin(B/2)sin(A/2)cos(C/2),]
    [cos(B/2)cos(A/2)cos(C/2) + sin(B/2)sin(A/2)sin(C/2)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上图中得到的最后公式就是从欧拉角转换到四元数的计算公式。&lt;/p&gt;

&lt;p&gt;四元数的虽然在计算上很方便且通用，但在辨识度上却存在着严重的缺陷，人肉眼很难分辨某个四元数的旋转情况。但是没关系，我们只要理解它的原理，并且已经知道了四元数的几何意义，我们在运用四元数过程中将更加自如。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;p&gt;《3D数学基础:图形与游戏开发》&lt;/p&gt;
</description>
               <pubDate>Sat, 07 Sep 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/09/07/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A62.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/09/07/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A62.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(一) - 图形学基础1</title>
               <description>&lt;p&gt;游戏项目除了逻辑，模块，框架，架构，算法，还需要图形学的支撑，很多人在业务层面打拼了很多年也始终无法突破的原因就是对图形学研究还不够深。&lt;/p&gt;

&lt;p&gt;最终我们还是要面对图形的绘制和计算的，所以这块也是非常重要的部分，只是在使用了现代图形引擎之后，特别是使用了Unity3D之后，它为我们包装了很多工具和接口，用起来很方便，但就因为方便往往忘了图形学知识的重大意义。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;其实缺哪块都不行，没有逻辑，不懂得各个模块的编写手法，不懂得框架的搭建，不懂架构，或者不懂算法，不懂图形学，都是在无法完整的体现一个优秀程序员的知识面的，特别是对于那些需要在一个项目中当起顶梁柱的主程同学，对于每个部分的都需要了如指掌，特别是图形学部分，因为它很容易被忽视，也特别需要我们静下心来学习、理解、掌握。&lt;/p&gt;

&lt;p&gt;非常想从最最基本的讲起，但我们毕竟是一本面向中高级程序员的书，所以不在将更多篇幅用在对点，线，面，向量，坐标系等的文字说明和介绍上了。&lt;/p&gt;

&lt;p&gt;我们特别挑出了比较重要部分与Unity3D结合的来细致讲解一下。&lt;/p&gt;

&lt;h3&gt;Vector3 的意义&lt;/h3&gt;

&lt;p&gt;Vector3 有，x，y，z三个变量，我们一眼就识别它是个代表坐标的数据。&lt;/p&gt;

&lt;p&gt;不仅如此，其实它还可以代表 距离，速度，位移，加速度，还有方向。&lt;/p&gt;

&lt;p&gt;两个Vector3变量a，b的相减，就能得到一个从b点到a点的向量c。&lt;/p&gt;

&lt;p&gt;这个c是一个长度为a到b的距离并且具备b到a的方向的向量，c也同样是一个Vector3，那么为什么a，b就是坐标，c就是向量呢。&lt;/p&gt;

&lt;p&gt;其实任何一个Vector3变量，确定它是坐标还是向量，全靠我们如何定义它。&lt;/p&gt;

&lt;p&gt;我们可以定义a是坐标，也可以定义a是速度，至于如何定义怎么计算，全靠我们在后面的程序中怎么对待它。&lt;/p&gt;

&lt;p&gt;速度，位移，加速度，也是同样的道理。我们再举个例子。&lt;/p&gt;

&lt;p&gt;还是a，b定义为Vector3的坐标点，a减去b，除以1，可以认为我们向量除以了一个时间1秒得到了我们需要的有方向的速度。&lt;/p&gt;

&lt;p&gt;再比如，a点减去b点，得到c向量，那么任意坐标加上c就会得到与a和b同样的相对位置的d点，那么c就成了位移。&lt;/p&gt;

&lt;p&gt;如果现在是四个坐标a，b，c，d，当a减去b除以1秒得到了a到b的时的速度，那么b减去c除以1秒得到也是b到c时的速度，如果这两个速度再相减，依然是Vector3，而此时这个Vector3已经不再代表坐标和速度，而是一个由两个Vector3的速度得到的加速度了。&lt;/p&gt;

&lt;h6&gt;赋予给Vector3什么样的意义全靠我们用它们来计算什么。&lt;/h6&gt;

&lt;p&gt;我们挑选了几个Vector3比较重要的几何意义。&lt;/p&gt;

&lt;h3&gt;Vector3点乘的几何意义&lt;/h3&gt;

&lt;p&gt;向量a，与，向量b点乘的计算公式为&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    a·b = (x1,y1,z1)·(x2,y2,z2) = x1*x2 + y1*y2 + z1*z2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而点乘又有另外一个计算公式即为&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    a·b = ||a||*||b||*cos(β)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即用更直观的如图所示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中a向量与b向量的夹角为β，a向量和b向量长度不变的情况下，计算出来的值越大，也就是β值越小，说明a和b的夹角越小。&lt;/p&gt;

&lt;p&gt;相反，当计算出来的值越小，也就是β值越小，说明a和b的夹角越大。&lt;/p&gt;

&lt;p&gt;当β大于90度时，计算出来的是一个负数，也就是b指向的方向其实与a指向的方向是相反的。&lt;/p&gt;

&lt;p&gt;我们用这种方式可以用点乘得到一个判断依据，即当a和b点乘得到的数为正数时，两者的方向比较一致，并且在长度相同的情况下结果越大越一致，而当点乘结果为负数时，a和b两者的方向则是相反的，在长度相同的情况下，数值负得越厉害，相反的程度越一致。&lt;/p&gt;

&lt;p&gt;除了方向判断外，我们还可以用点乘来计算出β的角度，即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    β = arcos( (a·b) / (|a|*|b|) )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;// todo Unity3D里的Vector3点乘API&lt;/p&gt;

&lt;h3&gt;Vector3叉乘的几何意义&lt;/h3&gt;

&lt;p&gt;与Vector3点乘一样，Vector3的叉乘也是类似的向量与向量之间的计算公式，不同的是，叉乘的结果不再是一个数值，而是一个同样维度的向量。即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    a x b = (a1, a2, a3) x (b1, b2, b3) = (a2*b3 - a3*b3, a3*b1 - a1*b3, a1*b2 - a2*b1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两个向量a，b的叉乘，得到的是与a，b向量形成的平面垂直的向量c。&lt;/p&gt;

&lt;p&gt;那么c的长度多少呢，其实a x b的长度等于向量的大小与向量的夹角sin值的积，即&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    |a x b| = |a|*|b|*sin(β)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即c的长度大小与a和b向量的夹角有关。这样看来，如果β为0时，即a和b是平行的，c就是0长度，当β为90度时，即a和b互相垂直时，a和b的叉乘长度就是a的模乘以b的模。&lt;/p&gt;

&lt;p&gt;此外，|a x b|得到的|a|&lt;em&gt;|b|&lt;/em&gt;sin(β)这个公式，就是a和b形成的四边形的面积值，即如图所示&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中四边形的体积公式其实是，|b| * h，那么h怎么得到呢，我们可以用|a| * sin(β) 得到，因此就有了这个公式的演变，即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    四边形面积 = |b| * h

    由于 h = |a| * sin(β) 代入后 =&amp;gt; 四边形面积 = |b| * |a| * sin(β)

    =&amp;gt; 四边形面积 = |b| * |a| * sin(β) = |a x b|
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经过几个公式的转换，我们得到向量叉乘后的模就是四边形的面积。在3D中也是同样适用，因为两个向量确定一个平面，所以两个向量可以确定给一个对等边四边形的平面，从而可以用叉乘可以算出他们的面积。&lt;/p&gt;

&lt;p&gt;// todo Unity3D里的Vector3叉乘API&lt;/p&gt;

&lt;h3&gt;向量之间的投影&lt;/h3&gt;

&lt;p&gt;在几何计算过程中，我们经常用到‘投影’这种方式，在向量中投影也是常用的技巧。如图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中向量b 往 向量a投影得到 c，其实c就是向量a乘以某个系数得到的。这个系数可以认为是c的模除以a的模得到的。即&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    c = a * (|c|/|a|)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们不知道|c|的值，但是c和b的夹角β又能得到计算cos的公式即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    cos(β) = |c|/|b|
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;于是&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    |c| = |b| * cos(β)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再套入到计算投影向量c的公式上去时，就变成了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    c = a * (|b| * cos(β)/|a|)

    进一步 =&amp;gt; c = a * (|b| * cos(β) * |a|/ |a| * |a|)

    由于 |b| * cos(β) * |a| 等于 a与b的点乘公式，于是就有了

    投影向量c =&amp;gt; c = a * (a · b) / |a|^2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此经历了几个公式的转换，得到了b向量向a向量投影，得到c向量的公式。&lt;/p&gt;

&lt;p&gt;// todo Unity3D里的Vector3投影API，以及其他API&lt;/p&gt;

&lt;h3&gt;矩阵的意义&lt;/h3&gt;

&lt;p&gt;矩阵看起来比较玄乎，很多人看到矩阵这个词就头疼，其实耐下心来研究，会发现矩阵是很可爱的。&lt;/p&gt;

&lt;p&gt;矩阵五花八门，这些五花八门的矩阵使用频率非常低，我们常用矩阵其实没几种。&lt;/p&gt;

&lt;p&gt;在图形学计算中，我们常用的矩阵大小是2x2，3x3，4x4 矩阵，这种行与列的数量相同的矩阵，我们称为‘方阵’矩阵。&lt;/p&gt;

&lt;p&gt;在众多方阵矩阵中，常用到也是一些比较特殊的矩阵。如对角矩阵，即只有行列号相同的位置有数字，其他位置都是0的方阵矩阵。&lt;/p&gt;

&lt;p&gt;以及单位矩阵，即行列号相同的对角线上的数字都为1，其他位置都为0的方阵矩阵。&lt;/p&gt;

&lt;p&gt;这两种特殊的矩阵因它们简单易懂在图形学计算过程中也是非常常用的矩阵。&lt;/p&gt;

&lt;p&gt;矩阵间的计算我们可以罗列一下其实并不多。&lt;/p&gt;

&lt;p&gt;转置矩阵，就是把矩阵沿着对角线翻转一下，由于我们常用的是‘方阵’矩阵，所以转置矩阵后方阵矩阵还是同样的大小，只不过对角线两侧的数字对调了一下。&lt;/p&gt;

&lt;p&gt;矩阵乘法，如果是数字和矩阵相乘则，直接带入矩阵中的所有变量即可，这种标量的乘法其实就是扩大矩阵中所有的数值。&lt;/p&gt;

&lt;p&gt;如果矩阵与矩阵相乘则，A矩阵 x B矩阵，则需要一些附加条件，即矩阵A的列数必须与矩阵B的行数相等，否则无法相乘或者说相乘无意义。&lt;/p&gt;

&lt;p&gt;矩阵相乘后得到的矩阵，里面每个位置Cij(即C矩阵的第i行第j列)都是A矩阵的第i行向量与B矩阵的第j列向量点乘的计算结果，如下我们拿2x2方阵相乘做示意：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    A x B = [a11, a12]  x  [b11, b12]
            [a21, a22]     [b21, b22]

    = [a11*b11 + a12*b21, a11*b12 + a12*b22]
      [a21*b11 + a22*b21, a21*b12 + a22*b22]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上图对矩阵乘法公式做出了很简单易懂的描述，即Cij = Ai1 * B1j + Ai2 * B2j + Ai3 * B3j ... 即A的i行向量与B的j列向量点乘的值。&lt;/p&gt;

&lt;p&gt;逆矩阵，逆矩阵由运算矩阵相乘而来，由于矩阵与矩阵相乘也会得到标准的单位矩阵，即对角线都是1其余都是0的方阵矩阵，于是就有了一个矩阵与某个矩阵相乘等于单位矩阵时，这‘某个’矩阵就是该矩阵的‘逆矩阵’。&lt;/p&gt;

&lt;p&gt;然而不是每个矩阵都有逆矩阵的，一个明显的例子是若矩阵的某一行或列上的元素都是0，用任何矩阵乘以该矩阵，结果都是一个零矩阵。因此我们通常称一个有逆矩阵的矩阵为这个矩阵可逆，相反如果这个矩阵没有逆矩阵，那么就称这个矩阵不可逆。&lt;/p&gt;

&lt;p&gt;最后我们了解一下齐次矩阵，齐次矩阵也并没有什么神秘的，只不过是从我们认知的角度上划分了矩阵分量和w分量。&lt;/p&gt;

&lt;p&gt;齐次坐标就是将一个原本是n维的向量用一个n+1维向量来表示，齐次矩阵也是同样的道理，n维表达不了的事情用n+1维来表达，我们由浅入深来理解齐次矩阵会更加容易。&lt;/p&gt;

&lt;p&gt;在二维空间中，(x,y)只能代表平面上的一个点，或平面上的向量，无法表达不同平面的点和向量，当如果需要表达不同平面的点就需要扩容维度，齐次向量就起到了这个作用。&lt;/p&gt;

&lt;p&gt;齐次向量中有3个分量，即(x, y, w)，x，y分量和第三个神秘的w。&lt;/p&gt;

&lt;p&gt;为了能更加容易的理解w分量存在的意义，我们可以把w分量想象是不同平面的代表，即当w = 1的平面是标准平面，即(x, y, 1)为标准平面中的x,y坐标点，这个点在w = 1的这个平面中。&lt;/p&gt;

&lt;p&gt;当w不是1时，就是不同平面的上的点，如果想要将坐标投影到w = 1的平面上去，就需要除以w分量，即齐次坐标(x, y, w)映射在二维平面中标准坐标系中时为(x/w, y/w)。&lt;/p&gt;

&lt;p&gt;同样的道理，在三维空间中(x, y, z)只能代表标准坐标系中的点和向量，无法表达非标准坐标系，齐次向量补充了它的缺陷，齐次向量坐标为(x, y, z, w)，当w = 1时，我们可以认为xyz坐标是在标准三维空间中，当w != 1时，则认为xyz是在其他空间当中的点，如果想要将它们坐标映射到标准三维空间中去，则只要除以w，即(x/w, y/w, z/w)，就是实际在标准空间上的点。那么当 w = 0时怎么办，我们则认为它是‘无限远的点’，它描述的是一个方向而不是一个坐标位置。&lt;/p&gt;

&lt;p&gt;向量在空间中的运用还不够广泛，矩阵可以表达空间中的缩放、旋转、切变，但无法表达偏移，因此我们需要增加一个维度的矩阵叫做齐次矩阵来表达当下维度的偏移，即齐次矩阵。&lt;/p&gt;

&lt;h3&gt;由矩阵带来的旋转，缩放，投影，镜像，和仿射。&lt;/h3&gt;

&lt;p&gt;很多人都难以理解，矩阵为什么能做到旋转和缩放，或者怎么理解矩阵的旋转和缩放，这节我们就来用最通俗易懂的方式讲讲如何理解矩阵的旋转和缩放。&lt;/p&gt;

&lt;h6&gt;我们先来了解下，向量与矩阵的乘法。&lt;/h6&gt;

&lt;p&gt;首先我们要明白，我们用的都是方阵矩阵，即2x2，3x3，4x4的矩阵。由于矩阵与矩阵相乘必须是前置的列与后置的行数要相等才有意义，向量与矩阵相乘也是一样，如果向量不是前置的那个即左乘矩阵，或者向量是以竖列表达方式右乘矩阵，对于向量与矩阵的乘法来说都是无意义的，即如下图所示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中，第一个例子，当向量左乘矩阵，是无定义的结果，第二个例子，向量以竖列的表达方式右乘矩阵，也是无定义的结果，只有第三个例子和第四个例子，向量横向表达右乘矩阵，或竖向表达左乘矩阵，才有意义。&lt;/p&gt;

&lt;p&gt;最终我们得出了向量与矩阵的乘法公式结果为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    (x*m11 + y*m21 + z*m31, x*m12 + y*m22 + z*m32, x*m13 + y*m23 + z*m33)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至于向量的行向量的表达方式，和列向量的表达方式，其实都是可以行得通的，那么我们为什么要选择行向量呢，因为行向量表达更方便，无论是书写还是计算，行向量更加适合我们人类的习惯，因此我们选择了行向量来表达向量。&lt;/p&gt;

&lt;h6&gt;如何理解旋转矩阵&lt;/h6&gt;

&lt;p&gt;我们从 2x2 矩阵讲起，因为比起3x3矩阵2x2矩阵更加容易理解，而它们的原理一样。假设一个 2x2 的矩阵即&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [2, 1]
    [-1,2]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以认为它是由两个行向量a,b构成，a为(2,1)，b为(-1,2)，即&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [2, 1]  等  [a]
    [-1,2]  于  [b]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在平面坐标系中，a和b的表达如图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中a，b向量表达在2D坐标系中，是两个互相垂直的线段向量。&lt;/p&gt;

&lt;p&gt;我们把这两个a,b向量可以看做是，从两个标准向量(1,0)和(0,1)旋转并且放大过来的向量，即如图下所示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中，(1,0)和(0,1)向量，缓缓的旋转，并且放大，逐步变成了(2,1)和(-1,2)，即从原来的(1,0)和(0,1)向量上，旋转了β度并放大了2.236倍。&lt;/p&gt;

&lt;p&gt;这就是矩阵的几何解释，其实从形象简单，对于标准矩阵来说，旋转多少缩放多少，最终形成了另一个矩阵，这个结果矩阵就是我们需要的‘变换矩阵’。&lt;/p&gt;

&lt;p&gt;对于任何一个向量来说，乘以‘变换矩阵’就能得到‘变换矩阵’所要表达的旋转和缩放值，即&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [2, 1]
    [-1,2]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果这个矩阵表达了，向量旋转β度和2.236倍的缩放，那么任何二维向量乘以这个矩阵，就会得到在标准坐标系中以标准轴为基准旋转β度，并且以标准轴为基准放大2.236倍。&lt;/p&gt;

&lt;p&gt;这样一个看起来无关紧要的矩阵还是不够直观，我们来看看更直观的表达方式，如果一个矩阵要表达旋转β度，那么它的a,b的向量该是如下图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;a就是 [cosβ, sinβ]，b就是 [-sinβ, cosβ]，它们分辨表达了标准向量(1,0)和(0,1)旋转β度后的向量。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [cosβ,  sinβ]
    [-sinβ, cosβ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此任何向量乘以这个这个旋转矩阵都会在标准坐标系中以标准轴为基准旋转β度。&lt;/p&gt;

&lt;h6&gt;理解了二维空间的矩阵旋转原理，我们延伸到三维空间就容易多了。&lt;/h6&gt;

&lt;p&gt;三维空间的矩阵也可以像二维空间一样理解，用三个向量来表示空间中的矩阵，即&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [a]   [Ax, Ay, Az]
    [b] = [Bx, By, Bz]
    [c]   [Cx, Cy, Cz]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个绕x轴旋转β度的旋转矩阵为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [1, 0,     0]
    [0, cosβ,  sinβ]
    [0, -sinβ, cosβ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么一个绕y轴旋转β度的旋转矩阵为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [cosβ, 0, -sinβ]
    [0, 1, 0]
    [sinβ, 0, cosβ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;于是一个绕z轴旋转β度的旋转矩阵为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [cosβ, sinβ, 0]
    [-sinβ, cosβ, 0]
    [0, 0, 1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用β度所形成的向量来表达坐标空间中的旋转矩阵，这样的表达可以帮助我们更加清晰的理解旋转矩阵的几何表达意义。&lt;/p&gt;

&lt;p&gt;上述只是对某一个轴进行旋转β度，如果我们要对某个向量做各个方向轴上的旋转，比如在x轴上旋转20度，再在y轴上旋转30度，最后在z轴上旋转15度，相当于这个向量在坐标系中旋转了20°,30°,15°，这时我们该怎么办？&lt;/p&gt;

&lt;p&gt;有了上述对各轴的旋转矩阵，我们就能很容易计算出各方向上的矩阵，就如上面提的问题，在各轴上都有旋转角度，我们就可以用先旋转x轴，再旋转y轴，最后旋转z轴的方式，来计算最后的结果，如图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中，c向量乘以x轴旋转矩阵，再乘以y轴旋转矩阵，最后乘以z轴旋转矩阵，即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;c * Mx * My * Mz = c`(旋转后的结果)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中Mx为以x轴为基准旋转20度的旋转矩阵，My为以y轴为基准旋转30度的旋转矩阵，Mz为以z轴为基准旋转15度的旋转矩阵。c乘以Mx得到旋转x轴后的向量，再乘以My得到旋转y轴后的向量，最后乘以Mz得到旋转z轴后的向量，最终得到结果。&lt;/p&gt;

&lt;h6&gt;绕任意轴旋转&lt;/h6&gt;

&lt;p&gt;绕标准轴即x轴，y轴，z轴旋转，得到的矩阵还远远不够我们需要的计算，很多时候我们需要计算绕任意向量或者说绕任意轴的计算公式。&lt;/p&gt;

&lt;p&gt;让我们导出绕轴 N 旋转角度 β 的矩阵，即这个公式为 F(N, β)，也就是说这个公式满足:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    v * F(N, β) = v&amp;#39; (v向量绕 N 轴，旋转β度后的结果v‘)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;怎么解这个公式呢，其中v已知，N已知，β已知，还需要知道哪些变量，如图所示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中，v 到 N 的投影分量可以计算得到 v1，进而可以计算得到 v 到 v1 的垂直向量 v2，最后用垂直向量 v2 与角度 β 可以计算得到 v’ 与 v 到 N 的投影分量的垂直向量 v‘’，最后由 v‘’ 和 v1 计算得到 v‘。&lt;/p&gt;

&lt;p&gt;其中用到的计算方式有，向量投影计算公式，向量旋转计算公式，垂直向量计算公式，最后结果为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺少图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个看起来很复杂的，只要一步步推导就能得到的结果矩阵。&lt;/p&gt;

&lt;p&gt;其实结果并不重要，我们也记不住，但推导的过程是比较重要的，因为推导的过程运用到了很多其他方面的知识，加深了理解，虽然’用进废退‘的我们也很容易忘记这些公式，但只要心里知道有这个公式的存在，只要模糊记忆依然存在，在需要用到时搜索一下很快就能进入状态了。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;p&gt;《3D数学基础:图形与游戏开发》&lt;/p&gt;
</description>
               <pubDate>Sun, 01 Sep 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/09/01/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A61.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/09/01/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A61.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第十章，地图与寻路(四) 地图的制作与优化</title>
               <description>&lt;h3&gt;地图的制作与优化&lt;/h3&gt;

&lt;p&gt;场景的制作占到所有项目制作中非常大的一块工作内容，这里我们不说场景制作在美术层面上的制作技巧，我们来说说技术层面的。上节把地图编辑器说了一遍，这节我们就在地图编辑器之外说说，地图场景的制作与优化。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;我们先来说说场景中的地图，准确的说应该说地形，地形是场景中比较关键的一部分，在项目中地形的制作分为几种：&lt;/p&gt;

&lt;h3&gt;一种是手动拼接的地图。&lt;/h3&gt;

&lt;p&gt;手动拼接的地形比较常见，由3D设计师制作出来的3D模型作为地面的地形放置在场景中，相当于是一个模型落在场景上一样，只是这个3D模型很可能是有碰撞体的，碰撞体即 Unity3D的 Mesh Collider 根据项目的需要而增加物理系统的组件，一般都会直接使用 Mesh Collider，除非是完全平面式的，不需要碰撞组件，而是自己开发的一套基于平面的2D地图障碍与寻路，完全脱离了传统的物理系统。&lt;/p&gt;

&lt;p&gt;也有可能会使用Unity3D内置的地形，也一样相当于一个3D模型放置在场景中，Unity3D的地形可以任意的改变起伏，但地形的渲染消耗比较大，因此我们并不建议使用Unity3D内置的地形，而是建议地图设计师和3D模型设计师用 Maya 和 3DMax 等模型软件来构建地形的起伏，这种做法能更加容易的被设计师掌控以及自由发挥，也更加节省资源，对程序来说在处理性能优化时也更加容易一些。&lt;/p&gt;

&lt;p&gt;其他3D物体，比如石头，小石块，草，树，动物等也用同种方式放置在场景中，只是放置的手法可能不同，有的可能通过嵌入到prefab的方式，而有的可能通过地图编辑器加入到地图数据文件中，再在加载的地图时，从文件数据中得到要加载的实体的资源位置，再实例化到场景中。&lt;/p&gt;

&lt;p&gt;手动拼接的好处在于地形和地图是可以完全表达美术风格的，地形设计师和场景制作人员能根据自己的喜好和想象中的画面来自由得定制场景，他们可以任意的移动、旋转、缩放，甚至更换、修整、完善等，这能让他们对场景画面的把控有很大的自由度。&lt;/p&gt;

&lt;p&gt;能自由发挥当然是好事，但也带来了诸多不可控性，由于场景内物件没有统一的标准，因此在场景制作时常常会大量使用，小块的地形，甚至带有动画的地形，特效，以及半透明效果来增强画面的效果，画面效果增强的同时导致性能急剧降低。地图上的小件就更不用说了，在给予场景制作团队自由发挥的同时，我们可以想象同时造成了性能无法承受的问题。&lt;/p&gt;

&lt;p&gt;虽然这本质是没有制定和规范场景制作的要求的问题，但无论怎么规范，毕竟不是每个团队的执行力都是完美的，大部分的执行力都是差强人意的，所以都会或多或少的在优化阶段发现很多糟糕的、令人头疼的性能开销问题。&lt;/p&gt;

&lt;h3&gt;另一种是地图地形的程序拼接方式。&lt;/h3&gt;

&lt;p&gt;用程序拼接地图的主旨意图是希望能更好的为设计人员自由设计更好的地图而选择的方式，不仅仅是美术设计人员，还包括策划设计人员，需要在设计和性能上求得平衡点，这样所有的地图都由程序而生成了一个或者几个模型的结构铺满整个地图。&lt;/p&gt;

&lt;p&gt;这种方式来制作地图最常见的要属2D的RPG游戏了，2D角色扮演类游戏中，几乎整个屏幕的地形都需要用地图编辑器来建立和拼合的，当需要这类地图出现时时，程序会将地图数据加载进来后，对每一块的地图都进行动态的拼合，这样一来，整个地图就只有一个drawcall，因为它只是同一个模型。&lt;/p&gt;

&lt;h6&gt;我们先来看看2D RPG游戏中，是如何动态拼合整个地图的&lt;/h6&gt;

&lt;p&gt;很多2D游戏都通过了Unity3D实现，其实2D也是有Mesh、顶点、UV的概念，和3D比起来只是少了1个维度而已。在2D游戏中的地图拼接的手法也都是通过生成顶点和三角来完成的。&lt;/p&gt;

&lt;p&gt;我们可以设想整个地图就是一个大的矩形，地图中每个方块是这个大矩形中的一个格子，而每个格子都由2个三角形构成，既然我们能计算出每个方块的位置，我们就能计算每个三角的顶点和位置。&lt;/p&gt;

&lt;p&gt;我们知道的是，整个地图有多大，也就是这个大矩形在什么位置、有多大，每个方块矩形有多大，也就是每个格子有多大。我们知道有多少格子，有多大的格子，就能计算出，总共有多少个顶点，每个顶点的位置在什么地方，也就能知道三角形该怎么拼接了。&lt;/p&gt;

&lt;p&gt;简单得说，地图是一个大矩形，横切竖切N刀，成了一个个大小一样的小矩形或者正方形，这种有规则、大小一样、位置可寻的网格，是可以通过程序生成的。&lt;/p&gt;

&lt;p&gt;我们利用三角形的拼接方式拼接完矩形，再把地图方块的UV接上去，因为每块地形的图都不一样，所以我们需要在离线时就把所有的地形图都拼成一张图，即以图集的方式存储地图的方块。当我们将图接到网格上时，我们需要将指定的方块图的UV数值赋值给顶点，对每个方块里的2个三角形做UV设置处理，让图集中的方块图显示在网格中。&lt;/p&gt;

&lt;p&gt;伪代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;//生成地图&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Generate_map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//遍历每块矩形的方块位置&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width_count&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height_count&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;generate_trangle_by_rectangle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texture_info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;CombineAdd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;//生成矩形方块所需要的，4个顶点，4个索引，2个三角形，2个三角形的顶点索引，以及三角形的uv位置。&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;generate_trangle_by_rectangle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texture_info&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//矩形的4个顶点&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;//顶点增加后的索引位置&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point_index1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point_index2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point_index3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point_index4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;//三角形的生成时的顶点&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;trangle1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;trangle2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;//三角形顶点的索引信息&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;trangle_index1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point_index1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point_index2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point_index3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;trangle_index2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point_index3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point_index4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point_index1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;//4个uv点位的信息&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point_uv1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uv_x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uv_y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point_uv2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uv_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uv_y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point_uv3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uv_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uv_y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point_uv4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uv_x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uv_y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;Mesh&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Mesh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;trangles&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trangle1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tangle2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;trangles_index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trangle_index1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trangle_index2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uvs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point_uv1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point_uv2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point_uv3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point_uv4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码中，对所有地图中的方块都进行遍历，在遍历中生成了每个方块所需要的顶点，顶点索引，uv点，进而生成三角形，三角形的索引。在生成完毕后，将这些生成的数据，与前面生成的数据进行合并，使得整个地图是一个一体化的网格，只产生一个drawcall。&lt;/p&gt;

&lt;p&gt;用程序拼接地图的好处是可以任意的通过地图编辑器来改变地形地貌，拼接完成的地图在渲染上的代价也相当的小，而且假如想换个地图的地形，只要更换贴图就可以了，什么样的贴图就可以产生什么样的地图。&lt;/p&gt;

&lt;p&gt;不过同时也带来了很多弊端，必须要有成形的地图编辑器支撑，前期工具的工作量比较大，稍微提高了点门槛，并且地图元素仅限于贴图中的元素，当地图元素增加到一定范围，就要扩大地图的贴图时就要重新排列地图信息。这一连套的工具链包括地图编辑器是必要的前提条件。&lt;/p&gt;

&lt;h6&gt;3D RPG角色扮演类游戏中，也时常常使用这种技巧来绘制游戏地图，曾经在日本风靡一时的《白猫计划》就是这样做的。&lt;/h6&gt;

&lt;p&gt;这种程序拼合的地图，策划设计师、关卡设计师可以在地图编辑器上，任意的绘制、拼接、同种类型的不同样式的地图（即在同一张贴图内容中的模型和地图元素），因此大大缩短了大量的场景试错时间。它能大量的生成出不同样式的地图，而不需要制作大量的不同类型的3D模型，大大缩短了项目时间进度，深受游戏制作人的喜爱。&lt;/p&gt;

&lt;p&gt;那么在3D地图中是怎么拼接方块地形的呢？看上去比2D更加复杂的事情，其实更加简单。&lt;/p&gt;

&lt;p&gt;首先，在3D地形模型制作时需要制定一下模型的规范。&lt;/p&gt;

&lt;p&gt;3D模型的长宽必须和地图切割后的方块长宽是一致的。3D地图中，不需要我们自己来拼接三角形了，因为已经有了固定的地形模型，但对每个地形模型就需要有规范。假如规定每块地形都是 1 x 1，那么在制作和拆分地形模型时就要按规定来，每个3D地形模型都必须以 1 x 1 的标准来定制，否则不可用。当然并不一定要 1 x 1，也可以是2 x 2、 3 x 3等等，只是当标准制定完毕后，地形模型的制作必须要按照标准来做，每个元素都相当于一个地图块。&lt;/p&gt;

&lt;p&gt;其次，所有地形模型的纹理贴图都必须并在一张贴图上制作。因为只有这样才能在合并模型才能合并，并且在合并后让这么多 1 x 1 的小方块只需要1个drawcall渲染调用就可以了绘制所有的地图。也只有这样，才能解决太多模型需要渲染导致的爆量drawcall问题。&lt;/p&gt;

&lt;p&gt;然后，在3D地形模型制作时也是需要相当的考量的，因为这个地图都被拆分成了N种类型的地形方块，所以在制作的初期需要对整个地形有哪些类型的需求，需要有一个设计、交流、探讨、决策、改进的过程。&lt;/p&gt;

&lt;p&gt;并且在读取地图编辑器编辑的数据后，实例化场景地图时也需要增加些许逻辑，这些逻辑是为了适应更好的模型拼合，比如当左边是某个模型时，为了能与它完美的拼接，当前这个格子上的模型必须是迎合它的那个，就像我们在制作和拆分城墙时那样，当城墙处于拐角处时，我们需要用拐角模型代替，还要判断它的左右前后有没有城墙，假设左边有城墙则应该选用带有连接左边城墙拐点的3D城墙模型，右边的、前面的、后面的、以及前后都有的，左右都有的，等等，总共9种情况都有不同的9种拐角城墙所代替，就是为了完美契合周围的环境而进行的额外的处理。&lt;/p&gt;

&lt;p&gt;最后的合并模型步骤就简单的多了，切分开来后的模型，按地图数据文件所描述的位置，放在指定的位置上，并向上面所说的选择好适配的模型，最后调用Unity3D的 Mesh.CombineMeshes 合并所有模型。&lt;/p&gt;

&lt;p&gt;在合并后可能发生衔接处的问题，用程序生成面片来补救很难做到完美的展示，我们还是建议调整3D模型在接缝处的面片与网格，只有这样才能调整出一个完美的或者说完全可掌控的地图造型。&lt;/p&gt;

&lt;h3&gt;常规场景的性能优化&lt;/h3&gt;

&lt;p&gt;上面几节阐述了地图的拼接方式，其中用程序拼接合并地图块的方式确实大大降低了 Drawcall 的数量，提升了渲染的性能，但只针对可拆分的地图类型项目，对大多数游戏类型来说地图是不可拆分成小块的。因此我们还是需要更多的针对常规场景讲解优化的方法和技巧。&lt;/p&gt;

&lt;p&gt;首先我们要清楚的是，是什么造成了场景的低渲染效率。我们在这里罗列一下主要的几个问题：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1.渲染面数太多，GPU压力太大。

    2.渲染管线调用次数太多，即drawcall太多，GPU排队渲染的队伍太长

    3.贴图太多太大，导致显存的带宽负荷太重

    4.动画太多，蒙皮的计算消耗的CPU太大

    5.实时光的GPU开销太大
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实还有很多很多问题需要解决，比如实时阴影导致的 Drawcall 太多，增大了渲染调用的排队长度，以及透贴太多，Overdraw 重绘问题比较严重，还有比如单个物体需要的Pass渲染太多，一个物体需要绘制多次才能完成等等。这些问题也是很重要的，但这节我们重点解决这最重要的5个问题。&lt;/p&gt;

&lt;h3&gt;1.渲染面数太多，GPU压力太大。&lt;/h3&gt;

&lt;p&gt;渲染面数太多分两种，一种是整个场景3D物体太多导致的面数多，一种是同屏展示的面数太多。&lt;/p&gt;

&lt;h6&gt;前一种Unity3D引擎会裁切掉在摄像头之外的物体，不让他们进入到渲染管线以减少消耗，虽然裁切也会消耗小部分CPU，但毕竟比起渲染整个物体要小的多。&lt;/h6&gt;

&lt;p&gt;在进入渲染管线前每个3D物体能计算出或者已经计算好了一个包围盒，即Bounds，这个包围盒由8个顶点组成，加上旋转矩阵就能计算出每个顶点是否在摄像头的锥形体范围内。&lt;/p&gt;

&lt;p&gt;裁切的算法简单说是这样的，如果有包围盒8个点中只要有一个点在锥形体内，就认为是需要渲染的不可被裁剪，如果8个顶点都不在摄像头的锥形体范围内，才认为是不需要被渲染的，然后Unity3D引擎会阻止这个模型渲染即在渲染调用前裁切掉。&lt;/p&gt;

&lt;p&gt;这种Unity3D引擎上的裁剪，帮助我们屏蔽掉了很多不需要渲染的物体，虽然裁剪也会花去些许CPU，但比起要绘制一个3D物体来说要少的多的多。&lt;/p&gt;

&lt;p&gt;这种裁剪的好处是，使得我们只要关心摄像头范围内的面片就可以了，但是如果是一个模型很大，或者常常我们项目中有合并的模型范围从南延伸到北贯穿整个场景，一旦这个模型很大，覆盖了整个场景，包围盒总有一段在摄像头内就不会被裁剪，这样就会浪费很多不必要的GPU计算。&lt;/p&gt;

&lt;p&gt;除了Unity3D引擎内的裁剪，OpenGL即渲染管线也会对每个三角形进行裁剪，不过三角形的裁剪要比8个顶点的包围盒裁剪要费的多。所以我们尽量还是能用包围盒裁剪就用包围盒裁剪方式，将更少的三角形面片带入渲染管线。&lt;/p&gt;

&lt;p&gt;传入渲染管线的所有三角形顶点管线对它们做的第一个动作就是裁剪，其次才是计算，网格根据摄像头锥形体进行裁剪，所有不在锥形体范围内的顶点都会被裁掉。但是这种裁切的效率比起8个顶点的包围盒效率要低得多。&lt;/p&gt;

&lt;p&gt;场景面数太多时，如果没有或者很少有这种从南到北的模型时，渲染的压力就取决于摄像头中可展示的物体的数量，但是如果单个模型通常会覆盖很多天南地北的网格，那么GPU对裁切计算的压力就会增大。&lt;/p&gt;

&lt;h6&gt;后一种同屏面数太多的情况，就是因为3D模型都在摄像头范围内，要么就是模型太多，要么就是模型面数太多，要么就是摄像头太远而显示距离太大造成的。&lt;/h6&gt;

&lt;p&gt;最简单直接的方法就是，拉近摄像头，或者拉近摄像头显示距离，让更少的模型进入视野内。当视野范围内的物体少了，需要渲染的模型面数也就少了，自然CPU和GPU的消耗也就少了。虽然这是最拙劣的办法，也是我们需要调整和调节的参数，让视线范围在一个合理的范围内。&lt;/p&gt;

&lt;p&gt;其次是减少模型面数，或者减少模型在场景中的数量，降低不必要的高品质。3D模型面数的降低，不是一两天就能完成的事，一个模型面数的降低也伴随着画面质量的降低，又要面数低又要品质高那是痴人做梦，所以我们找到一个平衡，也要制定一个容忍度，即前面几章提到的，要将模型面数在研发期间控制在一定范围内。模型数量在场景中的数量的降低，或者更直接的方式，去除了许许多多本来需要渲染的三角面，自然就省去了诸多CPU和GPU消耗，但也伴随着场景变得空旷不饱满不生动。&lt;/p&gt;

&lt;h6&gt;那么有没一种方法可以不更重制3D模型面数，不减少模型在场景里的数量，不缩短摄像头显示距离，也能优化性能的。有。&lt;/h6&gt;

&lt;p&gt;世上没有免费的午餐，想降低GPU的消耗，就得用增大内存来换。&lt;/p&gt;

&lt;p&gt;LOD，即Level of detail，就是此道。用内存换GPU。&lt;/p&gt;

&lt;p&gt;我们把每个3D模型，做成多个不同细节级别的模型，当摄像头拉远时，启用形状相似面数更少细节的模型，当摄像头拉近时，则启用形状相似面数更多细节的模型。&lt;/p&gt;

&lt;p&gt;这样即使众多的模型在摄像头范围内需要渲染，也只有几个模型在靠近摄像头的，而大部分都是远离摄像头的。&lt;/p&gt;

&lt;p&gt;远离摄像头的3D模型面数很少，即使数量众多，它们所展示的低等级的面数的总和也是可以接受的。&lt;/p&gt;

&lt;p&gt;我们常提到的 Mipmap 也是这种方式在运作，对于距离远的物体，启用更小的纹理贴图，而与摄像头距离近的物体则使用更大的纹理贴图。这样在渲染时就传送进渲染管线的贴图就更小了，宽带压力小了，GPU消耗自然少了。&lt;/p&gt;

&lt;p&gt;天下没有免费的午餐，提升了CPU和GPU的性能，就会增大内存的消耗，如果内存消耗太多也是得不偿失的，因此在考虑怎么分级、分多少级的细节级别上也需要一番考量，针对不同的项目分级的层数也是不同，拿大型MMORPG来说，那种可以在天上飞的游戏，看到的物体自然就很多，如果LOD分级少了画面则会显得突兀，而中小项目如果LOD分级太多，则加大了内存量和制作时间，得不偿失。&lt;/p&gt;

&lt;h3&gt;2.渲染管线太多，即 Drawcall 太多，渲染管线太多&lt;/h3&gt;

&lt;p&gt;除了面数带来的GPU计算压力，渲染管线太多也是造成GPU压力的一大问题。&lt;/p&gt;

&lt;p&gt;渲染管线太多的问题，大都是因为场景中的模型物体太多，或者使用的Shader中的管线太多，或者这两者同时造成的。&lt;/p&gt;

&lt;p&gt;其实这个问题是最好解决的，‘干掉’在场景中众多的模型物体，以及‘注释掉’Shader中不必要的管线。&lt;/p&gt;

&lt;p&gt;当然这是最粗暴的做法，无疑将美术设计师，场景设计师的辛勤工作的成果给抛弃了。但也不是不可为，适当的‘干掉’一部分不必要模型的其实是有助于场景制作的。&lt;/p&gt;

&lt;p&gt;那么我们能不能在不毁坏场景的前提下做些优化呢。可以的。&lt;/p&gt;

&lt;p&gt;关键点就在于‘合并’二字。&lt;/p&gt;

&lt;p&gt;为什么呢？因为一个屏幕内需要渲染的面片数量是一定的，即我们不减模型在场景中的数量，不减单个模型面数的情况下，一个画面上需要渲染的三角形面数是固定的数量。&lt;/p&gt;

&lt;p&gt;我们每次调用管线渲染（即drawcall）传给渲染管线的三角形数量却比较少，所以调用的次数比较多。&lt;/p&gt;

&lt;p&gt;我们能否合并这些面片数据，然后一次性得传递给管线，将原来需要很多次的管线调用变成一次，只有这样才能大大降低 Drawcall 的数量，降低渲染调用次数。&lt;/p&gt;

&lt;p&gt;那么减少渲染管线即减少 Drawcall 的数量究竟有什么好处？&lt;/p&gt;

&lt;p&gt;减少了渲染管线的数量，即降低了Drawcall的数量后，尽管并没有减少任何需要渲染的面片数量，只是每次传递给渲染管线的顶点和面片数增多了，传递的次数减少了，但是三角形数据进入渲染管线后，就可以开启GPU并行处理了，单行线变成了8车道甚至16车道单行线，速度加快8-16倍。&lt;/p&gt;

&lt;p&gt;原本调用一次渲染，就要在队列中等待管线渲染完毕后才进行下一次渲染，合并后就不同了。不再是像以前那样调用这么多次Drawcall，每次渲染一个画面时Drawcall的队伍都要排的老长老长的，都等在那排着队等待一个个的交给GPU处理，效率低下。&lt;/p&gt;

&lt;p&gt;合并后就不再是这样了，排队的数量少了，队伍短了，虽然每个排队的‘人’都很‘胖’（即数据量很多），但是一旦进入处理阶段，8-16条生产线并行处理这些数据，比前面排着老长得队伍一个个处理要来的高效的多。&lt;/p&gt;

&lt;p&gt;所以我们要想方设法的合并各种模型。怎么合并？&lt;/p&gt;

&lt;p&gt;其实Unity3D引擎自带有多种合批方式，前面几个章节有详细的介绍，这里我们简单提一下，Unity3D引擎中有动态合批、静态合批、GPU Instancing 三种合批方式，其中动态合批，合并的普通的模型，但要求比较高，包括模型面熟、Shader的Pass数等，静态合批也有自己的规则，它通过消耗的内存来换取CPU，而GPU Instancing 的原理是通过一次性传递更多的数据来达到合批Drawcall的目的。&lt;/p&gt;

&lt;p&gt;这里我们并不想通过Unity3D自动的方式来做‘合并’的操作，我们希望能够自己掌控‘合并’效率和效果。部分原因也是因为引擎自带的合批方式通常都是通用的合批方式，规则比较严格，合批率比较低。所以时常放弃它们而选择自己动手丰衣足食。&lt;/p&gt;

&lt;p&gt;‘合并’也分实时合并，与，非实时合并两种方法：&lt;/p&gt;

&lt;p&gt;其中实时合并也会消耗大量的CPU，因为它要读取多个模型，并创建新模型数据，不断的创建新模型数据，就会导致CPU的消耗。这里不再详细介绍，前面章节已经介绍过，这里简单点说一下，把相同材质球，相同贴图的模型，读取它们的模型数据，生成一个新的合并后的模型，然后隐藏原有的模型。如果很多模型材质球效果一样，但贴图不一样，我们可以在线下手动合并它们的贴图后再放到线上合并。&lt;/p&gt;

&lt;p&gt;非实时合并则全是线下的手动合并，即大家常说的静态合并。Unity3D静态批处理的规则比较严格，即要求相同材质球相同贴图还要形同模型，而且内存消耗比较大，因此我们还是建议使用自己手动合并的方式，即手动拼接场景中静态不动的、有相同材质球、相同贴图的模型，手动拼接成一个模型，也可以用插件来操作，比如 MeshBaker，通过 MeshBaker 来制作和合并模型与纹理贴图。&lt;/p&gt;

&lt;p&gt;静态合并Mesh的好处就是，游戏中不需要实时消耗CPU去合并模型，节省了不少CPU，也降低了很多Drawcall的数量。&lt;/p&gt;

&lt;p&gt;当然过犹不及么，如果把所有的在场景内的物体全部合成为一个模型，整个地图，无论摄像头能不能看到的地方都合并了，那么GPU的压力也同样很大，因为这样的话我们前面提到的引擎自身做的第一层包围盒裁剪就不生效了。渲染时会一股脑的将整个模型数据塞进渲染管线中，GPU在裁剪时的压力就会很大，因为它要裁剪整个地图的所有模型面片，计算量也是巨大的。&lt;/p&gt;

&lt;p&gt;因此我们在静态合并时也要适度，即合并周围距离不太远的、可以合并的模型。这样即减少 Drawcall 次数，也同时降低了GPU裁剪的压力。&lt;/p&gt;

&lt;h3&gt;3.贴图太多太大，显存的带宽负荷太重&lt;/h3&gt;

&lt;p&gt;贴图太多，宽带压力太大，导致的问题，主要是因为GPU在渲染时，需要将内存的纹理拷贝到显存中去才能使用在GPU中。所以拷贝的消耗和显存的消耗也是很大的。不过，显存只存在于主机和PC游戏中，在手机中没有显存的概念，只有内存，因此都是内存和内存的拷贝。&lt;/p&gt;

&lt;p&gt;在手机中只有内存与内存的拷贝，那么岂不是内存中的贴图纹理有两份？是的，如果引擎没有做额外处理的话，按照常理GPU的工作流程确实会是拷贝一份纹理到另外一段内存中，导致一份纹理占用了两份内存。但是毕竟引擎还是做了很多优化的，Unity3D就做了这方面的优化，当贴图没有勾选Read/Write 时Unity3D就认为该贴图是不会被改变的，当GPU需要该贴图时只是把原来在内存中的值传进去，而不是拷贝整个纹理，而当我们 勾选了 Read/Write 后Unity3D就认为该贴图是会被改变的，因此当GPU需要该贴图去渲染的时候，则会重新拷贝一份纹理贴图，这份纹理贴图专门给GPU渲染使用，避免GPU的纹理贴图随时被更改。&lt;/p&gt;

&lt;p&gt;因此我们在贴图设置时，首先要注意 Read/Write 选项是否需要被开启，绝大部分贴图是不需要被开启的，这些贴图被开启后造成的2倍内存也是不必要的。&lt;/p&gt;

&lt;p&gt;贴图太大太多，最好的办法是缩小贴图和压缩贴图。&lt;/p&gt;

&lt;p&gt;看起来挺简单的，其实我们在实际项目中，我们不可能随意的去缩小和压缩贴图，这样很容易导致项目因贴图质量太糟糕而影响画面效果。&lt;/p&gt;

&lt;p&gt;我们需要针对每个部分的贴图逐一去了解和设置，其实每个功能部分的贴图都有其用途。比如UI中的贴图分，图集和Icon图片，图集一般都是无损质量，因为要保障画面，也不需要 Mipmap采样，Icon图也是一样。虽然也不是不能压缩，不过压缩后确实UI的质量会遭到比较显著的降低，针对低端机时确实可以这样去做，因为无损的贴图在内存上和压缩的贴图通常有5-10倍的差距。&lt;/p&gt;

&lt;p&gt;又比如3D模型的贴图，这些模型纹理贴图，通常都是2的幂次存在，因为2的幂次的纹理在GPU中处理起来比较顺手，而他们也通常是可以压缩的，并且带有 Mipmap 采样生成标记的。要压缩多少，压缩到什么比例才适合，每个项目都不一样，因人而异，大部分时候我们都是指压缩到中位数即Normal Compress普通压缩。&lt;/p&gt;

&lt;p&gt;贴图的大小确实比较重要，每个项目在开始时都要好好的规范一下，因为只有遵守良好的规范，项目才能将内存限制在可控范围内。&lt;/p&gt;

&lt;p&gt;幸运的是，美术设计师无论将贴图做的多大，我们都可以在Unity3D里重新设置成我们需要的大小，Unity3D会将所有贴图都重新制作导出成用户指定大小的贴图和格式。因此即使前期贴图太大而导致的问题，也可以在Unity3D的项目中将贴图设置回我们想要的大小。&lt;/p&gt;

&lt;h3&gt;4.动画太多，蒙皮的计算量太大&lt;/h3&gt;

&lt;p&gt;动画确实是最令人头疼的，因为它是动态的，而且时时刻刻都是动态的，不像3D物件，虽然它们会出现消失，但大部分情况下还是静止不同的。而动画则不同，它们时时刻刻都在你眼前动来动去，即使不再屏幕上，大部分时候也需要一直保持动的状态。&lt;/p&gt;

&lt;p&gt;对于动画的优化，其实上几个章节中有讲的比较详细，这里只是简单的点一下。&lt;/p&gt;

&lt;p&gt;动画的消耗点最大的地方是CPU的蒙皮计算，如果有100个动画在屏幕中播放，由于每帧对蒙皮的计算都是全局性的，因此CPU会极大的消耗在蒙皮计算上。&lt;/p&gt;

&lt;p&gt;蒙皮计算，其实质就是骨骼与顶点的计算，骨骼动画用骨骼点去影响顶点，每帧都需要计算骨骼点与顶点的偏移、缩放与旋转。&lt;/p&gt;

&lt;p&gt;如果动画模型的顶点数量很多，骨骼数量很多，顶点关联着骨骼点，骨骼点影响着顶点，那么计算量就会很大，消耗的CPU自然就会很多。&lt;/p&gt;

&lt;p&gt;为了能节省计算量，我们可以减少顶点数，又或者减少骨骼点的数量，抑或两者都进行削减，就能使得CPU降低消耗。&lt;/p&gt;

&lt;p&gt;让3D模型设计师和动画师去减面和减动画骨骼，工作量毕竟是比较大的，涉及到所有3D模型和动画。在削减的时候还需要顾及画面，不能太糟糕，所以时间会比较长。这是我们程序无法控制的，我们能做的就是从程序上尽量的降低开销。&lt;/p&gt;

&lt;p&gt;由于每帧都要计算，所以很费CPU，如果能把计算好的每帧顶点偏移量存起来，播放的时候直接偏移过去就好了，于是就有了 Animation Instancing。它就是把所有动画文件中的数据都导出放入贴图中，由可编程的顶点着色器来完成顶点的偏移。这样我们就不需要计算了，在设置顶点的位置就可以了，省去了大量的CPU计算消耗。&lt;/p&gt;

&lt;p&gt;但是毕竟一个会动的模型，是无法合并Mesh，理论上说应该说每帧都合并一次对CPU消耗的代价太大，所以每个动画模型都需要至少一个Drawcall来支撑，如果Shader中有多个Pass管线，就有更多，比如描边，实时阴影等。&lt;/p&gt;

&lt;p&gt;假设有100个这样的动画，就需要至少100个Drawcall来支撑。消耗还是太大，能不能合并Drawcall，就像合并Mesh一样，相同的材质球合并成为一个Drawcall呢？&lt;/p&gt;

&lt;p&gt;Unity3D的 GPU Instancing 为我们提供了合并的可能。它可以合并相同材质球，相同模型的Drawcall。它原理是将多个模型的相同顶点，相同贴图，相同材质球，在不同位置的物体一次性提交给GPU，让它只绘制一次就能将所有物体都绘制在帧缓存中，进而体现在屏幕上。&lt;/p&gt;

&lt;p&gt;这种方式的条件虽然有点苛刻，但恰好能和 Animation Instancing 配合的很好，Animation Instancing 并没有改变3D模型，贴图，材质球，能与 GPU Instancing 能很好的结合，两者使用起来能减掉很多有用相同模型和材质球的动画物体，还能将计算蒙皮的CPU消耗省去，可以说是绝佳的搭档。&lt;/p&gt;

&lt;p&gt;与之相似的还有，另外一些场景中的草和树的摇动，我们可以用顶点动画和 GPU Instancing 结合来省去Drawcall和蒙皮计算的CPU消耗。&lt;/p&gt;

&lt;p&gt;其实和 Animation Instancing 一样的原来，只是草和树是纯顶点算法计算出来的摇动，而3D模型动画的 Animation Instancing 则是在离线下将动画数据导进纹理贴图中在顶点着色器中偏移顶点罢了。&lt;/p&gt;

&lt;p&gt;前者用了算法计算出顶点，而后者用纹理贴图当做数据载体直接偏移顶点。前者消耗了GPU来代替CPU计算，后者消耗了内存和少量GPU代替CPU，前者更加灵活但也受到算法的局限性，后者则死板一些但性能开销更少。各有利弊，在实际项目中也需要根据实际情况做选择和混用，我们在使用时应该衡量他们在项目中的限制和作用，尽量做最适合的选择。&lt;/p&gt;

&lt;h6&gt;5.实时光的GPU开销太大&lt;/h6&gt;

&lt;p&gt;烘培是解决实时灯光太多，GPU开销太大时比较好的解决手段。对于场景制作与优化，烘培是永远绕不过去的技巧，它能帮助我们省去很多灯光的实时开销，以及实时阴影的巨大开销。&lt;/p&gt;

&lt;p&gt;下一节我们就来专门来讲讲，烘培及其优化。&lt;/p&gt;
</description>
               <pubDate>Sat, 17 Aug 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/08/17/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E5%9C%B0%E5%9B%BE%E4%B8%8E%E5%AF%BB%E8%B7%AF4.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/08/17/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E5%9C%B0%E5%9B%BE%E4%B8%8E%E5%AF%BB%E8%B7%AF4.html</guid>
            </item>
        
    </channel>
</rss>