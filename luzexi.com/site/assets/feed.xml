<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title></title>
        <description>技术，哲学，金融</description>
        <link>http://www.luzexi.com</link>
        <atom:link href="http://www.luzexi.com/assets/feed.xml" rel="self" type="application/rss+xml" />
        
            <item>
               <title>读书笔记(四十七) 《游戏引擎架构》#4 低阶渲染器（2）</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484981&amp;amp;idx=1&amp;amp;sn=b5199f84ed73d28916dbb9143eeeb992&amp;amp;chksm=fc226332cb55ea2417b89e499284ab3a552ce591caba09d637912306503e4b457ed45c2e1d2d&amp;amp;token=1023740201&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;背景&quot;&gt;背景：&lt;/h2&gt;

&lt;p&gt;作为游戏开发从业者，从业务到语言到框架到引擎，积累了一些知识和经验，特别是在看了几遍《游戏引擎架构》后对引擎架构的理解又深入了些。&lt;/p&gt;

&lt;p&gt;近段时间有对引擎剖析的想法，正好借这书本对游戏引擎架构做一个完整分析。&lt;/p&gt;

&lt;p&gt;此书用简明、清楚的方式覆盖了游戏引擎架构的庞大领域，巧妙地平衡了广度与深度，并且提供了足够的细节。&lt;/p&gt;

&lt;p&gt;借助《游戏引擎架构》这本书、结合引擎源码和自己的经验，深入分析游戏引擎的历史、架构、模块，最后通过实践简单引擎开发来完成对引擎知识的掌握。&lt;/p&gt;

&lt;p&gt;游戏引擎知识面深而广，所以对这系列的文章书编写范围做个保护，即不对细节进行过多的阐述，重点剖析的是架构、流程以及模块的运作原理。&lt;/p&gt;

&lt;p&gt;同时《游戏引擎架构》中部分知识太过陈旧的部分，会重新深挖后总结出自己的观点。&lt;/p&gt;

&lt;h2 id=&quot;概述&quot;&gt;概述：&lt;/h2&gt;

&lt;p&gt;本系列文章对引擎中的重要的模块和库进行详细的分析，我挑选了十五个库和模块来分析：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;时间库&lt;/li&gt;
  &lt;li&gt;自定义容器库&lt;/li&gt;
  &lt;li&gt;字符串散列库&lt;/li&gt;
  &lt;li&gt;内存管理框架&lt;/li&gt;
  &lt;li&gt;RTTI与反射模块&lt;/li&gt;
  &lt;li&gt;图形计算库&lt;/li&gt;
  &lt;li&gt;资产管理模块&lt;/li&gt;
  &lt;li&gt;低阶渲染器&lt;/li&gt;
  &lt;li&gt;剔除与合批模块&lt;/li&gt;
  &lt;li&gt;动画模块&lt;/li&gt;
  &lt;li&gt;物理模块&lt;/li&gt;
  &lt;li&gt;UI底层框架&lt;/li&gt;
  &lt;li&gt;性能剖析器的核心部分&lt;/li&gt;
  &lt;li&gt;脚本系统&lt;/li&gt;
  &lt;li&gt;视觉效果模块&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本篇内容为列表中的第8个部分的第1节。&lt;/p&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文：&lt;/h2&gt;

&lt;p&gt;简单回顾下前文&lt;/p&gt;

&lt;p&gt;前文我们聊了下显卡在计算机硬件主板中的位置与结构，知道了CPU、GPU的通信介质，并简单介绍了手机上的主板结构。本篇开头对上一篇做一些内容补充，PC和手机的不同硬件组织，以及CPU与其他芯片的通信过程。&lt;/p&gt;

&lt;p&gt;下面我们开始这篇内容&lt;/p&gt;

&lt;h3 id=&quot;本次内容会围绕gpu来写从硬件架构到软件驱动再到引擎架构目标是帮大家理解gpu硬件的运作原理理解图形接口的架构理解引擎低阶渲染器的架构&quot;&gt;本次内容会围绕GPU来写，从硬件架构到软件驱动再到引擎架构，目标是帮大家理解GPU硬件的运作原理，理解图形接口的架构，理解引擎低阶渲染器的架构。&lt;/h3&gt;

&lt;p&gt;目录：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;主板结构中的显卡&lt;/li&gt;
  &lt;li&gt;GPU功能发展史&lt;/li&gt;
  &lt;li&gt;GPU与CPU的差异&lt;/li&gt;
  &lt;li&gt;GPU硬件特点&lt;/li&gt;
  &lt;li&gt;图形驱动程序架构&lt;/li&gt;
  &lt;li&gt;引擎低阶渲染架构&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;继续上篇未结束的内容&lt;/p&gt;

&lt;p&gt;说硬件结构时，我们常常从台式 PC 开始说起，因为智能手机本质上是袖珍型计算机，具有一些额外的无线电，并且在功耗、热量输出等方面极其受限的条件下运行。PC 主要由主板芯片组组成（通常分为连接处理器和内存“北桥”（例如 Intel 的 P45）和连接各种外围总线（例如 PCI-Express、USB 等）的“南桥”（例如 Intel 的 ICH10R） )、中央处理器（例如 CPU – Intel 的 Core 2 Duo）、随机存储器内存 (RAM)、永久存储器（硬盘或固态硬盘）、图形处理单元（例如 GPU – ATI 的 Radeon HD5890） 、电源和多个连接到 PCI 或 PCI-Express 总线的外围设备（例如，内置声音芯片组或附加 Wi-Fi 卡）。&lt;/p&gt;

&lt;p&gt;（三星手机拓扑图：图片来源网络）&lt;/p&gt;

&lt;p&gt;（iPhone6p A8 正面图：图片来源网络）&lt;/p&gt;

&lt;p&gt;（iPhone6p A8 背面图：图片来源网络）&lt;/p&gt;

&lt;p&gt;（苹果A8芯片内部结构：图片来源网络）&lt;/p&gt;

&lt;p&gt;智能手机也具有所有这些组件，只是集成度更高而已。一些主要芯片通常可以包含 CPU、GPU、其他专用协处理器、主板总线、内存控制器、LCD 控制器、声音芯片组、CMOS 摄像头接口、板载内存 ，以及一些外围设备（例如 Cell、Wifi 和蓝牙无线电）。 “应用处理器”是负责一般处理的芯片（类似于 CPU + 主板芯片组），并且可能内置了一些其他功能。 “基带处理器”负责蜂窝无线通信。&lt;/p&gt;

&lt;p&gt;智能手机与 PC 如此相似，那么为什么我们今天在智能手机中看不到像 Core 2 Duo 这样的 x86 CPU？答案是，Core 2 Duo 消耗的功率和产生的热量远远超出手机的可接受范围。典型的台式机 Core 2 Duo CPU 的功耗最高可达 65W，并且需要一个主动冷却系统来防止过热。即使是英特尔的 Atom 芯片也消耗 4W（峰值 TDP），而整个手机通常必须满足低于 1W 的功率。&lt;/p&gt;

&lt;p&gt;今天我们很多智能手机都使用 ARM 芯片， ARM 的运作方式与Intel截然不同。 Intel 自己设计和构建所有处理器，而 ARM 则创建指令集，任何跟随它们的 CPU 都将能够运行与 ARM 兼容的代码。 它还为适合其指令集的处理器创建参考设计，这使公司能够围绕 ARM 的核心设计轻松生产自己的芯片组。 一些公司，如英伟达、三星和德州仪器，只是简单地许可并采用 ARM CPU 参考设计，而其他公司，如高通和 Marvell，只许可指令集并创建自己的处理器以适应它们。 第一个 ARMv7 参考设计是 Cortex A8，其架构可在今天的智能手机中找到。很久以前低端智能手机倾向于使用实现 ARMv6 指令集的 ARM11 芯片，现在已经不复存在。&lt;/p&gt;

&lt;p&gt;这里再补充一下前文的硬件通信过程，每个带有处理程序的硬件都有自己的芯片，CPU是整个电脑的主要计算芯片，GPU则被单独拆分出来作为图像的处理芯片，除了这两个大家熟知的芯片，还有内存芯片，硬盘芯片，声卡芯片，网卡芯片等，这些芯片都通过总线进行数据交互。其中前面我们提到南桥和北桥芯片桥接了快慢不同的芯片之间的通信，让不同种类的设备通信效率更高更有序。&lt;/p&gt;

&lt;p&gt;（PC端CPU与GPU通信结构图）&lt;/p&gt;

&lt;p&gt;（手机端CPU与GPU通信结构图）&lt;/p&gt;

&lt;h3 id=&quot;cpu与其他芯片之间的通信步骤可以简单理解为cpu通过总线发送指令数据到其他芯片芯片收到指令并处理后再通过总线将反馈数据给cpu中间处理过程也会与内存芯片或其他芯片通信后再反馈给cpu&quot;&gt;CPU与其他芯片之间的通信步骤，可以简单理解为，CPU通过总线发送指令数据到其他芯片，芯片收到指令并处理后，再通过总线将反馈数据给CPU，中间处理过程也会与内存芯片或其他芯片通信后再反馈给CPU。&lt;/h3&gt;

&lt;p&gt;（CPU用虚拟地址访问内存拓扑图）&lt;/p&gt;

&lt;h3 id=&quot;cpu-在访问内存时需要通过-mmu-把虚拟地址转化为物理地址再通过总线访问内存mmu-开启后-cpu-看到的所有地址都是虚拟地址cpu-把这个虚拟地址发给-mmu-后mmu-会在页表里查出这个虚拟地址对应的物理地址再通过总线去访问ddr内存芯片&quot;&gt;CPU 在访问内存时需要通过 MMU 把虚拟地址转化为物理地址，再通过总线访问内存。MMU 开启后 CPU 看到的所有地址都是虚拟地址，CPU 把这个虚拟地址发给 MMU 后，MMU 会在页表里查出这个虚拟地址对应的物理地址，再通过总线去访问DDR内存芯片。&lt;/h3&gt;

&lt;p&gt;从这个芯片通信角度看，我们可以明白，总线传输数据的速度，限制了计算机的运行速度。因此我们在优化计算机程序时会常常去减少CPU与GPU之间通信量，原因就是在无法增加带宽上限这个大前提下，尽量减少它们之间通信数据量，从而减少访问消耗时间。&lt;/p&gt;

&lt;h2 id=&quot;gpu功能发展史&quot;&gt;GPU功能发展史&lt;/h2&gt;

&lt;p&gt;第一篇中我们介绍过一些图形接口的发展历史，现在我们来介绍一下GPU硬件的发展历史。硬件的发展史其实是一个商业的竞争过程，中间夹杂着很多商业战略与决策。尤其是当大家都看到GPU这块高新的技术’蛋糕’，有一系列公司参与进来相互竞争。因此这里不过多的介绍商业上的活动与竞争，而是专注于介绍GPU功能的发展过程。&lt;/p&gt;

&lt;p&gt;第一个真正的3D图形卡始于早期的显示控制器，即视频移位器和视频地址生成器（video shifters and video address generators）。它们充当主处理器和显示器之间的直通通道（pass-through）。传入的数据流被转换为串行位图视频输出，例如亮度，颜色以及垂直和水平复合同步，这将像素行保持在显示生成中，并同步每条连续行以及消隐间隔（时间间隔为 结束一条扫描线并开始下一条扫描线）。&lt;/p&gt;

&lt;p&gt;（图片来源网络）&lt;/p&gt;

&lt;p&gt;1970年代开始这些视频适配器出现了一系列的改进，主要兼容了不同分辨率以及不同的视频信号。&lt;/p&gt;

&lt;p&gt;1976年，ANTIC使用直接存储器访问（DMA）处理2D显示指令。&lt;/p&gt;

&lt;p&gt;1978年，英特尔82720图形卡芯片，它能够以256x256的分辨率（或以512x512的单色）显示八种颜色数据。其32KB的显示内存足以绘制线，弧，圆，矩形和字符位图。该芯片还提供了缩放，屏幕分区和滚动的功能。&lt;/p&gt;

&lt;p&gt;1979年，SGI推出了用于工作站的IRIS图形卡-GR1.x图形卡板，其中提供了用于颜色选项，几何图形卡，Z缓冲区和覆盖/底层的单独的外接（子）板。&lt;/p&gt;

&lt;p&gt;从第一块图形卡发明到现在，整个过程可以分为，视频适配器时代，2D时代、3D时代启程、3D时代崛起、3D时代巅峰，这4个部分。&lt;/p&gt;

&lt;p&gt;为此我画了一副时序图并标出了重要节点，便于大家理解显卡的发展史，同时以文字形式告知大家图形显卡的发展历史。&lt;/p&gt;

&lt;p&gt;（显卡发展史）&lt;/p&gt;

&lt;h2 id=&quot;2d时代&quot;&gt;2D时代&lt;/h2&gt;

&lt;p&gt;1981年, IBM推出了个人电脑时，它提供了两种显卡，一种是“单色显卡”(简称 MDA), 一种是 “彩色绘图卡” (简称 CGA), 从名字上就可以看出，MDA是与单色显示器配合运用的, 它可以显示80行x25列的文数字, CGA则可以用在RGB的显示屏上, 它可以绘制的图形和文数字资料。&lt;/p&gt;

&lt;p&gt;1982年，IBM又推出了MGA（Monochrome Graphic Adapter）, 又称Hercules Card (大力士卡),  除了能显示图形外，还保留了原来 MDA 的功能。&lt;/p&gt;

&lt;p&gt;这些显卡均为采纳使用数字方式的，直到MCGA（Multi-Color Graphics Array）的出现，才揭开了采纳使用模拟方式的显卡的序幕。MCGA是整合在 PS/2 Model 25和30上的影像系统。它采纳使用了Analog RGA影像信号, 解析度可高达640x480, 数位RGB和类比RGB不同的的方就像是ON-OFF式切换和微调式切换之间的差别。&lt;/p&gt;

&lt;p&gt;1986年ATI推出了第一款产品，即OEM颜色仿真卡。它用于通过9针DE-9连接器将黑色背景的单色绿色，琥珀色或白色磷光体文本输出到TTL监视器，该卡至少配备了16KB的内存。&lt;/p&gt;

&lt;p&gt;1987年，ATI在其OEM产品线中增加了Graphics Solution Plus系列，该产品线将IBM PC / XT ISA 8位总线用于基于Intel 8086/8088的IBM PC。该芯片通过DIP开关支持MDA，CGA和EGA图形卡模式。ATI EGA 800：16色VGA仿真，支持800x600。&lt;/p&gt;

&lt;p&gt;VGA（Video Graphic Array）即显示绘图阵列，它IBM是在其 PS/2 的Model 50, 60和80内建的影像系统。它的数字模式可以达到720x400色, 绘图模式则可以达到640x480x16色, 以及320x200x256色，这是显卡首次可以相应情况下最大限度显示256种色彩，而这些模式更成为其后所有显卡的共同标准。&lt;/p&gt;

&lt;p&gt;1988年，带有游戏控制器端口和复合输出选项的Small Wonder Graphics解决方案问世（用于CGA和MDA仿真），以及具有扩展EGA和16位VGA支持的EGA Wonder 480和800+，以及VGA 新增了VGA和SVGA支持的Wonder和Wonder 16。&lt;/p&gt;

&lt;p&gt;1988年，Trident 8900/9000显卡，它第一次使显卡成为一个独立的配件出现在电脑里，而不再是集成的一块芯片。而后其推出的Trident 9685更是第一代3D显卡的代表。不过真正称得上开启3D显卡大门的却应该是1996年的GLINT 300SX，虽然当时其3D功能非常简单，却具有里程碑的意义。&lt;/p&gt;

&lt;p&gt;1989年推出了更新的VGA Wonder / Wonder 16系列，其中包括降低成本的VGA Edge 16（Wonder 1024系列）。新功能包括一个总线鼠标端口，并支持VESA功能连接器。这是一个金手指连接器，类似于缩短的数据总线插槽连接器，它通过带状电缆链接到另一个视频控制器，以绕过拥挤的数据总线。&lt;/p&gt;

&lt;p&gt;1991年，Wonder系列的更新继续向前发展。WonderXL卡增加了VESA 32K颜色兼容性和Sierra RAMDAC，从而将最大显示分辨率提高到640x480 @ 72Hz 或 800x600 @ 60Hz。&lt;/p&gt;

&lt;p&gt;1991年5月，ATI的Mach系列与Mach8一同推出。它以芯片或电路板的形式出售，可以通过编程接口（AI）卸载有限的2D绘图操作，例如线条画，颜色填充和位图组合（Bit BLIT）.ATI添加了Wonder的一种变体 XL在扩展PCB上集成了Creative Sound Blaster 1.5芯片。它被称为VGA Stereo-F / X，它能够模拟Sound Blaster单声道文件中的立体声，并且其质量接近FM广播质量。ATI图形卡Ultra ISA（Mach8 + VGA）,将Mach8与VGA Wonder +的图形卡核心（28800-2）结合在一起以实现其3D功能。&lt;/p&gt;

&lt;p&gt;1992年1月，Silicon Graphics Inc（SGI）发布了OpenGL 1.0，这是一个针对2D和3D图形卡的多平台供应商不可知的应用程序编程接口（API）。OpenGL是从SGI专有的API（称为IRIS GL（集成的栅格成像系统图形卡库））演变而来的。最初，OpenGL瞄准的是基于UNIX的专业市场，但是由于开发人员对扩展实施的友好支持，很快将其用于3D游戏。同时微软正在开发自己的竞争对手Direct3D API，并没有确保OpenGL在Windows下也能正常运行。&lt;/p&gt;

&lt;p&gt;1993年11月，ATI宣布68890 PC电视解码器芯片的发布，该芯片首次在Video-It卡里面亮相。借助板载Intel i750PD VCP（视频压缩处理器），该芯片能够以320x240 @ 15 fps或160x120 @ 30 fps捕获视频，并能够实时压缩/解压缩。它还能够通过数据总线与图形卡板通信，从而无需使用加密狗或端口和带状电缆。&lt;/p&gt;

&lt;p&gt;1995年，ATI的Mach8发布，创造了许多著名的首创。它成为第一个以Xclaim形式在PC和Mac计算机上使用的图形卡适配器，并且与S3的Trio一起提供了全动态视频播放加速功能。&lt;/p&gt;

&lt;h2 id=&quot;3d时代开启&quot;&gt;3D时代开启&lt;/h2&gt;

&lt;p&gt;1995年5月，nVidia推出了他们的第一款图形卡芯片NV1，并成为首款能够进行3D渲染，视频加速和集成GUI加速的商业图形卡处理器。供应商发布显卡支持规格的主板（Diamond Edge 3D），D3D（Diamond Edge 3D）图形卡API确认依赖于渲染三角形多边形，而NV1则使用四边形纹理映射。nVidia通过驱动程序添加了有限的D3D兼容性，以将三角形包装为二次曲面，但是市面上仍然很少针对NV1量身定制的游戏。&lt;/p&gt;

&lt;p&gt;1995年11月，ATI宣布了他们的首个3D加速器芯片3D Rage（也称为Mach 64 GT）。&lt;/p&gt;

&lt;p&gt;1995年，3Dfx推出了业界的口碑极佳的3D图形加速卡：Voodoo。3Dfx的专利技术Glide引擎接口一度称霸了整个3D世界，直至D3D和OpenGL的出现才改变了这种局面。&lt;/p&gt;

&lt;p&gt;Voodoo标配为4Mb EDO显存，可以提供在640×480分辨率下3D显示速度和最华丽的画面。Voodoo也有硬伤，它只是一块具有3D加速功能的子卡，运用时需搭配一块具有2D功能的显卡，因此当时S3 765+Voodoo是为人津津乐道的黄金组合。&lt;/p&gt;

&lt;p&gt;S3 765显卡是当时兼容机的标准配置，最大限度支持2MB EDO显存，可以实现高分辨率显示，可以支持1024×768的分辨率，并且在低分辨率下支持最大限度32Bit真彩色，而且性能和价格比也较强。&lt;/p&gt;

&lt;p&gt;1995年，VideoLogic开发了一种基于图块的延迟渲染技术（TBDR），该技术在纹理、阴影和光照应用于剩下的渲染之前，抛弃了所有可见的几何形状，从而消除了对大规模z缓冲(在最终渲染中去除遮挡/隐藏的像素)的需求。这个过程产生的框架被分割成矩形块，每个图块都可以自行进行多边形渲染并发送到输出。一旦计算了帧所需的像素并剔除了多余的多边形(z缓冲只在平铺层发生)，对多边形渲染就开始了，这样就只需要进行最基本的计算。&lt;/p&gt;

&lt;p&gt;1995年，Rendition的VéritéV1000成为第一张具有可编程核心的显卡，它使用了基于MIPS的RISC处理器和Pixel Pipelines(像素管线)。处理器负责设置和组织管线的工作负载。 Vérité1000最初于1995年底开发，后来成为Microsoft用于开发Direct3D的主板之一。&lt;/p&gt;

&lt;p&gt;1996年 3DLabs 研制出Glint，该公司诞生于杜邦的Pixel图形卡部门。GLINT 300SX处理器能够进行OpenGL渲染，片段处理和光栅化。GLINT 300SX增加了2MB的内存。它为纹理和Z缓冲区使用了1MB，为帧缓冲区使用了1MB，但是还提供了一个选项，以增加VRAM的Direct3D兼容性。&lt;/p&gt;

&lt;p&gt;1997年3月ATI推出 3D Rage Pro，它在4MB格式下几乎可以媲美Voodoo Graphics的性能。在使用8MB和AGP接口时，其性能则优于3Dfx卡。它扩展了4kB高速缓存并增加了边缘抗锯齿功能，该显卡改进了Rage II的透视校正，纹理处理能力以及三线性滤波性能。还集成了一个浮点单元，以减少对CPU的依赖以及对DVD的硬件加速和显示支持。&lt;/p&gt;

&lt;p&gt;1997年4月，nVidia推出了RIVA 128（实时交互式视频和动画加速器），并通过渲染三角形多边形增加了Direct3D兼容性，使用新的350nm工艺，并开发了RAMDAC和视频转换器，这是nVidia具有里程碑意义的显卡。&lt;/p&gt;

&lt;p&gt;1998年1月，英特尔发布i740，它结合了R3D/100上两种不同的图形和纹理芯片的资源，实现了AGP纹理，纹理被上传到系统内存中(渲染缓冲区也可以存储在RAM中)。此前一些设计会选择使用显卡的帧缓冲区用来保存纹理，如果帧缓冲区饱和或纹理太大而无法存储在本地图形内存中，则纹理交换到系统RAM中。为了最大程度地减少延迟，英特尔的设计使用了AGP Direct Memory Execute（DiME）功能，该功能仅调用光栅化所需的那些纹理，其余的存储在系统RAM中。性能和图像质量可以接受的，性能大致与上一年的高端产品相匹配，因此该产品大放异彩。&lt;/p&gt;

&lt;p&gt;1998年3月，3Dfx推出Voodoo2。Voodoo2本身带有8Mb/12Mb EDO显存，PCI接口，卡上有双芯片，可以做到单周期多纹理运算。缺点是它的卡身很长，并且芯片发热量相当大，依然只作为一块3D加速子卡，需要一块2D显卡的支持。Voodoo2的推出使得3D加速又到达了一个新的里程碑，依仗Voodoo2的效果、画面和速度，征服了不少当时盛行一时的3D游戏，比如Fifa98，NBA98，Quake2等等。&lt;/p&gt;

&lt;p&gt;1998年7月，Matrox公司发布MGA G200继承了自己超一流的2D水准，3D方面有了革命性的提高，不但可以提供和Voodoo2差不多的处理速度和特技效果，另外还支持DVD硬解码和视频输出，并且独一无二的首创了128位独立双重总线技术，大大提高了性能，配合当时相当走红的AGP总线技术，G200也赢得了不少用户的喜爱。&lt;/p&gt;

&lt;p&gt;1998年的S3的野人系列Savage系列显卡，Savage3D采纳使用128位总线结构及单周期三线性多重贴图技术，最大像素填充率达到了125M Pixels/s，三角形生成速率也达到了每秒500万个。通过S3新设计的AGP引擎和S3TC纹理压缩技术，支持Direct3D与OpenGL，最大显存容量可达8MB SGRAM或SDRAM，支持AGP 4×规范。相应情况下也支持当时流行的如反射和散射、Alpha混合、多重纹理、衬底纹理、边缘抗锯齿、16/24位Z-buffering、Tri-linear Filtering（三线性过滤技术）、S3TC纹理压缩技术等技术。可惜就是受到驱动程序不兼容的严重影响，最终在99年时惨淡收场。&lt;/p&gt;

&lt;h2 id=&quot;3d时代崛起&quot;&gt;3D时代崛起&lt;/h2&gt;

&lt;p&gt;1999年2月，S3发布Savage4，成为的第一张支持多重纹理的显卡，也是第一张支持AGP 4x接口的显卡。&lt;/p&gt;

&lt;p&gt;1999年，NVidia推出TNT2 Ultra、TNT2和TNT2 M64三个版本的芯片，后来又有PRO和VANTA两个版本。这种分类方式也促使后来各个生产厂家对同一芯片进行高中低端的划分，以满足不同层次的消费需要。TNT系列配置了8Mb到32Mb的显存，支持AGP2X/4X，支持32位渲染等等众多技术。nVidia能战胜Voodoo3，与3Dfx公司推行的策略迫使众多生产厂家投奔nVidia也不无关系，促进了TNT系列的推广。&lt;/p&gt;

&lt;p&gt;1999年，Matrox推出 MGA G400，它拥有16Mb/32Mb的显存容量，支持AGP 2X/4X，还有支持大纹理以及32位渲染等等，独特漂亮的EMBM硬件凹凸贴图技术，营造出的完美凹凸感并能实现动态光影效果的技术，并且G400拥有优秀的DVD回放能力，只是价格有些昂贵。通过双显示控制器（被Matrox称为DualHead）驱动两台显示器的能力开始了公司的多显示器支持趋势。&lt;/p&gt;

&lt;p&gt;1999年，nVidia终于爆发了，它在99年末推出了当前革命性的显卡—Geforce 256，彻底打败了3Dfx。代号NV10的GeForce 256支持Cube-Environment Mapping，完全的硬件T&amp;amp;L（Transform &amp;amp; Lighting），把原来有CPU计算的数据直接交给显示芯片处理，大大解放了CPU，也提高了芯片的运用效率。GeForce256拥有4条图形纹理通道，单周期每条通道处理两个象素纹理，工作频率120MHz，全速可以达到480Mpixels/Sec，支持SDRAM和DDR RAM，运用DDR的产品能更好的发挥GeForce256的性能。其不足之处就在于采纳使用了0.22纳米的工艺技术，发热量相对其它的来说很高的。&lt;/p&gt;

&lt;p&gt;2000年7月，3Dfx发布的Voodoo 5引入了T-buffer技术，作为变换和照明的一种替代方法，它基本上采用了一些渲染帧并将它们聚合为一个图像的方法。这产生了稍微模糊的图片，当按帧顺序运行时，可以平滑动画的运动。&lt;/p&gt;

&lt;p&gt;2000年末，3Dfx最终被nVidia收购。&lt;/p&gt;

&lt;h2 id=&quot;3d时代巅峰&quot;&gt;3D时代巅峰&lt;/h2&gt;

&lt;p&gt;2000年，ATI依仗T&amp;amp;L技术打开市场，在经历“曙光女神”的失败后，ATI推出了自己的T&amp;amp;L芯片RADEON 256。RADEON和NVIDIA一样具有高低端的版本，完全硬件T&amp;amp;L，Dot3和环境映射凹凸贴图，还有两条纹理流水线，可以相应情况下处理三种纹理。最出彩的是HYPER-Z技术，大大提高了RADEON显卡的3D速度，拉近了与GEFORCE 2系列的距离，ATI的显卡开始在市场占据主导地位。&lt;/p&gt;

&lt;p&gt;2000年4月，nVidia发布了GeForce 2 GTS（GigaTexel Shader），称为Nvidia Shading Rasterizer，它允许将高光阴影，体积爆炸，折射，波浪，顶点混合，阴影体积，凹凸贴图和高程贴图等效果应用于每个像素通过硬件的基础。&lt;/p&gt;

&lt;p&gt;2000年8月，ATI Radeon DDR上市。在卓越的T&amp;amp;L实现和对即将推出的DirectX 8特性的支持下，Radeon DDR与GeForce 2 GTS一起，通过将对接口的支持集成到芯片本身，引入了DVI输出的使用。&lt;/p&gt;

&lt;p&gt;2001年，nVidia推出的Geforce 3系列，这张卡成为了该领域的新王者，GeForce 3显卡增加了可编程T&amp;amp;L功能，可以对几乎所有的画面效果提供硬件支持。GeForce 3总共具有4条像素管道，填充速率最大限度可以达到每秒钟800 Mpixels。支持DirectX 8，多重采样AA，梅花AA（基本上是2xMSAA +后期处理模糊），8x各向异性滤光以及无与伦比的处理8xAF +三线性滤光的能力以及可编程的顶点着色器，用于更紧密地控制多边形网格运动和更流畅的动画序列。还有LMA(光速内存架构)支持——基本上是Nvidia的HyperZ版本——用于剔除隐藏在屏幕上其他像素后面的像素(Z遮挡剔除)，以及压缩和解压数据以优化带宽使用(Z压缩)。最后，Nvidia实现了负载平衡算法，将其称为Crossbar内存控制器，该控制器由四个独立的内存子控制器（与行业标准的单个控制器相对）组成，从而可以更有效地路由传入的内存请求。&lt;/p&gt;

&lt;p&gt;2001年，ATI则推出Radeon 8500/7500系列，采纳使用0.15微米工艺制造，包括6000万个晶体管，采纳使用了不少新技术(如Truform、Smartshader等)。并根据显卡的核心/显存工作频率分成不同的档次——核心/显存分别为275/550MHz的标准版，核心/显存为250/500MHz的RADEON 8500LE，生产核心/显存频率分别为300/600MHz的Ultra版，以及中端的Radeon 7500，低端的Radeon 7200，7000等产品。值得一提的是Radeon 8500还支持双头显示技术。&lt;/p&gt;

&lt;p&gt;2002年，ATI R300 GPU发布，由最初构成ArtX核心的团队开发，交付出色。它是第一个提供DirectX 9.0支持的应用程序，并且扩展了第一个支持着色器模型2.0，顶点着色器2.0和像素着色器2.0的体系结构。&lt;/p&gt;

&lt;p&gt;2002年，nVidia与ATI的竞争更加白热化。为巩固其图形芯片市场霸主的位，nVidia推出了Geforce 4系列，GeForce4 Ti系列择定确定是最具性能和价格比的，其代号是NV25，主要针对当时的高端图形市场，是DirectX 8时代下最劲爆强大的GPU图形处理器。芯片内部包含的晶体管数量高达6千3百万，运用0.15微米工艺生产，采纳使用了新的PBGA封装，运行频率达到了300MHz，配合频率为650MHz DDR显存，可以实现每秒49亿次的采样。GeForce4 Ti核心内建4条渲染流水线，每条流水线包含2个TMU（材质贴图单元）。Geforce 4系列从高到低，横扫了整个显卡市场。&lt;/p&gt;

&lt;p&gt;2002年，ATI推出R9700/9000/9500系列，首次支持DirectX 9，使其在与NVidia的竞争中抢得先机。同时R9700支持AGP 8X、DirectX 9，核心频率是300MHz，显存时钟是550MHz。RADEON 9700实现了可程序化的革命性硬件架构。符合AGP 8X最新标准，配有8个平等处理的渲染管线，每秒可处理25亿个像素，4个并列的几何处理引擎能处理每秒3亿个形迹及光效多边形。R9000则面向低端的产品，R9500则对标Ti4200。&lt;/p&gt;

&lt;p&gt;2003年的显卡市场依旧为N系与A系所统治。nVidia的Gf FX 5800（NV30）系列拥有32位着色，颜色画面有质的提高，在基础上推出的GeForce FX 5900，提高了晶体管数，降低了核心频率与显存频率，改用了256BIT DDR以提高显存带宽。&lt;/p&gt;

&lt;p&gt;2003年7月，nVidia推出了GF FX 5950/5700系列，以取代GF FX 5900/5600。新的Detonator FX驱动程序大大改善了AA和AF。
2003年9月，ATI推出了RADEON 9800/pro/SE/XT，依仗其超强的性能以及较低的售价，再次打败GF GX 5800。&lt;/p&gt;

&lt;p&gt;2004年是ATI大放异彩的一年，其最大的功臣却是来自于面向中低端的Radeon 9550。2004年最具性能和价格比的显卡，让ATI在低端市场呼风唤雨。R9550基于RV350核心，采纳使用0.13微米制程，核心频率为250MHz，显存频率为400MHz，4条渲染管道，1个纹理单元，相应情况下兼容64bit和128bit。&lt;/p&gt;

&lt;p&gt;2005年，Nvidia推出6000系列显卡，特性包括DirectX 9.0c支持、shader model 3.0(尽管显卡从未完全利用这一点)、Nvidia的PureVideo解码和播放引擎，以及SLI支持。&lt;/p&gt;

&lt;p&gt;2006年10月25日，ATI被AMD收购，总价为54亿美元。&lt;/p&gt;

&lt;p&gt;–&lt;/p&gt;

&lt;p&gt;NVIDIA发展表：&lt;/p&gt;

&lt;p&gt;1995年，NV1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;50K triangles/sec
1M pixel ops/sec
1M transistors
16-bit color
Nearest filtering
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1997年，Riva 128 (NV3), DX3&lt;/p&gt;

&lt;p&gt;1998 – Riva TNT (NV4), DX5&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;32位颜色,
24位Z缓存,
8位模板缓存
双纹理,
双线性过滤
每时钟2像素 (2 ppc)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1999 - GeForce 256（NV10）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;固定管线，
支持DirectX 7.0
硬件T&amp;amp;L（Transform &amp;amp; lighting，坐标变换和光照）
立方体环境图（Cubemaps）
DOT3 – bump mapping
2倍各向异性过滤
三线性过滤
DXT纹理压缩
4ppc
引入“GPU”术语
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2001 - GeForce 3&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DirectX 8.0
Shader Model 1.0
可编程渲染管线
顶点着色器
像素着色器
3D纹理
硬件阴影图
8倍各向异性过滤
多采样抗锯齿（MSAA）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2003 - GeForce FX系列（NV3x）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DirectX 9.0
Shader Model 2.0
256顶点操作指令
32纹理 + 64算术像素操作指令
512像素操作指令
着色语言：HLSL、CGSL、GLSL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2004 - GeForce 6系列 (NV4x)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DirectX 9.0c
Shader Model 3.0
动态流控制
分支、循环、声明等
顶点纹理读取
高动态范围（HDR）
64位渲染纹理（Render Target）
FP16*4 纹理过滤和混合
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2006 - GeForce 8系列 (G8x)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DirectX 10.0
Shader Model 4.0
几何着色器（Geometry Shaders）
没有上限位（No caps bits）
统一的着色器（Unified Shaders）
Vista系统全新驱动
基于GPU计算的CUDA问世
GPU计算能力以GFLOPS计量。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2010 - GeForce 405（GF119）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DirectX 11.0
曲面细分（Tessellation）
外壳着色器（Hull Shader）
镶嵌单元（tessellator）
域着色器（Domain Shader）
计算着色器（Compute Shader）
支持Stream Output
Shader Model 5.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DirectX 11的渲染管线。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;多线程支持
改进的纹理压缩
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Shader Model 5.0&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;更多指令、存储单元、寄存器
面向对象着色语言
曲面细分
计算着色器
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2014 - GeForceGT 710（GK208）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DirectX 12.0
轻量化驱动层
硬件级多线程渲染支持
更完善的硬件资源管理
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2016 - GeForceGTX 1060 6GB&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;首次支持RTX和DXR技术，即光线追踪
引入RT Core（光线追踪核心）
支持RTX光线追踪的显卡列表
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2018 - TITAN RTX（TU102）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DirectX 12.1，OpenGL 4.5
6GPC，36TPC，72SM，72RT Core，...
8K分辨率，1770MHz主频，24G显存，384位带宽
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;p&gt;《GPU历史系列》&lt;/p&gt;

&lt;p&gt;https://new.qq.com/omn/20200506/20200506A0GP6H00.html?pc&lt;/p&gt;

&lt;p&gt;《GPU发展史》&lt;/p&gt;

&lt;p&gt;http://www.360doc.com/content/16/0607/16/30123241_565810074.shtml&lt;/p&gt;

&lt;p&gt;《显卡发展史1》&lt;/p&gt;

&lt;p&gt;http://www.360doc.com/content/20/0504/17/32196507_910185372.shtml&lt;/p&gt;

&lt;p&gt;《显卡发展史2》&lt;/p&gt;

&lt;p&gt;http://www.360doc.com/content/20/0504/17/32196507_910185435.shtml&lt;/p&gt;

&lt;p&gt;《显卡发展史3》&lt;/p&gt;

&lt;p&gt;http://www.360doc.com/content/20/0504/17/32196507_910187350.shtml&lt;/p&gt;

&lt;p&gt;《Making Sense of Smartphone Processors: The Mobile CPU/GPU Guide》&lt;/p&gt;

&lt;p&gt;https://www.techautos.com/2010/03/14/smartphone-processor-guide/&lt;/p&gt;

&lt;p&gt;《移动设备GPU架构知识汇总》&lt;/p&gt;

&lt;p&gt;https://zhuanlan.zhihu.com/p/112120206&lt;/p&gt;

&lt;p&gt;《针对移动端TBDR架构GPU特性的渲染优化》&lt;/p&gt;

&lt;p&gt;https://gameinstitute.qq.com/community/detail/123220&lt;/p&gt;

&lt;p&gt;《A look at the PowerVR graphics architecture: Tile-based rendering》&lt;/p&gt;

&lt;p&gt;https://www.imaginationtech.com/blog/a-look-at-the-powervr-graphics-architecture-tile-based-rendering/&lt;/p&gt;

&lt;p&gt;《A look at the PowerVR graphics architecture: Deferred rendering》&lt;/p&gt;

&lt;p&gt;https://www.imaginationtech.com/blog/the-dr-in-tbdr-deferred-rendering-in-rogue/&lt;/p&gt;

&lt;p&gt;《深入GPU硬件架构及运行机制》&lt;/p&gt;

&lt;p&gt;https://www.cnblogs.com/timlly/p/11471507.html&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484981&amp;amp;idx=1&amp;amp;sn=b5199f84ed73d28916dbb9143eeeb992&amp;amp;chksm=fc226332cb55ea2417b89e499284ab3a552ce591caba09d637912306503e4b457ed45c2e1d2d&amp;amp;token=1023740201&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

</description>
               <pubDate>Mon, 08 Nov 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/11/08/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B048</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/11/08/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B048</guid>
            </item>
        
            <item>
               <title>读书笔记(四十七) 《游戏引擎架构》#4 低阶渲染器（1）</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484964&amp;amp;idx=1&amp;amp;sn=99fd35baa5ad829cbae99753f14aa64b&amp;amp;chksm=fc226323cb55ea3598d74dd2508841f01e149176b2c857c54c077a2d8a3f493033ce8f57b56f&amp;amp;token=1534435063&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;背景&quot;&gt;背景：&lt;/h2&gt;

&lt;p&gt;作为游戏开发从业者，从业务到语言到框架到引擎，积累了一些知识和经验，特别是在看了几遍《游戏引擎架构》后对引擎架构的理解又深入了些。&lt;/p&gt;

&lt;p&gt;近段时间有对引擎剖析的想法，正好借这书本对游戏引擎架构做一个完整分析。&lt;/p&gt;

&lt;p&gt;此书用简明、清楚的方式覆盖了游戏引擎架构的庞大领域，巧妙地平衡了广度与深度，并且提供了足够的细节。&lt;/p&gt;

&lt;p&gt;我将借助《游戏引擎架构》这本书、结合引擎源码和自己的经验，深入分析游戏引擎的历史、架构、模块，最后通过实践简单引擎开发来完成对引擎知识的掌握。&lt;/p&gt;

&lt;p&gt;游戏引擎知识面深而广，所以对这系列的文章书编写范围做个保护，即不对细节进行过多的阐述，重点剖析的是架构、流程以及模块的运作原理。&lt;/p&gt;

&lt;p&gt;同时《游戏引擎架构》中部分知识太过陈旧的部分，会重新深挖后总结出自己的观点。&lt;/p&gt;

&lt;h2 id=&quot;概述&quot;&gt;概述：&lt;/h2&gt;

&lt;p&gt;本系列文章对引擎中的重要的模块和库进行详细的分析，我挑选了十五个库和模块来分析：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;时间库&lt;/li&gt;
  &lt;li&gt;自定义容器库&lt;/li&gt;
  &lt;li&gt;字符串散列库&lt;/li&gt;
  &lt;li&gt;内存管理框架&lt;/li&gt;
  &lt;li&gt;RTTI与反射模块&lt;/li&gt;
  &lt;li&gt;图形计算库&lt;/li&gt;
  &lt;li&gt;资产管理模块&lt;/li&gt;
  &lt;li&gt;低阶渲染器&lt;/li&gt;
  &lt;li&gt;剔除与合批模块&lt;/li&gt;
  &lt;li&gt;动画模块&lt;/li&gt;
  &lt;li&gt;物理模块&lt;/li&gt;
  &lt;li&gt;UI底层框架&lt;/li&gt;
  &lt;li&gt;性能剖析器的核心部分&lt;/li&gt;
  &lt;li&gt;脚本系统&lt;/li&gt;
  &lt;li&gt;视觉效果模块&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本篇内容为列表中的第8个部分。&lt;/p&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文：&lt;/h2&gt;

&lt;p&gt;简单回顾下前文&lt;/p&gt;

&lt;p&gt;前文简单提了下C++编译过程、C++内存布局、文件内核读取原理、图形计算的常用库内容，以及大篇幅的引擎资产管理。&lt;/p&gt;

&lt;p&gt;引擎资产管理简单回顾下：&lt;/p&gt;

&lt;p&gt;首先，资产分为DCC资产、中间格式资产、引擎资产，这三者是从制作到导入到使用的顺序。&lt;/p&gt;

&lt;p&gt;其次，引擎资产分为元数据和引擎资产文件，引擎不仅需要资产也需要资产的配置数据。&lt;/p&gt;

&lt;p&gt;接着，引擎内存中的资产有资源映射关系，资产路径、资产GUID、资产实例、资产实例ID。&lt;/p&gt;

&lt;p&gt;最后，引擎通常都有资源包，资源包的格式通常都差不多，头信息（包括索引信息和数据概要信息）+数据文件，压缩可以是整体压缩也可以是每个独立数据单独压缩，通过解剖资源包的数据格式，我们可以知道如何去做差量更新。&lt;/p&gt;

&lt;p&gt;这里补充一点，引擎在读取资产时，与读取资产配置的原理是一样的，它可以有自己的数据格式也可以用标准格式，引擎通常使用自定义格式。通过区分读取不同类型的资产数据来实例化引擎内不同的资源对象，包括网格、材质、动画、粒子、节点、组件配置等。&lt;/p&gt;

&lt;h3 id=&quot;下面我们开始这篇内容&quot;&gt;下面我们开始这篇内容&lt;/h3&gt;

&lt;p&gt;本次内容会围绕GPU来写，从硬件架构到软件驱动再到引擎架构，目标是帮大家理解GPU硬件的运作原理，理解图形接口的架构，理解引擎低阶渲染器的架构。&lt;/p&gt;

&lt;h2 id=&quot;目录&quot;&gt;目录：&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;主板结构中的显卡&lt;/li&gt;
  &lt;li&gt;GPU功能发展史&lt;/li&gt;
  &lt;li&gt;GPU与CPU的差异&lt;/li&gt;
  &lt;li&gt;GPU硬件特点&lt;/li&gt;
  &lt;li&gt;图形驱动程序架构&lt;/li&gt;
  &lt;li&gt;引擎低阶渲染架构&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;主板结构中的显卡&quot;&gt;主板结构中的显卡&lt;/h2&gt;

&lt;p&gt;我们讨论GPU和显卡时经常混为一谈，严格来说GPU是显卡（Video card、Display card、Graphics card）最核心的部件。
显卡除了GPU，还有扇热器、通讯元件、与主板和显示器连接的各类插槽。&lt;/p&gt;

&lt;p&gt;图1&lt;/p&gt;

&lt;p&gt;（主板结构图）&lt;/p&gt;

&lt;p&gt;早期计算机设备中的CPU都是由系统总线来与所有其他设备通信，当图形芯片需要跟CPU和内存大量交换数据时就出现了巨大瓶颈，于是人们设计了高速的北桥芯片和低速的南桥芯片，一来协调CPU、内存、图形设备之间的高速通信，二来专门处理磁盘、USB、键盘鼠标等低速设备。&lt;/p&gt;

&lt;p&gt;从上图中我们看到，离CPU越近，存取数据越快，最近的就是CPU内的组件了，其次是高速缓存总线，再是本地总线，接着是内存总线，最后是高速总线。
我们的GPU被安排在高速总线上，而且总线还有其他设备需要兼顾。因此从通信速度上来说，高速总线并不是那么快，这也是CPU与GPU的通信带宽通常成为瓶颈的其中一个原因。&lt;/p&gt;

&lt;p&gt;图1&lt;/p&gt;

&lt;p&gt;（现实中主板结构图：图片来自网络）&lt;/p&gt;

&lt;p&gt;这里重点介绍下北桥芯片，一个主板上最重要的部分可以说就是主板的芯片组了，主板的芯片组一般由北桥芯片和南桥芯片组成，两者共同组成主板的芯片组。北桥芯片主要负责实现与CPU、内存、AGP接口之间的数据传输，同时还通过特定的数据通道和南桥芯片相连接。南桥芯片主要负责和IDE设备、PCI设备、声音设备、网络设备以及其他的I/O设备的通信。&lt;/p&gt;

&lt;p&gt;主板和CPU发展都现在，北桥芯片慢慢开始消失被集成了CPU中。往后发展，主板芯片组可以看成是以往南桥芯片组的加强版，CPU与主板芯片采用DMI总线进行通信。&lt;/p&gt;

&lt;p&gt;虽然从Lynnfield Core i5/i7开始把北桥集成到CPU上，但是其内部仍是采用QPI总线来通讯，而外部与主板芯片组通讯，其实就是以往主板上南桥与北桥通讯，采用的是DMI总线。因此不能说Lynnfield Core i5/i7是精简了，只是集成度更高而已。&lt;/p&gt;

&lt;h3 id=&quot;手机主板结构与pc不同&quot;&gt;手机主板结构与PC不同&lt;/h3&gt;

&lt;p&gt;以下图片均来源网络&lt;/p&gt;

&lt;p&gt;图1&lt;/p&gt;

&lt;p&gt;图2&lt;/p&gt;

&lt;p&gt;图3&lt;/p&gt;

&lt;p&gt;图4&lt;/p&gt;

&lt;p&gt;手机的主板布局则不同，由于主板不能横向扩展，所以采用双或三层叠层的主板，GPU内嵌在处理器上与CPU同框，且它们周围布满了内存，这样通信更快。
同时由于空间小，功率和高速缓存大小也受到限制。&lt;/p&gt;

&lt;p&gt;多层主板虽然看上去设计巧妙，同时也将几个发热大户都贴在了一起，发热量和速度加倍。&lt;/p&gt;

&lt;p&gt;现代CPU都有一种过热自动降频或者关闭核心的保护措施，因此当玩王者或吃鸡等大型游戏时，就会因为发热而导致它更快的达到阈值温度而降频，这也是很多游戏优化后仍然会卡顿的主要原因。&lt;/p&gt;

&lt;p&gt;因此很多手机引入了水冷（热导管技术）CPU散热技术，用超大一块热导管来散热降温，让CPU不会因为过热而降频或锁核，从而能更长时间甚至全时运行在最大工作频率上，从而发挥出手机宣传时100%的性能。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484964&amp;amp;idx=1&amp;amp;sn=99fd35baa5ad829cbae99753f14aa64b&amp;amp;chksm=fc226323cb55ea3598d74dd2508841f01e149176b2c857c54c077a2d8a3f493033ce8f57b56f&amp;amp;token=1534435063&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料：&lt;/h2&gt;

&lt;p&gt;《主板北桥百科》&lt;/p&gt;

&lt;p&gt;https://baike.baidu.com/item/%E4%B8%BB%E6%9D%BF%E5%8C%97%E6%A1%A5/10252486?fr=aladdin&lt;/p&gt;

&lt;p&gt;《总线百科》&lt;/p&gt;

&lt;p&gt;https://baike.baidu.com/item/%E6%80%BB%E7%BA%BF/108823&lt;/p&gt;

&lt;p&gt;《iPhone 11/Pro Max内部结构示意图》&lt;/p&gt;

&lt;p&gt;http://www.itqianyan.com/m/view.php?aid=5479&lt;/p&gt;

&lt;p&gt;《拆解 iPhone 12 系列》&lt;/p&gt;

&lt;p&gt;https://www.igao7.com/news/202010/L2RP34HNtTEZ2yYC.html&lt;/p&gt;

&lt;p&gt;《iPhone 8和X拆解》&lt;/p&gt;

&lt;p&gt;https://m.iphonediule.com/hot/qiangxian.html&lt;/p&gt;
</description>
               <pubDate>Tue, 26 Oct 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/10/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B047</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/10/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B047</guid>
            </item>
        
            <item>
               <title>读书笔记(四十六) 《如何精彩演讲》#1 演讲的结构</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484952&amp;amp;idx=1&amp;amp;sn=aa014404eb8b71222820f1f3bbff437e&amp;amp;chksm=fc22631fcb55ea0981c20cab77f66da58a2697ab2e8a792f4b4c6ba15a3bc6b57dd2ba7309a1&amp;amp;token=1211671052&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;背景&quot;&gt;背景&lt;/h1&gt;

&lt;p&gt;不知不觉看完了6本关于演讲的主题，按推荐顺序排列分别是《高效演讲》、《演讲与口才》、《即兴演讲》、《关键对话》、《TED演讲的力量》、《说话的艺术》。&lt;/p&gt;

&lt;p&gt;我希望自己能够对演讲有一个系统性的学习。于是自己在平常的生活和工作中实践了一段时间，前前后后加起来有两个月时间。&lt;/p&gt;

&lt;p&gt;目标是，改善平常的工作、生活中表达的流畅和清晰度，能让人感觉到舒服让人感觉有活力。同时在公众演讲上，希望自己能够很好的呈现自己的所思所想以及所知所学。&lt;/p&gt;

&lt;p&gt;因此开启这个演讲学习系列的总结文章，我将对这6本书的内容加上我的实践经验做一次全面的系统性的总结。&lt;/p&gt;

&lt;h1 id=&quot;内容&quot;&gt;内容&lt;/h1&gt;

&lt;p&gt;这一篇主要讲演讲的结构。&lt;/p&gt;

&lt;p&gt;一场演讲分为三个部分：&lt;/p&gt;

&lt;p&gt;第1个部分是，开场。
第2个部分是，核心内容。
第3个部分是，收尾。&lt;/p&gt;

&lt;p&gt;这三个部分都有各自的技巧，而此篇主要来说说具体的演讲内容中的其中一点，即演讲结构。&lt;/p&gt;

&lt;h2 id=&quot;首先来说一下为什么我们需要结构&quot;&gt;首先来说一下为什么我们需要结构？&lt;/h2&gt;

&lt;p&gt;我们在平常的表达过程当中，一般是不会去刻意在意逻辑。
因此，我们在表述过程当中通常是按照时间线来进行表述。
表达过程当中，通常只是说出了自己脑中不断冒出的想法。
在这样的表达下，对方是很难get到我们想要说的内容的。
一旦我们说的内容稍微多一些时，对方很容易进入完全听不懂我们在说了什么情况。&lt;/p&gt;

&lt;p&gt;那么如何才能让对方听清楚，听明白，听得懂我们在说什么呢？&lt;/p&gt;

&lt;p&gt;我们就得用演讲结构去规范我们的演讲内容，让我们的演讲内容能够更清晰的呈现在听众的脑中，让脑袋更容易去记住我们的要点以及中心思想。&lt;/p&gt;

&lt;h2 id=&quot;那什么才是好的演讲结构呢&quot;&gt;那什么才是好的演讲结构呢？&lt;/h2&gt;

&lt;p&gt;首先演讲的内容必须围绕着一个中心思想去讲。
如果中心思想太多，很难让听众记得住，就不会是一个好的演讲。
因此一个演讲最好只有一个中心思想。
中心思想最好是能引起观众共鸣的。
（在后面的内容中再讲如何让中心思想引起共鸣）&lt;/p&gt;

&lt;p&gt;其次你的演讲内容要有层次感。&lt;/p&gt;

&lt;p&gt;在我们表达时最好有意识的按简单顺序进行表达，这样听众们的大脑才能记得住。
比如第一第二第三；过去现在未来；昨天，今天，明天；最重要其次最后等等。&lt;/p&gt;

&lt;p&gt;除了这种层次方式，还有另一种方式，即故事方式。
（后面的文章中再解剖如何讲好一个故事）&lt;/p&gt;

&lt;p&gt;这里先简单介绍一下一个好故事设计要有4个部分，情景带入、遇到危机、冲突和转折、大好结局。&lt;/p&gt;

&lt;p&gt;除了设计故事内容还要注意好故事有4个要点，篇幅小、通俗易懂、简单容易记、有共鸣。&lt;/p&gt;

&lt;p&gt;接着你的演讲内容，最好以总分总的形式去部署。
即提出观点、剖析观点、总结观点。
在开头时阐述演讲要点，结尾时进行要点总结，中间内容分成三个论点，每个论点都由三个句子组成演讲结构。&lt;/p&gt;

&lt;p&gt;这样的演讲结构即“1-3-3-3-1”形式组成的结构，让人听了更舒服也更容易记得住。&lt;/p&gt;

&lt;p&gt;最后在你平时的讲话和沟通表达的过程中，有意识的将自己说话的内容以层次感的形式表现出来。
一开始你可以在讲话前先先打好附稿或准备稿，按123规律来讲，注意不要把第3点和第1点说重复了。
经过长时间的练习，你可以自如的应对各种各样的演讲模式以及各种各样的即兴发挥。&lt;/p&gt;

&lt;h2 id=&quot;那么怎样才能练好演讲结构呢&quot;&gt;那么怎样才能“练”好演讲结构呢？&lt;/h2&gt;

&lt;p&gt;这里给出三个要点。&lt;/p&gt;

&lt;p&gt;第一，每次讲话前先打好腹稿再开口。&lt;/p&gt;

&lt;p&gt;为每次的公众演讲以及平时的沟通交流都打好腹稿，这是一种非常好的练习方式。
这让你时时刻刻提醒自己，在讲话时要有层次感，将这种方法印刻在脑海里，形成肌肉记忆。
时间长了，你自然而然就有了说话的层次感，形成了强有力的肌肉记忆。&lt;/p&gt;

&lt;p&gt;第二，多上台，多在台上运用演讲层次结构。&lt;/p&gt;

&lt;p&gt;台上的感觉和台下的感觉是完全不同的。
在台上你会更加紧张，也更加容易出错，同时更加在意别人对你的看法，也更加害怕。
多上台，多在台上运用演讲的层次结构，会让你在面对陌生场合，在面对激烈、紧张、恐惧时，也能够自如的运用层次感肌肉记忆，让演讲内容流畅清晰的表达出来。&lt;/p&gt;

&lt;p&gt;第三，发现生活中的主题进行层次训练。&lt;/p&gt;

&lt;p&gt;生活和工作中，周围每天都会发生很多的事情，我们可以通过仔细观察我们生活当中发生的事情，叙述或表达我们的观点。
表达时运用层次结构去跟自己对话，这样的训练每天都可以进行，有助于我们更快更好的形成肌肉记忆。&lt;/p&gt;

&lt;h2 id=&quot;最后告诉大家如何获得练习反馈&quot;&gt;最后告诉大家，如何获得练习反馈。&lt;/h2&gt;

&lt;p&gt;这里有三个方法告诉大家。&lt;/p&gt;

&lt;p&gt;1.录制后自我复盘。&lt;/p&gt;

&lt;p&gt;我们演讲的反馈可以通过自己录制视频，录制音频后进行复听来复盘自己的演讲。&lt;/p&gt;

&lt;p&gt;2.通过他人获得评价。&lt;/p&gt;

&lt;p&gt;可以通过同事、朋友、家人、以及专门演讲圈的人对自己的评价来复盘自己的演讲，从而获得自己改进的方向。&lt;/p&gt;

&lt;p&gt;但要注意，别人对你的负面评价要小心。
通常那些不专业的人给你的评价，都是打击你自信心的一个常见途径。
我们需要的是鼓励，而不是打击。鼓励让我们更有动力前进。而打击则适得其反。&lt;/p&gt;

&lt;p&gt;3.通过专业演讲训练师来反馈。&lt;/p&gt;

&lt;p&gt;最好是通过专业的演讲导师来纠正你的演讲问题，从而给予你正确的演讲练习方式和修正方向。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484952&amp;amp;idx=1&amp;amp;sn=aa014404eb8b71222820f1f3bbff437e&amp;amp;chksm=fc22631fcb55ea0981c20cab77f66da58a2697ab2e8a792f4b4c6ba15a3bc6b57dd2ba7309a1&amp;amp;token=1211671052&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

</description>
               <pubDate>Sun, 17 Oct 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/10/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B046</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/10/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B046</guid>
            </item>
        
            <item>
               <title>思路探讨(六十六) 人和事</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484939&amp;amp;idx=1&amp;amp;sn=e3df251c9cb4733784e5df9ccd21e3ab&amp;amp;chksm=fc22630ccb55ea1a27f035c062122bf9e40a504d0dac7143b0a383b4f7dc729dc8596cc10958&amp;amp;token=254199611&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;有两周时间没有发文章了，最近有些忙，自己也遇到了瓶颈，正在突破。&lt;/p&gt;

&lt;p&gt;前几个月发现我的表达能力有些弱，表达逻辑混乱，表达时没有自信。&lt;/p&gt;

&lt;p&gt;所以呢，我特别花了一些精力去加强这方面的训练。&lt;/p&gt;

&lt;p&gt;自己做了一些训练，去演讲俱乐部练习演讲，去读书聚会的地方做演讲，以及做主持人的表达工作。&lt;/p&gt;

&lt;p&gt;我希望通过这样的锻炼，提升表达能力。也看了几本书，暂时还没有去总结它们，希望后面能够挤出时间来写些关于这个主题书的读书总结。&lt;/p&gt;

&lt;p&gt;为什么要去做沟通跟表达演讲的训练呢？我内心声音是，我要解决人与人之间的关系，人与人之间的沟通。&lt;/p&gt;

&lt;p&gt;前面10几年都在做练习解决事情的技巧，比如我要写好程序，写书，写文章，都是去总结一些解决事情的经验。&lt;/p&gt;

&lt;p&gt;不管是程序还是项目还是工作分配工作拆解，都是需要我们去解决事情。这是我前面12年做的事情。&lt;/p&gt;

&lt;p&gt;我最近领悟到，其实解决事情只占了30%的部分，剩余的70%的部分并不是靠解决事情来解决的，而是靠做人，解决人与人之间关系来搞定的。&lt;/p&gt;

&lt;p&gt;一个典型的例子，在工作当中如果我们跟上级相处不好的话，跟家人的关系不好，你即使把成绩做出来了，也得不到家人的肯定，和领导的赏识，这对我们的感受有巨大影响，甚至会有强烈的挫败感。&lt;/p&gt;

&lt;p&gt;因此现阶段的我认为，解决人与人之间的关系比解决事情更重要。&lt;/p&gt;

&lt;p&gt;最重要的其实不是事情本身，而是与事情有关的人，这些人才是关键。例如事情提出的人是领导，或与事件有关的人是同事，在他们提出问题时，先确立这是不是个事实。&lt;/p&gt;

&lt;p&gt;我相信大部分时候是事实，也可能是被夸大的事实。当我们去做事时，其实应该首先跟他们聊一聊，跟老板聊一聊，跟这些部门的人来聊一聊，这样的才能体会到对方的感受，以及看到对方究竟想要的。&lt;/p&gt;

&lt;p&gt;跟人联系、寒暄后，才能知道对方的情绪、想法、需要，这时再想办法来解决问题&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484939&amp;amp;idx=1&amp;amp;sn=e3df251c9cb4733784e5df9ccd21e3ab&amp;amp;chksm=fc22630ccb55ea1a27f035c062122bf9e40a504d0dac7143b0a383b4f7dc729dc8596cc10958&amp;amp;token=254199611&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

</description>
               <pubDate>Tue, 12 Oct 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/10/12/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A866</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/10/12/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A866</guid>
            </item>
        
            <item>
               <title>读书笔记(四十五) 《游戏引擎架构》#3 链接、图形计算库、资产管理模块</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484932&amp;amp;idx=1&amp;amp;sn=13c96ed5d6a24abe43d9a63a5e2aca23&amp;amp;chksm=fc226303cb55ea1527fead1e2d90b435a6eb911cb54e58ffbde95b674f1982859fa6a66f3837&amp;amp;token=1405609858&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;背景&quot;&gt;背景：&lt;/h1&gt;

&lt;p&gt;作为游戏开发从业者，从业务到语言到框架到引擎，积累了一些知识和经验，特别是在看了好几遍《游戏引擎架构》后对引擎的架构感触颇深。&lt;/p&gt;

&lt;p&gt;近段时间对引擎剖析的想法也较多，正好借着书本对游戏引擎架构做一个完整分析。此书用简明、清楚的方式覆盖了游戏引擎架构的庞大领域，巧妙地平衡了广度与深度，并且提供了足够的细节，使得初学者也能很容易地理解其中的各种概念。&lt;/p&gt;

&lt;p&gt;我的目标是掌握游戏引擎架构知识，我的方法是借助《游戏引擎架构》这本书、结合引擎源码和自己的经验，深入分析游戏引擎的历史、架构、模块。最后通过实践简单引擎开发来完成对引擎知识的掌握。&lt;/p&gt;

&lt;p&gt;游戏引擎知识面深而广，所以对这系列的文章书编写范围做个保护，即不对细节进行过多的阐述，重点剖析的是架构、流程以及模块的运作原理。&lt;/p&gt;

&lt;p&gt;由于《游戏引擎架构》此书的部分知识太浅或太过陈旧，所以不得不将部分知识重新深挖后总结出自己的观点。&lt;/p&gt;

&lt;h1 id=&quot;概述&quot;&gt;概述：&lt;/h1&gt;

&lt;p&gt;本章开始对引擎中的重要的模块和库进行详细的分析，我挑选了十五个库和模块来分析：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;时间库&lt;/li&gt;
  &lt;li&gt;自定义容器库&lt;/li&gt;
  &lt;li&gt;字符串散列库&lt;/li&gt;
  &lt;li&gt;内存管理框架&lt;/li&gt;
  &lt;li&gt;RTTI与反射模块&lt;/li&gt;
  &lt;li&gt;图形计算库&lt;/li&gt;
  &lt;li&gt;资产管理模块&lt;/li&gt;
  &lt;li&gt;低阶渲染器&lt;/li&gt;
  &lt;li&gt;剔除与合批模块&lt;/li&gt;
  &lt;li&gt;动画模块&lt;/li&gt;
  &lt;li&gt;物理模块&lt;/li&gt;
  &lt;li&gt;UI核心框架&lt;/li&gt;
  &lt;li&gt;性能剖析器的核心部分&lt;/li&gt;
  &lt;li&gt;脚本系统&lt;/li&gt;
  &lt;li&gt;视觉效果模块&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本篇内容为列表中的6、7。&lt;/p&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文：&lt;/h1&gt;

&lt;p&gt;简单回顾下前文，前面我们聊了时间库、自定义容器、字符串、内存管理这四个模块的技术原理和特点，它们都是大型软件架构所必备的模块，同时简单讲述了它们在Unreal和Unity中存在的特点。&lt;/p&gt;

&lt;h2 id=&quot;编译链接过程与内存布局&quot;&gt;编译链接过程与内存布局&lt;/h2&gt;

&lt;p&gt;图1&lt;/p&gt;

&lt;p&gt;图2&lt;/p&gt;

&lt;p&gt;简单回顾一下C++编译过程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;源文件.cpp文件被编译成.o文件后由链接器链接成可执行文件或库文件。&lt;/li&gt;
  &lt;li&gt;库分为静态库和动态库。其中静态库为只是简单集合了.o文件，而动态库则是一个完整的编译、链接产物。&lt;/li&gt;
  &lt;li&gt;头文件.h文件不是编译的必需品，它只是包含在源文件中的声明文件。&lt;/li&gt;
  &lt;li&gt;Linux的so和Windows的DLL虽然都是ELF文件格式，但最终格式差了很多，因此不能互相使用。&lt;/li&gt;
  &lt;li&gt;编译器开启优化后（一般是Release时），会优化代码，包括内联、调换代码顺序、更改代码为最优等。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体可以看我前面写的《链接、装载与库》&lt;/p&gt;

&lt;p&gt;http://luzexi.com/2021/06/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B029&lt;/p&gt;

&lt;p&gt;也同时回顾下C++内存布局：
    1.C++内存布局中有，类、变量、内存对齐、虚表、RTTI
    2.类和结构在C++中差异较少
    3.每个变量内存占用量不同，int（32bit）、short int（16bit）、long long int（64bit）、float（4bit）、double（8bit）、char（8bit）等
    4.默认按4字节（32bit）对齐，不足4字节的编译器会补齐
    5.虚函数或虚继承的类有虚表及虚表指针
    6.没有RTTI的情况下，虚表只有当前的虚函数指针
    7.有RTTI的情况下，虚表中有type_info指针
    8.有RTTI的情况下，虚指针指向虚表中的第二个格子，即虚指针，第一个格子为type_info指针&lt;/p&gt;

&lt;p&gt;具体可以看我前面写的《深度探索C++对象模型-总结》&lt;/p&gt;

&lt;p&gt;http://luzexi.com/2020/11/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B014&lt;/p&gt;

&lt;h2 id=&quot;图形计算库&quot;&gt;图形计算库&lt;/h2&gt;

&lt;p&gt;图形库涉及内容有图形元素和运算两种，它们分别包含，点、矢量、矩阵、四元数、图形对象以及相关的运算（包括SIMD）。&lt;/p&gt;

&lt;p&gt;下面我们来介绍一下：&lt;/p&gt;

&lt;p&gt;矢量运算包括：矢量加减法、模、归一化、点积、投影、叉积、线性插值等。&lt;/p&gt;

&lt;p&gt;矩阵有，单位矩阵、转置矩阵、逆矩阵、齐次坐标。矩阵运算，包括矩阵乘法、加减法、除、与、或等。&lt;/p&gt;

&lt;p&gt;四元数运算包括，四元数乘法、加减法、逆运算、旋转矢量、等价的四元数矩阵、旋转线性插值、球面线性插值等。&lt;/p&gt;

&lt;p&gt;各图形转换操作，包括旋转、缩放、投影、平移、LookAt等。&lt;/p&gt;

&lt;p&gt;图形对象包括，直线、线段、球体、平面、包围盒、平截头体、圆形、矩形、三角形等。&lt;/p&gt;

&lt;p&gt;这部分内容可以在Unreal的Engine\Source\Runtime\Core\Public\Math中找到。&lt;/p&gt;

&lt;h3 id=&quot;下面简单介绍下simd&quot;&gt;下面简单介绍下SIMD：&lt;/h3&gt;

&lt;p&gt;硬件加速SIMD运算（Single instruction multiple data），单指令多数据，是指，现代微处理器用一个指令并行地对多个数据执行数学运算，它能帮助我们加速运算。&lt;/p&gt;

&lt;p&gt;游戏引擎中最常用的是SSE模式（Streaming SIMD extensions，SSE），它包裹了4个32位float值，它们都被打包进了一个128位寄存器。&lt;/p&gt;

&lt;p&gt;单个指令可对4对浮点数进行并行运算，如加法或乘法。在计算四元矢量和4x4矩阵相乘时特别有用。&lt;/p&gt;

&lt;p&gt;需要注意的是
1.由于在浮点运算器和SSE寄存器之间传输数据很糟糕，所以不要混合使用普通浮点数和SIMD运算，这样会使得CPU整个指令执行流水线停顿，浪费CPU周期。
2.在VS中用SIMD数据类型__m128声明的临时变量或参数，编译器通常会把它们直接置于SSE寄存器中而非内存栈。
3.动态分配SIMD结构时要注意内存按16字节对齐&lt;/p&gt;

&lt;h2 id=&quot;资产管理模块&quot;&gt;资产管理模块&lt;/h2&gt;

&lt;p&gt;先说文件系统&lt;/p&gt;

&lt;h3 id=&quot;文件系统&quot;&gt;文件系统&lt;/h3&gt;

&lt;p&gt;游戏引擎中的文件系统相对比较简单：
1.每个平台的路径、API不同，对平台需要做些封装。
2.文件读取的阻塞方式分同步和异步。&lt;/p&gt;

&lt;p&gt;其中同步需要阻塞当前进程来等待IO，异步则通过分线程阻塞等待IO，其两者原理是一样，都是调用内核读取文件且都需要等待IO。&lt;/p&gt;

&lt;p&gt;以前写过一篇关于操作系统内核中文件操作的底层原理《链接、装载与库 - 内核运行库》大家可以参考下。&lt;/p&gt;

&lt;p&gt;这里顺便简单回顾一下文件内核原理：&lt;/p&gt;

&lt;p&gt;图1&lt;/p&gt;

&lt;p&gt;图2&lt;/p&gt;

&lt;p&gt;这两张图清晰的表达了内核文件的读写原理：
1.操作系统内核中对每个打开的文件都有个内核对象
2.所有文件内核对象都被集中索引到一个数组中，称为文件打开表
3.文件表数组前三个元素填充的是stdin、stdout、stderr这三个内核对象
4.为了增加读写效率，内核已经实现了文件读取缓冲，会读取一段一段的读取
5.读取步骤，用户程序先开辟一段内存，内核程序则利用缓冲读取，不足时多次读取，结束时返回数据。&lt;/p&gt;

&lt;h2 id=&quot;资产管理器&quot;&gt;资产管理器&lt;/h2&gt;

&lt;p&gt;早前很多引擎都有独立的资产管理器，它被制作成了一个独立的软件，专门用于管理游戏资产，包括网格、材质、纹理、着色器程序、动画、音频、配置等。&lt;/p&gt;

&lt;p&gt;资产管理器本身是一个具有清晰设计、统一、中心化的子系统，负责管理游戏中用到的所有类型的资产，只是现代大多引擎已经将资产管理整合到引擎编辑器中。&lt;/p&gt;

&lt;h3 id=&quot;资产管理器解决了什么问题答案是&quot;&gt;资产管理器解决了什么问题？答案是：&lt;/h3&gt;
&lt;p&gt;1.资产预览，资产在引擎中快速预览，并对不同资产类型区分展示。
2.资产查找，通过查找功能快速查找到资产。
3.资产组合，通过组合信息管理资产各个依赖。
    资产通常组合在一起使用，因此组合信息是资产管理的一部分。
    加载时需要依赖多个资产，引擎通过资产元数据将这些信息保存下来。
4.资产转换，将外部资产导入到引擎中使用。
    外部资产需要经过一定的转换才能在引擎中使用。
    引擎通常有自己的资产导入系统，将外部资产转换为自身使用的数据格式。
5.运行时资产管理，引擎向应用层提供加载和释放资产接口，并管理已加载资产对象。
    资产的加载和释放，引擎需要提供给应用层加载和释放资产的接口，引擎本身也需要对这些资产进行管理。&lt;/p&gt;

&lt;p&gt;下面我们从资产管道、资产类型、运行时资产管理、元文件、资产包，四个方面介绍下引擎中的资产管理器。&lt;/p&gt;

&lt;h3 id=&quot;资产管道&quot;&gt;资产管道：&lt;/h3&gt;

&lt;p&gt;每个资产都需要通过资产管道才能最终被游戏引擎所使用。每个资产管道的始端都是DCC原生格式的源资产（Maya的.ma或.mb、3DMax的.max或.obj、Photoshop的.psd文件等）。资产经过资产管道的导出器、资产编译器、资产链接器，最终生成了游戏引擎可以使用的数据格式。&lt;/p&gt;

&lt;p&gt;第一步，通常DCC工具需要撰写自定义插件（大都已提供现成统一的插件），把DCC里的数据导出为某种中间格式（例如.fbx格式），一般DCC工具都会提供接口或脚本供程序员写导出插件。
第二步，中间格式数据仍然需要经过一定的转换才能被引擎使用，因此引擎通过资产编译器转换中间格式。
第三步，通常多个资产组合后才成为一个完整资产，例如网格文件、材质文件、动画文件、贴图文件等，它们经过资产链接器连接后组合成为完整的资产。&lt;/p&gt;

&lt;h3 id=&quot;资产类型&quot;&gt;资产类型：&lt;/h3&gt;

&lt;p&gt;资产经过资产管道后会生成相应的资产相关文件，包括：
1.资产源文件
2.资产配置文件（元数据文件）
3.资产目标文件&lt;/p&gt;

&lt;p&gt;资产也分为外部和内部资产，外部资产由DCC导出，内部资产则通过引擎生成，例如材质球、动画控制器、蓝图、粒子等。
资产配置文件记录了资产在引擎中的配置信息和依赖关系。
资产目标文件是引擎根据资产源文件和配置信息生成的符合引擎使用格式的资产文件。&lt;/p&gt;

&lt;p&gt;生成资产元数据文件和目标文件的目的是：
1.在保留原资产文件格式的前提下，生成引擎能使用的格式文件。
2.便于引擎获取每个资产文件的配置及依赖关系。
3.便于引擎统一管理资产，管理资产的目的是，提供例如建立资产数据库、查找、同步、打包等功能。&lt;/p&gt;

&lt;p&gt;Unity引擎使用Mate文件存储资产的配置和依赖关系。当引擎导入资产时就会生成相应的Mate文件，并根据这个Mate文件在Library文件夹下生成目标文件，同时根据修改的Mate文件配置来调整或重新生成目标文件。&lt;/p&gt;

&lt;p&gt;Unreal引擎则稍稍有些不同，资产源文件仍然会转换成资产目标文件，只是它把资产配置文件和资产目标文件合并在一个uasset文件中，这样导入后源文件就不再需要。如果你想要获取元数据，UE4也提供了python接口和蓝图接口。&lt;/p&gt;

&lt;h3 id=&quot;运行时资产管理&quot;&gt;运行时资产管理：&lt;/h3&gt;

&lt;p&gt;运行时资产管理通常包括，资产对象管理、资产对象映射管理。&lt;/p&gt;

&lt;p&gt;资产从加载到实例化，在引擎内部必须有一个有效的管理机制，其职责为：
1.同一份资源只会存在一个副本
2.管理资产生命周期，确保不需要时卸载
3.处理复合资产，复合资产依赖多个资产组合而成。
4.维护引用，确保复合资产在内存中的引用关系正确。
5.资产接口，提供资产载入与卸载接口，包含同步和异步的载入方式。&lt;/p&gt;

&lt;p&gt;基于这五个职责，资产在运行时的引擎中必须拥有信息为，资产地址，资产对象，资产对象ID（运行时ID）。&lt;/p&gt;

&lt;p&gt;部分引擎对每个资源都配备了资产唯一ID（GUID），让资产地址与资产唯一ID有绑定关系，这使得引擎在资产迁移时能发挥更好的作用。&lt;/p&gt;

&lt;p&gt;资产对象映射管理包括：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;资产路径与资产唯一ID的映射关系&lt;/li&gt;
  &lt;li&gt;资产唯一ID与资产对象ID的映射关系&lt;/li&gt;
  &lt;li&gt;资产对象ID与资产对象的映射关系&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有了这些映射关系，引擎就能通过资产路径查找到资产对象，从而保证不重复加载，并维护好各资产之间的引用关系。&lt;/p&gt;

&lt;p&gt;在UE4和Unity上也同样做了这种类型的资产映射关系的管理。&lt;/p&gt;

&lt;h3 id=&quot;资产加载和卸载&quot;&gt;资产加载和卸载&lt;/h3&gt;

&lt;p&gt;资产加载与卸载接口必不可少，通常引擎都会定制一些依赖数据，例如前面提到的资产配置文件（也可以说是资产元数据），多个资产组合达成资源包时，资源包之间的依赖关系也同样需要有数据来维护。&lt;/p&gt;

&lt;p&gt;引擎都会有资源加载的统一接口，包括加载和卸载，同步和异步，资源包和非资源包形式。&lt;/p&gt;

&lt;p&gt;图&lt;/p&gt;

&lt;p&gt;引擎的资产加载和卸载框架各引擎之间稍有不同，不过总体差不了太多，或直接IO调用，或用开启线程后做IO调用，然后通过存储资产对象与映射关系来搭建资产加载和释放的框架，由于各个引擎接口都不一样，不做详细介绍。&lt;/p&gt;

&lt;h3 id=&quot;资源包数据格式&quot;&gt;资源包数据格式&lt;/h3&gt;

&lt;p&gt;通常引擎都会提供类似AssetBundle的资源组合包，便于外部资源下载和更新。&lt;/p&gt;

&lt;p&gt;在UE4和Unity上都有相同的功能，只是命名不同，UE4为Pak，Unity为AssetBundle。&lt;/p&gt;

&lt;p&gt;Pak或AssetBundle中存放着多个复合资产，通过引擎接口加载指定资产。&lt;/p&gt;

&lt;p&gt;图&lt;/p&gt;

&lt;p&gt;为了方便理解，我把数据格式从头往下画。实际中的Pak和AssetBundle数据格式要倒一下，头信息在最底部，资产数据块在最前头。&lt;/p&gt;

&lt;p&gt;资源包数据格式：
1.文件头信息与数据块拆分
2.可整体压缩或部分压缩
3.通过依赖配置加载外部资源包&lt;/p&gt;

&lt;p&gt;资源包可以通俗的认为是一个多文件的组合，它可以自己做压缩，也可以让资产压缩后再组合成文件。&lt;/p&gt;

&lt;p&gt;通常资源包的数据格式由文件头和数据块两部分组成。文件头信息中包含了资产信息和偏移量，通过加载文件头，就能知道资产在文件中的位置、类型、名称、大小等。&lt;/p&gt;

&lt;p&gt;这种资产组织方式使得我们通过差量方式更新资产成为可能。&lt;/p&gt;

&lt;p&gt;图&lt;/p&gt;

&lt;p&gt;根据资源包的数据格式特点，可以规划差量更新步骤：
1.打差量包，包头保持完整，数据块则只加入差量部分
2.下载差量包
3.合并两个资源包文件
4.合并时使用差量包头作为文件头
5.合并时提取原资源包中的不更新部分和差量包中的更新部分放入新的资源包文件中
6.更新完成生成新的资源文件&lt;/p&gt;

&lt;p&gt;这部分内容Unity和Unreal并无太大差异。&lt;/p&gt;

&lt;h2 id=&quot;资产规范&quot;&gt;资产规范&lt;/h2&gt;

&lt;p&gt;资产规范目标：
规范命名，防止程序报错，方便自动化检测，方便筛选找寻。
优化内容，每个项目资源都应该有存在目的。
减短路径，路径简短易寻。&lt;/p&gt;

&lt;p&gt;图&lt;/p&gt;

&lt;p&gt;网上有同学分享的很详细了，这里就不赘述，参考《UE4工程规范》：&lt;/p&gt;

&lt;p&gt;https://github.com/skylens-inc/ue4-style-guide/blob/master/README.md#12-%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B%E8%A1%A8-&lt;/p&gt;

&lt;h3 id=&quot;参考资料&quot;&gt;参考资料：&lt;/h3&gt;

&lt;p&gt;《游戏引擎架构》叶劲峰 译&lt;/p&gt;

&lt;p&gt;《游戏引擎原理与实践》 程东哲 著&lt;/p&gt;

&lt;p&gt;《vmath》&lt;/p&gt;

&lt;p&gt;https://github.com/BlackMATov/vmath.hpp#Matrix-Transform-3D&lt;/p&gt;

&lt;p&gt;《从虚函数表到RTTI》&lt;/p&gt;

&lt;p&gt;https://zhuanlan.zhihu.com/p/150579874&lt;/p&gt;

&lt;p&gt;《虚幻引擎4文档》&lt;/p&gt;

&lt;p&gt;https://docs.unrealengine.com/4.27/zh-CN/Basics/AssetsAndPackages/AssetMetadata/&lt;/p&gt;

&lt;p&gt;《UE4工程规范》&lt;/p&gt;

&lt;p&gt;https://github.com/skylens-inc/ue4-style-guide/blob/master/README.md#12-%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B%E8%A1%A8-&lt;/p&gt;

&lt;p&gt;《链接、装载与库 - 内核运行库》&lt;/p&gt;

&lt;p&gt;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484809&amp;amp;idx=1&amp;amp;sn=89091ecce47229ebf10e4855c0ccceca&amp;amp;chksm=fc22608ecb55e998cdff3952057e6d1c6f099463797d57458ec1f4d37a432d46dc3c5bfcfbb5&amp;amp;token=557108361&amp;amp;lang=zh_CN#rd&lt;/p&gt;

&lt;p&gt;《链接、装载与库 - 静态链接》&lt;/p&gt;

&lt;p&gt;http://luzexi.com/2021/06/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B029&lt;/p&gt;

&lt;p&gt;《深度探索C++对象模型-总结》&lt;/p&gt;

&lt;p&gt;http://luzexi.com/2020/11/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B014&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484932&amp;amp;idx=1&amp;amp;sn=13c96ed5d6a24abe43d9a63a5e2aca23&amp;amp;chksm=fc226303cb55ea1527fead1e2d90b435a6eb911cb54e58ffbde95b674f1982859fa6a66f3837&amp;amp;token=1405609858&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

</description>
               <pubDate>Tue, 28 Sep 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/09/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B045</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/09/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B045</guid>
            </item>
        
            <item>
               <title>读书笔记(四十四) 《心流》#3 专注时人们的表现</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484913&amp;amp;idx=1&amp;amp;sn=9589d58b41c85d01d1aaa68872260539&amp;amp;chksm=fc2260f6cb55e9e08222aa5096a65949a05c98edc73eb005e289e11010c68a4816ed35a50035&amp;amp;token=134603822&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;背景&quot;&gt;背景：&lt;/h1&gt;

&lt;p&gt;在2020年初就买了《心流》，直到2021年1月才读完第一遍，读完的那一刻，我知道我又打开了一个新世界。&lt;/p&gt;

&lt;p&gt;不得不承认就是这本书让我的专注力提高了整整一个级别，这是最让我非常兴奋的地方。而我只是读了第一遍，吸收不到10%的结果，可想而知它的魔力有多么强大。&lt;/p&gt;

&lt;p&gt;于是决定好好回顾总结一下整本书，便开启了第二遍、第三遍的读书之旅。&lt;/p&gt;

&lt;p&gt;读此书的起源是由于我在平时工作、交流、学习时，常常难以集中注意力，因此带着好奇心阅读了这本书。&lt;/p&gt;

&lt;p&gt;我猜大家应该也和我一样，常常为自己难以击中注意力而烦恼，其实我们都希望自己在专注做一件事情的时候能够拥有更高的效率。&lt;/p&gt;

&lt;p&gt;本书的核心是心流的最优体验，简单来说就是“如何让你高兴地专注”。&lt;/p&gt;

&lt;p&gt;作者想表达的是，当你的心流会的体验最佳时，也是学习效率最高的时候，同时也是你最幸福的时刻。&lt;/p&gt;

&lt;p&gt;书本中讲到了关于学习、工作、运动、社交等各方面的心流原理和技巧，我作为知识的搬运工，做了一些精炼和总结的工作。&lt;/p&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文：&lt;/h1&gt;

&lt;p&gt;简单回顾下前文：&lt;/p&gt;

&lt;p&gt;前文我们说了专注力能带给我们幸福，生活让我们感到痛苦的一个重要原因是人们欲望无法填满，我们生活在这个社会被这个的规则所牵动，已经沦为社会的奴隶，在这种环境培养独立意识非常重要同时也非常艰难。&lt;/p&gt;

&lt;h2 id=&quot;控制意识能改善体验的品质&quot;&gt;控制意识能改善体验的品质&lt;/h2&gt;

&lt;p&gt;想要控制意识，首先要了解它。那么意识究竟是如何运作的呢？&lt;/p&gt;

&lt;p&gt;“意识”简单来说就是，某些我们能感觉到的，且有能力引导其方向的东西，诸如情绪、感觉、思想、企图等。&lt;/p&gt;

&lt;p&gt;首先，一个人可以不管外界不管发生什么事，只靠改变意识的内涵，使自己快乐或悲伤。&lt;/p&gt;

&lt;h3 id=&quot;其次意识的力量可以把无助的境况转变为有机会反败为胜的挑战&quot;&gt;其次，意识的力量可以把无助的境况转变为有机会反败为胜的挑战。&lt;/h3&gt;

&lt;p&gt;我们口中所说的奋斗不辍、克服万难的毅力，它不但是成功的要素，也是享受人生的不二法门。&lt;/p&gt;

&lt;h3 id=&quot;最后控制意识需要毅力而培养毅力应该从建立意识的秩序控制感觉与思想着手且最好不要企图走捷径&quot;&gt;最后，控制意识需要毅力，而培养毅力应该从建立意识的秩序、控制感觉与思想着手，且最好不要企图走捷径。&lt;/h3&gt;

&lt;p&gt;瑜伽行者就是控制意识的高手，但跟任何高手一样，他们下了多年功夫苦练，一刻都不懈怠。&lt;/p&gt;

&lt;p&gt;唯有这样投注所有时间与心力，提升操纵内在体验的技巧，方能成为专家。&lt;/p&gt;

&lt;h2 id=&quot;意识的极限&quot;&gt;意识的极限&lt;/h2&gt;

&lt;p&gt;生活中有太多的事情需要我们的注意，但我们顶多同时应付七组资讯，诸如分辨声音、影像、情绪或思想中可辨识的弦外之音等。&lt;/p&gt;

&lt;p&gt;大多数人在每天的三分之一的闲暇时间里，都尽可能避免用脑子，这段空档一半以上都在电视前、杂志、抖音、微信聊天、看app资讯上消磨掉。&lt;/p&gt;

&lt;p&gt;因此对于我们来说，准许哪些资讯进入意识就显得格外重要，这实际上，就决定了我们生活的内涵与品质。&lt;/p&gt;

&lt;h3 id=&quot;神经系统在特定时间内能处理的资讯极为有限每次只能认知和回应一定数量的事件而新涌进来的会把旧的挤掉所以思绪必须井然有序否则就会混乱&quot;&gt;神经系统在特定时间内能处理的资讯极为有限，每次只能认知和回应一定数量的事件，而新涌进来的会把旧的挤掉。所以思绪必须井然有序，否则就会混乱。&lt;/h3&gt;

&lt;h2 id=&quot;注意力是无价的资源&quot;&gt;注意力是无价的资源&lt;/h2&gt;

&lt;p&gt;注意力再强大也无法超越我们前面谈到的限制，它只能在一定时间内处理一定数量的资讯。&lt;/p&gt;

&lt;p&gt;从记忆库中取出资讯，理解、比较、评估，然后做决定，都需要心灵有限的资讯处理能力。&lt;/p&gt;

&lt;h3 id=&quot;控制意识最明显的指标就是能随心所欲地集中注意力不因任何事情而分心若能做到这一点就能在日常生活中找乐趣&quot;&gt;控制意识最明显的指标就是能随心所欲地集中注意力，不因任何事情而分心。若能做到这一点，就能在日常生活中找乐趣。&lt;/h3&gt;

&lt;p&gt;作者举例一位学员E女士：&lt;/p&gt;

&lt;p&gt;她无时无刻不在写作、解决问题、阅读报纸、翻阅当日行程，或只是提出问题，仔细观察周遭事物，并计划下一步的工作。&lt;/p&gt;

&lt;p&gt;她只花很少的时间在日常例行公事上。&lt;/p&gt;

&lt;p&gt;她每天都会抽出时间来位心灵充电，如在湖畔伫立15分钟，闭上眼睛让阳光洒在脸上，或牵着狗在镇外山坡上散步。&lt;/p&gt;

&lt;p&gt;她能充分控制注意力，可以随时把意识关闭，打个盹，然后恢复精神。&lt;/p&gt;

&lt;p&gt;另一位学员R先生：&lt;/p&gt;

&lt;p&gt;说话时目光深邃；听人说话时，往往从多方面分析对话的话语。&lt;/p&gt;

&lt;p&gt;一般人视为理所当然的事常令他感到困惑；在用原创但十分贴切的方式详加分析前，他绝不让任何事轻易溜走。&lt;/p&gt;

&lt;p&gt;R先生尽管不断地磨炼知性，外表却给人一种沉着、宁静的感觉。他似乎永远能察觉到周遭最微小的变动。&lt;/p&gt;

&lt;p&gt;他注意一件事，目的不在于改善或批判它，只要能够观察和了解事实，并表达自己的看法，他就心满意足了。&lt;/p&gt;

&lt;p&gt;R先生不像E女士那样对社会造成立刻的冲击，但他的意识同样复杂而有条理。&lt;/p&gt;

&lt;p&gt;他把注意力尽可能延伸，跟周遭的世界密切结合起来。&lt;/p&gt;

&lt;p&gt;跟E女士一样，他也能充分享受人生。&lt;/p&gt;

&lt;h2 id=&quot;像探照灯那样集中注意力&quot;&gt;像探照灯那样集中注意力&lt;/h2&gt;

&lt;p&gt;大多数人都不能像E女士或R先生那样，把有限的注意力像探照灯一般集中成一道光束，而是任它毫无章法的散开。&lt;/p&gt;

&lt;h3 id=&quot;这说明生活中人们应用注意力的方式足以决定人生的外观与内涵从而反应人们为人处世的现象&quot;&gt;这说明生活中人们应用注意力的方式足以决定人生的外观与内涵，从而反应人们为人处世的现象。&lt;/h3&gt;

&lt;p&gt;例如，在同一个宴会上，外向的人热衷于与人交际；成就不凡的人寻求有用的商界人脉；偏执狂则随时警惕，怕碰到危险等等。&lt;/p&gt;

&lt;p&gt;每种人都有自己的注意力探照灯，这也是不同人之间的差异。&lt;/p&gt;

&lt;p&gt;实际上工作生活中，我们每个职业都在训练自己的集中注意力的方式，例如，软件工程师会更多关注计算机软件运行过程，销售人员更关注人与人之间的交流与谈判，银行家更专注财务状况，运动员更关注动作协调与身体素质等等等等。&lt;/p&gt;

&lt;p&gt;这种探照灯一样的集中方式正是他们在专业领域中学会了如何抓住领域中易受忽略的讯号。&lt;/p&gt;

&lt;h2 id=&quot;内在失序与精神熵&quot;&gt;内在失序与精神熵&lt;/h2&gt;

&lt;p&gt;内在失序的意思是，外来资讯跟当下的意图发生冲突，使我们分心，使我们无法为现实意图而努力，造成对意识极为不利的影响。&lt;/p&gt;

&lt;p&gt;作者举了一个例子，胡里欧破轮胎的故事。他的汽车轮胎破了，于是他一大早小心翼翼地把车开到加油站，把轮胎的气打满，又尽快开到工厂。下班时轮胎气又漏光了，他再到工厂附近加油站打满气后再开回家。胡里欧如法炮制了三天，一整天他都在担心，今晚是否能回家以及明天是否能到岗。这使得他无法专心工作，情绪也变得烦躁不安。&lt;/p&gt;

&lt;h3 id=&quot;每当周围的环境对意识的目标构成威胁就会发生内在的失序现象这称为精神熵&quot;&gt;每当周围的环境对意识的目标构成威胁，就会发生内在的失序现象，这称为精神熵。&lt;/h3&gt;

&lt;h3 id=&quot;它会导致自我解体使效率大打折扣&quot;&gt;它会导致自我解体，使效率大打折扣。&lt;/h3&gt;

&lt;h3 id=&quot;这种状况若持续太久对自身造成严重的损害使自我再也不能集中注意力实现任何目标&quot;&gt;这种状况若持续太久，对自身造成严重的损害，使自我再也不能集中注意力实现任何目标。&lt;/h3&gt;

&lt;h2 id=&quot;井然有序的意识&quot;&gt;井然有序的意识&lt;/h2&gt;

&lt;p&gt;精神熵的反面就是最优体验。&lt;/p&gt;

&lt;h3 id=&quot;当我们专注于资讯与目标时精神能量就会源源不断涌上来这时我们就没有了忧虑情绪也不再猜疑自己的能力&quot;&gt;当我们专注于资讯与目标时，精神能量就会源源不断涌上来，这时我们就没有了忧虑情绪，也不再猜疑自己的能力。&lt;/h3&gt;

&lt;p&gt;我们不再怀疑自己，也是因为我们得到了明确的鼓励，你做的很好。这种积极的反馈，强化了自我，使我们能投入更多的注意力，照顾内心与外在环境的平衡。&lt;/p&gt;

&lt;p&gt;作者举了一个例子。麦德林的工作是装配线上的工人，每天要重复600次的工作，像这样枯燥的工作，他做了五年，但还是觉得很快乐。因为他对工作的态度跟一名奥运选手差不多，常常思索如何打破纪录。他像外科医生一般一丝不苟的设计工具的安放顺序和每一步动作，经过五年的努力，他最好的成绩是28秒装配完一个单元。&lt;/p&gt;

&lt;p&gt;心流的最优体验出现时，一个人可以投入全部的注意力以求实现目标。没有失序现象需要整顿，自我也没有受到任何威胁，因此不需要分心防卫。&lt;/p&gt;

&lt;h3 id=&quot;一个人若能充分掌控意识尽可能创造心流体验生活品质势必会提高&quot;&gt;一个人若能充分掌控意识，尽可能创造心流体验，生活品质势必会提高。&lt;/h3&gt;

&lt;p&gt;在心流中，我们是精神能量的主宰，无论做什么事，都能使意识更有秩序。&lt;/p&gt;

&lt;p&gt;一位攀岩专家简要说明了自己的心流感觉：&lt;/p&gt;

&lt;h3 id=&quot;越来越完美的自我控制产生一种痛快的感觉&quot;&gt;越来越完美的自我控制，产生一种痛快的感觉。&lt;/h3&gt;

&lt;h3 id=&quot;你不断逼迫身体发挥所有极限直到全身隐隐作痛&quot;&gt;你不断逼迫身体发挥所有极限，直到全身隐隐作痛。&lt;/h3&gt;

&lt;h3 id=&quot;然后你会满怀敬畏地回顾自己回顾你所做的一切&quot;&gt;然后你会满怀敬畏地回顾自己，回顾你所做的一切。&lt;/h3&gt;

&lt;h3 id=&quot;那种佩服的感觉简直无法形容&quot;&gt;那种佩服的感觉，简直无法形容。&lt;/h3&gt;

&lt;h3 id=&quot;它带给你一种狂喜一种自我满足&quot;&gt;它带给你一种狂喜，一种自我满足。&lt;/h3&gt;

&lt;h3 id=&quot;只要在这种战役中战胜过自己人生其他战场的挑战也就变得容易多了&quot;&gt;只要在这种战役中战胜过自己，人生其他战场的挑战也就变得容易多了。&lt;/h3&gt;

&lt;p&gt;其实战斗中对抗的不是自己，而是使意识失序的精神熵。&lt;/p&gt;

&lt;h3 id=&quot;体验过心流的人都知道那份深沉的快乐是严格的自律集中注意力换来的&quot;&gt;体验过心流的人都知道，那份深沉的快乐，是严格的自律、集中注意力换来的。&lt;/h3&gt;

&lt;h2 id=&quot;独特性与复杂性的完美结合&quot;&gt;独特性与复杂性的完美结合&lt;/h2&gt;

&lt;p&gt;复杂性是由两种广泛的心理过程造成的，一种是独特化，另一种是整合。&lt;/p&gt;

&lt;p&gt;1.独特化是把自己与他人区分开来，朝独一无二的方向发展。&lt;/p&gt;

&lt;p&gt;2.整合则恰好相反，是借着超越自我的观念和实体与他人连结。&lt;/p&gt;

&lt;p&gt;独特化和整合，两者都是使不可或缺的。如果独特化而不整合，体系就会出现一片混乱，反之也是一样。&lt;/p&gt;

&lt;h3 id=&quot;当我们只有独特化的自我时虽然也能获得极高的成就但会陷入以自我为中心的危险&quot;&gt;当我们只有独特化的自我时，虽然也能获得极高的成就，但会陷入以自我为中心的危险。&lt;/h3&gt;

&lt;h3 id=&quot;同样的如果一个人的自我若是完全建立在整合上固然也能有良好的人际关系和安全感却缺乏独立的个性&quot;&gt;同样的，如果一个人的自我若是完全建立在整合上，固然也能有良好的人际关系和安全感，却缺乏独立的个性。&lt;/h3&gt;

&lt;h3 id=&quot;只有一个人把精神能量平均投注在这两方面既不过分自私也不盲从才算达到自我所追求的复杂性&quot;&gt;只有一个人把精神能量平均投注在这两方面，既不过分自私，也不盲从，才算达到自我所追求的复杂性。&lt;/h3&gt;

&lt;p&gt;复杂的自我能够成功地融合这两种乍看矛盾的过程。心流体验会使自我变得比过去更复杂，这可以说是一种成长。&lt;/p&gt;

&lt;h3 id=&quot;我们在克服挑战时必然会使我们变得更有能力和技巧因此心流就是经由这种过程加深自我独特化的当我们每经历一次心流后我们就会变得更独特更难预测并拥有非凡的技能&quot;&gt;我们在克服挑战时，必然会使我们变得更有能力和技巧，因此心流就是经由这种过程加深自我独特化的。当我们每经历一次心流后，我们就会变得更独特，更难预测，并拥有非凡的技能。&lt;/h3&gt;

&lt;p&gt;选定一个目标，投入全部的注意力，不论做什么事情，都会觉得乐趣无穷。&lt;/p&gt;

&lt;h3 id=&quot;一旦尝到这种快乐我们就会加倍努力重温它的滋味自我就这样开始成长&quot;&gt;一旦尝到这种快乐，我们就会加倍努力，重温它的滋味，自我就这样开始成长。&lt;/h3&gt;

&lt;p&gt;心流之所以重要，不仅是因为他能使现在更快乐，也是因为它会强化我们的自信心。&lt;/p&gt;

&lt;p&gt;虽然心流没有捷径可走，但只要我们了解它的运作方式，就有可能使生活改观。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484913&amp;amp;idx=1&amp;amp;sn=9589d58b41c85d01d1aaa68872260539&amp;amp;chksm=fc2260f6cb55e9e08222aa5096a65949a05c98edc73eb005e289e11010c68a4816ed35a50035&amp;amp;token=134603822&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

</description>
               <pubDate>Wed, 22 Sep 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/09/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B044</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/09/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B044</guid>
            </item>
        
            <item>
               <title>读书笔记(四十三) 《游戏引擎架构》#2 容器、内存、RTTI与反射</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484906&amp;amp;idx=1&amp;amp;sn=70443040745649b082a93650d180959e&amp;amp;chksm=fc2260edcb55e9fb318468bd6f0ce4b2df2277338c3aeb1d0f31b00e4dcd01c18fba4b75581b&amp;amp;token=2034706848&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;背景&quot;&gt;背景：&lt;/h1&gt;

&lt;p&gt;作为游戏开发从业者，从业务到语言到框架到引擎，积累了一些知识和经验，特别是在看了好几遍《游戏引擎架构》后对引擎的架构感触颇深。&lt;/p&gt;

&lt;p&gt;近段时间对引擎剖析的想法也较多，正好借着书本对游戏引擎架构做一个完整分析。此书用简明、清楚的方式覆盖了游戏引擎架构的庞大领域，巧妙地平衡了广度与深度，并且提供了足够的细节，使得初学者也能很容易地理解其中的各种概念。&lt;/p&gt;

&lt;p&gt;目标是掌握游戏引擎架构知识，方法是跟随《游戏引擎架构》这本书、结合引擎源码、自己的经验，分析游戏引擎的历史、架构、模块。最后通过实践自主引擎的开发来完成对引擎知识的掌握。&lt;/p&gt;

&lt;p&gt;游戏引擎知识面深而广，所以对这系列的文章书编写范围做个保护，即不对细节进行过多的阐述，重点剖析的是架构、流程以及模块的运作原理。&lt;/p&gt;

&lt;p&gt;虽然参考了《游戏引擎架构》这本书，但由于它的部分知识太陈旧，所以我不得不将这些知识重新深挖后总结自己的观点。&lt;/p&gt;

&lt;h1 id=&quot;概述&quot;&gt;概述：&lt;/h1&gt;

&lt;p&gt;本章开始对引擎中的重要的模块和库进行详细的分析，我挑选了十五个库和模块来分析：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;时间库&lt;/li&gt;
  &lt;li&gt;自定义容器库&lt;/li&gt;
  &lt;li&gt;字符串散列库&lt;/li&gt;
  &lt;li&gt;内存管理框架&lt;/li&gt;
  &lt;li&gt;RTTI与反射模块&lt;/li&gt;
  &lt;li&gt;图形计算库&lt;/li&gt;
  &lt;li&gt;资产管理模块&lt;/li&gt;
  &lt;li&gt;低阶渲染器&lt;/li&gt;
  &lt;li&gt;剔除与合批模块&lt;/li&gt;
  &lt;li&gt;动画模块&lt;/li&gt;
  &lt;li&gt;物理模块&lt;/li&gt;
  &lt;li&gt;UI核心框架&lt;/li&gt;
  &lt;li&gt;性能剖析器的核心部分&lt;/li&gt;
  &lt;li&gt;脚本系统&lt;/li&gt;
  &lt;li&gt;视觉效果模块&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本篇内容为列表中的前五个。&lt;/p&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文：&lt;/h1&gt;

&lt;p&gt;由易到难，我们从最简单的说起。&lt;/p&gt;

&lt;h2 id=&quot;时间库&quot;&gt;时间库&lt;/h2&gt;

&lt;p&gt;时间库最简单使用的也最多，在引擎中的每个模块都会使用到。其时间信息包括：真实时间、游戏时间、全局时间、相对时间，时间缩放因子。
其常见问题为各平台的时间获取方式不同，因此基本都会针对每个平台分别实现一个时间获取函数。&lt;/p&gt;

&lt;p&gt;测量时间在时间库中占重要位置，游戏中循环调用间隔、帧率、以及移动速度都会使用时间测量的单位来进行。&lt;/p&gt;

&lt;p&gt;通常引擎都会用帧率调控的方法来稳定帧率，例如我们在引擎上设置了30帧/s，那么当本帧耗时小于33ms时，则在主循环结束时让线程在剩下的时间里休眠。
反之，如果主循环耗时大于33ms，则等待到下一帧再执行。通过这样调控的方式来稳定帧率。&lt;/p&gt;

&lt;p&gt;垂直同步是另一种帧率调控方法，由于前置缓冲区和后置缓冲区在交换时会有部分消隐问题导致画面撕裂，因此垂直同步会等待消隐时间，错过了则等待下一次消隐区间，这会让画面更加稳定，但并不保证以某个特定帧率运行而且时常会降低帧率，因此很少有游戏使用这种技术。&lt;/p&gt;

&lt;p&gt;当使用测量时间时，通常都会以帧的形式更新时间跨度，例如计算每帧之间的时间、计算动画当前帧、移动速度下当前帧的移动距离等。除此之外，最常用的如最大帧率、固定帧率、全局时间缩放等，这些因子在很多引擎模块中也常会用到，例如动画时间、音频时间，粒子生命时间等。&lt;/p&gt;

&lt;h2 id=&quot;自定义容器库&quot;&gt;自定义容器库&lt;/h2&gt;

&lt;p&gt;我们在使用的各式各样集合型数据结构也被称为容器，它们的任务都是一样的，存储及管理多个数据元素。
然而细节上各种容器运行方式会有一些差异，它们各自也有各自的优缺点。它们包括但不仅限于：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;数组（Array）&lt;/li&gt;
  &lt;li&gt;动态数组（Dynamic Array）&lt;/li&gt;
  &lt;li&gt;链表（Linked List）&lt;/li&gt;
  &lt;li&gt;堆栈（Stack）&lt;/li&gt;
  &lt;li&gt;队列（Queue）&lt;/li&gt;
  &lt;li&gt;双端队列（Double-ended Queue）&lt;/li&gt;
  &lt;li&gt;优先队列（Priority Queue）&lt;/li&gt;
  &lt;li&gt;树（Tree）&lt;/li&gt;
  &lt;li&gt;二叉查找树（Binary Search Tree，BST）&lt;/li&gt;
  &lt;li&gt;二叉堆（Binary Heap）&lt;/li&gt;
  &lt;li&gt;字典（Dictionary）&lt;/li&gt;
  &lt;li&gt;集合（Set）&lt;/li&gt;
  &lt;li&gt;图（Graph）&lt;/li&gt;
  &lt;li&gt;有向无环图（Directed Acyclic Graph，DAG）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们在操作容器时，常用的操作有：插入、移除、顺序访问（迭代）、随机访问、查找、排序。&lt;/p&gt;

&lt;p&gt;这里介绍下第三方标准库的优缺点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;STL，功能丰富、可移植能力强，但内存分配效率差一些，部分容器算法性能较差。&lt;/li&gt;
  &lt;li&gt;Boost，在STL上更多功能、效率高，发布许可证有些问题。&lt;/li&gt;
  &lt;li&gt;Loki，功能丰富，复杂度较高，性能未知。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;许多引擎都会提供常见的自定义容器实现，建立自定义容器类一般都处于如下原因：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;完全掌控：控制数据结构的内存需求、使用的算法、内存分配规则。&lt;/li&gt;
  &lt;li&gt;优化性能：针对某个业务做出适合性的调整，或借助某些硬件功能可以优化数据结构和算法。&lt;/li&gt;
  &lt;li&gt;可定制性：根据业务需要增加第三方库没有的功能、例如容器性能调试、内存统计、内存快照等。&lt;/li&gt;
  &lt;li&gt;消除外部依赖：当第三方库出现问题时，需要依赖外部的团队，这可能无法提供及时的服务。自定义容器，能在库出现问题时做到可自行修复。&lt;/li&gt;
  &lt;li&gt;并发同步：常用第三方容器在线程间并发同步上的操作可能没有你想的那么完美，用自定义容器就能为自己定制更合适的同步机制。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Unreal容器一看名字就知道是什么，它们包括：
TArray、TArrayView、TBasicArray、FBinaryHeap、TBitArray、TChunkedArray、TCircularBuffer、TCircularQueue、
TDiscardableKeyValueCache、TResourceArray、FHashTable、TIndirectArray、TLinkedList、TIntrusiveLinkedList、TDoubleLinkedList、TList、
TMapBase、TSortableMapBase、TQueue、FScriptArray、TSet、TSortedMap、TSparseArray、TStaticArray、TStaticBitArray、TTripleBuffer、TUnion等等&lt;/p&gt;

&lt;p&gt;Unity容器方面基本上与Unreal差不多，Unreal有的Unity也基本有，各自也都有一些特殊用途的容器，只是这些容器代码分散较开，说明容器部分的架构Unity编排的相对混乱一些。&lt;/p&gt;

&lt;h2 id=&quot;字符串散列库&quot;&gt;字符串散列库&lt;/h2&gt;

&lt;p&gt;字符串在程序中占据了很大的内存，通常有这三个问题，&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;拷贝多&lt;/li&gt;
  &lt;li&gt;拼接多&lt;/li&gt;
  &lt;li&gt;判断相同字符串&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;拷贝多原因&quot;&gt;拷贝多，原因：&lt;/h3&gt;

&lt;p&gt;在函数的形参和返回值上，常常会使用实例的方式去做，这导致字符串拷贝变的频繁。每次字符串拷贝都需要经历，内存分配，内存拷贝，内存销毁这三步骤，可想而知字符串在拷贝上的消耗非常大。&lt;/p&gt;

&lt;h3 id=&quot;拷贝多解决方案&quot;&gt;拷贝多，解决方案：&lt;/h3&gt;

&lt;p&gt;通常是由于业务代码引起的，因此也只有调整业务代码才能缓解。包括修改函数形参类型和返回值类型。&lt;/p&gt;

&lt;h3 id=&quot;拼接多原因&quot;&gt;拼接多，原因：&lt;/h3&gt;

&lt;p&gt;每个字符串在拼接完毕后通常都会生成一个临时的新的字符串，这导致拼接的那几个字符串内存被丢弃而浪费。&lt;/p&gt;

&lt;h3 id=&quot;拼接多解决方案&quot;&gt;拼接多，解决方案：&lt;/h3&gt;

&lt;p&gt;1.编码规范问题，具体业务具体分析
2.用对象池方式重复利用内存&lt;/p&gt;

&lt;h3 id=&quot;判断相同字符串原因&quot;&gt;判断相同字符串，原因：&lt;/h3&gt;

&lt;p&gt;相同字符串的判断逻辑在代码中占比通常比较大，特别是在业务逻辑中。如果只是单纯的比较两个字符串的每个字符，效率会变得非常低下&lt;/p&gt;

&lt;h3 id=&quot;判断相同字符串解决方案&quot;&gt;判断相同字符串，解决方案：&lt;/h3&gt;

&lt;p&gt;使用HashID就能解决这个问题，即把字符串计算成Hash值，用数字比较来代替字符串比较。&lt;/p&gt;

&lt;p&gt;注意，并不是一定要让字符串做Hash才能增加效率，如果相同字符的判断操作比较少，而Hash计算和加入容器的操作比较多，那么就会得不偿失。&lt;/p&gt;

&lt;h4 id=&quot;unreal引擎的字符串fstring构建&quot;&gt;Unreal引擎的字符串FString构建：&lt;/h4&gt;

&lt;p&gt;1.用TArray&lt;TCHAR&gt;动态数组作为容器
2.通过TArray&lt;TCHAR&gt;扩容构建和拼接字符串
3.TArray&lt;TCHAR&gt;使用专门的内存块作为管理，能做到提前分配和释放回池&lt;/TCHAR&gt;&lt;/TCHAR&gt;&lt;/TCHAR&gt;&lt;/p&gt;

&lt;h3 id=&quot;unreal引擎字符串的fname&quot;&gt;Unreal引擎字符串的FName：&lt;/h3&gt;

&lt;p&gt;1.FName和FString有些不同，FName有HashID，是含有一个uint32整数的结构体，而FString则没有
2.FName的字符串存储在FNameEntry实例中
3.每个FName都有自己的HashID，用于比较相同的字符串
4.FNameEntry是一个Char数组+HashID+Header的实例
5.通过FNamePool存储FNameEntry，FNamePool就是一个字典容器，存储着所有的FNameEntry实例
6.FName通过HashID从对象池中获得字符串实体FNameEntry
7.也可以直接通过HashID比较两个字符串是否相同，从而提高效率&lt;/p&gt;

&lt;h3 id=&quot;unity与unreal不同使用对象池方式重复利用字符串内存并且没有字符串散列机制因为引擎内部不需要&quot;&gt;Unity与Unreal不同，使用对象池方式重复利用字符串内存，并且没有字符串散列机制（因为引擎内部不需要）。&lt;/h3&gt;

&lt;h2 id=&quot;内存管理框架&quot;&gt;内存管理框架&lt;/h2&gt;

&lt;p&gt;先介绍下操作系统自身的内存管理方式：&lt;/p&gt;

&lt;p&gt;1.操作系统以进程为单位来运行每个程序。
2.同时为每个进程分配了一个独立的虚拟空间。
3.每个虚拟空间里有内核空间和用户空间之分。
4.内核空间为共享库和内核程序使用的堆栈空间。
5.每个虚拟空间都会拆分成多个段来存储各类数据和程序指令
6.虚拟内存和物理内存之间使用页表进行映射，因此在虚拟空间中连续的内存在物理空间中不一定连续。
7.操作系统会将不使用的内存块交换（Swap）出去成为硬盘空间的一部分，当需要访问时再交换（Swap）回来。&lt;/p&gt;

&lt;p&gt;下面我画了3个图，用图来解释会更容易理解些：&lt;/p&gt;

&lt;p&gt;图1&lt;/p&gt;

&lt;p&gt;图2&lt;/p&gt;

&lt;p&gt;图3&lt;/p&gt;

&lt;p&gt;以上三张图完整的体现了操作系统内存的运作方式。&lt;/p&gt;

&lt;p&gt;1.图1描述了，每个进程都有各自的独立虚拟空间，分为用户空间和内核空间，并且32位和64的空间大小不同。
2.图2描述了，一个虚拟空间中有很多个段，其中包括栈段、堆段、代码段、数据段等。
3.图3描述了，虚拟内存和物理内存通过页表映射，物理内容与硬盘会有一个Swap机制。&lt;/p&gt;

&lt;p&gt;写程序时我们比较关心堆内存，那么操作系统是如何管理堆内存的呢？&lt;/p&gt;

&lt;p&gt;我们来了解下堆内存的分配和释放机制&lt;/p&gt;

&lt;p&gt;图1：&lt;/p&gt;

&lt;p&gt;图2：&lt;/p&gt;

&lt;p&gt;图3：&lt;/p&gt;

&lt;p&gt;为了快速学习，画了三张图方便大家理解堆内存分配机制：
1.图1描述了，堆内存会切割成不同的块
2.图2描述了，堆内存分配设计为大堆、小堆和缓冲堆
3.图3描述了，堆内存分配流程，先找索引再从缓冲区中找最后切割大块内存&lt;/p&gt;

&lt;p&gt;一句话概括为，堆内存以分块方式切割设计，并分为大堆、小堆、和缓冲堆，通过索引和缓冲区来加速内存的分配和释放。&lt;/p&gt;

&lt;h3 id=&quot;游戏引擎中通常不依赖操作系统内存分配机制原因是对于引擎来说操作系统的内存分配效率太差因此每个引擎都有自建的内存管理框架&quot;&gt;游戏引擎中通常不依赖操作系统内存分配机制，原因是对于引擎来说操作系统的内存分配效率太差，因此每个引擎都有自建的内存管理框架。&lt;/h3&gt;

&lt;p&gt;自建的内存管理框架通常由一些分配规则构成，这些分配规则通常会写成内存分配器（Allocator）被用于引擎的各个模块中。&lt;/p&gt;

&lt;p&gt;虽然内存管理框架有很多种，但内存分配的规则都是相似的，每一种内存分配规则我们称为内存分配器（Allocator），下面我们简单列举一下内存分配器的种类及其规则。&lt;/p&gt;

&lt;p&gt;这里列举了11种（还有更多）内存分配器并分别用一句话概括它们：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;线性内存分配器，分配一块大内存，并不断向前分配。&lt;/li&gt;
  &lt;li&gt;环形内存分配器，支持循环利用的内存分配器。&lt;/li&gt;
  &lt;li&gt;双端内存分配器，两个模块共享一个线性内存分配，并从两端分别进行分配。&lt;/li&gt;
  &lt;li&gt;固定大小内存分配器，把一大块内存拆分成固定大小的N个内存块，每次分配一块。&lt;/li&gt;
  &lt;li&gt;泛化的固定大小内存分配器，拆分成M个大块内存，每个大块内存都有自己固定大小的N个内存块， 且不同块间的小内存块的大小不同。&lt;/li&gt;
  &lt;li&gt;散列式页内存分配器，按某个固定大小的页拆分内存块，用多叉树索引方式连接内存块，一次分配多页并调整树形索引。&lt;/li&gt;
  &lt;li&gt;栈型内存分配器，不断向前分配，并按先进后出的原则回收内存。&lt;/li&gt;
  &lt;li&gt;动态合并内存分配器，从一大块内存块开始分配，分配时不断切割，并在回收时合并相邻的内存块。&lt;/li&gt;
  &lt;li&gt;大小池内存分配器，有大内存池和小内存池之分，大小内存池的分配策略不同，小内存池通常使用泛型固定大小内存分配规则，大内存池由于分配频率低因此分配方式更自由些，可切割可固定可合并。&lt;/li&gt;
  &lt;li&gt;批量内存分配器，多次连续分配多个小内存，先临时分配并立即使用，最后提交锁定内存区间。&lt;/li&gt;
  &lt;li&gt;线程安全的内存分配器，在分配时加入了更多的原子操作或同步锁，让多个同线程可以共享一个内存块。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;引擎内存管理框架&quot;&gt;引擎内存管理框架&lt;/h2&gt;

&lt;p&gt;不同种类的引擎中的内存框架其实都是大同小异：&lt;/p&gt;

&lt;p&gt;1.大都使用内存分配器来搭建内存框架
2.多种类型的内存分配器混合使用很常见
3.每个模块都有自己的内存分配器
4.经常多个模块共享一个内存分配器&lt;/p&gt;

&lt;h2 id=&quot;unreal引擎的内存分配框架&quot;&gt;Unreal引擎的内存分配框架&lt;/h2&gt;

&lt;p&gt;Unreal有个HAL（Hardware Abstraction Layer）存放了大部分内存管理内容。&lt;/p&gt;

&lt;p&gt;用图来表示为：&lt;/p&gt;

&lt;p&gt;Unreal的内存管理框架总结：&lt;/p&gt;

&lt;p&gt;1.Unreal有统一的内存分配和释放接口FMemory
2.内存统计，使用的是获取堆栈、回溯堆栈信息的方式
3.虽然内存分配器有很多种，但主内存分配器只能选择一种
4.容器有自己专属的分配器，它封装了FMemory接口
5.UObject等业务逻辑有专属的分配器，它封装了FMemory接口，并在此基础上做了垃圾回收设计。
6.引擎各模块大部分使用了FMemory接口来分配和释放内存，少数封装了自己的分配器。
7.主内存分配器中FMallocBinned为主内存分配器（1、2、3代），其分配原则为大小内存池。&lt;/p&gt;

&lt;p&gt;Unity与Unreal稍有不同，它将GC和引擎内存分开管理，并且引擎独立模块有独立内存分配器自己管理。理论上来说这种做法会更好一些，每个模块需要有合适的内存分配算法。&lt;/p&gt;

&lt;h2 id=&quot;rtti与反射模块&quot;&gt;RTTI与反射模块&lt;/h2&gt;

&lt;p&gt;RTTI(Run-Time Type Information)运行时类型检查，它提供了运行时确定对象类型的方法。&lt;/p&gt;

&lt;p&gt;C++内建的RTTI通常很难满足我们的业务需求，特别是在需要做反射的业务上尤其明显，因此引擎通常都需要自建RTTI并增加反射系统。&lt;/p&gt;

&lt;p&gt;先说C++内建的RTTI。与内建RTTI相关的运算符为：typeid 和 dynamic_cast&lt;/p&gt;

&lt;p&gt;快速回顾下typeid 和 dynamic_cast两个运算符的原理&lt;/p&gt;

&lt;p&gt;我在前面的文章中详细介绍过C++内存模型，可以参考下&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://luzexi.com/2020/11/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B014&quot;&gt;《深度探索C++对象模型》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;每个有虚继承或虚函数的C++类都会在运行时有一个type_info数据，通过虚表中的指针指向type_info数据。&lt;/p&gt;

&lt;p&gt;type_info数据结构包含了类名字和父类指针，因此我们可以通过typeid来获得多态类的type_info数据。&lt;/p&gt;

&lt;p&gt;dynamic_cast就是借助type_info来做的功能，它通过多态的type_info来识别是否可以转换类型。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Point2D pt2d = dynamic_cast&amp;lt;Point2D&amp;gt;(pt);

可以拆解为：
Point2D pt2d = NULL;
type_info type_pt2d = typeid(Point2D);
type_info type_pt = typeid(Point);
if(type_pt2d == type_pt || type_pt.before(&amp;amp;type_pt2d))
{
        pt2d = (Point2D)pt;
}
return pt2d;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;自建rtti&quot;&gt;自建RTTI&lt;/h2&gt;

&lt;p&gt;由于内置C++的RTTI时常无法满足业务需求，所以通常人们都会自己去建立自己的RTTI。&lt;/p&gt;

&lt;p&gt;人们自建RTTI通常是因为：&lt;/p&gt;

&lt;p&gt;1.有反射需求，例如查找类、调用函数、获取变量、遍历属性等。
2.优化性能，包括减少RTTI内存，提高查找type_info效率等。&lt;/p&gt;

&lt;p&gt;Unreal引擎内部RTTI是默认被禁用的，它通过枚举或整数的方式来定制需要识别的类型。
Unity也是一样，在引擎内核中，无法使用内置的RTTI。&lt;/p&gt;

&lt;p&gt;禁用仅限于引擎实时运行库上，在工具套件和编辑器上仍然被使用。&lt;/p&gt;

&lt;h2 id=&quot;反射模块&quot;&gt;反射模块&lt;/h2&gt;

&lt;p&gt;反射模块是建立在自建RTTI之上的，因为反射需要通过RTTI来获取足够多的类、变量、函数的信息。&lt;/p&gt;

&lt;p&gt;通常当我们通过RTTI来建立反射框架时，通常需要对type信息结构做些规划。例如在type结构中增加动态数组或字典容器将变量和函数的名字和类型存储起来。&lt;/p&gt;

&lt;p&gt;示例代码例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct RTTR_LOCAL class_data
{
    class_data(get_derived_info_func func, std::vector&amp;lt;type&amp;gt; nested_types)
    :   m_derived_info_func(func),
        m_nested_types(nested_types),
        m_dtor(create_invalid_item&amp;lt;destructor&amp;gt;())
    {}
    get_derived_info_func       m_derived_info_func;
    std::vector&amp;lt;type&amp;gt;           m_base_types;
    std::vector&amp;lt;type&amp;gt;           m_derived_types;
    std::vector&amp;lt;rttr_cast_func&amp;gt; m_conversion_list;
    std::vector&amp;lt;property&amp;gt;       m_properties;
    std::vector&amp;lt;method&amp;gt;         m_methods;
    std::vector&amp;lt;constructor&amp;gt;    m_ctors;
    std::vector&amp;lt;type&amp;gt;           m_nested_types;
    destructor                  m_dtor;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上代码中我们看到，type实例结构中通常有属性结构实例容器、类型结构实例容器、函数结构实例容器等，目的就是为了存储变量和函数的信息。在实时运行过程中，当我们需要用字符串查找某个函数，或者查找某个变量时，则会从这些容器中去查找。&lt;/p&gt;

&lt;p&gt;自建RTTI是通过对象信息来构建RTTI信息集合代码的，因此每个需要RTTI类的实例都需要写相应的编码，通常都会用宏和自动化来代替繁琐的实例化RTTI编码。&lt;/p&gt;

&lt;p&gt;其基本思想是采用宏来代替常规的变量定义，这样我们就可以在宏函数中将定义的变量添加至自建的反射系统。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;rttr/registration&amp;gt;
using namespace rttr;

struct MyStruct { MyStruct() {}; void func(double) {}; int data; };

RTTR_REGISTRATION
{
    registration::class_&amp;lt;MyStruct&amp;gt;(&quot;MyStruct&quot;)
         .constructor&amp;lt;&amp;gt;()
         .property(&quot;data&quot;, &amp;amp;MyStruct::data)
         .method(&quot;func&quot;, &amp;amp;MyStruct::func);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;unreal的rtti和反射用途较多主要包括蓝图和垃圾回收&quot;&gt;Unreal的RTTI和反射用途较多，主要包括蓝图和垃圾回收。&lt;/h3&gt;

&lt;p&gt;与其他所有引擎一样，Unreal生成反射代码的步骤是：&lt;/p&gt;

&lt;p&gt;1.利用特殊的宏来对变量做标记
2.对C++代码文件进行语法分析
3.用指定的宏提取出对应的数据
4.扫描工具生成RTTI代码
5.最后在初始化时运行生成的代码
6.启动时将收集到的数据保存&lt;/p&gt;

&lt;p&gt;UE4定义了一系列的宏，来帮助开发者将自定义的字段和函数添加至反射系统：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UCLASS，告诉UE这个类是一个反射类。类必须派生自UObject
USTRUCT，可以不用派生自UObject。不支持GC，也不能包含函数
UPROPERTY，定义一个反射的变量
UFUNCTION，定义一个反射的函数
UENUM，告诉UE这是一个反射的枚举类。支持enum, enum class, enum namespace
UINTERFACE，定义一个反射接口类，只能包含函数
UMETA，反射的一些元数据定义，可以通过标签定义一些该变量的属性
UPARAM，定义函数的参数属性。主要就是显示名字和Ref属性
UDELEGATE，告诉UE这是一个可反射的delegate

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 一定要声明UCLASS
UCLASS()
class MYGAME_API UMyClass : public UObject
{
    GENERATED_BODY()
    public:
        // 定义一个可反射的函数
        UFUNCTION(BluprintCallable)
        void MyFunc();private:

        // 定义一个可反射的变量
        UPROPERTY(EditAnywhere, BlueprintReadWrite, meta=(AllowPrivateAccess = &quot;true&quot;))
        int MyIntValue;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过声明反射将数据结构、变量和函数添加到反射中。&lt;/p&gt;

&lt;p&gt;UE4的UHT（Unreal Header Tool）模块扫描之后生成的代码反射两个代码文件：&lt;/p&gt;

&lt;p&gt;.generated.h文件：重载各种操作符函数，声明各种构造函数。
.gen.cpp文件：单例实现，构造UClass（提取信息并注册）&lt;/p&gt;

&lt;p&gt;Unity与Unreal的稍有不同，一部分为C++调用Mono，另一部分为C#利用反射调用具体的函数。&lt;/p&gt;

&lt;p&gt;1.C++通过Mono获取C#接口
2.反过来C#调用C++则不需要反射。可以通过数组将C++句柄存储起来，用索引获取句柄的方式调用。
3.C#使用反射调用C#代码则比较常见，在编辑器与业务逻辑交互之间会比较多。&lt;/p&gt;

&lt;h3 id=&quot;参考资料&quot;&gt;参考资料：&lt;/h3&gt;

&lt;p&gt;《动态链接与装载》&lt;/p&gt;

&lt;p&gt;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484788&amp;amp;idx=1&amp;amp;sn=8e4f7f36e4ddf6dd2f7c086463c089de&amp;amp;chksm=fc226073cb55e965e5ab259f04293c48f718a2fd72858b11397852d8ba8c7fab656b0f46e248&amp;amp;token=283688006&amp;amp;lang=zh_CN#rd&lt;/p&gt;

&lt;p&gt;《深度探索C++对象模型》&lt;/p&gt;

&lt;p&gt;http://luzexi.com/2020/11/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B014&lt;/p&gt;

&lt;p&gt;《malloc和free的实现原理解析》&lt;/p&gt;

&lt;p&gt;https://jacktang816.github.io/post/mallocandfree/&lt;/p&gt;

&lt;p&gt;《UE4 反射系统详细剖析》&lt;/p&gt;

&lt;p&gt;https://cloud.tencent.com/developer/article/1606872&lt;/p&gt;

&lt;p&gt;《UE4内存分配器概述》&lt;/p&gt;

&lt;p&gt;https://www.cnblogs.com/kekec/p/12012537.html&lt;/p&gt;

&lt;p&gt;《RTTR C++ Reflection Library》&lt;/p&gt;

&lt;p&gt;https://github.com/rttrorg/rttr&lt;/p&gt;

&lt;p&gt;《UE4 MallocBinned2分配器》&lt;/p&gt;

&lt;p&gt;https://zhuanlan.zhihu.com/p/79715624&lt;/p&gt;

&lt;p&gt;《FMallocBinned2内存分配器》&lt;/p&gt;

&lt;p&gt;https://www.cnblogs.com/kekec/p/14675228.html&lt;/p&gt;

&lt;p&gt;《UE4垃圾回收》&lt;/p&gt;

&lt;p&gt;https://zhuanlan.zhihu.com/p/67055774&lt;/p&gt;

&lt;p&gt;《UE4蓝图》&lt;/p&gt;

&lt;p&gt;https://zhuanlan.zhihu.com/p/67683606&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484906&amp;amp;idx=1&amp;amp;sn=70443040745649b082a93650d180959e&amp;amp;chksm=fc2260edcb55e9fb318468bd6f0ce4b2df2277338c3aeb1d0f31b00e4dcd01c18fba4b75581b&amp;amp;token=2034706848&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

</description>
               <pubDate>Fri, 17 Sep 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/09/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B043</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/09/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B043</guid>
            </item>
        
            <item>
               <title>读书笔记(四十二) 《游戏引擎架构》#1 历史、现状、架构、团队</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484890&amp;amp;idx=1&amp;amp;sn=1d319050c82fed232d22f1f3dfce0cd3&amp;amp;chksm=fc2260ddcb55e9cbbda832e90def1e8e7440b7ffc85c60264be83d9c6bc62162c5b05839839b&amp;amp;token=834275592&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;背景&quot;&gt;背景：&lt;/h1&gt;

&lt;p&gt;作为游戏开发从业者，从业务到算法到语言到框架到引擎，积累了一些知识和经验，特别是在看了好几遍《游戏引擎架构》后对引擎的架构感触颇深。&lt;/p&gt;

&lt;p&gt;近段时间对引擎剖析的想法也较多，正好借着书本对游戏引擎架构做一个完整分析。此书用简明、清楚的方式覆盖了游戏引擎架构的庞大领域，巧妙地平衡了广度与深度，并且提供了足够的细节，使得初学者也能很容易地理解其中的各种概念。&lt;/p&gt;

&lt;p&gt;目标是掌握游戏引擎架构知识，方法是跟随《游戏引擎架构》这本书、结合引擎源码、自己的经验，分析游戏引擎的历史、架构、模块。最后通过实践自主引擎的开发来完成对引擎知识的掌握。&lt;/p&gt;

&lt;p&gt;游戏引擎知识面深而广，所以对这系列的文章书编写范围做个保护，即不对细节进行过多的阐述，重点剖析的是架构、流程以及模块的运作原理。&lt;/p&gt;

&lt;h1 id=&quot;概述&quot;&gt;概述：&lt;/h1&gt;

&lt;p&gt;文章分为五个部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;游戏引擎历史&lt;/li&gt;
  &lt;li&gt;现代引擎概览&lt;/li&gt;
  &lt;li&gt;计算机图形技术发展史&lt;/li&gt;
  &lt;li&gt;游戏制作团队&lt;/li&gt;
  &lt;li&gt;运行时引擎架构概述&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文：&lt;/h1&gt;

&lt;p&gt;此篇分四个主题来概述一下游戏引擎的基础知识，我会分别从历史、现状、架构、团队，这四个方面来阐述。&lt;/p&gt;

&lt;h2 id=&quot;游戏引擎历史&quot;&gt;游戏引擎历史&lt;/h2&gt;

&lt;p&gt;有些同学会问，为什么要讲历史？为什么要讲现状？那是因为了解历史和现状能帮助我们更好的理解引擎的每个部分。&lt;/p&gt;

&lt;p&gt;实际上，每每当你回顾历史，就会发现它是由很多巧合构成的，当知道它的来龙去脉时，我们也就能更好的理解“今天为什么它成为这个样子”。&lt;/p&gt;

&lt;p&gt;我认为游戏引擎这个词语用的非常好，它很好的概括它在游戏开发中的地位。&lt;/p&gt;

&lt;p&gt;我们说所有的程序都可以用工具两个字来描述，那么游戏引擎到底带给了我们什么，才让它成为今天人们普遍关注的焦点呢。&lt;/p&gt;

&lt;p&gt;十几年前的游戏都很简单，容量大小都是以兆计的，通常一款游戏的开发周期在8到10个月左右，最主要的是每款游戏开发都需要重头编写代码，期间存在着大量的重复劳动，耗时耗力。&lt;/p&gt;

&lt;p&gt;慢慢地开发人员总结出些规律，某些游戏逻辑总是有些相似的代码，可以做成模块重复使用，这样就可以大大减少游戏开发周期和开发费用。&lt;/p&gt;

&lt;p&gt;一开始，只是做些低耦合的通用方法，然后逐渐形成了模块，接着演变成了复合型框架，最后形成了大型软件工程，即现在的游戏引擎。&lt;/p&gt;

&lt;h3 id=&quot;id-tech-引擎发展史&quot;&gt;Id Tech 引擎发展史&lt;/h3&gt;

&lt;p&gt;说到引擎发展史不得不说ID software这家游戏公司，很早就开始开发起游戏，从一个小游戏到游戏移植再到《Wolfenstein 3D》，游戏技术让这家公司从无到有，不断创造出一个又一个技术巅峰。&lt;/p&gt;

&lt;p&gt;最后《Wolfenstein 3D》成了游戏引擎的始祖，它不但开创了3D 射击游戏世界，而且程序也被其他游戏所使用。&lt;/p&gt;

&lt;p&gt;对ID公司来说《Wolfenstein 3D》只是小试身手，DOOM（毁灭战士）游戏引擎才是引擎技术的代表，DOOM使用的引擎正是Id Tech 1。&lt;/p&gt;

&lt;p&gt;在DOOM发布后，获得了350万的销量，为ID公司带来了滚滚财源。&lt;/p&gt;

&lt;p&gt;更重要的是DOOM成了ID公司第一款用于商业授权的引擎，这为ID公司增加了一条创收之路，即商业引擎之路从此开始。&lt;/p&gt;

&lt;p&gt;引擎从Id Tech 1到Id Tech 5，每一代升级都是质的飞越。游戏Id Tech引擎也制作出了很多优秀的游戏，包括《Quake》、《半条命》、《反恐精英》等。&lt;/p&gt;

&lt;h3 id=&quot;unreal-引擎发展史&quot;&gt;Unreal 引擎发展史&lt;/h3&gt;

&lt;p&gt;EPIC公司在1998年发布了Unreal引擎，同时《虚幻》这款FPS游戏也发布出来，画面精致绚丽得到大众的认可。&lt;/p&gt;

&lt;p&gt;不仅如此，重要的是Unreal引擎得益于画面精美和DX规范的通用性，很快就得到了许多游戏公司的支持。而且，由于Unreal引擎的通用性，除了游戏，它还广泛使用在3D建模、建筑设计、动作捕捉、电影特效等等领域。&lt;/p&gt;

&lt;p&gt;Unreal引擎一战成名后，便开启了升级之路，引擎从Unreal 1到 Unreal 5，凭借着优秀的画质表现、适中的显卡要求、强大的自定义工具和一站式配套开发使得Unreal具备了各个平台各种游戏的适应性，因此越来越多的游戏采用Unreal引擎。目前已成为全球最流行的游戏引擎之一。&lt;/p&gt;

&lt;h3 id=&quot;unity-引擎发展史&quot;&gt;Unity 引擎发展史&lt;/h3&gt;

&lt;p&gt;Unity在2005年6月时发布了1.0版本的引擎。&lt;/p&gt;

&lt;p&gt;最初，是在2005年苹果公司的全球开发者大会上对外公布并开放使用，当时只是一款面向Mac OS X平台的游戏引擎。&lt;/p&gt;

&lt;p&gt;由于其引擎的易用性，受到广大开发者的喜爱，之后Unity公司便开启了快速升级之路，用了10年时间从1.0一路升级到5.0。&lt;/p&gt;

&lt;p&gt;鉴于引擎的更新速度逐渐加快，Unity官方决定不再在其版本号中标注纯数字，而改用年份与版本号的复合形式，如Unity 2018.2，发布时间为2018年7月10日。&lt;/p&gt;

&lt;p&gt;截止目前使用Unity引擎开发出了的手机游戏，无论是在数量上还是在流行度上，都是所有引擎中最多也是最受欢迎的。&lt;/p&gt;

&lt;p&gt;随着显卡性能越来越强，游戏的画质越来越高，游戏开发周期也越来越长，通常都会达到3到5年，自行开发游戏引擎的话时间还会更长，所以大多数游戏公司还是选择购买现成的游戏引擎，简化游戏的开发过程。&lt;/p&gt;

&lt;h2 id=&quot;现代引擎概览&quot;&gt;现代引擎概览&lt;/h2&gt;

&lt;p&gt;雷神之锤引擎，与游戏业务密切融合，它的第一款游戏是《德军总部》，后相继开发了《毁灭战士》、《雷神之锤》等游戏。Source引擎中的技术也能追溯到雷神之锤的技术。原始雷神之锤引擎的架构相当优秀并且整洁。这些代码都是非常好的例子，能说明工业级游戏引擎是怎样炼成的。&lt;/p&gt;

&lt;p&gt;虚幻引擎，从《虚幻》游戏开始进化，进化到虚幻4代引擎时，号称是业界最好的工具和最丰富的引擎功能。它有方便且强大的着色器制作工具，还提供一个方便快捷的图形用户界面编辑器，虚幻引擎以其全面的功能及内聚易用的工具著称。但虚幻引擎并非完美，大部分开发者都需要用不同方式优化它，才能在具体的目标硬件上运行。可贵的是虚幻引擎拥有极为强大的原型制作工具和商业游戏平台，可用来制作几乎任何3D游戏。&lt;/p&gt;

&lt;p&gt;Source引擎，《半条命2》起家的游戏引擎，其图形能力和工具套件可与虚幻引擎4娉美。&lt;/p&gt;

&lt;p&gt;寒霜引擎，是从《战地：叛逆连队》开发开始的，之后成为艺电应用最广泛的引擎。寒霜引擎拥有强大的统一资产创作工具FrostEd，以及强大的Backend Services工具管道。&lt;/p&gt;

&lt;p&gt;CryEngine，原本是为NVIDIA开发的技术演示程序。确立这个技术具有潜力后，就把演示程序改为了完整的游戏《孤岛惊魂》，最后演化成了游戏引擎。经过多年迭代，CryEngine3已经是一个强大的资产创作工具，具有丰富的功能并拥有高品质的图形渲染引擎。&lt;/p&gt;

&lt;p&gt;索尼的PhyreEngine，专为支持索尼的PS2，PS3，PS4等平台提供技术服务。PhyreEngine3.5让开发者能使用PS3 Cell架构的高度并行能力、PS4的高级演算能力，以及包括其他世界编辑器和开发工具。&lt;/p&gt;

&lt;p&gt;微软的XNA Game Studio，XNA基于微软的C#语言并使用Visual Studio管理游戏项目资产。&lt;/p&gt;

&lt;p&gt;Unity，支持广泛的平台，它的主要设计目标是容易开发及跨平台游戏开发。因此它提供了容易使用的整合编辑环境，我们可以在此环境中创建及处理游戏世界中的资产及实体，并能快速地在编辑器中浏览游戏运行的样子，同时也提供了直接在目标硬件上运行的功能。不仅如此它还提供了全面的资产调节管道，可以为每个平台独立调节性能与品质以达到两者的平衡。&lt;/p&gt;

&lt;h2 id=&quot;计算机图形技术发展史&quot;&gt;计算机图形技术发展史&lt;/h2&gt;

&lt;p&gt;我把计算机图形技术发展史分为了四个部分，它们分别是，硬件发展史、图形API发展史、图形软件发展史、以及图形技术发展史。&lt;/p&gt;

&lt;h3 id=&quot;图形硬件发展史&quot;&gt;图形硬件发展史&lt;/h3&gt;

&lt;p&gt;图形硬件，最初由SGI公司（Silicon Graphics Inc）开发的IRIS（综合光栅成像系统）受到市场热捧，它使用2MB内存的8 MHz M68000处理器，定制1024x1024帧缓冲器和几何引擎。其最初的市场定位为3D图形显示终端。随着市场策略的推进，SGI公司在电影、电视等领域的发展迅速并且它们的产品受到欢迎。&lt;/p&gt;

&lt;p&gt;接着是Sun微系统公司，它于1982年由安迪·贝托尔斯海姆与其他同门研究生在斯坦福大学成立。贝托尔斯海姆最初将SUN计算机设计为斯坦福大学网络（因此缩写为“SUN”）的个人CAD工作站。它是围绕Motorola 68000处理器设计的，具有Unix操作系统和虚拟内存，并且与SGI一样，具有嵌入式帧缓冲区。后来的发展包括计算机服务器和基于RISC处理器架构和一系列软件产品（如Solaris操作系统和Java平台）构建的工作站。&lt;/p&gt;

&lt;p&gt;GPU英文全称Graphic Processing Unit，20世纪70年代末GPU概念被提出，它的优点是具有高并行结构，所以GPU在处理图形数据和复杂算法方面由比CPU更高的效率。CPU大部分面积为控制器和寄存器，与之相比，GPU拥有更多的ALU（Arithmetic Logic Unit,逻辑运算单元）用于数据处理，这样的结构适合对密集型数据进行并行处理。GPU采用流式并行计算模式，可对每个数据进行独立的并行计算，所谓“对数据进行独立计算”即：流内任意元素的计算不依赖于其他同类型数据，例如，计算一个顶点的世界位置坐标，不依赖于其他顶点的位置，所谓“并行计算”是指“多个数据可以同时被使用，多个数据并行运算的时间和1个数据单独执行的时间是一样的”。所以，在顶点处理程序中，可以同时处理N个顶点数据。目前，线性代数，物理仿真和光线跟踪算法都已经成功的一直到GPU上。&lt;/p&gt;

&lt;p&gt;第一代GPU，NVIDIA于1998年宣布Modern GPU研发成功，这标志着第一代Mondern GPU的诞生，第一代GPU包括NVIDIA TNT2,ATI的Rage和3Dfx的Voodoo。这些GPU可以独立CPU进行像素缓存区的更新，并可以光栅化三角面片以及进行纹理操作，但是缺乏三维顶点的空间坐标变换能力，这意味着“必须依赖与CPU执行顶点坐标变换的计算”。这一时期的GPU功能非常有限，只能用于纹理组合的数学计算或者像素颜色值得计算。&lt;/p&gt;

&lt;p&gt;第二代GPU，NVIDIA于1999年推出一款显示核心代号NV10的geforce 256，率先将硬体T&amp;amp;L整合到显示核中。T&amp;amp;L原先由CPU负责，或者由另一个独立处理机处理。这次整合T&amp;amp;L是一大进步，原因是显视核心从CPU接管了大量工作。硬件T&amp;amp;L引擎带来的效果是3D 模型可以用更多的多边形来描绘，这样就拥有了更加细腻的效果。而对光照来说，CPU不必在计算大量的光照数据，直接通过显卡就能获得更好的效能。同时，这一阶段的GPU对于纹理的操作也扩展到了立方体纹理（Cube Map）。NVIDIA的GeForce MAX,ATI的Radeon 7500等都是在这一阶段研发的。&lt;/p&gt;

&lt;p&gt;第三代GPU，2001年是第三代Modern GPU的发展时期，这一时期研发的GPU提供Vertex Programmability (顶点编程能力)，如GeForce 3，GeForce 4Ti，ATI 的8500等。这些GPU允许应用程序指定一个序列的指令进行顶点操作控制，这是一个具有开创意义的时期，这一时期确立的GPU编程思想一直延续到今天，不但深入到工程领域帮助改善人类日常生活（医疗、地质勘探、游戏、电影），而且开创或延伸了计算机科学的诸多研究领域（人体绘制、光照模拟、人群动画、通用计算等）。同时Direct8和OpenGL都本着与时俱进的精神，提供了支持Vertex Programmability的发展。不过，这一时期的GPU还不支持像素级的编程能力，即Fragment Programmability(片段编程能力)。&lt;/p&gt;

&lt;p&gt;第四代GPU，发展时期从2002年末到2003年。NVIDIA的GeForceFX和ATI Radeon 9700同时在市场的舞台上闪亮登场，这两种GPU都支持顶点编程和片段编程。同时DriectX和OpenGL也扩展了自身的API，用以支持顶点编程和片段编程。自2003年起，可编程图形处理器正式诞生，并且由于DirectX和OpenGL契而不舍的追赶潮流，导致基于图形硬件的编程技术，简称GPU编程，也宣告诞生。&lt;/p&gt;

&lt;h3 id=&quot;图形api发展史&quot;&gt;图形API发展史&lt;/h3&gt;

&lt;p&gt;在 1980 年代，开发可与各种图形硬件配合使用的软件是一项真正的挑战。软件开发人员为每个硬件编写自定义接口和驱动程序。这个代价是昂贵的，将导致工作量成倍增加。到 1990 年代初，Silicon Graphics (SGI) 是工作站 3D 图形领域的领导者。他们的 IRIS GL API成为行业标准，比基于开放标准的 PHIGS 使用更广泛。&lt;/p&gt;

&lt;p&gt;OpenGL、DirectX、Vulkan、Metal等都属于图形API，它的本质是封装好的显卡接口，用来将应用程序与显卡驱动联系起来。有了图形API我们可以仅仅调用它的函数来更改渲染状态、缓存顶点数据、开始绘制等等，而如果没有它，我们就需要直接调用显卡驱动的接口来进行渲染，这会涉及到非常多的硬件接口，例如对寄存器的操作，相当繁琐。一般来说我们都不会希望在渲染的同时还要去关注对硬件的控制。&lt;/p&gt;

&lt;p&gt;目前比较常用的图形API：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;OpenGL&lt;/li&gt;
  &lt;li&gt;OpenGL ES&lt;/li&gt;
  &lt;li&gt;OpenCV&lt;/li&gt;
  &lt;li&gt;DirectX&lt;/li&gt;
  &lt;li&gt;Metal&lt;/li&gt;
  &lt;li&gt;Vunkan&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;OpenGL（Open Graphics Library），是一个跨平台、跨语言的编程图形框架，主要用于windows、mac等PC端。它将计算机资源抽象成一个个OpenGL对象，对这些资源的操作抽象为一个个OpenGL指令。&lt;/p&gt;

&lt;p&gt;OpenGL ES（OpenGL for Embedded Systems），OpenGL三维图像API的子集，主要是针对嵌入式设备的图形处理，比如安卓、iOS等。它在OpenGL之上去除了许多不必要的接口，以及性能较低的接口，并且兼容了GLSL着色器语法。&lt;/p&gt;

&lt;p&gt;OpenCV（Open Source Computer Vision Library），它与 OpenGL是图形API中两个大的分支，类似于iOS中的OC和swift，是两个不同的方向。OpenCV主要用于识别技术，例如人脸识别、身份识别、物体识别等，该API的使用需要与人工智能相结合。目前市面上用的最多的识别三方是 face++，且是收费的，支付宝等大厂的识别功能也是集成的face++。&lt;/p&gt;

&lt;p&gt;DirectX，仅支持Windows平台，由很多API组成，是一个多媒体处理框架，并不是单一的图形API。该框架可以大致分为4类，显示、声音、输入、网络。&lt;/p&gt;

&lt;p&gt;Metal，是苹果为了解决3D渲染问题而推出的框架，是为游戏开发者提供的新的平台技术，并且它将3D渲染图像的性能提高了原来的10倍。苹果系统中的CoreGraphics、CoreAnimation、CoreImage框架在2018年以前是基于OpenGL ES封装的，在2018年以后是基于Metal封装的。&lt;/p&gt;

&lt;p&gt;Vunkan，Vulkan API 最初被 Khronos 称为“下一代 OpenGL 计划”，与 OpenGL、Direct3D 11 和 Metal 相比，Vulkan 旨在提供更高的性能和更平衡的 CPU 和 GPU 使用，并为应用程序提供相当低级别的 API 和并行任务。&lt;/p&gt;

&lt;h3 id=&quot;opengl历史&quot;&gt;OpenGL历史&lt;/h3&gt;

&lt;p&gt;SGI 的竞争对手（包括 Sun Microsystems、Hewlett-Packard 和 IBM）也能够将 PHIGS 标准扩展支持的 3D 硬件推向市场，这迫使 SGI 将 IrisGL 版本作为公共标准开源，称为 OpenGL。&lt;/p&gt;

&lt;p&gt;然而，SGI的许多客户从 IrisGL 到 OpenGL 的转变需要大量投资。此外，IrisGL 具有与 3D 图形无关的 API 函数。例如，它包括一个窗口、键盘和鼠标 API等。其原因是，它是在 X Window System 和 Sun 的 NeWS 之前开发的。而且，由于许可和专利问题，IrisGL的库不适合开放。因此这个转变难度相当大，SGI公司付出了艰辛的努力，得到了市场的认可。&lt;/p&gt;

&lt;p&gt;IrisGL 的限制之一是它只提供对底层硬件支持的功能的访问。如果图形硬件本身不支持某个功能，则应用程序将无法使用它。OpenGL 通过提供硬件不支持的功能的软件实现来克服这个问题，允许应用程序在相对低功耗的系统上使用高级图形。&lt;/p&gt;

&lt;p&gt;OpenGL标准化了对硬件的访问，将硬件接口程序（设备驱动程序）的开发责任推给了硬件制造商，并将窗口功能委托给了底层操作系统。有了这么多不同种类的图形硬件，通过为软件开发人员提供一个用于 3D 软件开发的更高级别的平台，让它们以这种方式使用同一种语言产生了显着的影响。&lt;/p&gt;

&lt;p&gt;OpenGL在1992年由SGI（Silicon Graphics Inc）发布。起初它是作为Iris GL的一个替代品而出现的。Iris GL是SGI的专用图形API，由于它有一些与3D图形无关的API以及一些专利等原因，不适合作为行业的广泛标准，于是SGI编写了OpenGL 1.0规范。在之后，每隔一段时间OpenGL便会出现新的增量更新。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1992年，SGI发布了OpenGL 1.0。&lt;/li&gt;
  &lt;li&gt;2003年7月，OpenGL ES 1.0发布，它是专为手机、平板电脑、游戏主机等嵌入式系统设计的一个OpenGL API子集。&lt;/li&gt;
  &lt;li&gt;2004年9月，SGI发布了OpenGL 2.0，这其中就有GLSL 1.0（OpenGL Shading Language）的面世，这是一种类C语言，可以用它对固定管线的顶点/片段着色器进行编程。与之相伴的还支持了MRT（Multiple render targets）和NPOT（Non-power-of-two textures）。&lt;/li&gt;
  &lt;li&gt;2006年7月，OpenGL API规范的控制权转交给非盈利组织Khronos团队。&lt;/li&gt;
  &lt;li&gt;2008年8月，OpenGL 3.0发布，支持FBO（Framebuffer Objects）以及VAO（Vertex Array Objects）等多个功能，同时支持了非常多的特性，并且从这版开始OpenGL支持了向后兼容。&lt;/li&gt;
  &lt;li&gt;2009年8月，OpenGL 3.2发布，废弃了固定渲染管线，发布了核心模式（Core Profile），这种模式的灵活性与效率更高，之后的迭代也都是基于这个核心架构，同时版本中增加了新的着色器阶段：几何着色器。&lt;/li&gt;
  &lt;li&gt;2010年3月，OpenGL 3.3和OpenGL 4.0一起发布，带来了新的标准规范，自此之后GLSL的版本号与OpenGL版本号保持一致，即GLSL 3.3/4.0，同时新增了曲面细分着色器。&lt;/li&gt;
  &lt;li&gt;2017年7月，OpenGL 4.6发布，增加了SPIR-V 着色器，SPIR-V 使高级语言前端能够以标准化的中间形式发出程序，供 Vulkan、OpenGL 或 OpenCL 驱动程序摄取。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;vulkan历史&quot;&gt;Vulkan历史&lt;/h3&gt;

&lt;p&gt;Vulkan于Khronos在GDC 2015上首次公开，它也曾被叫做是“Next Generation OpenGL Initiative”(glNext)，旨在对OpenGL和OpenGL ES的一次重新设计，将两者统一到一个API中。&lt;/p&gt;

&lt;p&gt;与OpenGL相同它也是一个跨平台的2D、3D图形API，不同的是它是一个Low Level图形API，即会开放出更多与内存控制相关的接口。&lt;/p&gt;

&lt;p&gt;Vulkan能较好的支持多线程并行（OpenGL4.0+是为单线程设计的），这使得它的操作和维护比OpenGL复杂得多。另外OpenGL使用GLSL来编写着色器，每个显卡商需要为GLSL单独编写编译器来转换为在显卡上运行的机器码。在这点上Vulkan不同，它会先由操作系统把GLSL预编译为一种名为SPIR-V（Standard Portable Intermediate Representation）的中间码，再由显卡商编写Vulkan驱动程序对GPU进行一些特定的优化，加载速度变快了还节省了显卡商的开发及维护成本。这和Direct3D的HLSL预编译很像。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2016年2月，Vulkan 1.0发布。&lt;/li&gt;
  &lt;li&gt;2018年2月，Khronos发布MoltenVK，可以理解为MoltenVK是用Metal实现了Vulkan的API，这使得macOS和iOS也能支持Vulkan了。虽然绕了趟远路，但从Dota2的表现上来看，依旧比OpenGL高出了50%的帧率。&lt;/li&gt;
  &lt;li&gt;2018年3月，Khronos和GPUOpen公开V-EZ项目，它是“Easy Mode”的缩写，是一个基于Vulkan的中间层，相比于Vulkan它保留了Vulkan的大部分API，提供了更简单的内存管理API，封装了诸多底层细节。旨在开发者更容易上手Vulkan。&lt;/li&gt;
  &lt;li&gt;2018年3月，Vulkan 1.1发布。支持了HLSL语法以及光线追踪。可以更好的模拟DirectX 12。spirv更新至1.3。&lt;/li&gt;
  &lt;li&gt;2020年1月，Vulkan 1.2发布。新增了23项扩展以及更好的支持HLSL。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;direct3d历史&quot;&gt;Direct3D历史&lt;/h3&gt;

&lt;p&gt;Direct3D 是 Microsoft Windows 的图形应用程序编程接口 (API)。作为 DirectX 的一部分，Direct3D 用于在性能很重要的应用程序（例如游戏）中渲染 3D 图形。Direct3D 使用硬件加速（如果它在显卡上可用），允许对整个 3D 渲染管道进行硬件加速，也支持仅部分加速。&lt;/p&gt;

&lt;p&gt;Direct3D 公开了 3D 图形硬件的高级图形功能，包括 Z 缓冲、W 缓冲、模板缓冲、空间抗锯齿、alpha 混合、颜色混合、Mipmapping、纹理混合，剪裁、剔除、大气效果、透视校正纹理映射、可编程 HLSL 着色器等其他图形效果。与其他 DirectX 技术的集成使 Direct3D 能够提供视频映射、2D 覆盖平面中的硬件 3D 渲染甚至精灵等功能，从而在交互式媒体关系中提供 2D 和 3D 图形的使用。&lt;/p&gt;

&lt;p&gt;Direct3D 是一种立即模式图形 API。它为每个显卡的 3D 功能（转换、剪辑、照明、材质、纹理、深度缓冲等）提供了一个低级接口。立即模式呈现三个主要抽象：设备、资源和交换链。&lt;/p&gt;

&lt;p&gt;设备有四种类型，HAL（硬件抽象层）设备（支持硬件加速）、参考设备（模拟不可用的新功能）、软件设备（执行软件渲染）、空设备。&lt;/p&gt;

&lt;p&gt;每个设备都有一个交换链，交换链由一个或多个后台缓冲区组成，渲染发生在后台缓冲区中。&lt;/p&gt;

&lt;p&gt;资源有四个属性，资源类型（表面网格、立方体纹理、索引缓冲、顶点缓冲等）、池（内存管理与存储位置）、格式（资源在内存中的布局）、用法（用标志位方式确定如何使用资源）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1996年6月，第一版Direct3D 2.0跟随DirectX 2.0发布，有”Retained mode”和”Immediate mode”。&lt;/li&gt;
  &lt;li&gt;1998年8月，Direct3D 6.0发布，增加了许多新特性，如Multitexture、模板缓冲区等。&lt;/li&gt;
  &lt;li&gt;1999年9月，Direct3D 7.0支持了T&amp;amp;L硬件加速。&lt;/li&gt;
  &lt;li&gt;2000年11月，Direct3D 8.0发布，引进了可编程管道概念，新增了顶点/片段着色器，这个时候Direct3D完全超越了OpenGL。&lt;/li&gt;
  &lt;li&gt;2002年12月，Direct3D 9.0发布，发布了Shader Model 2.0。支持浮点纹理格式、MRT（Multiple render targets），9.0是最后一个支持WindowsXP的版本。&lt;/li&gt;
  &lt;li&gt;2006年11月，Direct3D 10.0发布，仅支持Windows Vista以上操作系统。固定功能管线被淘汰，取而代之的是可编程渲染管线。新增了几何着色器阶段，发布了Shader Model 4.0。&lt;/li&gt;
  &lt;li&gt;2009年7月，Direct3D 11.0与Windows7一块被发布，Direct3D 11.0新增了曲面细分着色器和Computer Shader，支持了多线程处理技术，发布了Shader Model 5.0。&lt;/li&gt;
  &lt;li&gt;2015年1月，Direct3D 12.0包含在Windows10一块被发布，更好支持多核心、多线程的优化，降低GPU处理瓶颈，并提升硬件功耗表现。简化了Direct3D 11中的管道状态对象（Pipeline state objects）。&lt;/li&gt;
  &lt;li&gt;2018年10月，发布了Direct3D 12光线追踪DirectX Raytracing (DXR)的扩展包。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;metal历史&quot;&gt;Metal历史&lt;/h3&gt;

&lt;p&gt;Metal是一款Low Level、Low Overhead的3D图形API，由苹果公司开发，并在2014年6月随iOS8公开。相比于OpenGL，Metal对底层拥有更大的操控性，同时又有着多线程上大量的优化。Metal Shader使用的是Metal Shader Language（MSL），是一种基于C++ 14的语言。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2014 年 6 月，Metal发布。在由 Apple A7 或更高版本驱动的 iOS 设备上可用，并自 2015 年 6 月 8 日起在运行 OS X El Capitan 的 Mac（2012 型号或更高版本）上可用。&lt;/li&gt;
  &lt;li&gt;2017 年 6 月，Metal第二个版本发布，Metal 2 可以在 Xcode 中实现更高效的分析和调试、加速机器学习、降低 CPU 工作负载、支持 macOS 上的虚拟现实，以及 Apple A11 GPU 的特性。&lt;/li&gt;
  &lt;li&gt;2020 年，Apple 宣布将 Mac 迁移到 Apple 芯片，使用 Apple 芯片的 Mac 将配备 Apple GPU，其功能集结合了以前在 macOS 和 iOS 上可用的功能，并将能够利用为 Apple GPU 的基于图块的延迟渲染 (TBDR) 架构量身定制的功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;图形软件发展史&quot;&gt;图形软件发展史&lt;/h3&gt;

&lt;p&gt;20世纪80年代，出现了许多著名的新型商业软件产品，例如Autodesk公司的AutoCAD专注于平面设计，以及它的另一个作品3D Studio专注于3D模型设计，Alias Research公司开发的Alias专注于3D模型设计。Softimage公司开发的Softimage 3D专注于集成建模、动画、渲染并成为业内标准的动画解决方案，副作用软件公司开发的Side Effects软件将程序化建模和运动产品开发成高度紧密集成的2D / 3D动画软件，并融合了多项技术突破。&lt;/p&gt;

&lt;p&gt;到了20世纪90年代，随着硬件技术的提升，图形软件技术也开始蓬勃发展，产生一批顶级的3D图形软件，例如CAD、3MAX、MAYA、SOFTIMAGE、HOUDINI等。借助这些软件，可以大大降低制作模型和动画的成本。&lt;/p&gt;

&lt;p&gt;因此90年开始，图形技术发展进入了重大的改革，不仅在技术上大举突破了各类瓶颈，在图形软件上有了大的进化，而且计算机图形技术开始渗透影视、动画、游戏等各行各业。&lt;/p&gt;

&lt;h2 id=&quot;图形技术发展史&quot;&gt;图形技术发展史&lt;/h2&gt;

&lt;p&gt;群体动物移动行为，群体行为的数学模型首先由Craig Reynolds于1986年在计算机上模拟，并很快在3D动画开始大规模使用。&lt;/p&gt;

&lt;p&gt;动作捕捉，80年代就开始基于计算机的动作捕作为摄影测量分析工具，表演者佩戴标记每个关节附近的标记之间的位置或角度来识别运动。&lt;/p&gt;

&lt;p&gt;运动跟踪，90年代中期，匹配移动（也称为运动跟踪或摄像头跟踪）虽然与动作捕捉有关，但却是一种完全不同的技术。除了使用特殊的相机和传感器来记录主体的运动外，还会将移动作品与预先存在的实时镜头相匹配，并单独使用计算机软件通过多个框架跟踪场景中的特定点，从而允许插入CGI元素以相对于现有材料的正确位置、比例、方向和运动进入镜头。&lt;/p&gt;

&lt;p&gt;虚拟演播室，虚拟演播室是一个工作室，这种虚拟场景在90年代电视节目中很普遍，它可以以无缝方式，实时组合人或其他真实物体，包括计算机生成的环境和物体。它要求3D CGI环境自动锁定，进而精确跟踪角色在实时相机和镜头前的任何移动。这种系统的精髓在于它使用某种形式的相机来跟踪创建一个实时的数据流，同时会使用CGI渲染软件，软件使用相机跟踪数据并生成完美拼接的虚拟合成图像。&lt;/p&gt;

&lt;p&gt;法线贴图，1996年，Krishnamurty和Levoy发明了法线贴图，这是对Jim Blinn 凹凸贴图的改进。&lt;/p&gt;

&lt;p&gt;PBR&amp;amp;卡通材质，这两个技术都是围绕画风的，PBR 指的是”Physically Based Rendering”， 简化了物理材质的计算流程，用接近物理正确的效果来渲染材质表面，材质包括绝缘体和金属材质两种。卡通渲染（英语：Toon Shading）是一种非真实感绘制（NPR），卡通渲染又称赛璐珞渲染（Cel-shading），旨在使电脑生成的图像呈现出手绘般的效果。为了使图像可以与漫画或者卡通达到形似的效果，专业人员通常使用卡通渲染着色器进行处理。&lt;/p&gt;

&lt;p&gt;高动态光照（HDRR，High-Dynamic Range rendering），人在黑暗的地方，为了看清楚对象，瞳孔会放大，以吸收更多光线；当突然走到光亮的地方，瞳孔来不及收缩，所以眯起眼睛，保护视网膜上的视神经。而电脑无法判断光线明暗，唯有靠HDRR技术模拟这效果——人眼自动适应光线变化的能力。方法是快速将光线渲染得非常光亮，然后将亮度逐渐降低。HDRR的最终效果是亮处的效果是鲜亮，而黑暗处的效果是能分辨物体的轮廓和深度，而不是以往的一团黑。&lt;/p&gt;

&lt;p&gt;体积光，可以让用户看到光束效果，例如在一个画面中用户能看到太阳光束射入敞开的窗户，这就是典型的体体积光技术体现。&lt;/p&gt;

&lt;p&gt;early-z-test，发生在顶点着色器后像素着色器之前的深度测试，原本深度测试在填充率、光照、纹理或像素着色器成为主要瓶颈的情况下已经成为了一个很好的优化，early-z-test这种技术将深度测试更进一步，提前到顶点着色器之后去完成，它节省了片元着色器的计算，但前提是片元着色器中不会有alpha混合和discard操作。&lt;/p&gt;

&lt;p&gt;光线追踪（Ray Tracing），是三维计算机图形学中的特殊渲染算法，追踪光线从来源开始照射到物体上，再由物体反射的光线“路径”，由于完整运算所有路径十分消耗运算资源，因此现有光线追踪技术仅运算“目所能及”的光线路径，由于是从玩家视角开始进行运算，有时被误解为光线追踪是追踪“从眼睛发出的光线”。通过这样一项技术生成编排好的场景的数学模型显现出来。这样得到的结果类似于光线投射与扫描线渲染方法的结果，但是这种方法有更好的光学效果，例如对于反射与折射有更准确的模拟效果，并且效率非常高，所以当追求高质量的效果时经常使用这种方法。 在物理学中，光线追迹可以用来计算光束在介质中传播的情况。在介质中传播时，光束可能会被介质吸收，改变传播方向或者射出介质表面等。我们通过计算理想化的窄光束（光线）通过介质中的情形来解决这种复杂的情况。 在实际应用中，可以将各种电磁波或者微小粒子看成理想化的窄波束（即光线），基于这种假设，人们利用光线追迹来计算光线在介质中传播的情况。光线追迹方法首先计算一条光线在被介质吸收，或者改变方向前，光线在介质中传播的距离，方向以及到达的新位置，然后从这个新的位置产生出一条新的光线，使用同样的处理方法，最终计算出一个完整的光线在介质中传播的路径。&lt;/p&gt;

&lt;p&gt;其他等等渲染技术非常多，这里点到为止不再延伸开来。&lt;/p&gt;

&lt;h2 id=&quot;游戏制作团队&quot;&gt;游戏制作团队&lt;/h2&gt;

&lt;p&gt;这里简单介绍下游戏制作团队，虽然大多数人都知道这些知识，但不妨碍我们回顾与总结。&lt;/p&gt;

&lt;p&gt;艺术家：
概念艺术家、三维建模师、纹理艺术家、灯光师、动画师、动捕演员、音效师、配音演员、作曲家等&lt;/p&gt;

&lt;p&gt;产品设计：
游戏设计师、数值设计师、关卡设计师、系统设计师、AI设计师、剧情设计师、操作设计师、技能设计师、制作人等&lt;/p&gt;

&lt;p&gt;软件工程师：
引擎工程师、渲染工程师、游戏系统工程师、AI工程师、网络工程师、构建工程师、工具开发工程师、架构工程师、效能工程师、中间件工程师、安全工程师、测试工程师等&lt;/p&gt;

&lt;h2 id=&quot;运行时引擎架构概述&quot;&gt;运行时引擎架构概述&lt;/h2&gt;

&lt;p&gt;游戏引擎通常由工具套件和运行时组件两部分构成。这里我们主要来说说运行时组件部分。&lt;/p&gt;

&lt;p&gt;与所有软件系统一样，游戏引擎也是由软件层构建的，即我们通常说的，上层依赖下层，下层不依赖上层，每层中各模块之间不相互依赖，这样的低耦合、高重用度架构在大型软件系统架构中是非常关键的设计。&lt;/p&gt;

&lt;p&gt;《游戏引擎架构》一书中对整体架构做了介绍，但我认为内容过于粗浅，也有点过时了，于是我自己重新画了架构图。&lt;/p&gt;

&lt;p&gt;我把整个运行时引擎架构分为十三个层级，每个层级都是只依赖下层，这十三个层级分别为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;目标硬件层&lt;/li&gt;
  &lt;li&gt;设备驱动层&lt;/li&gt;
  &lt;li&gt;操作系统层&lt;/li&gt;
  &lt;li&gt;平台独立层&lt;/li&gt;
  &lt;li&gt;第三方中间件&lt;/li&gt;
  &lt;li&gt;核心库&lt;/li&gt;
  &lt;li&gt;资产管理层&lt;/li&gt;
  &lt;li&gt;底层渲染器&lt;/li&gt;
  &lt;li&gt;引擎核心层&lt;/li&gt;
  &lt;li&gt;引擎应用层&lt;/li&gt;
  &lt;li&gt;业务基础层&lt;/li&gt;
  &lt;li&gt;游戏框架层&lt;/li&gt;
  &lt;li&gt;游戏业务层&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面来简单解释一下每个层级的拆解理念：&lt;/p&gt;

&lt;p&gt;目标硬件层，代表用来执行游戏的主机硬件。&lt;/p&gt;

&lt;p&gt;设备驱动层，是操作系统或硬件商提供的最低阶软件组件。负责管理硬件资源、也隔离了操作系统及上层引擎。&lt;/p&gt;

&lt;p&gt;操作系统层，管理协调整台计算机上多个程序的执行工作，进程通过调用操作系统的接口来访问操作系统。&lt;/p&gt;

&lt;p&gt;平台独立层，包装了常用的库和操作系统接口，供所有平台使用。&lt;/p&gt;

&lt;p&gt;第三方中间件，提供了独立的解决方案，简化开发流程，缩短开发时间。包括标准库、图形接口等。&lt;/p&gt;

&lt;p&gt;核心库，是由许许多多独立的软件工具库组成。这些库常常被引擎上层频繁使用，同时也是非常实用的软件工具。&lt;/p&gt;

&lt;p&gt;资产管理层，提供资源增删改查的完整解决方案，通常会提供一组统一的接口，供引擎和业务去访问任意的游戏资源。&lt;/p&gt;

&lt;p&gt;底层渲染器，提供最原始的渲染功能，根据应用层的数据调用图形API进行渲染。它通常会经过封装，从业务渲染提交的过程中拆解出来。&lt;/p&gt;

&lt;p&gt;引擎核心层，为应用层提供了最核心的功能，包括音频、动画、物理、剔除与合批、手柄设备接口等。&lt;/p&gt;

&lt;p&gt;引擎应用层，在核心层之上建立起来的引擎业务，包括性能剖析工具、UI核心框架、粒子系统、后处理系统等。&lt;/p&gt;

&lt;p&gt;业务基础层，引擎为游戏框架搭建而做的基础功能，是提供给实现游戏逻辑的重要功能与接口。&lt;/p&gt;

&lt;p&gt;游戏框架层，通过调用业务基础层来搭建的游戏框架，是游戏实现自身逻辑的框架，也是游戏逻辑的核心。&lt;/p&gt;

&lt;p&gt;游戏业务层，是实现具体游戏业务的逻辑，通过调用游戏框架来实现具体的业务逻辑。&lt;/p&gt;

&lt;h3 id=&quot;游戏引擎架构图&quot;&gt;游戏引擎架构图&lt;/h3&gt;

&lt;p&gt;在拆解了整个引擎的架构时，由于模块太多，因此只列了一些主要的模块，保持了基本架构的完整性：&lt;/p&gt;

&lt;p&gt;架构图中的重要模块，将在后面的文章中做详细的分析和解剖。&lt;/p&gt;

&lt;h3 id=&quot;参考资料&quot;&gt;参考资料：&lt;/h3&gt;

&lt;p&gt;《游戏引擎架构》 译者：叶劲峰&lt;/p&gt;

&lt;p&gt;《3D游戏引擎发展史》&lt;/p&gt;

&lt;p&gt;https://www.bilibili.com/read/cv6499569/&lt;/p&gt;

&lt;p&gt;《游戏引擎wiki》&lt;/p&gt;

&lt;p&gt;https://zh.wikipedia.org/wiki/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E&lt;/p&gt;

&lt;p&gt;《你不能不知道的计算机图形技术发展史》1、2&lt;/p&gt;

&lt;p&gt;https://www.bilibili.com/read/cv196689&lt;/p&gt;

&lt;p&gt;https://www.bilibili.com/read/cv221830&lt;/p&gt;

&lt;p&gt;《了解图形接口》&lt;/p&gt;

&lt;p&gt;https://www.jianshu.com/p/9dea5f163837&lt;/p&gt;

&lt;p&gt;《图形API发展历史》&lt;/p&gt;

&lt;p&gt;https://blog.csdn.net/ce1061183126/article/details/106159169&lt;/p&gt;

&lt;p&gt;《卡通渲染 Wiki》&lt;/p&gt;

&lt;p&gt;https://zh.wikipedia.org/wiki/%E5%8D%A1%E9%80%9A%E6%B8%B2%E6%9F%93&lt;/p&gt;

&lt;p&gt;《高动态光照渲染》&lt;/p&gt;

&lt;p&gt;https://zh.wikipedia.org/wiki/%E9%AB%98%E5%8A%A8%E6%80%81%E5%85%89%E7%85%A7%E6%B8%B2%E6%9F%93&lt;/p&gt;

&lt;p&gt;《Metal Wiki》&lt;/p&gt;

&lt;p&gt;https://en.wikipedia.org/wiki/Metal_(API)#History&lt;/p&gt;

&lt;p&gt;《Direct3D Wiki》&lt;/p&gt;

&lt;p&gt;https://en.wikipedia.org/wiki/Direct3D#Direct3D_12&lt;/p&gt;

&lt;p&gt;《OpenGL Wiki》&lt;/p&gt;

&lt;p&gt;https://en.wikipedia.org/wiki/OpenGL&lt;/p&gt;

&lt;p&gt;《Vulkan Wiki》&lt;/p&gt;

&lt;p&gt;https://en.wikipedia.org/wiki/Vulkan_(API)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484890&amp;amp;idx=1&amp;amp;sn=1d319050c82fed232d22f1f3dfce0cd3&amp;amp;chksm=fc2260ddcb55e9cbbda832e90def1e8e7440b7ffc85c60264be83d9c6bc62162c5b05839839b&amp;amp;token=834275592&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;
</description>
               <pubDate>Sun, 29 Aug 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/08/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B042</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/08/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B042</guid>
            </item>
        
            <item>
               <title>读书笔记(四十一) 《心流》#2 为何要培养独立意识</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484880&amp;amp;idx=1&amp;amp;sn=869424bd26f3c3fd8524ede6ced2d7a0&amp;amp;chksm=fc2260d7cb55e9c16f0a6d8c314dcb211bd43e7e6143d5f2dceee208ded17bb9bcd5d662854f&amp;amp;token=1516544318&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;背景&quot;&gt;背景：&lt;/h2&gt;

&lt;p&gt;在2020年初就买了《心流》，直到2021年1月才读完第一遍，读完的那一刻，我知道我又打开了一个新世界。&lt;/p&gt;

&lt;p&gt;不得不承认就是这本书让我的专注力提高了整整一个级别，这是最让我非常兴奋的地方。而我只是读了第一遍，吸收不到10%的结果，可想而知它的魔力有多么强大。&lt;/p&gt;

&lt;p&gt;于是决定好好回顾总结一下整本书，便开启了第二遍、第三遍的读书之旅。&lt;/p&gt;

&lt;p&gt;读此书的起源是由于我在平时工作、交流、学习时，常常难以集中注意力，因此带着好奇心阅读了这本书。&lt;/p&gt;

&lt;p&gt;我猜大家应该也和我一样，常常为自己难以击中注意力而烦恼，其实我们都希望自己在专注做一件事情的时候能够拥有更高的效率。&lt;/p&gt;

&lt;p&gt;本书的核心是心流的最优体验，简单来说就是“如何让你高兴地专注”。&lt;/p&gt;

&lt;p&gt;作者想表达的是，当你的心流会的体验最佳时，也是学习效率最高的时候，同时也是你最幸福的时刻。&lt;/p&gt;

&lt;p&gt;书本中讲到了关于学习、工作、运动、社交等各方面的心流原理和技巧，我作为知识的搬运工，做了一些精炼和总结的工作。&lt;/p&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文：&lt;/h2&gt;

&lt;p&gt;简单回顾下前文，前文我们说，结果其实并不重要，过程才是我们幸福的来源，专注就是注重过程保持幸福的一种方法。我们常常心灵处于混乱状态，专注能让我们保持有序的心流。人生要的不是最后的终点，而是每时每刻点点滴滴成长的过程，成长本身就是我们的目的。&lt;/p&gt;

&lt;h2 id=&quot;为何我们在为拥有幸福而追求幸福&quot;&gt;为何我们在为拥有幸福而追求幸福&lt;/h2&gt;

&lt;p&gt;作者说我们常常为拥有幸福而追求幸福，同时我们也在追求其他目标，例如健康、美貌、金钱、权利，追求这些无非也是因为我们以为拥有这些就能得到幸福。&lt;/p&gt;

&lt;p&gt;维克多在《活出意义来》序言里写道：&lt;/p&gt;

&lt;h3 id=&quot;不要以成功为目标你越是对它念念不忘就越有可能错过它&quot;&gt;不要以成功为目标，你越是对它念念不忘，就越有可能错过它。&lt;/h3&gt;

&lt;h3 id=&quot;因为成功如同幸福不是追求就能得到它必须因缘际会是一个人全心全意投入并把自己置之度外时意外获得的副产品&quot;&gt;因为成功如同幸福，不是追求就能得到；它必须因缘际会，是一个人全心全意投入并把自己置之度外时，意外获得的副产品。&lt;/h3&gt;

&lt;p&gt;经研究表明，运动、游戏、音乐、绘画、嗜好等都是比较容易产生心流的活动，但我们不能光靠游戏和艺术来改善我们的生活啊，所以我们要学会如何将枯燥的工作转化为产生心流的活动。&lt;/p&gt;

&lt;p&gt;我们大多数人几乎一生时间都花在工作和社交上，因此学习把工作转化为产生心流的活动，以及设法与父母、配偶、儿女、朋友相处得更愉快，是格外重要的事。&lt;/p&gt;

&lt;h2 id=&quot;如何反转苦难的生活&quot;&gt;如何反转苦难的生活&lt;/h2&gt;

&lt;p&gt;不仅如此，生活还不断给我们各种挑战和苦难，这阻碍了我们享受幸福享受人生。&lt;/p&gt;

&lt;p&gt;那么如何不为苦难所阻，继续享受人生呢？&lt;/p&gt;

&lt;p&gt;人生的悲剧在所难免，即使是幸运儿也难免遭逢压力，但遭受这些打击未必就是与幸福绝缘。&lt;/p&gt;

&lt;h3 id=&quot;人在压力下的反应往往决定他们是否能转祸为福否则只能徒然地受苦受难&quot;&gt;人在压力下的反应，往往决定他们是否能转祸为福，否则只能徒然地受苦受难。&lt;/h3&gt;

&lt;h3 id=&quot;如果我们能做到在困难和压力下转祸为福就能对人生掌控自如使生命丰富璀璨&quot;&gt;如果我们能做到在困难和压力下转祸为福，就能对人生掌控自如，使生命丰富璀璨。&lt;/h3&gt;

&lt;h3 id=&quot;此时是否苗条是否富裕是否掌权都已无关紧要甚至最单调的体验也会变得趣味盎然&quot;&gt;此时，是否苗条、是否富裕、是否掌权都已无关紧要，甚至最单调的体验也会变得趣味盎然。&lt;/h3&gt;

&lt;h2 id=&quot;幸福之所以难求是因为我们的贪得无厌的欲望难以填满&quot;&gt;幸福之所以难求是因为我们的贪得无厌的欲望难以填满&lt;/h2&gt;

&lt;h3 id=&quot;我们说一个人如果不靠任何支持试图仅凭自己的力量去追求幸福很可能他会从极致的生理快乐和社会公认的最具吸引力的事物开始着手&quot;&gt;我们说一个人如果不靠任何支持，试图仅凭自己的力量去追求幸福，很可能他会从极致的生理快乐和社会公认的最具吸引力的事物开始着手。&lt;/h3&gt;

&lt;h3 id=&quot;因此财富权势性就成为很多人奋斗的主要目标然而大多数人并不明白这些并不能改善我们生活的品质&quot;&gt;因此财富、权势、性就成为很多人奋斗的主要目标，然而大多数人并不明白这些并不能改善我们生活的品质。&lt;/h3&gt;

&lt;p&gt;那该怎么办呢？作者说唯有直接控制体验感受，从我们所做的每一件事、每一个此时此刻中汲取快乐，才能克服欲望的障碍，从而得到满足。&lt;/p&gt;

&lt;p&gt;各种证据表明，大多数人会陷入期望值不断升高的恶性循环中无力自拔，但也有不少人能从中逃脱出来。&lt;/p&gt;

&lt;h3 id=&quot;这些人或许物质条件不够优越却仍然能改善生活品质他们不但自己知足常乐也常能使周遭的人生活得比其他人更快乐&quot;&gt;这些人或许物质条件不够优越，却仍然能改善生活品质，他们不但自己知足常乐，也常能使周遭的人生活得比其他人更快乐。&lt;/h3&gt;

&lt;h3 id=&quot;这种人充满活力愿意接纳各式各样的经历活到老学到老而且对别人及周遭的环境有强烈的责任感&quot;&gt;这种人充满活力，愿意接纳各式各样的经历，活到老学到老，而且对别人及周遭的环境有强烈的责任感。&lt;/h3&gt;

&lt;p&gt;那么到底有多少人热爱自己的工作，满意自己的运气，不追悔过去，对前途满怀信心呢？答案是：极少的。&lt;/p&gt;

&lt;p&gt;这种普遍的“病态”并非直接由外界因素引起。不满的根源存乎于一心，自己的问题唯有依靠自己才能解决。&lt;/p&gt;

&lt;p&gt;我们从小到大，在渐渐长大的过程中，从满怀希望的无知少年，长成冷静沉稳的大人。&lt;/p&gt;

&lt;p&gt;童年或许令人痛苦，青春期或许令人困惑，但对大多数人而言，痛苦与困惑的背后，至少还有个长大后一切会好转的希望。&lt;/p&gt;

&lt;p&gt;然而，长大后，各种老化的迹象明明白白地告诉我们“你的时间快到了，准备动身吧”，但很少人在这时候已经准备妥当。&lt;/p&gt;

&lt;p&gt;人们会反问，“等一下，不可能是我吧，我还没开始生活呢，我该赚的那些钱在哪儿，我该享受的那些好时光在哪儿”&lt;/p&gt;

&lt;p&gt;这番觉悟使我们有种受骗上当的感觉，似乎是慈悲的命运为我们安排好的一切。&lt;/p&gt;

&lt;p&gt;当这番觉悟来临时，每个人都会以不同的方式面对这个问题。有些人选择继续奋斗不息，金钱、名誉、权利，不得到誓不罢休。有些人则选择对症下药，节食、健身、跳舞、整容、上提高自信的课、参加权贵人士的午餐聚会等等。&lt;/p&gt;

&lt;p&gt;但不久人们就会发现，这些零星的解决方案根本发挥不了作用。&lt;/p&gt;

&lt;p&gt;无论下多少功夫，老化的定律不会因此而改写。&lt;/p&gt;

&lt;p&gt;提升了自信，无形中却疏远了朋友。&lt;/p&gt;

&lt;p&gt;花太多时间结交新朋友，又疏忽了配偶和家人。&lt;/p&gt;

&lt;p&gt;人们会发现，堤坝太多缺口，濒临溃决，根本来不及抢救。&lt;/p&gt;

&lt;p&gt;在无法同时满足太多要求的挫折之下，有些人干脆投降认输，躲进自己的小天地。&lt;/p&gt;

&lt;p&gt;他们可能培养一种高雅的嗜好，如搜集抽象画或陶瓷人像，甚至也会沉溺于酒精或麻醉品构筑的迷幻堡垒里。&lt;/p&gt;

&lt;p&gt;这些异国情调的娱乐和所费不菲的消遣活动，纵然能使人暂时忘记根本的疑问，却不能提供答案。&lt;/p&gt;

&lt;h2 id=&quot;我们是如何沦为社会控制的奴隶&quot;&gt;我们是如何沦为社会控制的奴隶&lt;/h2&gt;

&lt;h3 id=&quot;心理学家指出文明就是建立在压抑个人欲望基础上的社会成员不论乐意与否都被迫接受既定的习惯与技能否则就不可能维持社会秩序和复杂的分工制度&quot;&gt;心理学家指出，文明就是建立在压抑个人欲望基础上的。社会成员不论乐意与否，都被迫接受既定的习惯与技能，否则就不可能维持社会秩序和复杂的分工制度。&lt;/h3&gt;

&lt;p&gt;所以对于我们，个人的社会化是必然的。社会化的真谛在于使个人依赖社会的控制，并对赏罚有既定的反应。社会化的最高境界就是使每个人都完全认同社会秩序，根本不想触犯任何规则。&lt;/p&gt;

&lt;h3 id=&quot;我们应该了解到寻求快乐是基因为物种延续而设的一种即时反射其目的并非个人利益例如美食的快乐性爱的快乐娱乐的快乐都其实是人类基因的布局&quot;&gt;我们应该了解到，“寻求快乐”是基因为物种延续而设的一种即时反射，其目的并非个人利益。例如，美食的快乐、性爱的快乐、娱乐的快乐都其实是人类基因的布局。&lt;/h3&gt;

&lt;p&gt;跟随基因的反应，享受自然的乐趣，并没有什么不好，但我们应该认清事实真相，在必要的时候，按照自己的优先顺序，做自己的主人。&lt;/p&gt;

&lt;h3 id=&quot;彻底社会化的人只追求周遭他人认定的应该期望的东西这些东西往往都是与天性密切结合的欲望&quot;&gt;彻底社会化的人，只追求周遭他人认定的、应该期望的东西，这些东西往往都是与天性密切结合的欲望。&lt;/h3&gt;

&lt;h3 id=&quot;他可能会有机会经历到许多难能可贵的事但由于这些事与他们的欲望不符而被他们完全忽略掉&quot;&gt;他可能会有机会经历到许多难能可贵的事，但由于这些事与他们的欲望不符而被他们完全忽略掉。&lt;/h3&gt;

&lt;h3 id=&quot;其实他们在意的并非他们现在拥有什么而是满足别人的要求后能获得什么&quot;&gt;其实他们在意的并非他们现在拥有什么，而是满足别人的要求后能获得什么。&lt;/h3&gt;

&lt;h3 id=&quot;这种沦为社会控制的奴隶人只知道周而复始地追逐一到手就化为泡影的奖赏他们的局限性太强被社会和他人牢牢地控制&quot;&gt;这种沦为社会控制的奴隶人，只知道周而复始地追逐“一到手”就化为泡影的奖赏，他们的局限性太强，被社会和他人牢牢地控制。&lt;/h3&gt;

&lt;p&gt;虽然在这个复杂的社会求生，绝对有必要实现外在的目标而去暂时牺牲一些自我意识，但不必因此而成为傀儡。&lt;/p&gt;

&lt;h3 id=&quot;为了不让自己成为傀儡最好的方法是不以社会的奖赏为念试着以自己所能控制的奖赏取而代之&quot;&gt;为了不让自己成为傀儡，最好的方法是不以社会的奖赏为念，试着以自己所能控制的奖赏取而代之。&lt;/h3&gt;

&lt;h3 id=&quot;当然这也并不表示我们要完全放弃社会认可的每项目标而是在社会用以利诱我们的目标之外另行建立自己的目标&quot;&gt;当然这也并不表示，我们要完全放弃社会认可的每项目标，而是在社会用以利诱我们的目标之外，另行建立自己的目标。&lt;/h3&gt;

&lt;p&gt;然而，从社会制约下解放自我，最重要的步骤就是，时时刻刻发掘每一事件中的回馈。&lt;/p&gt;

&lt;p&gt;如果我们学会在不断向前推进的体验中找到快乐与意义，社会制约的重担就会从肩上自动滑落。&lt;/p&gt;

&lt;p&gt;当奖赏不再受外在力量管制时，生命的权力就回到了个人手中。&lt;/p&gt;

&lt;p&gt;社会根据生物倾向而设计的“刺激–反应”模式，就是受外界所控制的。&lt;/p&gt;

&lt;p&gt;无论是迷人的广告使我们对产品垂涎不已，还是老板皱一下眉头就使我们整天提心吊胆，都代表着我们没有决定体验内涵的自由。&lt;/p&gt;

&lt;h3 id=&quot;人们害怕的其实是自己对事物的看法而非事物本身外界事物令你痛苦并不是因为它们打扰了你而是归因于你对它们的判断而你有能力立刻消除这种判断&quot;&gt;人们害怕的其实是自己对事物的看法，而非事物本身。外界事物令你痛苦并不是因为它们打扰了你，而是归因于你对它们的判断，而你有能力立刻消除这种判断。&lt;/h3&gt;

&lt;h2 id=&quot;培养独立意识有多难&quot;&gt;培养独立意识有多难&lt;/h2&gt;

&lt;p&gt;在亚洲有很多控制意识的技巧，能使人达到高层次的满足感。&lt;/p&gt;

&lt;p&gt;例如，印度瑜伽、佛教禅宗、宗教祷告等，目的都在于摆脱混沌的威胁和生理冲动的制约，从而释放内在生命。&lt;/p&gt;

&lt;p&gt;但各派的哲学都依赖于当时所创生的环境，这些额外的成分若不能从基本要素中剔除，那么通往自由的路上就不免要长出许多莠草。形式一旦逾越内容，追寻者就只得重回起点。&lt;/p&gt;

&lt;h3 id=&quot;所以想要培养我们的独立意识对意识的控制就不能予以制度化一旦成为社会规则与标准它就失去了原有的作用&quot;&gt;所以想要培养我们的独立意识，对意识的控制就不能予以制度化，一旦成为社会规则与标准，它就失去了原有的作用。&lt;/h3&gt;

&lt;h3 id=&quot;在时代更迭频繁的时代每隔几年培养独立意识所需的条件就会变化我们必须重新加以考虑与组合&quot;&gt;在时代更迭频繁的时代，每隔几年，培养独立意识所需的条件就会变化，我们必须重新加以考虑与组合。&lt;/h3&gt;

&lt;p&gt;既然掌握人生是永远的中心议题，现代知识对此有什么看法呢？一个人又如何消除焦虑与恐惧，摆脱对社会奖赏的患得患失之心呢？&lt;/p&gt;

&lt;h3 id=&quot;作者给出了简短的回答控制意识才能控制体验的品质任何在这方面的进步都能够提升生活的品质使快乐更快乐也更有意义&quot;&gt;作者给出了简短的回答，控制意识才能控制体验的品质，任何在这方面的进步都能够提升生活的品质，使快乐更快乐、也更有意义。&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484880&amp;amp;idx=1&amp;amp;sn=869424bd26f3c3fd8524ede6ced2d7a0&amp;amp;chksm=fc2260d7cb55e9c16f0a6d8c314dcb211bd43e7e6143d5f2dceee208ded17bb9bcd5d662854f&amp;amp;token=1516544318&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;
</description>
               <pubDate>Sun, 22 Aug 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/08/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B041</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/08/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B041</guid>
            </item>
        
            <item>
               <title>读书笔记(四十) 《非暴力沟通》#3 - 沟通中如何爱自己</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484873&amp;amp;idx=1&amp;amp;sn=b7d9986ffd0f259ec3dc25bc50f528a5&amp;amp;chksm=fc2260cecb55e9d8dec522275320a2211e2ebb4f2025ff415c6e730c66d0ce07b9aaa0892adb&amp;amp;token=1516544318&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;背景&quot;&gt;背景：&lt;/h2&gt;

&lt;p&gt;表达能力和沟通技巧有诸多问题，工作和生活上出现了比较大的瓶颈，于是看了些表达和沟通方面的书，其中三本最为经典《非暴力沟通》、《关键对话》、《说话的艺术》。细细品读了这三本书并且收获满满，分享出来希望大家一同进步。&lt;/p&gt;

&lt;p&gt;看完书后反观自己以前的沟通技巧和表达方式，明白了以前自己在这些方面都有比较大的认知错误，回想起来可以用愚蠢来形容。&lt;/p&gt;

&lt;p&gt;既然有这么好的沟通技巧和表达方式，我希望将这些方法和技巧实实在在的落地到实际生活中，让生活、工作、学习更美好。&lt;/p&gt;

&lt;p&gt;下面我就以《非暴力沟通》这本书为主线，来阐述我们在沟通过程中遇到的一些问题和对应的解决方法。&lt;/p&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文：&lt;/h2&gt;

&lt;p&gt;简单回顾下前文，前面我们说在提出的请求要明确，请求越详细越具体，才能让别人更清楚的了解我们的想法。&lt;/p&gt;

&lt;p&gt;同时说了，倾听很重要，它能治愈身心也能预防潜在的暴力，倾听后向对方做出良好的反馈使得对话能够保持顺畅温和。&lt;/p&gt;

&lt;p&gt;这节也是非暴力沟通学习的最后一篇，主题是在沟通时如何爱自己。&lt;/p&gt;

&lt;h3 id=&quot;爱自己而不是自责&quot;&gt;爱自己而不是自责&lt;/h3&gt;

&lt;p&gt;非暴力沟通最重要的应用在于 - 爱护自己&lt;/p&gt;

&lt;p&gt;我们常常对自己做出负面的评价，严厉的苛责自己。&lt;/p&gt;

&lt;p&gt;但负面的自我评价使我们看不到生命的美，让我们忘记自己是“特殊的生命”，而把自己当做一个工具。&lt;/p&gt;

&lt;h3 id=&quot;如果我们习惯于将自己视为工具充满各种缺陷的工具那么自我憎恨是自然的&quot;&gt;如果我们习惯于将自己视为工具，充满各种缺陷的工具，那么自我憎恨是自然的。&lt;/h3&gt;

&lt;p&gt;其实我们都希望自己所做的任何事情都是有益的，良好的自我评价的方式就要有助于学习，使我们的选择符合生命的需要。&lt;/p&gt;

&lt;h3 id=&quot;然而不幸的是我们的自我评价方式往往是负面这直接导致了自我憎恨而无助于学习&quot;&gt;然而不幸的是，我们的自我评价方式往往是负面，这直接导致了自我憎恨，而无助于学习。&lt;/h3&gt;

&lt;p&gt;许多人会陷入自责，他们认为自己所做的事情是错的，并且应当为此感到痛苦。&lt;/p&gt;

&lt;p&gt;虽然我们犯的错误揭示了我们的局限性从而引导我们成长，但陷入自责使得我们无法从错误中获益。&lt;/p&gt;

&lt;p&gt;作者认为我们的改变最好要出于对生命的爱，而不是出于羞愧或内疚这些具有负面影响的心理。因为羞愧是自我憎恨的一种形式，出于羞愧的行为不是自由快乐的行为。即使我们试图更加友善和体贴，一旦人们意识到我们行为背后的羞愧或内疚，他们对这些行为的欣赏也就比不上那些只是出于爱的行为了。&lt;/p&gt;

&lt;p&gt;我们的话语中常常带有一些容易引起羞愧和内疚的词，例如，“应该”，“不得不”，“必须”，举个简单的例子：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;我应该早点知道&lt;/li&gt;
  &lt;li&gt;我真的应该戒烟了&lt;/li&gt;
  &lt;li&gt;我必须加强锻炼&lt;/li&gt;
  &lt;li&gt;我真的受不了自己，我必须改改&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;一旦我们顺从了这些羞愧和内疚的命令生活也就会失去了乐趣如果我们经常责备自己强迫自己也使我们更像工具而不像人从而引起自我的憎恨&quot;&gt;一旦我们顺从了这些羞愧和内疚的命令，生活也就会失去了乐趣。如果我们经常责备自己、强迫自己，也使我们更像工具而不像人，从而引起自我的憎恨。&lt;/h3&gt;

&lt;p&gt;因此当发现自己在做错误的事时，其实我们的挑战是如何对需要和价值观保持清醒的认识，这促进我们转变。&lt;/p&gt;

&lt;p&gt;其中专注于需要能帮助我们从自我评价中获益，那么怎样才算是“专注于需要”呢？下面作者为我们做了解释。&lt;/p&gt;

&lt;h3 id=&quot;我们应该尽可能的直面人生的苦难在遇到挫折时充分体会人生的悲哀和内心的渴望感到遗憾是难免的无须责备自己它能帮助我们从经历中学习&quot;&gt;我们应该尽可能的直面人生的苦难：在遇到挫折时，充分体会人生的悲哀和内心的渴望。感到遗憾是难免的，无须责备自己，它能帮助我们从经历中学习。&lt;/h3&gt;

&lt;h3 id=&quot;专注于需要&quot;&gt;专注于需要&lt;/h3&gt;

&lt;h3 id=&quot;如果我们能专注于尚未满足的需要我们就能从中获益并考虑如何满足它&quot;&gt;如果我们能专注于尚未满足的需要，我们就能从中获益并考虑如何满足它。&lt;/h3&gt;

&lt;h3 id=&quot;只要我们对自己的需要保持清醒的认识我们就能建设性地满足它们&quot;&gt;只要我们对自己的需要保持清醒的认识，我们就能建设性地满足它们。&lt;/h3&gt;

&lt;h3 id=&quot;反之如果用苛刻的语言指责自己我们不仅难以找到解决办法而且容易陷于自我惩罚的痛苦中&quot;&gt;反之，如果用苛刻的语言指责自己，我们不仅难以找到解决办法，而且容易陷于自我惩罚的痛苦中。&lt;/h3&gt;

&lt;p&gt;那么什么是专注于需要呢？作者举了一个自己的例子：&lt;/p&gt;

&lt;p&gt;有一天他买了一件漂亮的外衣出席会议，在外衣口袋里放了一只钢笔，到达会议才发现钢笔帽忘盖了，外套上染上了一片黑色。他不停的训斥自己“你怎么可以这么粗心！”，此刻其实正是作者需要得到体谅的时刻。幸运的是他很快就意识到了自己的自责，于是他停下来，回想了下，发现其实他是想要照顾好自己，在匆忙地回应他人的请求时，多留意些自己的需要让自己更体面更舒适一些。想到这里，他的心情也开始变化，不再感到恼怒、羞愧和内疚，身体也放松了下来。&lt;/p&gt;

&lt;p&gt;故事中，作者把恼怒和内疚的情绪转移为观察自己“去了解自己，需要什么”，了解到了自己的真实需求后，心情也开始发生了变化，最后身体放松了下来。
如果我们能致力于满足他人及自己健康成长的需要，那么即使艰难的工作也不乏乐趣。&lt;/p&gt;

&lt;p&gt;反之，如果我们的行为是出于义务、职责、恐惧、内疚或羞愧，那么即使有意思的事情也会变得枯燥无味。&lt;/p&gt;

&lt;p&gt;在我们的社会中内疚常常被运用来控制人，这造成指责他人常常成为一种习惯。有时为了使这种手段奏效，我们可能就会认为一个人可以主导另一个人的情绪。这是极其错误的想法。&lt;/p&gt;

&lt;p&gt;对于每个人来说，同一件事情有不同的需要，也导致了不同的感受。&lt;/p&gt;

&lt;p&gt;如果意识不到自己尚未满足的需要，一心考虑别人的过错，我们难免就会生气。&lt;/p&gt;

&lt;h3 id=&quot;其实我们无须压抑愤怒只要我们专注于他人的感受和需要愤怒也就不再存在&quot;&gt;其实我们无须压抑愤怒，只要我们专注于他人的感受和需要，愤怒也就不再存在。&lt;/h3&gt;

&lt;p&gt;作者说出了愤怒的根本原因，即愤怒其实是我们的思维方式造成的，正是由于我们的思维方式无法满足我们的需要导致了我们的愤怒。
如果我们能够借助愤怒来提醒自己，我们的需要没有得到满足，这表明当下我们的思维方式有问题，因为它难以满足我们的需要，从这个角度思考的话愤怒就是有价值的。&lt;/p&gt;

&lt;p&gt;因此我们有必要了解自己的需要再采取行动。&lt;/p&gt;

&lt;p&gt;但是做到这一点并不容易，因为愤怒驱使我们去惩罚他人，而不是去满足需要，这是人性使然。&lt;/p&gt;

&lt;p&gt;作者建议我们有意识的去培养发现对方和自己需要的习惯，与其沉浸于“合理的愤怒”，不如倾听自己和他人的需要。&lt;/p&gt;

&lt;p&gt;当然，这需要一个过程，我们需要通过不断实践去培养这个思维习惯，有意识的将“我生气是因为他们xxx”代替为“我生气是因为我需要xxx，对方需要xxx”。&lt;/p&gt;

&lt;p&gt;这里又举了一个作者生活中的例子，&lt;/p&gt;

&lt;p&gt;有一次他去一所学校提供咨询服务时，被两个孩子各打了两拳，第一个孩子打他时他差点打回去，第二个孩子打他时他则没有。他回想起这段经历说，自己生气的原因并不在于别人到底做了什么，而在于自己怎么看待对方及其行为。因为第一个孩子作者一开始就认为对方是个调皮的坏孩子，所以打他时他很生气，而第二个孩子作者从一开始就认为是个可爱的孩子，所以打他时他能从容的面对。&lt;/p&gt;

&lt;p&gt;由此可知，如果人们认为自己的痛苦是由他人造成的，并认为那人应该受到谴责或惩罚，那么我们就播下了暴力的种子。&lt;/p&gt;

&lt;p&gt;同样的，如果我们满脑子是非对错，把某些人看作是贪婪的人、不负责任的人、骗子或其他类型的坏人，那么，我们就很难与他们建立良好的关系。&lt;/p&gt;

&lt;h3 id=&quot;说到底我们通常生气的原因并不在于别人到底做了什么而是我们自己怎么看待对方及其行为&quot;&gt;说到底，我们通常生气的原因，并不在于别人到底做了什么，而是我们自己怎么看待对方及其行为。&lt;/h3&gt;

&lt;h3 id=&quot;指责他人有时可以使我们达到目的例如他们出于害怕内疚或惭愧使他们改变了自己的行为&quot;&gt;指责他人有时可以使我们达到目的，例如他们出于害怕、内疚或惭愧，使他们改变了自己的行为。&lt;/h3&gt;

&lt;h3 id=&quot;然而以这样的方式来满足我们的需要其实我们也是在使用暴力&quot;&gt;然而，以这样的方式来满足我们的需要，其实我们也是在使用暴力。&lt;/h3&gt;

&lt;p&gt;那么当我们愤怒时到底应该怎么做才能让表达更流畅呢？&lt;/p&gt;

&lt;p&gt;作者给出了，正确表达愤怒的四个步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;停下来，除了呼吸，什么都别做&lt;/li&gt;
  &lt;li&gt;想一想是什么想法使我们生气了&lt;/li&gt;
  &lt;li&gt;试着去了解自己的需要&lt;/li&gt;
  &lt;li&gt;表达当下的感受和尚未满足的需要&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有时在步骤4表达前需要先倾听了解别人的需要，当我们专注于他人的感受和需要时，我们就会发现彼此作为人的共同点。&lt;/p&gt;

&lt;p&gt;根据生活经验，在与人交往的过程中，我们的第一反应常常是习惯性的反应，因此运用非暴力沟通其实是很别扭的事。只要人们认为自己受到了指责，他们就很难体会到别人的痛苦。因此专注他人的感受和需要并不容易，我们需要有足够的耐心来学习和运用非暴力沟通。&lt;/p&gt;

&lt;p&gt;这里列举了几个生活中的方法，来练习非暴力沟通：&lt;/p&gt;

&lt;p&gt;方法1，把非暴力沟通的表达形式写在一张卡片上，每次有人批评时，就把卡片拿出来提醒自己用非暴力沟通方式表达。&lt;/p&gt;

&lt;p&gt;方法2，刚开始运用非暴力沟通时，把节奏放慢些，在说话前先想一想，有时甚至停下来，什么也不说。&lt;/p&gt;

&lt;p&gt;方法3，留意我们脑袋中“我不喜欢抽烟的人…”之类的想法，然后问自己“我不喜欢他们…，是因为我什么样的需要没有得到满足”，通过这样的方式，我
们就把注意力放在了尚未得到满足的需要，而不是考虑他人有什么过错。&lt;/p&gt;

&lt;h3 id=&quot;运用强制力避免伤害&quot;&gt;运用强制力避免伤害&lt;/h3&gt;

&lt;p&gt;作者列举了几个不够成熟的表现，它认为当人们不够成熟的时候我们可能会有以下的表现&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;我们意识不到自己行为的后果&lt;/li&gt;
  &lt;li&gt;我们认识不到，我们并不需要通过惩罚他人来满足自己的需要&lt;/li&gt;
  &lt;li&gt;我们相信，我们有“权利”去惩罚或伤害他人，因为他们是罪有应得。&lt;/li&gt;
  &lt;li&gt;我们产生了幻觉，例如，听到“某种声音”叫我们去杀人。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在使用惩罚性的强制力时，我们在心里认为某些人是邪恶的，为了让他们悔改，必须给他们一点颜色看看。&lt;/p&gt;

&lt;p&gt;此时的我们希望痛苦能让他们，意识到自己的过程，或感到懊悔，或改变行为。然而，实际生活中，惩罚往往加强了对方的敌意和抵触心理，使双方的关系更加疏远。&lt;/p&gt;

&lt;p&gt;例如在我们面对的孩子教育时：&lt;/p&gt;

&lt;p&gt;有时候，孩子拒绝做一件对他们有益的事情，只是因为他们不想在父母的压力面前屈服。
其次，即使体罚能带来立竿见影的效果，这也并不意味着，其他方法无法达到同样的效果。
体罚孩子会造成不良的社会影响。除了体罚外，指责或否定他人也是常见的惩罚方式。&lt;/p&gt;

&lt;h3 id=&quot;惩罚的代价&quot;&gt;惩罚的代价&lt;/h3&gt;

&lt;h3 id=&quot;我们要清醒的认识到惩罚是有代价的当我们为了回避惩罚去做事情时我们可能会忽视事情本身的价值而仅仅陷入了对失败的忧虑如果员工的表现只是在服从管理层的命令士气就会受到影响工作效率迟早都会降低惩罚也将导致关系的疏远一旦我们被看作是施暴的人我们就很难得到友善的回应&quot;&gt;我们要清醒的认识到惩罚是有代价的，当我们为了回避惩罚去做事情时，我们可能会忽视事情本身的价值，而仅仅陷入了对失败的忧虑。如果员工的表现只是在服从管理层的命令，士气就会受到影响，工作效率迟早都会降低。惩罚也将导致关系的疏远，一旦我们被看作是施暴的人，我们就很难得到友善的回应。&lt;/h3&gt;

&lt;p&gt;举个例子，
作者有一次去校园培训，校长看到操场上有个学生在打人，校长抓住那个学生，重重推了他一下并训斥道他。
作者告诉校长，他并没有达到目的，学生只是学会了在打比他弱小的人时要注意附近是否有比他强壮的人，并且强化了他们通过打架来解决问题的意识。&lt;/p&gt;

&lt;p&gt;当我们想要影响他人的行为时，存在两个问题：&lt;/p&gt;

&lt;p&gt;第一，当我不喜欢他现在的行为时，我希望他怎么做？&lt;/p&gt;

&lt;p&gt;第二，我希望他基于怎样的原因去做我想要他做的事情？&lt;/p&gt;

&lt;h3 id=&quot;威胁和惩罚确实可以影响第一个问题我希望他怎么做但我们可以发现它难以实现第二个问题我希望他基于怎样的原因去做这就是惩罚的局限性&quot;&gt;威胁和惩罚确实可以影响第一个问题（我希望他怎么做），但我们可以发现它难以实现第二个问题（我希望他基于怎样的原因去做），这就是惩罚的局限性。&lt;/h3&gt;

&lt;p&gt;再举了个例子，
在一所秩序比较混乱的学校里，作者通过沟通了解到，上课时有些学生听不进去但又没有地方去，所以在课堂上捣乱。
经过跟学生的一番讨论，他们主动提出，设置一个空教室，听不进课的学生可以选择去那个教室玩自己的事，这样课堂上其他想要学习的学生就不会被打扰了。&lt;/p&gt;

&lt;p&gt;于是作者请求校长设置这样一个空教室，并且在教室里安排一个熟练掌握非暴力沟通技巧的老师和他们交谈，最后慢慢地学校恢复了正常的秩序。&lt;/p&gt;

&lt;h3 id=&quot;了解别人基于什么样的原因来满足我们的需要是至关重要的因为我们彼此相互依存我们的幸福与他人的幸福息息相关&quot;&gt;了解别人基于什么样的原因来满足我们的需要是至关重要的，因为我们彼此相互依存，我们的幸福与他人的幸福息息相关。&lt;/h3&gt;

&lt;p&gt;生活中我们也许需要使用强制力来保护自己和他人，但这样做只是为了避免伤害而不是为了惩罚他人。&lt;/p&gt;

&lt;h3 id=&quot;如果我们通过威胁和惩罚手段来制裁他人人们常常会产生敌意和抵触心理这样彼此的关系将会疏远&quot;&gt;如果我们通过威胁和惩罚手段来制裁他人，人们常常会产生敌意和抵触心理。这样，彼此的关系将会疏远。&lt;/h3&gt;

&lt;h3 id=&quot;重获生活的热情&quot;&gt;重获生活的热情&lt;/h3&gt;

&lt;h3 id=&quot;倾听内心的声音&quot;&gt;倾听内心的声音&lt;/h3&gt;

&lt;p&gt;我们在社会文化影响下形成了许多不良的习惯，渗透到了生活的各个方面，以致于我们很难察觉到它们的存在。&lt;/p&gt;

&lt;p&gt;前面我们认识到，情感的根源在于个人的需要和想法，并且我们需要以建设性的语言提出明确的请求。在《精神病学的革命》一书中提出，“沮丧是因为一个人处于激烈的内心冲突之中，无所适从”，就像我们的内心中有两个声音在呼喊那样，一个说要这样做，另一个说要那样做，我们陷入了僵局。
因此沮丧意味着，我们不了解自己的需要，我们不知道自己到底要什么以及如何满足愿望。&lt;/p&gt;

&lt;p&gt;举了一位女士的例子，
这位女士很沮丧，在孩子出生后一直在家里照顾孩子，她很想出去工作，这两种声音一直在内心中冲突。
于是她用非暴力沟通的方式表达出来，“为了照顾孩子我放弃了工作，我有点心灰意冷，因为我需要成就感，我想出去找份工作”，“我一想到上班，就很害怕，因为我要确保孩子得到很好的照顾，我想我需要一位好保姆来照顾孩子，而且我还要确保下班时有精力陪伴孩子”。
这位女士用两次非暴力沟通与两个不同的自己对话，说出心里话后让她大大的松了一口气。&lt;/p&gt;

&lt;p&gt;这个故事告诉我们，当我们正确表达出我们的需要和感受时，我们会更爱护自己同时也会让自己“松一口气”。&lt;/p&gt;

&lt;h3 id=&quot;心灵环保&quot;&gt;心灵环保&lt;/h3&gt;

&lt;h3 id=&quot;现实告诉我们如果我们时常以苛刻的态度对人对己我们的心情也好不到哪里去&quot;&gt;现实告诉我们，如果我们时常以苛刻的态度对人对己，我们的心情也好不到哪里去。&lt;/h3&gt;

&lt;p&gt;运用非暴力沟通，我们能不再试图分析自己或他人有什么毛病，而是用心去了解我们的需要，这样，我们的内心就会逐渐变得平和。&lt;/p&gt;

&lt;p&gt;作者举了两个学生的例子，
以前他每次头痛时都会回忆前几天的经历来找到原因，现在则不同，他会先问自己需要做什么来缓解头痛，然后坐起来做一些柔和的头部运动，走到外面做一些别的事情，让自己放松下来。他观察到了自己的状态，并了解了自己的需要，通过这样的方式他有了重大的突破。
另一个学生，他每次开车都有路怒症，看到别人开车不守规矩就会愤怒，现在他更多的会去关注自己的感受和需要，以及对方司机的感受和需要。“是的，我看到他们这样开车，我真的很害怕，我希望他们开车时能注意安全”，“前面的那位司机有点不知所措，希望得到后面司机的谅解。路渐宽时我超车看到司机是位老太太，她看上去确实是惊慌失措，我很庆幸，我曾用心去体会她的感受和需要。”&lt;/p&gt;

&lt;h3 id=&quot;用非暴力沟通代替诊断&quot;&gt;用非暴力沟通代替诊断&lt;/h3&gt;

&lt;p&gt;作者相信可以用非暴力沟通来代替诊断和治疗。他相信，在治疗过程中，表达个人的感受和需要是有益的。&lt;/p&gt;

&lt;p&gt;于是在诊所诊断病人时，作者不再根据他所学习的心理学理论来分析来访者的心理特点，而是用心去体会他们的话，并表达自己内心的感受。结果效果非常好，无论是来访者还是我自己，都十分满意。&lt;/p&gt;

&lt;p&gt;作者解释到，自己不会去分析病人有什么毛病，而是问自己以下问题，“她现在什么心情？有什么需要？和她在一起我是什么心情？我的心情反映了我怎样的需要？我想请她做出什么决定或采取什么行动，以使她能快乐些？”在回答这样的问题时，我们会揭示自己的内心活动以及个人需要。与平常的诊断相比，我们能深深体会到我们作为人的弱点。&lt;/p&gt;

&lt;p&gt;一旦我们不把人当作诊断的对象，而是专注于彼此作为人的感受和需要，人们通常都会有积极的反应。&lt;/p&gt;

&lt;p&gt;小节，在情绪低落时，我们也许会怨天尤人。如果我们以苛刻的态度对人对己，我们的心情也好不到哪里去。&lt;/p&gt;

&lt;p&gt;通过运用非暴力沟通，我们不再试图分析自己或他人有什么毛病，而是用心去了解我们的需要，这样，我们的内心就会逐渐变得平和。
一旦我们发现自己心底深处的愿望，并采取积极的行动，我们将会重获生活的热情。&lt;/p&gt;

&lt;h3 id=&quot;如何正确的表达感激&quot;&gt;如何正确的表达感激&lt;/h3&gt;

&lt;p&gt;赞扬也可能造成人与人之间的隔阂。这听起来似乎很奇怪。不过请注意，在赞扬他人时，我们很少揭示内心活动，而把自己放在了裁判的位置。
我们认为，赞扬并不总是有助于深化彼此的联系。&lt;/p&gt;

&lt;p&gt;如果学生或员工一旦意识到经理和老师赞扬的目的是为了操纵他们，员工和学生很可能就会产生逆反心理。&lt;/p&gt;

&lt;p&gt;当发现这些赞扬的潜在目的之后，人们对于由衷的感谢也会心存疑虑。&lt;/p&gt;

&lt;p&gt;同样的，如果我们利用赞扬来施加影响，对方还可能误解我们的意思。&lt;/p&gt;

&lt;p&gt;用非暴力沟通方式表达感激时，我们只是为了庆祝他人的行为提升我们的生活品质，而不是想得到任何回报。&lt;/p&gt;

&lt;p&gt;非暴力沟通表达感激的方式包含三部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对方做了什么事情时我们的生活得到了改善？&lt;/li&gt;
  &lt;li&gt;我们有哪些需要得到了满足？&lt;/li&gt;
  &lt;li&gt;得到满足后，我们的心情怎么样？&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;我们常常假定人们已经知道我的情意然而这是想当然的即使人们在听到感激时也会感到尴尬他们会想听到明确的表达而不是泛泛而谈的感激&quot;&gt;我们常常假定人们已经知道我的情意，然而这是想当然的。即使人们在听到感激时也会感到尴尬，他们会想听到明确的表达，而不是泛泛而谈的感激。&lt;/h3&gt;

&lt;p&gt;在别人表达感激时，人们通常有两种截然不同的反应。一种是自我膨胀，相信我们比别人优越；另一种是假谦虚，否定别人的欣赏，耸耸肩“哦，这没什么”。如果我们意识到我的能力是生命赋予我的，我就能够同时避免自我膨胀和假谦虚。&lt;/p&gt;

&lt;h3 id=&quot;当别人我们的感激时我们可以与对方一起庆祝生命的美这样既不自大也不假谦虚&quot;&gt;当别人我们的感激时，我们可以与对方一起庆祝生命的美，这样既不自大也不假谦虚。&lt;/h3&gt;

&lt;p&gt;以色列前总理哥达曾说，“不要那么谦虚，因为你没有那么伟大”。作家玛丽安也说，“我们让自己的光芒闪耀，也允许他人散发光芒。一旦我们从自我的恐惧中解放出来，我们的存在，也会让他人得到解放。”&lt;/p&gt;

&lt;p&gt;最后回顾下非暴力沟通模式，观察、感受、需要、请求&lt;/p&gt;

&lt;p&gt;1.观察&lt;/p&gt;

&lt;p&gt;我所观察到的有助于我的福祉的具体行为&lt;/p&gt;

&lt;p&gt;2.感受&lt;/p&gt;

&lt;p&gt;对于这些行为，我有什么样的感受&lt;/p&gt;

&lt;p&gt;3.需要&lt;/p&gt;

&lt;p&gt;什么样的需要或价值导致我那样的感受&lt;/p&gt;

&lt;p&gt;4.请求&lt;/p&gt;

&lt;p&gt;清楚地请求那些能丰富我生命的具体行为&lt;/p&gt;

&lt;p&gt;我们在表达时要注意两点：&lt;/p&gt;

&lt;p&gt;一.诚实地表达自己，而不批评、指责&lt;/p&gt;

&lt;p&gt;二.关切地倾听他人，而不解读为批评或指责&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484873&amp;amp;idx=1&amp;amp;sn=b7d9986ffd0f259ec3dc25bc50f528a5&amp;amp;chksm=fc2260cecb55e9d8dec522275320a2211e2ebb4f2025ff415c6e730c66d0ce07b9aaa0892adb&amp;amp;token=1516544318&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;
</description>
               <pubDate>Tue, 17 Aug 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/08/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B040</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/08/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B040</guid>
            </item>
        
    </channel>
</rss>