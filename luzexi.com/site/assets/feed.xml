<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title></title>
        <description>漫漫人生,记录点滴技术,始于2013</description>
        <link>http://www.luzexi.com</link>
        <atom:link href="http://www.luzexi.com/assets/feed.xml" rel="self" type="application/rss+xml" />
        
            <item>
               <title>思路探讨(二十三) 997成就世界</title>
               <description>&lt;p&gt;实际上还是有人不知道996是什么的。996，每天早上9点上班，晚上9点下班，周6加班，一周工作6天。&lt;/p&gt;

&lt;p&gt;似乎所有人都很痛恨这种模式，当所有人都在喊996痛苦的时候。你，就不应该喊了，你是普通人吗，你不是的。普通人每天过着凑合的日子，每天上着凑合的班，做着凑合的工作，什么都凑合。加班对他们来说是种恶毒的迫害，是对他们劳动力的剥削，是对他们娱乐生活的不尊重，所以他们痛恨。他们认为资本家是万恶的，是拥有无限权利的，是可以掌控世界的，是可以无所不能的，所以他们拒绝资本家的‘迫害’。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;那么真的是他们想象的那样吗？是真的为了迫害，是真的为了剥削，是真的不尊重，是真的万恶，是真的拥有无限权利和无所不能，才996的吗？不是的。&lt;/p&gt;

&lt;p&gt;资本家也是人，有一天你也会成为资本家，其实你我都有可能是资本家。资本家是人，也会痛苦，也会被迫害，也会遭遇不幸，也同样受到压迫，只是他们穿的西服比我们贵，但这并不舒服，不如我们的睡袍和卫衣，吃的200块钱一餐的美食，同样有可能用的是地沟油，也不如我们的汉堡包、薯条、鸡块来的可口。&lt;/p&gt;

&lt;p&gt;世界真的是公平的，不会因为你钱多而让你的痛苦少一点，也不会因为你钱少而给你少一点的机会。&lt;/p&gt;

&lt;h3&gt;我不赞成996，但我心中不止996，成年人世界里辛苦点又算的了什么，为了生存，为了更好的生存，为了追求极致的生存，皮肉上痛苦在成年人的世界里已经是最轻量级的痛苦了。&lt;/h3&gt;

&lt;p&gt;普通人依赖环境，没有环境他们无法生存。普通人，任人摆布，他们无法自控只有听从于他人。普通人，委曲求全，没有突出的能力到哪都是求稳定，稳定就要牺牲自我牺牲尊严。普通人，听从命运，你愿意听从你那稀烂的命运吗？！&lt;/p&gt;

&lt;p&gt;世界是残酷的，也是公平的。残酷在，人人都要为生存而斗争，不是你死就是我活。公平在，只有勤奋努力好学的人才配的上成功，机会永远都是给那些积累很多年并且时时刻刻保持勤奋努力好学的人的。&lt;/p&gt;

&lt;p&gt;当面临淘汰时，也同样公平，也同样残酷，那些凑合的人最先被淘汰，然后那些普通人大部分被淘汰，留下的普通人只是幸运儿，下次还会这么幸运么，你死我活的斗争一直没有停歇。&lt;/p&gt;

&lt;h6&gt;996不能赢得世界，但997能(相当于全年无休)。为什么？&lt;/h6&gt;

&lt;p&gt;因为996给自己留了余地，说一周来每天这么辛苦最后一天让自己休息一下。实际上，只要停下来，启动就难了。给了一个停下来的理由，启动的理由却又要再次寻找了。难以维系。&lt;/p&gt;

&lt;p&gt;我们之间有聪明与不聪明的区别吗？没有，（不要以为自己比别人聪明，当这么认为的时候我们就已经输了一半了）。从整个人生来看，到死之前，我们比的都是谁能坚持到最后，比的是都是耐力，是毅力，是勇气。谁能勇敢的坚持到最后谁就能赢得世界，聪不聪明只是人的自以为是的幻想而已，持久战才是人生真正的赛点。&lt;/p&gt;

&lt;p&gt;那么‘坚持’真就这么容易吗？不是的。‘坚持‘超难，难到怀疑人生。&lt;/p&gt;

&lt;h6&gt;为什么997就能成就世界？因为全年无休让你不得不转变观念。&lt;/h6&gt;

&lt;h6&gt;当我们明白自己无法逃脱全年无休的状态时，我们已经彻底放弃了所有试图休息的谋划，转而关注如何提高专注力，如何用更少的精力做好当下的事情，如何加强体力，如何加强免疫力，以及如何平衡工作、学习和娱乐三者之间的关系。&lt;/h6&gt;

&lt;p&gt;我们训练了更多提高专注力的方法，从而提高了专注力，训练了更多做好事情的方法、知识和技巧，从而提高了效率，加强了每天的健身锻炼，从而让自己每天元气满满，免疫力爆棚，抵御外来病毒侵扰，让高效状态保持的更久更有力。&lt;/p&gt;

&lt;p&gt;我们开始主动关注了每天工作的时间，学习的时间，娱乐的时间，不断调整着三者的时间平衡，我们没有时间娱乐，但人又不能没有娱乐活动，所以我们只能在工作中学习，在学习中娱乐，在娱乐中工作，边工作边学习边娱乐，三者混为一体，工作即学习，学习即娱乐，娱乐为了更好的工作，保持平衡和高效，不断主动的调整，因为它们并不是一个固定时间比，每个人每个时间段每个环境下都不一样，需要主动及时调整。&lt;/p&gt;

&lt;h6&gt;997让我们做时间的朋友。&lt;/h6&gt;

&lt;p&gt;全年无休的情况下我们不得不做时间的朋友，只有让时间成为我们最重要的朋友，我们才能减轻无休的痛苦。做时间的朋友最大的好处便是复利，时间就是复利的要素，每天积累一点，一年下来你就比别人多跑一点，5年下来，你就比别人多跑好几个整圈，10年下来你就别人多跑好几个级别的比赛。&lt;/p&gt;

&lt;p&gt;每天都问下自己，今天和时间这个朋友合作的如何，今天有把时间好好分配吗，能对得起这位默默无闻支持你永不抛弃永不放弃你的朋友吗，如果有明天继续，如果没有明天继续努力。&lt;/p&gt;

&lt;h6&gt;997让我们转念，转念之间，997反而成就了我们，让时间成为了我们最好的朋友，让复利的积累引领我们走向了世界的巅峰。&lt;/h6&gt;
</description>
               <pubDate>Sat, 13 Apr 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/04/13/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A823.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/04/13/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A823.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第八章 AI(3) 非典型性AI</title>
               <description>&lt;p&gt;前面讲了状态机和行为树在AI中的运用，在实际开发过程中，特别是一些在游戏行业做过5-10年左右的很多人似乎似乎已经习惯了用这些固定的工具去写AI逻辑，一想到游戏AI就固定思维的认为，就用状态机去写，或者说就用行为树去写。&lt;/p&gt;

&lt;p&gt;思维跳不出这些‘工具’，我们就成不了大师。大师是什么，是能将‘剑’运用到最高境界的人，手里‘无剑’而心中有剑，是他们的至高境界。万事万物都是同一个道理，‘技术’就像剑术，在练习过程中，都会经过几个阶段，到底具体有哪些阶段每个人都不一样，我能确定的是，‘识剑’是第一个阶段，认识剑是怎么样的，或者说认识‘技术’是个怎样的东西用在哪里。而‘用剑’是另一个阶段，如何用剑或者说如何运用这项‘技术’是大多数人停留的阶段，怎么用剑怎么用好剑，是一个非常漫长而枯燥的阶段。‘无剑’就是最后一个阶段，手里没有剑而心中有剑在剑术的造诣上达到了至高的境界，无剑胜有剑在这个阶段体现的淋漓尽致。&lt;/p&gt;

&lt;p&gt;我们接触的面要尽量的广，接受和包容的东西要尽量的多，才能体验到更多的东西。游戏开发也是，世界上不是只有RPG角色扮演类一种游戏类型，还有SLG策略类游戏，还有休闲娱乐类游戏，还有体育竞技类游戏，还有学习教育类游戏等等等。只有状态机，只有行为树，或者只有状态机和行为树是无法为项目开发出最好最适合的AI的。我们应该尽量包容非典型性AI。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;下面我们来了解下游戏项目中非典型性的AI。&lt;/p&gt;

&lt;h3&gt;1，庄家式AI&lt;/h3&gt;

&lt;p&gt;顾名思义，是庄家统治游戏的一种玩法，玩法中AI就是全局的统治者，它决定了整个游戏的高潮和低谷，AI如何操作成为了至关重要的关键点，玩家是否喜欢这款游戏很大程度上取决于AI的策略。&lt;/p&gt;

&lt;p&gt;这种类型游戏大部分以彩票或赌局的形式存在，比如老虎机，百家乐，21点，以及部分以彩票为形式的游戏。&lt;/p&gt;

&lt;p&gt;AI策略的目的是要让玩家玩的好又不能赢太多而且最终是要输给AI的。玩家喜欢继续玩但从总体上来看却又是输的，让庄家就是游戏运行商有的赚，但又不能太狠，让游戏细水长流。&lt;/p&gt;

&lt;p&gt;这种AI常以输赢的概率为基本控制手段，比如现阶段以玩家欢乐为主，那么胜的概率变得大一点，玩家会认为幸运女神眷顾他了，一段时间后为了让玩家遇到点困难，让玩家有挑战性，这时AI慢慢降低了赢的概率，玩家缓慢觉得赢的次数开始减少，有些玩家会以为幸运女神走了，需要靠自己的‘本事’玩下去了，他们不断得发现和寻找输赢的规律，以及出牌和翻牌的概率，直到输得所剩无几，然后AI开始了缓慢提高胜率的操作，让玩家又看到了希望，找到了自信，认为自己终于不费苦心找到了规律和破解的秘密，于是又开始了一轮有输有赢但赢多输少的旅程。&lt;/p&gt;

&lt;p&gt;如此这般不断得循环往复，AI以一种庄家的形式控制着整个游戏过程。&lt;/p&gt;

&lt;h6&gt;从技术上来看，这种控制概率的过程，就是加法和减法的过程，相对比较简单。其核心是给出一个概率后，如何让它真的起到概率的作用，而且这种概率能让人很舒适的接受，比如当有30%概率赢时能否做到真正的随机值在30%的概率上徘徊，比如10局中有2-4局能中玩家可以得到想要的那个点位或者想要的牌什么的，而不是10局中0-5局能赢，输赢实际结果波动到了不好的体验。&lt;/h6&gt;

&lt;h3&gt;2，可演算式AI&lt;/h3&gt;

&lt;p&gt;可演算式的AI在策略类游戏中非常常见，在页游里的大部分的自动对战，以及现在卡牌手游中的大部分自动战斗都是可演算式的AI，是可以根据两边的阵容数据和一个随机种子来演算出整场战斗的每个细节的。例如，两个军队的各5个英雄，互相间攻击并释放技能，服务器需要在一瞬间把所有需要在客户端演示的内容都计算出来，并以数据的形式发送给客户端，客户端根据演算的数据进行展示人物的动作，位移，技能释放等，客户端并不需要计算任何内容，所有内容都在服务器里已经计算好了，以数据形式代表了整个过程。&lt;/p&gt;

&lt;h6&gt;可演算式AI的特点是逻辑一定是确定性的，不能是模糊的，或者会随机改变的，或者随时间变化而变化的结果，同样的数据第一次计算和多次计算的结果必须是相同的，才能最终体现出可演算的这个特征。&lt;/h6&gt;

&lt;p&gt;其次，可演算式AI大都是根据时间轴来演化游戏的进程，在那里‘时间轴’的概念在可演算式AI中是比较常见的。&lt;/p&gt;

&lt;p&gt;什么是时间轴演算路径？我们用卡牌对战算法来举几个例子。&lt;/p&gt;

&lt;p&gt;首先最简单的时间轴演算路径，例如，先由敏捷度最高的英雄进攻，等待英雄进攻完毕后再由其次高敏捷度的英雄进攻，依次进行下去直到所有的英雄进攻完毕再重新一轮进攻。这种相对比较简单，可以把进攻看成一轮一轮的回合，每个回合都相当于是一次for循环，每次for循环前先对敏捷度进行排序，再在for循环中依次计算进攻了谁受到了多少伤害，以及是否死亡。最后把进攻的数据和伤害的数据用队列的形式存储在数据中发送给客户端，客户端受到数据后再进行演示。&lt;/p&gt;

&lt;p&gt;稍微复杂点的时间轴逻辑，例如，不再由敏捷度来决定进攻的先后次序了，而是由每个英雄的进攻间隔冷却时间来决定进攻次序，对战开始时开始计算每个英雄的进攻冷却时间是否结束，谁的冷却时间先结束谁就最先得到进攻权，进攻完毕后再等待下一个英雄的冷却时间，以此类推。从技术上讲，冷却时间不需要等待，把所有英雄加入一个队列，排序一下就可以得到谁的剩余冷却时间最短，就立马可以开始计算进攻细节，完毕后根据冷却时间插入到队列中去，任然还是一个有序的剩余冷却时间队列，一直这样计算下去直到演算结束一方胜利或失败。这种演算方式就有了更多了时间轴的概念。&lt;/p&gt;

&lt;p&gt;再稍微复杂点，前面所说的进攻逻辑都是在其他英雄都停止的状态下进行的，现在进攻时不再需要其他英雄等待了，一旦冷却时间结束就可以立刻进攻。也就是说，每个英雄都可以在其他英雄还在进攻时进行进攻操作，只要他的冷却时间到位，并且他的进攻时需要花费固定时间的，等到进攻完毕后再判断对方和自己是否死亡。这种方式，不只是多了一个进攻消耗时间这么简单，还多了一个死亡判断时间，在还没有死亡判定前，此英雄虽然是死了但任然可以被进攻。从技术上来看，计算的量从单一的剩余时间量排序，增加了进攻消耗时间排序插入，以及死亡判定排序，我们既要在冷却时间结束时计算进攻，还要在选择进攻对象时计算该英雄是否已经判定死亡，最后在进攻完毕后计算当前的时间并插入到排序队列中。&lt;/p&gt;

&lt;p&gt;再复杂点，英雄在进攻一半时可以被别的英雄打死，也可以被其他英雄的技能打断，也包括了随时被回复血量蓝量，增加状态等等，让战斗更加逼真、更具有实时性。加强了实时性的要求，更加考验可演算式AI的复杂度，由于太多的需要计算的时间内容，所以我们必须有一个能有效管理时间轴的方法。从技术上来看，我们必须定义‘时间节点’这个概念了。&lt;/p&gt;

&lt;h6&gt;什么是‘时间节点’？‘时间节点’就是一个事件在整个过程的时间轴上的发生时的位置。&lt;/h6&gt;

&lt;p&gt;有了时间节点这个概念，我们可以用时间节点为计算标准，把所有人物的下一个事件的时间节点计算出来，比如，移动到达敌方位置，又比如，释放技能，又比如，回到原地，又比如，冷却时间结束，每个人只计算最近的一个时间节点，并把计算出来的结果放进队列中，然后就可以找出时间节点里离我们最近的一次事件的发生节点，也就是时间差最少的节点，执行它。&lt;/p&gt;

&lt;p&gt;由于每个时间点都有可能引起其他时间点的变化，比如把对方打死了，对方的时间节点就消失了，又比如打断了别人技能释放，对方就回到了冷却时间，时间节点就需要重新计算了，又比如加速了友军的攻击速度，因此所有友军正在攻击或打算攻击的时间节点都要重新计算了，等等等等。&lt;/p&gt;

&lt;p&gt;所以每次在执行完一个时间节点后，都要对有可能产生变化的人物的时间节点进行重新计算，并加入队列，然后就可以找出离我们最近的一个时间节点了，当然旧的时间节点数据必须清除掉。&lt;/p&gt;

&lt;p&gt;如此往复的重复这个计算过程，直到没有任何时间节点可计算和执行，最终决出这张战斗的胜利或失败。&lt;/p&gt;

&lt;h6&gt;时间轴贯穿了整个AI过程，人物之间的打斗，移动，释放法术，冷却时间等待，AI每次只计算一个时间节点，因为只有最近的那个时间节点是一定不会被其他节点影响的，这样既照顾到了可演算的根本原则，也照顾到了游戏的实时性，让战斗更加精彩。然后把每个计算的结果都记录下来，就可以在客户端进行演示了，整个过程的事件发生的时间都将准确无误呈现出来。&lt;/h6&gt;

&lt;h3&gt;3，博弈式AI&lt;/h3&gt;

&lt;p&gt;游戏项目中大部分AI的目的都是以娱乐玩家为主，并没有要真正打败玩家，最多也是要与玩家达到一种平衡。而博弈式AI则不同，它的目标就是为了打败玩家，它是为了赢得比赛而生的。&lt;/p&gt;

&lt;h6&gt;博弈AI最大的特点是搜索。通过搜索，将所有下一步可能发生的，以及下几步可能发生的事情都记录在内存中，以此来确定电脑该怎么进行下一步动作，进而获得最大的效益。&lt;/h6&gt;

&lt;p&gt;有的人不理解为什么是搜索，这里稍微做下解释。在AI选择下一步的动作前，下一步要发生的情况有很多，我们需要选择最佳的那个，怎么选择呢？把所有下一步的情况都列出来，再把下一步的后几步的情况也列在下一步的下面，由于cpu计算量的限制后面的几十几百步计算量太大以至于无法计算，假设我们只计算和预测十步的结果，我们需要找到第十步的最好结果，再反推到第一步来确定第一步到第十步是怎么走的。&lt;/p&gt;

&lt;p&gt;把这十步的所有结果都计算出来太耗时CPU负重太大，有些甚至无法承受这样大的计算量，那么我们就要在没有结果的情况下得到最佳选择，怎么做呢？既然我们要从第一步走到第十步，假设第一步有10种情况，第十步有10种情况，每一步之间都有一个结果就相当于一点到另一个点的路径一样，从第一步到第十步就可以视为路径的一种，那么从第一个点到第十个点的最短路径，就是第一步到第十步的最佳结果。把视角一转换后发现事情变得的简单了，用最短路径算法就可以解决搜索问题。&lt;/p&gt;

&lt;p&gt;不过事情远没有这么简单，这里只是举了个简单的例子，情况会复杂到每一步有几百种情况，普通的搜索方式计算机可能完全无法承受。为了能让计算机承受这样大的计算量，我们就需要引入更多的枝剪和优化，比如，存储一些固定技巧，以及拒绝计算一些明显比较差的选择。&lt;/p&gt;

&lt;h6&gt;另一个特点是AI对局势的估值该如何认定。估值表示了当前局势的好坏程度，通常用一个0到100的浮点数来表示估值，估值的好坏是AI一个比较关键的点，只有正确的计算出局势的估值，AI才能知道选择的行动方向是正确的还是错误的。&lt;/h6&gt;

&lt;p&gt;拿最简单的五子棋来说。棋盘上的每一个点都是对手下一步的可能性，通常不会在空白处下一个完全不着边的棋，所以搜索范围缩减到了当前棋盘上有棋子的范围周围的空位。AI对所有这些空位录入并计算当AI把棋子放入该位置上后，对方可能做出的反应以及由此引发的后几步的对弈可能。我们假设AI只搜索和计算后5步的预测，也就是说，计算出来的当前落子的估值，就是所有棋盘中可落子的后5步内最优估值。&lt;/p&gt;

&lt;h6&gt;最后一个特点是数据录入。人类的手法太过高明，欺骗性很强，很容易就能躲过AI的盲点，所以录入特别的人类的想法的是博弈AI的一大关键点。没有数据的录入，AI很难知道人类的想法。&lt;/h6&gt;

&lt;p&gt;96年97年的人机国际象棋大战就是录入了大量的棋局来告诉AI人类的一些固定走法，让AI在对弈中识别人类的套路。&lt;/p&gt;

&lt;p&gt;以前的数据是一些人手动录入的，所以局限性还是很大，不能应付现代这么快更新换代的技巧和想法。为了做出更强大的博弈式AI，我们不得开始让AI拥有自学的能力，所以机器学习，深度学习得到了广泛的关注和应用。它们原理就是数据录入，加，估值判定，给AI不断地喂数据的同时，告诉AI这个数据是对的还是错的，或者说估值能达到多少，通过不断的喂数据（也相当于用数据训练AI）的方式，让AI拥有丰富的‘经验’，从而在对弈中赢得比赛。&lt;/p&gt;
</description>
               <pubDate>Sun, 07 Apr 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/04/07/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-AI3.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/04/07/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-AI3.html</guid>
            </item>
        
            <item>
               <title>思路探讨(二十二) 人为什么做不出最正确的选择</title>
               <description>&lt;p&gt;人这一生真的能在每个节点都做出最好的决策吗，肯定不能。这个比较理想化的美梦，大多数人都知道是不可能的。&lt;/p&gt;

&lt;p&gt;但人真的能在模棱两可的分岔路面前做出最正确的决策吗？我认为是不可能的。（需要明确一点是，模棱两可的选择是指两种或者几种选择都是朝着光明的方向去的，而不是一黑一白或者两种都是黑。）&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;为什么做不出最正确的选择？&lt;/p&gt;

&lt;p&gt;因为最好的决策通常都是事后分析才会知道，在当下是无法知道事情到底会如何发展，只有当事情变成了历史，我们再回过头来看这件事时才能真正找到最好的决策方向。&lt;/p&gt;

&lt;p&gt;比如，何时买股票，何时卖股票，何时买房，何时卖房，选择什么专业，该不该和这个人结婚，该不该下海去创业，该不该选择这个人合作，该不该送孩子出国，该报考哪所学校，以及该不该跳槽，应该去哪座城市工作和生活等等等。所有这些都会等你做出决策，并执行多年后，再回过头来梳理时，才能真正明白到底我做对了还是错了。&lt;/p&gt;

&lt;p&gt;为什么是要等事情成为了历史才能知道当时该如何决策，我就不能直接洞悉事情的发展方向做出相应的决策？&lt;/p&gt;

&lt;p&gt;不能。因为世界是变化的。&lt;/p&gt;

&lt;p&gt;我们所处的这个世界里每分每秒都在变化，在这个变化的世界里，我们永远无法知道事情会如何发展，永远无法知道别人到底怎么想（你以为你聪明到能知道所有人的想法时就已经代表你错了），他们到底会怎么做，有多少人会这么想并有多少人会那样做，这所有与之有关的人的行为会给这样事情产生多少影响，又有多少人会因为别人的行为而改变自己的行为方式，你认为就凭你聪明的脑袋能计算的过来么，不可能。&lt;/p&gt;

&lt;p&gt;更何况还有那些与事情有关联的人的关联人，以及与之相关联事情的事情，太多太多，甚至我们都无法知道究竟有多少与之相关联的事情在同时发生，何况在同一时刻这所有关联的人和事都在不断得产生着变化。&lt;/p&gt;

&lt;h6&gt;我们不得不敬畏这个世界，我们永远无法估量，到底有多少事情在影响着我们当下关心的这件事情。&lt;/h6&gt;

&lt;h6&gt;在这个变化的世界里，想做出最正确的选择，是不太可能的，正确的选择只有在回顾历史时才存在。而我们只能就自己的理解做出自己认为最正确的选择。&lt;/h6&gt;

&lt;p&gt;那么做出一个正确的选择真的那么重要吗？不是的。为什么？&lt;/p&gt;

&lt;p&gt;我们退一步说，即使从历史的角度看我们做出了正确的选择，就一定能成功吗？不是。&lt;/p&gt;

&lt;p&gt;首先，即使我们很幸运做出的选择，从历史角度看是最正确的选择，我们也不一定能执行到位。&lt;/p&gt;

&lt;p&gt;实际上，大部分时候连我们自己都不太相信自己做出的决策是对是错，总是在摇摆不定，虽然在表面上坚定的支持这种选择，但在心里还是持有一定的怀疑的态度。这种怀疑的态度，导致我们无法完全百分百的执行我们做出的决策。&lt;/p&gt;

&lt;p&gt;知行合一的难度就在这里，我们到底相信多少我们所知道的。由于人类思维的灵活性以及人性的弱点，我们很难百分百相信我们所知道的一切，永远都在怀疑是否有更好的我们所不知道的存在，所以很难做到相信即行动。&lt;/p&gt;

&lt;p&gt;其次，即使我们很幸运做出了正确的选择，并且很坚决的执行了决策，但成功并不是一个决策而导致的结果，而是由几百几千个决策共同组成的决策群，和，所有为之努力的执行方式的集合组合而成的结果。&lt;/p&gt;

&lt;p&gt;成功的难度就在这里，一个决策并不能决定一个人或一件事的成功与否，成功是由一群决策方向和一群行动方向组合而成，并经过多年累月得到的最终结果。&lt;/p&gt;

&lt;h6&gt;抢到门票就能赢吗？不是的，门票只是一个赛跑的起步优势点并不能决定整场比赛的输赢，别忘了拼命抢到的门票也有可能是一场灾难的开始。&lt;/h6&gt;

&lt;h6&gt;做出‘一个’正确的选择并没有那么重要。重要的是做出选择后的所有其他的选择，以及接下来的所有行动。我们共勉。&lt;/h6&gt;
</description>
               <pubDate>Sun, 31 Mar 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/03/31/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A822.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/03/31/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A822.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第八章 AI(2)-用行为树构建AI</title>
               <description>&lt;p&gt;前面讲了用状态机来构建游戏中的怪物AI，由于它易于理解，容易被人类接受，扩展性和耦合性都很好，所以状态机的用途很广泛。但是状态机也有很大的缺点，就是不能处理和模仿太复杂的智能行为，比如模拟一个人类奔赴一场大型战役中，对战场中的各种繁多的突发事件做出符合人类模式的处理，这种方式状态机就无能为力，由于突发情况太多，组合起来的突发情况更多，做出反应的方式也变化多端，用人类思维逻辑去编写每个状态，状态的数量就会如指数级攀升无法应付，说的直白点就是人类大脑无法应付这么复杂的逻辑编写。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;行为树很好的弥补了状态机的缺点，它简化了逻辑拼凑的方式，让简单头脑的人类能更容易编写和控制机器人的智能行为。这其实也是AI架构的关键点，能够让简单头脑的人类制作复杂的人工智能的行为方式，化繁为简。&lt;/p&gt;

&lt;p&gt;化繁为简是我们的重点，人工智能的行为方式，都是由人类头脑指定的行为方式，是人类头脑所预期的，而非不可控的。制作出人类所预期的AI行为逻辑，制作的方式和过程又在人类大脑的承受范围内的，才是我们需要的。状态机的方式制作AI理论上可以实现任何AI，但复杂到一定程度人脑无法承受，其实就是无效的，或者说失败的。&lt;/p&gt;

&lt;p&gt;行为树的优势就在这里，能够通过一些简单的人类能够应付的操作，制作出达到人类所预期的足够复杂的机器人行为方式。&lt;/p&gt;

&lt;p&gt;下面我们来详细介绍行为树的组成。&lt;/p&gt;

&lt;p&gt;行为树(Behavior Tree)具有如下的特性：&lt;/p&gt;

&lt;p&gt;它有4大类型的N节点：&lt;/p&gt;

&lt;h6&gt;1，Composite Node 复合节点&lt;/h6&gt;

&lt;p&gt;复合节点可详细的分为3种：&lt;/p&gt;

&lt;p&gt;一种是Selector Node，选择节点。当执行本类型节点时，它将从头到尾迭代执行自己的子节点，如果遇到一个子节点执行后返回True则停止迭代，本Node向自己的上层的父节点也返回True，否则所有子节点都返回False，那么本Node向自己的父节点返回False。&lt;/p&gt;

&lt;p&gt;一种是Sequence Node，顺序节点。当执行本类型Node时，它将从头到尾依次迭代执行自己的子节点，如遇到一个Child Node 子节点执行后返回False，那停止迭代，本Node向自己的Parent Node父节点也返回False；否则所有Child Node都返回True，那本Node向自己的Parent Node返回True。&lt;/p&gt;

&lt;p&gt;还有一种是Parallel Node，并发节点，并发执行它的所有Child Node子节点。&lt;/p&gt;

&lt;p&gt;向Parent Node父节点返回的值和Parallel Node所采取的具体策略相关：&lt;/p&gt;

&lt;p&gt;Parallel Selector Node: 执行完所有子节点，有一个False则返回False，全True才返回True。&lt;/p&gt;

&lt;p&gt;Parallel Sequence Node: 执行完所有子节点，有一个True则返回True，全False才返回False。&lt;/p&gt;

&lt;p&gt;Parallel Hybird Node: 执行完所有子节点，指定数量的Child Node返回True或False后才决定结果。&lt;/p&gt;

&lt;p&gt;并行节点提供了并发性，由于它可以在线程或协程级别提供并发操作，所以在性能上面有能够充分利用CPU提高性能。&lt;/p&gt;

&lt;p&gt;通常情况下，Parallel Node下会并行挂多个Action子树，或者挂多个Condition Node以提供实时性。&lt;/p&gt;

&lt;p&gt;Parallel Node增加性能和方便性的同时，也增加实现和维护复杂度。&lt;/p&gt;

&lt;p&gt;除此以外为了进一步提高AI的复杂度和随机性，Selector 和 Sequence可以进一步提供非线性迭代的加权随机变种。比如，Weight Random Selector，每次执行不同的起点，提供了每次执行不同的First True Child Node的可能。而Weight Random Sequence则每次执行顺序不同，提供了不同的迭代顺序的方式。这在AI术语中称为partial-order，能使AI避免总出现可预期的结果，让结果更加的随机化。&lt;/p&gt;

&lt;h6&gt;2，Decorator Node 修饰节点&lt;/h6&gt;

&lt;p&gt;Decorator Node，它的功能正如它的字面意思：它将它的Child Node执行后返回的结果值做额外修饰处理后，再返回给它的Parent Node。比如反向修饰Decorator Not：将结果反置后返回上级处理，失败修饰Decorator FailUtil：将失败修改后返回上级处理，计数修饰Decorator Counter：将结果计数后返回上级处理，时间修饰Decorator Time：将时间修改后返回上级处理。也可以作为日志处理Decorator Log，动画修饰处理Decorator Animation，甚至Decorator Nothing什么都不干。&lt;/p&gt;

&lt;h6&gt;3，Condition Node 条件节点&lt;/h6&gt;

&lt;p&gt;Condition Node相对比较简单，条件满足则返回Ture，否则返回False。&lt;/p&gt;

&lt;p&gt;各式各样的条件节点，都继承基础条件节点并且返回Ture或False。&lt;/p&gt;

&lt;p&gt;比较常用的条件节点例如，血量判断条件，距离判断条件，状态判断条件，时间间隔判断条件等。&lt;/p&gt;

&lt;h6&gt;4，Action Node 行动节点&lt;/h6&gt;

&lt;p&gt;Action Node，通常都是最后的叶子节点，它完成具体的一次(或一个step)的行为，视需求返回值。&lt;/p&gt;

&lt;p&gt;Action Node可以是执行一次的，也可以视为分步执行很多次的行为。例如，向前进这个行为，可以一直被执行，直到条件不满足。&lt;/p&gt;

&lt;p&gt;也就是说，通过扩展Action Node完全可以不需要借助外在程序或接口，自主定义角色行为。&lt;/p&gt;

&lt;p&gt;常用的Action Node节点的例如，行走到目标地点Action，跟踪目标Action，转换角色方向Action，撤退Action，攻击Action，防御Action，释放技能Action等等。&lt;/p&gt;

&lt;h6&gt;在行为树中任何Node被执行后，必须向其上层的父节点报告执行结果：成功True或失败False。这简单的成功或失败汇报原则被很巧妙地用于控制整棵树的决策方向。&lt;/h6&gt;

&lt;p&gt;行为树能够支撑起对复杂逻辑的AI的原因就是由于使用了这些简单的节点去搭建整个AI模型。由于人脑可以很容易的写出这些简单的单个节点的逻辑，使得节点的功能性扩展变得非常容易，而拼装这些节点，就像是一个搭积木的过程，人脑能搭建多复杂的积木，就能搭建起多复杂的AI。&lt;/p&gt;

&lt;p&gt;整棵行为树中，只有Condition Node和Action Node才能成为Leaf Node叶子节点，而也只有Leaf Node才是需要特别定制的Node。而Composite Node和Decorator Node均用于控制行为树中的决策走向。所以有些资料中也统称Condition Node和Action Node为Behavior Node行为节点，而Composite Node和Decorator Node为Decider Node决策节点。&lt;/p&gt;

&lt;p&gt;在行为树之前，还有决策树这个被遗忘了的AI解决方案。决策树和行为树一样都是树形结构，都是由节点构成。决策的构成是由树形结构的头部开始，从上往下一路判断该往哪走，最后一定会执行到叶子节点，在决策树中只有叶子节点才决定了如何行动，而且在决定后的行动中，无法中途退出，要等到档次行为执行完毕或者被打断后才能开始下一次决策。&lt;/p&gt;

&lt;p&gt;从理念上讲，决策树就是为了制定决策，而行为树是为了控制行为，是两个不同的理念，行为树更加注重变化，而决策树则注重选择。因此行为树可以定制比决策树更加复杂的AI逻辑，而实现的难易程度行为树并没有增加多少，所以决策树被冷落也是情理之中。&lt;/p&gt;

&lt;h6&gt;行为树比状态机更容易编写复杂的AI逻辑就是由于单一节点的易扩展性，以及整个AI树的可搭建能力都是在人脑的可及范围内。但是，再厉害的人脑也有搭建复杂度的极限，无论你对搭建行为树这项技能有多么精通，都有到一个极限的状态，也就是搭建的复杂度超出人类大脑的时候，人类就完全无法继续搭建了，或者说无法完成。例如，如果想完全模拟人类的思维判断逻辑，对不同的人，对不同的事，对不同的景色，对不同的物体，不同的路面，以及以上混合组合的不同组合，就完全超出了人类大脑搭建的极限。像这种特别复杂，完全不能由人类大脑自主搭建的方式形成的AI，就需要引入‘机器学习’这个概念了。由于情况太多，太复杂，唯有‘机器自主学习’才能适应这些复杂的情况时，‘Machine learning机器学习’，‘Deep learning深度学习’，‘Artificial Neural Network神经网络’，就成了解决这些问题的方案。&lt;/h6&gt;

&lt;p&gt;参考:&lt;/p&gt;

&lt;p&gt;《使用行为树(Behavior Tree)实现游戏AI》by AKara 2010&lt;/p&gt;
</description>
               <pubDate>Thu, 28 Mar 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/03/28/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-AI2.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/03/28/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-AI2.html</guid>
            </item>
        
            <item>
               <title>思路探讨(二十一) 生存之战</title>
               <description>&lt;p&gt;22周岁毕业，在杭州工作了4年，26岁带着不甘心独自去了上海，27岁结了婚，28岁有了第一个孩子，29岁第二个孩子降临，今年要32周岁了。从毕业到现在过去了10个年头，有时偶尔回头望去觉得是精彩的，不过精彩的并不是结果，而是这10年里拼搏的过程，那种奋力前行用尽全力突破自我的精神和逆流而上明知山有虎偏向虎山行的勇气。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;这种勇气和精神，来自于我的内心，不甘心成为一个平庸的人的意识形态，我不愿意自己每天妥协过着看不到尽头的无奈日子，我希望自己改变自己，改变成为自己心中的那个非常强大的人。&lt;/p&gt;

&lt;h6&gt;还没有孩子前我只为我自己奋斗，那时我觉得这样的动力已经很足够了，但我还是too young too naive，在有了孩子后，特别是有第二个孩子之后，我彻底清醒的认识到我过去的行动和能力都是小儿科级别的。&lt;/h6&gt;

&lt;p&gt;特别是最近我读了《富兰克林自传》、《居里夫人自传》、《稻盛和夫自传》、《韩信传》、《林肯传》这些名人传记后，生存的严肃性再次深刻的、深切的、深不见底的印在我记忆的肌肉里。&lt;/p&gt;

&lt;h6&gt;他们都是严肃生活的典范，他们专心，专业，努力，奋力，认真得经营着自己，包括身体、知识、思想、家庭。他们并不埋怨环境，而是改变自己，他们知识环境无法改变，只有改变自己。因此在恶劣的环境下他们任然保持自己前进的节奏，虽然偶尔被环境所打断，甚至被迫害，但他们依然能够不断调整自己回到最初的状态，尽管时常也陷入巨大的瓶颈，但多大的苦难和瓶颈都没能挡得住他们突破自己的步伐。&lt;/h6&gt;

&lt;p&gt;对比我自己，我还是太稚嫩，严肃的不够严肃，认真得不够认真，对生活没有一个清醒的彻底的完全的认识，时常有’休息一下也没事‘、’一天不努力也可以‘、’明天再学也不迟‘的行为和想法，导致原本制定的计划，或者良好的生活习惯，或者良好的学习习惯被一点点侵蚀，最终导致自律能力彻底丧失，彻底沦为浪费时间浪费生命的大懒虫。&lt;/p&gt;

&lt;p&gt;我再次回忆我这年轻的岁月里，浪费了有多少的时日时，时常感叹如果我能早点知道该有多好。&lt;/p&gt;

&lt;h6&gt;每次有这种’早点知道该有多好‘的感叹时，我知道为时还不晚，因为有很多智者提醒过我，任何时候只要你意识到正确的道路在个方向时都不晚。虽然这些智者我都没见过，他们存在于书中，电视中，视频中，但却时常能够起到提醒我的作用。&lt;/h6&gt;

&lt;p&gt;正确的道路确实难走，所以人才会跟随人性弱点去选择舒适的但错误的道路。&lt;/p&gt;

&lt;h6&gt;生存之战就是谁能长时间的、长期的、长久的、更长时间的、更长期的、更长久的走在正确道路上的无形的战争。&lt;/h6&gt;

&lt;p&gt;每个人在战争中都走的是自己的路并平行于他人，从来都不跟别人碰撞，但每一步都有好有坏，而每个步都有他们自己来决策。&lt;/p&gt;

&lt;p&gt;让人感到意外又不十分惊奇的是，很多人并不知道他们已经决策了自己的路，他们甚至以为生活的决策是有个缓冲期的，会给到具体的问题和正确的答案。&lt;/p&gt;

&lt;h6&gt;生存之战的残酷性就在这里，它的决策之路很少有具体的标志性的事件或者缓冲期，甚至连问题和答案都没有，所有的人生道路的决策都是由生活中的一言一行，一举一动拼凑而成的。&lt;/h6&gt;

&lt;p&gt;你是怎么生活的，你就是怎么决策着你的道路，容不得我们半点侥幸。根本不会出现，例如有个决策能一下子完全彻底的改变你的人生道路的东西出来，所有你走出来的道路都是由你生活的点滴组合而成，所有导致事件发生的都是由你先前的生活中一举一动的决策积累导致的量变引起的质变。&lt;/p&gt;

&lt;p&gt;人们口中时常说的残酷是由于人多或者需求多而供应少导致的，我觉得生存之战的残酷比它这种残酷要残酷一百倍。&lt;/p&gt;

&lt;p&gt;生存之战的残酷是没有硝烟的，是看不见摸不着的，但却时时刻刻在战斗，更残酷的是，并不是战斗一年两年就结束的，而是10年，20年，30年，40年，50年，一辈子。直接说一辈子太突兀，所以用前面的数字来做铺垫会让人好受些。&lt;/p&gt;

&lt;p&gt;一辈子持久战的残酷性，我想是我们这个和平年代下最最残酷的残酷战争了吧。&lt;/p&gt;

&lt;h6&gt;提高警惕并且奋斗，这是场最长的持久战，记得身体是第一关键因素哦，谁在持久战中身体先垮掉谁就第一个败下阵，每天运动保持身体免疫系统正常工作是第一要素。有了身体还不够，还要有知识、技能、思维方式、育人技巧、沟通能力、经验等等等，等着我们去征服它们。&lt;/h6&gt;

&lt;h6&gt;别放弃，别太多沮丧，哭完了我们继续上！&lt;/h6&gt;
</description>
               <pubDate>Sun, 17 Mar 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/03/17/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A821.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/03/17/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A821.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第八章 AI(1)-状态机构架机器人行为</title>
               <description>&lt;p&gt;AI机器人在游戏中非常普遍，它们常以模仿人类的行为在游戏中活动。游戏中的怪物的自动行为比较普遍，这种简单的人工智能方式可以用几种不同的方式进行编写，这里我们介绍两种方式，一种为容易被人类思维接受的状态机AI编程，另一种为特别为机器人思考方式编写的行为树AI编程。其实还有很多方式来编写AI，比如和行为树差不多的决策树，以及相对比较复杂的神经网络，以及更复杂的机器学习，在此不多做介绍，由于过于复杂甚至超过了项目的周期，研发和维护成本太高，所以在游戏中的应用并不太多，很少有人尝试。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h3&gt;AI-状态机&lt;/h3&gt;

&lt;p&gt;状态机虽然是个比较简单的概念，但在实际编程中花样也是繁多的，不过最终都是围绕着状态这个基础变量来做变化的。&lt;/p&gt;

&lt;p&gt;状态机最符合人类思考的方式，我们喜欢把事物以状态形式进行拆分成：当前状态，前置状态，下一个状态，状态变化需要的条件等。其中每个状态都有自己定义，比如行走，蹲下，躺下，攻击，防守，三连击，俯冲，左移，右移等。&lt;/p&gt;

&lt;p&gt;人们习惯把人或动物的某些连贯的行为定义为状态，所以状态其实不只是一个动作，它可以是好几个动作，或者好几段位移，也就是好几段执行程序。&lt;/p&gt;

&lt;p&gt;这种好几个动作和好几段位移一起组成的组合，在程序中用状态来表示最符合逻辑。每种状态下不只是一个动作或一种位移，而是由很多个动作多段位移组合而成。&lt;/p&gt;

&lt;p&gt;在游戏里，智能的机器人由于都是人设计出来的，行为方式也最符合人类的逻辑，所以状态机的方式制作AI最符合人类思维，也最容易被接受。&lt;/p&gt;

&lt;p&gt;从面向程序的角度来看，状态可以从父类构建开始，并且向不同的方向继承并衍生，最终再把所有的状态类集中到控制状态的状态控制器中。&lt;/p&gt;

&lt;p&gt;下面我们就以图和文的方式构建一个 AI 状态机：&lt;/p&gt;

&lt;p&gt;我们以 AIStateBase 为状态基础类，基础类中有一个识别状态类的变量，可以是整数，也可以是枚举，和三个必要的接口，更新函数 Update() ，进入状态事件引发的事件函数 OnEnter()，退出状态事件引发的事件函数 OnExit()。这三个函数足以概括状态的出、入、以及自我循环更新三个动作，状态机定义下也只有这三个动作可以做。&lt;/p&gt;

&lt;p&gt;接下来，我们开始扩展状态机的功能，以跑步动作状态为例：&lt;/p&gt;

&lt;p&gt;在进入跑步动作状态时，表现为，机器人有跑步动画，并且向前移动。&lt;/p&gt;

&lt;p&gt;实现跑步状态，首先继承父类 AIStateBase 并且把跑步状态类命名为 AIRunState。然后再对 AIRunState 进行编写，在进入状态时也就是 OnEnter 函数中编写机器人播放跑步的动画并让动画不断循环播放，然后在更新函数 Update 中开启不断向前移动的位置变化。当不再需要移动时，也就是退出跑步状态事件中，OnExit 里调用停止播放动画，也可以不停止播放，因为下一个状态肯定会播放其他动画，不如让他们插值过度下动画看起来会更顺滑。&lt;/p&gt;

&lt;p&gt;实现了跑步状态，可以引申出其他和它基本相同的状态，它们可以完全按照跑步状态的方式实现，比如后退，侧移，漫步，打坐，跳跃，攻击等，它们都是只用到播放自身动画和持续位移组合的方式完成状态。对其他复杂状态来说，算是比较基本的状态。&lt;/p&gt;

&lt;p&gt;现在我们来实现稍微复杂点的状态‘追击’状态。追击中有两个动作，一个是追，一个是攻击，不止是这些，我们还必须首先锁定目标，然后寻找追击的路径。当怪物进入‘追击’状态时，会锁定目标，然后不断向目标跑去，当跑到攻击范围内时，进行攻击。&lt;/p&gt;

&lt;p&gt;我们定义一个‘追击’状态类，AIAttackState 类同样继承 AIStateBase。当‘追击’状态开始时，进入 OnEnter 函数时先锁定目标，把目标保存下来，并且寻找追击目标的路径 Path Find，寻路解决方案会在地图与寻路章节中详细介绍。接下来就是‘追击状态’的更新函数，每帧都会调用更新函数 Update，在Update中，检查目标是否已在攻击范围内，如果是则立刻播放攻击动画，并且调用目标的伤害接口使目标受伤，如果不在范围内则检查锁定目标是否移动，如果有移动就重新寻找路径，并且根据路径来进行位移。整个追击状态，在追击中都是在 Update 函数中不断判断和位移的。&lt;/p&gt;

&lt;p&gt;追击状态以追和攻击为主要行为。与追击状态类似的，也比较常用的还有‘巡逻状态’，当怪物进入这个‘巡逻状态’时，怪物会在一个范围内到处行走以查看敌人是否在周围，如果在视野范围内查看到敌人，则退出巡逻状态，进而进入追击状态。&lt;/p&gt;

&lt;p&gt;我们来看看编写‘巡逻状态’的步骤。当进入‘巡逻状态’时，状态进入 OnEnter 函数，在 OnEnter 里找到最近的一个巡逻点，然后在更新函数 Update 中持续循环走向最近的巡逻点，当走到第一个最近的巡逻点后继续按照巡逻点的布置顺序继续往下一个巡逻点走，如此不断循环往复。同时更新每次移动时，都检查一下敌人是否在范围内，如果有敌人在检查范围内，当前‘巡逻状态’就结束，OnExit 被调用，转而进入‘追击状态’。&lt;/p&gt;

&lt;p&gt;至于‘追击状态’返回‘巡逻状态’的条件可以设置为，当追击太远时重新转入’巡逻状态‘，比如在进入’追击状态‘ OnEnter 函数里记录起始追击位置，每次移动时都判断下，与起始位置的距离是否太远，如果太远则退出当前的’追击状态‘转而进入’巡逻状态‘。&lt;/p&gt;

&lt;p&gt;游戏策划常设计Boss怪物进入‘疯狂状态’，例如，这个怪物突然变身，然后开始疯狂得从天空里召唤火球，这些火球像流星一般撞向地面，爆炸，并在爆炸范围内敌人受到伤害，结束后怪物又回到了普通的’追击状态‘。&lt;/p&gt;

&lt;p&gt;我们来分析下这个’疯狂状态‘如何编写。当进入’疯狂状态‘时，状态类被调用进入状态事件函数 OnEnter ，函数里播放立刻Boss怪物的变身动画，因为 OnEnter 只调用一次，所以所有检查都在更新函数 Update 里进行，Update 中检查变身动画结束时更换怪物的模型为变身后的新模型，因为需要新模型播放自己的动画所以必须更换。紧接着更换完变身后的模型后，就用新的模型播放施法动画，同时不断按次序调让火球出现在上空的某个位置，并持续移动向地面，当火球的物理引擎检测碰撞到地面时，销毁火球并生成爆炸特效，同时在爆炸位置范围内，查找到是否与爆炸位置距离小于某个值的敌人，如果有则调用敌人的受伤接口使其受伤。当检测到所有火球都已经爆炸完毕，则完成了此次’疯狂状态‘，退出并转向’追击状态‘。&lt;/p&gt;

&lt;p&gt;无论多少复杂的技能或者行为，都能在一个状态中体现出来，以状态形式的编写好用就在这里。有了众多复杂的状态还不够，我们还需要有控制这些状态的状态控制器。&lt;/p&gt;

&lt;p&gt;状态控制器就是记录，这些状态的状态管理类，我们可以命名为 StateControl类，所有状态都在 StateControl 里有一份实例，而且状态控制器记录了一个变量是当前是什么状态，由于所有状态都是继承与 AIStateBase，所以这个当前状态变量可以为 AIStateBase 以支持所有类型的状态类。又由于所有的状态类的对外接口都是统一，所以只需要基类就能操作所有状态，而且状态的转换也完全可以各自状态的本身来决定。状态控制器，只是起到了对状态实例管理和转换的工具，所以状态控制器没有太多了的逻辑，所有AI逻辑都放在了每个状态类里面，由每个从 AIStateBase 父类继承而来的AI子类来决定如何行动，这种做法大大降低了逻辑的耦合，让代码逻辑更加清晰，维护性强，扩展性强。&lt;/p&gt;

&lt;h6&gt;用状态机编写AI有诸多优点，诸如可维护性强，可扩展性强，逻辑耦合清晰，符合人类思维逻辑易上手。但缺点也很大，由于每个状态都必须由设计人亲自制定，所以在每个状态时编写时要考虑到所有情况，每种情况都要有自己的处理方式，这样就导致当需要设计的AI行为过于复杂的时候，编写的逻辑复杂度和工期长度也呈现指数级的增长，到最后有可能无法承受太复杂的AI行为逻辑，比如人类在战场中的随机应变能力，对于各种各样的爆炸，攻击，冲锋，防御的应变能力需要表现出各种不一样的行为方式时，如果任然用状态机来编写，就会很容易陷入超出人类逻辑的复杂度。&lt;/h6&gt;
</description>
               <pubDate>Sun, 10 Mar 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/03/10/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-AI1.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/03/10/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-AI1.html</guid>
            </item>
        
            <item>
               <title>YOU CAN LIVE YOUR DREAM!</title>
               <description>&lt;p&gt;I don’t know what that dream is that you have.&lt;/p&gt;

&lt;p&gt;I don’t care how disappointing it might have been, as you’ve been working towards that dream.&lt;/p&gt;

&lt;p&gt;That the dream that you’re holding in your mind … that it’s possible.&lt;/p&gt;

&lt;p&gt;That some of you already know that its hard… it’s not easy. Its hard changing your life.&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;That in the process of working on your dreams you are going to incur a lot of disappointment … a lot of failure … a lot of pain … there are moments when you’re going to doubt yourself … and say “ God why? why is this happening to me? I’m just trying to take care of my children and my mother I’m not trying to steal or rob from anybody. How did this have to happen to me ?”&lt;/p&gt;

&lt;p&gt;For those of you that have experienced some hardships, don’t give up on your dream.&lt;/p&gt;

&lt;p&gt;There are rough times that are gonna come but they have not come to stay, they have come to pass.&lt;/p&gt;

&lt;p&gt;Greatness is not this wonderful esoteric, elusive, god like feature that only the special among us will ever taste … it’s something that truly exists in all of us.&lt;/p&gt;

&lt;p&gt;It’s very important for you to believe, that you are the one.&lt;/p&gt;

&lt;p&gt;Most people, they raise a family, they earn a living and then they die.&lt;/p&gt;

&lt;p&gt;They stop growing… they stop working on themselves, they stop stretching, they stop pushing themselves.&lt;/p&gt;

&lt;p&gt;And a lot of people like to complain but they don’t want to do anything about their situation, and most people don’t work on their dreams.&lt;/p&gt;

&lt;p&gt;why? One is because of fear, the fear of failure… “what if things don’t work out?” And the fear of success… “what if they do and I can’t handle it?”. These are not risk takers.&lt;/p&gt;

&lt;p&gt;You spend so much time with other people, you spend so much time trying to get people to like you, you know other people more than you know yourself, you study them… you know about them, you wanna hang out with them, you wanna be just like them.&lt;/p&gt;

&lt;p&gt;And you know what you’ve invested so much time into being like them you don’t know who you are, I challenge you to spend time by yourself.&lt;/p&gt;

&lt;p&gt;It’s necessary that you get the losers out of your life, if you want to live your dream.&lt;/p&gt;

&lt;p&gt;For people who are running towards their dreams, life has a special kind of meaning.&lt;/p&gt;

&lt;p&gt;When you become the right person, what you do is you start separating yourself from other people, you begin to have a certain uniqueness.&lt;/p&gt;

&lt;p&gt;As long as you follow other people and as long as you’re being a copy cat you will never ever be the best copy cat in the world. But you will be the best you can be.&lt;/p&gt;

&lt;p&gt;I challenge you to find your value. That everybody won’t see it, that everybody won’t join you, that everybody won’t have the vision, it’s necessary to know that. That you are an uncommon breed.&lt;/p&gt;

&lt;p&gt;It’s necessary that you align yourself with people and attract people into your business who are hungry.&lt;/p&gt;

&lt;p&gt;People who are unstoppable and unreasonable, people who are refusing to live life just as it is and who want more.&lt;/p&gt;

&lt;p&gt;The people that are living their dream are finding winners to attach themselves to. The people that are living their dreams, are the people that know that if it’s gonna happen it’s up to them.&lt;/p&gt;

&lt;p&gt;If you wanna be more successful, if you wanna do and have stuff that you have never had before, I’m asking you to invest in you.&lt;/p&gt;

&lt;p&gt;Someone’s opinion of you does not have to become your reality … that you don’t have to go through life being a victim. And even if you have to face disappointment, you have to know within yourself, I can do this even if no one else sees this in me I must see it for myself.&lt;/p&gt;

&lt;p&gt;Because you’re still talking about your dream … you’re still talking about your goal …you’ve not done anything … just take the first step … you can touch millions of peoples ‘ lives … and the world will never be the same again … because you came this way.&lt;/p&gt;

&lt;p&gt;Don’t let nobody steal your dreams. If you face a rejection or a no, if you hold a meeting and nobody shows up, if someone says ” you can count on me ” and they don’t come through.&lt;/p&gt;

&lt;p&gt;What if we have that kind of attitude, a cause repossessed, nobody believes in you … you’ve lost again, and again, and again, the lights are cut off … but you’re still looking at your dream, renewing it every day and saying to yourself it’s not over… UNTIL I WIN !&lt;/p&gt;

&lt;p&gt;YOU CAN LIVE YOUR DREAM!&lt;/p&gt;

&lt;h3&gt;Copy from google&lt;/h3&gt;
</description>
               <pubDate>Tue, 19 Feb 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/02/19/you-can-live-your-dream.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/02/19/you-can-live-your-dream.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第一章，C#要点技术(六) 搜索算法</title>
               <description>&lt;h3&gt;搜索算法&lt;/h3&gt;

&lt;p&gt;广度优先搜索和深度优先搜索是最直接的搜索方式，但也效率最差，直接使用广度和深度算法，而不加以优化和改进，会浪费太多CPU，以至于整体效率差劲。&lt;/p&gt;

&lt;p&gt;好的搜索算法，大部分需要有数据结构的支撑，在数据结构里记录了信息的特征，搜索的记录，和当前搜索内容的环境，以达到裁剪优化的目的。&lt;/p&gt;

&lt;p&gt;搜索的目的一般有，一个数组中找出某元素，一个数组中找出某个范围的所有元素，一个2D或3D空间中找出某元素，2D或3D空间中找出某一个范围的所有元素，以及一堆相互连接的结构中找出两点的最短路径等等等。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h6&gt;二分查找算法&lt;/h6&gt;

&lt;p&gt;二分查找算法是搜索中用的最多，也是最简单易用的，效率也比较好。不过它有个先决条件，条件是查找的数组必须是有序的数组。&lt;/p&gt;

&lt;p&gt;也就是说，在使用二分算法查找前，必须对数组进行排序。而且在每次更改，插入，删除后都要进行排序以保证数组的有序状态。&lt;/p&gt;

&lt;p&gt;二分查找算法的步骤是：&lt;/p&gt;

&lt;p&gt;1，将数组分为三块，依次是前半部分，中间位，后半部分。&lt;/p&gt;

&lt;p&gt;2，将要查找的值和数组的中间位进行比较，若小于中间位则在前半部分查找，若大于中间位则在后半部分查找，等于中值时直接返回。&lt;/p&gt;

&lt;p&gt;3，下一个查找范围，跳入1步骤，依次进行递归过程，将当前的范围继续拆分成前半部分，后半部分，和中间位三部分，直到范围缩小到最小，如果还是没有找到，那说明元素并不在数组里面。&lt;/p&gt;

&lt;p&gt;二分查找的平均时间复杂度为O(logN)，算是一个比较好的时间复杂度了。不过前提是数组或序列是有序的，这个门槛比较高。&lt;/p&gt;

&lt;h6&gt;二叉树、二叉查找树、平衡二叉树、红黑树、B树&lt;/h6&gt;

&lt;p&gt;二叉树及其衍生的所有算法都是以节点有且只有至多两个节点为规则的，这种结构在一维数组上比较有效且容易理解。&lt;/p&gt;

&lt;p&gt;二叉查找树，在二叉树之上建立的查找树，主要目标是快速查找，它在构造时的特点是，左边的子节点一定比父节点小，右边的子节点一定比父节点大。算法的方式与二分查找算法有点类似，不一样在于，构建出来的树形结构，由于数据的排序不同有可能是深度很大的二叉树犹如直线连接的节点，因此它是个不稳定的查找方式，搜索的速度由构造元素的顺序决定，顺序不好，速度就不佳，不稳定。&lt;/p&gt;

&lt;p&gt;平衡二叉树，就是用来解决查找二叉树的问题的，它的规则是，父节点的左右两棵树的深度差的绝对值不能超过1，并且左右两棵子树叶同样遵循这个规则。二叉树的深度问题解决了，在查找时就不会出现不稳定的状况了。&lt;/p&gt;

&lt;p&gt;红黑树，就是实现平衡二叉树的算法，红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。&lt;/p&gt;

&lt;p&gt;红黑树虽然高效稳定，但实际项目中运用的还是少，首先算法复杂度高，普通的程序员还是要费点心思去研究的，时间成本、人力成本增加。另一方面，因为完全可以用“快速排序”+“二分查找”代替，效率一样而且更加稳定、简单、易用，如果使用优化后的快速排序效率时常会高于红黑树。至少在游戏项目中，是很难看到其应用场景的，但并不代表它没用，树形结构的好处就是有自带有更多的信息，节点中不止存放的是‘值’信息，还有很多与值相关与逻辑相关的数据可提供更好的服务。&lt;/p&gt;

&lt;p&gt;B树，是建立在平衡二叉查找树之上的，多叉树。它的节点上有多个值的，且多叉的，且平衡的，查找树。犹如在红黑树之上，建立了多叉的方式，并且比较方式由单一值比较，改为了多值比较。一个节点里的信息是个数组，且它们是有序的，可用二分查找比较和查找，找到中间节点继续往下搜索。&lt;/p&gt;

&lt;p&gt;B树会更快吗，从查找上来看与红黑树效率一样，从构建上来看，增加，删除会更复杂，算法上都是使用二分思想所以相差不多。其实B树在游戏里也很少能用到，因为能代替它的算法很多。不过它在文件存储结构上能发挥巨大作用，这也是它被发明的原因，包括B+和B*树都是从B树衍生而来。&lt;/p&gt;

&lt;h6&gt;无论用得到用不到，思考方式和思考角度是关键，知道了有这些多种角度的思考方式，在平时的算法编写时就有了更多的思路和想法，因为指不定什么时候就从这种思想角度里得出了你要的算法，毕竟需求和环境是多变的，我们需要找到适合的优秀的算法。&lt;/h6&gt;

&lt;h6&gt;四叉树搜索算法&lt;/h6&gt;

&lt;p&gt;四叉树搜索算法，有点像二叉树的多维度版本，有点类似一维数组上数组分成4块进行查找，但也仅限于此。&lt;/p&gt;

&lt;p&gt;四叉树的最重要的理念是空间划分，把一个二维空间划分成多个块来存放，它由树形结构支撑，每个点有四个子节点，这四个子节点代表父节点的四个象限区块，四个子节点加起来代表整个完整的父节点，以此类推下去，每个节点可以有子节点，一旦有就得四个一起有。&lt;/p&gt;

&lt;p&gt;在实际运用中，四叉树也是在2D平面空间上的搜索用的比较多，虽然其他领域也有用到，但在2D平面空间划分上更适合。我们可以把一个2D矩形平面想象成，一个分成相等四个大小的矩形，总共四块矩形方块，每块中又再次分成相等大小的四块，直到分到定义的最小块为止，每一块都有自己的父节点和子节点(除了最底部的节点)。&lt;/p&gt;

&lt;p&gt;当元素加入这个平面时，也就是加入到了这个四叉树的数据结构中去，从最大的四块开始依次往下推，一直到推到没有子区块的节点上，每个区块都有元素容量。当元素达到最大容量时，节点分裂。把需要搜索和查找的每个元素按这个步骤推入四个子节点。&lt;/p&gt;

&lt;p&gt;形成四叉树数据结构后，就可以根据这个数据结构进行查找元素了。比如，在某个位置上查找在相同块内的所有元素。给出坐标后，就能根据四叉树依次推下去最终找到没有子节点的那个节点，获取块上的所有信息。&lt;/p&gt;

&lt;p&gt;由于每次元素加入到四叉树时，在每个父节点都会留下相关的信息，所以在父节点上也能得到相关的信息列表。比如把地图分成3级，每一级四块矩形图上都存有相关元素的信息，可以快速得到1，2，3级地图上某块内的所有元素的信息。&lt;/p&gt;

&lt;p&gt;四叉树在游戏项目中的运用有，二维平面上的有效碰撞检测搜索范围，地形的有效展示范围，在地图上找人或事务或地点，在地图上找某范围的人或事务或地点，二维平面的寻路网格构建等。&lt;/p&gt;

&lt;h6&gt;由于四叉树的搜索是建立在元素不移动的状态下进行的，一旦移动就得进行先删除后再加入的操作，如果移动的操作比较频繁，效率将急剧下降。所以四叉树构建的搜索算法，不适合大量元素移动频繁的系统上。而对于那些固定或者说太变动的，如，地形，地块，网格，地点，物体，以及不动的人是比较有效的。&lt;/h6&gt;

&lt;h6&gt;八叉树搜索算法&lt;/h6&gt;

&lt;p&gt;八叉树与四叉树类似，但在理念上更关注三维空间上的划分。八叉树把一个立方体，纵向和横向各切一刀，分裂成八个相同大小的立方体，每个小立方体也就是子节点，也可以在适当的时候分裂成八个相同大小的小立方体，用树形结构表示每个大大小小的立方体形成了八叉树。&lt;/p&gt;

&lt;p&gt;经过树形结构构造，八叉树就很容易用在3D空间中的场景管理，可以很快地知道物体在3D场景中的位置，或测试与其它物体是否有碰撞以及是否在可视范围内。因此八叉树在实际游戏中用到的，有渲染中的渲染裁切，和物理引擎中的碰撞检测。&lt;/p&gt;

&lt;h6&gt;优秀的算法都是能找到事物特征并且利用好事物特征的算法，不同种类的算法有其自身的理念，混用或合用几个算法也是常有的事，理解和知晓是第一步，灵活运用真的不是一朝一夕的事，若非项目需要所驱动的算法研究通常也只是纸上谈兵，真搬上项目真刀实枪的干时，很多时候都是和底下读几篇文章、敲几个算法是完全两样的，所以我才常听到‘老兵们’常说的一句，适合的才是最好的，和交朋友、谈恋爱是一个道路。&lt;/h6&gt;
</description>
               <pubDate>Sun, 17 Feb 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/02/17/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-CSharp%E8%A6%81%E7%82%B9%E6%8A%80%E6%9C%AF6.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/02/17/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-CSharp%E8%A6%81%E7%82%B9%E6%8A%80%E6%9C%AF6.html</guid>
            </item>
        
            <item>
               <title>思路探讨(二十) 如何将你的家庭与普通人拉开差距</title>
               <description>&lt;p&gt;这个标题好刺激，说的好像很容易似的，假如拉开差距容易的话，也就不会在这里说了，我直接拉开了，还扯什么蛋。&lt;/p&gt;

&lt;h6&gt;实际上大部分人都知道怎么拉开差距，但知易行难啊，知道和执行是两码事。&lt;/h6&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;办法是，努力学习，努力工作，努力做人，努力保持健康。不可能是偷懒，投机，作弊，暴力，反社会。&lt;/p&gt;

&lt;p&gt;这属于正常思路的范畴。可是大部分人都不信啊，为什么不信，效果太慢，太枯燥乏味，需要5-10年甚至20年。于是他们一定要寻找另外一条路，从此踏上了寻找捷径的旅途。&lt;/p&gt;

&lt;p&gt;他们相信世界上有这么一条捷径，他们一定能找到，比别人用的时间少花的精力少就能夺得世界，不能夺得世界也能拥有自己一块领土，颐养天年。他们对这种想法的意志非常坚定。&lt;/p&gt;

&lt;p&gt;可是真的有么？弯弯绕，最后都要回到原地，回来后发现还是要按部就班得走，这时才发现差距已经拉开了。&lt;/p&gt;

&lt;p&gt;不可否认，有些人还真的是运气好到爆炸，真的被他找到一条路，通往世界的宝藏中心，财富和权利的交集处。&lt;/p&gt;

&lt;p&gt;但故事只是个开头，后面故事怎么发展，不能下定论，虽然我的观点是99%最后都灰飞烟灭了，但世界不会因为我怎么想而怎么走。&lt;/p&gt;

&lt;p&gt;无论如何，这个概率也是几十亿到几百亿分之一以下的概率，基本可以忽略不计，但人就是这样，永远认为自己会是那个幸运儿。&lt;/p&gt;

&lt;h6&gt;啊哈，看到没有，只要按正常人的正常思路走，就能击败大部分人，与普通人拉开差距。&lt;/h6&gt;

&lt;p&gt;为什么？因为普通人耐不住寂寞，受不了枯燥，行动不下去。&lt;/p&gt;

&lt;p&gt;那么真的有人能耐得住寂寞，受的了枯燥，沉着冷静吗？&lt;/p&gt;

&lt;p&gt;当然没有，别骗自己了，我们都是人，都是恒温动物，都有血有肉，都有感情，贪嗔痴慢疑一样不能少。&lt;/p&gt;

&lt;p&gt;每个人都是一样的，拥有完整的人性的弱点，谁都躲不过。&lt;/p&gt;

&lt;p&gt;一个拥有完整人性弱点的人，是不可能完完全全、彻彻底底反人性的。&lt;/p&gt;

&lt;p&gt;那什么样的人能够完完全全、彻彻底底反人性？疯子，神经病。无论什么原因病态彻底扰乱了人性的特点。&lt;/p&gt;

&lt;p&gt;我肯定不想成为疯子，我也意识到人性的弱点无法改变，但我又想抗拒人性弱点，怎么办？&lt;/p&gt;

&lt;h6&gt;1，在枯燥中寻找乐趣。不惜一切方式、方法，围绕目标消除枯燥，即使会暂时的退步，也是以退为进的一种战略战术。&lt;/h6&gt;

&lt;h6&gt;2，在痛苦中寻找欢乐。痛苦是必然的，疲惫也是必然的，要在痛苦中找到欢乐，在疲惫中找到精神支柱。就不会像表面上看起来那么苦了，虽然表面上还是苦的累的，但当事人心里却是甜的是兴奋的。&lt;/h6&gt;

&lt;h6&gt;3，迷茫时给自己打精神麻醉剂，告诉自己是金子总会发光的。不要忘了事业，财富，并不是直线向上的，而是一个波动的曲线。无论有多强大的心，生命中充斥着大部分的，都是失败。因此迷茫是必然的，而且大部分时候都在迷茫，真正看清前方道路的时间没几分钟，不一会又会再次陷入迷茫。不要在迷茫上浪费太多的时间，告诉自己是金子总会发光的，不要犹豫了，先冲上去拨开云雾。&lt;/h6&gt;
</description>
               <pubDate>Mon, 04 Feb 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/02/04/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A820.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/02/04/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A820.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第一章，C#要点技术(五) 排序算法</title>
               <description>&lt;p&gt;年纪越大，写程序写的越多，时间越长，就越觉得算法的重要性，基础能力决定你到底能走多远。&lt;/p&gt;

&lt;p&gt;我们不是写一两年就完事的，从毕业算起，我们可能要写20-30年的程序，这段漫长的长跑路程中，最终比的不是谁熟悉API比较多，也不是谁用插件用的有多熟练，更不是比谁更熟悉某软件，而是比谁的算法能力强，比谁对底层结构更加熟知于心，比谁能够解决的系统复杂度有多高。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;算法能力非常重要，在程序生涯中，算法是基础能力，很多时候程序的好坏，一方面看的是写程序的经验，另一方面看的是对计算机原理的理解程度，还有一方面看的是对算法的运用到如何程度。&lt;/p&gt;

&lt;p&gt;算法能力不仅仅是表面的算法熟知度，更是种精神高度，对所有经过自己手的程序效率负责的精神高度。某一处的算法有可能运用的很好，但如果其他地方都用烂算法，对于整体程序效率来说其实也没什么用，效率依然很烂。&lt;/p&gt;

&lt;p&gt;在平时的编程时，做到时刻关注算法的效率是区分中、高水平的一个大的关键点。&lt;/p&gt;

&lt;p&gt;其中排序和搜索算法最为常用。毫不夸张的说一个项目中有90%的算法都是排序和搜索算法，如果说我们把这90%的算法提高到一个很高效的程度，那么剩下的10%算法处理起来也没那么压力了。&lt;/p&gt;

&lt;h3&gt;快速排序算法&lt;/h3&gt;

&lt;p&gt;快速排序，也叫二分排序，是最最最常用，最最最好用，用的最最最多的排序算法。它的排序方式是：&lt;/p&gt;

&lt;p&gt;1.从序列中选一个元素作为基准元素&lt;/p&gt;

&lt;p&gt;2.把比基准元素小的元素移到基准元素的左边，把基准元素大的移到右边。&lt;/p&gt;

&lt;p&gt;3.对分开来的二个一大一小区块进行递归再筛选，对两个区块同样进行1、2的两个步骤处理。&lt;/p&gt;

&lt;p&gt;简单来说就是把一个区域的数字分成两半，一半比另一半大。然后继续对这两半做同样的操作。&lt;/p&gt;

&lt;p&gt;由于这是最常用的排序方法，几乎占据50%以上的排序算法编码量，所以我们要着重优化此算法，对大批量使用的算法和程序绝对不能忽视。&lt;/p&gt;

&lt;h3&gt;优化：&lt;/h3&gt;

&lt;h6&gt;1.随机选择中轴数&lt;/h6&gt;

&lt;p&gt;如果选中的数字不是中位数，而是一个比较偏左或者比较偏右的数字，那么排序的速度就会降低，比如选中的刚好是最大的或者最小的数字，左边完全没有数字可以排，而所有数字都在它的右边。&lt;/p&gt;

&lt;p&gt;我们肯定无法准确的找到中位数，但是我们可以随机一个列表上的元素来作为基准元素。&lt;/p&gt;

&lt;p&gt;随机是为了减小选到最大和最小值的概率，但随机也时常会选到坏的基准元素，实际上随机数并没有对排序提供多大的帮助。&lt;/p&gt;

&lt;h6&gt;2.三数取中&lt;/h6&gt;

&lt;p&gt;为了让选择的中轴数更加接近中位数，可以先选择头、中点、尾，三个数字先来次排序，把最小的放在头，中间的放在中，最大的放在尾。&lt;/p&gt;

&lt;p&gt;每次每个区间的头中尾的排序前都做这个操作，也就是说，每次排序前，中位数都不可能是最小的，起码是区间里第2小的或者第2大的，这样选出来的中轴数靠近中位数就的概率就大了。&lt;/p&gt;

&lt;p&gt;虽然可以把三个数扩大到M个数，但过多数字的选择就相当于多出了个一个排序算法，减慢的二分排序的效果。实际效果不如3个数字来的快。&lt;/p&gt;

&lt;p&gt;也可以用随机选取3个数字的方式来替代做选择，但实际上随机性并没有多大的帮助，况且伪随机数的计算也是需要消耗cpu的，而常用的头，中，尾的做法是选择接近中位数的比较有效的办法。&lt;/p&gt;

&lt;h6&gt;3，小区间使用插入排序&lt;/h6&gt;

&lt;p&gt;插入排序和二分排序一样都依赖于序列的有序性，如果是反序列效率最差，反之如果是有序序列效率最大。&lt;/p&gt;

&lt;p&gt;其中，插入排序当序列越长，效率越差，而短序列的排序效果则很好，序列长度在8左右。&lt;/p&gt;

&lt;p&gt;在排序中，当切分的区块小于等于8的个数时，就可以采用插入排序来替代二分排序，其他时候任然采用二分切割算法。&lt;/p&gt;

&lt;h6&gt;4，缩小分割范围，与中轴数相同的合并在一起&lt;/h6&gt;

&lt;p&gt;与中轴数相同的数可以立即合并到中轴数的位置，使得后面的分割范围变得小，范围越小，排序的速度越快。&lt;/p&gt;

&lt;p&gt;具体做法是，在二分比较中，当元素与中轴数相等时就移动到中轴数身边，移动完毕后，划分范围从中轴数变为最边上的相同元素的位置。&lt;/p&gt;

&lt;h6&gt;快速排序是最常用，使用范围最广的排序算法，铭记于心是有必要的。&lt;/h6&gt;

&lt;h3&gt;其他排序算法简要&lt;/h3&gt;

&lt;p&gt;其他排序虽然使用频率没有快速排序来的多，但提供了对解决问题的思路很有帮助。&lt;/p&gt;

&lt;p&gt;比如，桶排序，把所有的元素按一定大小范围分成N个组，对每个组进行快速排序，最终得到有序的数组，并且得到N个桶的记录，虽然第一次排序的速度不怎么样，但这N个桶的信息记录下来后对于后面的程序逻辑有非常大的帮助。比如我们需要进行模糊排序或模糊搜索，这种桶信息就会有很大帮助。&lt;/p&gt;

&lt;p&gt;又比如，堆排序，和快速排序一样用的是二分的方式，是一种近似完全二叉树的结构，速度上虽然没有快速排序来的快，但却能快速定位某元素，排序完成后，形成的有序最大堆或最小堆数据结构在后面程序逻辑需要插入新元素，找某元素时，效率比较高。&lt;/p&gt;

&lt;p&gt;再比如，基数排序，是针对元素的特性来实时的‘分配式排序’，利用数字的特性按个位数，十位数，百位数的性质放入0-9的桶中不用排序，几次合并后直接就是有序数组，利用元素特性排序的速度比任何其他排序方式都要快速。这就教会我们，在运用算法时，首先要从元素的特性和环境着手，找到更合适更快的算法。&lt;/p&gt;

&lt;h6&gt;基本的、常用的几种排序算法是我们需要了解的，当我们面对需要解决的难题时，我们的思路就更为广阔，算法在实际运用中并不是固定的，适合的才是最好的，我们应该随着问题环境的变化而变化，找到最佳的突破口。&lt;/h6&gt;
</description>
               <pubDate>Sun, 03 Feb 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/02/03/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-CSharp%E8%A6%81%E7%82%B9%E6%8A%80%E6%9C%AF5.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/02/03/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-CSharp%E8%A6%81%E7%82%B9%E6%8A%80%E6%9C%AF5.html</guid>
            </item>
        
    </channel>
</rss>