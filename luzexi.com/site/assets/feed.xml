<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title></title>
        <description>技术融入哲学,哲学支撑技术</description>
        <link>http://www.luzexi.com</link>
        <atom:link href="http://www.luzexi.com/assets/feed.xml" rel="self" type="application/rss+xml" />
        
            <item>
               <title>思路探讨(三十四) 纠正错误观念</title>
               <description>&lt;p&gt;平时会用‘印象笔记’来记录自己在脑中一闪而过的想法，这些想法很细碎，很难形成连贯的大篇幅的文章，于是我把它们都命名为‘随记’1、2、3、4...到现在已经记录到了60多个随记片段，部分已经写入到文章中已经被删除，留下了45个片段还没有被连接进入大篇幅的文章中。&lt;/p&gt;

&lt;p&gt;在平时写文章的过程中会用到一些片段，但很多片段都没有成形的理论体系，连自己都想不明白也就无法拿出来与大家分享。其中有一些理论在当时看来觉得很对，现在回过头去看却是错误的观念。今天就把一部分记录在‘随记’里的错误观念，拿出来复盘一下，当时自己是怎么想的，为什么错。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h3&gt;记在‘随记3‘中的:&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    大多数成功是可以根据现有的经验推出来的。
    虽然不能说一定成功，不过，一旦有了先前成功经验，就能在大概率上，或者说关键点加强成功概率。

    这样说有点泛泛而谈，有些成功经验确实是没有意义的，比如躺赢，突然被风口吹上天，突然政策转变你刚好被砸中等，一些完全没有自己全程经历过的事情，没有辛苦琢磨过的，都有可能是伪成功经验，这种经验是大坑。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段想法错从本质上就错误的理解了’成功‘。’成功‘就是赚到钱吗？不是的。但当时记录我就是这么认为的，话中透露出我对赚到钱的渴望，这种渴望会诱导我走向错误的道路，比如只关注短期结果，对长期的计划和展望关注度减少，形象到生活中比如只关注与钱有关的事物，而对人与人之间的合作比如情绪、交流、人情交际上关注度减少，最终将导致原本想找捷径更快走向目标’赚钱‘，反而绕了更大的弯路甚至走向了完全相反的方向’费钱‘。&lt;/p&gt;

&lt;h6&gt;其实只对钱感兴趣的必定会和合作之道背道而驰，在这个我们光怪陆离的时代，致富之道何止万千，即使是旁门左道，有时候也会为人带来巨富。对此我们不必感到惊讶，虽然我们绝不敢说做人正直、有所不为的人一定能够成功，但是我们却敢断言，守正道、明事理必能使其勇气保持不坠，并且不失尊严与自信。&lt;/h6&gt;

&lt;h3&gt;记在’随记2‘中的:&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    能力太大就会很容易越过界，造成严重失误。

    枯燥，乏味，充斥着大部分生活，如果没有目标，很快就会陷入困惑，从而降低学习和工作效率。

    游戏太浪费时间和精力，能否找到有效的放松方式很关键，健康的放松方式和方式习惯让人非常受益，每个人每个阶段都不一样。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;言语和文字中看出本质，这段想法的本质是对’个人能力‘的错误理解。我当时太关注’个人能力‘。’个人能力‘能解决所有问题吗？不能。但当时的记录来看我就是这么认为的，认为个人能力可以解决所有问题，至少认为是可以解决所有核心问题。对个人能力的错误理解，其实就是对’人与人合作‘的错误理解，人类是合作的社会，没有合作就没有人类发展，工作、生活也是同样的道理因为它反映了人类生活的结构规则。人类社会得益于分工制度，它为人类生产生活提供巨大效益。如果每个人都是什么都要完全自己来，没有人合作，没有人站在前人的肩膀上工作、学习，那么整个社会就是停留在原始的动物阶段，没有工具、知识、文化的积累，一生下来就是重新开始，只靠着基因进化适应环境，跟动物没有分别。&lt;/p&gt;

&lt;h6&gt;对于合作产生的效益来说，个人能力实在微不足道。工作、生活中亦是如此，我们应该放弃个人能力改变世界的愚蠢想法，转而致力于促进更多的合作，改进合作向更好的合作走去，当每个个人奉献出自己的力量的时，让 1人 加 1人 或者 10人 + 10人 或者更多组合 10人 + 12人 + 18人 + ... = 等于原来结果数倍还多的能量。&lt;/h6&gt;

&lt;h3&gt;记在’随记7‘中的:&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    我们要理解蠢货的存在，不要去计较蠢货的思维逻辑。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;没有人是蠢货，存在即合理。我们心中的世界本质上是围绕我们自己为中心的世界，本来就是一个扭曲的世界，用扭曲的世界看真实的世界，怎么看怎么不合理。归根结底还是我们自己太狭隘，太固执，没有放平心态，敞开怀抱拥抱世界，这种不寻求合作反而倒退去固步自封的想法，是错上加错。&lt;/p&gt;

&lt;h3&gt;记在’随记7‘中的:&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    我的智慧足以教育女儿登顶同龄人成为人生赢家，但我的财力不足以支撑我这么做。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我把教育想的太简单，也高估了自己，这是在我还没有深入接触幼儿教育之前的想法，那时完全由我妻子来负责，而我只负责空想。当我深入接触和了解时则与我想象的完全不同，一下子感觉到了自己的渺小，对方的伟大。《自卑与超越》中写下了大量人类儿童时期的心理过程让我深受启发。一些浅见是，我们应该更多的思考，如何让孩子对周围的环境和人发生足够的兴趣，以使得他们在日常活动中形成更多的合作，我们也应该致力于让孩子尽早了解社会分工制度，尽早确立自己感兴趣的职业方向。&lt;/p&gt;

&lt;h6&gt;其实还有许多愚蠢的想法，愚蠢到自己都羞涩难忍，就放在后面的文章中再一一显露出来好了。写’思维探讨‘的目的就是进阶思维方式和思维角度，靠什么进阶呢，光靠自己空想没用，要多看书而且是精读，再和周围的朋友们多聊聊各自的想法，从中碰撞出思维的火花。&lt;/h6&gt;
</description>
               <pubDate>Thu, 02 Jan 2020 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2020/01/02/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A834.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2020/01/02/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A834.html</guid>
            </item>
        
            <item>
               <title>思路探讨(三十三) 2019年我做了什么</title>
               <description>&lt;p&gt;最近忙了好多事情，原以为休息在家可以轻松点，但依然忙的不可开交，我没常回家的1年多时间里有这么多事情堆积着。原本想着把《算法导论》再看一遍后把关于‘算法’的文章写完，可惜算法这块知识量和知识深度有点大，还需待点时日。&lt;/p&gt;

&lt;p&gt;2019年我做了什么呢？虚的我觉得讲出来可能大家都有不同的意见（什么人生哲学，生活大道理，思维方式，智慧之举等等），我们就讲讲实实在在能看到的，我把这些实实在在能看到的学习生活记录了下来，尽量记录的详尽，虽然有部分遗漏但大部分都被记录了下来。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;一整年我都在使用一个叫‘滴答’的任务app，我在里面设置了每天要做的事情，每天做完把它勾掉，做不完也没事，留到下一天来做。不想给自己太多的压力，也为了放过自己，既然做不完，那就让它过去，第二天里的任务继续有，只要我今天做了一个任务我就把它勾掉。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/life/idea-talking33-3-2.png&quot; alt=&quot;滴答详情&quot;&gt;&lt;/p&gt;

&lt;p&gt;于是就有了上面这张图。其实不止这些，还加入了简简单单就能完成的任务，比如每天白天累了趴下休息10分钟，每天早中晚三餐规律饮食，每天不看娱乐新闻，每天下午3点吃点东西补充能量，每天12点前睡等等等，有28条每日任务。&lt;/p&gt;

&lt;p&gt;我做了这么多年游戏已经彻底清楚的明白对于一个平民玩家，每日任务就是其最宝贵的追上土豪玩家的途径，土豪玩家有钱没毅力快速提升靠钱砸，平民玩家没钱只能靠毅力靠肝靠做任务坚持几个月，最终还是能追上一部分土豪玩家的，毕竟他们整体上来说总是在不断放弃与重新开始中，平民玩家也就只有肝，那么肝之中，每日任务最为精华，其他途径都是效率相对比较低的。结合到实际生活中也是同样的道理，我们可以把人生看成一次游戏，要么你出生就有钱有地位，要么就只有肝这条路。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/life/idea-talking33-3.png&quot; alt=&quot;滴答等级&quot;&gt;&lt;/p&gt;

&lt;p&gt;我每天都会点掉很多任务，也留下了很多任务。每点掉一个任务就会增加一些经验，就像游戏人生一样，我每天做一些任务学一些东西就会增加一些人生阅历和知识经验。这个软件也是一样，于是我就有了如上图所示的经验等级。其实它的满级只有10级，但是在里面用的人真的很厉害，我花了很大的力气，坚持了这么久，还有百分之5的人没有被我击败，可想而知他们该有多努力。&lt;/p&gt;

&lt;p&gt;这是在我去年9月份时看了一本《做时间的朋友》后开始做的事情，当初的想法是把时间利用起来，跟时间一起‘玩’，这样就能让自己每天的生活很充实，也很高效。虽然事情一开始比较顺利，但随着日子一天天过，枯燥和疲惫的冲击，做这些事变得越来越困难，甚至一度停止过。&lt;/p&gt;

&lt;p&gt;这其实跟人生在岔道口的挑战一样，当挑战来临时，有明显的征兆，比如当挑战来临时你一定很疲惫，你一定很痛苦，甚至有时你很无聊。熬过去很多时候会是柳暗花明又一村的另一个美好世界的景象。我想我熬过来了，这个过程我加入了很多反馈机制，来调节我的感官上的感觉，以达到刺激自我感觉的目的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/life/idea-talking33-8.png&quot; alt=&quot;anki&quot;&gt;&lt;/p&gt;

&lt;p&gt;比如这张图，我用Anki软件来背英语单词，每天的背诵量被记录下来，并且用这种日历方格的统计形式展示出来，让我很有成就感，每天都为打满这个图而不懈的坚持，越多越有劲，越坚持越停不下来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/life/idea-talking33-7.png&quot; alt=&quot;github&quot;&gt;&lt;/p&gt;

&lt;p&gt;也比如这张图，这是我在github上写文章的记录，原本计划是每天写半小时文章，但计划并没有顺利的进行，这个任务难度确实很大，我不跟自己死磕到底，我也怕自己的身体受不了，于是我饶了自己，尽自己所能的每天写点，在身体允许的范围下尽量做到每周一篇文章。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/life/idea-talking33-9.jpeg&quot; alt=&quot;github&quot;&gt;&lt;/p&gt;

&lt;p&gt;写书写文章的灵感并不是每天都有的，一开始会有很多灵感，是因为我这么多年积累了很多自己的生活，工作的知识和经验，想说的想表达的，但毕竟我的经历还是单薄，狭窄的世界观有时任然显露无疑，为了能让自己能有更多的知识，更深刻的理论体系，更广泛的见识，我坚持每天看书，每天风雨无阻坚持看半小时-两小时。看书的速度与日俱增，但始终无法敌过我买书的速度，看书的速度越快，买书的量就越凶残，最后导致办公桌上全是书。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/life/idea-talking33-4.png&quot; alt=&quot;github&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/life/idea-talking33-5.png&quot; alt=&quot;github&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/life/idea-talking33-6.png&quot; alt=&quot;github&quot;&gt;&lt;/p&gt;

&lt;p&gt;其中我看了《精力管理》这本书后让我对时间和精力的管理，有了更深刻的认识。先前知识对时间的认识，也只是想着要好好利用时间，提高时间的利用率，但并没有结合人的属性来制定计划和规划。在看了《精力管理》后，对人本身的精力和时间上的规划有了更深刻的认识。先前我不屑于对时间和精力的精确管理，在看了《精力管理》后，让我对时间和精力管理有了更加浓厚的兴趣。于是就有了上面三张图的内容，这是我日常中记录下来的每天做事的大致内容，内容并没有精确细致到细节，但是时间块上的记录让我知道了我每天运用精力都在什么地方上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/life/idea-talking33-1.png&quot; alt=&quot;github&quot;&gt;&lt;/p&gt;

&lt;p&gt;就这样用昨天的记录来调整今天的状态，每天周而复始，从今年3月份开始，记录下了我每天都把精力花在哪了，用每日、每周、每月的统计图表的方式，让自己了解自己的状态如何。于是就有了上图这张，至今为止记录下来的统计图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/life/idea-talking33-10.png&quot; alt=&quot;github&quot;&gt;&lt;/p&gt;

&lt;p&gt;这些记录与练习仍然不够，我在不断发掘自己的缺点，比如我的说话表达能力很差，因为30几年来一直认为‘没什么好说的，成绩和实干决定一切’的错误观念，导致我脸部的肌肉非常糟糕，软软的只能用来装可爱，因为没有得到充分的锻炼，在说话时完全没有脸部肌肉工作的成分，使得说话非常吃力，完全由大脑来控制该说什么话，如何说，如何开口，如何动口，大脑工作得很累，久而久之就会觉得说话很累，不想说话，于是情况更加糟糕。&lt;/p&gt;

&lt;p&gt;为了改进这个缺点，我找到了一个方法，就是朗读，用朗读书本的方式去锻炼脸部的肌肉，当脸部肌肉得到了锻炼在我说话时就不会那么累了，部分词语完全可以用脸部的肌肉记忆代替大脑的工作，减轻大脑的负担。于是就有了上图，在‘喜马拉雅app’上每天对着书朗读10-20分钟，并且上传到个人文件夹保存起来留作纪念，也是一种正向的反馈机制让自己能够更加有兴趣继续下去。&lt;/p&gt;

&lt;h6&gt;我发现我越来越向务实靠近，脱虚务实的趋向越来越严重，这并不是什么绝对的好现象，但至少我现在需要它。最近在公众号上看到的一个人提出来，&amp;quot;心上学，事上练&amp;quot;的口号，我很是赞成。接下来我希望自己少写些，哲学类话题，而更多的是事实在在的从事情上学习、研究、分析，真正能够做到‘事上练，心上学’。&lt;/h6&gt;

&lt;h6&gt;2019年只是一个开始，既然开始了，我不想再停下来，别人说曾国藩自律了20年才有这样的成就，那我可以先试试自律10年。我看见了另一个世界，一个更加积极，更加自律，更加善于合作的世界。&lt;/h6&gt;

&lt;h6&gt;题外话：我很赞同《自卑与超越》里说的，”合作能力是大多数人所缺乏的“，我们要努力成为一个容易合作、能够主动建立合作、帮助别人加入合作的人。&lt;/h6&gt;
</description>
               <pubDate>Sat, 28 Dec 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/12/28/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A833.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/12/28/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A833.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(五) - Projector投影原理</title>
               <description>&lt;h3&gt;Projector 投影的原理与应用&lt;/h3&gt;

&lt;p&gt;Unity3D中的 Projector 投影像是一个很神秘的组件，但其实它依然运用的是以着色器为基准的渲染流程，和普通的3D模型渲染从本质上来看并没有实质上的区别，唯一的区别是它从它自己的视体(视锥体或平视体)中检测到的模型，并根据默认或者自定义的材质球与Shader着色器，将这些物体又重新绘制了一遍。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;从Unity3D引擎上来讲，可以这样解释 Projector：&lt;/p&gt;

&lt;p&gt;根据 Projector 自身的视体的范围，平视体或视锥体，遍历并计算出视体范围内与视体占边的所有物体。&lt;/p&gt;

&lt;p&gt;接着 Projector 取得这些物体模型数据，并计算投影矩阵。&lt;/p&gt;

&lt;p&gt;这个投影矩阵是什么呢，其实就是前面说的 Projector 视体空间的投影矩阵。&lt;/p&gt;

&lt;p&gt;最后将投影矩阵传入Shader中，根据这个投影矩阵，对这些物体再渲染一次。&lt;/p&gt;

&lt;p&gt;投影中的Shader着色器是投影绘制的主要手段，Projector 的工作只是检测了所有范围内的模型，并传递了投影空间的矩阵而已。&lt;/p&gt;

&lt;p&gt;投影Shader中，通常会结合传入的投影矩阵，将顶点转为 Projector 投影空间中，并以此为投影贴图的UV来渲染模型。&lt;/p&gt;

&lt;p&gt;例如这个简单的投影着色器：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sampler2D&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;float4x4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unity_Projector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SV_POSITION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;texc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TEXCOORD0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;appdata_base&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UNITY_MAXTRIX_MVP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;texc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unity_Projector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;COLOR&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tex2Dproj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;texc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 unity&lt;em&gt;Projector 变量就是由 Projector 传入投影矩阵。在顶点着色器中 unity&lt;/em&gt;Projector 矩阵被用来构造投影坐标，和普通的空间投影转换矩阵MVP(Model View Project)不同的是，其中的V是 Projector 空间的相关矩阵，即 Projector 组件所属的 Transform 的 worldToLocalMatrix变量，而P则是和Projector远近裁切相关的矩阵。&lt;/p&gt;

&lt;p&gt;用 unity_Projector 矩阵计算出vertex(顶点)在投影空间中的坐标后，我们就可以以此坐标为uv坐标绘制物体了。&lt;/p&gt;

&lt;p&gt;为什么可以将顶点坐标视为uv坐标呢？当坐标变换到投影空间后，其坐标空间就变成了投影平面视角，在这个视角中如果我们将平面视为纹理大小，就相当于一一匹配上顶点的uv坐标。&lt;/p&gt;

&lt;p&gt;这个转化后的投影空间中的坐标，也就是我们常说的&amp;quot;投影纹理坐标&amp;quot;。&lt;/p&gt;

&lt;p&gt;&amp;quot;投影纹理坐标&amp;quot;不能直接当作uv来作为纹理坐标来使用，需要调用 tex2Dproj 方法来获取纹理坐标:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    tex2Dproj(texture,uvproj);

    这个纹理投影函数，其实就是在使用之前会将该投影纹理坐标除以透视值

    可以等价于按如下方法使用普通二维纹理查询函数

    float4 uvproj = uvproj/uvproj.w;

    tex2D(texture,uvproj);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果如下图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;缺图
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;​###### 投影的技巧还有很多，我们下面介绍几种投影技巧在游戏项目中的运用。&lt;/p&gt;

&lt;h6&gt;平面阴影&lt;/h6&gt;

&lt;p&gt;平面阴影也是投影技巧的一种，它稍微需要运用些图形计算，主要的原理是在着色渲染模型时，另外做一个Pass将模型上顶点转换到平面上再渲染一次，以此作为平面的阴影，无论地上有没地形，都以平面呈现。如下图:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺图
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要计算这个平面阴影需要我们从光源点，顶点，法线，平面这些已知数据出发计算顶点转换到平面上的点。&lt;/p&gt;

&lt;p&gt;我们首先已知的是地面法线向量 TerrainNormal，和平面上随便一个初始点点的坐标 TerrainPos，我们假设我们需要计算的点为p点&lt;/p&gt;

&lt;p&gt;由平面表达公式得知，平面上的任意向量与该平面的点乘所得值为0，因此地面上的方向向量 TerrainNormal 与 要投影的坐标与初始点所形成的方向向量点乘为零，即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    (p - TerrainPos) 点乘 TerrainNormal = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;又由于平面映射的P点是由光射到顶点延伸到平面而得到的，所以&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    p = d*L + L0 其中L0为顶点，的l为光到顶点的射线方向，d为L0射到p点的距离。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此根据这两个公式，代入得到:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    (dL + L0 - TerrainPos) 点乘 TerrainNormal = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解析后为&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    dL 点乘 TerrainNormal + (L0 - TerrainPos) 点乘 TerrainNormal = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;于是再得到d为:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    d = ((TerrainPos - L0) 点乘 TerrainNormal) / (l 点乘 TerrainNormal)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再代入进 p = d * l + L0 这个公式得到p，即如下Shader中的顶点函数所写&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CGPROGRAM&lt;/span&gt;

    &lt;span class=&quot;cp&quot;&gt;#pragma vertex vert&lt;/span&gt;
    &lt;span class=&quot;cp&quot;&gt;#pragma fragment frag&lt;/span&gt;
    &lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;quot;UnityCG.cginc&amp;quot;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;appdata&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;vertex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;POSITION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;vertex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SV_POSITION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;            

    &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TerrainPos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TerrainNormal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;vert&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;appdata&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wPos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unity_ObjectToWorld&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 光的方向&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;float3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normalize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_WorldSpaceLightPos0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// d 值的计算&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dist&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TerrainPos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wPos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TerrainNormal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TerrainNormal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 代入 p = d * l + L0 公式&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;wPos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wPos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dist&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 空间顶点转换&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unity_MatrixVP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wPos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;fixed4&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;frag&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SV_Target&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fixed4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ENDCG&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述Shader中，利用了_WorldSpaceLightPos0来确定光的反向，也可以用一个光的坐标与顶点的差值来得到一个光的方向。计算过程的公式转换可以以这张手绘的图作为参考。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/pingmianyinying.png&quot; alt=&quot;平面阴影&quot;&gt;&lt;/p&gt;

&lt;p&gt;图中清晰的标明了所有已知向量，和可计算向量，以及最终需要结算的点，上述所说的这些公式的转换都是基于这个图来做的。&lt;/p&gt;

&lt;h6&gt;利用深度信息计算图片投影&lt;/h6&gt;

&lt;p&gt;图片投影其实就是贴花的动态版，其做法也有很多种，我们在这里简单讲讲其中一种方法为:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    绘制一个box，其纹理的展示方式则以深度信息为依据，纹理贴近其绘制的模型上。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方式可以随着这个box的移动贴到不同物体上。&lt;/p&gt;

&lt;p&gt;大致的方向是，以一个BOX为渲染对象，渲染时在片元着色器中重新判定渲染纹理与渲染坐标。怎么判定呢？&lt;/p&gt;

&lt;p&gt;先从顶点着色器上获得顶点坐标的屏幕坐标，在片元着色器中传入的屏幕坐标时成了片元在屏幕上的坐标，用屏幕坐标获取对应的深度值，再让深度值作为z坐标来形成一个三维坐标，这时三维坐标只是屏幕空间上的坐标，我们让其屏幕空间转换到相机空间，再从相机空间转换到世界空间，再转换到投影空间，这样坐标就到了投影空间，再除以透视值，就得到坐标在0-1范围的坐标值，用这个值去提取纹理上的颜色，最后用这个颜色绘制片元。&lt;/p&gt;

&lt;p&gt;这个方法比较费的点为片元着色器中重新计算渲染坐标，这个坐标会以深度信息为z轴信息需要经过几个空间的转换，导致计算量比较大，不能放在顶点着色器中的原因是因为只有在片元着色器中才能得到片元深度信息。&lt;/p&gt;

&lt;h6&gt;贴花(喷图)&lt;/h6&gt;

&lt;p&gt;贴花的制作，可以以摄像机为节点向外计算一个长方体，所有与长方体有交集的模型上的面上的顶点都被存储起来，另外如果有顶点里外都有的面，则计算与长方体的面相交的新节点并加入进来，最后把所有得到的顶点和三角面制作成一个新的模型，这个模型的顶点转换到立方体空间再除以透视值，则成为了uv点，以此来呈现一个贴花(喷图)的效果。&lt;/p&gt;

&lt;p&gt;参考文献：&lt;/p&gt;

&lt;p&gt;《Unity3D ShaderLab 开发实战详解》&lt;/p&gt;

&lt;p&gt;《维基百科 Line–plane intersection》 https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection&lt;/p&gt;

&lt;p&gt;Planar Shadow http://qiankanglai.me/2016/12/23/planar-shadow/&lt;/p&gt;
</description>
               <pubDate>Tue, 10 Dec 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/12/10/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A610.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/12/10/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A610.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(四) - 多重采样以及着色器编译原理</title>
               <description>&lt;h3&gt;GPU上的多重采样(Multisampling)与反走样(Antialiasing)&lt;/h3&gt;

&lt;p&gt;多重采样(Multisampling)是一种对几何图元的边缘进行平滑处理的技术，也称为反走样技术之一。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;OpenGL支持几种不同的反走样技术，比如线段反走样，多边形反走样，纹理图像压缩的质量以及导数精度设置。事实上这几个反走样技术都是以开关的形式在OpenGL中存在，算法大致是将原本单一的线条或像素块周围填充更多的像素块，具体的填充算法细节比我们想象的要复杂的多，而且不同OpenGL是现在的算法中也有细微的差异，我们在这里不进行深入讨论。&lt;/p&gt;

&lt;p&gt;多重采样的工作方式是对每个像素的几何图元进行多次采样。在多次采样后，每个像素点不仅仅只是单个颜色(以及除了颜色外的深度值、模板值等信息)，还记录了许多样本值。&lt;/p&gt;

&lt;p&gt;这些样本值类似于将一个像素分拆成了更小型的像素，每个像素都存储着颜色、深度值、模板值等信息，当我们需要呈现最终图像的内容时，这个像素的所有样本值会被解析为最终像素的颜色。&lt;/p&gt;

&lt;p&gt;在Unity3D中对这方面的反走样功能也提供了支持，可以通过Quality Settings中的AntiAliasing来设置，它将启用图形接口(OpenGL或DirectX)中的多边形的反走样算法，并且开启多重采样，根据多重采样信息对多边形边缘进行像素填充。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    AntiAliasing 可以设置3档采样质量分别是 2倍, 4倍 and 8倍的多重采样。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;GPU上的反走样代价是消耗更多的GPU算力和显存，庆幸的它并不消耗CPU算力。&lt;/p&gt;

&lt;h3&gt;着色器编译过程与变体&lt;/h3&gt;

&lt;p&gt;我们在知道GPU渲染管线如何运作后，对着色器编译过程仍然需要知晓，我们还是以使用OpenGL为例来学习着色器在Unity3D中从编译到执行的全过程。&lt;/p&gt;

&lt;p&gt;着色程序的编译过程与C语言等编译语言的编译过程非常类似，只是C语言在编译时是以离线的方式进行，而着色器程序的编译则是当引擎需要时，通过引擎调用图形接口(OpenGL或DirectX)的方式来进行编译，整个应用程序只需要编译一次后面可以重复利用，这和我们通常所说的JIT(Just in time 即时编译)有点相似。&lt;/p&gt;

&lt;h6&gt;上面所说的这些都是图形引擎控制和执行的，也就是当需要某个着色器程序时Unity3D引擎通过判断是否存在已经编译好的着色器程序，来决定是否编译着色器代码或是重用已经编译好的着色器程序。&lt;/h6&gt;

&lt;p&gt;那么着色程序从编译到执行过程到底是怎样的呢？让我们来讲一讲。&lt;/p&gt;

&lt;p&gt;首先当引擎得知渲染需要用到的Shader不曾被编译过时，就会调用图形接口 glCreateShader 为着色器创建一个新的着色器对象。&lt;/p&gt;

&lt;p&gt;然后通过程序从Shader文件中获取Shader内容(字符串)并调用 glShaderSource 将源代码(字符串)关联到刚刚创建的着色器对象上。&lt;/p&gt;

&lt;h6&gt;这时着色器对象已经关联了源代码，我们可以通过调用图形接口的编译接口 glCompileShader 对这个着色器对象进行编译。&lt;/h6&gt;

&lt;p&gt;编译完成后，我们可以通过 glGetShaderInfoLog 来获得编译信息以及是否成功的结果。&lt;/p&gt;

&lt;p&gt;到此仅仅是某个着色器对象编译完成，这个着色器对象可能是顶点着色器，也可能是片元着色器，或也许是细分着色器或几何着色器。&lt;/p&gt;

&lt;p&gt;通常情况下，有好几个着色器需要编译，顶点着色器和片元着色器通常都成对出现，则会创建相应的着色器对象来分别编译它们的源代码。&lt;/p&gt;

&lt;p&gt;有了着色器对象还不够，我们需要把这些着色器关联起来。&lt;/p&gt;

&lt;p&gt;首先引擎会使用 glCreateProgram 需要创建一个空的着色器程序。&lt;/p&gt;

&lt;p&gt;然后多次调用 glAttachShader 来一个个地绑定着色器对象。&lt;/p&gt;

&lt;h6&gt;当所有必要的着色器对象关联到着色器程序之后，就可以链接对象来生成可执行程序了，调用 glLinkProgram 将所有关联的着色器对象生成一个完整的着色器程序。&lt;/h6&gt;

&lt;p&gt;当然，着色器对象也可能存在某些问题，因此在链接过程中依然可能失败，引擎通过 glGetProgramiv 来查询链接操作的结果，以及通过 glGetProgramInfoLog 接口来获取程序链接的日志信息，由此我们就可以判断错误原因。&lt;/p&gt;

&lt;p&gt;成功完成了着色器程序的链接后，引擎就可以通过调用 glUseProgram 来运行着色器程序。&lt;/p&gt;

&lt;p&gt;我们平常在Unity3D中用到的Shader中的Pass，每个Pass中都有着色器需要编译，因此每次在绘制不同的Pass时都会对Pass中的顶点着色器和片元着色器进行编译。也就是说，Unity引擎会为每个Pass标签生成一个着色器程序，生成这些着色器程序后，执行顺序仍然按照Pass的先后次序来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader_compile.jpg&quot; alt=&quot;着色器编译流程&quot;&gt;&lt;/p&gt;

&lt;h6&gt;除了着色器的编译流程外，Unity3D中的Shader Varant(变体)在实际开发中也是比较严重的问题&lt;/h6&gt;

&lt;p&gt;那么什么是“变体”呢。其实它是由Unity3D自身的宏编译指令引起的，它为不同情况而编译生成不同的着色器程序。从引擎端的说法来看，Unity3D把不同的编译版本拆分成了不同的着色器源代码，在运行时再通过图形接口将这些着色器源代码编译成不同的着色器程序。&lt;/p&gt;

&lt;p&gt;为什么要使用宏编译指令导致生成这么多的着色器程序呢？因为要简化Shader，让同一个Shader在不同材质球上的应用不同的效果时更加便捷，修改和完善起来也更加高效。&lt;/p&gt;

&lt;h6&gt;假如编写很多同一个风格但不同效果的Shader，在使用和维护过程中会造成诸多的麻烦和不便，为了统一风格，为了提高效率，也为了能更好的打通各部门之间的沟通渠道，以及能让美术同学能更好的发挥对画面效果的调整，将同一个风格不同效果的Shader写在同一个Shader文件里是必不可少的，这样能更加容易的统一美术风格和制作流程，目的就是为了让风格更加统一，沟通更加便捷，效率更加高。&lt;/h6&gt;

&lt;p&gt;那么我们来看看Unity3D是怎么通过编译指令来编写宏以及它是怎么生成着色器源代码的。&lt;/p&gt;

&lt;p&gt;Unity3D的Shader中使用&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#pragma multi_compile&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#pragma shader_feature&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两个指令来实现着色器程序的自定义宏，它既适用于顶点片元着色器也适用于表面着色器。&lt;/p&gt;

&lt;p&gt;在运行时，Unity3D会根据材质(Material)的关键字(Material的对象方法EnableKeyword和DisableKeyword)或者全局着色器关键字(Shader的类方法EnableKeyword和DisableKeyword)&lt;/p&gt;

&lt;p&gt;我们通过 multi_compile 指令编写例如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#pragma multi_compile A_ON B_ON&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;这样会生成并编译两个Shader(变体)，一个是A&lt;em&gt;ON的版本，一个是B&lt;/em&gt;ON的版本。&lt;/h6&gt;

&lt;p&gt;运行的时候Unity3D会根据材质(Material)的关键字或者Shader全局关键字判断应该使用哪个Shader，如果两个关键字都为false，那么会使用第一个(A_ON)Shader变体。&lt;/p&gt;

&lt;p&gt;我们也可以创建多个组合关键字例如:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#pragma multi_compile A B C&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#pragma multi_compile D E&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样会使得Shader的变体成倍的增加，例如上述的预编译方式，会生成 3x2 = 6 个变体，分别是 A+D、 B+D、 C+D、 A+E、 B+E、 C+E 六种。&lt;/p&gt;

&lt;p&gt;假如multi_compile组合多到10行，每行2个，就是2的10次方个Shader(变体)就是1024个，这样生成这1024个Shader(变体)，在打包时会耗费很长在变体的生成上的打包时间。&lt;/p&gt;

&lt;h6&gt;除了 multi&lt;em&gt;compile 之外，另外一个指令 shader&lt;/em&gt;feature 也可以设置预编译宏，与 multi&lt;em&gt;compile 的区别是 shader&lt;/em&gt;feature 不会将没有被使用到的Shader(变体)打包进包内，因此 shader&lt;em&gt;feature 更适合材质球的关键字指定预编译内容，因为Unity3D只生成和编译被使用的预编译情况，而 multi&lt;/em&gt;compile 更适合全局Shader指定关键字，因为它会把所有组合都编译一遍，无论有没有用到。&lt;/h6&gt;

&lt;p&gt;除了这两个自定义预编译指令，Unity3D 本身自带的一些内建的 multi_compile 的快捷写法也会导致Shader变体的产生：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    multi_compile_fwdbase 为前向渲染编译多个变体，不同的变体处理不同的光照贴图的计算，并且控制了主平行光的阴影的开关。

    multi_compile_fwdadd 为前向渲染额外的光照部分编译多个变体，不同的变体处理不同灯光类型，平行光，聚光灯，点光，以及他们附带的cookie纹理版本。

    multi_compile_fwdadd_fullshadows 和 multi_compile_fwdadd 一样，并且包含了灯光的实时阴影功能。

    multi_compile_fog 为处理不同的雾效类型（off/linear/exp/exp2）扩展了多个变体。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;总的来说，无论是 multi&lt;em&gt;compile 还是 shader&lt;/em&gt;feature 亦或内建预编译指令，都会造成 Shader(变体)数量的增多，使得打包时间增加，运行时编译次数增多。当Unity3D在运行时检测到需要渲染的材质球里是不曾被编译的Shader时，则会将与自己匹配的Shader变体拎出来编译一下生成一个着色器程序，因此为了应对变体在运行时的编译消耗，通常会在运行时提前将所有Shader变体编译一下，使得运行中不再有Shader编译的CPU消耗。&lt;/h6&gt;

&lt;p&gt;参考文献:&lt;/p&gt;

&lt;p&gt;《OpenGL编程指南》&lt;/p&gt;

&lt;p&gt;《Unit3D Documentation》 https://docs.unity3d.com/Manual/SL-MultipleProgramVariants.html&lt;/p&gt;
</description>
               <pubDate>Wed, 04 Dec 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/12/04/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A69.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/12/04/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A69.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(三) - 渲染原理与知识3</title>
               <description>&lt;h3&gt;GPU Instancing 的来龙去脉&lt;/h3&gt;

&lt;p&gt;GPU Instancing 初次听到这个名词时还有点疑惑，其实翻译过来应该是GPU多实例化渲染，它本身是GPU的一个功能接口，Unity3D将它变得更简单实用。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;前面讲过一些关于Unity3D的动态合批(Dynamic batching)与静态合批(Static batching)的功能，GPU Instancing 实际上与他们一样都是为了减少Drawcall而存在。&lt;/p&gt;

&lt;p&gt;有了动态合批和静态合批为什么还需要 GPU Instancing 呢，究竟他们之间有什么区别呢，我们不妨来简单回顾一下Unity3D动态合批(Dynamic batching)与静态合批(Static batching)。&lt;/p&gt;

&lt;h6&gt;开启动态合批(Dynamic batching)时，Unity3D引擎检测视野范围内的非动画物体(通过遍历所有渲染模型，计算包围盒在视锥体中的位置，如果完全不在视锥体中则抛弃)，如果在视锥体内并且符合条件的就进行合批操作，将他们的网格合并后与材质球一并传给GPU去绘制。&lt;/h6&gt;

&lt;p&gt;需要符合什么条件呢：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1，900个顶点以下的模型。

    2，如果我们使用了顶点坐标，法线，UV，那么就只能最多300个顶点。

    3，如果我们使用了UV0，UV1，和切线，又更少了，只能最多150个顶点。

    4，如果两个模型缩放大小不同，不能被合批的，即模型之间的缩放必须一致。

    5，如果是不同的材质球实例同样不能被合批，即使他们一模一样。即材质球属性不能被修改，材质球对象实例必须是同一个。

    6，如果他们有lightmap的数据，必须是相同的才有机会合批。

    7，多个pass的Shader是绝对不会被合批。

    8，延迟渲染是无法被合批。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;条件比较苛刻，一不小心就无法达到合并条件。为什么它要使用这么苛刻的条件呢，我们来了解下设计动态合批这个功能的意图。&lt;/p&gt;

&lt;h6&gt;动态合批(Dynamic batching)这个功能的目标是以最小的代价合并小型网格模型，减少Drawcall调用。&lt;/h6&gt;

&lt;p&gt;很多人会想既然合并了为什么不把所有的模型都合并呢，这样不是更减少Drawcall的开销。如果把各种情况的中大型网格都合并进来，就需要消耗巨大的CPU资源，而且在摄像机移动过程中，每帧都要进行合并网格的消耗，CPU算力消耗太大，得不偿失。于是Unity3D就对这种极其消耗CPU算力的功能做了如此多的的限制，就是为了让它在运作时性价比更高。&lt;/p&gt;

&lt;p&gt;与动态合批不同，静态合批(Static batching)并不实时合并网格，而是会在离线状态下生成合并的网格，所有被标记为静态物体的模型，只要拥有相同实例的材质球都会被一并合并成网格。&lt;/p&gt;

&lt;p&gt;静态合批有诸多优点，但也存在不少弊端。被合批的是静态物体，它们是不能被移动旋转和缩放的，也只有这样我们在离线状态下生成的网格才是有效的（离线的网格数据不需要重新计算），生成的离线数据被放在Vertex buffer和Index buffer中。&lt;/p&gt;

&lt;h6&gt;静态合批生成的离线网格将导致存放在内存的网格数据量剧增，因为在静态合批中每个模型都会独立生成一份网格数据，无论他们所使用的网格是否相同，也就是说场景中有多少个静态模型就有多少个网格，与原本只需要一个网格就能渲染所有相同模型的情况不一样了。&lt;/h6&gt;

&lt;p&gt;好处是静态合批后同一材质球实例(材质球实例必须相同，因为材质球的参数要一致)调用Drawcall的数量合并了，另外合批也不会额外消耗CPU算力因为它们是在离线时生成的合批数据(也就是网格数据)，在实时渲染时如果该模型在视锥体范围内，三角形索引被部分提取出来合并后提交，而那些早就被生成的网格将被整体提交(整体网格过大时则会导致CPU和GPU的带宽消耗过大)，最后再一并发送给GPU进行渲染。&lt;/p&gt;

&lt;h6&gt;简而言之，动态合批为了平衡CPU消耗和GPU性能优化，将实时合批条件限制在比较狭窄的范围内。静态合批则牺牲了大量的内存和带宽，以使得合批工作能够快速有效的进行。&lt;/h6&gt;

&lt;p&gt;GPU Instancing 没有动态合批对网格数量的限制，也没有静态网格需要这么大的内存，很好的弥补了这两者的缺陷，但也有存在着比较大的优缺点，我们下面来逐一阐述。&lt;/p&gt;

&lt;p&gt;GPU Instancing 并不像动态和静态合批那样通过对网格的合并操作进行优化，GPU Instancing 的目标是只用一个模型网格绘制很多个地方，这些地方绘制的网格缩放大小，旋转角度和坐标可以不一样，材质球虽然相同但材质球属性可以各自有各自的区别。&lt;/p&gt;

&lt;p&gt;本质上来说 GPU Instancing 调用的是 OpenGL 和 DirectX 里的多实例渲染接口。我们拿 OpenGL 来说:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;glDrawArraysInstanced&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLenum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLsizei&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Glsizei&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;primCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;glDrawElementsInstanced&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLenum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLsizei&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLenum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;indices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLsizei&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;primCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;glDrawElementsInstancedBaseVertex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLenum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLsizei&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLenum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;indices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLsizei&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instanceCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLuint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baseVertex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这三个接口正是 GPU Instancing 调用多实例渲染的接口，第一个是无索引的顶点网格集多实例渲染，第二个是索引网格的多实例渲染，第三个是索引基于偏移的网格多实例渲染。调用这三个接口会向GPU传入渲染数据并开启渲染，与平时渲染多次要多次执行整个渲染管线不同的是，这三个接口会分别将模型渲染多次，并且是在一个渲染管线内。&lt;/p&gt;

&lt;p&gt;如果只是一个坐标上渲染多次模型是没有意义的，我们需要将一个模型渲染到不同的多个地方，并且以不同的缩放大小和旋转角度，以及不同的材质球参数，这才是我们真正需要的。&lt;/p&gt;

&lt;p&gt;GPU Instancing 正我们提供这个功能，上面三个渲染接口告知Shader着色器开启一个叫 InstancingID 的变量，这个变量可以确定在着色计算时使用哪个实例的属性。&lt;/p&gt;

&lt;p&gt;有了这个 InstancingID 就能使得我们在多实例渲染中，辨识到底使用哪个属性参数。Shader的顶点着色器和片元着色器可以通过这个变量来获取模型矩阵、颜色等不同变化的参数。&lt;/p&gt;

&lt;p&gt;我们来看看Unity3D是怎么做的:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shader&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;SimplestInstancedShader&amp;quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Properties&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_Color&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Color&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;SubShader&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Tags&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;RenderType&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Opaque&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;LOD&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;CGPROGRAM&lt;/span&gt;
            &lt;span class=&quot;cp&quot;&gt;#pragma vertex vert&lt;/span&gt;
            &lt;span class=&quot;cp&quot;&gt;#pragma fragment frag&lt;/span&gt;
            &lt;span class=&quot;cp&quot;&gt;#pragma multi_compile_instancing&lt;/span&gt;
            &lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;quot;UnityCG.cginc&amp;quot;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;appdata&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;vertex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;POSITION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;UNITY_VERTEX_INPUT_INSTANCE_ID&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//顶点着色器的 InstancingID定义&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;vertex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SV_POSITION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;UNITY_VERTEX_INPUT_INSTANCE_ID&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//片元着色器的 InstancingID定义&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;UNITY_INSTANCING_BUFFER_START&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 定义多实例变量数组&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;UNITY_DEFINE_INSTANCED_PROP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;UNITY_INSTANCING_BUFFER_END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;appdata&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

                &lt;span class=&quot;n&quot;&gt;UNITY_SETUP_INSTANCE_ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//装配 InstancingID&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;UNITY_TRANSFER_INSTANCE_ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//输入到结构中传给片元着色器&lt;/span&gt;

                &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UnityObjectToClipPos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;fixed4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SV_Target&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;UNITY_SETUP_INSTANCE_ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//装配 InstancingID&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;UNITY_ACCESS_INSTANCED_PROP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//提取多实例中的当前实例的Color属性变量值&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ENDCG&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述是一个很普通的调用 Instancing 的Shader，其中&lt;em&gt;Color 和 unity&lt;/em&gt;ObjectToWorld (模型矩阵)是多实例化的，他们通过 InstancingID 索引来确定取数组中的哪个变量。&lt;/p&gt;

&lt;p&gt;为什么这么说呢？我们来看看Shader中这些包含有 INSTANCE 字样的宏定义。&lt;/p&gt;

&lt;p&gt;首先编译命令 multi&lt;em&gt;compile&lt;/em&gt;instancing 会告知着色器我们将会使用多实例变量。&lt;/p&gt;

&lt;p&gt;其次在顶点着色器和片元着色的输入输出结构中，加入 UNITY&lt;em&gt;VERTEX&lt;/em&gt;INPUT&lt;em&gt;INSTANCE&lt;/em&gt;ID 告知结构中多一个变量即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    uint instanceID : SV_InstanceID;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每个顶点和片元数据结构中都定义了 instanceID 这个变量，这个变量将被用于确定使用多实例数据数组中的哪个实例参数，很关键。&lt;/p&gt;

&lt;p&gt;接着Shader中要把需要用到的多实例变量参数定义起来:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;UNITY_INSTANCING_BUFFER_START&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;UNITY_DEFINE_INSTANCED_PROP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;UNITY_INSTANCING_BUFFER_END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述中的宏很容易从字面看出它们为&amp;quot;开始多实例宏定义&amp;quot;，&amp;quot;对多实例宏属性定义参数&amp;quot;，以及&amp;quot;结束多实例宏定义&amp;quot;。&lt;/p&gt;

&lt;p&gt;这三个宏定义我们可以在 UnityInstancing.cginc 中看到，即:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class=&quot;cp&quot;&gt;#define UNITY_INSTANCING_BUFFER_START(buf)      UNITY_INSTANCING_CBUFFER_SCOPE_BEGIN(UnityInstancing_##buf)&lt;/span&gt;
        &lt;span class=&quot;cp&quot;&gt;#define UNITY_INSTANCING_BUFFER_END(arr)        UNITY_INSTANCING_CBUFFER_SCOPE_END&lt;/span&gt;
        &lt;span class=&quot;cp&quot;&gt;#define UNITY_DEFINE_INSTANCED_PROP(type, var)  type var[UNITY_INSTANCED_ARRAY_SIZE];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以上述的宏定义中理解到，这三个宏可以对多实例的多属性数组进行定义。&lt;/p&gt;

&lt;p&gt;于是在顶点着色器与片元着色中，我们对 InstancingID 进行装配，即宏定义：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    UNITY_SETUP_INSTANCE_ID(v) 和 UNITY_SETUP_INSTANCE_ID(i);

    装配过程其实就是从基数偏移的过程 unity_InstanceID = inputInstanceID + unity_BaseInstanceID;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终我们通过 UNITY&lt;em&gt;SETUP&lt;/em&gt;INSTANCE&lt;em&gt;ID 装配得到了 unity&lt;/em&gt;InstanceID 即当前渲染的多实例索引ID。&lt;/p&gt;

&lt;p&gt;有了多实例的索引ID，我们就可以通过这个变量获取对应的当前实例的属性值，于是就有了以下的宏定义 UNITY&lt;em&gt;ACCESS&lt;/em&gt;INSTANCED_PROP 以及通过这个宏定义获取变量的代码。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#define UNITY_ACCESS_INSTANCED_PROP(arr, var)   var[unity_InstanceID]&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;UNITY_ACCESS_INSTANCED_PROP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//提取多实例中的当前实例的Color属性变量值&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;有了类似_Color的多实例属性操作，在模型矩阵变化中也需要具备同样的操作，我们没看到模型矩阵多实例是因为Unity在Shader编写时用宏定义把它们隐藏起来了，它就是 UnityObjectToClipPos。&lt;/h6&gt;

&lt;p&gt;UnityObjectToClipPos 其实是一个宏定义，当多实例渲染开启时，它被定义成了如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#define unity_ObjectToWorld     UNITY_ACCESS_INSTANCED_PROP(unity_Builtins0, unity_ObjectToWorldArray)&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;UnityObjectToClipPosInstanced&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UNITY_MATRIX_VP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unity_ObjectToWorld&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;UnityObjectToClipPosInstanced&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UnityObjectToClipPosInstanced&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define UnityObjectToClipPos UnityObjectToClipPosInstanced&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个定义也同样可以在 UnityInstancing.cginc 中找到，其中unity_ObjectToWorld是关键，它从多实例数组中取出了当前实例的模型矩阵，再与坐标相乘后计算投影空间的坐标。也就是说当开启 Instancing 多实例渲染时，UnityObjectToClipPos 会从多实例数据数组中取模型矩阵来做模型到投影空间的转换。而当不开启 Instancing 时，UnityObjectToClipPos 则只是用当前独有的模型矩阵来计算顶点坐标投影空间的位置。&lt;/p&gt;

&lt;p&gt;到此我们就从着色器中获取了多实例的属性变量，根据不同实例的不同索引获取不同属性变量包括模型矩阵，从而渲染不同位置，不同的旋转角度，不同的缩放大小，以及更多比如_Color的其他属性，整个过程都是围绕着 InstancingID 来做索引操作。&lt;/p&gt;

&lt;h6&gt;知道了 GPU Instancing 是如何渲染还不够，我们还要知道数据是怎么传进去的。&lt;/h6&gt;

&lt;p&gt;我们还是拿 OpenGL 接口编程来分析。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//获取各属性的索引&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;glGetAttribLocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;position&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normal_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;glGetAttribLocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;normal&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;glGetAttribLocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;color&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matrix_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;glGetAttribLocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;model_matrix&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//按正常流程配置顶点和法线&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glBindBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_ARRAY_BUFFER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position_buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//绑定顶点数组&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glVertexAttribPointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_FLOAT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//定义顶点数据规范&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glEnableVertexAttribArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//按上述规范，将坐标数组应用到顶点属性中去&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glBindBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_ARRAY_BUFFER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normal_buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//绑定发现数组&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glBertexAttribPointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;normal_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_FLOAT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//定义发现数据规范&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glEnableVertexAttribArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;normal_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//按上述规范，将法线数组应用到顶点属性中去&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//开始多实例化配置&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//设置颜色的数组。我们希望几何体的每个实例都有一个不同的颜色，&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//将颜色值置入缓存对象中，然后设置一个实例化的顶点属性&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glBindBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_ARRAY_BUFFER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color_buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//绑定颜色数组&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glVertexAttribPointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_FLOAT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//定义颜色数据在color_loc索引位置的数据规范&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glEnableVertexAttribArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//按照上述的规范，将color_loc数据应用到顶点属性上去&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;glVertexattribDivisor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//开启颜色属性的多实例化，1表示每隔1个实例时共用一个数据&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;glBindBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_ARRAY_BUFFER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model_matrix_buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//绑定矩阵数组&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//设置矩阵第一行的数据规范&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glVertexAttribPointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matrix_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_FLOAT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mat4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vec4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//将第一行的矩阵数据应用到顶点属性上去&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glEnableVertexAttribArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matrix_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//开启第一行矩阵数据的多实例化，1表示每隔1个实例时共用一个数据&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glVertexattribDivisor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matrix_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个示例很精准的表达了数据是如何从CPU应用层传输到GPU上再进行实例化的过程。&lt;/p&gt;

&lt;p&gt;我在代码上做了比较详尽的注释，首先获取需要推入顶点属性的数据的索引，再将数组数据与OpenGL
缓存进行绑定，这样才能注入到OpenGL里去，接着告诉 OpenGL 每个数据对应的格式，然后再根据前一步描述的格式应用到顶点属性中去，最后如果做的是 GPU Instancing 多实例的属性数据则开启多实例化属性接口，让 InstancingID 起效。&lt;/p&gt;

&lt;h6&gt;总结，我们解析了 GPU Instancing 在 Unity3D 中的工作方式，得知了它能用同一个模型同一个材质球渲染不同的位置、角度、缩放大小、以及不同颜色等属性。这种没有对模型网格数量限制，没有占用大量内存的性能优化来说，很好的弥补了动态合批(Dynamic batching)与静态合批(Static batching)的不足。&lt;/h6&gt;

&lt;p&gt;但是它毕竟是只能围绕一个模型来操作，只有相同网格(Mesh)和相同的材质球实例(参数可以不同，但必须使用API来设置不同参数)的情况下才能做到多个实例在同一个渲染管线中一次性渲染的优化操作，而动态合批和静态合批却只需要材质球实例一致，网格是可以有差别的。&lt;/p&gt;

&lt;h6&gt;三者利弊各不同，有互相弥补的地方，各自本身也存在着不同程度的限制和优缺点。从整体上来看，GPU Instancing 更适合同一个模型渲染多次的情况，而动态合批(Dynamic batching)更适合同一个材质球并且模型面数小的情况，静态合批(Static batching)更适合当我们能容忍内存扩大的情况。&lt;/h6&gt;
</description>
               <pubDate>Wed, 20 Nov 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/11/20/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A68.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/11/20/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A68.html</guid>
            </item>
        
            <item>
               <title>思路探讨(三十一) 钱、才、运</title>
               <description>&lt;p&gt;最近几年一直在突破自己的认知，可能是我本身从小对世界的认知水平就比较狭小的缘故，努力了好几年才只是普通人的水平，但对我来说已经是很厉害了，我很满足，山外有山，人外有人，一山还有一山高，一水还有一水深，做好自己最重要。&lt;/p&gt;

&lt;p&gt;从小到大一直无法想明白的一件事是，‘有才’为什么不一定有钱，有钱人为什么不是因为‘有才’才赚到钱。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h6&gt;后来才渐渐明白，这是我人生中一个比较大的认知错误，认为钱和才是对等的。&lt;/h6&gt;

&lt;p&gt;钱和才，虽然谈不上完全是两码事，但他们之间的联系确实没有这么紧密，不过‘有才’至少能让你解决温饱问题。&lt;/p&gt;

&lt;h6&gt;一个人有价值(就是有知识，有技能，有经验)和赚到大钱是两码事，很多时候有价值的人能被人看重，但并不一定能赚到钱，因为公司或者说组织不一定能成事，他是厉害了，周围的人不配合不协作，各怀鬼胎，一个人再厉害也无法扭转乾坤，即使周围的人协同性很好而时代潮流不配合也同样无济于事。&lt;/h6&gt;

&lt;p&gt;所以想要赚到大钱，‘天时、地利、人和’一样不能少，这个就是我们俗称的‘运气’。说起来很俗气，‘运气’很神秘，就像神棍一样，没有科学的依据，但确实这个东西真真正正存在我们的周围。&lt;/p&gt;

&lt;p&gt;这个‘运气’，有两种诠释：&lt;/p&gt;

&lt;h6&gt;一种是像稻盛和夫(日本经营之神，创业百分百成功，做什么成什么，企业破产了求他接手，立刻妙手回春)这类的，认为‘运气’是靠自己争取来的，以精神世界为中心，自己积善行德才能积攒足够多的‘运气’，用利他心态来做事，加上不屑努力，最后全社会都会回馈给他以‘运气’，最终靠着这股‘运气’走上成功的道路。&lt;/h6&gt;

&lt;p&gt;另一种是认为‘运气’是随机，就像守株待兔里的农夫，指不定什么时候兔子就自己撞到枪口上了就能有一顿饱肉吃，也像彩票的中奖概率，不知道什么时候就来那么一下，你就什么都有了。&lt;/p&gt;

&lt;p&gt;这两种我更偏向于稻盛和夫的理念，我也一直向他老人家在学习，用利他的心态做事，不屑努力，来感动全宇宙的量子(这个说法是从一本叫做《The Secret》中文叫秘密里看到的，它其实是一部鸡汤成功学的书，它告诉你其实全世界都是量子，你只要拿出你的诚意并且全力拼搏，量子就会被你吸引来帮助你)。&lt;/p&gt;

&lt;p&gt;我们不偏执任何一种，事实上两种都存在，既有自身的因素，也有随机的因素。&lt;/p&gt;

&lt;p&gt;随机的运气也并不是我们表面上看上去那么容易，它很多时候都需要毅力支撑。毅力二字是大多数人成功的秘诀，即使日子再苦再累再无趣，受压迫得再厉害，如果依然能够扛得住，运气就有可能降临到他们身上。&lt;/p&gt;

&lt;p&gt;为什么？因为风险是波动的，当震荡加剧，波幅增大，低谷更低，时间更长时，精神上和肉体上的压力就会增大，无法承受导致崩溃消亡也是正常的现象。大部分人无法承受这种非人的精神压力都选择了退缩，但只要扛过去，通常都是拨云见日，柳暗花明又一村，只是人是脆弱的，99%都选择了退缩，那最后1%中也有一半中途崩溃了，最后剩下的才是苦字熬出头的人，最终运气降临在他们身上，这种看似运气而实非运气的事也很常见。&lt;/p&gt;

&lt;h6&gt;这个世界还是公平的，我们无法把控的‘运气’确实占了成功因素的很大一部分，也只有这样才不是任何人想怎么样就怎么样的么，王思聪有钱有人有才，理论上说没有失败的理由，实际上，他开的公司，创的业，投资标的，不照样该垮的还是垮，”不经历风雨怎能见彩虹，没有人能随随便便成功“。&lt;/h6&gt;

&lt;p&gt;说实在的，我们可以避开赚钱二字不谈，人不一定要赚到足够多的钱才会幸福。&lt;/p&gt;

&lt;p&gt;“没有赚到钱的人生也能幸福”这句话很多人不理解。因为人们把钱看得太重，以至于认为成功就是有钱，有钱才能幸福，把三者划上了等号。&lt;/p&gt;

&lt;p&gt;这个偏执的观念会让人变得很痛苦，人常常会被欲望所控制，越想有钱，越痛苦，越不幸福，是一个恶性循环的开始。&lt;/p&gt;

&lt;h6&gt;我们应该坦然一点才是。​我希望我们能想明白，我们赚钱的目的是什么，如果是养家糊口，那是应该的。如果是追求富足的生活，我觉得该量力而行，别最后钱没赚到人没了情也没了，或者钱有了情没了身体没了，都得不偿失。如果是追求更高的精神境界，我觉得应该有计划的，有进也有退的，以更加稳健的姿态走向目标。&lt;/h6&gt;

&lt;p&gt;我在知乎的问答里看到这么一句话，虽然偏题了但我觉得挺值得深思，他说：”如果一个人到了40几岁，夫妻感情好，每个周还能有性生活，孩子学习成绩好，全家人身体强壮有力，这就是成功“，体会一下。&lt;/p&gt;
</description>
               <pubDate>Sat, 09 Nov 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/11/09/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A831.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/11/09/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A831.html</guid>
            </item>
        
            <item>
               <title>思路探讨(三十) 改变自己才能改变孩子</title>
               <description>&lt;p&gt;这4年半的父亲生涯着实让我改变了很多，我从我的女儿身上学到了很多很多东西。&lt;/p&gt;

&lt;p&gt;我知道她是我的镜子，我不经意间的坏习惯都能在她的身上放大很多倍，每次责备她时我都会想到自己的问题，让我心生愧疚。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;我着实明白孩子是张白纸，大部分的行为方式都是从我们日常的行为中学到，她没有这么多的经历和生活经验，所以也无法判断好与坏，只是顺着我们行为方式照着模仿罢了。&lt;/p&gt;

&lt;h6&gt;只是我们也很讨厌我们自己，大部分时候我们自己知道的自己的缺陷和自卑，而通常自己选择了原谅自己，而大部分时候无法原谅孩子有同样的问题。&lt;/h6&gt;

&lt;p&gt;这就像我们生活和工作中那样，总是拿自己做不到的事情来要求别人，我一直记得一句话：对别人是马克思主义，对自己却是自由主义。&lt;/p&gt;

&lt;p&gt;所以我想到了改变自己，我想让女儿知道，并且以自己的行为方式和思维方式让女儿知道，“我们应该怎样做才是正确的，并且做正确的事有很多很多的好处。”&lt;/p&gt;

&lt;p&gt;在正确的道路上行走着实不容易，就像我们以前在学校里上课学习那样，平时的上课学习着实枯燥乏味，如果没有小伙伴能与你一起共同努力共同学习共同生活，我们很难在读书学习这条路上直线的走下去，总是会把注意力跑偏向更加有趣的事物上去。&lt;/p&gt;

&lt;p&gt;因此我知道她要有个伴，这个伴至少应该是个精神上的伙伴，如果还能成为生活中的伙伴那是最好不过的了。(通常我的工作并不允许经常性的陪伴在她身边，但一有时间我就围绕着她)&lt;/p&gt;

&lt;p&gt;我们也像大部分父母那样严格要求女儿去纠正自己的行为习惯，不同的是我们还是觉得我们需要以洞察和理解人性的角度来对待我的女儿，只因为我深刻的认识到其实我们大部分时候，知道和明白她所要做的事情很难突破，很枯燥，很复杂，连我们自己都无法做到，却让孩子去完成。&lt;/p&gt;

&lt;h6&gt;不过无论对女儿有多心疼，多理解，我还是没有放弃对孩子正确的行为习惯和思维方式的教育，只是我想换种方式，我希望这种方式更加彻底，我也明白这种方式的艰难程度。&lt;/h6&gt;

&lt;h6&gt;抱着这种既要女儿纠正行为习惯，要学习，要突破，也同时要理解女儿是我们自己缺点和自卑心理写照的心态，我希望自己走上改变自我再影响她的路线。&lt;/h6&gt;

&lt;p&gt;于是，“改变自己，同时改变女儿，我优秀了女儿也会优秀”，成为了我的教育理念。&lt;/p&gt;

&lt;p&gt;这个教育理念是从我这些年对社会的理解和反思的所得。&lt;/p&gt;

&lt;p&gt;那么我应该怎么改变自己，改变成什么样才是对的。如果我的方向错了，或者偏了，改变的最终效果还是会有问题。&lt;/p&gt;

&lt;p&gt;于是我把这个问题的思考引向了，改变自己到什么样才是对的这个问题上。&lt;/p&gt;

&lt;h6&gt;我首先发现的是安心的心理环境是促成的理智心理的重要因素。&lt;/h6&gt;

&lt;p&gt;理智沉稳的心理状态对学习和生活都是非常有效的帮助。相反，焦躁、恐惧、不安的心态时常会导致效率低下，无法集中注意力，思考的角度也会变得狭窄和阴暗。&lt;/p&gt;

&lt;p&gt;于是我首先让自己时常保持理智，尽量减少情绪的波动，心平气和的与女儿对话，让她感觉到这个氛围是平和的。&lt;/p&gt;

&lt;p&gt;我希望创造一种环境，这种环境中，女儿能很好的思考，包括自己的问题，和别人的问题，环境对她只有促进作用而不是阻碍作用，因此我首先要保证我是理智的，平和的，否则她的思维习惯会跑偏。&lt;/p&gt;

&lt;h6&gt;其次我发现最应该原谅的是别人而不是自己，最应该去帮助别人而不是期待别人的帮助。&lt;/h6&gt;

&lt;p&gt;我们大部分时候都觉得，自己没问题，全是别人的错。这其实是人性的弱点，我们最容易原谅的是自己，最容易责备的是别人，也最容易把希望寄托在别人身上，而自己什么都不做。&lt;/p&gt;

&lt;p&gt;原谅应该更多的体现在对待别人上，只有原谅了别人，事情才会有进展。教育女儿也是一样，我更多的选择理解和原谅女儿的缺点和坏习惯，理解并且明白在困难面前人都是软弱的。&lt;/p&gt;

&lt;p&gt;帮助则更应该体现在对待别人身上，只有通过帮助别人，事情才会有十足的推进。教育女儿也是一样，我更多的去辅助女儿改掉坏习惯，在对她面对的困难的理解之上，逐步纠正她的缺点与习惯，而不是逼迫她。&lt;/p&gt;

&lt;h6&gt;我发现对精神世界改造的重要性&lt;/h6&gt;

&lt;p&gt;面对这个充满焦虑的时代，欲望与恐惧充斥着满世界，我们时常都会不由自主的随波逐流的被世界带着走，被金钱、名誉、权利、地位所吸引，被捆绑，被遏制。&lt;/p&gt;

&lt;p&gt;我反复思考着我们最终人生的意义，我想它肯定不是这些金钱、名誉、权利、地位这些东西，虽然是它们都是我们所渴望的、期盼的，也是避不开的实实在在的‘必需品’。&lt;/p&gt;

&lt;p&gt;但它们毕竟是靠机缘巧合出现的，也时常机缘巧合的消失(眼看他起高楼，眼看他宴宾客，眼看他楼坍塌的事数不甚数)，唯有精神力量才会一直存在下去。&lt;/p&gt;

&lt;h6&gt;精神力量能让我们在面对幸运时更加稳健，在面对低谷时更加冷静沉着，也只有精神力量才能让我们更加持久、幸福、并且优秀的生活下去。&lt;/h6&gt;

&lt;p&gt;于是我希望改造自己成为精神力量的源泉，而不是精神力量的消耗者，锻炼自己拥有更加强大的毅力、耐力、抵抗力，并且将这颗精神力量的种子种在女儿身上，始终鼓励她勇敢的挑战自己，突破自己，让她变得坚强、勇敢、积极乐观。&lt;/p&gt;

&lt;h6&gt;我发现人生中无论大小孩，积累对我们的重要性&lt;/h6&gt;

&lt;p&gt;我发现社会是由‘积累’构成的，无论是财富，名誉，智慧，知识，经验，都是逐日积累而成，而不是一蹴而就的。&lt;/p&gt;

&lt;p&gt;就因为不是一蹴而就的，所以才形成了一种牢固的‘优势’，这种‘优势’不是一日所成(人们总是幻想着能拼几天几星期几个月就能换来‘优势’)，也并不会因一日所垮。‘劣势’或者说坏习惯，也同样不是一蹴而就的，也是通过日复一日，年复一年的积累而成，我们时常担心着潮流会瞬息间转向导致自己无法适应。&lt;/p&gt;

&lt;h6&gt;于是我提出了“每日一小步，每年一大步”的生活和学习理念，我不但要自己每日践行这种自律的理念，也希望女儿心中也能逐步体会到积累的重要性，在我们生活中，每天都积累一些小优势，每年就能积累一个大优势，年复年的坚持下去，最终我和她都将得益于积累，也得以于自律。&lt;/h6&gt;

&lt;h6&gt;对女儿的教育始终源自于我对人性的洞察，我们无法避免的承受着各种各样的缺点和自卑的情节，有时我也原谅自己，但始终未放弃前进，我希望最终我的努力奋进和自我突破的意识，能感动女儿，在她心中种下一颗小小的种子，这颗种子在她潜意识里生根发芽。&lt;/h6&gt;

&lt;h6&gt;女儿的性格是我性格的写照，女儿的习惯是我生活中的点滴所形成的，“改变女儿最有效的方式就是改变自己”这句话始终刻印在我心中，警醒着我不断向更好的自己，更好的家庭，更好的未来前进。&lt;/h6&gt;
</description>
               <pubDate>Mon, 04 Nov 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/11/04/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A830.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/11/04/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A830.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第五章，资源的加载与释放</title>
               <description>&lt;p&gt;我们在计算机上编程，始终逃不过计算机的体系范围。对于计算机来说不过是进程，线程，CPU，CPU缓存，内存，硬盘，GPU，GPU显存，我们在编程和优化时始终围绕着这个几个关键点在做文章。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;从计算机宏观的角度上来看，计算机本身的内容就这么些，假如我们暂时不去细想具体的逻辑细节，我们可以从大体上明白我们需要做的工作与这些内容有多大的关系。&lt;/p&gt;

&lt;p&gt;我们制作的软件运行在进程上，所以进程是我们的载体，线程可以分担进程的负担，有利于我们更大限度的利用多核CPU，这样就有不只一个CPU为我们工作。&lt;/p&gt;

&lt;p&gt;在PC下CPU的负荷是由多个进程的消耗所组成的但我们只需要关心我们自己进程的消耗，它大部分都是由业务逻辑、算法，内存分配与回收等程序运行所造成的消耗。&lt;/p&gt;

&lt;p&gt;CPU缓存的存在增加了CPU执行命令的命中率，使得CPU执行效率提高。只是CPU只认机器码由1和0组成的命令组合，于是在CPU之上又有了汇编这种语言做中间件，使得我们能够不用去记住0和1的世界，只是这个中间件还需要操作寄存器等直面硬件的事务让我们觉得还是太繁琐。对于庞大的软件系统来说人类无法承受如此庞大复杂度系统下的调试之苦，于是就有了更高级的语言+编译器来让编程变得更加简单，编译器它翻译了我们能容易识别的各种语言包括C++、Java、C#等，它先翻译成中间语言再将中间语言翻译成的二进制码被CPU识别。&lt;/p&gt;

&lt;p&gt;这些高级语言能够让人类更加专注于编写复杂和庞大的软件系统，从而解放了我们直面硬件的痛苦。Unity3D引擎从这层意义上来说也是做了同样的事情，它将大部分对OpenGL/DirectX等图形接口底层的调用都封装好了等我们去用，解放了我们需要学习枯燥复杂的底层的时间，可以将更多的注意力放在对业务逻辑的框架结构和逻辑上。但是在我们制作过程中始终绕不过去的是硬件的工作流程和方式，如果我们想要编写更加优秀的程序，就得学习和理解这些底层原理，也只有这样才能明白我们在编写具体框架逻辑中对计算机是有利还是有弊。&lt;/p&gt;

&lt;p&gt;内存是除了CPU缓存外最快的数据存取地点了，所以要想更快的取得内容就要更多的借助内存，不过也不能无止境的使用内存，比如我们的移动设备，在手机中内存还不是那么廉价或者说容量还不足以可以肆无忌惮的任意使用，即使是PC上内存已经足够大了也要考虑到其他软件进程的内存消耗，不能只顾自己进程的霸占更多内存。&lt;/p&gt;

&lt;p&gt;硬盘在现代已经是很廉价了，硬盘占用的大小已经很少被大家所诟病，不过背后却需要考虑宽带问题。虽然硬盘廉价，但宽带并没有那么廉价，大部分对磁盘的占用都需要从网络上下载下来，这种宽带的占用量其实是紧张的，因此我们经常需要约束对硬盘的占用量，就是为了考虑下载时更多的节省宽带的占用量。&lt;/p&gt;

&lt;p&gt;GPU对CPU的优势是对图形图像的处理比CPU更加强大，它的主要架构和运行模式都是为图形图像而生的，CPU常将大部分图形图像处理都交给GPU去做。从前都是CPU自己处理图形图像，但现代社会中GPU已经不像是以前那么昂贵了，成本已经到了平民化的水平，GPU也已经完全普及在各大设备中。即使是GPU普及的情况下，但GPU的性能好坏也是参差不齐，我们依旧要尽最大的努力去学习和理解GPU的运作原理，以在利用GPU算力时尽可能得发挥其最大优势，以及降低无用的等待与消耗。&lt;/p&gt;

&lt;p&gt;虽然移动设备架构的设计没有将显存加入进去，但显存在PC上却是运用的玲离尽致，显存也确实让GPU在工作效率上升了一个台阶，就像CPU的缓存一样，显存让GPU得到数据和处理数据的效率更高。&lt;/p&gt;

&lt;h6&gt;前面的章节说了这么多关于算法、框架、结构、数学、图形学等，我希望能用更大的角度来观察总结我们所天天需要接触的编程工作。每条语句，每个结构，每个编码都能知道我们现在所要围绕的是哪个节点，是否能通过节点优化来让当前程序的执行更加高效，让程序跑在设备上时更加流畅。&lt;/h6&gt;

&lt;h6&gt;说了这些关于计算机本身的事，寓意是想从宏观的角度看问题，抛开具体的架构、系统逻辑、框架结构等细节来看看我们所面对的工作到底是个怎样的世界。从根本上看我所说这些并不是什么特别具体底层的东西，但是也可以从另一个角度了解我们所面对的编程工作，对我们未来的技术方向会有很大的帮助。&lt;/h6&gt;

&lt;h3&gt;前面讲了很多关于计算机本质的东西，这节我们主要来讲一下关于资源的内容。&lt;/h3&gt;

&lt;h3&gt;资源加载的多种方式&lt;/h3&gt;

&lt;p&gt;虽然资源的格式并不一定要依照引擎来，但如果自己另开辟一种格式来做为自定义资源格式确实耗时耗力，性价比很难适合，虽然也要按项目的需求来，如果是那种资源保密性要求很强的，其实也可以借助Unity3D自身的机制来完成加密工作(下面的章节中会介绍加密)。&lt;/p&gt;

&lt;p&gt;这里我们还是主要来说说以Unity3D自身格式为重点的资源加载方式。&lt;/p&gt;

&lt;p&gt;我们可以把资源加载分为阻塞式和非阻塞式。到底什么是阻塞式什么是非阻塞式呢？&lt;/p&gt;

&lt;p&gt;简单来说，阻塞是当前资源加载完了才能执行下一条语句，非阻塞是开另一个线程(或协程)加载资源，当前的主线程可以继续执行程序，当加载完毕时再通知主线程。&lt;/p&gt;

&lt;p&gt;在Unity3D中阻塞式的加载主要有：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1.Resource.Load
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Resource.Load是传统的资源加载方式，Unity3D通过Resources这个名字的文件夹来加载资源。&lt;/p&gt;

&lt;p&gt;在移动设备下，Unity3D打包了Resources文件夹的所有资源文件成为1个或几个资源文件(是资源文件合并成1个或几个资源包文件)放入包内，当调用Resource.Load时从这几个资源文件中加载。&lt;/p&gt;

&lt;h6&gt;这个资源包文件会被Unity3D在打包时压缩，保证了包体的大小会适度的减少，压缩的另一面是解压，因此在通过Resource.Load加载时也增加了解压的CPU损耗。这也是很多项目不乐意使用Resources的缘由，解压消耗带给他们不必要的开销，因为CPU资源比硬盘资源珍贵的多。&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    2.File read + AssetBundle.CreateFromMemory + AssetBundle.Load
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们也可以先通过文件操作加载资源文件，再通过AssetBundle.CreateFromMemory的方式把byte数据转换成AssetBundle格式，再通过AssetBundle.Load从AssetBundle中加载某个资源。&lt;/p&gt;

&lt;h6&gt;这种方式看起来费时费力，但是这种方式可以加入我们些许自定义功能。比如能在加载AssetBundle前做加解密操作，加载AssetBundle前自主加载了文件，文件的数据的加解密方式就可以自由的把控，我们可以先用文件操作获得数据后解密，再转换成AssetBundle实例，最后交给资源控制程序处理。&lt;/h6&gt;

&lt;p&gt;不过获得加解密AssetBundle的能力，是需要付出代价的，代价就是内存和GC(内存的分配与销毁)。&lt;/p&gt;

&lt;p&gt;由于用文件操作时完全读入了整个文件的数据，导致当前还不需要的资源也一并读入内存，增大了内存消耗，另外转换成AssetBundle后的byte数据也不再由用处，等待GC的消耗动作，大大增加了内存分配和销毁的CPU负荷。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    3.AssetBundle.CreateFromFile + AssetBundle.Load
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们还可以使用通过直接加载文件变成AssetBundle的方式，再通过AssetBundle.Load接口来获得资源。&lt;/p&gt;

&lt;p&gt;这种加载方式最大的好处是按需分配内存。AssetBundle.CreateFromFile并不会把所有资源文件整个加载进内存中，而是先加载数据头，通过数据头中的数据去识别各个资源在文件中的偏移位置，当调用AssetBundle.Load时，根据数据头中对应资源偏移量的记录，找到资源位置，加载数据进入内存，因此我们说它是按需分配内存的。&lt;/p&gt;

&lt;p&gt;在Unity3D中非阻塞式的加载有：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1.AssetBundle.CreateFromFile + AssetBundle.LoadAsync
    2.WWW + AssetBundle.Load
    3.WWW + AssetBundle.LoadAsync
    4.File Read all + AssetBundle.CreateFromMemory + AssetBundle.Load
    5.File Read all + AssetBundle.CreateFromMemory + AssetBundle.LoadAsync
    6.File Read async + AssetBundle.CreateFromMemory + AssetBundle.Load
    7.File Read async + AssetBundle.CreateFromMemory + AssetBundle.Load
    8.File Read async + AssetBundle.CreateFromMemory + AssetBundle.LoadAsync
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;几种方式主要是由文件读取和AssetBundle异步加载形式组合而成。&lt;/p&gt;

&lt;h6&gt;前2种为主流的异步加载方式。其中第1种用的比较多，因为大多数资源文件都会在游戏开始前进行比对和下载，所以没必要使用WWW的形式从本地读取或从网络下载。&lt;/h6&gt;

&lt;p&gt;其实这里涉及到“为什么要用非阻塞加载”的问题。阻塞式加载这么好用，为什么还要用非阻塞式。&lt;/p&gt;

&lt;p&gt;我们不要为了异步而异步，有人会觉得异步更高级，如果只是为了异步而做异步是没有意义的。大部分情况下我们在使用阻塞式加载资源时，都会遇到一个问题，在某一帧加载的资源很多，加载完毕后需要实例化的资源也很多，从而导致画面在这一帧耗时特别长，画面卡顿现象特别不严重，用运营同学们的话说“对用户来说不友好”。为了能更好更平滑的过度场景，我们需要把要加载和实例化的时间跨度拉长，虽然增加了些许等待时间，却能平滑过渡到最终我们需要的画面。&lt;/p&gt;

&lt;h6&gt;具体怎么做呢。其实不复杂的，可以先获取所有需要加载的资源，放入队列中，每次加载N个(N可以根据实际情况调整)，如果已经加载过的就直接通知逻辑程序实例化，不曾被加载的则调用加载程序并将调用后的加载信息(AssetBundleRequest)放入‘加载中’队列，不开携程而是用Update帧更新去判断‘加载中’队列中是否有完成的，每加载完毕一个资源先从‘加载中’队列里移除，再通知逻辑程序再进行实例化，直到队列中的请求加载完毕为止，继续下一个N个加载请求。当然这里也需要做些判断，例如已经在加载队列里的资源不重复加载等一些避免重复加载的判断。&lt;/h6&gt;

&lt;h3&gt;AssetBundle的引用计数方式卸载&lt;/h3&gt;

&lt;p&gt;Assetbundle在加载后我们需要寻求释放，只有加载没有释放内存只会不断攀升。该怎么释放就成了问题，因为资源使用的地方太多，太庞杂，所以为了能更好的知道什么时候该释放资源，我们需要制定一个规则，这个在遵守这个规则的前提下，我们就知道什么时候资源没有被再使用了，有多少个地方在使用。&lt;/p&gt;

&lt;p&gt;引用计数就是判断这种释放依据的很好的技巧，具体方式为如下：&lt;/p&gt;

&lt;h6&gt;我们对AssetBundle包装一个计数器(是个整数)，当需要某个AssetBundle时先加载所有依赖的AssetBundle，每加载一个AssetBundle就为该AssetBundle的引用计数加1。&lt;/h6&gt;

&lt;p&gt;如果调用的是Prefab，会通过Instantiate进行实例化，这里必须在每次实例化时对该AssetBundle引用计数加1，不过这样在实例化时才做引用计数加1的手法，又消耗了些许我们的注意力而且容易遗漏，我们可以选择一次实例化调用一次加载，这样就节省了人额外的注意力，少一点主意力的消耗，就少一些遗漏。&lt;/p&gt;

&lt;p&gt;如果是Texture贴图这种不需要进行实例化的资源则最好不要被再次被引用，因为被再次引用会导致引用计数的错乱，我们可以选择每次当需要Texture时通过查看AssetBundle是否加载，有则直接取，没有则加载后再取，每次取资源时都对相应的AssetBundle计数加1。&lt;/p&gt;

&lt;h6&gt;当Destroy销毁实例或者不需要用资源时，则统一调用某个自定义的Unload(假设这个接口名字是自定义类AssetBundleMrg.Unload)接口并附上加载时的关键字(为了能更快的找到AssetBundle实例)，从而将对应的AssetBundle的引用计数减1。&lt;/h6&gt;

&lt;p&gt;减少引用计数后，倘若该AssetBundle引用计数为0，则认为可以进行AssetBundle卸载，则立即卸载。&lt;/p&gt;

&lt;p&gt;但是问题又来了，及时的卸载也会有问题，因为每次都卸载后又需要该资源时需要再加载，中间消耗的IO和CPU也很多，我们可以通过增加空置倒计时时间来给卸载AssetBundle一个预留时间。&lt;/p&gt;

&lt;p&gt;当需要卸载时，AssetBundle进入倒计时，比如5秒，5秒内仍然没有任何程序使用这个资源则立即进行卸载，如果5秒内又有程序加载该AssetBundle资源则继续使用引用计数来判断是否需要进入卸载倒计时。&lt;/p&gt;

&lt;p&gt;不过还是有个小问题，如果大量资源在同一时间卸载，就会造成大量资源同一时间进入倒计时，倒计时完毕同时进行卸载，也会带来1帧消耗过大的问题，毕竟资源的卸载时内存的消耗，大量的内存在同一时间销毁会带来大量的CPU消耗。此时我们可以对倒计时进行随机2-5秒的时间内随机一个值，让卸载分散在这个时间段内，让卸载的消耗更加平滑。&lt;/p&gt;

&lt;h3&gt;AssetBundle的打包与颗粒度大小&lt;/h3&gt;

&lt;p&gt;Unity3D对AssetBundle的封装做的很好，当我们在打包AssetBundle时Unity3D会自动去计算AssetBundle与AssetBundle之间的依赖关系，所以我们能很轻松的将资源打的很细(贴图，网格，Shader，Prefab，每个资源分的很开)。&lt;/p&gt;

&lt;p&gt;这使得我们能很轻松得让一个AssetBundle只装一个资源文件并且控制起来也得心应手，只要在加载时读取存有依赖关系的AssetBundle就能得到AssetBundle之间的依赖关系数据(AssetBundleManifest实例数据)，根据这个依赖数据我们就能轻松的加载相关的其他AssetBundle。&lt;/p&gt;

&lt;p&gt;既然AssetBundle颗粒度可以很容易的缩放，那么我们就需要考虑颗粒度的大小到底对项目产生多大的影响。&lt;/p&gt;

&lt;p&gt;我们说说左右两种极端状态下的表现。&lt;/p&gt;

&lt;h6&gt;一种为颗粒度极粗状态，所有资源都打成一个AssetBundle包，所有逻辑程序要的资源都从这个AssetBundle里取。引用计数，在这里已经完全没有了用处，由于只有一个AssetBundle已经完全没有卸载的可能了。这导致了内存只会逐步增大，而绝不会因为不再需要某资源而卸载AssetBundle(当前AssetBundle的卸载机制中没有只销毁某部分资源的功能)。&lt;/h6&gt;

&lt;p&gt;我们来看看整个过程，从一个很大的文件包从网络上下载下来，解压后成为一个AssetBundle文件，然后我们读取它并从中获得资源。从这个过程来看只有一个AssetBundle的极限状态下，文件操作的数量极低，导致读取AssetBundle文件信息没有障碍，解压的IO连续性非常高，导致解压时不需要创建很多文件从IO上会相对比较快些，同时由于只有一个文件内容所以打包的压缩率也是最大的。&lt;/p&gt;

&lt;h6&gt;另一种为颗粒度极细状态，所有贴图、网格、动画、Shader、Prefab都各自打自己的一份AssetBundle(一份AssetBundle只带一个资源)。为了能更有效的控制内存，AssetBundle之间的依赖关系和引用计数在这里用处非常大。通过引用计数和依赖关系，我们能很有效的控制逻辑系统中需要的资源和内存中的资源是一致的。&lt;/h6&gt;

&lt;p&gt;我们来看看整个过程，从网上下载下来所有AssetBundle资源文件，对每个压缩过的资源文件进行解压，当需要某个资源时从AssetBundle读取资源并且读取前先根据依赖关系读取需要的资源，并且对所有加载过的AssetBundle引用计数加1。当卸载时，对当前卸载的AssetBundle引用计数减一，并且对存有需求上依赖关系的其他AssetBundle也减一（由于当前资源卸载后对其他依赖资源不再引用），如果引用计数为0则启动卸载。&lt;/p&gt;

&lt;p&gt;我们从这个过程看来，一个极限细分颗粒度状态下的AssetBundle机制，文件操作数量会很大，IO操作的时间会因为文件增多的增大许多，导致下载时间拉长，下载完毕后解压的总时间也会拉长，打包时由于每个文件单独打包压缩因此压缩比率会降低压缩时间加长。&lt;/p&gt;

&lt;p&gt;上述分析了两种极限状态下的利弊，我们可以根据自己项目的需求来定制AssetBundle打包机制。&lt;/p&gt;
</description>
               <pubDate>Sat, 02 Nov 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/11/02/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E8%B5%84%E6%BA%90%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E9%87%8A%E6%94%BE.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/11/02/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E8%B5%84%E6%BA%90%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E9%87%8A%E6%94%BE.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(三) - 渲染原理与知识2</title>
               <description>&lt;p&gt;这节我们将继续补充前面渲染管线中没有讲到的渲染知识和原理。&lt;/p&gt;

&lt;h3&gt;Filter 滤波方式&lt;/h3&gt;

&lt;p&gt;Filter滤波其实在图形引擎中被用到的地方有很多，我们在做项目时却很少察觉到，它的重要性不容忽视。Filter 滤波到底是什么呢？下面我们来讲讲它的来龙去脉。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;一张纹理贴图可以是线性的，正方形的，长方形，甚至三维形式的，当它们被映射到网格表面，再变换到屏幕坐标系之后，纹理上的独立纹素(纹素)几乎不可能直接和屏幕上的最终画面像素直接对应起来。为什么呢？&lt;/p&gt;

&lt;p&gt;因为屏幕上的物体可能是放大后的效果，或者离摄像机很近导致物体需要被放大在屏幕上，这样就导致是屏幕上的一个像素只是对应纹理贴图上一个纹素的一部分（因为被放大了），或者也有可能物体被缩小了，或者离摄像机很远，这时一个像素可能包含很多纹素（因为被缩小了）。因此一个纹素与一个像素通常都是无法一一对应的。&lt;/p&gt;

&lt;p&gt;无论哪种情况我们都无法精确的知道应该使用哪些纹素值，以及如何对它们求平均值或插值。OpenGL就为我们提高了多种Filter 滤波方式，不同的滤波方式在速度和画质上做出了不同的权衡。&lt;/p&gt;

&lt;p&gt;滤波一般分两种，一种是最近采样即Nearest，一种是线性采样即Linear。在Unity3D中Point类型的采样就是最近采样(Nearest Point Sampling)，线性采样在Unity3D中又分为双线性采样(Bilinear)和三线性采样(Trilinear)。&lt;/p&gt;

&lt;p&gt;最近采样，即当纹素与像素大小不一致时，取最接近的纹素进行采样。虽然使用了Mipmap技术，但像素点与纹素仍然没有得到很好的匹配，所以这种方法在纹理需要进行放大或缩小时，结果会变形难看。于是就有了更好的双线性采样算法。&lt;/p&gt;

&lt;p&gt;双线性采样，是取离纹素最近的4个纹素，取得的纹素与中心点的纹素的距离就是参与计算的权重值，把所有采样得到的纹素进行加权平均后得到最终的像素颜色。&lt;/p&gt;

&lt;p&gt;双线性过滤是怎么计算的这4个纹素呢？假设源图像大小为m x n，目标图像为a x b。那么两幅图像的边长比分别为：m/a和n/b。目标图像的第（i,j）个像素点（i行j列）可以通过边长比对应到源图像。其对应坐标应该为（i&lt;em&gt;m/a,j&lt;/em&gt;n/b）。显然这个对应坐标一般来说不是整数，而非整数的坐标是无法在图像中使用。双线性插值通过寻找距离这个对应坐标最近的四个像素点，来计算该点的像素值。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    映射点计算方法:

    srcX=dstX* (srcWidth/dstWidth)+0.5*(srcWidth/dstWidth-1)

    srcY=dstY* (srcWidth/dstWidth)+0.5*(srcWidth/dstWidth-1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/book/7/g1.png&quot; alt=&quot;双线性过滤&quot;&gt;&lt;/p&gt;

&lt;p&gt;双线性过滤像素之间的过渡更加平滑，但是它只作用于一个MipMap Level,它选取纹素和像素之间大小最接近的那一层MipMap进行采样。当和像素大小匹配的纹素大小在两层Mipmap Level之间时，双线性过滤在有些情况效果就不太好。于是就有了三线性过滤。&lt;/p&gt;

&lt;p&gt;三线性过滤以双线性过滤为基础。对像素大小与纹素大小最接近的两层Mipmap Level分别再进行一次双线性过滤，然后再对两层得到的结果进行线性插值。&lt;/p&gt;

&lt;p&gt;上面的几种线性过滤外，还有各向异性过滤(Anisotropic Filtering)。什么是各向异性和同性呢：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    各向同性，当需要贴图的三维表面平行于屏幕就是各向同性。

    各向异性，当要贴图的三维表面与屏幕有一定角度的倾斜则是各向异性。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;各向异性过滤，除了会把Mipmap因素考虑进去外，还会把纹理与屏幕空间的角度这个因素考虑进去。它会考滤一个像素对应到纹理空间中在u和v方向上与u和v的比例关系，如果u:v不是1:1时，将会按比例在各方向上采样不同数量的点来计算最终的结果。&lt;/p&gt;

&lt;p&gt;各向异性采样的多少取决于Anisotropic Filtering的X值，所以在Unity3D的纹理图片设置上有一个Aniso Level的设置选项，用来设置Anisotropic Filtering的级别。&lt;/p&gt;

&lt;p&gt;采样方式从，最近采样，到双线性过滤，到三线性过滤，再到各向异性过滤，采样次数一级级提高，最近采样1次，双线性采样4次，三线性采样8次，各向异性采样随着等级不同各有不同，效果也是一级级的提高，随着采样次数的提高需要消耗的GPU也会逐级提高(这些都是在OpenGL或DirectX中完成的)，因此我们在设置图片过滤时需要权衡画质与性能。&lt;/p&gt;

&lt;h3&gt;光照阴影是如何生成的&lt;/h3&gt;

&lt;p&gt;前面讲了很多关于Mipmap和纹理采样的知识，对Mipmap和纹理采样的理解对底层画面渲染的理解有很大的帮助。这些所讲的内容也同样具有重大意义，阴影涉及到实际生活中的知识在渲染中是如何模拟的，让原本虚拟的计算机画面更加拟真现实生活。&lt;/p&gt;

&lt;p&gt;为了能让场景和人物看起来更加真实，光影效果是不可或缺的。我们经常能在画面中看到阴影跟随着物体摆动而变动，并且物体被光照遮挡的阴影投射在其他物体上，这样的效果十分动人，那么阴影是如何产生的呢？我们来细致的解析一下，通过解析我们能够更加深刻的理解阴影的生成原理，还可以通过对阴影原理的理解来有针对性的优化阴影对性能的消耗。&lt;/p&gt;

&lt;p&gt;我们可以首先考虑真实生活中阴影的产生流程，当一个光源发射一条光线遇到一个不透明物体时，这条光想不能再继续照亮它背后的物体。因此这个物体背后的物体就会产生阴影，这些阴影区域的产生是因为光线无法到达这些区域。&lt;/p&gt;

&lt;p&gt;在计算机的实时渲染中我们无法用表达出每条光照的射线，我们是如何做到阴影的投射的呢？&lt;/p&gt;

&lt;p&gt;其实可以很简单，假设，我们将摄像机放在光源的位置上，方向与光源照射的方向重合，那些看不到的地方就成了阴影产生的地方。不过，我们不可能真的将摄像机放在那里，但却可以用这种形式的方式，单独渲染一次在摄像机在该位置的图像。只有图像不行，我们需要的是阴影，刚好物体从该位置渲染出来的片元的深度值提供了我们需要的数据，将所有片元的深度值都写入深度缓存中后，我们就可以利用这个深度缓存做阴影的计算了，深度值越大的片元被遮挡的可能性越大，深度值最小的片元不会被遮挡。&lt;/p&gt;

&lt;p&gt;这就是阴影映射纹理(Shadow Map)技术，即在渲染中第一个渲染流程(pass)负责在光源点位置计算得到深度值，输出像素到阴影映射纹理(Shadow Map)。我们实质上得到是一张深度图，它记录了从该光源的位置出发，能看到的场景中距离它最近的表面位置的深度信息。&lt;/p&gt;

&lt;p&gt;只是这张阴影映射纹理对于我们人类来说不够直观，如果想要更好更直观的看到当前摄像机屏幕上的阴影图就更好了。屏幕空间的阴影投影技术(Screenspace Shadow Map)就产生了这种直观的效果，性能和效率也更高，不过它需要显卡支持MRT(Multiple Render Targets)，有些移动平台并不支持这种特性。&lt;/p&gt;

&lt;p&gt;当使用了屏幕空间阴影投射技术(Screenspace Shadow Map)时，Unity3D会让从光源出发的深度图与摄像机产生的深度图做比较，如果摄像机的深度图中记录的点的表面深度大于转化到光源出发生成的深度图的点的深度，那么就说明表面虽然是可见的但却处于该光源的阴影中。通过这样的方式，屏幕空间阴影投射技术(Screenspace Shadow Map)得到了当前摄像机屏幕空间中的阴影区域，即得到了当前摄像机屏幕的阴影图。&lt;/p&gt;

&lt;p&gt;到这里，我们已经得到了阴影映射纹理，不管是传统的阴影图还是屏幕空间阴影图，我们都可以根据这张阴影图来计算出投射到物体的阴影了，那么阴影图有了，应该怎么投射呢？&lt;/p&gt;

&lt;p&gt;主动计算投射到其他物体产生阴影是比较难的，但反过来，根据阴影图主动计算当前渲染物体上的片元是否被阴影是相对比较容易。我们会看到Unity3D在渲染物体上看到有生成阴影和接受阴影两个选项，即Cast Shadows 和 Receive Shadows。&lt;/p&gt;

&lt;p&gt;传统的接受阴影的方式，是将当前顶点的位置变换到光源点的空间下得到它在光源空间中的位置，再根据xy轴分量对阴影映射纹理(Shadow Map)进行采样，从而得到阴影映射纹理中该位置的深度值，如果这个深度值小于该顶点的深度值即z轴分量，那么说明该点位于阴影中，于是在片元颜色输出上加深阴影颜色，反之则没有被阴影遮盖。&lt;/p&gt;

&lt;p&gt;在屏幕空间阴影映射技术中(Screenspace Shadow Map)则可以更加方便一点，因为已经得到了当前摄像机整个屏幕的阴影图，不需要再进行额外的计算，只需要在当前屏幕位置对阴影图进行采样便能知道是否在阴影下，即将当前顶点坐标从模型空间变换到屏幕空间后使用这个坐标对阴影图进行采样即可。相对于传统的阴影渲染来说，屏幕空间阴影映射技术提高了更多的GPU性能效率。&lt;/p&gt;

&lt;p&gt;在Unity3D中使用 LightMode 为 ShadowCaster 的Pass标记为阴影生成管线。当Unity3D在渲染时会首先在当前Shader中找到LightMode为ShadowCaster的Pass，如果没有则会在Fallback指定的Shader中继续寻找，如果没有则无法产生阴影，无论传统的阴影投射还是屏幕空间阴影投射都需要第一步先产生阴影纹理图(Shadow Map)。当找到LightMode为ShadowCaster的Pass后，Unity3D会使用该Pass来制作光源的阴影映射纹理(Shadow Map)。&lt;/p&gt;

&lt;h3&gt;Lightmap烘培原理&lt;/h3&gt;

&lt;p&gt;随着硬件技术的发展，人们对场景的画质效果越来越高，实时光照早已经满足不了人们对画质的需求，想要更加细腻真实光照效果，只能通过离线的烘培技术才能达到理想画质的效果。&lt;/p&gt;

&lt;p&gt;全局光照，简称GI(Global Illumination)，是在真实的大自然中，光从太阳照射到物体和地面再经过无数次的反射和折射，使得地面的任何物体和地面都叠加着直接照射的光和许许多多物体反射过来的间接光(反射光)，导致我们从眼睛里看到画面是光亮又丰富的。&lt;/p&gt;

&lt;p&gt;这种无数次反射和折射形成的高质量画面，才是人们在3D游戏画面中真正想要看到的。但是即使今天硬件技术发展的如此迅速，也无法做到实时的进行全局光照(Realtime Global Illumination)，这样计算量太大，CPU和GPU都无法负担起这个重任。&lt;/p&gt;

&lt;p&gt;离线全局光照就担负起了这个丰富画面光照效果的重任，它不再需要这么多的实时计算的CPU和GPU算力，只要1张或几张光照图(Lightmap)就能将全局光照的效果复原到物体上，不过也仅限于场景静态物体的光照烘培。&lt;/p&gt;

&lt;p&gt;其实烘培这趟水很深，如果要具体深入到工程上的实现，涉及到的算法和图形学知识非常多，这里并不打算深究，而是讲讲我们能相对容易获得的关于Lightmap的原理和知识。根据这个原理，我们在项目的制作和优化中能起到很好的作用。&lt;/p&gt;

&lt;p&gt;什么是烘焙？个人认为从英文‘Bake’翻译过来有点偏差，导致很多工具按钮用‘Bake’表示时，很多人都同样把它理解成了烘培，其实更应该理解为‘制作’。&lt;/p&gt;

&lt;p&gt;烘培简单地说, 就是把物体光照的明暗信息保存到纹理上, 实时绘制时不再需要进行光照计算, 而是采用预先生成的光照纹理(Lightmap)来表示明暗效果。&lt;/p&gt;

&lt;p&gt;我们在渲染3D模型时用到的基本都是顶点，UV，纹理贴图等(这里不多展开)，在顶点上设置UV，形成片元后就成了顶点间的插值UV，用这个UV坐标去纹理贴图上取得颜色值，再填充到帧缓存中最后显示到画面上。&lt;/p&gt;

&lt;p&gt;光照纹理(Lightmap)的显示也是同样道理，用UV坐标来取得光照纹理(Lightmap)上的颜色，最后叠加到片元颜色上输出给缓存。&lt;/p&gt;

&lt;p&gt;这其中的UV有一点讲究。我们在制作模型时的UV数据可以有很多个，其中UV0主要是为了映射贴图纹理而用，在模型制作过程就在模型数据中制作好了，而UV1也就是我们程序中的uv2或俗称的2u，主要是为Lightmap做准备的，还有UV2即程序中的uv3，是为实时全局光照准备的，只有UV3即程序中的uv4开始才是我们程序可以自定义使用的UV数据，其实uv可以有很多个uv5，uv6，不过Unity3D的网格类(Mesh)暂时只提供到uv4的获取接口。&lt;/p&gt;

&lt;p&gt;既然光照纹理(Lightmap)存储的是光照信息，那么它到底存了哪些信息呢？我们先来看下这幅图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺图
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这幅图解释了烘培的简单模型，它分为三个部分，第一部分为光线射到墙壁后反射过来照到模型上，第二部分为光线照射过来时被其他模型挡住，导致当前的模型没有被光线照射到并且有阴影产生，第三部分为光线直接照射到模型上产生的颜色信息。&lt;/p&gt;

&lt;p&gt;这三者之和最终形成了完全的光照颜色。可以用一个简单的公式来说明这三者的结合方式：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    光照颜色 = 间接光照颜色 + 直接光照颜色 * 阴影系数(0到1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于直接光的计算代价比较少，在一些光照并不复杂的场景中不记录直接光信息，而是由Shader自己计算直接光照。因此我们能看到，很多项目并没有记录直接光，而只是记录间接光，即光照纹理中只记录了从其他物体反射过来的光产生颜色的总和，加上另一张阴影纹理记录产生阴影部位的信息。如果你希望记录在光照纹理中主要光的方向，则可以开启Directional Model的Directional来获得，这个文素上主要光的方向信息可以被用在Shader中作为计算的变量。&lt;/p&gt;

&lt;p&gt;现在我们知道了烘培(Bake)会最多产生3种贴图，一种是光照纹理图(可能是间接光照纹理图，也可能是间接光照+直接光照+阴影合并的纹理图，取决于你在Unity3D中Lighting Mode的设置)，一种是阴影纹理图，一种是主要光方向纹理图，以及模型的UV2数据。&lt;/p&gt;

&lt;p&gt;其中UV1(不是UV2，因为uv对应UV0，uv2对应UV1)会被加载到模型网格信息中去，也就是烘培后模型prefab的mesh.uv2的数据会被改写。因此我们在制作和导出模型时要注意，烘培需要用到模型的uv2数据，在导出模型时如果没有导出uv2数据，则无法得到正确的烘培。&lt;/p&gt;

&lt;h6&gt;那么烘培器是如何生成uv和贴图的呢？我们需要理解下UV Chart&lt;/h6&gt;

&lt;p&gt;在烘培时，烘培器会对所有场景中的静态物体上的Mesh网格进行扫描，按块大小和折线角度大小来制作和拆分Mesh上的对应的UV块，这个UV块就是UV Chart。&lt;/p&gt;

&lt;p&gt;UV Chart是静态物件在光照纹理(Lightmap)上某块Mesh的对应的UV区块，一个物体在烘培器预计算后会有很多个UV Chart。因此每个物件的UV Charts是由很多个UV Chart组成，每个UV Chart为一段连续的UV片段。默认情况下，每个Chart都至少是4x4的纹素，无论模型的大小一个Chart都需要16个纹素。UV Chart之间预留了0.5个像素的边缘来防止纹理的溢出。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/uvchart.png&quot; alt=&quot;UV Chart0&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    图0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/book/7/LightingGiUvs-2.png&quot; alt=&quot;UV Chart1&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    图1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/book/7/LightingGiUvs-4.png&quot; alt=&quot;UV Chart2&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    图2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/book/7/LightingGiUvs-0.jpg&quot; alt=&quot;UV Chart3&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    图3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中1描述了，当一个场景只有1个正方形物体时，这个正方体网格物体被烘培后，6个面上的UV Chart是如何映射到烘培纹理上的。图2描述了场景中当有多个简单的立方体时，每个物体被扫描后制成UV Chart的情况。图3描述了当烘培场景更加复杂时，扫描后UV Chart被制作的情况，不同规格的模型UV被映射到Lightmap纹理贴图上。&lt;/p&gt;

&lt;p&gt;我们很清晰的能从图中了解到，在烘培时，每个场景中的静态物体都会被扫描网格，并且将计算出来的UV Chart合起来制作成一张或几张(可能场景太大一张不够用)光照纹理贴图。&lt;/p&gt;

&lt;h6&gt;那么什么决定了烘培中扫描网格时形成的UV Chart大小和数量呢？相邻顶点间的最大简化距离和最大夹角值。&lt;/h6&gt;

&lt;p&gt;烘培器为了能更加快速的计算制作出UV Chart，烘培器需要对模型面的顶点扫描进行简化。简化方式为，将相邻顶点间距离小于某个数值的顶点归入一个UV Chart，当这个数值设置相对比较大时，UV Chart生成的速度就会加快。但是只是距离上的简化往往会出现很多问题，我们需要从相邻面的角度上进行约束，即当相邻面间的角度大于某个值时，不能简化成同一个UV Chart。这两个参数在Unity3D中都有设置，点击静态物体在右边的版面上就能看到。如图位置：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/LightingGiUvs-3.png&quot; alt=&quot;UV Chart1&quot;&gt;&lt;/p&gt;

&lt;p&gt;图中展示了静态物体Mesh Renderer中设置Lightmap UV生成参数，参数包括最大简化顶点距离，最大邻接面角度。&lt;/p&gt;

&lt;p&gt;当设置的最大简化距离和邻接面最大角度数值比较大时，计算生成UV Chart的数量就会比较少，相反如果设置的最大简化距离和最大邻接面角度比较少，则需要计算和生成的UV Chart会比较多，烘培的速度也会比较慢，因为在预计算实时全局光照(GI)时，每个UV Chart上的像素都会计算灯光，预计算的时间跟Chart的数量有很大关系。&lt;/p&gt;

&lt;h6&gt;上述描述了烘培的前置制作中Lightmap纹理分布和场景中物体的UV映射的原理，那么绘制Lightmap纹理贴图时纹理上颜色是怎么生成的呢？&lt;/h6&gt;

&lt;p&gt;我们知道如果不用烘培，在实时渲染中，因为算力的原因我们只能计算直接光对物体的明暗影响，如果想要在实时渲染中计算间接光的影响是非常消耗GPU的算力的，即使有足够强大的显卡支撑使用光线跟踪计算，也只能在带有RTX的显卡计算机上使用。暂时还没有做到普及的程度，因此离线烘培成了我们解决间接光的主要手段。&lt;/p&gt;

&lt;p&gt;在一个场景中如果这些物体只考虑直接光的影响，则会缺乏很多光影细节，导致视觉效果很“平”。而间接光则描述了光子在物体表面之间的反弹，增加了场景中明暗变化以及光线折射的细节，提高了真实感。&lt;/p&gt;

&lt;p&gt;光照纹理贴图的颜色主要是根据光的折射与反射现象来计算的，这里我们需要了解一下Unity3D中采用的Enlighten和Progressive Lightmapper算法解决方案。&lt;/p&gt;

&lt;p&gt;全局照明可以用一个称为渲染方程的复杂方程来描述：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/LightingGi-1.png&quot; alt=&quot;渲染方程&quot;&gt;&lt;/p&gt;

&lt;p&gt;这个渲染方程定义了光线是如何离开表面上某个点的。但是这个积分方程太复杂以至于无法快速计算出结果，Unity3D中Enlighten采用的近似方法即辐射算法，可以大大提高计算渲染方程式的速度。&lt;/p&gt;

&lt;p&gt;辐射算法假设了场景中存在一组有限的静态元素，以及仅有漫射光传输来简化计算。在计算过程中它把场景拆分成很细很细的面片，分别计算它们接受和发出的光能，逐次迭代直到每个面片的光能数据不再变化(或者到一定的阀值)为止，得到最终的光照图。&lt;/p&gt;

&lt;p&gt;场景拆分后的以及每个面片之间的作用，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/LightingGi-2.png&quot; alt=&quot;渲染方程&quot;&gt;&lt;/p&gt;

&lt;p&gt;Enlighten将场景切割成很多个面片我们称它们为Cluster(Cluster大小可以通过Unity3D的烘培设置数值大小)，这些Cluster会对其映射的静态物体的纹理中的反射系数进行采样，然后计算Cluster之间的关系，使得光在Cluster之间传递。&lt;/p&gt;

&lt;p&gt;Enlighten将渲染方程简化成了迭代公式即：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/LightingGi-3.png&quot; alt=&quot;渲染方程&quot;&gt;&lt;/p&gt;

&lt;h6&gt;其中Bi指的是在i点最终的光，Le是i点本身的光，而两个Cluster之间光的反弹系数有Fij来决定，Lj则是J点的光。这也是为什么Enlighten能够支持场景物体不变的情况下允许光源发生变化的原因：因为几何体素化和辐射系数计算代价比较大，需要离线计算，而迭代每个Cluster形成最终结果则计算量相对比较小可以实时进行。&lt;/h6&gt;

&lt;p&gt;Progressive Lightmapper即渐进式光照贴图，是Unity3D 2018版本后才能使用的烘培算法。&lt;/p&gt;

&lt;p&gt;Progressive Lightmapper是一种基于路径追踪（fast path-tracing-based）的光照贴图系统，它能在编辑器中逐步刷新的烘焙光照贴图（baked lightmaps）和光照探针（Light Probes）。&lt;/p&gt;

&lt;p&gt;Progressive Lightmapper主要的优势是能随着时间的推移逐步细化输出画面，及时逐步的看到画面效果，这样能够实现更完善的交互式照明工作流。另外Progressive Lightmapper还提供了一个预估的时间，所以烘焙时间更加可预测。&lt;/p&gt;

&lt;p&gt;参考文献：&lt;/p&gt;

&lt;p&gt;《OpenGL编程指南》&lt;/p&gt;

&lt;p&gt;《OpenGL ES 3.0编程指南》&lt;/p&gt;

&lt;p&gt;《Unity移动平台下的烘焙使用及优化》&lt;/p&gt;

&lt;p&gt;《浅析Unity中的Enlighten与混合光照》&lt;/p&gt;

&lt;p&gt;《Progressive CPU Lightmapper》&lt;/p&gt;

&lt;p&gt;《光照贴图Lightmap初探》&lt;/p&gt;

&lt;p&gt;《辐射度算法(radiosity)原理》&lt;/p&gt;
</description>
               <pubDate>Sat, 26 Oct 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/10/26/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A67.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/10/26/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A67.html</guid>
            </item>
        
            <item>
               <title>思路探讨(二十九) 有没有可能是我们理解错了</title>
               <description>&lt;h1&gt;有没有可能是我们理解错了&lt;/h1&gt;

&lt;p&gt;我经常这样问自己，有没有可能是我理解错了。有没有可能完全不是我理解的那么回事。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h6&gt;这个世界的真相总是在我们背后，但我们总认为自己的前方所见就是全世界。因此完全推翻自己的认知是有必要的。&lt;/h6&gt;

&lt;p&gt;“有没有可能是我们理解错了”，这个问题是来自于我们的反思，不过看起来似乎像是用好奇心来破解当前面对的困局。&lt;/p&gt;

&lt;h6&gt;当我们遇到困境，遇到疑惑，遇到迷茫时，不妨用好奇的口吻来表达我们渴望突破。&lt;/h6&gt;

&lt;p&gt;其实我们都是井底的那只蛙，我们弹跳力不够很难跳出这口井，就像我们无法用旁观者的角度看自己那样，在井中我们总是认为自己所思所想都是对的，以至于认为世界就是我们所认为的方式在运作。&lt;/p&gt;

&lt;p&gt;映射到实际生活中，比如像我一样的程序员编程技术工作者们，我们很难跳出这个技术视野去看事物。很多像我一样以为只要技术好就能升职加薪赢取白富美走上人生巅峰，这可能是程序员思维中最大的错误理解。因为我们身处在具体的工作细节中，这个具体工作本身就是那口井，我们无法跳出这口井去看外面的世界，就像我们无法用旁观者的角度看清问题的本质一样。&lt;/p&gt;

&lt;h6&gt;面对程序员的职业发展与事业道路，我对自己表达了好奇“有没可能是我理解错了”，我希望透过现象看本质。&lt;/h6&gt;

&lt;p&gt;就此我提出四个点来表达透过现象看到的本质：&lt;/p&gt;

&lt;h3&gt;技能可以用来打工，产品才能用来赚钱。&lt;/h3&gt;

&lt;p&gt;为什么说“只要技术好就能升职加薪赢取白富美走上人生巅峰”是错的呢？&lt;/p&gt;

&lt;p&gt;不是技术没用，而是只有技术还远远不够。口才和心理素质比技术有用的多。&lt;/p&gt;

&lt;p&gt;技术只不过是熟能生巧而已，可以理解为经验和知识在脑中的肌肉记忆。&lt;/p&gt;

&lt;p&gt;而口才是嘴巴和脸部肌肉的肌肉记忆，心理素质则是环境在脑中的肌肉记忆。&lt;/p&gt;

&lt;p&gt;只有这几个肌肉记忆联结起来才会产生实质性的效果。而产品其实就是这几个因素联结起来的结果。&lt;/p&gt;

&lt;p&gt;一个好的产品不只要有好的技术，还要有好的营销，好的运营，好的耐心和好的专注。&lt;/p&gt;

&lt;p&gt;如果只有技术，那就会什么都不是。&lt;/p&gt;

&lt;h3&gt;开源只是种学习的方式，并不能成为崛起财富的途径。&lt;/h3&gt;

&lt;p&gt;很多人都喜欢开源，因为他们弄不清目标，只是觉得开源很酷。&lt;/p&gt;

&lt;p&gt;开源是种精神，这种精神很多种，有的纯粹为了分享，虽然对世界有益，但对个人而言毫无益处。但有的开源就是为了锻炼自己，把自己的行为、希望、作品抛到全世界的平台上去让大家去检验去抨击你，（前提是这种行为是你这个领域一无所有或者投资太多关注太少的时候，如果你已经拥有很多，开源就会变成了一种浪费），那是真正对自己有益的行为。&lt;/p&gt;

&lt;h3&gt;技术驱动的企业必定失败，只有利益和市场才是财富的依靠。&lt;/h3&gt;

&lt;p&gt;世界上没有以技术为导向的公司，所有声称以技术导向的公司都死了，因为这并不符合市场的规律，不符合人类的天性。&lt;/p&gt;

&lt;p&gt;人类的天性是逐利的，技术并不能决定市场的逐利行为，技术不迎合市场一样遭遇淘汰。&lt;/p&gt;

&lt;h3&gt;市场是不道德的，遵循道德跟是否得到市场认可无关，但遵循道德可以让人安心踏实。&lt;/h3&gt;

&lt;p&gt;市场跟道德无关，很多现象看似不道德其实只是人们心里的偏见而已，其实并无他，即使站在道德的制高点也不会让市场回头。&lt;/p&gt;

&lt;p&gt;不过虽然道德跟很多逐利的事物无关，但跟人本身却有很大关系，它能让人安心踏实，人生在世，图的其实就是个安心，道德对人来说就是最好的抚慰剂，让人安心踏实。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;最后说说我自己。我有好奇的毛病，我想大多数人都和我一样，它时常让我陷入困境，比如我时常有奇思怪想，去体验一把没有体验过的人生旅途，最后发现没有人去体验不是因为他们不敢而是因为这条路体验很差或许还很受伤。不过好奇也同样时常让我豁然开朗，因为体验后自己就经历了比别人更多的遭遇，也有了更多人生体验和感悟。&lt;/p&gt;
</description>
               <pubDate>Sun, 13 Oct 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/10/13/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A829.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/10/13/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A829.html</guid>
            </item>
        
    </channel>
</rss>