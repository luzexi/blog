<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title></title>
        <description>技术，哲学，金融</description>
        <link>http://www.luzexi.com</link>
        <atom:link href="http://www.luzexi.com/assets/feed.xml" rel="self" type="application/rss+xml" />
        
            <item>
               <title>读书笔记(二十九) 《装载、链接与库》#2 静态链接过程</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484763&amp;amp;idx=1&amp;amp;sn=f1b3d678c1309a66d44b64b7ff22a002&amp;amp;chksm=fc22605ccb55e94a53558e85fdbe196fc58612fe20c88f35f8c0f4098e240ef48bcd2da099b0&amp;amp;token=535520395&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;背景&quot;&gt;背景：&lt;/h3&gt;

&lt;p&gt;看此书的起源是我在了解Linux注入技术的时候翻阅到的，由于注入技术需要用到很多ELF格式的内容，很多网络上的技术文章都指向了同一本书。也刚好周围的同事有此书，便翻阅了一下，这一番翻阅打开了我对程序世界的又一扇大门。&lt;/p&gt;

&lt;p&gt;很快我就自己买了此书并阅读完成，整本书给我很大的震撼，让我对程序从编译到链接到装载有了更深刻的认识。&lt;/p&gt;

&lt;p&gt;我把我的整个学习过程以及对书本的理解，用自己的语言和自己画的图表达出来，让读者能够更容易接受到我所学的知识。&lt;/p&gt;

&lt;h3 id=&quot;目标&quot;&gt;目标：&lt;/h3&gt;

&lt;p&gt;了解编译过程&lt;/p&gt;

&lt;p&gt;了解动态库和静态库的装载细节&lt;/p&gt;

&lt;p&gt;了解可执行程序装载和执行过程&lt;/p&gt;

&lt;p&gt;了解可执行文件和动态库的数据格式&lt;/p&gt;

&lt;h3 id=&quot;疑问&quot;&gt;疑问：&lt;/h3&gt;

&lt;p&gt;c/c++编译器是如何将cpp编译为可执行文件的？&lt;/p&gt;

&lt;p&gt;多个c/c++文件是如何编译成一个可执行文件的？&lt;/p&gt;

&lt;p&gt;操作系统内存是如何初始化和管理的？&lt;/p&gt;

&lt;p&gt;动态库和静态库的链接和装载过程是怎样的？&lt;/p&gt;

&lt;p&gt;操作系统的用户态和内核态是如何运作的？&lt;/p&gt;

&lt;h3 id=&quot;正文&quot;&gt;正文：&lt;/h3&gt;

&lt;p&gt;前文《链接、装载与库-回顾基础》说了计算机设备的架构，硬盘的存储方式，内存虚拟空间的意义，多线程调度和安全的本质，以及代码编译的整体流程。&lt;/p&gt;

&lt;p&gt;我们平常用C++代码编译出来的可执行文件、静态库、动态库，看上去它们的不一样的东西，其实它们的数据格式是相同的。&lt;/p&gt;

&lt;p&gt;现代流行的操作系统分Windows和Linux两种，因此我们主要介绍这两种平台下的文件格式。在Windows下的可执行文件格式称为PE（Portable Executable），在Linux下则称为ELF（Executable Linkable Format），其实它们都是COFF（Common file format）格式的变种。&lt;/p&gt;

&lt;p&gt;不光是可执行文件，动态链接库（DLL，Dynamic Linking Library）和静态链接库（Static Linking Library）都是按照可执行文件格式存储的。&lt;/p&gt;

&lt;p&gt;静态链接库稍有不同，它把很多目标文件捆绑在一起形成一个文件，可以简单把它理解为一个包含很多目标文件的文件包。&lt;/p&gt;

&lt;p&gt;单个目标文件简单的结构介绍&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int global_init_var = 84; // 已初始化全局变量
int global_uninit_var; // 未初始化全局变量

//全局函数
void func1( int i)
{
    printf(&quot;%d\n&quot;,i);
}

//入口函数
int main(void)
{
    static int static_var = 85; // 已初始化静态变量
    static int static_var2; // 未初始化静态变量

    int a = 1; // 已初始化局部变量
    int b; // 未初始化局部变量
    func1(static_var + static_var2 + a + b); // 调用全局函数

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们先以目标文件为例，来举一个简单的文件ELF结构。目标文件是最常见的编译单位，它将指令代码、数据以Section的形式存储在文件中。&lt;/p&gt;

&lt;p&gt;上图中我们简单说明了程序、已初始化全局数据、未初始化全局数据在目标文件中的存放位置。
其中.data段保存的是已初始化了的全局静态变量和局部静态变量，这些数据是可写可读的，而只读数据则存放在.rodata中，例如const修饰的变量和字符串常量。
用.rodata单独保存只读数据能够更加好的保护数据，任何修改.rodata中的数据都会作为非法操作处理。&lt;/p&gt;

&lt;p&gt;类似的Section段有很多，我们列举一些重要的来说：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;.bss：包含程序运行时未初始化的数据（全局变量和静态变量）。当程序运行时，这些数据初始化为0。
.data和.data1，包含初始化的全局变量和静态变量。
.dynamic，包含了动态链接的信息，包括链接器地址、需要的动态库、段地址信息，类型为SHT_DYNAMIC。
.dynstr，包含了动态链接用的字符串，通常是和符号表中的符号关联的字符串，类型为SHT_STRTAB。
.dynsym，包含动态链接函数符号表和地址，没有地址的则为0，标志SHF_ALLOC，类型为SHT_DYNSYM。
.fini，正常结束时要执行的析构程序，类型为SHT_PROGBITS。
.got，全局偏移表(global offset table)，类型为SHT_PROGBITS。
.hash，包含符号hash表，用于快速查找函数名的。标志SHF_ALLOC，类型为SHT_HASH。
.init，程序运行或加载时初始化程序。类型为SHT_PROGBITS。
.interp，该节内容是一个字符串，指定了程序链接器的路径名。如果文件中有一个可加载的segment包含该节，属性就包含SHF_ALLOC，否则不包含。类型为SHT_PROGBITS。
.plt 过程链接表（Procedure Linkage Table），类型为SHT_PROGBITS。
.rodata和.rodata1， 包含只读数据，组成不可写的段。标志SHF_ALLOC，类型为SHT_PROGBITS。
.shstrtab，包含section的名字，真正的字符串存储在.shstrtab中，其他都是索引。类型为SHT_STRTAB。
.strtab，包含字符串，通常是符号表中符号对应的变量名字和函数名。类型为SHT_STRTAB。
.symtab，Symbol Table，符号表。包含了所有符号信息，包括变量、函数、定位、重定位符号定义和引用时需要的信息。符号表是一个数组，Index 0 第一个入口，它的含义是undefined symbol index， STN_UNDEF。
.rela.dyn，包含了除PLT以外的 RELA 类型的动态库重定向信息。
.rela.plt，包含了PLT中的 RELA 类型的动态库重定向信息
.rela.text 代码重定位表
.rela.data 数据重定位表
.line，调试时的行号表，即源代码行号与编译后指令的对应表
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们想自定义些Section，可以用__attribute__((section(“name”)))把相应的变量或函数放到“name”作为段名的段中，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;__attribute__((section(&quot;GlobalTest&quot;))) int global = 42;

__attribute__((section(&quot;FuncTest&quot;))) void foo()
{
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么ELF结构在文件中是以怎样的形式存在的呢？&lt;/p&gt;

&lt;h3 id=&quot;下面是elf文件的大致布局&quot;&gt;下面是ELF文件的大致布局&lt;/h3&gt;

&lt;p&gt;（来源ELF描述文档 http://www.skyfree.org/linux/references/ELF_Format.pdf）&lt;/p&gt;

&lt;p&gt;左边是ELF的链接视图，可以理解为是目标代码文件的内容布局。右边是ELF的执行视图，可以理解为可执行文件的内容布局。
目标代码文件（编译过程中的.o文件）的内容是由Section组成的，而可执行文件（二进制可执行文件或库文件）的内容是由Segment段组成的。&lt;/p&gt;

&lt;p&gt;ELF header的定义可以在 /usr/include/elf.h 中找到。Elf32_Ehdr是32位 ELF header的结构体。Elf64_Ehdr是64位ELF header的结构体。
    （Linker and Libraries Guide：https://docs.oracle.com/cd/E19120-01/open.solaris/819-0690/chapter6-43405/index.html）&lt;/p&gt;

&lt;p&gt;其中e_ident的前4个字节是魔数，魔数是固定的，它用来确认文件的类型，操作系统在加载可执行文件时会确认魔数是否正确，如果不正确则说明文件不是ELF格式，则拒绝加载。&lt;/p&gt;

&lt;h3 id=&quot;elf的整体结构&quot;&gt;ELF的整体结构&lt;/h3&gt;

&lt;p&gt;现在我们知道了，ELF Header描述了Program header table 和 Section header table，Program header table 又描述了Segment摘要，Section header table 又描述了Section摘要。&lt;/p&gt;

&lt;h3 id=&quot;那么-program-header-table-和-section-header-table-究竟是怎么去描述segment和section摘要的呢&quot;&gt;那么 Program header table 和 Section header table 究竟是怎么去描述Segment和Section摘要的呢？&lt;/h3&gt;

&lt;p&gt;前面我们说ELF Header里已经有了Program header table 和 Section header table的位置的偏移量，有了它们每个table的大小，以及有多少个table，我们就能知道Program header table 和 Section header table的起始地址、每个结构体的位置、以及它们的范围。&lt;/p&gt;

&lt;p&gt;也就是说，每个Program header table 和 Section header table是一个由固定大小结构体组成的数组，于是可以根据ELF Header来确定它们的数据内容和范围。&lt;/p&gt;

&lt;p&gt;我们来看下它们的结构体，Program header结构：&lt;/p&gt;

&lt;p&gt;Section header结构：&lt;/p&gt;

&lt;p&gt;这里特别从重要的几个Section中挑出几个特别重要的字段来重点说明下。&lt;/p&gt;

&lt;h3 id=&quot;重定位表&quot;&gt;重定位表&lt;/h3&gt;

&lt;p&gt;任何需要重定位的Section都需要一个重定位表，例如&lt;/p&gt;

&lt;p&gt;.text需要.rel.text来辅助重定位
.data需要.rel.data来辅助重定位
.rela.dyn，用于动态重定位变量的表
.rela.plt，则用于动态重定位函数的表&lt;/p&gt;

&lt;p&gt;重定位分为两种&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一种是静态编译时重定位，在编译时重定位&lt;/li&gt;
  &lt;li&gt;另一种是动态加载时重定位，在执行时重定位&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;重定位我们放后面详细介绍&quot;&gt;重定位我们放后面详细介绍&lt;/h3&gt;

&lt;h3 id=&quot;字符串表&quot;&gt;字符串表&lt;/h3&gt;

&lt;p&gt;字符串主要用于匹配函数和变量名，但不同用途的字符串也会分开存放。&lt;/p&gt;

&lt;p&gt;.shstrtab，包含section名字的字符串存储在.shstrtab中
.strtab，包含符号表中符号对应的变量名字和函数名的字符串
.symtab，Symbol Table符号表，包含了所有符号信息，包括变量、函数、定位、重定位符号定义和引用时需要的信息，这里所有的字符串都只有索引指向.strtab中的内容。
.dynstr，包含了动态链接用的字符串，通常是和符号表中的符号关联的字符串
.hash，包含符号hash表，用于快速查找函数名和变量名&lt;/p&gt;

&lt;p&gt;字符串表中包含了存储字符串的表、存储索引的表、以及hash表，它们的用途分别是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;存储字符串的表目的是存储真实字符串数据&lt;/li&gt;
  &lt;li&gt;其他表有需要字符串的都用索引表示以节省内存&lt;/li&gt;
  &lt;li&gt;hash表则主要用于快速查找和比较字符串&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;符号表&quot;&gt;符号表&lt;/h3&gt;

&lt;p&gt;符号表主要用于记录函数名、变量名和地址，例如：&lt;/p&gt;

&lt;p&gt;.symtab，Symbol Table符号表，包含了所有符号信息，包括变量、函数、定位、重定位符号定义和引用时需要的信息
.dynsym，包含动态链接函数符号表和地址，没有地址的则为0&lt;/p&gt;

&lt;p&gt;这两者的区别是，symtab记录了所有符号，包括内部的和外部的函数和变量，而.dynsym则只包含了对外动态加载时需要提供的函数和变量，可以.dynsym是.symtab的阉割版。&lt;/p&gt;

&lt;p&gt;symtab的数据结构为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;typedef struct{
  Elf32_Word st_name; // 符号名在符号表中的索引
  Elf32_Addr st_value; // 符号相对应的值，是地址或者其他值
  Elf32_Word st_size; // 符号大小，包含数据的符号，该值为占用大小
  unsigned char st_info; // 符号类型和绑定信息
  unsigned char st_other; // 无用，值为0
  Elf32_Half st_shndx; // 符号所在段的索引
} Elf32_Sym;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;函数签名规则&quot;&gt;函数签名规则&lt;/h3&gt;

&lt;p&gt;前面说函数名就是符号名，会存储在符号表中，但C++中函数名常常会有相同的时候，因此编译器在编译时会对函数名进行处理，以区别不同范围内的函数。&lt;/p&gt;

&lt;p&gt;我们称这种改变符号名的机制为函数签名（Function Signature）。
签名后的函数名，包含了函数名、它的参数类型、它所在的类和命名空间以及其他信息。&lt;/p&gt;

&lt;p&gt;签名规则每种编译器都不一样，GCC编译器的规则为，所有符号以“_Z”开头，对于嵌套的名字后面紧跟“N”，然后是各个名称空间和类的名字，每个名字前是名字字符串长度，再以“E”结尾，“E”后面是参数列表，对于int类型来说就是字母“i”，float类型来说就是字母“f”，以此类推。&lt;/p&gt;

&lt;p&gt;来举几个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;* int func(int)  签名后--&amp;gt; _Z4funci --&amp;gt; _Z开头，4个字符的函数名func，参数是i整型
* float func(float) 签名后--&amp;gt; _Z4funcf --&amp;gt; _Z开头，4个字符的函数名func，参数是f浮点型
* int C::func(int) 签名后--&amp;gt; _ZN1C4funcEi --&amp;gt; _Z开头，嵌套1个字符C，接4个字符的函数名func，E结尾，参数是i整型
* int C::C2::func(int) 签名后--&amp;gt; _ZN1C2C24funcEi --&amp;gt; _Z开头，嵌套1个字符C，再嵌套2个字符C2，接4个字符的函数名func，E结尾，参数是i整型
* int N::func(int) 签名后--&amp;gt; _ZN1N4funcEi --&amp;gt; _Z开头，嵌套1个字符N，接4个字符函数名func，E结尾，参数是i整型
* int N::C::func(int) 签名后--&amp;gt; _ZN1N1C4funcEi --&amp;gt; _Z开图，嵌套1个字符N，再嵌套1个字符C，接4个字符func，E结尾，参数是i整型
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于不同编译器的签名规则不同，所以当我们要使用C语言写的外部函数时，就需要告诉编译器使用C语言的命名规则&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extern &quot;C&quot;{
  int func(int);
  int var;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们在C++中没有使用extern “C”申明会如何？
如果我们没有正确告知编译器外部引用函数的编译器规则，则在链接器链接时就会因为符号不匹配而无法链接，因此对于C++引用C函数来说，必须使用extern “C”来声明编译器规则。&lt;/p&gt;

&lt;h3 id=&quot;强符号弱符号强引用弱引用&quot;&gt;强符号弱符号，强引用弱引用&lt;/h3&gt;

&lt;p&gt;通常我们定义的变量和函数都是强符号和强引用，意思是当符号冲突时会直接覆盖原来的符号，而弱符号和弱引用则是当符号冲突时不覆盖原来的。
在编写通用库、共享库程序时，弱符号和弱引用，可以起到替换和被替换的作用。
例如库中定义的弱符号被用户定义的强符号覆盖，从而使得程序可以使用自定义版本的库函数；或者扩展某个功能模块时，弱引用被新模块接口覆盖，从而使得程序可以在正常使用的情况下扩展功能。
&lt;strong&gt;attribute&lt;/strong&gt;((week)) week_var = 2;
&lt;strong&gt;attribute&lt;/strong&gt;((weekref)) void func();&lt;/p&gt;

&lt;p&gt;Linux提供了几个工具来帮助我们了解ELF格式内容&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;readelf，可以帮助我们读取ELF文件中Section的内容&lt;/li&gt;
  &lt;li&gt;objdump，可以帮助我们翻译二进制指令和数据&lt;/li&gt;
  &lt;li&gt;c++filt，可以帮助我们解析被修饰过的名称&lt;/li&gt;
  &lt;li&gt;编译时通过加 -g 参数，可以让编译器在产生目标文件时加上调试信息&lt;/li&gt;
  &lt;li&gt;strip，可以通过这个命令把ELF中的调试信息都去除&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;静态链接&quot;&gt;静态链接&lt;/h3&gt;

&lt;p&gt;静态链接的过程其实就是把目标文件中的数据归档到一个文件中，其归档步骤有两步。&lt;/p&gt;

&lt;h3 id=&quot;第一步空间与地址分配&quot;&gt;第一步，空间与地址分配&lt;/h3&gt;

&lt;p&gt;扫描所有输入的目标文件，获取它们的各Section的数据，合并各段数据并建立映射关系。
同时把所有目标文件中的符号和符号定义都收集起来放到全局符号表中。&lt;/p&gt;

&lt;h3 id=&quot;第二步符号解析与重定位&quot;&gt;第二步，符号解析与重定位&lt;/h3&gt;

&lt;p&gt;根据第一步收集到的信息，包括Section和符号表信息，进行符号解析与重定位，调整代码中的地址。&lt;/p&gt;

&lt;h3 id=&quot;在重定位时由于各个符号的在section内的位置是相对固定的所以只要计算出section的偏移量就可以知道合并后的符号实际位置&quot;&gt;在重定位时，由于各个符号的在Section内的位置是相对固定的，所以只要计算出Section的偏移量就可以知道合并后的符号实际位置。&lt;/h3&gt;

&lt;h3 id=&quot;在第一步完成空间分配后就可以确定所有符号的虚拟地址了但这时目标文件内含有其他目标文件函数则需要另外通过符号表来重定位&quot;&gt;在第一步完成空间分配后，就可以确定所有符号的虚拟地址了，但这时目标文件内含有其他目标文件函数，则需要另外通过符号表来重定位。&lt;/h3&gt;

&lt;h3 id=&quot;由于在完成空间分配后全局符号表内的符号都确定了地址因此在重定位时可以使用全局符号表中的地址替换未定位地址&quot;&gt;由于在完成空间分配后，全局符号表内的符号都确定了地址，因此在重定位时可以使用全局符号表中的地址替换未定位地址。&lt;/h3&gt;

&lt;p&gt;每个目标文件都可能定义一些符号，也可能引用到定义在其他目标文件的符号。链接器在重定位的过程中，每个重定位的入口都是一个符号的引用，当需要对某个符号的引用进行重定位时，就要确定这个符号的目标地址。这时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位。&lt;/p&gt;

&lt;h3 id=&quot;注意在未确定外部符号地址时编译器把这部分地址暂时用0x00000000和0xfffffffc来代替在链接时再由链接器将计算好的地址填充进来&quot;&gt;注意：在未确定外部符号地址时，编译器把这部分地址暂时用“0x00000000”和“0xFFFFFFFC”来代替，在链接时再由链接器将计算好的地址填充进来。&lt;/h3&gt;

&lt;h3 id=&quot;重定位表-1&quot;&gt;重定位表&lt;/h3&gt;

&lt;p&gt;我们前面说过每个需要重定位的Section都有一个重定位表，例如“.text”有“.rel.text”，“.data”有“.rel.data”。&lt;/p&gt;

&lt;p&gt;每个重定位表里的数据为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;typedef struct{
  Elf32_Addr r_offset; // 相对于当前Section的相对位置
  Elf32_Word r_info; // 低8位表示重定位入口类型，高24位表示重定位入口符号的索引
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单来说就是，重定位表数据中有一个需要重定位的位置和一个重定位的符号名字符串索引，有了这两个数据，链接器就能在链接时从全局符号表中找到合并后的真实虚拟地址。&lt;/p&gt;

&lt;p&gt;在符号地址修正时，也分绝对寻址修正和相对寻址修正，它们的区别是绝对寻址修正后的地址为该符号的实际虚拟地址，相对寻址修正后的地址为符号距离被修正位置的地址差，因此它们分别服务的是不同类型的指令。&lt;/p&gt;

&lt;h3 id=&quot;全局构造和析构表&quot;&gt;全局构造和析构表&lt;/h3&gt;

&lt;p&gt;.init段中保存的初始化代码。当一个程序开始运行时在main函数调用之前Glibc的初始化程序会执行这个段中的代码。
.fini段中保存的析构代码。当一个进程的main函数正常退出时Glibc会安排执行这个段中的代码。
这两个段有特别的目的，.init在main函数前执行，.fini则在main函数后执行，利用这两个特性C++的全局构造和析构函数就由此实现。&lt;/p&gt;

&lt;h3 id=&quot;将不同编译器的编译结果链接&quot;&gt;将不同编译器的编译结果链接&lt;/h3&gt;

&lt;p&gt;那么有没有可能将不同编译器的编译结果链接成一个可执行文件呢？其实可以的，但非常困难。&lt;/p&gt;

&lt;p&gt;目标文件必须满足以下条件：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;目标文件的数据格式兼容&lt;/li&gt;
  &lt;li&gt;符号签名规则兼容&lt;/li&gt;
  &lt;li&gt;变量的内存分布方式兼容&lt;/li&gt;
  &lt;li&gt;函数调用方式兼容&lt;/li&gt;
  &lt;li&gt;堆栈分布方式兼容&lt;/li&gt;
  &lt;li&gt;寄存器使用阅读兼容&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们把这种链接时的兼容性相关内容称为ABI（Application Binary Interface）。与API不同的是，ABI是指二进制层面的接口兼容性更加严格，而API则只是源代码级别上的的接口。
其实不同编译器链接成可执行文件的最大问题就是，各种硬件平台、编程语言、编译器、链接器和操作系统之间的ABI互不兼容。由于ABI的不兼容，导致各个目标文件之间无法互相链接。&lt;/p&gt;

&lt;h3 id=&quot;静态库与链接&quot;&gt;静态库与链接&lt;/h3&gt;

&lt;p&gt;其实静态库可以简单看成一组目标文件的集合，在制作静态库时只是将所有目标文件打包压缩后归档为一个文件而已。&lt;/p&gt;

&lt;p&gt;Linux下可以使用“ar”这个工具命令来归档目标文件，“ar”压缩程序将所有目标文件压缩到一起并对其进行编号和索引，以便于查找和检索，就形成了xxx.a静态库文件。Visual C++也提供了类似ar的工具，叫lib.exe，这个程序可以用来创建、提取、查看.lib文件中的内容。&lt;/p&gt;

&lt;p&gt;在静态库链接时，Linux下的链接器ld会自动寻找需要的静态库，并从中解压出来目标文件，再最终将这些目标文件链接在一起成为可执行文件。&lt;/p&gt;

&lt;p&gt;从这个规则上看来，我们在编写静态库的时候，最好是每个函数独立存放在一个目标文件中，因此这样可以尽量减少空间浪费，因为没有被用到的目标文件就不会链接到最终的输出文件中。&lt;/p&gt;

&lt;h3 id=&quot;中间件bfd库&quot;&gt;中间件BFD库&lt;/h3&gt;

&lt;p&gt;我们说各种操作系统平台都遵循类似ELF格式的文件格式，虽然是相似的ELF格式但在不同软硬件平台都有着不同的变种。
种种差异导致编译器和链接器很难处理不同平台之间的目标文件，因此最好有一种统一的接口来处理不同格式的文件。
BFD库（Binary File Dexcriptor library）就是为了这个目的存在的，它的目标就是用一种统一接口来处理不同的目标文件格式。&lt;/p&gt;

&lt;p&gt;现在GCC编译器、链接器ld、调试器gdb、binutils等工具都是通过BFD库来处理文件，而不直接操作目标文件。
这样做的好处是将编译器和链接器与具体的目标文件格式隔离开来，一旦我们需要支持一种新的目标文件格式，只需要在BFD库里添加一种格式就可以了，而不需要再去修改编译器和链接器。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484763&amp;amp;idx=1&amp;amp;sn=f1b3d678c1309a66d44b64b7ff22a002&amp;amp;chksm=fc22605ccb55e94a53558e85fdbe196fc58612fe20c88f35f8c0f4098e240ef48bcd2da099b0&amp;amp;token=535520395&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;
</description>
               <pubDate>Sun, 20 Jun 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/06/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B029</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/06/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B029</guid>
            </item>
        
            <item>
               <title>读书笔记(二十八) 《C++ Primer》#3</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484764&amp;amp;idx=1&amp;amp;sn=edc0beab7722d092571c8f88a9a38bd6&amp;amp;chksm=fc22605bcb55e94d95e3445b7449c42f87450a2fcc8dd16d63f44a242b17e63b6f5051e91dcd&amp;amp;token=535520395&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;背景&quot;&gt;背景：&lt;/h3&gt;

&lt;p&gt;我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意。第三是当我们在巩固时创造出了新的知识，那么这些新的知识和旧的知识将同时变成智慧融合到身体中。&lt;/p&gt;

&lt;p&gt;本系列基于《C++ Primer》学习，由于重点放在“重学”，我略过了滚瓜烂熟的部分，挑出以前常忽略的部分，以及记忆没有那么深刻的部分，特别是那些重要的但没有上心的部分。&lt;/p&gt;

&lt;h3 id=&quot;开始&quot;&gt;开始&lt;/h3&gt;

&lt;h3 id=&quot;左值和右值&quot;&gt;左值和右值&lt;/h3&gt;

&lt;p&gt;这两个名词是从C语言继承过来的，原本是为了帮助记忆即：左值可以位于赋值语句的左侧，右值则不能。
在C++语言中则没那么简单了，可以简单归纳为：
当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。&lt;/p&gt;

&lt;p&gt;不同运算符对运算对象的要求不同，有的需要左值运算对象、有的则需要右值运算对象。
因此有个重要原则：在需要右值的地方可以用左值来代替，但不能把右值当左值（也就是位置）使用。当一个左值被当成右值使用时，实际使用的是它的内容（就是值）。&lt;/p&gt;

&lt;p&gt;举几个例子：
	赋值运算符，是左值运算，因为结果是值（内容）
	取地址符，是右值运算，因为结果的是指针或地址
	解引用运算符、下标运算符，是左值运算，因为运算结果是值（内容）
	递增运算，是左值运算，因为运算结果是值（内容）&lt;/p&gt;

&lt;h3 id=&quot;关于后置&quot;&gt;关于后置++&lt;/h3&gt;

&lt;p&gt;这里有个小提示，后置++版本会多浪费一个寄存器，但是编译器会帮我们优化掉，不过对于迭代器来说则不同，编译器通常不会优化迭代器的后置++，因此我们在使用迭代器后置++时要注意一下代码的优化。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;cout&amp;lt;&amp;lt; *iter++ &amp;lt;&amp;lt; endl;
==&amp;gt; 优化
count&amp;lt;&amp;lt; *iter &amp;lt;&amp;lt; endl;
++iter;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;sizeof运算符&quot;&gt;sizeof运算符&lt;/h3&gt;

&lt;p&gt;sizeof有离线计算和实时运算之分，通常情况下有些值在离线时就能知道的类型的大小，这时编译器都会在编译时就将其替换成固定值。&lt;/p&gt;

&lt;p&gt;举例说明sizeof运算符的结果取决于其作用类型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对char类型表达式执行sizeof运算，结果为1。编译器离线计算&lt;/li&gt;
  &lt;li&gt;对引用类型执行sizeof，结果为被引用对象所占空间大小。编译器离线计算&lt;/li&gt;
  &lt;li&gt;对指针执行sizeof运算，结果为指针本身空间大小。编译器离线计算&lt;/li&gt;
  &lt;li&gt;对解引用指针执行sizeof，结果为指针指向的对象的空间大小。编译器离线计算&lt;/li&gt;
  &lt;li&gt;对数组执行sizeof运算，结果是整个数组所占空间大小。编译器离线计算&lt;/li&gt;
  &lt;li&gt;对string对象或vector对象执行sizeof运算，结果为该类型固定部分的大小。实时计算空间大小&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;强制类型转换&quot;&gt;强制类型转换&lt;/h3&gt;

&lt;p&gt;强制类型转换的根本目的就是告诉编译器，该变量的类型改变了，符合后面的逻辑运算，好让在编译器在编译时能够不误解逻辑运算，所以编译器并没有对内存内容做任何的改变，它只是为了迎合编译器。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;//旧式的强制类型转换
type (expr); // 函数形式的强制类型转换
(type) expr; // c语言风格的强制类型转换

//新式的强制类型转换
static_cast&amp;lt;type&amp;gt;(expression); // 静态转换
dynamic_cast&amp;lt;type&amp;gt;(expression); // 运行时转换
const_cast&amp;lt;type&amp;gt;(expression); // 常量转换
reinterpret_cast&amp;lt;type&amp;gt;(expression); // 低阶类型转换
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;强制转换分为static_cast静态转换dynamic_cast运行时转换const_cast常量转换reinterpret_cast低阶类型转换4种&quot;&gt;强制转换分为，static_cast（静态转换），dynamic_cast（运行时转换），const_cast（常量转换），reinterpret_cast（低阶类型转换）4种&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;static_cast静态转换，直接将对象转换成指定类型对象。&lt;/li&gt;
  &lt;li&gt;dynamic_cast运行时转换，通常用于继承对象，运行时转换会先通过RTTI的方式判断是否能进行父子转换，如果可以再进行执行转换。&lt;/li&gt;
  &lt;li&gt;const_cast常量转换，只能改变运算对象的底层const无法改变具体类型，可以将const变量转换为非const变量，这样编译器就不再阻止我们对该对象进行写操作了。&lt;/li&gt;
  &lt;li&gt;reinterpret_cast低阶类型转换，通常为运算对象的位模式提供低层次上的解释。例如将int转换为char*等低阶模式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;注意使用reinterpret_cast比较危险的是使用reinterpret_cast强制转换后编译器不会怀疑所转换的类型如果类型错误则会因调用混乱而崩溃而编译器在编译时不会发出任何警告或错误因此reinterpret_cast通常适合比较底层转换工作&quot;&gt;注意：使用reinterpret_cast比较危险的是，使用reinterpret_cast强制转换后编译器不会怀疑所转换的类型，如果类型错误则会因调用混乱而崩溃，而编译器在编译时不会发出任何警告或错误，因此reinterpret_cast通常适合比较底层转换工作。&lt;/h3&gt;

&lt;h3 id=&quot;异常处理&quot;&gt;异常处理&lt;/h3&gt;

&lt;p&gt;当异常被抛出时，首先在该函数中寻找匹配的catch子句，如果没有找到则终止该函数并在调用该函数的函数中继续寻找，以此类推沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。
如果最终还是没能找到任何匹配的catch子句，程序会转到名为terminate的标准库函数中。该函数的行为与系统有关，一般情况下，执行该函数会导致程序非正常退出。
如果当程序没有使用try catch语句且发生了异常，系统会直接调用terminate函数并终止当前程序的执行。&lt;/p&gt;

&lt;h3 id=&quot;分离式编译&quot;&gt;分离式编译&lt;/h3&gt;

&lt;p&gt;分离式编译的意思就是，多个源文件在编译中可以只顾自己编译，最后再统一链接到执行文件或库文件中。&lt;/p&gt;

&lt;p&gt;在分离式编译中，如果我们修改了其中一个源文件，那么只需要重新编译那个改动了的文件，再重新链接就可以。
现代大多数编译器提供了分离式编译每个文件的机制，这一过程通常会产生一个后缀名是.obj（windows）或.o(UNIX)的目标文件，再用链接器将所有目标文件链接成可执行文件或库文件。&lt;/p&gt;

&lt;h3 id=&quot;参数传递&quot;&gt;参数传递&lt;/h3&gt;

&lt;p&gt;解释下，实参就是要传递的数据变量，形参就是传递后函数中的参数变量。&lt;/p&gt;

&lt;p&gt;参数传递分引用传递和值传递&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;引用传递，通过传递引用的方式避免了对象拷贝。&lt;/li&gt;
  &lt;li&gt;值传递，则都是通过拷贝对象传递数据的。其中指针形参也是值传递，只不过传递时拷贝的是指针数据而非具体对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;函数设置参数时，我们要注意尽量使用const常量引用或指针作为形参，因为这样既避免了对象拷贝，又可以限制对象的修改。&lt;/p&gt;

&lt;h3 id=&quot;可变形参&quot;&gt;可变形参&lt;/h3&gt;

&lt;p&gt;使用initializer_list类型的形参可以做到传递可变数量的实参。和Vector不一样的是，initializer_list中的元素永远都是常量值。&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;void test_func(initializer_list&amp;lt;string&amp;gt; li)
{
  for(auto beg = li.begin(); beg != li.end() ; ++beg)
      cout&amp;lt;&amp;lt; *beg &amp;lt;&amp;lt; &quot; &quot;;
}

test_func(&quot;1&quot;,&quot;3&quot;,&quot;4&quot;);
test_func(&quot;2&quot;,&quot;3&quot;);
test_func(&quot;2&quot;,&quot;4&quot;,&quot;6&quot;,&quot;8&quot;,&quot;10&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;值返回和引用返回&quot;&gt;值返回和引用返回&lt;/h3&gt;

&lt;p&gt;与值传递和引用传一样，在函数返回时，我们也需要注意拷贝操作。&lt;/p&gt;

&lt;p&gt;例如字符串拼接后的返回值就会造成对象拷贝的消耗：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;string test_func(string &amp;amp;a, string &amp;amp;b)
{
   return a + b;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了避免拷贝我们会使用引用返回或指针，但要注意，使用引用返回或指针时如果返回的是局部对象则会引起内存使用错误。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;string &amp;amp;test_func()
{
   string test = &quot;test&quot;;
   return test; // 错误的返回了局部变量，导致内存使用错误
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;函数重载&quot;&gt;函数重载&lt;/h3&gt;

&lt;p&gt;函数重载的特点是函数名字相同参数列表不同且在同一个作用域。&lt;/p&gt;

&lt;p&gt;在重载函数调用时，可能与我们想象的不同，其实编译器在离线时就区分了不同重载函数的调用地址。
当调用重载函数时，编译器会根据传递的实参类型去比较每个重载函数的参数直到匹配成功或失败。
我们知道虽然重载函数名字相同，但参数列表不同，这导致函数签名时的实际名字是不同，也就相当于调用的是不同名字的函数。&lt;/p&gt;

&lt;p&gt;举例说明重载函数的函数签名后命名不同：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;int func(int); //  函数签名后--&amp;gt; _Z4funci 
int func(float); // 函数签名后--&amp;gt; _Z4funcf

func(3); // -&amp;gt; 匹配 _Z4funci
func(3.5F); // -&amp;gt; 匹配 _Z4funcf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重载函数的匹配过程为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;收集所有重载函数&lt;/li&gt;
  &lt;li&gt;比较实参与所有重载函数的形参，寻找最佳匹配函数&lt;/li&gt;
  &lt;li&gt;匹配规则为精准匹配和转换匹配两种，精准匹配要求实参与形参高度一致，转换则可以通过const转换、类型提升、算术类型转换来实现匹配。&lt;/li&gt;
  &lt;li&gt;匹配成功后替换为匹配函数的函数签名&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;至于函数签名的规则，其实每种编译器都不同，不过也是大同小异的。例如上述我们举例代码中的GCC编译器的规则为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所有符号以“_Z”开头，&lt;/li&gt;
  &lt;li&gt;对于嵌套的名字后面紧跟“N”，&lt;/li&gt;
  &lt;li&gt;然后紧跟各个名称空间和类的名字，每个名字前是名字字符串长度，&lt;/li&gt;
  &lt;li&gt;再以“E”结尾，“E”后面是所有参数，&lt;/li&gt;
  &lt;li&gt;参数以简写代替，例如对于int类型来说就是字母“i”，float类型来说就是字母“f”，以此类推。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;内联函数&quot;&gt;内联函数&lt;/h3&gt;

&lt;p&gt;我们知道函数在调用时会先保存当前寄存器、拷贝实参值、并在返回时拷贝恢复，这些都是函数调用的消耗。&lt;/p&gt;

&lt;p&gt;内联函数则可以避免函数调用的消耗，其原理是就地展开函数，这样能省去了函数调用前和后的一系列操作。
我们可以通过内联关键字inline告诉编译器该函数需要在编译器时展开，但这也只是向编译器发出请求而已，如果编译器认为该内敛展开后性价比不高可以选择忽略这个请求。&lt;/p&gt;

&lt;p&gt;常量表达函数constexpr，我们可以通过constrexpr定义常量表达式的函数，与普通内联函数不同的是，编译器会把constexpr函数的调用替换成实际结果，简单来说就是离线计算好结果并替换调用函数。&lt;/p&gt;

&lt;p&gt;对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致，基于这个原因，内联函数和constexpr函数通常定义在头文件中。&lt;/p&gt;

&lt;h3 id=&quot;调试辅助指令&quot;&gt;调试辅助指令&lt;/h3&gt;

&lt;p&gt;assert是常见的调试工具，它其实是一个预处理宏，通过判断表达式来终止程序执行。&lt;/p&gt;

&lt;p&gt;assert的行为依赖于一个名为NDEBUG的预处理变量。如果定义了NDEBUG，则assert什么也不做。
默认状态下没有定义NDEBUG，我们可以使用#define来定义NDEBUG从而关闭调试状态，或者使用编译器的预处理指令
cc -D NDEBUG main.c&lt;/p&gt;

&lt;p&gt;除了assert，C++编译器还定义了多个帮助我们调试的变量，例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;func&lt;/strong&gt;，存放的是当前函数名字&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;FILE&lt;/strong&gt;，存放的是当前文件名&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;LINE&lt;/strong&gt;，存放的是当前代码行号&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;TIME&lt;/strong&gt;，存放的是当前文件编译时间&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;DATA&lt;/strong&gt;，存放的是当前文件编译日期&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;函数指针&quot;&gt;函数指针&lt;/h3&gt;

&lt;p&gt;函数指针指向的是函数地址，它的类型由它的返回值类型、形参类型共同决定，编译器会检查函数类型与函数指针类型之间的一致性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;bool (*point_func)(const string &amp;amp;, const string &amp;amp;);
// point_func前面有个*，因此point_func是指针，这里括号不能少。
// point_func右侧是形参列表，表示point_func指向的是，两个const string引用为参数、并且返回值是bool的函数类型。

bool lenCompare(const string &amp;amp;, const string &amp;amp;);

point_func = lenCompare; //指向lenCompare
point_func = &amp;amp;lenCompare; //等价于赋值
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在指向不同函数类型的指针间不存在转换规则，也就是说，不同类型函数之间无法转换，即我们无法将一个类型函数转换到另一个类型函数指针。&lt;/p&gt;

&lt;p&gt;在将函数指针用于形参、返回值、重载函数时，都必须遵循函数类型与函数指针一致性的原则，编译器不会自动将函数类型转换成我们想要的类型，因为转换是不允许的。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484764&amp;amp;idx=1&amp;amp;sn=edc0beab7722d092571c8f88a9a38bd6&amp;amp;chksm=fc22605bcb55e94d95e3445b7449c42f87450a2fcc8dd16d63f44a242b17e63b6f5051e91dcd&amp;amp;token=535520395&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

</description>
               <pubDate>Sat, 19 Jun 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/06/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B028</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/06/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B028</guid>
            </item>
        
            <item>
               <title>给女儿的信(十三) 要赢的是自己</title>
               <description>&lt;p&gt;Sharon，Anne，爸爸回到深圳了，很想你们哟。&lt;/p&gt;

&lt;p&gt;这里的天气和杭州一样暖，只是这里没有太多的雨。爸爸又回到了公司开始工作了。&lt;/p&gt;

&lt;p&gt;想起在家里和你们一起的这几天，爸爸很开心哟，爸爸喜欢和你们一起玩、一起学习。&lt;/p&gt;

&lt;p&gt;还记得Sharon跟爸爸一起玩拼图游戏的时候吗，Sharon老想着要和爸爸比谁快。&lt;/p&gt;

&lt;p&gt;爸爸跟你说，不要总想着和别人比，要和自己比。&lt;/p&gt;

&lt;p&gt;Sharon疑惑的问爸爸，什么是跟自己比。&lt;/p&gt;

&lt;p&gt;爸爸跟你说，爸爸以前也总是和别人比，但是和别人比总会让爸爸很紧张发挥不出真正的实力，因为爸爸总想赢，太着急了太在意了赢得也不轻松，输了就会很失落。&lt;/p&gt;

&lt;p&gt;所以当爸爸想着和别人比的时候，情绪波动很大，特别遇到比自己厉害很多的人时心情就更低落了。&lt;/p&gt;

&lt;p&gt;爸爸后来不和别人比了，因为这样太不好了，转而和自己比。&lt;/p&gt;

&lt;p&gt;怎么比呢，例如，去年我能看多少本书，今年我就比去年多看几本书。&lt;/p&gt;

&lt;p&gt;去年我能认识多少字，今年我就比去年的我多认识一些。&lt;/p&gt;

&lt;p&gt;每天坚持积累一些些，今天的我比昨天的我进步一些些，每天都在跟昨天的自己比，跟过去的自己比，我每次都能战胜过去的自己，我就像是不断战胜自己的勇士那样，充满了斗志。&lt;/p&gt;

&lt;p&gt;即使这样爸爸有时候也还是会陷入到和别人比较的陷进中去，但爸爸慢慢习惯和自己比赛后，挣脱出这种困境就越来越容易了。&lt;/p&gt;

&lt;p&gt;由于每天积累看书，帮助爸爸建立起了丰富的知识，让爸爸在工作和生活当中更加轻松自如哟。&lt;/p&gt;

&lt;p&gt;Sharon、Anne要和爸爸一起加油哟。爱你们。&lt;/p&gt;

</description>
               <pubDate>Wed, 16 Jun 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/06/16/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A113</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/06/16/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A113</guid>
            </item>
        
            <item>
               <title>读书笔记(二十七) 《装载、链接与库》#1</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484732&amp;amp;idx=1&amp;amp;sn=e53f438b8815df3840208d7caa36f4f7&amp;amp;chksm=fc22603bcb55e92debcabe242e42139c805b56addbc5993c1f521e967806f5bb76d62b0bb612&amp;amp;token=890029854&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;背景&quot;&gt;背景：&lt;/h2&gt;

&lt;p&gt;看此书的起源是我在了解Linux注入技术的时候翻阅到的，由于注入技术需要用到很多ELF格式的内容，很多网络上的技术文章都指向了同一本书。也刚好周围的同事有此书，便翻阅了一下，这一番翻阅打开了我对程序世界的又一扇大门。&lt;/p&gt;

&lt;p&gt;很快我就自己买了此书并阅读完成，整本书给我很大的震撼，让我对程序从编译到链接到装载有了更深刻的认识。&lt;/p&gt;

&lt;p&gt;为了能更好的巩固知识，我把我的整个学习过程以及对书本的理解，用自己的语言和自己画的图表达出来，让读者能够很好的接受到我所学的知识。&lt;/p&gt;

&lt;h2 id=&quot;目标&quot;&gt;目标：&lt;/h2&gt;

&lt;p&gt;了解编译过程&lt;/p&gt;

&lt;p&gt;了解动态库和静态库的装载细节&lt;/p&gt;

&lt;p&gt;了解可执行程序装载和执行过程&lt;/p&gt;

&lt;p&gt;了解可执行文件和动态库的数据格式&lt;/p&gt;

&lt;h2 id=&quot;疑问&quot;&gt;疑问：&lt;/h2&gt;

&lt;p&gt;c/c++编译器是如何将cpp编译为可执行文件的？&lt;/p&gt;

&lt;p&gt;多个c/c++文件是如何编译成一个可执行文件的？&lt;/p&gt;

&lt;p&gt;操作系统内存是如何初始化和管理的？&lt;/p&gt;

&lt;p&gt;动态库和静态库的链接和装载过程是怎样的？&lt;/p&gt;

&lt;p&gt;操作系统的用户态和内核态是如何运作的？&lt;/p&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文：&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484732&amp;amp;idx=1&amp;amp;sn=e53f438b8815df3840208d7caa36f4f7&amp;amp;chksm=fc22603bcb55e92debcabe242e42139c805b56addbc5993c1f521e967806f5bb76d62b0bb612&amp;amp;token=890029854&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

</description>
               <pubDate>Mon, 14 Jun 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/06/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B027</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/06/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B027</guid>
            </item>
        
            <item>
               <title>读书笔记(二十六) 《C++ Primer》#2</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484732&amp;amp;idx=3&amp;amp;sn=13204e3fd9171849653497a8c788c649&amp;amp;chksm=fc22603bcb55e92dfe641a5066c21000b70a3a03a61d2c691324b23a20ae3fffeef40a70facd&amp;amp;token=890029854&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;背景&quot;&gt;背景：&lt;/h2&gt;

&lt;p&gt;我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意。第三是当我们在巩固时创造出了新的知识，那么这些新的知识和旧的知识将同时变成智慧融合到身体中。&lt;/p&gt;

&lt;p&gt;本系列基于《C++ Primer》学习，由于重点放在“重学”，我略过了滚瓜烂熟的部分挑出以前常忽略的部分，以及记忆没有那么深刻的部分，特别是那些重要的但没有上心的部分。&lt;/p&gt;

&lt;h2 id=&quot;开始&quot;&gt;开始&lt;/h2&gt;

&lt;h2 id=&quot;1const限定&quot;&gt;1.const限定&lt;/h2&gt;

&lt;p&gt;关键字const对变量的类型加以限定，因此它的值在初始化后不能被改变。&lt;/p&gt;

&lt;p&gt;const默认情况下只在文件内生效，当需要支持多个文件共享时，则使用extern关键字，不管定义和声明都添加extern关键字，并且只需要定义一次。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//a.cpp&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test_constVar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fcn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//b.cpp&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test_constVar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;通过添加extern共享const变量。&lt;/p&gt;

&lt;h2 id=&quot;const引用常量引用&quot;&gt;const引用（常量引用）&lt;/h2&gt;

&lt;p&gt;与普通引用不同的是，常量引用不能被用作它修改它所绑定的对象。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ci&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;r1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//错误，常量引用不能修改绑定对象&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//错误，普通引用无法赋值常量&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;严格来说，并不存在常量引用。因为引用不是一个对象，所以我们没法让引用本身恒定不变。
事实上，由于c++语言并不允许随意改变引用所绑定的对象，所以从这层意义上理解所有的引用又都算是常量。
引用的对象是常量还是非常量可以决定其所能参与的操作，却无论如何都不会影响到引用和对象的绑定关系。
简单来说，由于绑定对象无法改变，所以要求引用对象也不能改变。&lt;/p&gt;

&lt;p&gt;但const引用可以绑定一个非const对象，其意义为，绑定后const引用无法改变，只能由所绑定的对象来决定内容。&lt;/p&gt;

&lt;h2 id=&quot;const指针常量指针&quot;&gt;const指针（常量指针）&lt;/h2&gt;

&lt;p&gt;const指针与const引用有同样的规则。
const指针在初始化后无法改变，const指针不能改变所指对象的值，但可以指向非常量变量。
当指向非常量时，const指针所指向的对象的值，只能由对象本身来决定。&lt;/p&gt;

&lt;p&gt;C++11中，用constexpr来表示常量表达式，声明为constexpr的变量是一个常量，编译器会验证变量的值是否为常量表达式并离线计算该值。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//离线计算&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//离线计算&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// size()必须是constexpr函数&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;2类型别名&quot;&gt;2.类型别名&lt;/h2&gt;

&lt;p&gt;类型别名是某种类型的同义词。&lt;/p&gt;

&lt;p&gt;使用类型别名是为了让复杂的类型名字变得简单明了、易于理解和使用。&lt;/p&gt;

&lt;p&gt;C++11新标准中，使用using来定义类型的别名&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//wages是double的同义词&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wages&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//base是double的同义词，并且p是double*的同义词&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pstring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//pstring 是char*的同义词&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;It&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Item_test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// It 是Item_test的同义词&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//定义&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;wages&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//定义double 变量&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;It&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//定义Item_test 变量&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pstring&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//定义一个char *&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;3其他&quot;&gt;3.其他&lt;/h2&gt;

&lt;p&gt;auto和decltype都是用来让编译器在离线下自动识别类型的关键字。
其中decltype着重识别结果类型与表达式的关系。&lt;/p&gt;

&lt;p&gt;预处理器能确保头文件多次包含仍能安全工作，它在编译之前被执行。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt; &lt;span class=&quot;cp&quot;&gt;#include、#define、#ifdef、#ifndef都是预处理关键字。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;第3章&quot;&gt;第3章&lt;/h2&gt;

&lt;h2 id=&quot;1string字符串类&quot;&gt;1.string字符串类&lt;/h2&gt;

&lt;p&gt;前面说using可以用于类型别名，using也可以用于声明命名空间。
using namespace::name
不过头文件中不应包含using声明，因为这会导致头文件在被拷贝时多次重复声明using。&lt;/p&gt;

&lt;p&gt;string是标准库中的类对象。
string在使用中最容易发生的问题就是拷贝。
特别是等号(=、+)引起的合并和拷贝需要注意。
string在比较时(==、!=、&amp;lt;、&amp;lt;=、&amp;gt;、&amp;gt;=)有比较算法但每个字符都会比较。&lt;/p&gt;

&lt;p&gt;严格来说string对象不属于容器类型，但string支持很多与容器类似的操作，比如下标、迭代器等。&lt;/p&gt;

&lt;h2 id=&quot;2vector动态数组&quot;&gt;2.vector动态数组&lt;/h2&gt;

&lt;p&gt;vector是标准中的动态数组模版库。
模版本身不是类或函数，可以把模版看成编译器生成的类或函数。编译器根据模版创建类或函数的过程称为实例化。因此使用模版时，我们要指出编译器应把类或函数实例化成何种类型。
因此vector是模版而非类型，由vector生成的类才叫类型。&lt;/p&gt;

&lt;p&gt;vector容器本身就是对象，因此也能通过拷贝初始化。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 初始化3个元素，1、2、3&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 初始化10个元素，都是-1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 用拷贝来初始化，将v1中的数据拷贝到v3，完成后v3拥有独立的数据&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 提前预备20个值，每个值都是0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;由于vector是动态数组，因此如果能在初始化时提前告知vector的话，vector就不用扩容了，运行时性能会更好。&lt;/p&gt;

&lt;h2 id=&quot;3迭代器&quot;&gt;3.迭代器&lt;/h2&gt;

&lt;p&gt;迭代器有三种不同含意，一是迭代器概念本身，二是容器定义的迭代器类型，三是指某个迭代器对象。&lt;/p&gt;

&lt;p&gt;有时她跟指针很像，但又完全不一样。&lt;/p&gt;

&lt;p&gt;其实迭代器是个由模版封装过的类，根据不同的类型的容器，编译器生成功能相似但命名不同的类。&lt;/p&gt;

&lt;p&gt;迭代器又重写了==、&amp;gt;、&amp;lt;、!=、&amp;lt;=、&amp;gt;=、+=、-=运算符，使得我们在编写代码时更加方便。&lt;/p&gt;

&lt;p&gt;共识：当使用迭代器时如果对容器做了增删操作，则会使得迭代器失效，甚至报错和崩溃。&lt;/p&gt;

&lt;p&gt;迭代器对象是实时生成的，当我们获取迭代器对象时，容器会实时生成一个迭代器对象，我们再通过操作这个迭代器对象达成我们的目的。&lt;/p&gt;

&lt;h2 id=&quot;4数组&quot;&gt;4.数组&lt;/h2&gt;

&lt;p&gt;一些复杂的数组声明难以理解，因此如果能从数组的名字开始按照由内向外的顺序阅读会更加容易些。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 普通数组含有10个整数&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ptrs是含有10个整数指针的数组&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Parray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Parray指向一个含有10个整数的数组&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arrRef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// arrRef引用一个含有10个整数的数组&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptrs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//arry是数组的引用，该数组含有10个整数指针&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;数组真正使用的时候编译器会把它转成指针。
因此指向数组的指针可以使用+、-、==、!=运算符号来操作数组。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// e指向arr元素的下一位置&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;至于多维数组，严格来说C++中没有多维数组，通常所说的多维数组其实是数组的数组，也就是用数组类型组成的数组。&lt;/p&gt;

&lt;p&gt;其中要注意的是在多维数组遍历时，其遍历顺序应该按照数组的整块内存来遍历，否则命中效率比较低。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484732&amp;amp;idx=3&amp;amp;sn=13204e3fd9171849653497a8c788c649&amp;amp;chksm=fc22603bcb55e92dfe641a5066c21000b70a3a03a61d2c691324b23a20ae3fffeef40a70facd&amp;amp;token=890029854&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

</description>
               <pubDate>Sat, 12 Jun 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/06/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B026</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/06/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B026</guid>
            </item>
        
            <item>
               <title>读书笔记(二十五) 《C++ Primer》#1</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484732&amp;amp;idx=2&amp;amp;sn=cbf9e354ddf1157c9913d7e4fc3ad41f&amp;amp;chksm=fc22603bcb55e92dd8e5fdd6210f007c072f1208ecf85a081f0273f26e54ff95ad9d219d2094&amp;amp;token=890029854&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;背景&quot;&gt;背景：&lt;/h2&gt;

&lt;p&gt;我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意，将这些知识变成智慧融合到身体中。&lt;/p&gt;

&lt;p&gt;本系列基于《C++ Primer》学习，重学的时候，我略过了滚瓜烂熟的部分，挑出以前忽略的，以及记忆没有那么深刻的，特别是那些重要的但以前没有上心的部分。&lt;/p&gt;

&lt;h2 id=&quot;开始&quot;&gt;开始&lt;/h2&gt;

&lt;p&gt;使用命令行界面来学习c++会更好一些，这种学习方式可以让你将精力集中在c++语言本身上，一旦掌握了语言，使用和学习IDE编辑器通常也更容易些。&lt;/p&gt;

&lt;p&gt;.h文件作为头文件只是程序员的习惯，头文件后缀并没有特定的规范，通常为了方便查看都以.h为后缀。&lt;/p&gt;

&lt;p&gt;编译器一般不关心文件名的形式，但有的IDE对此有特定要求。&lt;/p&gt;

&lt;h2 id=&quot;c基础&quot;&gt;c++基础&lt;/h2&gt;

&lt;p&gt;c++是一种静态数据类型语言，它的类型检查发生在编译时。因此，编译器必须知道程序中每一个变量对应的数据类型。&lt;/p&gt;

&lt;p&gt;c++提供了一组内置数据类型、相应的运算符、以及为数不多的程序流控制语句，这些元素共同构成了c++语言的基本形态。&lt;/p&gt;

&lt;p&gt;仅就c++的基本形态来说，它是一种简单的编程语言。&lt;/p&gt;

&lt;p&gt;但其强大的能力显示于它对程序员自定义数据结构的支持，程序员可以通过自主定义新的数据结构来使语言满足他们各自的需求。&lt;/p&gt;

&lt;p&gt;省略掉一些简单变量类型的内容，将一些特别需要注意，以及大家常忽略又比较重要的内容提取出来。&lt;/p&gt;

&lt;p&gt;类型转换&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;char在一些机器上是有符号的，另一些机器上则是无符号的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当我们赋值给一个无符号类型的变量一个超出它范围的值时，结果是总数取模后的余数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当我们赋值给带符号类型一个超出他范围的值时，结果是未定义（不可预测）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;切勿混用有符号和无符号的类型，如果表达式里既有带符号又有无符号类型，带符号的数会自动转换成无符号，如果是个负数则会出现异常结果。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;无法预知的行为源于编译器无须检查的错误。在某些情况或某些编译器下，含有无法预知行为的程序也能正确执行。&lt;/p&gt;

&lt;p&gt;不可移植通常都是程序依赖了环境，或操作系统环境或编译器环境，程序应该尽量避免依赖于实现环境的行为。例如我们把 int 的尺寸看成一个固定不变的值，这样的程序就称为不可移植。&lt;/p&gt;

&lt;h2 id=&quot;变量&quot;&gt;变量&lt;/h2&gt;

&lt;p&gt;何为对象？对象就是指一块能存储数据并具有某种类型的内存空间。&lt;/p&gt;

&lt;p&gt;初始化是一个复杂的过程，很多程序员对于初始化的认识，停留在=等号赋值的认知上。事实上它完全不是这样的。&lt;/p&gt;

&lt;p&gt;它有构造、拷贝、赋值三种途径，且有默认构造、未初始化、定义与声明三个容易出错的地方。&lt;/p&gt;

&lt;p&gt;初始化并不一定被默认执行，这是因为并对象不一定有默认构造函数，且有些编译器构造的默认构造函数并不一定会去初始化变量，这导致一个未被初始化的变量在拷贝和访问时就会引发错误，因此我们最好自己主动的去初始化每个变量。&lt;/p&gt;

&lt;p&gt;c++支持分离式编译，允许将程序分为若干个文件，每个文件可被独立编译。&lt;/p&gt;

&lt;p&gt;因此我们可以把变量的定义和声明区分开来，即在某个文件中定义，在另一些文件中声明后再使用。&lt;/p&gt;

&lt;p&gt;变量能且只能定义一次，但可以被多次声明，在声明时不能重复初始化：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// a.cpp&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;global_index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//定义&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// b.cpp&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;global_index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//声明&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;global_index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// c.cpp&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;global_index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//声明&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;global_index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;如上代码中，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpp&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;中定义了&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;global_index&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;并初始化为&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，在&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpp&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;和&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpp&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;中使用。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;复合类型&quot;&gt;复合类型&lt;/h2&gt;

&lt;p&gt;复合类型有两种，即引用和指针。&lt;/p&gt;

&lt;p&gt;引用特点：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	引用本身不是对象，而它必须绑定一个对象。

	引用在定义时必须被初始化，它不能为空。

	引用在初始化后，与它的值绑定在一起，并且无法再重新绑定到另外的对象上。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指针特点：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	指针本身就有自己的对象概念，存放的是对象的地址，可为null也可以为具体的指针值。

	指针无须在定义时初始化（未初始化有风险），可以为空，也可以指向某个对象，也可能是无效的野指针。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引用和指针通过，取地址符（&amp;amp;），解引用（*）来操作，我们来举个例子：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 初始化&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 绑定dval&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 取地址，赋值给指针&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 此时dval 为3，tval也为3，*pd也为3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;特殊指针：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	1.c++11中引入了nullptr的空指针类型，以前用的NULL空指针，其实质是一个宏预处理，NULL定义在cstdlib中值为0。
	
	2.void*也是特殊指针，可用于存放任意对象地址。但不能操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，它仅仅是内存空间。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484732&amp;amp;idx=2&amp;amp;sn=cbf9e354ddf1157c9913d7e4fc3ad41f&amp;amp;chksm=fc22603bcb55e92dd8e5fdd6210f007c072f1208ecf85a081f0273f26e54ff95ad9d219d2094&amp;amp;token=890029854&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

</description>
               <pubDate>Mon, 07 Jun 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/06/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B025</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/06/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B025</guid>
            </item>
        
            <item>
               <title>读书笔记(二十四) 《如何高效阅读 - 中》</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484709&amp;amp;idx=1&amp;amp;sn=4c609d7afb6e41db78948f7797e31de6&amp;amp;chksm=fc226022cb55e934935d6df6b188978331f28a6854abd70eec313fc71d225a709bdcbd291af0&amp;amp;token=679775473&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;背景&quot;&gt;背景：&lt;/h2&gt;

&lt;p&gt;看了很多书，也总结过很多书，对如何看书以及如何总结书本仍然迷茫。
所以自己找了3本书，《如何阅读》、《如何阅读一本书》、《如何高效阅读一本书》，专门针对这三本书做了仔细的总结和分析。
我把文章分为上、中、下三篇，本篇为中篇，讲的是《如何阅读一本书》这本书。&lt;/p&gt;

&lt;p&gt;书中有几个方法和框架，无论你是完全照做，或只是掌握个形式，你都得了解要如何跟着规则走，这是第一步。&lt;/p&gt;

&lt;p&gt;只有了解规则怎么走，熟悉了规则，才会能逐渐掌握。就像我们在学习新知识的时候那样，可能一开始只是模仿，只是形式上的掌握，没有触及技巧的灵魂。随着我们熟练度的深入，规则越来越熟悉，技巧越来越熟练，也就慢慢地将技巧的灵魂融入到我们的身体中甚至生活习惯中。&lt;/p&gt;

&lt;p&gt;下面我们就来看看书中是怎么论述阅读规则和技巧的。&lt;/p&gt;

&lt;h2 id=&quot;简要总结&quot;&gt;简要总结：&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;阅读有四个层次，基础阅读、检视阅读、分析阅读、主题阅读。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;主动阅读就是带着目的阅读，在阅读前提出问题，带着问题阅读，并且在多次重复阅读中回答问题。最后阅读完成用自己的语言写大纲和评价。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;主题阅读需要阅读很多同一主题的书，然后再做分析和讨论。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;针对不同类型的读物，我们需要用不同类型的方法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;珍惜一本好书的方法，就是读很多遍，甚至是一辈子都在读。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;主动阅读对我们各方面的帮助都会很大。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文：&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484709&amp;amp;idx=1&amp;amp;sn=4c609d7afb6e41db78948f7797e31de6&amp;amp;chksm=fc226022cb55e934935d6df6b188978331f28a6854abd70eec313fc71d225a709bdcbd291af0&amp;amp;token=679775473&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

</description>
               <pubDate>Sat, 29 May 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/05/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B024</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/05/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B024</guid>
            </item>
        
            <item>
               <title>读书笔记(二十三) 《如何高效阅读 - 上》</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484653&amp;amp;idx=1&amp;amp;sn=f16e52ea17560947ace74b8a7ecfaefb&amp;amp;chksm=fc2261eacb55e8fc2d96d43bcf8dc1978cfa67e678d5003b793d33a7adb7bdf7b4859e28c740&amp;amp;token=2074622695&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;背景&quot;&gt;背景：&lt;/h2&gt;

&lt;p&gt;看了很多书，也总结了很多书，但对读书这个词语越来越迷茫。&lt;/p&gt;

&lt;p&gt;迷茫的是，不知道自己的阅读习惯是否真的好，自己的阅读效率是否真的高，我对自己的阅读能力不自信。&lt;/p&gt;

&lt;p&gt;因此买了三本经典阅读技巧书，一本是《如何阅读一本书》、另一个本是《如何阅读》，再加上去年读过的《如何有效阅读一本书》，&lt;/p&gt;

&lt;p&gt;三本书加起来，对阅读的技巧和效率做一个巩固和总结。因此我把此系列总结文章分成三部分，上、中、下，本文是上篇。&lt;/p&gt;

&lt;p&gt;本文总结的是《如何阅读》这本书，它主要讲的主题是，如何提高我们的阅读速度。&lt;/p&gt;

&lt;p&gt;阅读速度是否是阅读的关键呢，我认为是的，但也认为不是。关键在于你怎么理解和运用。我们来看看作者是怎么认为的。&lt;/p&gt;

&lt;p&gt;文中并没有详细的提到带着目的去阅读的具体方法，但全文都在提倡带着目的去阅读，我认为这是个重要方法，这个重要的方法我打算在另一本书《如何阅读一本书》的总结里做分析。&lt;/p&gt;

&lt;h2 id=&quot;简要总结&quot;&gt;简要总结：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;不一定什么书都要细读，针对不同的书要使用不同的阅读方式。

提高阅读速度的技巧有很多种，针对不同的内容使用不同阅读速度。

阅读的环境和习惯是提高效率的一个重要关键点。

理解力是阅读效率的一个重要指标，它要求我们和作者不断对话，彼此交流达到沟通理解的地步。

阅读笔记是增加理解力，加强注意力，提高回顾效率的一个有效方式。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文：&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484653&amp;amp;idx=1&amp;amp;sn=f16e52ea17560947ace74b8a7ecfaefb&amp;amp;chksm=fc2261eacb55e8fc2d96d43bcf8dc1978cfa67e678d5003b793d33a7adb7bdf7b4859e28c740&amp;amp;token=2074622695&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

</description>
               <pubDate>Sun, 23 May 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/05/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B023</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/05/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B023</guid>
            </item>
        
            <item>
               <title>思路探讨(六十五) 人生的框架</title>
               <description>&lt;p&gt;目标管理从2月份到现在已经实践了有一段时间了，它给我带来了很多震撼的效果，也开阔了我不少视野。&lt;/p&gt;

&lt;p&gt;我慢慢发现行为习惯和思维习惯的改变就像脱胎换骨一样，是极难的，也是极其痛苦的过程。&lt;/p&gt;

&lt;p&gt;当然这也意味着，目标管理的这3个月折磨的我很痛苦，不过这些都是值得的，都是改变行为习惯和思维习惯所必须经历。人就是这样的，改变的太多太快，身体就会承受很大的痛苦，心思上和肉体上都会有。&lt;/p&gt;

&lt;h3 id=&quot;最大的体会是目标给我提供了动力和方向&quot;&gt;最大的体会是，目标给我提供了动力和方向。&lt;/h3&gt;

&lt;p&gt;这给了我很多提示，很多旧思想和旧习惯在我脑海中浮现。&lt;/p&gt;

&lt;p&gt;以前经常会去寻找安全感，去为获得安全感而努力，比如想着有一天能安心躺着赚钱，或者存够钱去农村养老，或者找到一份安逸稳定的饭碗，还有我们总是想早点完成手头上的工作来获得安全感。&lt;/p&gt;

&lt;p&gt;这其实就是人性的一面，为获得安全感而活，所以很多新闻标题都以恐吓人的方式来命名，以吸引人来关注。&lt;/p&gt;

&lt;h3 id=&quot;这些年的经历告诉我不要试图去追求安全感周遭的环境从来都不会有绝对的安全如果有那肯定是陷进你安全的越久就会陷的越深越无法自拔&quot;&gt;这些年的经历告诉我，不要试图去追求安全感，周遭的环境从来都不会有绝对的安全，如果有，那肯定是陷进，你安全的越久，就会陷的越深越无法自拔。&lt;/h3&gt;

&lt;h3 id=&quot;只有不断的挑战不断努力不断拼搏才能让自己有永恒的动力才会有不灭的优势&quot;&gt;只有不断的挑战，不断努力，不断拼搏，才能让自己有永恒的动力，才会有不灭的优势。&lt;/h3&gt;

&lt;p&gt;也体会到，人越老，年龄越大就越对周围的事物失去兴趣，保持热情变得越来越困难。&lt;/p&gt;

&lt;p&gt;年轻时对周围的事物都充满了新鲜感，社会生活了10几年后，这层新鲜感就不在了，留下的都是枯燥和乏味。有些人沉沦，有些人走偏，这也都是在预料之中的事。&lt;/p&gt;

&lt;p&gt;保持热情，就要保持好奇。而保持好奇心最好的方式，就要有目标，这些都是一环扣一环的，有目标，可量化，就能得到反馈，有反馈就有令人兴奋的动力。&lt;/p&gt;

&lt;p&gt;这些我都写在《目标管理》的一篇文章中，这些年我建立了自己的框架，框架中包含了做人做事的心态，家庭，价值观，目标，行为习惯和思维习惯等方方面面，我希望我的人生是平衡的，这样走下去才会更加的稳。&lt;/p&gt;

&lt;p&gt;什么是更加稳的人生呢？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.更少的情绪波动（外部波动可能很大，内部波动则更小）

2.要事优先，做更重要的事情

3.朝着正确的人生方向不偏离

4.帮助周围的人一起往更好的方向奔去
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时这个框架让我所做的事情变得可积累，甚至是把原本不可积累事情的变成了可积累。这样，在这个框架中，我积累的越多，框架就越强大，我也会活的更好些。&lt;/p&gt;

&lt;h3 id=&quot;当然框架不是一蹴而就的可能需要建设10年20年甚至一辈子所以我一直在完善这个框架不断去调整它加入更好的元素去掉错误的理解调整偏离的方向&quot;&gt;当然，框架不是一蹴而就的，可能需要建设10年20年甚至一辈子，所以我一直在完善这个框架，不断去调整它，加入更好的元素，去掉错误的理解，调整偏离的方向。&lt;/h3&gt;

&lt;p&gt;框架也同时成为了我人生中的可以一直感兴趣的事情，因为我在不断研究它完善它，我相信这个框架会给我带来越来越好的人生。也希望各位能共同努力，往更好的人生方向奔去。&lt;/p&gt;

&lt;p&gt;一点点小总结，希望能给大家带去一些参考价值。&lt;/p&gt;
</description>
               <pubDate>Fri, 14 May 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/05/14/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A865</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/05/14/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A865</guid>
            </item>
        
            <item>
               <title>给女儿的信(十二) 关于积分制</title>
               <description>&lt;p&gt;hi Sharon Anne，爸爸几天不见好想你们。爸爸又回到深圳工作了，爸爸跟你们说过，爸爸不只是来工作的，更是来学习的。&lt;/p&gt;

&lt;p&gt;爸爸每天都很努力的去学习，去思考，爸爸想多学一点。&lt;/p&gt;

&lt;p&gt;但是，你知道，每个人都会有累的时候，都会有这么段时间想偷懒的时候。&lt;/p&gt;

&lt;p&gt;爸爸不想偷懒，但人就是会有是有懒的时候，懒的早起，懒的看书，懒的运动，懒的写文章。&lt;/p&gt;

&lt;p&gt;这不是爸爸想要的，爸爸想克服它，为了能抵抗人的懒惰，爸爸想了很多办法，也尝试了很多办法。&lt;/p&gt;

&lt;p&gt;幸运的是，爸爸终于找到一个很好的办法来抵抗懒惰，那就是给自己设定目标，并且奖励小星星。&lt;/p&gt;

&lt;p&gt;爸爸给自己设置了很多奖励小星星的任务，&lt;/p&gt;

&lt;p&gt;比如看完一本书，就给自己10颗小星星，写一篇文章就给自己8颗小星星，每天早起锻炼就给自己1颗小星星。&lt;/p&gt;

&lt;p&gt;爸爸又给自己设定了奖励，比如用30颗小星星换一次回家休息的机会，用50颗小星星换一次去外面野餐的机会，80颗小星星换一个游戏。&lt;/p&gt;

&lt;p&gt;爸爸把这些小星星积累起来，到了足够多的时候，就把它们用在自己喜欢的事情上。&lt;/p&gt;

&lt;p&gt;于是为了能够凑足小星星，获得自己想要的奖励，爸爸又充满的动力了，每天都努力读书，写文章，锻炼，攒小星星。&lt;/p&gt;

&lt;p&gt;哈哈，是不是很好玩，爸爸也跟你们一起攒小星星呢，攒满了小星星，一起去玩哦。&lt;/p&gt;

&lt;p&gt;加油Sharon，加油Anne，爸爸喜欢你们哦，要照顾好妈妈呦，笔芯。&lt;/p&gt;

</description>
               <pubDate>Tue, 11 May 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/05/11/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A112</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/05/11/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A112</guid>
            </item>
        
    </channel>
</rss>