<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title></title>
        <description>漫漫人生,记录点滴技术,始于2013</description>
        <link>http://www.luzexi.com</link>
        <atom:link href="http://www.luzexi.com/assets/feed.xml" rel="self" type="application/rss+xml" />
        
            <item>
               <title>白领投资探讨(六)</title>
               <description>&lt;h3&gt;为什么不要做逆向投资，和，为什么坚决要做逆向投资的探讨&lt;/h3&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;一直没明白这个世界，也一直不断地在找这个世界的方向。这个世界，这么多的变化的，这么多的故事，这个多的人，我们要学习的太多太多。&lt;/p&gt;

&lt;p&gt;很久前就知道这个世界是变化的道理，不过这个道理始终都没有落在心里，直到今天才有点醒悟。&lt;/p&gt;

&lt;p&gt;我们不知道明年会怎样，明天会如何，甚至都无法确定下一秒会发生什么，一切都在变。&lt;/p&gt;

&lt;p&gt;我记得有一天工作到中午忘了吃饭，肚子很饿，于是穿上衣服去吃饭，然而这么一件大概率确定的事，却在出门后快进餐厅那一瞬间因为跟同事聊了几句，就跟着同事去了他的办公室，一个下午没有吃上饭。&lt;/p&gt;

&lt;p&gt;如果世界上有一个确定的事情，那就是，“这个世界是永恒变化的”这个道理。&lt;/p&gt;

&lt;h6&gt;这就是我们今天要探讨的话题的基础，在“变化下投资”。&lt;/h6&gt;

&lt;h3&gt;1，为什么不要做逆向投资。&lt;/h3&gt;

&lt;p&gt;最常见的是在逆向投资中容易迷失自己。不要忘了，我们是时代下的蚂蚁，时代的浪潮推我们去哪，我们就得去哪，谁都逃不过，越挣扎越痛苦。&lt;/p&gt;

&lt;p&gt;这就是趋势，最大浪潮的趋势，最宏观的浪潮趋势，拍动着整个国家，或者整个地区，甚至是整个全球的去向。我们这种蚂蚁级别的小颗粒，做再大的挣扎都无济于事。&lt;/p&gt;

&lt;p&gt;因此逆向投资最容易受伤，它是在对抗时代，拒绝被推动，最后反而被时代撕裂。&lt;/p&gt;

&lt;p&gt;在逆向投资中，富豪变得一无所有的例子遍地是，亿万富豪破产不是梦。&lt;/p&gt;

&lt;h3&gt;2，又为什么要坚持做逆向投资。&lt;/h3&gt;

&lt;p&gt;先把教条拿出来，巴菲特说过：别人贪婪我恐惧，别人恐惧我贪婪。&lt;/p&gt;

&lt;p&gt;要反着做，是在这个社会生存的更好的基本要素。当所有人都悲观绝望卖出时，你就应该与众不同拿出积极乐观的态度坚决买入。&lt;/p&gt;

&lt;p&gt;大的盈利，大的利润基本上都是在逆向投资中获得的，因为低谷越低，高峰越高，上下幅度足够大时，利润能高的吓人。&lt;/p&gt;

&lt;p&gt;另外一点，是赔率，如果1%的概率1块钱，能赢10000块，为何不做，投100次也才100块，却能获得10000块的收入。&lt;/p&gt;

&lt;p&gt;足够大的赔率，是投资的最佳机会。这种机会，也就只会在逆势中才会出现，恐慌，踩踏，所有人都撤退时，这种好赔率才会浮出水面。&lt;/p&gt;

&lt;p&gt;等大多数人清醒过来，好的赔率早就没了。&lt;/p&gt;

&lt;p&gt;最后一点，要学会乐观面对世界。倒下了要学会站起来，只有站起来，才能继续往前进，躺在那里，只有死路一条。&lt;/p&gt;

&lt;h3&gt;3，如何理解两个方法。&lt;/h3&gt;

&lt;p&gt;其实这两个方法不矛盾，完全可以一起进行，同时操作。&lt;/p&gt;

&lt;p&gt;比如，在还没出现大面积资金撤退，并且还没出现撤退完毕迹象的情况下，坚决不做逆向投资。&lt;/p&gt;

&lt;p&gt;又比如，在大面积资金撤退完毕，并出现明显踩踏，恐慌现象后，以3年为期，把打算投资的资金分为36份，每个月投一份，而且这一份资金中，进行分散投资，降低踩雷概率，以防一次性亏损过大。&lt;/p&gt;

&lt;p&gt;再比如，不对没有实际业绩支撑的公司进行投资，在逆势中，这种公司雷暴概率最大，资金链断裂最快。&lt;/p&gt;

&lt;p&gt;还比如，坚决分批买入，那些自己熟悉的行业，自己擅长的行业。行业有起，有伏，有最冰冷时，也会有最火热时，自己擅长的行业，自己最清楚，什么时候最冷，什么时候最热。&lt;/p&gt;

&lt;p&gt;题外话：&lt;/p&gt;

&lt;h6&gt;还记得跟一位友人聊天，他说：每次在人生的十字路口，都知道哪条路是正确的，但他每次都不选择那条路，他说因为他知道那条路实在太难走了。&lt;/h6&gt;

&lt;h6&gt;正确的路当然难走，即使选择了正确的路，也不是每个人都能坚持走完的，大多数人都在中途放弃了，有些甚至一开始就没有选择这条难走的路。&lt;/h6&gt;

&lt;h6&gt;所以这个社会的层级才是金字塔形状，而不是扁平形状。少数人赢得了胜利，统治了世界。&lt;/h6&gt;
</description>
               <pubDate>Sun, 23 Sep 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/09/23/%E7%99%BD%E9%A2%86%E6%8A%95%E8%B5%84%E6%8E%A2%E8%AE%A86.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/09/23/%E7%99%BD%E9%A2%86%E6%8A%95%E8%B5%84%E6%8E%A2%E8%AE%A86.html</guid>
            </item>
        
            <item>
               <title>白领投资探讨(五)</title>
               <description>&lt;h3&gt;金融知识到底带给我了什么？&lt;/h3&gt;

&lt;p&gt;刚开始学习金融知识时候，对各类信息都非常关注，小到商品的的价格波动起伏，大到全球的政治格局。&lt;/p&gt;

&lt;p&gt;一开始不懂，认为牛人肯定是对信息把握和预测能力很强，包括对政策的洞察力等等。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;后来明白了点，价格是无序波动的，是无法预测的，价格的根源是交易，交易由两个人类相互作用，一个乐观的买入，一个悲观的卖出，而人类无序紊乱的情绪导致了整个波动的无需的。越短的周期内的价格波动的表象越是无法捕捉到规律，这就是几亿人情绪共同作用导致的。倘若是交易由机器发起，就会变得有规律可循，因为机器是无情绪化的。&lt;/p&gt;

&lt;p&gt;再后来又明白了点，价值才真正的王道，人的价值，知识的价值，市场的价值，技术的价值，那些无法用金钱换来的才是真正意义上的价值体现。&lt;/p&gt;

&lt;p&gt;不过价值可并不等于金钱，在一段很长时间里，价值在金钱上是无法体现出来的。就像那些死后才出名的画家，诗人，政治家，科学家一样，在生前，在还没有等到价值体现的那一刻，他们就去世了，一辈子都没能等到价值体现的那一刻。&lt;/p&gt;

&lt;p&gt;再后来，终于懂了这个世界上没有大神，即使巴菲特也不是绝对的，大家都是被时代的浪潮推着走的人，时代推我们到哪我们就在哪。&lt;/p&gt;

&lt;p&gt;在这个过程中，淘汰了许多人，留下来的活下来的得到了最终的胜利。于是就有人说这些人是大神，殊不知这个世界上有幸存者偏差的存在，所有有利信息都指向胜者的优势，忽略了失败者的能力。其实换个环境换个趋势，那些所谓的优胜者，有可能分分钟被秒杀。说白了就是运气好。&lt;/p&gt;

&lt;h3&gt;那么难道说这个世界就是靠运气的？可以说是，也可以说完全不是！&lt;/h3&gt;

&lt;h3&gt;因为人！可！以！制！造！运！气！&lt;/h3&gt;

&lt;p&gt;努力的人创造价值，坚持努力的人创造更多的价值，十年如一日坚持努力的人创造巨量的价值，巨量的价值吸引了很多人来关注，关注的人越来越多，量变积累导致了质变，巨量的价值给我们带来了机会和运气。&lt;/p&gt;

&lt;p&gt;价值是人类社会的基础，没有价值的人，没有价值的事，是不会有人愿意去关心的，没有人关心的事才没有价值和意义。&lt;/p&gt;

&lt;p&gt;想要制造运气，就要坚持努力，特别是十年如一日的坚持，将带给你颠覆性的变化。&lt;/p&gt;

&lt;h3&gt;胜者，败者，都很努力，为什么还是分出了胜负？&lt;/h3&gt;

&lt;p&gt;这个问题本身就有问题，因为这个问题太关注当前的胜负结果。&lt;/p&gt;

&lt;p&gt;胜，和，负，只是我们在整个坚持努力的过程中的一个结果。如果我们太关注胜负，很容易被胜负心理吞没，无法自拔。&lt;/p&gt;

&lt;p&gt;试问大家，谁就能够保证，一辈子赢？首富都有倾家荡产流落街头的例子，何况是其他人。&lt;/p&gt;

&lt;p&gt;“眼看他起高楼，眼看他宴宾客，眼看他楼坍塌”，这种事时时刻刻都在发生，万事万物一直在变，只有努力价值从而创造运气不会变。&lt;/p&gt;

&lt;h3&gt;我们在生活中，事业中，学习中，最怕不是失败，而是害怕失败。&lt;/h3&gt;

&lt;h3&gt;失败不可怕，最怕的是害怕失败。&lt;/h3&gt;

&lt;p&gt;当遭遇重大挫折或是迷茫后，有些人一蹶不振，从此得过且过混日子，再也抬不起头。这样的人是大多数，这样的公司也是绝大多数。&lt;/p&gt;

&lt;p&gt;但总有那么些人和公司，他们会在痛苦中思索，反省，成长，蜕变，直到进化出第二曲线，重回新一阶段的成长。&lt;/p&gt;

&lt;p&gt;经历过挫折的打磨，可能他们的成长不如过去锋利、迅猛，但更加沉稳坚定。&lt;/p&gt;

&lt;h3&gt;在黑暗中保持乐观，在狂热中保持理性最难。&lt;/h3&gt;

&lt;p&gt;在失业下，没有收入来源时，甚至饥寒交迫时，你还能保持每天规律的作息，坚持运动，坚持学习，沉稳的心态，积极主动的态度吗？大多数人就像只发疯的苍蝇一般到处乱串，只有少数人冷静的对待，保持平稳心态，排除悲观情绪，积极乐观，主动出击。&lt;/p&gt;

&lt;p&gt;最黑暗的时候，最需要鼓起勇气面对，积极乐观向上，而大多数人即使明白这个道理也做不到，所以只有少部分人突出重围，从下层突围到中层，或者从中层突围到上层，甚至从上层突围到顶层。&lt;/p&gt;

&lt;p&gt;反过来说，如果现在社会安定，每个人都很有钱，工作机会很多，工资都很高，股价房价涨涨涨，并没有多少需要担心的事，大家只需要掏出钱来买买买，尽情享受躺着赚钱就行的时候，我们是否还能做到居安思危，让未来更加有保障吗？可以说，大多数人都沉浸在享受中，而并没有对未来有可能发生的灾难提高警惕。&lt;/p&gt;

&lt;p&gt;对狂热的不理性，才会有这么多倾家荡产的悲剧发生。&lt;/p&gt;

&lt;h3&gt;大多数人，还是逃不过遭难的，只有少部分人可以。&lt;/h3&gt;

&lt;h3&gt;大多数人都会沦为平庸平凡的一生，而只有少部分人才真正为自己创造了“运气”，成为新一代的领导者。&lt;/h3&gt;

&lt;h3&gt;这些少部分人，就是那些，自律，努力，积极，勇敢的家伙们。&lt;/h3&gt;
</description>
               <pubDate>Sat, 08 Sep 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/09/08/%E7%99%BD%E9%A2%86%E6%8A%95%E8%B5%84%E6%8E%A2%E8%AE%A85.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/09/08/%E7%99%BD%E9%A2%86%E6%8A%95%E8%B5%84%E6%8E%A2%E8%AE%A85.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，Shader(八) - Surface</title>
               <description>&lt;h6&gt;Surface Shaders 是Unity3D创建的，用来简化手动编写Shader的一种方式。&lt;/h6&gt;

&lt;h6&gt;Surface 能帮我们生成HLSL，不过Surface并不是种语言，可以用开关和指令集来形容Surface，并且我们依然要关注HLSL如何编写。&lt;/h6&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;Surface shader 和 vertex fragment shader 一样需要书写 CGPROGRAM..ENDCG，并且写入#pragma surface 来表明使用Surface，不同的是：Surface 它不能有Pass，所有的Surface编码都写在SubShader中，然后再由shader编译器编译成多个Pass。&lt;/p&gt;

&lt;h6&gt;#pragma surface 的格式如下：&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    #pragma surface surfaceFunction lightModel [可选择参数]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数说明：&lt;/p&gt;

&lt;h6&gt;1，surfaceFunction，是一个有输入输出参数的函数，其格式为&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    void surf (Input IN, inout SurfaceOutput o)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Surface通过这个函数来修改渲染细节，Shader中必须写有这个名字和格式的函数。&lt;/p&gt;

&lt;h6&gt;2，lightModel，选择光照模型。在内置的光照模型中，有以物理为基础的 Standard 和 StandardSpecular，和无物理基础的Lambert (diffuse漫反射) and BlinnPhong (specular镜面反射)。除此之外，还可以定义自己的光照模型。&lt;/h6&gt;

&lt;p&gt;其中内置的光照模型：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Standard 光照模型使用 SurfaceOutputStandard 作为输出结构并且匹配了Unity3D内置的Standard Shader(金属流)。

    StandardSpecular 光照模型使用 SurfaceOutputStandardSpecular 作为输出结构并且匹配了Unity3D内置的Standard Shader(镜面反射)。

    Lambert 和 BlinnPhong 光照模型则不以物理为基础，使用它们时可以在低端设备上运行得更快。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SurfaceOutputStandard 和 SurfaceOutputStandardSpecular 在 UnityPBSLighting.cginc 中有定义。&lt;/p&gt;

&lt;p&gt;Lambert 和 BlinnPhong 在 Lighting.cginc 中有定义，分别是 UnityLambertLight 和 UnityBlinnPhongLight。&lt;/p&gt;

&lt;h6&gt;3，可选择指令。&lt;/h6&gt;

&lt;h6&gt;透明物体 和 alpha testing 功能指令&lt;/h6&gt;

&lt;p&gt;透明物体 和 alpha testing 类型的参数可以控制alpha和alphaTest也就是alpha混合和alpha裁切 的功能。&lt;/p&gt;

&lt;p&gt;透明物体分为两种，一种是传统的alpha混合，另一种是更加物理化的“premultiplied blending”左自乘混合，它能够在半透明上保留适度的镜面反射。&lt;/p&gt;

&lt;p&gt;启用半透明使得surface shader包含了alpha混合功能。而启用alpha cutout 将根据alpha值在生成像素时中裁切掉不符合的片段。&lt;/p&gt;

&lt;p&gt;透明物体和alpha testing的功能指令如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    alpha 或者 alpha:auto，指令意思为，选择渐进透明也就是 alpha:fade 作为简单光照函数，并且选择左自乘透明方式也就是 alpha:premul 作为物理基础的光照函数。

    alpha:blend，开启alpha混合。

    alpha:fade，开启传统的渐进透明函数。

    alpha:premul，开启左自乘alpha透明度。

    alphatest:VariableName，开启alpha cutout裁切功能。将根据跟定的值裁切不符合的alpha片段。裁切后可以通过 addshadow 指令生成阴影。

    keepalpha，保持alpha值，让那些不透明的物体也有alpha通道为1.0的值。这个操作使得灯光函数在不透明物体上也起到alpha的作用。

    decal:add，开启叠加贴花功能，让贴花贴图使用叠加混合。

    decal:blend，开启半透明贴花功能，让贴花贴图使用alpha混合。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;自定义函数，自定义函数可以计算和修改顶点数据，或者计算和修改最终的片元颜色。&lt;/h6&gt;

&lt;p&gt;vertex:VertexFunctionName，自定义修改顶点函数。这个函数被调用来计算和修改模型的每个顶点的数据。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    函数的格式如下：

    void VertexFunctionName(inout appdata_full v, out Input o)

    函数中必须带有两个类型的参数，inout appdata_full 和 out Input。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 appdata_full 在Unity内置的UnityCG.cginc文件中，结构为如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;appdata_full&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;POSITION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tangent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TANGENT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normal&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NORMAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texcoord&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TEXCOORD0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texcoord1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TEXCOORD1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texcoord2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TEXCOORD2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texcoord3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TEXCOORD3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fixed4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;COLOR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UNITY_VERTEX_INPUT_INSTANCE_ID&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;其中 Input 的结构为如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Input结构里当使用某张纹理的uv时，可以使用“uv”加变量名来提取该纹理坐标，或者“uv2”加变量名使用第二纹理uv。（uv2一般用于lightmap）

    float3 viewDir - 视图方向（view direction）。

    float4 with COLOR semantic - 每个顶点插值后的颜色。

    float4 screenPos - 屏幕空间中的位置。

    float3 worldPos - 世界空间中的位置。

    float3 worldRefl - 世界空间中的反射向量。 如果surface 
    shader没有赋值o.Normal，将会包含世界反射向量。

    float3 worldNormal - 世界空间中的法线向量。如果surface 
    shader没有赋值o.Normal，将会包含世界法向量。

    float3 worldRefl; INTERNAL_DATA - 世界空间中的反射向量。如果surface 
    shader没有赋值o.Normal，将会包含这个参数。为了获得逐像素法线贴图的反射向量，请使用WorldReflectionVector 
    (IN, o.Normal)。参见例子： Reflect-Bumped shader。

    float3 worldNormal; INTERNAL_DATA -世界空间中的法线向量。如果surface 
    shader没有赋值o.Normal，将会包含世界法向量。为了获得逐像素法线贴图的法向量，请使用WorldNormalVector 
    (IN, o.Normal)。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;finalcolor:ColorFunctionName，设置自定义函数修改最终颜色。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    函数格式如下：

    void ColorFunctionName(Input IN, SurfaceOutput o, inout fixed4 color)

    函数中必须带有Input IN, SurfaceOutput o, inout fixed4 color，这三个参数。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;finalgbuffer:ColorFunctionName，自定义修改延迟路径gbuffer内容。&lt;/p&gt;

&lt;p&gt;finalprepass:ColorFunctionName，自定义修改旧有的延迟渲染前的路径。&lt;/p&gt;

&lt;h6&gt;阴影和网格细化指令&lt;/h6&gt;

&lt;p&gt;阴影和网格细化这两种指令，可以用来控制处理阴影渲染和网格细分。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    addshadow，生成一个阴影渲染管线。addshadow 经常会与顶点修改函数一起使用，让阴影有一定的动画效果。通常shader不需要任何特殊的方法处理阴影，他们可以用shader caster作为后备方案。

    fullforwardshadows，支持所有正向渲染路径下的灯光阴影。默认情况下shader在正向渲染中只支持1个方向光的阴影渲染。如果你需要在正向渲染中对点光源进行阴影渲染，就得使用这个指令。

    tessellate:TessFunctionName，使用DX11 GPU 网格细化。自定义函数中计算了三角形的边和里面的细分因素。

    网格细分化功能，需要使用Shader Model 4.6 target进行编译，所以只能在 DX11/12, OpenGL Core and PS4/XB1 上使用。

    TessFunctionName的格式为：

    float4 TessFunctionName(appdata v0, appdata v1, appdata v2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;代码生成操作指令&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    exclude_path:deferred, exclude_path:forward, exclude_path:prepass，不生成指定的渲染路径。

    三个指令分别代表延迟渲染, 正向渲染 和 旧式延迟渲染。

    noshadow，关闭所有阴影渲染支持。

    noambient，不使用环境光或者光探测。

    novertexlights，在正向渲染中不使用任何光探测或顶点光照。

    nolightmap，关闭所有烘培光照图。

    nodynlightmap，关闭实时动态全局自发光的支持。

    nodirlightmap，关闭方向光的支持。

    nofog，关闭内置迷雾效果。

    nometa，不生成meta渲染管线。

    noforwardadd，关闭正向渲染增加的渲染管线。

    nolppv，关闭 Light Probe Proxy Volume。

    noshadowmask，关闭 Shadowmask。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;其他指令&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    softvegetation，Suface shader只在 Soft Vegetation 开启时渲染。

    interpolateview，对视向上的做插值操作，替换像素shader里的计算。

    halfasview，替换观察向量为一半方向向量传给光照函数。

    dualforward，在正向渲染中使用双重光照图。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;自定义光照模型&lt;/h3&gt;

&lt;p&gt;光照模型是用来计算光照的，包括，光照影响，阴影，漫反射，镜面反射，环境光等。&lt;/p&gt;

&lt;p&gt;Unity3D内置的光照模型有 Lambert (漫反射光照) 和 BlinnPhong (镜面反射光照) 两种，这两种光照模型被写在Unity3D内置文件 Lighting.cginc 中，可以前往查看，window上的地址为(unity install path)/Data/CGIncludes/Lighting.cginc，Mac上的地址为 /Applications/Unity/Unity.app/Contents/CGIncludes/Lighting.cginc。&lt;/p&gt;

&lt;p&gt;除了这两种光照模型，我们还可以定义自己的光照模型。&lt;/p&gt;

&lt;p&gt;所有自定义的光照模型函数都必须以 Lighting 作为开头定义在Shader文件的 Surface块中。函数定义可以如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    half4 Lighting&amp;lt;Name&amp;gt; (SurfaceOutput s, UnityGI gi); 这种方式使用正向渲染，且没有视向的依赖。

    half4 Lighting&amp;lt;Name&amp;gt; (SurfaceOutput s, half3 viewDir, UnityGI gi); 这种方式使用正向渲染，且依赖视向。

    half4 Lighting&amp;lt;Name&amp;gt;_Deferred (SurfaceOutput s, UnityGI gi, out half4 outDiffuseOcclusion, out half4 outSpecSmoothness, out half4 outNormal); 这种方式使用的是光照延迟渲染。

    half4 Lighting&amp;lt;Name&amp;gt;_PrePass (SurfaceOutput s, half4 light); 这种方式使用的是旧的光照延迟渲染。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;自定义GI模型：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    half4 Lighting&amp;lt;Name&amp;gt;_GI (SurfaceOutput s, UnityGIInput data, inout UnityGI gi);

    如果你想使用内置的GI模型，有 DecodeLightmap 和 ShadeSHPerPixel 两种。他们都写在 UnityGlobalIllumination.cginc 的 UnityGI_Base 里。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Tessellation 网格细分&lt;/h3&gt;

&lt;p&gt;在模型渲染时很容易有锯齿感，Tessellation 网格细分可以改善这种锯齿感，Surface支持Tessellation 网格细分的功能，但只在DirectX 11 / OpenGL Core GPU上有效。&lt;/p&gt;

&lt;p&gt;Tessellation 功能指令为&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    tessellate:FunctionName 这个方法计算三角形的边和里面的细分因素。

    它是在 vertex:FunctionName 之后才被调用的，所以每个顶点都会被替换映射。

    Surface 可以选择使用 phong tessellation 平滑模型表面，而不用替换顶点映射。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;tessellate 有如下限制：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1，只计算三角形，没有方形，没有等值线细分。

    2，当tessellation被使用时，Shader 自动被编译成 Shader Model 4.6 target，意味着这个Shader只在 DX11/12, OpenGL Core and PS4/XB1 下工作。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;tessellate Function 的格式如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    float4 tessellateFunction(appdata v0, appdata v1, appdata v2);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;开启 phong tessellation 功能，需要加入指令：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    tessphong:VariableName

    VariableName 为Phong变量强度。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Unity3D：Writing Surface Shaders
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
               <pubDate>Tue, 21 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/21/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader8.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/21/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader8.html</guid>
            </item>
        
            <item>
               <title>中国，顶住！！</title>
               <description>&lt;h6&gt;在美国主导的加息和减税的政策下，美元强势回流，全球汇率大幅度波动，很多新兴国家混乱不堪，陷入经济危机，金融危机中，国家经济陷入倒退。&lt;/h6&gt;

&lt;h6&gt;中国也没能幸免，今年股，汇，商品，三杀，经济数据糟糕。&lt;/h6&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;确实中国存在很多问题，但美国难道问题不大吗，美国也存在诸多问题，甚至比中国还要多还要大。只是现在它的霸主地位，很多问题被掩盖了。&lt;/p&gt;

&lt;p&gt;而现在在中国，太多人崇洋媚外，特别是这个时候，中国经济最困难的时候，出汉奸的概率很大。&lt;/p&gt;

&lt;p&gt;说实话，美国确实强大，他的霸主地位无人能撼动，这是由历史原因造成的，但也不至于去投靠，连尊严都不要吧。&lt;/p&gt;

&lt;p&gt;我们可以学习，可以借鉴，但不可以放弃尊严选择去无脑膜拜。中国现在是世界经济第2大国，难道这还不足以说明中国的强大吗？！&lt;/p&gt;

&lt;p&gt;中国只需要一个机会就能颠覆美国。只要美国犯一个致命错误，比如次贷危机，内乱内战，或者陷入全面对外战争那种就可以。但这个机会一直没有出现，可能需要等上4，5十年。&lt;/p&gt;

&lt;p&gt;在两国都没有陷入危机的情况下，就会始终保持这种被压制的局面。打破平衡，需要大事件。&lt;/p&gt;

&lt;p&gt;现在最严重的问题是，境内外势力正在合力搞垮中国。那些近几年没赚到钱或者亏钱的人都站在欧美势力上了，汉奸会越来越多。&lt;/p&gt;

&lt;p&gt;真的要当心啊，每个新兴国家，在没达到霸主地位前，任然在发展中的情况下，一直都会有这种问题，不断有崇洋媚外的人冒出来，不顾国家利益的鼓动人民投靠他国。那些无法冷静的，没有独立思考的人民，就会像热锅上的蚂蚁一样乱了阵脚。&lt;/p&gt;

&lt;p&gt;我们任然是新兴国家，被美国收割是正常的，这场风暴是美国一手主导的，目的就是收割新兴国家。但太多人投靠美国，导致信心挫败。&lt;/p&gt;

&lt;p&gt;这几年中国肯定艰难痛苦，反转只能靠政府自己，人民群众是靠不住的。&lt;/p&gt;

&lt;h6&gt;人民只会关心自己的利益，而不顾国家的利益，幸好国家是一党专政制度，否则后果不堪设想：政变，大规模示威游行，甚至军变，内战都有可能。&lt;/h6&gt;

&lt;h6&gt;美国就希望看到中国内乱，内战，这样他的目的就达到了。一旦内乱，经济地位，全球地位就不保，错失了这个地位，未来再重返，将难上加难。&lt;/h6&gt;

&lt;h3&gt;中国千万要顶住！！！！&lt;/h3&gt;
</description>
               <pubDate>Fri, 17 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/17/%E4%B8%AD%E5%9B%BD%E9%A1%B6%E4%BD%8F.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/17/%E4%B8%AD%E5%9B%BD%E9%A1%B6%E4%BD%8F.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，Shader(七) - Fixed Function</title>
               <description>&lt;h3&gt;Fixed-function 是Unity3D官方自己编写的一套API，它与Surface shaders，及vertex and fragment program是区分开来的。Fixed-function，Suface program 和 vertex and fragment programs 三种编写Shader的方法不能同时使用，任何一种方式被编写后，其他两种都将无效。&lt;/h3&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;Fixed-function 相对于Suface 和 Vertex and fragment 来说简单很多，它是由一些简单的开关的函数组成的。我们可以用 Fixed-function 来做一些简单的灯光，贴图的变化。&lt;/p&gt;

&lt;p&gt;下面我们来了解一下这些开关和函数的语法。&lt;/p&gt;

&lt;h6&gt;Pass的第一个指令如果是Fixed-function的命令，则认为是Pass开启Fixed-function program。&lt;/h6&gt;

&lt;p&gt;顶点和灯光的颜色计算在模型渲染中被最先执行，它们在顶点转换上操作，并且计算的基础颜色在贴图使用前就被应用到了顶点上。&lt;/p&gt;

&lt;h6&gt;Material块&lt;/h6&gt;

&lt;p&gt;Material标签，可以用来定义材质球的各种光属性的颜色。格式如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Material
    {
        Diffuse [_Color]
        Ambient [_Color]
        Shininess [_Shininess]
        Specular [_SpecColor]
        Emission [_Emission]
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数如下：&lt;/p&gt;

&lt;p&gt;Diffuse color，漫反射颜色，这是物体的基础颜色。&lt;/p&gt;

&lt;p&gt;Ambient color，环境光颜色，被光照到后反应出来的颜色。&lt;/p&gt;

&lt;p&gt;Specular color，镜面反射的高光颜色。&lt;/p&gt;

&lt;p&gt;Shininess number，高光圈的大小，也就是尖锐度，数值范围在0-1之间。为0时高光圈很大覆盖整个物体，为1时高光圈很小，几乎缩小成一个点。&lt;/p&gt;

&lt;p&gt;Emission color，自身发出的颜色，当没有光照到的时候。&lt;/p&gt;

&lt;p&gt;整个光照颜色的公式为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;color = Ambient * 设置中的Ambient强度 + (灯光颜色 * Diffuse + 灯光颜色 * Specular) + Emission
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中灯光颜色，当多个灯光照射时会叠加多次。&lt;/p&gt;

&lt;h6&gt;Color颜色&lt;/h6&gt;

&lt;p&gt;Color颜色设置不透明物体的颜色。格式如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Color color
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;Lighting 开关&lt;/h6&gt;

&lt;p&gt;Lighting 是一个灯光的开关，Material块, ColorMaterial 和 SeparateSpecular都受到它的影响，如果Lighting 关掉的话，它们都将失效。&lt;/p&gt;

&lt;p&gt;格式如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Lighting On | Off
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;SeparateSpecular 镜面反射开关&lt;/h6&gt;

&lt;p&gt;SeparateSpecular 选项开启后会在最后一个pass后加上一个镜面反射光的pass，这使得镜面放射光不受到贴图的影响。&lt;/p&gt;

&lt;p&gt;格式如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    SeparateSpecular On | Off
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;ColorMaterial Material块中的颜色&lt;/h6&gt;

&lt;p&gt;ColorMaterial可以在每个顶点上替换Material中的颜色，其中AmbientAndDiffuse 替换Material块中的 Ambient 和 Diffuse 的颜色，Emission 替换Material块中 Emission 的颜色。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    ColorMaterial AmbientAndDiffuse | Emission
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;SetTexture 设置贴图&lt;/h6&gt;

&lt;p&gt;Fixed function 的贴图功能可以替换旧有的合并效果。我们可以写很多个 SetTexture 命令在 Pass里，所有的贴图都会依次被应用，就像绘制程序里的层级一样。&lt;/p&gt;

&lt;p&gt;另外，SetTexture 命令必须放在Pass的最后部分。&lt;/p&gt;

&lt;p&gt;SetTexture 格式为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    SetTexture [TextureName] {Texture Block}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 TextureName 为贴图的变量名，{Texture Block} 里面的有两种操作，一种是 combine 为主要操作命令，另一个是 constantColor 命令用来设置一个常量颜色。&lt;/p&gt;

&lt;p&gt;combine 命令在SetTexture里最为重要，它的格式可以为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    combine src1 * src2，src1 与 src2 相乘，颜色叠加。

    combine src1 + src2，src1 与 src2 相加，颜色加白加量。

    combine src1 - src2，src1 减去 src2，获得色差。

    combine src1 lerp (src2) src3，使用src2的alpha值计算src1到src3的插值。

    注意src2的alpha为1时结果为src1，src2的alpha为0时结果为src3。

    combine src1 * src2 + src3，src1 与 src2的alpha相乘，然后加上src3。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;上面所有的 src 属性可以是texture，或者previous，或者constant，或者primary。这几个变量分别是如下意思：&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    texture 是贴图变量TextureName贴图上的颜色。

    previous 是前面计算结果的颜色。

    primary 是顶点经过灯光计算后的颜色。也就是前面Material块中diffuse, ambient and specular colors与灯光的计算结果。

    constant 是常量颜色，可以使用 ConstantColor 在 combine 前设置。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;src变量后面可以跟的参数有&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Double 和 Quad 参数。src后面可以跟随double和quad，分别表示2x，4x的亮度，相当于乘2，乘4的效果。

    lerp 插值，所有src变量都可以使用 lerp 做插值操作。

    alpha 透明通道，src后面跟着alpha参数的话，就表示只使用src的alpha通道。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;合并时对Color和Alpha分开处理&lt;/h6&gt;

&lt;p&gt;有时我们需要对颜色和透明通道分开处理，可以在SetTextue时在颜色处理后面加逗号表示分开处理color和alpha。&lt;/p&gt;

&lt;p&gt;具体处理格式为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    SetTexture [_MainTex] { combine previous * texture, previous + texture }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 previous * texture 为颜色处理部分，previous + texture 为alpha处理部分。&lt;/p&gt;

&lt;h6&gt;Fixed function 所有功能的完整示例&lt;/h6&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shader&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;VertexLit&amp;quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Properties&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_Color&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Main Color&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_SpecColor&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Spec Color&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_Emission&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Emmisive Color&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_Shininess&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Shininess&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Range&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0.01&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.7&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Base (RGB)&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;white&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_ConstantColor&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Main Color&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SubShader&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Material&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Diffuse&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Ambient&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Shininess&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Shininess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Specular&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_SpecColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Emission&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Emission&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Lighting&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;On&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;SeparateSpecular&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;On&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;SetTexture&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;constantColor&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_ConstantColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Combine&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texture&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;primary&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DOUBLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texture&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;primary&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;SetTexture&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;ConstantColor&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;combine&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;constant&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lerp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;texture&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;previous&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;SetTexture&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;combine&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;previous&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texture&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))
    { //移动端
        /*mobile-20:5*/
        var cpro_id = &quot;u3493987&quot;;
        document.write(&quot;\&lt;script type=\&quot;text\/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/cm.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
    else
    {
         /*700*200信息流*/
        var cpro_id = &quot;u3469788&quot;;
        document.write(&quot;\&lt;script type=\&quot;text/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/c.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
&lt;/script&gt;

&lt;h6&gt;Alpha Test 透明裁切&lt;/h6&gt;

&lt;p&gt;Alpha Test 是像素即将要输出到屏幕前的最后一步处理，它通过比较像素的alpha值来决定是否展示。&lt;/p&gt;

&lt;p&gt;格式如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    AlphaTest Off | On

    AlphaTest 操作符号 AlphaValue
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中AlphaValue可以是0-1之间的任何浮点数，也可以是给定的变量。&lt;/p&gt;

&lt;p&gt;操作符号可以为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Greater 只有alpha值 大于 给出的AlphaValue的像素才会被渲染。

    GEqual  只有alpha值 大于等于 给出的AlphaValue的像素才会被渲染。

    Less    只有alpha值 小于 给出的AlphaValue的像素才会被渲染。

    LEqual  只有alpha值 小于等于 给出的AlphaValue的像素才会被渲染。

    Equal   只有alpha值 等于 给出的AlphaValue的像素才会被渲染。

    NotEqual    只有alpha值 不等于 给出的AlphaValue的像素才会被渲染。

    Always  渲染所有像素，相当于AlphaTest Off，关闭了AlphaTest的功能。

    Never   不渲染任何像素。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;AlphaTest 根据Alpha值进行像素的裁切，而不是走alpha混合的路，所以没有深度数据问题，在渲染时不会造成前后渲染排序错乱问题。&lt;/h6&gt;

&lt;p&gt;在使用AlphaTest 制作树和枝叶时，由于AlphaTest裁切过于生硬导致画面上有锯齿感，我们可以采用AlphaTest和Alpha Blend混合使用的方式让画面更加平滑。如下代码：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shader&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;Vegetation&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Properties&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_Color&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Main Color&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(.&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Base (RGB) Alpha (A)&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;white&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_Cutoff&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Base Alpha cutoff&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Range&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,.&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SubShader&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Set up basic lighting&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Material&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Diffuse&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Ambient&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Lighting&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;On&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Render both front and back facing polygons.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Cull&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Off&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// first pass:&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// render any pixels that are more than [_Cutoff] opaque&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;AlphaTest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Greater&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Cutoff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;SetTexture&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;combine&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texture&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;primary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texture&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Second pass:&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// render in the semitransparent details.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// Dont write to the depth buffer&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ZWrite&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;off&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// Don&amp;#39;t write pixels we have already written.&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ZTest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Less&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// Only render pixels less or equal to the value&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;AlphaTest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LEqual&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Cutoff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// Set up alpha blending&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Blend&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SrcAlpha&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OneMinusSrcAlpha&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;SetTexture&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;combine&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texture&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;primary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texture&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;上述代码中两个Pass来渲染树和枝叶，第一Pass对Alpha进行硬裁切，第二个Pass将前面其余没有被裁切的部分进行Alpha混合，这样就能让画面更加平滑，虽然alpha混合会导致渲染排序问题，但主要枝干能够正常排序，剩下的边缘部分只起到平滑作用，牺牲一点排序错位让画面更加柔和。&lt;/p&gt;

&lt;h6&gt;Fog 迷雾颜色&lt;/h6&gt;

&lt;p&gt;Fog 命令可以设置雾颜色，根据与摄像机的不同距离，可以叠加不同的颜色。&lt;/p&gt;

&lt;p&gt;格式如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Fog {Fog Commands}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Fog Commands 有：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Mode Off | Global | Linear | Exp | Exp2

    Mode 可以设置计算公式，Off为关闭，Global为全局，Linear为线性插值计算颜色，Exp为指数公式计算颜色，Exp2为以2 为底的指数公式计算。

    Color ColorValue

    Color 用来设置迷雾颜色。

    Density FloatValue

    Density 用来设置迷雾密度。

    Range FloatValue, FloatValue

    Range 用来设置迷雾的显示范围。近圈距离，外圈距离，他们之间的用线性的方式展示迷雾。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;Fog命令不会与 Vertex Fragment program 和 Surface program 冲突，它是独立于他们之外的功能。&lt;/h6&gt;

&lt;h6&gt;在没有设置Fog的默认情况下，Fog会根据 Lighting Window(Window &amp;gt; Lighting &amp;gt; Settings) 里的设置进行渲染。&lt;/h6&gt;
</description>
               <pubDate>Tue, 14 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/14/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader7.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/14/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader7.html</guid>
            </item>
        
            <item>
               <title>白领投资探讨(四)</title>
               <description>&lt;h1&gt;白领投资探讨(四)&lt;/h1&gt;

&lt;p&gt;流动性探讨&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;从交易流动性谈起，在股票和期货市场上做交易，交易量就是流动性，如果没有流动性，就相当于买卖的人少，从而导致少数人决定大多数人价格的情况。&lt;/p&gt;

&lt;p&gt;打个比方一个市值100亿的企业股票，每天的交易量为100万，今天涨5%，那么就是说，这100万导致了100亿的资金躺着赚了5个亿。一个区区100万，却能影响100亿的资金，是不是很不正常。流动性缺失导致的，因为没人交易所以才会使得100万影响100亿。今天会因为这100万的交易涨5%，明天也会因为这100万的交易量而跌10%，甚至20%，这种可能性很大。&lt;/p&gt;

&lt;p&gt;流动性可以比喻为人流，交易的标的可以比作为一座城市，一座城市如果没有人流那就是个空城，如果有人在一座人烟稀少的城市做生意会如何，一个面包卖1块钱也会可能没人要。即使因为空城导致的供给短缺价格上涨，有人卖100块一个面包，那又怎样，每个月就那么1-2个人来买你这个100块的面包，你永远赚不到大钱，而且随时有亏本的风险，因为这1-2个人随时可能离开，你随时会因为没人来买而亏本破产。在这种城市里做生意是十分危险的，即便你垄断了货物，也有可能破产亏本，因为趋势是空城越来越空，人越来越少，交易越来越少。&lt;/p&gt;

&lt;p&gt;因此流动性差得地方价格特别容易有特别大的起伏，今年1块钱一个，明年100块钱一个，但买卖交易的人永远都只会是那么一两个。大的资金是绝对不会去那种地方的，因为即使在1块钱买进仓库的面包，在价格涨到100块的时候卖出，也卖不了几个，没人来接盘，大量的面包堆积在仓库卖不出去。&lt;/p&gt;

&lt;h3&gt;聪明的富人远离流动性差的投资产品是有道理的，他们知道倘若没人做他们的对手盘，没人愿意接盘怎么做都是死永远赚不到钱，而且随时有把所有钱都亏完的风险，他们何必要冒这么大的风险做这种愚蠢的事。只有没有钱的穷人，眼里只看到价格的穷人，才会冲进去交易厮杀，最终的结果是没人能赢，因为交易本身就是个负和游戏，买卖双方在交易完成时就要交一笔费用，交易税。&lt;/h3&gt;

&lt;p&gt;那么流动性大，到底有什么好处呢？&lt;/p&gt;

&lt;h3&gt;1，当参与者众多的时候，能平摊风险。要明白，交易是人创造出来，人的思维具有多样，有人看多就有人空，否则，怎么会有成交，就因为有人卖有人买才能成交。卖的人看空，买的人看多，人越多，多样性越复杂，随时随地有看空的转为看多，看多的转为看空，多空一直在随着时间的推移不断得变化，人越多这种多样性就越多，变化也就越复杂。&lt;/h3&gt;

&lt;p&gt;所以我们说股价是不可控的，无论你精通多少数学方法，AI计算，宏观经济，企业财报都无法知道股价的走势。这不仅仅是在流动性大的地方不可控，在流动性少的地方也一样不可控，因为交易本身就是由人创造出来的，人这种生物本身就是不可控的，虽然我们因为这种不可控导致获得了很多好处，比如发明新的理论，发现新的大陆等。&lt;/p&gt;

&lt;p&gt;那么越多的多样性怎么就能平摊风险了呢？就因为多样性才能平摊风险，不至于预期一致性，比如一致看空无人看多的情况，一个几百亿市值的公司，一夜市值归零，就是一致看空导致的结果，所有人都不看好，没人看好的结果就是踩踏，挤兑，巨幅下跌。&lt;/p&gt;

&lt;p&gt;但是如果有足够多的多样性会如何？即使再大的坏消息，依然有人看多，那些人认为坏消息固然不好，但是跌的太过，完全超出了坏消息的影响幅度，或者有人认为利空消息是有人恶意编造，或者有人认为利空消息有可能会转折，甚至会有人认为利空消息并不一定是坏消息也有利于管理层认清现实在今后的工作中更加有效对待现有的漏洞。&lt;/p&gt;

&lt;p&gt;这些多样性导致大量的买入操作，从而让更多人相信跌的太多，或者有希望将利空消息转为利好消息，从而随着时间的推移，看空转看好的人越来越多，致使不至于导致非常糟糕的一致性预期，踩踏，挤兑等。&lt;/p&gt;

&lt;p&gt;这就是流动性的好处，让更多的多样性来平摊风险，而不至于让预期一致性发生而导致一瞬间破产。&lt;/p&gt;

&lt;h3&gt;2，吸引更多资金参与，有更多接盘可能的选择。流动性好的地方，因为交易的频繁，导致交易量大，比如1天几十亿资金的交易量，待在里面的1个亿体量的基金会很放心，随时都可以在几天之内把自己手上的股票抛完，也可以在几天之内买进几亿的股票而不让股票大幅上升而增加自己的持仓成本。&lt;/h3&gt;

&lt;p&gt;所以更多的资金愿意参与进来，因为大家知道，自己随时都能套现走人，而不用顾忌被埋，他们更多的专注是企业的内在，企业的核心资产，核心技术，技术壁垒，管理层人员，行业供给等。&lt;/p&gt;

&lt;p&gt;当资金认为这个企业有美好未来时候，它可以毫不犹豫的买入而不影响股价上涨带来的持仓成本抬高，相反，当他们认为美好未来不再，可以随时卖出而不影响股价下跌导致成交价下跌，因为接盘的人随时都有。&lt;/p&gt;

&lt;p&gt;流动性大导致，资金持有人可以不用考虑自己想卖的时候没人要。作为一个投资持有者，无论是你持有股票，还是期货，还是房产，都是一样的，最怕的不是卖的价格太低，而是卖不出去，没人愿意接盘，再低的价格都没人要的情况，因为那时候就相当于你手里持有的是一张废纸。&lt;/p&gt;

&lt;h3&gt;简单的来说，流动性差的地方更容易破产，一瞬间破产的概率较大，流动性大的地方虽然不能保证价格上升但可以保证不会一夜破产，并且会因为多样性多而得到有更多机会。&lt;/h3&gt;
</description>
               <pubDate>Mon, 13 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/13/%E7%99%BD%E9%A2%86%E6%8A%95%E8%B5%84%E6%8E%A2%E8%AE%A84.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/13/%E7%99%BD%E9%A2%86%E6%8A%95%E8%B5%84%E6%8E%A2%E8%AE%A84.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，Shader(六) - Pass(三)Blend</title>
               <description>&lt;h3&gt;Blend，设置颜色混合的方式。&lt;/h3&gt;

&lt;p&gt;Blend 主要作用是颜色混合，颜色混合是在所有渲染完成图像都成型后进行的，这时像素都已经被绘制好了，并且屏幕上也已经有成像的图形，但还没有完全完成，因为是物体各自画各自的已经画完了放入了缓存中，但alpha还没有发挥出效果，这时就需要混合来做补充，这之前的屏幕上所有的图像都是实体的，没有半透明和透明部分。总之Blend最重要的作用就是让alpha起到半透明的作用，当然也可以做到颜色加强，改变，混合，削弱等作用。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader34.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    图1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader34.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    图2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图1为没启用Blend的效果，没有发挥alpha的半透明和透明的作用。&lt;/p&gt;

&lt;p&gt;图2为启用了Blend的效果，贴图上的alpha发挥了应该有的透明效果。&lt;/p&gt;

&lt;p&gt;Blend在Shader上的格式，图1只是注释掉了Blend那一行，图2没有注释任何代码:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shader&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;Test/Blend&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Properties&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Base (RGB) Trans (A)&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;white&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SubShader&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Blend&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SrcAlpha&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OneMinusSrcAlpha&lt;/span&gt; 

            &lt;span class=&quot;n&quot;&gt;SetTexture&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;Combine&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Primary&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Texture&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;上述例子将Alpha混合进颜色中。&lt;/p&gt;

&lt;p&gt;下面我们来看看Blend的使用方法以及它的参数配置。&lt;/p&gt;

&lt;h6&gt;1，Blend Off，关闭混合，默认是关闭颜色混合的。&lt;/h6&gt;

&lt;h6&gt;2，Blend SrcFactor DstFactor。&lt;/h6&gt;

&lt;p&gt;当前物体产生的图像上的颜色与ScrFactor(Source Factor)参数相乘，屏幕上的已经存在的颜色与DstFactor(Destination Factor)参数相乘，两者的结果相加的结果放入帧缓存。&lt;/p&gt;

&lt;p&gt;这里的ScrFactor(Source Factor)和DstFactor(Destination Factor)是固定的系数，ScrFactor中的Source 意味着本物体，代表本物体颜色相关，Destination意味着Blend前已经在屏幕上绘制的颜色相关。&lt;/p&gt;

&lt;p&gt;这些系数说明如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;One，表示完整的颜色，不加修改，无论是本物体的颜色还是屏幕上的颜色。

Zero，表示数据零，本物体和屏幕上的颜色都不要。

SrcColor，表示本物体的颜色。

SrcAlpha，表示本物体的Alpha。

DstColor，表示屏幕上的颜色。

DstAlpha，表示屏幕上的Alpha。

OneMinusSrcColor,表示1-Source Color，即反转本物体上的Color。

OneMinusSrcAlpha,表示1-Source Alpha，即反转本物体上的Alpha。

OneMinusDstColor,表示1-Destination Color，即反转屏幕上的Color。

OneMinusDstAlpha,表示1-Destination Alpha，即反转屏幕上的Alpha。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假设：颜色信息的四个分量（红Red，绿Green，蓝Blue，透明度Alpha）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    （1）“源颜色”  ：（Rs, Gs, Bs, As）

    （2）“目标颜色”：（Rd, Gd, Bd, Ad）

    （3）“源因子”  ：（Sr, Sg, Sb, Sa）

    （4）“目标因子”：（Dr, Dg, Db, Da）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么混合产生的新颜色可以表示为：（Rs&lt;em&gt;Sr + Rd&lt;/em&gt;Dr , Gs&lt;em&gt;Sg + Gd&lt;/em&gt;Dg , Bs&lt;em&gt;Sb + Bd&lt;/em&gt;Db , As&lt;em&gt;Sa + Ad&lt;/em&gt;Da）&lt;/p&gt;

&lt;p&gt;如果颜色的某一分量超过了1.0，则它会被自动截取为1.0，不需要考虑越界的问题。&lt;/p&gt;

&lt;p&gt;混合说的通俗点就是把某一像素位置上原来的颜色和将要画上去的颜色，通过某种公式计算得出另一种颜色，从而实现特殊的效果。&lt;/p&gt;

&lt;p&gt;源图片颜色被称作“源颜色”，而屏幕上已存在的图片颜色则被称作“目标颜色”。&lt;/p&gt;

&lt;h6&gt;3，BlendOp Op，此命令可以改变两个颜色结果相加的操作。&lt;/h6&gt;

&lt;p&gt;颜色混合的最后一步是相加，通过这个命令可以改变最后一步的符号，比如相减，取最小值，取最大值等。&lt;/p&gt;

&lt;p&gt;具体可用的操作符如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;Add，相加，默认的操作符号。

Sub，相减，目标结果 – 源结果。

RevSub，相减，源结果 – 目标结果。

Min，取最小值，目标结果和源结果中取最小值。

Max，取最大值，目标结果和源结果中取最大值。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有一些只能在特定显卡下使用的操作符，比如LogicalClear，LogicalSet等等只能在DX11.1及以上的版本中使用。&lt;/p&gt;

&lt;h6&gt;4，BlendOp OpColor,  OpAlpha，此命令与上面一样也是改变操作符号的，但此命令可以把颜色和Alpha的操作符号分开来改变。&lt;/h6&gt;

&lt;p&gt;OpColor参数代表目标结果和源结果的颜色操作符号，OpAlpha参数代表目标结果和源结果的Alpha操作符号。&lt;/p&gt;

&lt;p&gt;可用的参数与BlendOp Op一样，只是拆分了Color和Alpha。&lt;/p&gt;

&lt;h6&gt;5，当使用Multiple render target(MRT)多管线目标渲染时，还可以针对不同的管线目标进行操作，但仅限于固定级别显卡以上的设备，比如DX11/12, GLCore, Metal, PS4等。&lt;/h6&gt;

&lt;p&gt;下面是可操作的命令格式，N为目标管线索引(0-7)：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Blend N SrcFactor DstFactor

    Blend N SrcFactor DstFactor, SrcFactorA DstFactorA

    BlendOp N Op

    BlendOp N OpColor, OpAlpha
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;6，AlphaToMask On/Off，此命令为开关Alpha To Coverage(A2C)。&lt;/h6&gt;

&lt;p&gt;Alpha To Coverage(A2C)是一种经由流水线完成的“Alpha Test”。&lt;/p&gt;

&lt;p&gt;在使用了多重采样(Multi-sample)的场合下，经由检测当前需要绘制的fragment的alpha值来决定该fragment在对应像素上的sample覆盖率。&lt;/p&gt;

&lt;p&gt;启用AlphaToMask的条件是必须在multisample anti-aliasing(MSAA，在QualitySetting中设置)开启的情况下才有效。&lt;/p&gt;

&lt;p&gt;Alpha To Coverage(A2C)是对Alpha Test和Alpha Blend的两种透明绘制方法的折中改进方法。&lt;/p&gt;

&lt;p&gt;Alpha Test过于粗糙，“非0即1”的强硬手段导致边缘有强烈的锯齿感，这种阈值控制的剔除法在渲染上始终有很多不足。&lt;/p&gt;

&lt;p&gt;Alpha Blend(文中的Blend命令)则可以根据物体本身的纹理上的颜色和透明度柔和的将Alpha混合显示在屏幕上并没有锯齿感，但这种机制不是对每个物件并行处理的，对当前DrawCall产生作用时必然会考虑的是当前“画板上已经画了些什么”即所谓的“已经绘制在屏幕上的图像，即目标结果”。这样最后的结果就与深度信息无关了，混合的结果跟绘制的顺序有关(前文中Queue标签的绘制顺序)。&lt;/p&gt;

&lt;p&gt;所以说对于Alpha Blend，必须让绘制满足从后往前的顺序执行，而无法做场景中深度的排序。&lt;/p&gt;

&lt;p&gt;Alpha To Coverage(A2C)中和了Alpha Test和Alpha Blend的方法，让半透明既不那么粗糙，也有深度数据来判断前后的关系。&lt;/p&gt;

&lt;h3&gt;在介绍常用的Blend混合方法之前，我想有必要介绍下颜色的操作符，即颜色的乘法，加法，减法，最小值，最大值的表现结果。&lt;/h3&gt;

&lt;h6&gt;1，颜色乘法，可以视为颜色（或者说图像）的叠加。&lt;/h6&gt;

&lt;p&gt;为什么乘法颜色节点能够让颜色叠加。&lt;/p&gt;

&lt;p&gt;我们把两个RGBA值转换成为0-1之间的范围就可以明白了。&lt;/p&gt;

&lt;p&gt;比如白色（1,1,1,1），灰色（0.5,0.5,0.5,1），两个颜色相乘得到（0.5,0.5,0.5,1） 还是灰色，也就是说在白色的底板上，画上灰色的颜色，颜色就叠加了，这就是颜色的叠加方法。&lt;/p&gt;

&lt;p&gt;颜色相乘的公式是 Color a, Color b, a*b = new Color(a.r * b.r, a.g * b.g, a.b * b.b, a.a * b.a); 从此公式可以看出，因为所有数字都小于等于1，所以相乘只会让颜色更加深，也就是更加接近黑色，不断的叠加各种各样的颜色，最后都会无限接近黑色(0,0,0,1)或者无限接近黑色透明(0,0,0,0)。&lt;/p&gt;

&lt;h6&gt;2，颜色加法，可以视为颜色（或者说图像）加白(或者说亮)。&lt;/h6&gt;

&lt;p&gt;为什么说加法可以视为颜色的加白操作。因为颜色相加后，不能超过最大值1（或者另一种表达方式的数字255）,超过部分都会被截断。&lt;/p&gt;

&lt;p&gt;加法的公式是：Color a, Color b, a+b = new Color(a.r + b.r, a.g + b.g, a.b + b.b, a.a + b.a); 从此公式可以看出，所有的数字都小于等于1，所以r，g，b，a，随着不断加各种颜色，最终会到达最大值1。也就是不透明白色(1,1,1,1)。&lt;/p&gt;

&lt;p&gt;所以颜色无论加什么颜色都会更加接近白色，也就得到我们的结论，颜色加法可以视为颜色（或者说图像）加白(或者说亮)。&lt;/p&gt;

&lt;h6&gt;3，颜色减法，可以视为颜色(或者说图像)的色差。&lt;/h6&gt;

&lt;p&gt;如果两个一样的颜色比如红色，相减，就变成了(0,0,0)黑色，而两个相差比较大的颜色相减，结果就会无限接近白色(1,1,1)。&lt;/p&gt;

&lt;p&gt;颜色的相减公式为：Color a, Color b, a-b = new Color(a.r - b.r, a.g - b.g, a.b - b.b, a.a - b.a); 相减的结果大于等于0小于等于1，一直做减法操作的话，就会无限接近黑色(0,0,0)或者透明黑色即无色(0,0,0,0)。&lt;/p&gt;

&lt;p&gt;因此我们可以认为，颜色相减，可以视为颜色（或者说图像）的色差。&lt;/p&gt;

&lt;h6&gt;4，颜色最大值，可以视为颜色（或者说图像）的最白(或者说亮)状态。&lt;/h6&gt;

&lt;p&gt;因为RGB的所有颜色都做了最大值操作，无论哪个颜色都会更加接近白色(1,1,1)，所以两个颜色或者图像做最大值操作就是取其最白(或者说亮)的状态。&lt;/p&gt;

&lt;h6&gt;5，颜色最小值，可以视为颜色（或者说图像）的最暗状态。&lt;/h6&gt;

&lt;p&gt;与最大值相同因为RGB的所有颜色都做了最小值操作，无论哪个颜色都会更加接近黑色(0,0,0)，所以两个颜色或者图像做最小值操作就是取其最暗(黑)的状态。&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))
    { //移动端
        /*mobile-20:5*/
        var cpro_id = &quot;u3493987&quot;;
        document.write(&quot;\&lt;script type=\&quot;text\/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/cm.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
    else
    {
         /*700*200信息流*/
        var cpro_id = &quot;u3469788&quot;;
        document.write(&quot;\&lt;script type=\&quot;text/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/c.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
&lt;/script&gt;

&lt;h3&gt;有了这些颜色操作的常识我们就可以更加深入的了解Blend混合方法了。&lt;/h3&gt;

&lt;h3&gt;常用的Blen混合方法：&lt;/h3&gt;

&lt;h6&gt;1， 透明度混合Blend SrcAlpha OneMinusSrcAlpha，即常用半透明物体的混合方式。&lt;/h6&gt;

&lt;p&gt;这时最常用的半透明混合了，首先要保证半透明绘制的顺序比实体的要后面，所以Queue标签是必要的Tags {&amp;quot;Queue&amp;quot; = &amp;quot;Transparent&amp;quot;}。Queue标签告诉着色器此物体是透半透明物体排序。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader36.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;Blend SrcAlpha OneMinusSrcAlpha 我们来解释下，以上图为例，图中油桶是带此Shader的混合目标。&lt;/p&gt;

&lt;p&gt;当绘制油桶时，后面的实体BOX已经绘制好并且放入屏幕里了，所以ScrAlpha与油桶渲染完的图像相乘，部分区域Alpha为0即相乘后为无(颜色)，这时正好另一部分由OneMinusSrcAlpha(也就是1-ScrAlpha)为1即相乘后原色不变，两个颜色相加后就相当于油桶的透明部分叠加后面实体Box的画面，于是就形成了上面的这幅画面。&lt;/p&gt;

&lt;p&gt;反过来也是一样，当ScrAlpha为1时，源图像为不透明状态，则两个颜色在相加前最终变成了，源图像颜色+无颜色=源图像颜色，于是就有了上图中油桶覆盖实体Box的图像部分。&lt;/p&gt;

&lt;h6&gt;2，加白加亮叠加混合 Blend One One，即在原有的颜色上叠加屏幕颜色更加白或亮。&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader37.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;第一参数One代表本物体的颜色。第二个参数代表屏幕上的颜色。两种颜色相加则，导致形成的图像更加亮白。这样我们就看到了一个图像加亮加白的图像了。&lt;/p&gt;

&lt;h6&gt;3，保留原图色彩Blend One Zero，即只显示自身的图像色彩不加任何其他效果。&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader38.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;本物体颜色，加上，零，就是本物体颜色。这是最简单的混合了。&lt;/p&gt;

&lt;h6&gt;4，自我叠加（加深）混合Blend SrcColor Zero，即源图像与源图像自我叠加。&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader39.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;与上面相比，加深了本物体的颜色。第一个参数本物体的颜色与本物体的颜色相乘，加深了颜色，第二个参数为零，使得屏幕颜色不被使用。所以形成的图像为颜色加色的图像。&lt;/p&gt;

&lt;h6&gt;5，目标源叠加（正片叠底）混合Blend DstColor  SrcColor，即把目标图像和源图像叠加显示。&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader40.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;第一个参数，本物体颜色与屏幕颜色相乘，颜色叠加。第二个参数，屏幕颜色与本问题颜色相乘，颜色叠加。两种颜色相加，加亮加白。这个混合效果就如同两张图像颜色叠加后的效果。&lt;/p&gt;

&lt;h6&gt;6，软叠加混合Blend DstColor  Zero，即把目标源图像叠加到前面来。&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader41.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;与前面的叠加混合效果相似，这个只做一次叠加，并不做颜色相加操作，使得图像看起来在叠加部分并没有那么亮白的突出。因为第二个参数为零，表示后面的屏幕颜色与零相乘即为零。&lt;/p&gt;

&lt;h6&gt;7，差值混合BlendOp Sub，Blend One One，即注重黑白通道的差值。&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader42.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;在这个混合中使用了混合操作改变，从默认的加法改成了减法，使得两个颜色从加法变为了减法，不再是变白变亮的操作，而是反其道成为了色差的操作。&lt;/p&gt;

&lt;h3&gt;ColorMask，设置颜色遮罩过滤。&lt;/h3&gt;

&lt;p&gt;ColorMask可以进行颜色的遮罩功能，这相当于在渲染时把某种颜色剔除一样。&lt;/p&gt;

&lt;p&gt;ColorMask可供选择参数 ColorMask RGB | A | 0 | R,G,B,A的任意组合。&lt;/p&gt;

&lt;p&gt;当ColorMask 0 时将关闭所有的颜色通道，相当于没有颜色渲染就没有成型的图像了，实际上你是看不见它的，只是在Editor下可以点选出来看到轮廓。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader43.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;当ColorMask R|G|B|A时我们来看看效果，第一张是RGBA参数时的图，即为全通道颜色渲染的模型图。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader44.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader45.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader46.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader47.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader48.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;第2张是只开放R(红色)通道其他通道被拒绝，第3张是只开放G(绿色)通道，第4张是只开放B(蓝色)通道，第5张是只开放A (alpha通道)。&lt;/p&gt;

&lt;p&gt;从上图的例子中可以充分的明白了，ColorMask对颜色通道的操作。&lt;/p&gt;

&lt;p&gt;ColorMasks虽然也可以在Multiple render target(MRT)下做一些额外的操作，比如ColorMask RGB 3 后面数字3对RGB通道中进行数字3的遮罩功能，但MRT需要显卡的支持，比如PC显卡中大多数在2006年后支持MRT从GeForce 8XXX，Radeon X2400，Intel G45开始。&lt;/p&gt;

&lt;p&gt;在手机上能支持MRT并不多，而且对MRT的功能也限制了很多，基本可以说在手机平台上无法使用。&lt;/p&gt;
</description>
               <pubDate>Wed, 08 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/08/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader6.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/08/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader6.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，Shader(五) - Pass(二)</title>
               <description>&lt;h3&gt;Render State Command渲染状态指令详解&lt;/h3&gt;

&lt;p&gt;Render State Command 是渲染状态的指令，它在Pass和SubShader都有效，放在Pass就只在当前Pass里有效，放在SubShader中则是多个Pass的共同状态。&lt;/p&gt;

&lt;p&gt;不过不是所有的Render State都可以成为共同拥有的渲染状态的，有些Render State只在Pass中有效，而另一些则可以成为共同渲染状态。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;下面我们来介绍下Pass中的渲染状态Command指令：&lt;/p&gt;

&lt;h3&gt;Cull，前后裁切指令。&lt;/h3&gt;

&lt;p&gt;Cull是种优化的指令，可以让远离屏幕的部分不渲染。所有的物体都有前后两面，比如一个Box箱子你永远都看 不到屏幕另一侧的部分，所以可以对Box箱子后半部分进行裁切不渲染。&lt;/p&gt;

&lt;p&gt;可设置参数如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader20.png&quot; alt=&quot;cull&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    上图为参数 Cull Back，裁切白色Box的后半部分，保留前半部分。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader21.png&quot; alt=&quot;cull&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    上图为参数 Cull Front，裁切白色Box的前半部分，保留后半部分，展示的后半部部分与后面的箱子相交。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader22.png&quot; alt=&quot;cull&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    参数 Cull Off，关闭裁切功能，与Cull Back展示的效果一样，但其实多渲染了后半部分的网格模型。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Cull默认是裁切后半部分的，这样可以达到优化的效果，如果你没有对它进行设置的话。其实裁切后半部分和完全不裁切，在有深度缓存数据时是显示的效果是完全一样的，只是一个做了优化另一个没做而已。&lt;/p&gt;

&lt;h3&gt;ZTest，设置深度缓存测试模式。&lt;/h3&gt;

&lt;p&gt;ZTest的功能是在两个物体相交时渲染绘制中对前后深度进行测试，默认情况下以LEqual小于等于其他物体时测试为不通过，当不通过时就不渲染那部分模型。&lt;/p&gt;

&lt;p&gt;LEqual参数，其实就是测试前面的物体是否挡住了该物体部分，如果挡住了就不渲染的意思，它也是ZTest的默认参数。&lt;/p&gt;

&lt;p&gt;其他参数还包括&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;ZTest Less | Greater | LEqual | GEqual | Equal | NotEqual | Always

参数 小于 | 大于 | 小于 | 小于等于 | 大于等于 | 等于 | 不等于 | 关闭测试
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数解释：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader23.png&quot; alt=&quot;ztest&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;上图中为参数 Less 该物体上的部分深度在其他物体后面时不渲染。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader24.png&quot; alt=&quot;ztest&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;上图中为参数 Greater 该物体上的部分深度在其他物体部分前面时不渲染，也就是被覆盖的显示，没被覆盖的反而不显示。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader25.png&quot; alt=&quot;ztest&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;上图中为参数 Equal 该物体上的部分深度与其他一致时才渲染，否则不渲染。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader26.png&quot; alt=&quot;ztest&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;上图中为参数 NotEqual 该物体上的部分深度与其他物体不一致时才渲染，否则不渲染。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;ZWrite，设置深度缓存写入开关。&lt;/h3&gt;

&lt;p&gt;Zwrite可以控制物体渲染的像素是否写入depth buffer深度缓存数据中。&lt;/p&gt;

&lt;p&gt;如果没有depth buffer深度缓存数据，物体将无法辨识前后关系也就无法实现阻挡物体不绘制的功能。&lt;/p&gt;

&lt;p&gt;这在大多数不透明物体中都是需要depth buffer深度缓存数据来识别前后遮挡的，但在半透明和透明物体中就不需要depth buffer。&lt;/p&gt;

&lt;p&gt;半透明和透明物体没有depth buffer深度缓存数据，所以没有所谓的写入一说，也就是通常在半透明和透明物体的Shader中，ZWrite是关闭的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader27.png&quot; alt=&quot;zwrite&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader28.png&quot; alt=&quot;zwrite&quot;&gt;&lt;/p&gt;

&lt;p&gt;如上两个图，图1为ZWrite On时的效果，黄色Box遮挡住了后面的蓝色Box因为有depth buffer深度缓存的写入，前后关系有依据。&lt;/p&gt;

&lt;p&gt;图2为ZWrite Off的效果，后面蓝色的Box被提到了黄色Box的前面显示，这是因为黄色Box的depth buffer没有写入，在渲染时，面片前后关系没有了依据，导致了错乱。&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))
    { //移动端
        /*mobile-20:5*/
        var cpro_id = &quot;u3493987&quot;;
        document.write(&quot;\&lt;script type=\&quot;text\/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/cm.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
    else
    {
         /*700*200信息流*/
        var cpro_id = &quot;u3469788&quot;;
        document.write(&quot;\&lt;script type=\&quot;text/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/c.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
&lt;/script&gt;

&lt;h3&gt;Offset，设置深度缓存的偏移。&lt;/h3&gt;

&lt;p&gt;Offset允许你设置物体在深度缓冲中的偏移量，这相当于让物体在屏幕显示中提前或者推后显示位置，但实际世界中的位置不变。&lt;/p&gt;

&lt;p&gt;Offset有两个参数，Factor偏移缩放大小和Units偏移量。Factor相当于缓存数据偏移放大的倍数，Units相当于直接偏移的量。&lt;/p&gt;

&lt;p&gt;如果从公式上理解，可以理解为Buffer = (x or y)*Factor + Units。&lt;/p&gt;

&lt;p&gt;举例 Offset 3 , 5，可以理解为偏移放大3倍，并且再偏移5个单位。&lt;/p&gt;

&lt;p&gt;注意，偏移负方向才是离屏幕越近的方向。所以Offset 0 , -1时，两个物体重合部分肯定是拥有Offset 0 , -1的提前显示。&lt;/p&gt;

&lt;p&gt;如果两个物体前后差的比较远，那么想把后面的物体提到前面来显示，那么就要加大偏移量了，比如 Offset 0 , - 1000 或者 Offset -100, -1等。&lt;/p&gt;

&lt;p&gt;下面举例说明Offset的作用：&lt;/p&gt;

&lt;p&gt;对白色的做处理Offset 0 , 0 -------两者重叠，时而显示普通的有贴图的立方体，时而显示白色的立方体，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader29.png&quot; alt=&quot;offset&quot;&gt;&lt;/p&gt;

&lt;p&gt;对白色的做处理Offset 0 , -1------两者重叠部分完全被白色覆盖,因为白色立方体做了偏移量的处理，深度缓存中的坐标离屏幕更近，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader30.png&quot; alt=&quot;offset&quot;&gt;&lt;/p&gt;

&lt;p&gt;对白色的做处理Offset 0 , 0 ---- 现在把两个立方体的距离拉开，正常情况下按透视的距离进行显示，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader31.png&quot; alt=&quot;offset&quot;&gt; &lt;/p&gt;

&lt;p&gt;对白色的做处理Offset 0 , -1000 ---- 现在加重白色立方体的偏移量，深度缓存数据向屏幕偏移，这时很多有贴图的立方体部分被覆盖，因为偏移量加大，提前量就加大了，但绿色立方体其他部分的深度数据还是比偏移后的大，所以那个部分还是无法覆盖，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader32.png&quot; alt=&quot;offset&quot;&gt;&lt;/p&gt;

&lt;p&gt;对白色的做处理Offset -100 , -1000------再次加大偏移量，这次加入了缩放比例的偏移，偏移的更多，使得白色立方体全部覆盖绿色立方体，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader33.png&quot; alt=&quot;offset&quot;&gt;&lt;/p&gt;

&lt;p&gt;注意以上所有图中两个立方体的世界坐标一直都没有更改。如果要让物体向后推也是同样方法，负数变正就可以，所有的偏移都是渲染上的偏移，与物体实际坐标无关。&lt;/p&gt;
</description>
               <pubDate>Wed, 08 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/08/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader5.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/08/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader5.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，Shader(四) - Pass(一)</title>
               <description>&lt;h3&gt;Pass&lt;/h3&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;Pass块的格式，如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;    [Name and Tags]&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;    [Render State]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Pass可以定义自己的名字，和Tag标签，以及渲染状态Render State。&lt;/p&gt;

&lt;p&gt;Pass通过Tag标签来变更渲染引擎里的设置。Pass里的这个Tag和SubShader上的Tag是同一种标签，SubShader起到了共享标签的作用，而Pass里的Tag则是独立的个性化的。&lt;/p&gt;

&lt;h3&gt;Tag标签详解&lt;/h3&gt;

&lt;p&gt;Tag的格式很简单，就同Key-Value一样，每个标签都有一个Key，对应一个Value，Key之间用空格隔开。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { “TagKey1” = “Value1” “TagKey2” = “Value2” }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么究竟有哪些Tag可以供我们使用？&lt;/p&gt;

&lt;p&gt;我们先介绍SubShader和Pass共用的Tag。&lt;/p&gt;

&lt;h6&gt;Queue 标签Tag&lt;/h6&gt;

&lt;p&gt;Queue是渲染顺序的标签。可以用这个标签决定模型在绘制时所用的顺序。&lt;/p&gt;

&lt;p&gt;Shader会在渲染前决定物体属于哪个渲染顺序，从而确保所有透明或半透明物体的绘制顺都排在不透明物体的后面。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    例子，Tags { &amp;quot;Queue&amp;quot; = &amp;quot;Transparent&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下为渲染顺序的定义选择。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Background：这种类型的顺序会排在所有物体的前面。

    Geometry(默认)：大多数物体都使用这种方式。所有不透明物体使用这个类型。

    AlphaTest：使用Alpha Test的物体使用这个类型的渲染顺序。它被排在不透明物体的渲染后面。

    Transparent：排在Geometry和AlphaTest后渲染。所有alpha混合的物体都应该选择这个类型（因为Shader不会入depth buffer）。

    Overlay：这个类型是最后渲染的，比前面所有类型都要置后。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在实际的运用过程中，Render Queue是可以有自己的排序状态的，不同的Shader同一种排序类型可以有不同的前后关系。&lt;/p&gt;

&lt;p&gt;比如在两个物体都使用Geometry类型的渲染顺序，第一个物体使用 Geometry+1 比其他的 Geometry 类型物体更加滞后渲染，第二个物体使用 Geometry+2 写法，比第一个物体还要靠后渲染，目的有可能是需要在其他物体渲染完毕后再对周围环境做出反应。&lt;/p&gt;

&lt;p&gt;这种方式在透明和半透明的物体中特别常用，因为透明和半透明物体没有深度缓存测试，所以他们之间的渲染顺序是混乱的，当两个半透明物体放在前后位置进行渲染时，摄像机看到的是一个比较混乱的排序方式。因此在半透明物体的运用中我们时常人工指定某些物体的排序大小，比如如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { &amp;quot;Queue&amp;quot; = &amp;quot;Transparent+1&amp;quot; }

    Tags { &amp;quot;Queue&amp;quot; = &amp;quot;Transparent+2&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后者比前者在渲染绘制时排在后面，先绘制了+1的半透明物体后，再绘制+2的半透明物体，结果是+2物体会覆盖+1物体而显示得靠前。&lt;/p&gt;

&lt;p&gt;例子中“+1”表达了渲染顺序往后靠一位，+2比+1更往前后，数字越大渲染时越排在后面。&lt;/p&gt;

&lt;p&gt;“Queue”标签在Shader里会提前告诉着色器这个物体的渲染顺序，这样在渲染中就不会因为没有深度缓存数据而导致前后渲染的混乱。&lt;/p&gt;

&lt;p&gt;渲染顺序到2500(“Geometry+500”)是非透明物体和可优化绘制顺序（自动排序）物体最佳的性能位置。&lt;/p&gt;

&lt;p&gt;超过2500是半透明物体和手动排序物体的区间范围。天空盒(Skybox)被排在非透明物体和半透明物体中间。&lt;/p&gt;

&lt;h6&gt;RenderType 标签Tag&lt;/h6&gt;

&lt;p&gt;RenderType 标签是自由识别类标签，他没有自己的标签类型选择，可以为任意字符串。&lt;/p&gt;

&lt;p&gt;RenderType的主要作用是被识别与替代。在Shader替换效果中比较常用，比如场景中有些类型的物体需要在某个时刻替换某种Shader，并且不是真正的替换Shader，而是只针对某个Camera摄像机，其他的Camera摄像机保持原样。这时就需要用到RenderType标签，再用Camera.RenderWithShader或Camera.SetReplacementShader进行替换，因为函数中需要找出某种类型的Shader进而才可以进行替换，所以RenderType就是那个标识记号。&lt;/p&gt;

&lt;p&gt;Camera.RenderWithShader或Camera.SetReplacementShader渲染的规则是，没有RenderType标记的全部替换并渲染，有标记的但跟给定的标记一样的才渲染，否则不渲染。&lt;/p&gt;

&lt;p&gt;Unity内部Shader已经全部标记了RenderType，可以在它的Shader源码内参考。&lt;/p&gt;

&lt;h6&gt;DisableBatching标签&lt;/h6&gt;

&lt;p&gt;DisableBatching可以将该物体上的Draw Call Batching打开或关闭。&lt;/p&gt;

&lt;p&gt;为什么要关闭呢，因为在一些Shader中需要对顶点进行更改达到Mesh变化的目的，而Draw Call Batching会对所有的可合并的模型进行合并后放入场景空间，所以这些对Mesh操作的Shader就不起作用了，需要关闭Draw Call Batching才能重新得到该Shader要的效果。&lt;/p&gt;

&lt;p&gt;DisableBatching有三种类型可以选择。&lt;/p&gt;

&lt;p&gt;第一种是True，标志着Draw Call Batching 功能在这个物体上将被关闭。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { &amp;quot;DisableBatching&amp;quot; = &amp;quot;True&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二种是False，标志着Draw Call Batching 功能在这个物体上不关闭。False是默认值，也就是说如果不去设置它时，Shader模式是不关闭Draw Call Batching的。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { &amp;quot;DisableBatching&amp;quot; = &amp;quot;False&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第三种是LODFading，这个比较特殊，只在LOD fading设置被开启时关闭这个物体上的Draw Call Batching功能。一般常用在树上，会动且有LOD功能。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { &amp;quot;DisableBatching&amp;quot; = &amp;quot;LODFading&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;这里简单介绍下Draw Call Batching功能，后面章节中会有详细的介绍。&lt;/h6&gt;

&lt;p&gt;每个物体都有一个材质球，每个材质球都有一个Shader，每个Shader都起码有 一个Pass渲染管线，每个物体在渲染时，引擎会抓取模型的顶点，网格，颜色，贴图，UV，法线等数据进行一次渲染操作。&lt;/p&gt;

&lt;p&gt;那么如果每个物体都单独走一次渲染管线，几百几千甚至几万个物体一起渲染时，就会因为渲染引擎工作量过大CPU和GPU负荷过高而导致画面渲染次数减少，也就是帧数下降，因为每一帧一个画面。帧数下降导致画面有卡顿感，不流畅。所以要使用Batching批处理进行优化，于是就有了Draw Call Batching。&lt;/p&gt;

&lt;p&gt;它是怎么优化的呢？把所拥有有相同材质球的模型放在一起走一次渲染管线，不同的材质球对应的模型不能进行Draw Call Batching。&lt;/p&gt;

&lt;p&gt;这样大大加强了处理速度，原来一个一次的处理方式，变成了一批一次，达到了优化的目的，绘制画面的次数上去了，每秒的帧数（FPS）也上就去了。&lt;/p&gt;

&lt;p&gt;Draw Call Batching分两种，一种是动态的，一种是静态的。&lt;/p&gt;

&lt;p&gt;要进行动态的Batching批处理要求有点高，比如它要求模型必须少于900个顶点甚至更少，又比如它要求Batching批处理对象的Scale大小是一模一样的否则不予处理，再比如必须使用同一种材质球而且是同一个实例，不同材质球或者同一材质球而不同实例也不行，还有如果有烘培的模型，它的烘培图必须是同一张，甚至Shader中不能使用多个Pass等等苛刻的条件。所以想要做动态批处理还是比较困难的。&lt;/p&gt;

&lt;p&gt;静态Batching就比较好弄了，只有在编辑器的右上角勾选静态标志就可以了，不过一旦勾上静态标志，物体就再也不能动不能旋转和缩放了。&lt;/p&gt;

&lt;p&gt;当然Draw Call Batching本身有很多的限制，但对优化渲染管线还是有一定好处的，如果想要加大加强加快优化的力度，还有其他很多方法，每个部分的优化方案都写进了各个章节中，特别是针对Draw Call Batching的替代方案，在模型章节中有很深入的讲解。&lt;/p&gt;

&lt;h6&gt;ForceNoShadowCasting 标签Tag&lt;/h6&gt;

&lt;p&gt;ForceNoShadowCasting是针对是否强制关闭阴影投射功能的。&lt;/p&gt;

&lt;p&gt;当ForceNoShadowCasting为True时，物体将不会去绘制阴影部分，着色器也不会把时间浪费在阴影的绘制上了。默认为False的，默认状态下，物体会去绘制阴影部分的渲染图。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { &amp;quot;ForceNoShadowCasting&amp;quot; = &amp;quot;True&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;IgnoreProjector 标签Tag&lt;/h6&gt;

&lt;p&gt;IgnoreProjector针对的是投射阴影的开关功能。&lt;/p&gt;

&lt;p&gt;当IgnoreProjector为True时，着色器将关闭Projector投射阴影的绘制功能，这个物体将不会绘制投射阴影部分的渲染。默认状态下是False，默认状态下，物体是能响应Projector投射的阴影绘制的。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { &amp;quot;ForceNoShadowCasting&amp;quot; = &amp;quot;True&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;CanUseSpriteAtlas 标签Tag&lt;/h6&gt;

&lt;p&gt;CanUseSpriteAtlas是针对图集里的元素的，它是UGUI中常使用。当CanUseSpriteAtlas为False时，将不会对打进图集里的贴图进行绘制。默认为True。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { &amp;quot;CanUseSpriteAtlas&amp;quot; = &amp;quot;False&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;PreviewType 标签Tag&lt;/h6&gt;

&lt;p&gt;PreviewType是展示材质球预览形状的默认选项的。编辑器中Material材质球展示预览效果时，默认是球形，通过这个标签，可以设置为Plane面板形状，也可以设置为Skybox天空盒形状。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { &amp;quot;PreviewType&amp;quot; = &amp;quot;Plane&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))
    { //移动端
        /*mobile-20:5*/
        var cpro_id = &quot;u3493987&quot;;
        document.write(&quot;\&lt;script type=\&quot;text\/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/cm.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
    else
    {
         /*700*200信息流*/
        var cpro_id = &quot;u3469788&quot;;
        document.write(&quot;\&lt;script type=\&quot;text/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/c.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
&lt;/script&gt;

&lt;h3&gt;以上是SubShader和Pass共享的Tag标签，下面我们介绍一些只有在Pass里使用的Tag标签。&lt;/h3&gt;

&lt;h6&gt;LightMode 标签Tag&lt;/h6&gt;

&lt;p&gt;通过设置LightMode可以在Pass里设置一个光照模型，主要是针对光的相互作用。&lt;/p&gt;

&lt;p&gt;值类型选择范围有：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Always：一直都渲染，不应用光照作用。

    ForwardBase： 使用正向渲染。环境光，主方向光，vertex/SH lights 和 烘培贴图功能被开启。

    ForwardAdd：使用正向渲染。在ForwardBase的基础上，添加像素光的应用，每个Pass（渲染管线）一个灯管。

    Deferred：使用延迟渲染。着色使用g-buffer。

    ShadowCaster：渲染物体depth到阴影图(Shadowmap)或者一张深度贴图(depth texture)。

    MontionVectors：计算每个物体的运动矢量。

    PrepassBase：使用旧的延迟光照。渲染法线和镜面反射。

    PrepassFinal：使用旧的延迟光照。用合并贴图，光照和发散光，来渲染最终颜色。

    Vertex：当物体不使用烘培贴图时，使用旧的顶点灯光渲染模式。所有顶点光都被开启。

    VertexLMRGBM：当物体使用烘培贴图时，使用旧的顶点灯光渲染模式。PC和Console平台上烘培贴图是RGBM编码格式。

    VertexLM：当物体使用烘培贴图时，使用久的顶点灯光渲染模式。在手机平台上烘培贴图是double-LDR编码。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;PassFlags 标签Tag&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    OnlyDirectional：当使用ForwardBase的Pass标签时，这个标签会只让主方向光和环境光数据通过进入Shader。这意味着不重要的灯光数据，不会被通过进入顶点光或球面谐波Shader变量。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;RequireOptions 标签Tag&lt;/h6&gt;

&lt;p&gt;RequrieOptions可以做到，一个Pass申明当有某种外部条件发生的时候才被渲染。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    SoftVegetation：当软植物(Soft Vegetation)在Quality Settings中被设置时，才渲染这个Pass。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
               <pubDate>Wed, 08 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/08/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader4.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/08/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader4.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，Shader(三) - 渲染管道</title>
               <description>&lt;h3&gt;SubShader模块&lt;/h3&gt;

&lt;p&gt;SubShader相当于子Shader的意思，SubShader在Shader中可以有很多个，每个SubShader都可以针对一种设备，但不是所有SubShader都会被采用。当Unity去展示一个模型时，会从第一个SubShader开始寻找是否匹配当前的设备，如果不匹配则与下一个SubShader继续匹配，直到找到能够匹配该设备为止。如果所有的SubShader都没有匹配上，则会使用 Fallback 标签的Shader。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;格式如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SubShader&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;   [Tags]&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;   [CommonState]&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;   [Pass1]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RenderSetup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;    [Pass2]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RenderSetup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;    [Pass3]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RenderSetup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;    […]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Fallback&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;”&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fallback&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Off&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;SubShader中可以定义了Tag标签，以及与Pass共同拥有的状态(Common State)。&lt;/p&gt;

&lt;p&gt;Pass代表了一个渲染管道，每次通过Pass进行渲染都是通过一次完整渲染管道。&lt;/p&gt;

&lt;p&gt;当一个SubShader被设备选中进行渲染时，定义的每个Pass都会渲染该物体一次，如果有很多灯光相互作用的话可能不止一次。通过Pass渲染一次会承担相当大的代价，所以我们在编写Shader Pass时需要小心，尽量减少Pass的使用，尽量将Pass数量最小化。&lt;/p&gt;

&lt;p&gt;建议只有在我们无法使用单个Pass达到效果时，才启用多个Pass进行Shader编程。&lt;/p&gt;

&lt;p&gt;所有在SubShader块中的渲染状态都可以在Pass中进行特殊化，也就是说定义在SubShader中的渲染状态是所有Pass公有的渲染状态，同时Pass可以定义自己的个性化的渲染状态。&lt;/p&gt;

&lt;p&gt;比如以下例子：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SubShader&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Lighting&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Off&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Cull&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Front&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Cull&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Back&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Fallback&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Diffuse&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;”&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;上述例子中 SubShader 设置了一个共同的渲染状态(Common State)就是把灯光影响关掉，灯光不再影响着色，第一个Pass中使用了独立的渲染状态是，裁切模型前半部分，第二个Pass中也使用了独立的渲染状态，裁切模型模型后半部分，然后他们共同拥有Common State是关闭灯光效果，所以第一个Pass就有了两个状态，一个是关闭灯光效果，第二个是裁切前半部分模型，而第二个Pass的也有两个状态，一个是关闭灯光效果，另一个是裁切后半部分模型。&lt;/p&gt;

&lt;p&gt;SubShader最后还有一个Fallback标识，代表了当所有SubShader都对设备无效时，则选择备用的Shader作为替代。而当你认为无法替代，或者无需替代的时候可以关闭Fallback的功能 Facllbck off 。&lt;/p&gt;

&lt;p&gt;在上面的例子中，Fallback “Diffuse”表示了，当所有SubShader都无法起作用的时候漫反射Diffuse替代当前Shader。&lt;/p&gt;

&lt;p&gt;SubShader本身并不复杂，但里有几个重要的模块，以及这些模块中的标签和用途可能会稍微繁琐一些，下面我们要详细讲一讲Pass块的格式和属性内容。&lt;/p&gt;

&lt;h3&gt;渲染管道&lt;/h3&gt;

&lt;p&gt;提到渲染管道，不得不提到渲染管线流程，一整个渲染管线流程分八个阶段。&lt;/p&gt;

&lt;h6&gt;阶段1， 指定几何对象&lt;/h6&gt;

&lt;p&gt;这个阶段引擎在选择某些几何对象作为渲染目标。&lt;/p&gt;

&lt;p&gt;理论上是一次抓取一个几何对象，但一般引擎都有批处理优化功能，一次抓取一批相同材质球的几何物体进行渲染。&lt;/p&gt;

&lt;h6&gt;阶段2，顶点处理&lt;/h6&gt;

&lt;p&gt;主要工作就是“变换三维顶点坐标”和“光照计算”。&lt;/p&gt;

&lt;p&gt;顶点变换或坐标系变换包括：&lt;/p&gt;

&lt;p&gt;3D中有以下几种空间：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1，Object space，模型坐标

    模型空间也叫本地空间或者建模空间，这是我们定义物体三角形的坐标系，当一个建模人员创建一个物体的三维模型的时候，他选择了一个方便的方向、比例和位置来保存模型的组成顶点，当前物体的模型、空间和其他模型没用任何关系。

    2，World space，世界坐标；

    世界空间的目的就是给你的场景中的物体提供一个绝对的参考。

    3，Eye space，视觉空间（视锥裁剪）

    以摄像机为基准，以摄像机的位置为原点，摄像机朝向Z轴正方向，右边X轴为正方向，上边为Y轴正方向，之所以设置这个坐标系，主要是为了方便投影及裁剪操作。

    ###### 4，Clip and Project space，摄影，裁剪空间坐标（也叫屏幕坐标）

    该空间即世界空间的物体被投影到相应的投影上面之后，继而进行的裁剪操作所在的空间。

    Eye space坐标转换到Clip and Project space坐标的过程其实就是一个投影、剪裁、映射的过程。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了坐标转换和光照计算，第2阶段还做了纹理坐标变换(纹理矩阵)，材质状态纹理坐标生成。&lt;/p&gt;

&lt;p&gt;这个阶段所接收到的数据则是每个顶点的属性特征，输出则是变换后的顶点数据。&lt;/p&gt;

&lt;p&gt;这个阶段也是Shader里，vertex fragment着色器编程中 vertex 顶点转换函数的处理阶段，vetex顶点函数就在这个阶段编写顶点的变化。&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))
    { //移动端
        /*mobile-20:5*/
        var cpro_id = &quot;u3493987&quot;;
        document.write(&quot;\&lt;script type=\&quot;text\/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/cm.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
    else
    {
         /*700*200信息流*/
        var cpro_id = &quot;u3469788&quot;;
        document.write(&quot;\&lt;script type=\&quot;text/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/c.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
&lt;/script&gt;

&lt;h6&gt;阶段3，图元装配&lt;/h6&gt;

&lt;p&gt;在顶点处理之后,顶点的全部属性都已经被确定 在这个阶段顶点将会根据应用程序送往的图元规则.&lt;/p&gt;

&lt;h6&gt;阶段4，图元处理(裁剪 消隐)&lt;/h6&gt;

&lt;p&gt;将图元与用户定义的裁剪平面和模型投影矩阵所建立的视景比较，裁剪且丢弃位于视景和裁剪平面外部的图元，不再予以处理。&lt;/p&gt;

&lt;p&gt;若是采用透视投影，那么将会对每个顶点的x,y,z坐标分别乘以透视矩阵。&lt;/p&gt;

&lt;p&gt;接着由视口变换将顶点坐标变换至窗口坐标。视口变换，即把投影变换后的顶点X,Y坐标，根据用户设定的视口参数，变换到屏幕上对应的坐标。&lt;/p&gt;

&lt;p&gt;最后执行消隐操作，把那些被遮挡的部分进行消除。&lt;/p&gt;

&lt;p&gt;消隐操作，即隐藏面消除，即使经过了裁剪操作，对于每个物体，摄像机只能看到正对着摄像机的一面，对背对着摄像机的一面是看不到的。&lt;/p&gt;

&lt;p&gt;这一步的任务就是把看不到的这一面消除掉，以免继续处理，影响计算机的性能和效率。&lt;/p&gt;

&lt;p&gt;为了确定一个多边形是正对着还是背对着摄像机，就要用到我们在输入集合阶段指定多边形时的顶点顺序了，默认情况下，D3D规定按顺时针指定的三角形属于正面，逆时针为背面。确定顺时针还是逆时针，可以用如下方法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    给出两个向量：E0=V1-V0 E1=V2-V0 对E0和E1进行叉乘操作N=E0XE1，如果N指向摄像机，则为正面，否则为背面。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;阶段5，栅格化&lt;/h6&gt;

&lt;p&gt;三维模型经过了顶点变换已经投影到了二维平面上，而且被装配成图元了，但是屏幕是一个一个细细小小的像素格子组成的，对于一个图片，电脑是怎么知道应该把它搞到哪几个像素上去显示的呢？这就是光栅化。说白了就是，把想看见的图片，搞成像素能显示的。光栅化工作告诉了显卡，哪个格子是你这个图元应该画上的哪个不是。&lt;/p&gt;

&lt;p&gt;传递过来的图元数据，在此将会被分解成更小的单元并对应帧缓冲区的各个像素，这些单元被称之为片元。一个片元可能包含窗口大小，深度，颜色，纹理坐标等属性。&lt;/p&gt;

&lt;p&gt;片元的属性是图元上顶点数据等经过插值而确定的，比如颜色，深度等。&lt;/p&gt;

&lt;p&gt;顶点属性的插值计算，在输入集合阶段用户指定的一系列的多边形，以三角形为例，每个三角形由三个顶点组成，每个顶点包含一系列的属性，如坐标，法线，纹理坐标等等，在经过顶点着色阶段，视口变换后，这个顶点在屏幕上都有对应的坐标。但为了显示该三角形，仅仅三个顶点显然是不够的，为了计算该三角形所覆盖的屏幕上每个像素的属性，要进行正确的插值计算，计算结果填充到片元中去。&lt;/p&gt;

&lt;h6&gt;阶段6，片元处理&lt;/h6&gt;

&lt;p&gt;这个阶段首先对片元上纹理，通过纹理坐标取得纹理内存中相对应的颜色。&lt;/p&gt;

&lt;p&gt;再进行雾化，通过片元与当前视点位置的距离修改颜色。&lt;/p&gt;

&lt;p&gt;最后颜色汇总，将纹理,主定义的颜色,雾化的颜色,次颜色光照阶段计算的颜色汇总一起。&lt;/p&gt;

&lt;p&gt;这个阶段就是vertex fragment着色器编程中 fragment 片元转换函数的处理阶段，fragment 片元函数通过这个阶段的编程对片元进行修改。&lt;/p&gt;

&lt;h6&gt;阶段7，像素操作（Pixel Operation）&lt;/h6&gt;

&lt;p&gt;所有的片元的测试都在这里进行，包括：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    像素所有权测试 -&amp;gt; 裁剪测试 -&amp;gt; alpha测试 -&amp;gt; 模板测试 -&amp;gt; 深度测试 -&amp;gt; 混合 -&amp;gt; 抖动显示 -&amp;gt; 逻辑操作
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;阶段8，帧缓冲区（Frame Buffer）&lt;/h6&gt;

&lt;p&gt;执行帧缓冲的写入等操作，写入帧缓冲区，等待最后产生了显示出来的像素。&lt;/p&gt;

&lt;p&gt;渲染管线的整个过程如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader11.png&quot; alt=&quot;render pipe&quot;&gt;&lt;/p&gt;

&lt;p&gt;上图中 vertex框就是可编程部分的 vertex 函数，它可以修改顶点部分的数据来表现个性化的效果，fragment框也是一样，是 fragment 函数的调用点，修改通过这个fragment函数可以修改片元数据达到需要的效果。&lt;/p&gt;

&lt;p&gt;Unity3D在渲染管线各阶段中所用到的功能，和我们前面所描述的阶段有很相似的地方，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader12.png&quot; alt=&quot;render pipe&quot;&gt;&lt;/p&gt;

&lt;p&gt;上图所要表达的功能和阶段，正是我们要在Shader章节中讲解和说明的部分。&lt;/p&gt;

&lt;p&gt;参考资料&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1，渲染管线流程 作者：不详

    2，【图形学】渲染管道 作者：阵雷
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
               <pubDate>Wed, 08 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/08/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader3.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/08/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader3.html</guid>
            </item>
        
    </channel>
</rss>