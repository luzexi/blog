<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title></title>
        <description>技术，哲学，金融</description>
        <link>http://www.luzexi.com</link>
        <atom:link href="http://www.luzexi.com/assets/feed.xml" rel="self" type="application/rss+xml" />
        
            <item>
               <title>思路探讨(五十八) 学习目标管理的第二周</title>
               <description>&lt;p&gt;说到上周，给自己定的目标比较满，自己比较焦虑，当时写下思路探讨57后，发现最后竟然在自己的奋力拼搏之下在周日的最后一刻完成了。&lt;/p&gt;

&lt;p&gt;虽然完成了，喜悦感和成就感，仍然很少，因为太满太重，让自己很焦虑，做事很急躁，即使完成了也觉得太辛苦了，不想再来第二次。&lt;/p&gt;

&lt;p&gt;这周又继续犯了同样的毛病，，给自己定的目标仍然太高，但心态稳了，由于这周紧急事情比较多，大部分时间都花费在了工作上，留给自己的时间很少。但我仍然挤出了不少时间来完成目标，可惜最后仍然还有一项完全没时间去做。&lt;/p&gt;

&lt;p&gt;我原谅了我自己，我跟我自己说，事情一直在变，没有按计划走很正常，以后我要考虑的更周到一些，于是默默的将这项目标移到了下周。&lt;/p&gt;

&lt;h3 id=&quot;没有按计划走很正常生活和工作中失败也很正常我一生都充斥着失败我曾一度认为自己会成为那个游走在社会边缘的人成为一个寄生虫最后还不是挺过来了&quot;&gt;没有按计划走很正常，生活和工作中失败也很正常，我一生都充斥着失败，我曾一度认为自己会成为那个游走在社会边缘的人成为一个寄生虫，最后还不是挺过来了。&lt;/h3&gt;

&lt;h3 id=&quot;失败是人生旅途中的很关键的要素它激发我的反思敲醒了我的斗志让我从迷糊和沉睡中醒来进而让我从困惑中走出来所以没有必要太在意反而要感谢它它抹去了那层虚伪的窗户纸让我们知道我们自己现在的真实状况&quot;&gt;失败是人生旅途中的很关键的要素，它激发我的反思，敲醒了我的斗志，让我从迷糊和沉睡中醒来，进而让我从困惑中走出来。所以没有必要太在意，反而要感谢它，它抹去了那层虚伪的窗户纸，让我们知道我们自己现在的真实状况。&lt;/h3&gt;

&lt;h3 id=&quot;当你遇到失败时你应该这么想所有杀不死你的终将使你强大只要秉持这个理念你就能从失败走向成功从黑暗走向光明&quot;&gt;当你遇到失败时，你应该这么想，所有杀不死你的终将使你强大。只要秉持这个理念，你就能从失败走向成功，从黑暗走向光明。&lt;/h3&gt;

&lt;p&gt;其实这周我完成了很多事情，目标清单上的内容，我很有把握努力一下能完成它们，虽然最后还是有一项没完成，但我没有沮丧，也没有焦虑，从这个现象上看，我进步了，我对目标的本身，以及对制定目标的意义有了更深层次的理解，同时我认为我对制定目标的尺度在越来越靠谱了。&lt;/p&gt;

&lt;h3 id=&quot;前面一直都在说我给自己制定周目标但其实周目标的大方向要用月目标来配合月目标要用年目标来配合这样才能真正发现自己每周做的事情都是有意义的而1年目标要用5年目标来指引方向5年目标要用10年目标来指引方向10年目标要用生命的目标来指引方向&quot;&gt;前面一直都在说我给自己制定周目标，但其实周目标的大方向要用月目标来配合，月目标要用年目标来配合，这样才能真正发现自己每周做的事情都是有意义的，而1年目标要用5年目标来指引方向，5年目标要用10年目标来指引方向，10年目标要用生命的目标来指引方向。&lt;/h3&gt;

&lt;h3 id=&quot;只有这样一环扣一环拆分到每周的目标才会更加清晰信心也能得到更加多的支撑知道自己要什么该怎么做&quot;&gt;只有这样一环扣一环，拆分到每周的目标才会更加清晰，信心也能得到更加多的支撑，知道自己要什么，该怎么做。&lt;/h3&gt;

&lt;h3 id=&quot;当你知道自己要什么该怎么做时具体执行时如果能多坚持几周每周都能完成自己拆分后的目标我猜你很快就能体会到什么叫信心爆棚动力十足思路广阔&quot;&gt;当你知道自己要什么，该怎么做时，具体执行时如果能多坚持几周，每周都能完成自己拆分后的目标，我猜你很快就能体会到什么叫信心爆棚、动力十足、思路广阔。&lt;/h3&gt;

&lt;p&gt;很多人害怕目标，一看到目标就吓坏了。其实目标没有这么可怕，就像我今天跟媳妇提出要买别墅这个目标时那样，媳妇连想都没想过，分析都没分析过就吓坏了，直接反击到“不可能”。&lt;/p&gt;

&lt;p&gt;其实这个目标有很多条道路通向它，比如选择3、4、5线城市的别墅，别墅本身就没有那么多聚集属性，本身就是要远离城市的喧嚣，是一个要让自己更加独立和自律的地方，假如我们没有那么多现金可以抵押现有的房子拿现金付首付，也可以向亲戚朋友借点钱，或者把房子卖了去3、4线，或者把现有的房子拆分成两半，一半付别墅首付，一半付更小套的首付，装修自己来，自己一天天蚂蚁搬砖自己DIY。如果仅仅是为了住别墅，其实方法有很多种，条条道路通罗马，把所有选项整理一下，找出适合自己的，目标就变的没那么可怕了。&lt;/p&gt;

&lt;p&gt;哈哈哈哈我脑洞挺大的，说实话，这个脑洞还真的可行。&lt;/p&gt;

&lt;p&gt;以前我时常问自己，我究竟要的是什么，
后来改成了，我想成为什么样的人，
现在又改成了，我想让后人如何评价我，
每一层思想的蜕变都有不一样的风景。
每每遇到问题，都要以这个为前提去思考。&lt;/p&gt;

&lt;p&gt;希望我的学习分享，能给大家一些启示。&lt;/p&gt;
</description>
               <pubDate>Mon, 08 Mar 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/03/08/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A858</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/03/08/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A858</guid>
            </item>
        
            <item>
               <title>思路探讨(五十七) 目标管理学习的第一周</title>
               <description>&lt;p&gt;目标管理这个词已经听过很多次了，以前一直对它有点排斥，以为是陈词滥调，因此也一直没有去研究。&lt;/p&gt;

&lt;p&gt;但就在最近发现自己对目标管理这个东西越来越感兴趣了，越来越对目标这个事感兴趣，于是找了网上的学习资料学习了一下‘目标管理’，并在我生活中实践一下。&lt;/p&gt;

&lt;p&gt;其实这也符合我近些年一直练习的精力管理和时间管理，也让我回忆起，去年看过的一本书《精英们的清晨日课》，里面的一些话让我感同身受，后续再回顾总结一下这本书。&lt;/p&gt;

&lt;p&gt;这里简单介绍下目标在制定时必须遵守的原则。&lt;/p&gt;

&lt;p&gt;首先目标必须与我们的核心价值观一致，核心价值观就是我们自己认为我这一生想成为什么样的人，自律、智慧、真诚、可靠、进取、友爱、合作、魅力、独立、冒险、安全等等。&lt;/p&gt;

&lt;p&gt;其次我们的目标必须遵循3个准则：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	1. 目标必须遵循 SMART原则，即具体的、可测量的、可达到的、和其他目标相关联的、有时间限制的。
	2. 目标必须在人生的各领域平衡，包括，事业、家庭、健康、关系、财务、精神生活等人生各领域，一个不能少。
	3. 目标必须是有挑战性的，并且不能是够不到的，也不能是轻松就能办到的，必须我们使劲用力跳一下能够到的目标。
		有挑战性目标，会给你带来突破限制的想象力和创造力，让你看到自己都没发现的潜力。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等等等….其实里面有很多内容和原理，待我日后一一跟大家详述。&lt;/p&gt;

&lt;p&gt;很不幸目标管理学习第一周，由于自己制定的目标太大，导致挫败感很强烈。&lt;/p&gt;

&lt;p&gt;在此我对这次失败的目标管理总结一下。&lt;/p&gt;

&lt;h3 id=&quot;第一这周我给自己设定了一个周目标可以我设定了很多的目标把自己的目标排的很满&quot;&gt;第一，这周我给自己设定了一个周目标，可以我设定了很多的目标，把自己的目标排的很满。&lt;/h3&gt;

&lt;p&gt;这周前3天动力很足但后几天就嫣了，因为前3天太用力了差点累垮了自己，虽然我做了很多事情，完成了比较重的任务，但没有感觉到成就感，相反挫败感却油然而生。&lt;/p&gt;

&lt;p&gt;这是因为自己给自己制定的目标太多，即使我花了大力气也没能完成，自己却发现用力过猛有点不适应。当我发现无法完成所有任务时，情绪就会低落，精神状态就会萎靡，接下来就越来越糟糕。&lt;/p&gt;

&lt;h3 id=&quot;第二我在制定目标时并没有思考它是否符合我的核心价值观而是一味的觉得自己想达成这些目标&quot;&gt;第二，我在制定目标时并没有思考，它是否符合我的核心价值观，而是一味的觉得自己想达成这些目标。&lt;/h3&gt;

&lt;p&gt;没有核心价值观的支撑，目标在执行时，显得很脆弱，一旦遇到不顺心的事，就没有底层原动力去支撑继续前进。&lt;/p&gt;

&lt;p&gt;目标必须符合我的核心价值观，我的核心价值观是，自律，智慧，团队合作，进取。当然核心价值观随着年龄的增大会有所不同，我也不断在审视自己的核心价值观。&lt;/p&gt;

&lt;h3 id=&quot;第三我的目标并没有平衡我的生活只是一味的在某个方向上尝试突破&quot;&gt;第三，我的目标并没有平衡我的生活，只是一味的在某个方向上尝试突破。&lt;/h3&gt;

&lt;p&gt;在制定目标前，我并没有审视自己在人生各领域的进展，而一味的选择自己认为现在重要的方向去突破。&lt;/p&gt;

&lt;p&gt;这让我的工作和生活，在原来的基础上更加偏离轨道，向着一个更极端的方向驶去。也同时导致了我对世界和周围事物的理解更加偏执。&lt;/p&gt;

&lt;h3 id=&quot;总的来说我并没有仔细认真的对待目标管理的每个细节而是粗糙的将它理解为定目标执行目标完成目标的简单过程导致目标执行时很痛苦最终也难以完成的结果&quot;&gt;总的来说，我并没有仔细认真的对待目标管理的每个细节，而是粗糙的将它理解为，定目标，执行目标，完成目标的简单过程，导致目标执行时很痛苦，最终也难以完成的结果。&lt;/h3&gt;

&lt;p&gt;没关系，这只是第一周的学习，失败也是常有的，失败给我警示，总结复盘带给我进步。后面我会，调整目标，改善行动策略，设定奖励，写计划，拆分目标等等，待我下回一一跟大家分享我学习的过程。&lt;/p&gt;

&lt;p&gt;也为了更加完善我的目标管理练习，接下去我也会加入目标执行的统计日志，记录每次执行目标时的原因、行动、结果，用数据统计和数据分析的方式来改善我执行目标的方式。&lt;/p&gt;

&lt;h3 id=&quot;仍然在学习中希望我的分享能给大家一些启示&quot;&gt;仍然在学习中，希望我的分享能给大家一些启示。&lt;/h3&gt;
</description>
               <pubDate>Sun, 28 Feb 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/02/28/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A857</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/02/28/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A857</guid>
            </item>
        
            <item>
               <title>读书笔记(十九) 《十分钟冥想》</title>
               <description>&lt;h2 id=&quot;背景&quot;&gt;背景：&lt;/h2&gt;

&lt;p&gt;买此书《十分钟冥想》时，是在一个比较特殊的时期，自己的精神状态比较混乱，恰好在某本书中看到推荐此书的评语。
抱着好奇心和神秘感读了此书，刚读前几章就深深体会到此书的精妙。&lt;/p&gt;

&lt;p&gt;于是在后面的几个月中，我逐步践行了书中所描述的冥想技巧，着实很受益，让自己在这个繁杂的社会中获得了一片小小的宁静。&lt;/p&gt;

&lt;h2 id=&quot;疑问&quot;&gt;疑问：&lt;/h2&gt;

&lt;p&gt;整本书大约有25万字，读完并践行后，我把整个过程分为四个部分：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	1. 第一部分，告诉你什么是冥想？为什么要冥想？
	2. 第二部分，告诉你如何去冥想？
	3. 第三部分，告诉你如何将冥想融入生活？
	4. 第四部分，我的冥想体验记录，增进你对冥想的了解
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;结论&quot;&gt;结论：&lt;/h2&gt;

&lt;p&gt;书对我的帮助很大，可以认为这是一本能教会你如何排除外界干扰的书，如果你肯坚定的去练习冥想的话，一切事情都会越来越专注。&lt;/p&gt;

&lt;p&gt;我也从冥想中学习到了如何保持专注，以及如何在平常事物中发现新的趣味（书中称觉醒），同时自己也日复一日的不断练习，希望自己能有一天在杂乱或危机的环境中仍然能保持定力，也希望自己能在发现事物的更多面。&lt;/p&gt;

&lt;p&gt;不只是学习，冥想从此成为了我排除干扰，练习专注的一个方法，我把它当作我日常生活中的一部分，借助它来缓解我的紧张、焦虑和急躁的性格，同时也借助它来帮助我练习心流体验（《心流》一书中所描绘的专注）。
关于心流体验，我将在另一个篇文章中写关于我看了《心流》这本书后，在自己工作、学习、生活中是如何去实践，书中所描绘的心流，如何去整理内心秩序，让自己更加专注于当下的事物，挖掘更多当下事物的乐趣。&lt;/p&gt;

&lt;h2 id=&quot;内容&quot;&gt;内容：&lt;/h2&gt;

&lt;h2 id=&quot;点击查看内容&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/x3_Xq7-lUh8D2BCf0i9C1Q&quot;&gt;点击查看内容&lt;/a&gt;&lt;/h2&gt;

</description>
               <pubDate>Sun, 21 Feb 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/02/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B019</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/02/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B019</guid>
            </item>
        
            <item>
               <title>思路探讨(五十六) 自信的支撑点</title>
               <description>&lt;p&gt;这篇聊聊自信的支撑点。&lt;/p&gt;

&lt;p&gt;事情的缘由是，最近看到很多人都会因为xxx而感到自豪。&lt;/p&gt;

&lt;p&gt;这个xxx指某件事，或某个能力，或某个项目，或某个企业。&lt;/p&gt;

&lt;p&gt;于是想到了自己是否会因为某个东西而感到自豪，想了想，我可能会因为自己看了很多书而感到自豪，也可能会因为自己坚持健身很多年而感到自豪，会因为自己在腾讯感到自豪，会因为自己写了很多文章感到自豪。&lt;/p&gt;

&lt;p&gt;每个人都有自信的支撑点，有些人会因为自己有钱而感到自信，有些人则会因为自己有学识而感到自信，有些人则是强壮的身体，有些人则是美貌，有些人则是说话表达技巧。&lt;/p&gt;

&lt;p&gt;除了自身的因素外，他人也会成为支撑自己信心的点，比如有亲人中的某位有权有势的人会支撑我们的自信，也有可能是工作在世界500强的这个企业支撑我们的自信，也有可能是自己的老师或朋友中有才或者有名支撑我们的自信。&lt;/p&gt;

&lt;p&gt;无论如何，自己身上的自信支撑点，比依赖他人的支撑点更加牢固。对自己有信心比对别人有信心更重要。因为他人因素是不由我们控制，我们所依赖的某亲戚、某公司、某朋友、某个政策，发生变化时，我们就会失去依赖或支撑。&lt;/p&gt;

&lt;p&gt;而自身因素上，钱、设备工具、荣誉名声、美貌，又是自身因素中的外在因素，它会随着时间的流逝而不断变化，虽然有些可控性，但不足以完全掌控。&lt;/p&gt;

&lt;p&gt;而自身内在因素，学识、身体、思维方式和习惯，则可以被我们完全掌控，并且随着日积月累，越来越多，越来越强。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;当然我们不能只关注内在因素，外在因素也是需要我们关注和维护的内容，只是没有内在因素那么重要，但也不可忽视。&lt;/p&gt;

&lt;p&gt;正好我半年前看过一本书《自信的力量》，他讲的很不错。&lt;/p&gt;

&lt;p&gt;他说，一个人的自信，首先是由自己与周围环境的和谐程度决定的，再由自己与周围朋友合作默契程度决定，其次和自己的高深的学识、强壮的身体息息相关，最后才和金钱、公司、职位挂钩。&lt;/p&gt;

&lt;p&gt;想来确实如此，自信心本就是他人给予的，它与周围的人和事息息相关，由自身素质从内而外散发出来，最后由其他外在因素景上添花。&lt;/p&gt;

</description>
               <pubDate>Wed, 17 Feb 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/02/17/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A856</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/02/17/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A856</guid>
            </item>
        
            <item>
               <title>改造jekyll 为iframe框架的博客内容</title>
               <description>
&lt;div class=&quot;static_post&quot;&gt;
&lt;iframe src=&quot;/static-page/post-2021-02-10/改造jekyll 为iframe框架的博客内容.html&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt; &lt;/iframe&gt;
&lt;/div&gt;

</description>
               <pubDate>Wed, 10 Feb 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/02/10/%E6%94%B9%E9%80%A0jekyll%E4%B8%BAiframe%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/02/10/%E6%94%B9%E9%80%A0jekyll%E4%B8%BAiframe%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9</guid>
            </item>
        
            <item>
               <title>思路探讨(五十五) 第一性原理</title>
               <description>&lt;p&gt;最近越来越经常写文章但很少发出来（基本都是每周一篇总结 + 每日一篇自我反省的文章），没能分享到博客的原因第一是写的文章有些是属于公司保密级的，不能发布在博客上，甚至有几篇文章完全不能脱敏。第二是自己写的向内看系列的内容，真的越来越向内看越来越私密，由于太私密触及内心的兴奋与失落，起伏过大所以也不好拿出来跟大家分享。&lt;/p&gt;

&lt;p&gt;​在公众号中，我秉持着开放的态度与自己对话，也常与朋友和同事们聊聊自己的想法。
希望能从不同的角度来看待事物，也希望能从各个方向上来改善自己做人做事的态度。&lt;/p&gt;

&lt;p&gt;由于年底事情特别多，也特别繁杂，因此只能将有限的精力用在照顾自己的工作和学习进度。在此跟大家说声抱歉。
2021年会继续跟大家分享我的所思所想，以及公开自己的所学所为。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;前面听过第一性原理的概念，但没有了解的很清楚，在放假回老家最后一天突然兴致勃勃的看了，张善友教授讲的第一性原理的视频。&lt;/p&gt;

&lt;p&gt;感觉讲的很不错，也契合我一直以来秉持的理念，在听了他所讲的内容后，对这块理念更加深刻。&lt;/p&gt;

&lt;p&gt;什么是第一性原理？
第一性原理，事物背后的不变的理念(原理)，根据这个原理可以推出所有的其他东西出来。这个理念就叫第一性原理。&lt;/p&gt;

&lt;p&gt;第一性原理是事物的本质、本性，是事物背后支配性的理念，而不是现象层面流变的物质。一旦在逻辑上导通一个共同的抽象概念，与此相关的所有具象问题，立即全部化解。&lt;/p&gt;

&lt;p&gt;随着我们年龄增大，接触的事情越来越复杂，处理这件复杂的事物需要花费的精力也通常越来越复杂。
第一性原理告诉我们，越高深的事物，底层理念越简约，其原理通常具有简一性，即简约和单纯。
找到第一性原理，就像是找到了支配事物运动的发动机。&lt;/p&gt;

&lt;p&gt;计算机程序执行原理、操作系统内核原理，对于每个编程的人来说都是第一性原理。为技术人拓展更扎实的编程思路提供了底层支撑。
抽象能力是软件架构设计的第一性原理。为技术人拓展更简洁实用的架构能力提供了底层支撑。
尊严与诚信是人在社会生存是第一性原理。为社会人拓展生活和工作中的方方面面提供了支撑。
能量守恒是宇宙的第一性原理。为物理、化学的研究工作提供了支撑。等等等&lt;/p&gt;

&lt;p&gt;人们常说，道理说的很好，但听过就忘了。显然大多数人都没有将人生的底层原理铭刻在心中，时刻忘记遵守事物的本质规律，也时常不得不在所谓的现实面前妥协。&lt;/p&gt;

&lt;p&gt;你找到生活中的真正的第一性原理了吗？
当第一性原理（事物的本质）和现象冲突的时候，你选择了什么？&lt;/p&gt;

&lt;p&gt;每个你的选择都决定了你今后的道路，你是坚持本质还是妥协现象，N个选择积累后，最终成为了今天的你。&lt;/p&gt;

&lt;p&gt;当然我们也需要注意下，第一性原理不是绝对真理，虽然事物的本质和原理适用于每个人，但对于每个人来说都需要有不同方式去执行。​&lt;/p&gt;

</description>
               <pubDate>Tue, 09 Feb 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/02/09/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A855</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/02/09/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A855</guid>
            </item>
        
            <item>
               <title>向内看自己(十二) 精力训练</title>
               <description>&lt;p&gt;健身一整年的体会与变化，精力训练的一整年。&lt;/p&gt;

&lt;p&gt;体会 + 对策 + 图 + 视频&lt;/p&gt;

&lt;h2 id=&quot;点击查看内容&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/PkEWsEOxpRmdIm8AdV2OPA&quot;&gt;点击查看内容&lt;/a&gt;&lt;/h2&gt;

</description>
               <pubDate>Sun, 24 Jan 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/01/24/%E5%90%91%E5%86%85%E7%9C%8B%E8%87%AA%E5%B7%B112</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/01/24/%E5%90%91%E5%86%85%E7%9C%8B%E8%87%AA%E5%B7%B112</guid>
            </item>
        
            <item>
               <title>向内看自己(十一) 底层能力和核心</title>
               <description>&lt;p&gt;最近一直在学习技术，由于几篇文章是跟项目有关的所以得脱敏后才能发。由于技术聊的太多，感觉自己脑袋闭塞了，这篇我想聊聊别的，可能有点乱。&lt;/p&gt;

&lt;p&gt;最近有点苦闷。&lt;/p&gt;

&lt;p&gt;又到了，阶段性怀疑人生的时刻。&lt;/p&gt;

&lt;p&gt;工作上的、生活上的、学习上的都有一些。&lt;/p&gt;

&lt;p&gt;最近接触了些自己以前没有接触过的东西，包括，冥想，专注练习，分析和整理的方法，这些可以说是以前没有在意的东西。&lt;/p&gt;

&lt;p&gt;在我看了《十分钟冥想》、《心流》、《金字塔原理》这三本书后，发现书中的这些方法在我们生活中特别重要。&lt;/p&gt;

&lt;p&gt;于是我开始学习冥想、学习如何保持专注、学习整理和分析知识和经验的方法，但收效甚微。&lt;/p&gt;

&lt;p&gt;由于开始注重自己的心境、自己的专注力、自己的分析方法，发现自己在这方面能力值好低，瓶颈好大，思路狭窄。&lt;/p&gt;

&lt;p&gt;以前并没有这么觉得，因为我没有注重这些技巧的运用，都是猛打猛冲的在向前进发。&lt;/p&gt;

&lt;p&gt;看了大师们的解说，再自己去试行，才发现好难。&lt;/p&gt;

&lt;p&gt;所以挫败感很强烈。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;做这些目的是想把自己的底层能力巩固一下，没想到的是原来自己的底层能力这么差。&lt;/p&gt;

&lt;p&gt;为什么要去打造底层能力这个问题，也是我从健身中感悟到。&lt;/p&gt;

&lt;p&gt;在一开始健身的时候，会无脑的去跑步、去跳操，一段时间后接触了固定器械健身，以及固定肌肉部位的健身，觉得这样的效率会更高，于是开始了固定肌肉和器械的健身方式，过了一段时间，但这导致了我的核心没有被训练到，肌肉是上来了，但核心没有变强，腿部、腹部、身体的整个平衡能力，耐力，都没有变强。&lt;/p&gt;

&lt;p&gt;只是改善了外观，增加了肌肉，降低了体脂，但核心体魄上完全没有变化，甚至变的更弱了。&lt;/p&gt;

&lt;p&gt;没有抓住核心导致我虽然外观改善了，但内在却没有改善。&lt;/p&gt;

&lt;p&gt;这也是我为什么要执著于打造底层能力的原因。&lt;/p&gt;

&lt;p&gt;万事万物都要是一个道理，万事万物都要是一个道理，要抓住核心。&lt;/p&gt;

&lt;p&gt;写程序、做游戏的道理也是一样，做游戏要先做核心战斗，有了核心战斗，周边的功能开发才有意义。
写程序也是一个道理，理解底层原理，熟悉底层机制，去实践底层逻辑，核心的组件做出来，围绕核心做业务才会更稳，否则就像豆腐渣工程很容易倒塌，底层不牢固。（其实每个模块有核心，先做核心，再做周边是比较好的顺序）&lt;/p&gt;

&lt;p&gt;延展到生活中也是如此，核心我认为除了工作外的生活中核心是家庭，我们应该把重心放在家庭上，而家庭中，成员之间的的默契程度是核心，因此我们要团结友爱，互帮互助，分工合作来努力让这个核心更加稳固。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;这个世界证明了未来总是不可预测的，历史总是固定并有理有据的。&lt;/p&gt;

&lt;p&gt;我们常去预测未来，认为根据历史经验就能知道未来，认为至少知道个大概。&lt;/p&gt;

&lt;p&gt;不要去预测未来，我们大部分人都不肯接受不确定性，有些人希望能控制未来，那更是不可能。&lt;/p&gt;

&lt;p&gt;我们能做只能是尝试去稳定未来的发展方向，至于未来到底会发生什么，我们完全控制不了。&lt;/p&gt;

&lt;p&gt;我们能控制的只有自己，做好自己该做的事情，不断完善自己，完善底层能力，再在自己能力范围内尽可能照顾好周围的人。&lt;/p&gt;

&lt;p&gt;至于那些我们不能控制的未来，永远都会让我们焦虑，并借此扰乱我们的心智。&lt;/p&gt;
</description>
               <pubDate>Sat, 23 Jan 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/01/23/%E5%90%91%E5%86%85%E7%9C%8B%E8%87%AA%E5%B7%B111</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/01/23/%E5%90%91%E5%86%85%E7%9C%8B%E8%87%AA%E5%B7%B111</guid>
            </item>
        
            <item>
               <title>Perfetto内存工具分析</title>
               <description>&lt;p&gt;用Markdown在贴图方面不是很方便，于是用印象笔记写了篇文章，尝试一下新的方式。&lt;/p&gt;

&lt;p&gt;我越来越觉得图对理解的重要性，所以想把更多文字转为以图文结合的方式表达，这样会更加清晰一些，也更易于理解。&lt;/p&gt;

&lt;p&gt;后面会更多的尝试用这样方式来写文章，即，用印象笔记写完后，导出html放在博客上。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/static-page/Perfetto/Index/Perfetto内存工具分析.html&quot;&gt;点击查看文章内容&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;static_post&quot;&gt;
&lt;iframe src=&quot;/static-page/Perfetto/Index/Perfetto内存工具分析.html&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt; &lt;/iframe&gt;
&lt;/div&gt;

</description>
               <pubDate>Wed, 20 Jan 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/01/20/Perfetto%E5%86%85%E5%AD%98%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/01/20/Perfetto%E5%86%85%E5%AD%98%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90</guid>
            </item>
        
            <item>
               <title>读书笔记(十八) 《C++性能优化指南》三</title>
               <description>&lt;p&gt;此篇主要介绍热点代码、I/O、以及并行部分的优化，我们会从原理出发来，再根据原理讲优化，这样即学习了原理，又知道了优化的来龙去脉。&lt;/p&gt;

&lt;h2 id=&quot;热点代码&quot;&gt;热点代码&lt;/h2&gt;

&lt;p&gt;这里作者带我们聊一聊关于代码细节的优化，虽然语句的细节优化并不能带来非常明显的提升，但是也是非常有必要的优化步骤，尤其在那些追求极致高性能或精小的组件中，代码细节的优化决定了组件与组件之间的差异。&lt;/p&gt;

&lt;p&gt;语句细节的优化，其实质是对CPU指令的优化，可以认为是从执行指令流中移除指令的过程。下面先来阐述一下细节优化的原理。&lt;/p&gt;

&lt;h3 id=&quot;语句的细节优化其实质是执行指令数量的优化指令跳转次数的优化向栈中保存临时寄存器次数的优化以及内存分配次数的优化&quot;&gt;语句的细节优化，其实质是执行指令数量的优化，指令跳转次数的优化，向栈中保存临时寄存器次数的优化，以及内存分配次数的优化。&lt;/h3&gt;

&lt;p&gt;执行指令数量减少了可以减少CPU在执行程序时的耗时我们很好理解，指令跳转则是因为指令也是被放在内存中的数据，因此它也会被高速缓存cache，长距离跳转会让高速缓存失效，静态函数调用和非成员函数调用通常都是长距离指令跳转的典型案例。&lt;/p&gt;

&lt;p&gt;函数调用开销不可忽视，即使一个空函数，在调用时也会有性能开销（编译器可能会帮我们优化掉空函数），有时为了极致的优化，我们应该最大限度的减少调用函数的频率，特别是频率最高的top3。&lt;/p&gt;

&lt;p&gt;因为在函数被调用时会保存当前函数的数据，包括参数、局部变量、当前指令地址、临时寄存器和标记寄存器等，每次调用一个函数会做如下处理：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	1.当调用函数时，先保存当前函数的临时变量、参数、临时寄存器、标记寄存器。
	
	2.将这些每个要保存的数据都复制到栈中。
	
	3.当前执行的地址复制到栈中。

	4.将指令指针寄存器IP指向要执行的函数体的第一句

	5.执行函数体中的指令

	6.将函数调用结果保存到寄存器

	7.从栈中推出要返回的地址，并复制给指令寄存器IP

	8.推出栈中的临时寄存器、参数、局部变量、标记寄存器都重新还原回去

	9.继续执行剩下的指令直到遇到下一个函数。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果遇到成员函数是虚函数的，还得先从虚表中偏移并取出函数地址再调用，这里又多了2次计算，即先取出虚表地址、再根据虚表地址偏移获得真正的函数地址、最后再才能跳转过去。如果是多重继承、或者是多重继承的继承类中的虚函数成员，则需要再加一次地址偏移计算。&lt;/p&gt;

&lt;p&gt;inline内联是减少函数调用的最佳方式，内联函数并不像一般函数那样会保存数据并且跳转指令，因为编译器会就地展开内联函数中的指令，因此没有推栈入栈保存数据到栈和跳转指令到函数再返回的步骤，取而代之的是就地直接执行指令。&lt;/p&gt;

&lt;p&gt;这样看来减少函数调用(或让函数内联)的同时也减少了入栈、出栈、复制数据的指令数量，也减少了指令跳转的丢失高速缓存的概率。&lt;/p&gt;

&lt;p&gt;不必要的内存分配也是在代码细节中常犯的错误，尤其指向堆内存分配，当函数中需要某个容器或者类实例时，常会临时向堆内存申请一次以用来计算。&lt;/p&gt;

&lt;p&gt;我们来看看以上这说的7个细节的具体例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;
for(int i = 0 ; i&amp;lt;strlen(str) ; i++)
	...

//改为

for(int i = 0, n = strlen(str) ; i&amp;lt;n ; i++)
	...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.将重复计算提到前面，但这里不一定有优化，因为编译器可能会识别这类循环并将实时计算移出去，不过不能保证编译器一定会这么干，所以我们最好做人为的优化，保证不重复计算。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;
void function()
{
	list = new list();
	for(int i = 0 ; i&amp;lt;n ; i++)
	{
		list.Add(xx);
	}

	return;
}

//改为

public static list = new list(); //改为全局变量

void function()
{
	list.Clear();
	for(int i = 0 ; i&amp;lt;n ; i++)
	{
		list.Add(xx);
	}

	return;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.函数中临时的堆内存分配，改为全局的共用内存，只要分配一次，每次使用前先清理就能节省开销。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;
int k = 0;
for(int i = 0 ; i&amp;lt;100 ; i++)
{
	int j = sin(100) + cos(50);
	k = j*i;
}

//改为

int k = 0;
int j = sin(100) + cos(5);
for(int i = 0 ; i&amp;lt;100 ; i++)
{
	k = j*i;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.移除循环中不变的计算，减少不必要的指令，可能会被编译器优化掉。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;for(int i = 0 ; i&amp;lt;10 ; i++)
{
	int b = Add(3,5);
	...
}

//改为

int b = 0
for(int i = 0 ; i&amp;lt;10 ; i++)
{
	b = 3 + 5;
	...
}

//或者将Add函数内联

inline int Add(a,b)
{
	...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.用内联或者手动内联的方式，减少循环中的函数调用开销。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;
string str = &quot;a&quot;;

str = &quot;&amp;lt;p&amp;gt;&quot; + str + &quot;&amp;lt;/p&amp;gt;&quot;;

//改为

str = string.format(&quot;&amp;lt;p&amp;gt;{0}&amp;lt;/p&amp;gt;&quot;,str);

//或者

str = StringCacheMgr.instance.Format(&quot;&amp;lt;p&amp;gt;{0}&amp;lt;/p&amp;gt;&quot;,str);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.减少字符串内存分配次数，将原来要分配两次的字符串，改为只要分配1次。或者使用自制的字符串内存管理方式管理分配和操作字符串(前面的内存优化那一节我们讲过这种方式)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;
for(int i = 0 ; i&amp;lt;1000 ; i++)
{
	test();
}

//改为

test();

void test()
{
	for(int i = 0 ; i&amp;lt;1000 ;i++)
	{
		...
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.将1000次调用函数的开销改为1次，节省函数调用的开销。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;
if(x == a)
{
	...
}
else if(xx == a)
{
	...
}
else if(xxx == a)
{
	...
}
else ...

//改为

switch(a)
{
	case x:
		break;
	case xx:
		break;
	case xxx:
		break;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.通常switch都会被编译器优化为索引的方式去跳转，因此用switch比if效率高的多，也不用我们自己对数据排序。&lt;/p&gt;

&lt;p&gt;最后说下异常try catch的开销，在早期C++的try catch机制会在栈帧上包含一个异常上下文，这些上下文会随着异常抛出或者作用范围结束而销毁，增加性能开销。现在则不同了，上下文开销都没有了，只是会在开始try时多几个指令更改中断程序的指向，退出时再改回来，但是即使这样，我们也不能有太多try catch，因为try catch太多仍然会多出很多额外的指令消耗。&lt;/p&gt;

&lt;h3 id=&quot;我们做个小结我们说语句的细节优化实质是减少执行指令数量减少指令跳转次数减少函数调用以及减少内存分配次数我们用代码细节来解释有哪些细节是可以遵从我们的原理来优化的这些细节的优化在性能要求比较高的组件上会比较有用好的代码细节是业务逻辑优化的前提业务逻辑上当我们更多运用的是调整实现方式调整数据结构的方式调整业务逻辑策略的方式时这些细节的优化则成了底层的支柱&quot;&gt;我们做个小结，我们说语句的细节优化，实质是减少执行指令数量，减少指令跳转次数，减少函数调用，以及减少内存分配次数。我们用代码细节来解释有哪些细节是可以遵从我们的原理来优化的，这些细节的优化，在性能要求比较高的组件上会比较有用，好的代码细节是业务逻辑优化的前提。业务逻辑上，当我们更多运用的是调整实现方式，调整数据结构的方式，调整业务逻辑策略的方式时，这些细节的优化则成了底层的支柱。&lt;/h3&gt;

&lt;h2 id=&quot;io-文件操作&quot;&gt;I/O 文件操作&lt;/h2&gt;

&lt;h3 id=&quot;io操作的优化空间相对比较小是因为它主要的工作大部分由操作系统完成因此我们先介绍下操作系统中io的读写原理再从原理出发优化io操作效率包括降低读写次数减少读取时间和优化体验俩个方面&quot;&gt;I/O操作的优化空间相对比较小，是因为它主要的工作大部分由操作系统完成。因此我们先介绍下操作系统中I/O的读写原理，再从原理出发优化I/O操作效率，包括降低读写次数减少读取时间和优化体验俩个方面。&lt;/h3&gt;

&lt;p&gt;操作系统中为了分割操作内容让调用更安全，分为‘用户态’和‘内核态’，当用户态需要内核态工作时我们称为‘系统调用’，我们平常写的程序只要不涉及系统调用的都是用户态完成的，一旦涉及到需要操作系统工作的部分，就要先切到内核态完成工作，结束后再切回用户态继续执行后面的程序，这个切换的过程是比较费时费力的，I/O调用就是其中一种需要切换内核态的系统调用。&lt;/p&gt;

&lt;p&gt;操作系统可以支持多种底层不同的文件系统（比如NTFS, FAT, ext3, ext4），为了给内核和用户进程提供统一的文件系统视图，Linux在用户进程和底层文件系统之间加入了一个抽象层，即虚拟文件系统(Virtual File System, VFS)，进程所有的文件操作都通过VFS，由VFS来适配各种底层不同的文件系统，完成实际的文件操作。&lt;/p&gt;

&lt;h3 id=&quot;这里我们来了解下虚拟文件系统构成和主要模块&quot;&gt;这里我们来了解下虚拟文件系统构成和主要模块：&lt;/h3&gt;

&lt;h3 id=&quot;超级块super_block&quot;&gt;超级块（super_block）&lt;/h3&gt;

&lt;p&gt;用于保存一个文件系统的所有元数据，相当于这个文件系统的信息库，为其他的模块提供信息。&lt;/p&gt;

&lt;p&gt;因此一个超级块可代表一个文件系统，文件系统的任意元数据修改都要通过超级块修改，超级块对象是常驻内存并被缓存起来的。&lt;/p&gt;

&lt;h3 id=&quot;目录项模块&quot;&gt;目录项模块&lt;/h3&gt;

&lt;p&gt;是管理路径的目录项，比如一个路径 /home/foo/hello.txt，那么目录项有home, foo, hello.txt三个。&lt;/p&gt;

&lt;p&gt;每个目录项的块，存储的是这个目录下的所有的文件的inode号和文件名等信息。其内部是树形结构，操作系统检索一个文件是从根目录开始，按层次解析路径中的所有目录，直到定位到具体文件。&lt;/p&gt;

&lt;h3 id=&quot;inode模块&quot;&gt;inode模块&lt;/h3&gt;

&lt;p&gt;管理的是一个具体的文件，是文件的唯一标识，一个文件对应一个inode。&lt;/p&gt;

&lt;p&gt;通过inode可以方便的找到文件在磁盘扇区的位置，同时inode模块可链接到address_space模块，方便查找自身文件数据是否已经被缓存在内存中。&lt;/p&gt;

&lt;h3 id=&quot;打开文件列表模块&quot;&gt;打开文件列表模块&lt;/h3&gt;

&lt;p&gt;包含所有内核已经打开的文件，已经打开的文件对象由open系统调用在内核中创建，也叫文件句柄。&lt;/p&gt;

&lt;p&gt;打开文件列表模块中包含一个列表，列表表项是一个结构体struct file，结构体中的信息存储了打开的一个文件的各种状态参数。&lt;/p&gt;

&lt;h3 id=&quot;file_operations模块&quot;&gt;file_operations模块&lt;/h3&gt;

&lt;p&gt;模块中维护一个数据结构，是一系列函数指针的集合，其中包含所有可以使用的系统调用函数，例如open、read、write、mmap等。&lt;/p&gt;

&lt;p&gt;每个打开文件（打开文件列表模块的一个表项）都可以连接到file_operations模块，从而对任何已打开的文件，通过系统调用函数，实现各种操作。&lt;/p&gt;

&lt;h3 id=&quot;address_space模块&quot;&gt;address_space模块&lt;/h3&gt;

&lt;p&gt;记录了文件在页缓存中已经缓存了的物理页信息，是页缓存和外部设备中文件系统的桥梁。如果将文件系统可以理解成数据源，内存中的页缓存是已经读取的内容，那么address_space可以说是内存系统和文件系统的中间层。&lt;/p&gt;

&lt;h3 id=&quot;所有文件信息保存在超级块中通过目录项模块找到文件所在位置所有被打开的文件放在文件列表模块中file_operations模块负责操作文件每个文件都有唯一标识inode磁盘数据与内存缓存通过address_space联接与映射&quot;&gt;所有文件信息保存在超级块中，通过目录项模块找到文件所在位置，所有被打开的文件放在文件列表模块中，file_operations模块负责操作文件，每个文件都有唯一标识inode，磁盘数据与内存缓存通过address_space联接与映射。&lt;/h3&gt;

&lt;h3 id=&quot;下面我们来看看读写入文件时的基本流程&quot;&gt;下面我们来看看读写入文件时的基本流程：&lt;/h3&gt;

&lt;h3 id=&quot;读文件&quot;&gt;读文件&lt;/h3&gt;

&lt;p&gt;1、进程调用库函数向内核发起读文件请求；&lt;/p&gt;

&lt;p&gt;2、内核通过检查进程的文件描述符定位到虚拟文件系统的已打开文件列表表项；&lt;/p&gt;

&lt;p&gt;3、调用该文件可用的系统调用函数read()&lt;/p&gt;

&lt;p&gt;read()函数通过文件表项链接到目录项模块，根据传入的文件路径，在目录项模块中检索，找到该文件的inode；&lt;/p&gt;

&lt;p&gt;4、在inode中，通过文件内容偏移量计算出要读取的页；&lt;/p&gt;

&lt;p&gt;5、通过inode找到文件对应的address_space；&lt;/p&gt;

&lt;p&gt;6、在address_space中访问该文件的页缓存树，查找对应的页缓存结点：&lt;/p&gt;

&lt;p&gt;（1）如果页缓存命中，那么直接返回文件内容；&lt;/p&gt;

&lt;p&gt;（2）如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页；重新进行第6步查找页缓存；&lt;/p&gt;

&lt;p&gt;7、文件内容读取成功。&lt;/p&gt;

&lt;h3 id=&quot;写文件&quot;&gt;写文件&lt;/h3&gt;

&lt;p&gt;前5步和读文件一致，在address_space中查询对应页的页缓存是否存在：&lt;/p&gt;

&lt;p&gt;6、如果页缓存命中，直接把文件内容修改更新在页缓存的页中。写文件就结束了。这时候文件修改位于页缓存，并没有写回到磁盘文件中去。&lt;/p&gt;

&lt;p&gt;7、如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页。此时缓存页命中，进行第6步。&lt;/p&gt;

&lt;p&gt;8、一个页缓存中的页如果被修改，那么会被标记成脏页。脏页需要写回到磁盘中的文件块。有两种方式可以把脏页写回磁盘：&lt;/p&gt;

&lt;p&gt;（1）手动调用sync()或者fsync()系统调用把脏页写回&lt;/p&gt;

&lt;p&gt;（2）pdflush进程会定时把脏页写回到磁盘&lt;/p&gt;

&lt;p&gt;同时注意，脏页不能被置换出内存，如果脏页正在被写回，那么会被设置写回标记，这时候该页就被上锁，其他写请求被阻塞直到锁释放。&lt;/p&gt;

&lt;h3 id=&quot;页缓存实际上就是一个基数树结构它将一个文件的内容组织起来存放在struct-page结构中文件越大树形结构越庞大每一页都记录着文件内容的页信息和缓存信息&quot;&gt;页缓存实际上就是一个基数树结构，它将一个文件的内容组织起来存放在struct page结构中，文件越大树形结构越庞大，每一页都记录着文件内容的页信息和缓存信息。&lt;/h3&gt;

&lt;p&gt;另外内核使用task_struct来表示单个进程的描述符，其中包含维护一个进程的所有信息。task_struct结构体中维护了一个 files的指针（和“已打开文件列表”上的表项是不同的指针）来指向结构体files_struct，files_struct中包含文件描述符表和打开的文件对象信息，这使得系统能够：&lt;/p&gt;

&lt;p&gt;1、多个进程可以同时指向一个打开文件对象（文件列表表项）。&lt;/p&gt;

&lt;p&gt;2、一个进程可以多次打开一个文件，生成不同的文件描述符，每个文件描述符指向不同的文件列表表项。但是由于是同一个文件，inode唯一，所以这些文件列表表项都指向同一个inode。&lt;/p&gt;

&lt;h3 id=&quot;我们知道了文件的读写原理再来看看我们在平时编写文件操作时的优化思路&quot;&gt;我们知道了文件的读写原理再来看看我们在平时编写文件操作时的优化思路。&lt;/h3&gt;

&lt;p&gt;1.减少读写次数，减少读写时间。&lt;/p&gt;

&lt;p&gt;由于每次读取文件内容都会从用户态转到内核态，完成后再切回来，这种切换的消耗是比较重的，因此我们应该尽量减少读写次数。&lt;/p&gt;

&lt;p&gt;在读取一个文件时，尽量将需要的内容一次性读取完毕，甚至可以预先读取未来的内容，以避免多次读取。在写文件时也是同样，尽量一次性写入硬盘，避免多次写入。例如下面代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;
while(getline(file,line))
{
	doSomeThing(line);
}

//改为

lines = getlines(file);

for(int i = 0 ,n = len(lines) ; i&amp;lt; n ; ++i)
{
	doSomeThing(lines[i]);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;一次性读取所有行再对每行做处理&quot;&gt;一次性读取所有行，再对每行做处理。&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;
void write_lines(std::ostream&amp;amp; file std::string const&amp;amp; lines[])
{
	for(int i = 0,n = len(lines) ; i&amp;lt;n ; ++i)
	{
		file &amp;lt;&amp;lt; lines[i]
		file-&amp;gt;flush();
	}
}

//改为

void write_lines(std::ostream&amp;amp; file std::string const&amp;amp; lines[])
{
	for(int i = 0,n = len(lines) ; i&amp;lt;n ; ++i)
	{
		file &amp;lt;&amp;lt; lines[i];
	}
	file-&amp;gt;flush();
}

//或用内存池的方式改为

void write_lines(std::ostream&amp;amp; file std::string const&amp;amp; lines[])
{
	int str_size = 0;
	for(int i = 0,n = len(lines) ; i&amp;lt;n ; ++i)
	{
		str_size += len(lines[i] + 1)*sizeof(char);
	}
	
	byte[] data = MemoryPool.instance.AllocMemory(str_size);

	CombineStringData(lines, data); //将lines中的数据都拷贝到data中

	file-&amp;gt;write(data);
	file-&amp;gt;flush();

	MemoryPool.instance.Free(data);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;每次写入文件时系统并不会立即写入文件而是存放在页缓存如果我们每次刷新则会每次都同步到硬盘写入硬盘速度比较内存慢很多会消耗比较长时间所以要减少刷新调用次数&quot;&gt;每次写入文件时系统并不会立即写入文件，而是存放在页缓存，如果我们每次刷新，则会每次都同步到硬盘，写入硬盘速度比较内存慢很多，会消耗比较长时间，所以要减少刷新调用次数。&lt;/h3&gt;

&lt;h3 id=&quot;只是减少刷新次数但依然减少不了内核态切换的次数于是我们用内存池的方式减少内存分配的时间将内存分配的耗时降低将原本要调用很多次系统调用的次数降低为了一次从而减少了内核态切换的次数&quot;&gt;只是减少刷新次数，但依然减少不了内核态切换的次数。于是我们用内存池的方式减少内存分配的时间，将内存分配的耗时降低，将原本要调用很多次系统调用的次数降低为了一次，从而减少了内核态切换的次数。&lt;/h3&gt;

&lt;p&gt;2.优化体验&lt;/p&gt;

&lt;p&gt;用阻塞读取的方式，由于线程要等待磁盘设备的工作，对于整个程序的效率来说是比较低的，因为硬盘设备读写的速度比较慢，主线程要等待硬盘设备工作完毕后才进行后面的工作。因此为了能让程序的整体效率提升，我们可以用异步读取的方式来优化整体的程序时间，即在读取或写入文件的同时，其他程序工作同步进行。&lt;/p&gt;

&lt;p&gt;最常见的是游戏的开机画面，加载画面，切换场景画面，甚至有些游戏中边加载边进行的部分，都是可以通过并行来优化体验的。&lt;/p&gt;

&lt;h3 id=&quot;文件读写并发通常都是开启线程后的读写操作与阻塞内容一样只是更多的利用可利用的cpu时间而不让线程空闲等待硬盘原理是我们尽力能让计算机中的所有设备资源都满负荷运转并很好的协作而不是相互牵制&quot;&gt;文件读写并发通常都是开启线程后的读写操作，与阻塞内容一样，只是更多的利用可利用的CPU时间而不让线程空闲等待硬盘，原理是我们尽力能让计算机中的所有设备资源都满负荷运转并很好的协作，而不是相互牵制。&lt;/h3&gt;

&lt;p&gt;下面我们就来讲讲并发的优化内容。&lt;/p&gt;

&lt;h2 id=&quot;并发&quot;&gt;并发&lt;/h2&gt;

&lt;p&gt;并发的方案有很多特别是在业务层上有很多技巧，这里只是选取与语言相关部分。我们将从原理出发讲一讲，线程同步中的技巧、原子性、以及无锁容器的原理。&lt;/p&gt;

&lt;p&gt;由于设备资源并不总是运行，因为我们的程序并没有使用到这些资源，或者说有时没有同一时间同时让它们一起运转，这使得资源的闲置造成了浪费，如果能在当某个程序在执行指令时，另一个设备在满负荷运作，这样就相当于提高了运行效率。&lt;/p&gt;

&lt;h3 id=&quot;并发的挑战是找到足够多的独立任务来充分地使用所有可用的计算机资源让资源都能满负荷的执行提高整体运行效率其中cpu资源是最稀缺也是使用最频繁的资源如果能让多核中所有cpu都满负荷工作不考虑降频问题程序的效率就能提高很多即使不满负荷也能提其他cpu分担不少工作让降频的概率减少到最低&quot;&gt;并发的挑战是找到足够多的独立任务来充分地使用所有可用的计算机资源，让资源都能满负荷的执行，提高整体运行效率。其中CPU资源是最稀缺，也是使用最频繁的资源，如果能让多核中所有CPU都满负荷工作(不考虑降频问题)程序的效率就能提高很多，即使不满负荷，也能提其他CPU分担不少工作，让降频的概率减少到最低。&lt;/h3&gt;

&lt;p&gt;首先我们来梳理下操作系统中的进程、线程、时间片的概念。&lt;/p&gt;

&lt;p&gt;线程是实际工作的单元，进程只是一个容器用来管理线程。严格来说Linux内核其实不区分进程和线程，内核把执行单元叫做任务(Task)。操作系统实际上调度的是进程，进程通过fork()来创建同样的另一个进程。每个进程有一个PID，同一组进程中最先启动的那个还有一个TGID，严格来说前者应该叫线程ID，后者应该叫进程ID，其实它们都是Linux的Task。&lt;/p&gt;

&lt;p&gt;多线程能同时做好几件事情以提高效率，但实际问题是，CPU的数量（核心数）是有限的，而且并不多。如果你的CPU有8个核，并且整个操作系统中有8个线程的话，不考虑中断等因素，每个线程理论上能一直执行下去。然而多于8个线程以后，操作系统就必须进行调度，也就是分配时间片。具体的分配方案，或者说调度算法有很多种。如果一个进程创建了很多线程的话，最多也只有8个能够处于执行的状态(这里说的是物理线程，有别于逻辑线程)，其余的线程必须等待调度。线程被调度的时候需要进行上下文切换，这个操作是一种额外的开销。当线程数量过多的时候，上下文切换产生的额外开销会对系统的效率造成负面影响。&lt;/p&gt;

&lt;p&gt;线程的调度算法和进程一样通常有优先级之分，优先级高的线程可以比优先级低的线程多抢占些CPU时间片。甚至不同的线程可以通过系统调用将线程绑定在某个CPU核上。因此我们也可以通过将线程绑某个cpu核的方式来强制执行线程调度，从而优化并行开销。&lt;/p&gt;

&lt;h3 id=&quot;线程同步&quot;&gt;线程同步&lt;/h3&gt;

&lt;p&gt;通常我们在多个线程交叉执行时最关心的是同步问题。解决这个问题我们可以用，减少锁的占用时间、减少锁的颗粒度、无锁容器三个方式。前两者更好理解些，也用的比较多，最后一个需要阐明下原理。&lt;/p&gt;

&lt;p&gt;通常我们使用锁和互斥量来解决线程间的同步问题，但这会带来潜在问题，就是由于锁的原因导致线程间的等待时间变长，实际执行的效率可能并没有因此而增加。&lt;/p&gt;

&lt;p&gt;因此锁的范围必须被压缩到最小，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;
void doFunction(item)
{
	lock(obj)
	{
		doSomeThing1();

		list.push(item); //must lock

		doSomeThing2();
	}
}

//改为

void doFunction(item)
{
	doSomeThing1();

	lock(obj)
	{
		list.push(item); //must lock
	}

	doSomeThing2();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;尽可能的缩小锁的范围减少锁等待时间&quot;&gt;尽可能的缩小锁的范围，减少锁等待时间。&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;
void doFunction1()
{
	lock(obj)
	{
		...
	}
}

void doFunction2()
{
	lock(obj)
	{
		...
	}
}

//改为

void doFunction1()
{
	lock(obj1)
	{
		...
	}
}

void doFunction2()
{
	lock(obj2)
	{
		...
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;减少锁的颗粒度让各自的锁只负责自己一小部分的内容这里也涉及到细粒度锁算法它通常基于轻量级原子性原语由于并不是基于系统提供的同步原语所以性能开销很小但在高并发的情况下细粒度锁算法就会成为程序的瓶颈&quot;&gt;减少锁的颗粒度，让各自的锁只负责自己一小部分的内容。这里也涉及到细粒度锁(算法)，它通常基于轻量级原子性原语，由于并不是基于系统提供的同步原语所以性能开销很小，但在高并发的情况下，细粒度锁(算法)就会成为程序的瓶颈。&lt;/h3&gt;

&lt;p&gt;由于指定锁某些局部的计算范围或者函数，锁的时间太长并不划算，所以我们通常在两个线程间的协作上使用消息队列(或者其他容器)让线程更大程度的并行，但这依然需要对容器加锁，以使得操作不冲突。&lt;/p&gt;

&lt;p&gt;为了能让容器冲突时间更小，当只有两个线程操作容器时，我们通常会采用些技巧。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;例如双队列，设置两个队列，其中一个用于处理消息，另一个用于接收消息，当处理消息时，两个队列的头指针交换一下再处理，这样就能让接收的队列继续接收，处理的队列独自处理，这种方式的缩短了锁的占用时间，锁的时间缩短到了变量交换时间。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;以及循环队列的方式，用头尾循环的方式做队列，一个线程只对尾部操作，另一个线程只对头部操作，发送数据的线程向尾部推入数据，接收数据的线程从头部取出数据，循环操作队列，只有当队列满时才需要停一停等待数据
处理，其他时候，两者永远都不需要相互等待。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;无锁容器&quot;&gt;无锁容器&lt;/h3&gt;

&lt;p&gt;无锁容器的复杂度有点高，它适用于高并发场景，这里不便深入，其原理是原子操作。虽然我们不深入无锁容器的具体写法，但我们用问答的方式来解释下原子操作。&lt;/p&gt;

&lt;h3 id=&quot;什么是原子性&quot;&gt;什么是原子性？&lt;/h3&gt;

&lt;p&gt;如果一个更新操作不会计算到一半的时候被另外一个线程看到，就叫原子性。&lt;/p&gt;

&lt;p&gt;原子操作可认为是一个不可分的操作；要么发生，要么没发生，我们看不到任何执行的中间过程，不存在部分结果(partial effects)。可以想象的到，原子操作要保证要么全部发生，要么全部没发生，这样原子操作绝对不是一个廉价的消耗低的指令，相反，原子操作是一个较为昂贵的指令。&lt;/p&gt;

&lt;h3 id=&quot;非原子操作为什么会更新到一半被另一个线程看到&quot;&gt;非原子操作，为什么会更新到一半被另一个线程看到？&lt;/h3&gt;

&lt;p&gt;即使一个简单的整型变量的赋值操作，也有可能更新到一半被另一个线程看到，这是为什么呢？原因就是高速缓存中的旧数据。&lt;/p&gt;

&lt;p&gt;由于每个cpu除了共享一个内存设备外还有各自的高速缓存，一个cpu更新了内存中的内容后，其实并没有通知其他cpu中的缓存去掉该内容，这导致其他cpu中的高速缓存存储的仍然是旧的数据。当这些CPU读取这个变量时会从缓存中取得旧数据，直到缓存中的这个数据被丢弃或更新。&lt;/p&gt;

&lt;h3 id=&quot;原子操作做了什么使得更新不被其他线程看到&quot;&gt;原子操作，做了什么使得更新不被其他线程看到？&lt;/h3&gt;

&lt;p&gt;CPU的高速缓存间有一个MESI协议(cache一致性协议，4个关键词 Modifed Exclusive Shared Invalid 拼凑起来的缩写)，通过这个消息协议，CPU可以查看其他CPU高速缓存中的数据状态，就像不同设备间通信那样。&lt;/p&gt;

&lt;p&gt;当执行原子操作 store 即写入数据时，先查看当前cpu高速缓存中有没有数据，如果没有，则通知其他cpu中的高速缓存该数据切为无效状态，等待所有cpu都将该数据切为无效状态后，此cpu才开始发起写入内存和高速缓存的操作，并标记该值为修改状态。如果有，则更新高速缓存中的值，并通知其他cpu中的高速缓存该值已经不合法，最后此cpu并没有将该值写入内存，而是在高速缓存中标记该值被修改，以便下次再利用，或者等到丢弃时再写入内存。&lt;/p&gt;

&lt;p&gt;当执行原子操作 load 即读取数据时，先查看当前cpu高速缓存中有没有该数据，如果没有(或者是无效的)，则从先从查看其他cpu中查看该数据，如果有则获取，没有则从内存中获取。如果当前cpu高速缓存中有该数据，则直接使用该数据(必须不是无效的)。&lt;/p&gt;

&lt;h3 id=&quot;其他并行优化&quot;&gt;其他并行优化&lt;/h3&gt;

&lt;p&gt;1.分割资源，减少线程间的争夺。&lt;/p&gt;

&lt;p&gt;分割或者复制一块内存出来，让某个线程专门使用，这样就不会与其他线程冲突，计算结束时再考虑合并的事。&lt;/p&gt;

&lt;p&gt;此方法在Unity引擎的 Job System中有使用到，即给Job System一块独立的内存来处理自己的事物，与其他线程不冲突。&lt;/p&gt;

&lt;p&gt;2.散列容器，减少锁的范围，和前面介绍的细粒度锁(算法）稍微有点不一样，这种容器是散列的，冲突更少但使用范围很小。&lt;/p&gt;

&lt;p&gt;3.SIMD指令虽然不是并行，但由于它可以同时处理4个数据的运算，也算是勉强算并行处理了。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/huxiao-tee/p/4657851.html&quot;&gt;《从内核文件系统看文件读写过程》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/64723752&quot;&gt;《Linux系统中 进程 、线程 、时间片的关系》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jiqizhixin.com/articles/2019-01-22-12&quot;&gt;《说说无锁(Lock-Free)编程那些事》&lt;/a&gt;&lt;/p&gt;
</description>
               <pubDate>Sun, 27 Dec 2020 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2020/12/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B018</link>
               <guid isPermaLink="true">http://www.luzexi.com/2020/12/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B018</guid>
            </item>
        
    </channel>
</rss>