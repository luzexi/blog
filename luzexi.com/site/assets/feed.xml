<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title></title>
        <description>漫漫人生,记录点滴技术,始于2013</description>
        <link>http://www.luzexi.com</link>
        <atom:link href="http://www.luzexi.com/assets/feed.xml" rel="self" type="application/rss+xml" />
        
            <item>
               <title>思路探讨(二十四) 要勇敢的相信自己</title>
               <description>&lt;p&gt;你是很厉害的人物，就像是无所不能的一样，但凡你接触到的都能成功搞定。&lt;/p&gt;

&lt;p&gt;我很确信的知道所有看我文章的读者都是很聪明的人，我认为你们就应该这么认为自己。&lt;/p&gt;

&lt;p&gt;我为什么要这么认为？&lt;/p&gt;

&lt;p&gt;因为我知道人与人之间的区别就是思想上的区别。你在想什么，怎么想的，决定了你的现在和你的未来。&lt;/p&gt;

&lt;p&gt;就比如现在我就是这么认为，你们是很聪明的，很棒的，很有能力的一群人，我认为读我的文章的人，都是这个世界上很厉害的人，无论你们来自哪个地方，都那个地方的佼佼者。&lt;/p&gt;

&lt;p&gt;这也同时映射出我是很棒的，是聪明的，是厉害的人。&lt;/p&gt;

&lt;p&gt;我不是反夸自己，因为我相信自己是个厉害的人物，是个聪明的人，是个很棒的人，不论现在是不是，未来一定是。在变成未来那个很厉害的人之前，所有阻碍和困哪，都不值得去太在意。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h6&gt;我只关注那个未来画面里的我要成为的那个厉害的人，我只关注我是如何变成那个人的这个过程，只关注我要如何可以更快更好的变成未来那个人的方法，只关注我有没有按照变成未来那个人的方向去行动。&lt;/h6&gt;

&lt;h6&gt;除了上面这些，其他的一切都不值得我在意，因为我很坚信我能成为我心中的那个很棒的人。钱没了就没了，再去赚，下次小心点，贵重物丢了就丢了，再买一个，下次小心点，事情失败了就失败了，再来一次，下次小心点，事情变遭了，尽力修复，下次小心点。&lt;/h6&gt;

&lt;p&gt;你看，我并没有把注意力聚焦在那些阻碍我发展的事情上，而是把所有的注意力都集中在了我相信的那个事情上。其他所有的阻碍、困难、失败，都被我轻描淡写的掠过了，而我则在这些苦难后还在继续向前走。&lt;/p&gt;

&lt;p&gt;这就不就是，我们生活中一直幻想着的那个，聪明的，冷静的，有远见的，不斤斤计较的，充满智慧的人么。我们每天都在期盼有一个这样厉害的家伙成为自己的合作伙伴。&lt;/p&gt;

&lt;p&gt;成为这样的人其实很简单，只要你想，就能成。&lt;/p&gt;

&lt;h6&gt;是的，只要你把注意力集中在你想的那个东西上，其他事物都是次要的。如果我们把注意集中在未来的美好事物上，我们就能在当下成为一个聪明智慧的人，并且在未来成为画面里那个很棒的人。&lt;/h6&gt;

&lt;p&gt;不知道你有没有和我有同样的体会：回忆过去的时候，发现，很多很多事情都是因为我们不相信，所以才没有成，也有很多很多事情只是因为我们相信我们能成才成就的。我们能否做成一件事，全靠我们有多少的相信（即我相信的力度），我‘有点’相信，这个事情成功的概率就有是‘有点’，如果我‘非常’相信，那么这个事情的成功率就有‘非常’高。&lt;/p&gt;

&lt;p&gt;我相信我今天存进银行的钱，明天就能取出来，那么明天确实能取出来。&lt;/p&gt;

&lt;p&gt;如果我不相信我今天存进银行的钱能取出来，那么明天真的有可能取不出来。（如果有一天社会动荡到你完全不相信存进银行的钱是安全的时候，明天银行就会因挤兑而倒闭）&lt;/p&gt;

&lt;p&gt;我不是神棍，而是告诉大家，让人相信某件事是很难的，让人不相信某件事业也同样很难。就比如我如何让你不相信，存进银行的钱，明天取不出来，这件事，很难。因为现在的社会环境让你非常相信，存进银行的钱，明天就能取出来，我是很难改变你的想法的。就像我无法让你相信，你以后会竞选总理并且获胜一样，很难让你有这种相信的想法。但我能让你相信，我的想法是对，并且对你很有用，这个相对容易点，但也不是针对每个人都有效。&lt;/p&gt;

&lt;h3&gt;让一个人相信一件事，或者让一个人不相信一件事都非常难，概括可以说，要改变一个人的想法非常难。&lt;/h3&gt;

&lt;p&gt;我想了很久，关于人与人之间的区别到底在哪里的问题。&lt;/p&gt;

&lt;p&gt;是钱么？&lt;/p&gt;

&lt;p&gt;如果是钱，那么为什么有钱的人也同样迷茫，也同样冲动，也同样不知所措，同样犯与没钱的人一样的错误，也同样无知。&lt;/p&gt;

&lt;p&gt;是知识么？&lt;/p&gt;

&lt;p&gt;如果是知识，那么为什么博士以及博士后不是在掌控世界，理论上说他们的知识量是最大的，为什么依旧与普通人一样，迷茫，冲动，不知所措，也同样表现的无知。&lt;/p&gt;

&lt;p&gt;其实都不是。人与人之间的区别就是思维，和，想法。你怎么想的，决定了你怎么做，你想的是什么，决定了你最终会成为什么样人。&lt;/p&gt;

&lt;p&gt;如果你每天想着，我基因不好，我老是身体不好，我总是生病，我比较笨，我不会运动，我很穷，我被穷困所限制，老是有人和我作对，我的人生是苦难的，我有才但始终没有伯乐，我每次都被别人抛弃，我在变老，我怕我会破产，我总是迟到，我总是经不住诱惑，别人老是来占我便宜。等等等等。&lt;/p&gt;

&lt;p&gt;那么你就会成为你所想的，你的基因一定不好，你的身体肯定会坏，你肯定总是生病，你肯定比较笨，你肯定不擅长运动，你肯定富不起来，你的人生肯定是苦难的，你肯定遇不到伯乐，你肯定每次都被抛弃，你肯定老的很快，你肯定破产，你肯定迟到.....&lt;/p&gt;

&lt;p&gt;你想什么，就是你希望得到的，事情就会往这个方向发展，最终就会实现你所想。&lt;/p&gt;

&lt;p&gt;反之，如果我们的想法能更加积极点，乐观点，美好点，光明点，那么事情就会向更加积极，乐观，美好，光明的方向去走。&lt;/p&gt;

&lt;p&gt;如果我每天都认为，我的人生是完美的，我拥有很好的基因，我身体很棒，我免疫力很好，我很会运动，我总是很幸运，我总能遇到伯乐，我总是能和大家搞好关系，我永远都是那么年轻，我会越来越富有，我总是很准时的赴约，我总是很理智，别人都很喜欢跟我合作，我的知识会越来越渊博，我很智慧，我总是很受人照顾，我会很厉害。等等等等。&lt;/p&gt;

&lt;p&gt;那么事情就会真的向我想象的方向发展，我的基因很完美，我很健康，我很理智，我总是很受欢迎，我总是能遇到伯乐，我变得越来越富有，我很幸运，我看上去一直很年轻。&lt;/p&gt;

&lt;h6&gt;难道说真的有什么外在因素在决定这些事情的发生吗？并没有，原因在人的内心：我怎么想，决定了事情怎么走。&lt;/h6&gt;

&lt;h3&gt;人与人之间最大的区别就在这里，可以用很简单的一句话概括：你相信什么？信则有，不信则无。&lt;/h3&gt;

&lt;h3&gt;你所相信的，就是你能得到的。同样的，你所不相信的，就是你得不到的。&lt;/h3&gt;

&lt;h3&gt;无论你遭遇什么境况，都要勇敢的相信自己，我是健康的人，我是幸运的人，我是厉害的人，我是受欢迎的人，我是幸福的人。&lt;/h3&gt;
</description>
               <pubDate>Wed, 01 May 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/05/01/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A824.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/05/01/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A824.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第五章，3D模型与动画(四) - 3D模型的变与换2</title>
               <description>&lt;p&gt;上一篇介绍了一些3D模型的渲染基础知识，并且将这些基础知识运用在了3D模型的切割、拉伸、扭曲当中。&lt;/p&gt;

&lt;h6&gt;技术原理是最重要的核心点，人只要理解了技术原理，就能将技术表象解释清楚，在实际项目中将这种技术运用自如。&lt;/h6&gt;

&lt;h6&gt;实际中并没有这么容易，理解和运用自如之间，还是有一段很大的差距的，在实际项目过程中，理解只是理解，只是能解释这种表象是如何发生的，运用自如，则是熟知了原理的优缺点，不再对这种技术有任何的偏见，能做什么不能做什么，做什么有什么优势，有什么有什么劣势，有了更加深入的理解，当没有了这么多的偏见，运用起来自然得心应手。&lt;/h6&gt;

&lt;h6&gt;理论上说，我们每个人把所有精力先放在理解原理上，然后再去做技术实现不就轻松了吗。理论上是这样的，但人类头脑的进化毕竟还没到那么高级的程度，还不能轻松的把抽象的事物短时间内在脑中有条不紊的整理清楚，这还没把人的情绪影响算进去，人性毕竟是弱点多于优点的，虽然表面上能处理一些看上去相对复杂的事物，但从学习知识的角度看，人类的大脑还是不够高级，说实话应该说是有点低级。&lt;/h6&gt;

&lt;h6&gt;对于这么低级的大脑，我们只能通过反复的学习，然后实践，再学习，再实践，很多遍后才能对原理的理解推进那么一点点，我们也只能依靠长时间的、漫长时间的、很长很长时间的磨练，从有兴趣到放弃，再重新拿起到再放下，再拾取再举起再抛向天空，反反复复但始终不离弃，才能最终到达运用自如的境界。人之间没有聪明与不聪明之分，有的人善于思考，善于举一反三是因为前面很长一段时间他都一直在练习这种多思考和举一反三的方式，当我们看到他时他的思维方式已经成型，这些并不是先天就有，而是通过后天努力得来。天才这东西，不管它是否真的存在，我们都应该忽略它，转而更加专注于自己的努力上。&lt;/h6&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h3&gt;3.简化模型&lt;/h3&gt;

&lt;p&gt;经常在项目中看到有模型有几万个面，甚至几十万个面的情况，模型面数多的好处是能表现的更加精细，画面更细腻，但坏处却是加重了渲染压力，渲染的面数越多压力越重，帧率越低。所以一般都会对场景中的单个3D模型进行限制，或者对整体场景面数进行限制。&lt;/p&gt;

&lt;p&gt;画面质量和性能需要权衡，通常都是要求模型降低面数而画面质量不变，LOD(Level Of Detail)在这里就可以发挥巨大的作用，随着镜头的靠近逐级更换更细腻的模型很好的解决这种需求。&lt;/p&gt;

&lt;p&gt;简化模型在LOD中用到的最多，有手动用3D模型软件简化的，也有用程序工具式的简化模型，手动简化更加平滑但费时间，时间成本大，而用程序工具去简化则快速，但不平滑。我们可以根据项目的需求，规模，画质等要求来权衡是否使用程序工具去简化模型，或者更加灵活点，一部分不太需要细致的模型使用程序工具简化，而另一部分比较需要细节化的模型使用手动简化，这样即照顾到了画质，又照顾到了工期。&lt;/p&gt;

&lt;p&gt;这里我们来具体讲述下简化模型的算法。虽然市面上简化模型的插件和工具很多，但如果我们对原理有了更深入了解，在实际的项目中运用这些工具会更加自如且得心应手。&lt;/p&gt;

&lt;p&gt;3D模型是由点，线，面组成。面由点和线组成，减面相当于减点和线，单纯的减去点和线容易引起模型变化不受控制，收缩线上的两顶点成为一个顶点则更加靠谱些。[Garland et al. 1997]提出了一种基于二次项误差作为度量代价的边收缩算法，其计算速度快并且简化质量较高。&lt;/p&gt;

&lt;p&gt;该方法是去选择一条合适的边进行收缩时，定义一个边的收缩都是有代价的，每个顶点也有自己的代价，对于网格中的每个顶点v，我们预先定义一个4×4的对称误差矩阵Q，那么顶点v=[x y z 1]的代价为其二次项形式Δ(v)=vQ。&lt;/p&gt;

&lt;p&gt;同时也定义了边收缩的代价公式，假设对于一条收缩边(v1,v2)，其收缩后v1，v2顶点收缩为v3，我们定义顶点v3的误差矩阵Q3为Q3=Q1 + Q2，也就说是v1，v2的这条边的收缩为v3后代价为Δ(v3) = v3(Q1 + Q2)，以此类推每条边都有一个代价。&lt;/p&gt;

&lt;p&gt;有了上面的代价公式，下面的网格简化算法就容易理解多了：&lt;/p&gt;

&lt;p&gt;1，对所有的初始顶点都计算它们各自的Q矩阵.&lt;/p&gt;

&lt;p&gt;2，选择所有有效的边（这里取的是两点有连线的边，也可以将两点有连线且距离小于某个阈值的边归为有效边）&lt;/p&gt;

&lt;p&gt;3，对每一条有效边(v1,v2)，计算最优收缩目标v3.误差(Q1+Q2)是收缩这条边的代价（cost）&lt;/p&gt;

&lt;p&gt;4，将所有的边按照cost的权值都放在队列中从小到大进行排序。&lt;/p&gt;

&lt;p&gt;5，每次移除队列顶部的代价（cost）最小的边，也就是收缩最小代价的边，删除v1，v2，并用v3替换。&lt;/p&gt;

&lt;p&gt;6，重复1-5步骤，直到顶点数少于某个设定的值，或者所有cost代价大于某个值，则停止收缩算法。&lt;/p&gt;

&lt;p&gt;整个算法并不复杂，关键这里有两个核心问题需要解决，一个是每个顶点的初始Q矩阵如何计算，另一个是v1，v2收缩为v3时的坐标位置该怎么计算。&lt;/p&gt;

&lt;p&gt;在原始网格模型中，每个顶点可以认为是其周围三角片所在平面的交集，也就是这些平面的交点就是顶点位置，因此我们定义顶点的误差为顶点到这些平面的距离平方和。&lt;/p&gt;

&lt;p&gt;由此定义我们可以计算出每个顶点的初始误差矩阵Q：Δ(v)为顶点误差值 = vQ = 0，因为初始顶点的误差值为0，因为是它与相交平面的距离平方和为0，那么初始顶点的误差矩阵Q也可以由此计算出来。&lt;/p&gt;

&lt;p&gt;至于v1，v2收缩为v3时如何选择最优的坐标，简单的方法就是取v1，v2，和中点(v1+v2)/2的三个中收缩代价最小的一个为最优选择，另一种策略则是数值计算顶点v3位置使得Δ(v3)最小，由于Δ的表达式是一个二次项形式，因此令一阶导数为0。&lt;/p&gt;

&lt;p&gt;按照这个算法步骤，不停的收缩最小代价的边，直到顶点数量小于某个值时停止，最终将得到一个简化的模型。&lt;/p&gt;

&lt;h3&gt;4.蒙皮骨骼动画&lt;/h3&gt;

&lt;p&gt;有了3D模型，有会有3D模型动画，那么3D模型和3D模型动画之间到底有什么区别，我们先做个了解。&lt;/p&gt;

&lt;p&gt;为了能让读者们更直观的了解模型与模型动画的不同，我们从 Unity3D 的 MeshRenderer 和 SkinnedMeshRenderer 上作为切入点。&lt;/p&gt;

&lt;p&gt;在Unity3D中，MeshRenderer 与 SkinnedMeshRenderer 分别用于渲染 3D模型 和 3D模型动画。&lt;/p&gt;

&lt;p&gt;蒙皮网格(SkinnedMeshRenderer)渲染的是模型，由3D模型数据组成，普通网格(MeshRenderer)渲染的也是模型，也由3D模型数据组成。&lt;/p&gt;

&lt;p&gt;不过蒙皮网格被创造出来主要是为了动作动画服务的，所以蒙皮网格除了3D模型数据外还有骨骼数据以及顶点权重数据。&lt;/p&gt;

&lt;p&gt;假设说蒙皮网格(SkinnedMeshRenderer)上没装有任何骨骼动画，和普通网格的作用没有任何区别，都只能渲染禁止不动的3D模型。&lt;/p&gt;

&lt;p&gt;有很多人并没有理解骨骼动画的原理，所以在实际项目中对3D模型骨骼动画的运用有很多误区，这里我们有必要阐述一下骨骼动画的原理，以及在Unity3D的SkinnedMeshRenderer上骨骼动画是如何组装和组成的。通过对骨骼动画的原理解剖和对 SkinnedMeshRenderer 的解剖，我们能彻底的明白骨骼动画其实并不复杂，揭开这层薄薄的面纱后是一片平坦的开阔地。&lt;/p&gt;

&lt;p&gt;我们知道3D模型要做动作，首先是模型上的点，线，面要动起来，只有点，线，面动起来了，在每帧渲染的时候才能在每帧渲染时有不同的3D模型形状。&lt;/p&gt;

&lt;p&gt;那么怎么让点，线，面动起来呢？有两种方法，一种是移动顶点，叫顶点动画，一种加入骨骼机制去影响顶点，叫骨骼动画。&lt;/p&gt;

&lt;p&gt;这两种都是通过每一帧改变模型上的各个顶点位置，从而让模型变形，进而形成动画的效果。&lt;/p&gt;

&lt;p&gt;模型上成千上万的顶点，如果每个都要手动来调整，每一帧都要手动调整一次，这种量级的劳动力，人类无法承受，所以在最初，还没有骨骼动画这个概念的时候，只能用程序写一个顶点走向算法去改变每个顶点的位置，或者用着色器(Shader)在顶点函数中去改变顶点位置成为动画效果，这种动画效果现在很多游戏中都还在使用，这种方法已经成为节省骨骼动画开销的必要手段，比如草、树在风中的左右摆动，丝带或国旗在空中自然飘动等。至于如何在着色器(Shader)中编写顶点动画，我们会在OpenGL渲染章节中讲解。&lt;/p&gt;

&lt;p&gt;骨骼动画的出现让3D模型的动画效果就变得越来越丰富多彩。为什么这么说？因为它是由简单的几个骨骼点组成，一般骨骼动画的骨骼数量都不会超过50个，是人类能够承受的操控范围之内。通过这一些简单的骨骼点操作，加上3DMAX，Maya这样的好用的动画工具，让人类能够创造出许许多多丰富多彩的动画效果。&lt;/p&gt;

&lt;p&gt;首先，骨骼动画由骨骼点组成，每个骨骼动画可以由许多个骨骼，现代手机游戏中每个人物的骨骼动画的数量一般都会在30个左右，PC单机游戏中会更多点到达40-50个左右。骨骼数量越多，表现出来的动画越细腻越有质感，但同时也消耗掉更多的CPU计算。&lt;/p&gt;

&lt;p&gt;其次，一个骨骼可以有很多个子骨骼，每个子骨骼都与父节点拥有相同的功能，只是当父节点移动、旋转、缩放时子节点也随着父节点的一起移动、旋转、缩放，他们的相对位置、相对角度、相对比例不变。这一点与Unity3D中的 GameObject 的节点很相似，父子节点有着相对位置的关系，所以骨骼点在Unity3D中的表现是由类似GameObject的形式存在的，我们可以直观的从带有骨骼的模型中看到骨骼点的挂载结构。&lt;/p&gt;

&lt;p&gt;在 SkinnedMeshRenderer 中就有 bones 这个变量来记录所有骨骼点，骨骼点的表现在 SkinnedMeshRenderer 中就是 Transform 数组，因此 bones 这个变量就是 Transform[] 类型。&lt;/p&gt;

&lt;p&gt;另外，一个骨骼点可以影响周围一定范围内的所有顶点，单一一个顶点，也可以受到多个骨骼的影响。在Unity3D中的 Quality setting 图形质量设置中，我们可以看到关于Blend Weights的设置，就是关于一个顶点能被多少骨骼影响的参数设置。选项中，有1 Bone，2 Bones，4 Bones，意思是一个顶点能被1个骨骼影响，或者被2个骨骼影响，或者被4个骨骼影响，能被影响的骨骼数越多，CPU消耗在骨骼计算蒙皮的时间越长，消耗量越大。&lt;/p&gt;

&lt;p&gt;最后，模型中每个顶点都有对它顶点本身影响的最多4个骨骼的权重值，在Unity3D中这4个骨骼权重被记录在了 BoneWeight 这个类中，每个 Mesh类 都有一个 boneWeights 变量来记录所有顶点的骨骼权重值，而无骨骼动画的 Mesh 是不需要这些数据的。&lt;/p&gt;

&lt;p&gt;每个顶点都有一个BoneWeight 类实例，BoneWeight 中boneIndex0，boneIndex1，boneIndex2，boneIndex3分别代表被影响的骨骼索引值，而weight0，weight1，weight2，weight3则是分别代表被影响的权重值，权重最大为1，最小为0，所有权重分量之和为1。&lt;/p&gt;

&lt;h3&gt;未完，篇幅有限，下篇继续&lt;/h3&gt;
</description>
               <pubDate>Sat, 27 Apr 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/04/27/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB5.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/04/27/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB5.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第五章，3D模型与动画(四) - 3D模型的变与换1</title>
               <description>&lt;p&gt;3D模型是3D游戏中的基础单位，除了在游戏中那些静止的一动不动的3D模型外，还有许许多多动来动去的，这些3D模型除了骨骼动画，顶点动画外，很多时候为了画面效果的表现，我们还需要：切割，简化，变形，捏脸，飘动等等。那么它们是怎么实现的呢？我们今天就来讲讲这蕴含其中的技术与原理。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;一个3D模型是如何显示到屏幕中去的，这整个过程详细讲解下来有点长，所以将它们放在了OpenGL渲染管道章节中，这里我们先来做个不太深入的了解。&lt;/p&gt;

&lt;p&gt;众多的顶点构成了一个3D模型，顶点之间的连线组成了三角形或多边形，其实还是以三角形为主。为什么？因为OpenGL，DirectX都以三角形为单位渲染。至于为什么要以三角形为单位进行渲染，会在OpenGL渲染管道章节中详细讲解。&lt;/p&gt;

&lt;p&gt;这么多的顶点是怎么表达三角形的呢，有很多种方式，例如顶点索引，三角带，三角扇，不过这里我们只说说普遍用的比较多方式，也就是顶点索引方式，其他方式留到渲染管道章节去详细剖析。&lt;/p&gt;

&lt;p&gt;顶点索引是主流的三角形表达方式，其他方式都是为了优化索引这个数组而设计出来的，应用的范围相对小一点。&lt;/p&gt;

&lt;p&gt;顶点索引的方式就是把所有顶点放进一个数组里，然后用另一个数组用来表达三角形的组成（就是用顶点数组里的index下标）。在索引数组里，每3个索引组成一个三角形，也就是说，如果有4个顶点的数组表达了一个正方形的形状，这个正方形相当于有两个三角形组成的，索引的数组就是大小就是6，前3个索引数组表达第一个三角形，后3个数组表达了另一个三角形。&lt;/p&gt;

&lt;p&gt;看数据：(0,0,0), (0,1,0), (1,1,0), (1,0,0) 这个4个顶点构成了正方形。&lt;/p&gt;

&lt;p&gt;那么索引数组就是，0,1,2,2,3,0 ，其中前三个0,1,2构成一个三角形，后三个2,3,0构成另一个三角形。&lt;/p&gt;

&lt;p&gt;依次类推，每三个索引单元描述三角形的三个顶点。&lt;/p&gt;

&lt;p&gt;我们把所有顶点和所有顶点索引都传给显卡驱动，显卡驱动就可以根据这些数据来展示3D模型，这中间并没有这么简单，不过也并没有复杂到不可理解，只是多了些陌生的的流程和步骤而已，熟悉下就可以理解和应对了，这些都将在OpenGL渲染管道章节中，由浅入深的剖析。&lt;/p&gt;

&lt;p&gt;那么图片是怎么贴上去的呢？&lt;/p&gt;

&lt;p&gt;如果把3D的三角形当做一个2D的面片来看就会好理解多了，一个2D的三角形面片为了把图片贴上去，就需要在图片上也指定三个点，图片上的三个点形成了与三角形一样比例大小的形状，就可以贴上去了，如果比例不对称也可以贴，只是会拉伸或缩放而已。这三个在图片上的点坐标就叫u和v，都是2个数字的数组（都是Vector）为什么叫uv而不是传统的xy，因为不想和xy概念混合，而且uv是一个0到1的浮点数，0表示起始位置，1表示最大偏移位置，一听uv二字母就知道说的是图片上的坐标。&lt;/p&gt;

&lt;p&gt;以这种三角形贴图的方式贴到3D模型的每个三角形上，就可以如期的绘制出有’皮‘的3D模型了。&lt;/p&gt;

&lt;p&gt;这样一来，在绘制3D模型时，就多了另一个数组，叫uv数组，这个uv数组是由uv坐标组成的，由于已经有了顶点索引来表达三角形，所以uv数组就不再需要索引来表达了，只需要按照顶点的索引形成的三角形来定制uv的顺序就可以了。&lt;/p&gt;

&lt;p&gt;还是用旧数据举例来说明：&lt;/p&gt;

&lt;p&gt;[(0,0,0), (0,1,0), (1,1,0), (1,0,0)] 这个4个顶点构成了正方形。&lt;/p&gt;

&lt;p&gt;[0,1,2,2,3,0] 组成了顶点索引表达了2个三角形的形成。&lt;/p&gt;

&lt;p&gt;[(0,0), (0,1), (1,1), (1,1), (1,0), (0,0)] 组成了uv数组，表达了两个三角形上贴图的绘制范围。&lt;/p&gt;

&lt;p&gt;别小看这些基础知识，这些基础知识在平时的实践中有很大很大的用途。下面就开始介绍我们在具体实践中，是如何将这些基础知识灵活的运用到项目中去的。&lt;/p&gt;

&lt;h3&gt;1.切割模型&lt;/h3&gt;

&lt;p&gt;模型切割，也可以说模型的分裂，在游戏中也比较常见。我们这里不具体深入不同切割的算法，因为项目的每种切割方式都可以是不同的，可以由不同的算法代替。我们只说如何切割模型，就拿最简单的一刀切割的方式，如’切水果游戏‘那样，横向或纵向切割。&lt;/p&gt;

&lt;p&gt;我们知道一个模型是由一个渲染实例构成的，也就是说一个Render组件（MeshRender或者SkinnedMeshRender,这里统一称为Render组件）只能渲染一个模型。&lt;/p&gt;

&lt;p&gt;那么要把一个Render渲染的模型切割成2个，就相当于把这个渲染组件删掉，生成两个新的Render渲染组件，渲染不同的模型。&lt;/p&gt;

&lt;p&gt;有了这个方向就容易多了。我们可以把原来的Render渲染组件中的顶点数组、顶点索引数组，uv数组，都提取出来，并全部都分成两部分，一部分是切割后的左半部分，另一部分是切割后的右半部分。再把这两部分，分别放入新建的两个新的Render渲染组件实例中去，就得到了切割后的模型。&lt;/p&gt;

&lt;p&gt;假如在切割后再对这两个切割后的模型，加入碰撞体和物理运动组件（或者说重力引擎Rigidbody），就可以让画面表现的像是真实的被切割开来后倒地分成了两半一样。&lt;/p&gt;

&lt;p&gt;这其中，核心的难点是如何拆分成两部分，以什么规则拆分，如何知道这个顶点在左半边还是右半边，切割中如何生成新的切割顶点，如何将这切割顶点缝合。&lt;/p&gt;

&lt;p&gt;首先面临的是怎么区分点在左半边还是右半边，我们不用区分是左边还是右边，只要区分是否是在平面的同一侧就可以了，方法有很多，比如点与平面上任意点组成的线段和平面上任意线的点积来判断是否为相同一侧，也可以通过平面与线段的交点之间的连线与点与交点的连线的点积判断是否为同一侧。&lt;/p&gt;

&lt;p&gt;其次我们用平面与线段是否有交点的图形算法，来判定是否有新交点。把所有三角形的线都与平面做交点碰撞测试，如果有碰撞，则交点就是新切割点。得出的新切割点用处很大，而且要复制两份，一份放在左半部分，一份放在有半部分。&lt;/p&gt;

&lt;p&gt;切割后，原本点与点之间相连的映射关系被打破并转移到了新交割点上，于是旧点与新切割点组成了新的三角形，左右两部分都是同理。&lt;/p&gt;

&lt;p&gt;用数组的方式更容易理解点，还是拿上面的数据来举例。&lt;/p&gt;

&lt;p&gt;[(0,0,0), (0,1,0), (1,1,0), (1,0,0)] 这个4个顶点构成了正方形。&lt;/p&gt;

&lt;p&gt;切割后分成了两个数组，假设切割点为中点对半切开，也就是切割点位(0.5,0.5,0)和(0.5,0,0)。&lt;/p&gt;

&lt;p&gt;此时数据就变成了这样&lt;/p&gt;

&lt;p&gt;[(0,0,0), (0,1,0), (0.5,0.5,0), (0.5,0,0)]&lt;/p&gt;

&lt;p&gt;和&lt;/p&gt;

&lt;p&gt;[(0.5,0.5,0), (0,0.5,0), (1,1,0), (1,0,0)]&lt;/p&gt;

&lt;p&gt;这个举例的例子是相对比较简单的实例，不需要缝合切面。&lt;/p&gt;

&lt;p&gt;如果切割的对象是一个立方体或者更复杂的模型，切割后，就需要缝合切割面。因为缝合的面上所有点是在同一平面的，所以缝合时只需要缝合新生成出来的交点部分就可以了，因为其他部分还是保留原来的样子。&lt;/p&gt;

&lt;p&gt;缝合的算法很多，主要的目的是，将多新生成出来的点，有规则的组成新的三角形，进而形成一整个切割面。&lt;/p&gt;

&lt;p&gt;其中一种算法是，先选一个点，再用这个点与其他点形成的线段算出夹角，用夹角的大小进行排序，排序后的结果，就是顺时针或者逆时针的点位，然后按顺序先将靠最前面的前三个点形成一个三角形，后面的点位与它之前的两个点形成新的三角形，也就是第4个点与前两个点也就是第三个点和第二个点形成三角形，第5个点与第4个和第3个点形成新的三角形，依次类推形成切割面。&lt;/p&gt;

&lt;h3&gt;2.扭曲模型&lt;/h3&gt;

&lt;p&gt;扭曲模型，相当于将3D模型变形，凹进去，凸出来，部分放大，或者部分缩小等。&lt;/p&gt;

&lt;p&gt;有了上面介绍过的3D模型的基础知识，这里在编写模型的变形时就显得更加容易。&lt;/p&gt;

&lt;p&gt;3D模型就是由三角形组成的，三角形是由点组成的，要变形就是移动顶点的位置，不只一个顶点的位置，是一片顶点的位置，或者说一个范围上的点的位置。&lt;/p&gt;

&lt;p&gt;扭曲和变形在实际项目中也有很多应用，比如爆炸后的地面凹陷，击打某墙壁后的墙壁有个凹陷的表现，或者拉某个球时球有个先被拉伸再恢复的过程，或者3D模型表现制陶工艺，将模型从一个罐头转转转，拉拉拉，拉成一个自定义的陶瓷品，也些角色扮演类游戏中，操控的摇杆就是用可拉伸的泡泡糖表现的，这些都是对模型内某个范围或者某些顶点的进行位移后表现出来的。&lt;/p&gt;

&lt;p&gt;顶点的点位的移动相对比较简单，就是取出顶点数组，修改坐标，再放进去，三个步骤。&lt;/p&gt;

&lt;p&gt;难点一是如何正确找出需要修改的顶点，二是不同的点修改的值如何不同，找出修改方向的算法，三是持续修改的算法。&lt;/p&gt;

&lt;p&gt;我们拿爆炸凹陷，球体拉伸反弹，制陶工艺这三个例子来剖析如何扭曲模型的技巧。&lt;/p&gt;

&lt;p&gt;当发生在场景中发出爆炸特效时，首先找出爆照范围的这块地面，并取出这块地面的所有顶点数据，对所有顶点求出在爆炸范围球体内的地面顶点，这些顶点就是需要修改的顶点。&lt;/p&gt;

&lt;p&gt;爆炸需要凹陷，凹陷算法的目的是把顶点位置修改到爆炸球体的球表面上，这个算法相当于，如何把一个点对应到一个球体的面上，计算出来后修改点位置，再装入渲染的实例中，凹陷变形就完成了，顶点索引和uv都不需要任何变化。&lt;/p&gt;

&lt;p&gt;再说说球体拉伸与反弹恢复，第一个动作是拉伸球体，计算所有顶点与要拉的那个点位的距离，距离越大，顶点需要的位移的越小，这个比例肯定不能是个正比关系，一定是一个衰减的曲线，例如距离是d，拉伸的距离为f，结果为res，最简单的衰减公式为 res =  f/(d * d)，用这个公式对每个顶点进行计算，得到一个需要移动的数据res，这个数据是根据距离大小而衰减的，与拉伸点离得越近移动量越大，反之越小。修改完成所有顶点的坐标后，再推入渲染实例中去，就得到了球体拉伸的效果。&lt;/p&gt;

&lt;p&gt;球体的第二个动作是放开后恢复，这里我们假定球体的屁股是被固定的。恢复和拉伸有点相似，拉的最远的反弹的快，也就是与原有的位置距离最大的点反弹的速度最大，也就是说，我们需要记录原来没被拉伸时的顶点的坐标位置，他们与原来的位置相减就是反弹速度的基础变量。&lt;/p&gt;

&lt;p&gt;反弹力度肯定也不是正比关系，肯定也是类似衰减公式的增强公式，或者说是弧线比例，最简单的公式就做个平方，res = d * d，或者为了更平滑点，找个更好的曲线公式res = (d / max) * (d - 2) * k。&lt;/p&gt;

&lt;p&gt;反弹恢复的力度，在不断得计算过程中，会由于顶点与原有的点位的距离缩小而减小，后又由于反弹过度而不断放大，有一个来回反弹的过程，最后恢复到平静不再移动的状态，用这个公式能就很好的体现出来，因为它与原顶点距离有关，力度在不断得衰减，最后形成稳定态。&lt;/p&gt;

&lt;p&gt;最后再说说制陶工艺的模拟，一个罐体模型在转盘上不停的转，当用手（鼠标或者触摸屏）去触摸它的时，在触摸的点会形成凹陷，或者拉伸，人们通过在这样不断的凹陷和拉伸过程中制作出了一个完整的陶瓷的模样，这就是制陶工艺的过程。&lt;/p&gt;

&lt;p&gt;在一个叫做《釉彩》的手机App中有具体的表现，里面你可以用一个很丑的泥罐，通过来回、上下、左右的手指滑动制作出一个你喜欢的陶瓷品，制作出来的陶瓷品可以让别人定做，也可以通过里面的超市直接购买。&lt;/p&gt;

&lt;p&gt;它的原理非常简单，就是在当你触碰时，根据你的手指滑动的方向，把范围内的顶点向手指滑动方向偏移，并且有一个衰减范围，离手指最近的点越近拉伸的距离越大，离得越远拉伸的距离越小。顶点选取的范围的判定可以认为是在一个矩形中的范围，比如认定的手指滑动的矩形范围，从而构建出一个相应的立方体范围，进而选出在立方体内的顶点，再进行衰减式的位移，最终构建出，可上下，左右，对陶瓷罐的拉伸变形操作。&lt;/p&gt;

&lt;p&gt;由于篇幅限制，下篇将继续介绍’3D模型的变与换2‘。&lt;/p&gt;
</description>
               <pubDate>Sun, 21 Apr 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/04/21/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB4.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/04/21/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB4.html</guid>
            </item>
        
            <item>
               <title>思路探讨(二十三) 997成就世界</title>
               <description>&lt;p&gt;实际上还是有人不知道996是什么的。996，每天早上9点上班，晚上9点下班，周6加班，一周工作6天。&lt;/p&gt;

&lt;p&gt;似乎所有人都很痛恨这种模式，当所有人都在喊996痛苦的时候。你，就不应该喊了，你是普通人吗，你不是的。普通人每天过着凑合的日子，每天上着凑合的班，做着凑合的工作，什么都凑合。加班对他们来说是种恶毒的迫害，是对他们劳动力的剥削，是对他们娱乐生活的不尊重，所以他们痛恨。他们认为资本家是万恶的，是拥有无限权利的，是可以掌控世界的，是可以无所不能的，所以他们拒绝资本家的‘迫害’。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;那么真的是他们想象的那样吗？是真的为了迫害，是真的为了剥削，是真的不尊重，是真的万恶，是真的拥有无限权利和无所不能，才996的吗？不是的。&lt;/p&gt;

&lt;p&gt;资本家也是人，有一天你也会成为资本家，其实你我都有可能是资本家。资本家是人，也会痛苦，也会被迫害，也会遭遇不幸，也同样受到压迫，只是他们穿的西服比我们贵，但这并不舒服，不如我们的睡袍和卫衣，吃的200块钱一餐的美食，同样有可能用的是地沟油，也不如我们的汉堡包、薯条、鸡块来的可口。&lt;/p&gt;

&lt;p&gt;世界真的是公平的，不会因为你钱多而让你的痛苦少一点，也不会因为你钱少而给你少一点的机会。&lt;/p&gt;

&lt;h3&gt;我不赞成996，但我心中不止996，成年人世界里辛苦点又算的了什么，为了生存，为了更好的生存，为了追求极致的生存，皮肉上痛苦在成年人的世界里已经是最轻量级的痛苦了。&lt;/h3&gt;

&lt;p&gt;普通人依赖环境，没有环境他们无法生存。普通人，任人摆布，他们无法自控只有听从于他人。普通人，委曲求全，没有突出的能力到哪都是求稳定，稳定就要牺牲自我牺牲尊严。普通人，听从命运，你愿意听从你那稀烂的命运吗？！&lt;/p&gt;

&lt;p&gt;世界是残酷的，也是公平的。残酷在，人人都要为生存而斗争，不是你死就是我活。公平在，只有勤奋努力好学的人才配的上成功，机会永远都是给那些积累很多年并且时时刻刻保持勤奋努力好学的人的。&lt;/p&gt;

&lt;p&gt;当面临淘汰时，也同样公平，也同样残酷，那些凑合的人最先被淘汰，然后那些普通人大部分被淘汰，留下的普通人只是幸运儿，下次还会这么幸运么，你死我活的斗争一直没有停歇。&lt;/p&gt;

&lt;h6&gt;996不能赢得世界，但997能(相当于全年无休)。为什么？&lt;/h6&gt;

&lt;p&gt;因为996给自己留了余地，说一周来每天这么辛苦最后一天让自己休息一下。实际上，只要停下来，启动就难了。给了一个停下来的理由，启动的理由却又要再次寻找了。难以维系。&lt;/p&gt;

&lt;p&gt;我们之间有聪明与不聪明的区别吗？没有，（不要以为自己比别人聪明，当这么认为的时候我们就已经输了一半了）。从整个人生来看，到死之前，我们比的都是谁能坚持到最后，比的是都是耐力，是毅力，是勇气。谁能勇敢的坚持到最后谁就能赢得世界，聪不聪明只是人的自以为是的幻想而已，持久战才是人生真正的赛点。&lt;/p&gt;

&lt;p&gt;那么‘坚持’真就这么容易吗？不是的。‘坚持‘超难，难到怀疑人生。&lt;/p&gt;

&lt;h6&gt;为什么997就能成就世界？因为全年无休让你不得不转变观念。&lt;/h6&gt;

&lt;h6&gt;当我们明白自己无法逃脱全年无休的状态时，我们已经彻底放弃了所有试图休息的谋划，转而关注如何提高专注力，如何用更少的精力做好当下的事情，如何加强体力，如何加强免疫力，以及如何平衡工作、学习和娱乐三者之间的关系。&lt;/h6&gt;

&lt;p&gt;我们训练了更多提高专注力的方法，从而提高了专注力，训练了更多做好事情的方法、知识和技巧，从而提高了效率，加强了每天的健身锻炼，从而让自己每天元气满满，免疫力爆棚，抵御外来病毒侵扰，让高效状态保持的更久更有力。&lt;/p&gt;

&lt;p&gt;我们开始主动关注了每天工作的时间，学习的时间，娱乐的时间，不断调整着三者的时间平衡，我们没有时间娱乐，但人又不能没有娱乐活动，所以我们只能在工作中学习，在学习中娱乐，在娱乐中工作，边工作边学习边娱乐，三者混为一体，工作即学习，学习即娱乐，娱乐为了更好的工作，保持平衡和高效，不断主动的调整，因为它们并不是一个固定时间比，每个人每个时间段每个环境下都不一样，需要主动及时调整。&lt;/p&gt;

&lt;h6&gt;997让我们做时间的朋友。&lt;/h6&gt;

&lt;p&gt;全年无休的情况下我们不得不做时间的朋友，只有让时间成为我们最重要的朋友，我们才能减轻无休的痛苦。做时间的朋友最大的好处便是复利，时间就是复利的要素，每天积累一点，一年下来你就比别人多跑一点，5年下来，你就比别人多跑好几个整圈，10年下来你就比别人多跑好几个级别的比赛。&lt;/p&gt;

&lt;p&gt;每天都问下自己，今天和时间这个朋友合作的如何，今天有把时间好好分配吗，能对得起这位默默无闻支持你永不抛弃永不放弃你的朋友吗，如果有明天继续，如果没有明天继续努力。&lt;/p&gt;

&lt;h6&gt;997让我们转念，转念之间，997反而成就了我们，让时间成为了我们最好的朋友，让复利的积累引领我们走向了世界的巅峰。&lt;/h6&gt;
</description>
               <pubDate>Sat, 13 Apr 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/04/13/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A823.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/04/13/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A823.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第八章 AI(3) 非典型性AI</title>
               <description>&lt;p&gt;前面讲了状态机和行为树在AI中的运用，在实际开发过程中，特别是一些在游戏行业做过5-10年左右的很多人似乎似乎已经习惯了用这些固定的工具去写AI逻辑，一想到游戏AI就固定思维的认为，就用状态机去写，或者说就用行为树去写。&lt;/p&gt;

&lt;p&gt;思维跳不出这些‘工具’，我们就成不了大师。大师是什么，是能将‘剑’运用到最高境界的人，手里‘无剑’而心中有剑，是他们的至高境界。万事万物都是同一个道理，‘技术’就像剑术，在练习过程中，都会经过几个阶段，到底具体有哪些阶段每个人都不一样，我能确定的是，‘识剑’是第一个阶段，认识剑是怎么样的，或者说认识‘技术’是个怎样的东西用在哪里。而‘用剑’是另一个阶段，如何用剑或者说如何运用这项‘技术’是大多数人停留的阶段，怎么用剑怎么用好剑，是一个非常漫长而枯燥的阶段。‘无剑’就是最后一个阶段，手里没有剑而心中有剑在剑术的造诣上达到了至高的境界，无剑胜有剑在这个阶段体现的淋漓尽致。&lt;/p&gt;

&lt;p&gt;我们接触的面要尽量的广，接受和包容的东西要尽量的多，才能体验到更多的东西。游戏开发也是，世界上不是只有RPG角色扮演类一种游戏类型，还有SLG策略类游戏，还有休闲娱乐类游戏，还有体育竞技类游戏，还有学习教育类游戏等等等。只有状态机，只有行为树，或者只有状态机和行为树是无法为项目开发出最好最适合的AI的。我们应该尽量包容非典型性AI。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;下面我们来了解下游戏项目中非典型性的AI。&lt;/p&gt;

&lt;h3&gt;1，庄家式AI&lt;/h3&gt;

&lt;p&gt;顾名思义，是庄家统治游戏的一种玩法，玩法中AI就是全局的统治者，它决定了整个游戏的高潮和低谷，AI如何操作成为了至关重要的关键点，玩家是否喜欢这款游戏很大程度上取决于AI的策略。&lt;/p&gt;

&lt;p&gt;这种类型游戏大部分以彩票或赌局的形式存在，比如老虎机，百家乐，21点，以及部分以彩票为形式的游戏。&lt;/p&gt;

&lt;p&gt;AI策略的目的是要让玩家玩的好又不能赢太多而且最终是要输给AI的。玩家喜欢继续玩但从总体上来看却又是输的，让庄家就是游戏运行商有的赚，但又不能太狠，让游戏细水长流。&lt;/p&gt;

&lt;p&gt;这种AI常以输赢的概率为基本控制手段，比如现阶段以玩家欢乐为主，那么胜的概率变得大一点，玩家会认为幸运女神眷顾他了，一段时间后为了让玩家遇到点困难，让玩家有挑战性，这时AI慢慢降低了赢的概率，玩家缓慢觉得赢的次数开始减少，有些玩家会以为幸运女神走了，需要靠自己的‘本事’玩下去了，他们不断得发现和寻找输赢的规律，以及出牌和翻牌的概率，直到输得所剩无几，然后AI开始了缓慢提高胜率的操作，让玩家又看到了希望，找到了自信，认为自己终于不费苦心找到了规律和破解的秘密，于是又开始了一轮有输有赢但赢多输少的旅程。&lt;/p&gt;

&lt;p&gt;如此这般不断得循环往复，AI以一种庄家的形式控制着整个游戏过程。&lt;/p&gt;

&lt;h6&gt;从技术上来看，这种控制概率的过程，就是加法和减法的过程，相对比较简单。其核心是给出一个概率后，如何让它真的起到概率的作用，而且这种概率能让人很舒适的接受，比如当有30%概率赢时能否做到真正的随机值在30%的概率上徘徊，比如10局中有2-4局能中玩家可以得到想要的那个点位或者想要的牌什么的，而不是10局中0-5局能赢，输赢实际结果波动到了不好的体验。&lt;/h6&gt;

&lt;h3&gt;2，可演算式AI&lt;/h3&gt;

&lt;p&gt;可演算式的AI在策略类游戏中非常常见，在页游里的大部分的自动对战，以及现在卡牌手游中的大部分自动战斗都是可演算式的AI，是可以根据两边的阵容数据和一个随机种子来演算出整场战斗的每个细节的。例如，两个军队的各5个英雄，互相间攻击并释放技能，服务器需要在一瞬间把所有需要在客户端演示的内容都计算出来，并以数据的形式发送给客户端，客户端根据演算的数据进行展示人物的动作，位移，技能释放等，客户端并不需要计算任何内容，所有内容都在服务器里已经计算好了，以数据形式代表了整个过程。&lt;/p&gt;

&lt;h6&gt;可演算式AI的特点是逻辑一定是确定性的，不能是模糊的，或者会随机改变的，或者随时间变化而变化的结果，同样的数据第一次计算和多次计算的结果必须是相同的，才能最终体现出可演算的这个特征。&lt;/h6&gt;

&lt;p&gt;其次，可演算式AI大都是根据时间轴来演化游戏的进程，在那里‘时间轴’的概念在可演算式AI中是比较常见的。&lt;/p&gt;

&lt;p&gt;什么是时间轴演算路径？我们用卡牌对战算法来举几个例子。&lt;/p&gt;

&lt;p&gt;首先最简单的时间轴演算路径，例如，先由敏捷度最高的英雄进攻，等待英雄进攻完毕后再由其次高敏捷度的英雄进攻，依次进行下去直到所有的英雄进攻完毕再重新一轮进攻。这种相对比较简单，可以把进攻看成一轮一轮的回合，每个回合都相当于是一次for循环，每次for循环前先对敏捷度进行排序，再在for循环中依次计算进攻了谁受到了多少伤害，以及是否死亡。最后把进攻的数据和伤害的数据用队列的形式存储在数据中发送给客户端，客户端受到数据后再进行演示。&lt;/p&gt;

&lt;p&gt;稍微复杂点的时间轴逻辑，例如，不再由敏捷度来决定进攻的先后次序了，而是由每个英雄的进攻间隔冷却时间来决定进攻次序，对战开始时开始计算每个英雄的进攻冷却时间是否结束，谁的冷却时间先结束谁就最先得到进攻权，进攻完毕后再等待下一个英雄的冷却时间，以此类推。从技术上讲，冷却时间不需要等待，把所有英雄加入一个队列，排序一下就可以得到谁的剩余冷却时间最短，就立马可以开始计算进攻细节，完毕后根据冷却时间插入到队列中去，任然还是一个有序的剩余冷却时间队列，一直这样计算下去直到演算结束一方胜利或失败。这种演算方式就有了更多了时间轴的概念。&lt;/p&gt;

&lt;p&gt;再稍微复杂点，前面所说的进攻逻辑都是在其他英雄都停止的状态下进行的，现在进攻时不再需要其他英雄等待了，一旦冷却时间结束就可以立刻进攻。也就是说，每个英雄都可以在其他英雄还在进攻时进行进攻操作，只要他的冷却时间到位，并且他的进攻时需要花费固定时间的，等到进攻完毕后再判断对方和自己是否死亡。这种方式，不只是多了一个进攻消耗时间这么简单，还多了一个死亡判断时间，在还没有死亡判定前，此英雄虽然是死了但任然可以被进攻。从技术上来看，计算的量从单一的剩余时间量排序，增加了进攻消耗时间排序插入，以及死亡判定排序，我们既要在冷却时间结束时计算进攻，还要在选择进攻对象时计算该英雄是否已经判定死亡，最后在进攻完毕后计算当前的时间并插入到排序队列中。&lt;/p&gt;

&lt;p&gt;再复杂点，英雄在进攻一半时可以被别的英雄打死，也可以被其他英雄的技能打断，也包括了随时被回复血量蓝量，增加状态等等，让战斗更加逼真、更具有实时性。加强了实时性的要求，更加考验可演算式AI的复杂度，由于太多的需要计算的时间内容，所以我们必须有一个能有效管理时间轴的方法。从技术上来看，我们必须定义‘时间节点’这个概念了。&lt;/p&gt;

&lt;h6&gt;什么是‘时间节点’？‘时间节点’就是一个事件在整个过程的时间轴上的发生时的位置。&lt;/h6&gt;

&lt;p&gt;有了时间节点这个概念，我们可以用时间节点为计算标准，把所有人物的下一个事件的时间节点计算出来，比如，移动到达敌方位置，又比如，释放技能，又比如，回到原地，又比如，冷却时间结束，每个人只计算最近的一个时间节点，并把计算出来的结果放进队列中，然后就可以找出时间节点里离我们最近的一次事件的发生节点，也就是时间差最少的节点，执行它。&lt;/p&gt;

&lt;p&gt;由于每个时间点都有可能引起其他时间点的变化，比如把对方打死了，对方的时间节点就消失了，又比如打断了别人技能释放，对方就回到了冷却时间，时间节点就需要重新计算了，又比如加速了友军的攻击速度，因此所有友军正在攻击或打算攻击的时间节点都要重新计算了，等等等等。&lt;/p&gt;

&lt;p&gt;所以每次在执行完一个时间节点后，都要对有可能产生变化的人物的时间节点进行重新计算，并加入队列，然后就可以找出离我们最近的一个时间节点了，当然旧的时间节点数据必须清除掉。&lt;/p&gt;

&lt;p&gt;如此往复的重复这个计算过程，直到没有任何时间节点可计算和执行，最终决出这张战斗的胜利或失败。&lt;/p&gt;

&lt;h6&gt;时间轴贯穿了整个AI过程，人物之间的打斗，移动，释放法术，冷却时间等待，AI每次只计算一个时间节点，因为只有最近的那个时间节点是一定不会被其他节点影响的，这样既照顾到了可演算的根本原则，也照顾到了游戏的实时性，让战斗更加精彩。然后把每个计算的结果都记录下来，就可以在客户端进行演示了，整个过程的事件发生的时间都将准确无误呈现出来。&lt;/h6&gt;

&lt;h3&gt;3，博弈式AI&lt;/h3&gt;

&lt;p&gt;游戏项目中大部分AI的目的都是以娱乐玩家为主，并没有要真正打败玩家，最多也是要与玩家达到一种平衡。而博弈式AI则不同，它的目标就是为了打败玩家，它是为了赢得比赛而生的。&lt;/p&gt;

&lt;h6&gt;博弈AI最大的特点是搜索。通过搜索，将所有下一步可能发生的，以及下几步可能发生的事情都记录在内存中，以此来确定电脑该怎么进行下一步动作，进而获得最大的效益。&lt;/h6&gt;

&lt;p&gt;有的人不理解为什么是搜索，这里稍微做下解释。在AI选择下一步的动作前，下一步要发生的情况有很多，我们需要选择最佳的那个，怎么选择呢？把所有下一步的情况都列出来，再把下一步的后几步的情况也列在下一步的下面，由于cpu计算量的限制后面的几十几百步计算量太大以至于无法计算，假设我们只计算和预测十步的结果，我们需要找到第十步的最好结果，再反推到第一步来确定第一步到第十步是怎么走的。&lt;/p&gt;

&lt;p&gt;把这十步的所有结果都计算出来太耗时CPU负重太大，有些甚至无法承受这样大的计算量，那么我们就要在没有结果的情况下得到最佳选择，怎么做呢？既然我们要从第一步走到第十步，假设第一步有10种情况，第十步有10种情况，每一步之间都有一个结果就相当于一点到另一个点的路径一样，从第一步到第十步就可以视为路径的一种，那么从第一个点到第十个点的最短路径，就是第一步到第十步的最佳结果。把视角一转换后发现事情变得的简单了，用最短路径算法就可以解决搜索问题。&lt;/p&gt;

&lt;p&gt;不过事情远没有这么简单，这里只是举了个简单的例子，情况会复杂到每一步有几百种情况，普通的搜索方式计算机可能完全无法承受。为了能让计算机承受这样大的计算量，我们就需要引入更多的枝剪和优化，比如，存储一些固定技巧，以及拒绝计算一些明显比较差的选择。&lt;/p&gt;

&lt;h6&gt;另一个特点是AI对局势的估值该如何认定。估值表示了当前局势的好坏程度，通常用一个0到100的浮点数来表示估值，估值的好坏是AI一个比较关键的点，只有正确的计算出局势的估值，AI才能知道选择的行动方向是正确的还是错误的。&lt;/h6&gt;

&lt;p&gt;拿最简单的五子棋来说。棋盘上的每一个点都是对手下一步的可能性，通常不会在空白处下一个完全不着边的棋，所以搜索范围缩减到了当前棋盘上有棋子的范围周围的空位。AI对所有这些空位录入并计算当AI把棋子放入该位置上后，对方可能做出的反应以及由此引发的后几步的对弈可能。我们假设AI只搜索和计算后5步的预测，也就是说，计算出来的当前落子的估值，就是所有棋盘中可落子的后5步内最优估值。&lt;/p&gt;

&lt;h6&gt;最后一个特点是数据录入。人类的手法太过高明，欺骗性很强，很容易就能躲过AI的盲点，所以录入特别的人类的想法的是博弈AI的一大关键点。没有数据的录入，AI很难知道人类的想法。&lt;/h6&gt;

&lt;p&gt;96年97年的人机国际象棋大战就是录入了大量的棋局来告诉AI人类的一些固定走法，让AI在对弈中识别人类的套路。&lt;/p&gt;

&lt;p&gt;以前的数据是一些人手动录入的，所以局限性还是很大，不能应付现代这么快更新换代的技巧和想法。为了做出更强大的博弈式AI，我们不得开始让AI拥有自学的能力，所以机器学习，深度学习得到了广泛的关注和应用。它们原理就是数据录入，加，估值判定，给AI不断地喂数据的同时，告诉AI这个数据是对的还是错的，或者说估值能达到多少，通过不断的喂数据（也相当于用数据训练AI）的方式，让AI拥有丰富的‘经验’，从而在对弈中赢得比赛。&lt;/p&gt;
</description>
               <pubDate>Sun, 07 Apr 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/04/07/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-AI3.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/04/07/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-AI3.html</guid>
            </item>
        
            <item>
               <title>思路探讨(二十二) 人为什么做不出最正确的选择</title>
               <description>&lt;p&gt;人这一生真的能在每个节点都做出最好的决策吗，肯定不能。这个比较理想化的美梦，大多数人都知道是不可能的。&lt;/p&gt;

&lt;p&gt;但人真的能在模棱两可的分岔路面前做出最正确的决策吗？我认为是不可能的。（需要明确一点是，模棱两可的选择是指两种或者几种选择都是朝着光明的方向去的，而不是一黑一白或者两种都是黑。）&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;为什么做不出最正确的选择？&lt;/p&gt;

&lt;p&gt;因为最好的决策通常都是事后分析才会知道，在当下是无法知道事情到底会如何发展，只有当事情变成了历史，我们再回过头来看这件事时才能真正找到最好的决策方向。&lt;/p&gt;

&lt;p&gt;比如，何时买股票，何时卖股票，何时买房，何时卖房，选择什么专业，该不该和这个人结婚，该不该下海去创业，该不该选择这个人合作，该不该送孩子出国，该报考哪所学校，以及该不该跳槽，应该去哪座城市工作和生活等等等。所有这些都会等你做出决策，并执行多年后，再回过头来梳理时，才能真正明白到底我做对了还是错了。&lt;/p&gt;

&lt;p&gt;为什么是要等事情成为了历史才能知道当时该如何决策，我就不能直接洞悉事情的发展方向做出相应的决策？&lt;/p&gt;

&lt;p&gt;不能。因为世界是变化的。&lt;/p&gt;

&lt;p&gt;我们所处的这个世界里每分每秒都在变化，在这个变化的世界里，我们永远无法知道事情会如何发展，永远无法知道别人到底怎么想（你以为你聪明到能知道所有人的想法时就已经代表你错了），他们到底会怎么做，有多少人会这么想并有多少人会那样做，这所有与之有关的人的行为会给这样事情产生多少影响，又有多少人会因为别人的行为而改变自己的行为方式，你认为就凭你聪明的脑袋能计算的过来么，不可能。&lt;/p&gt;

&lt;p&gt;更何况还有那些与事情有关联的人的关联人，以及与之相关联事情的事情，太多太多，甚至我们都无法知道究竟有多少与之相关联的事情在同时发生，何况在同一时刻这所有关联的人和事都在不断得产生着变化。&lt;/p&gt;

&lt;h6&gt;我们不得不敬畏这个世界，我们永远无法估量，到底有多少事情在影响着我们当下关心的这件事情。&lt;/h6&gt;

&lt;h6&gt;在这个变化的世界里，想做出最正确的选择，是不太可能的，正确的选择只有在回顾历史时才存在。而我们只能就自己的理解做出自己认为最正确的选择。&lt;/h6&gt;

&lt;p&gt;那么做出一个正确的选择真的那么重要吗？不是的。为什么？&lt;/p&gt;

&lt;p&gt;我们退一步说，即使从历史的角度看我们做出了正确的选择，就一定能成功吗？不是。&lt;/p&gt;

&lt;p&gt;首先，即使我们很幸运做出的选择，从历史角度看是最正确的选择，我们也不一定能执行到位。&lt;/p&gt;

&lt;p&gt;实际上，大部分时候连我们自己都不太相信自己做出的决策是对是错，总是在摇摆不定，虽然在表面上坚定的支持这种选择，但在心里还是持有一定的怀疑的态度。这种怀疑的态度，导致我们无法完全百分百的执行我们做出的决策。&lt;/p&gt;

&lt;p&gt;知行合一的难度就在这里，我们到底相信多少我们所知道的。由于人类思维的灵活性以及人性的弱点，我们很难百分百相信我们所知道的一切，永远都在怀疑是否有更好的我们所不知道的存在，所以很难做到相信即行动。&lt;/p&gt;

&lt;p&gt;其次，即使我们很幸运做出了正确的选择，并且很坚决的执行了决策，但成功并不是一个决策而导致的结果，而是由几百几千个决策共同组成的决策群，和，所有为之努力的执行方式的集合组合而成的结果。&lt;/p&gt;

&lt;p&gt;成功的难度就在这里，一个决策并不能决定一个人或一件事的成功与否，成功是由一群决策方向和一群行动方向组合而成，并经过多年累月得到的最终结果。&lt;/p&gt;

&lt;h6&gt;抢到门票就能赢吗？不是的，门票只是一个赛跑的起步优势点并不能决定整场比赛的输赢，别忘了拼命抢到的门票也有可能是一场灾难的开始。&lt;/h6&gt;

&lt;h6&gt;做出‘一个’正确的选择并没有那么重要。重要的是做出选择后的所有其他的选择，以及接下来的所有行动。我们共勉。&lt;/h6&gt;
</description>
               <pubDate>Sun, 31 Mar 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/03/31/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A822.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/03/31/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A822.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第八章 AI(2)-用行为树构建AI</title>
               <description>&lt;p&gt;前面讲了用状态机来构建游戏中的怪物AI，由于它易于理解，容易被人类接受，扩展性和耦合性都很好，所以状态机的用途很广泛。但是状态机也有很大的缺点，就是不能处理和模仿太复杂的智能行为，比如模拟一个人类奔赴一场大型战役中，对战场中的各种繁多的突发事件做出符合人类模式的处理，这种方式状态机就无能为力，由于突发情况太多，组合起来的突发情况更多，做出反应的方式也变化多端，用人类思维逻辑去编写每个状态，状态的数量就会如指数级攀升无法应付，说的直白点就是人类大脑无法应付这么复杂的逻辑编写。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;行为树很好的弥补了状态机的缺点，它简化了逻辑拼凑的方式，让简单头脑的人类能更容易编写和控制机器人的智能行为。这其实也是AI架构的关键点，能够让简单头脑的人类制作复杂的人工智能的行为方式，化繁为简。&lt;/p&gt;

&lt;p&gt;化繁为简是我们的重点，人工智能的行为方式，都是由人类头脑指定的行为方式，是人类头脑所预期的，而非不可控的。制作出人类所预期的AI行为逻辑，制作的方式和过程又在人类大脑的承受范围内的，才是我们需要的。状态机的方式制作AI理论上可以实现任何AI，但复杂到一定程度人脑无法承受，其实就是无效的，或者说失败的。&lt;/p&gt;

&lt;p&gt;行为树的优势就在这里，能够通过一些简单的人类能够应付的操作，制作出达到人类所预期的足够复杂的机器人行为方式。&lt;/p&gt;

&lt;p&gt;下面我们来详细介绍行为树的组成。&lt;/p&gt;

&lt;p&gt;行为树(Behavior Tree)具有如下的特性：&lt;/p&gt;

&lt;p&gt;它有4大类型的N节点：&lt;/p&gt;

&lt;h6&gt;1，Composite Node 复合节点&lt;/h6&gt;

&lt;p&gt;复合节点可详细的分为3种：&lt;/p&gt;

&lt;p&gt;一种是Selector Node，选择节点。当执行本类型节点时，它将从头到尾迭代执行自己的子节点，如果遇到一个子节点执行后返回True则停止迭代，本Node向自己的上层的父节点也返回True，否则所有子节点都返回False，那么本Node向自己的父节点返回False。&lt;/p&gt;

&lt;p&gt;一种是Sequence Node，顺序节点。当执行本类型Node时，它将从头到尾依次迭代执行自己的子节点，如遇到一个Child Node 子节点执行后返回False，那停止迭代，本Node向自己的Parent Node父节点也返回False；否则所有Child Node都返回True，那本Node向自己的Parent Node返回True。&lt;/p&gt;

&lt;p&gt;还有一种是Parallel Node，并发节点，并发执行它的所有Child Node子节点。&lt;/p&gt;

&lt;p&gt;向Parent Node父节点返回的值和Parallel Node所采取的具体策略相关：&lt;/p&gt;

&lt;p&gt;Parallel Selector Node: 执行完所有子节点，有一个False则返回False，全True才返回True。&lt;/p&gt;

&lt;p&gt;Parallel Sequence Node: 执行完所有子节点，有一个True则返回True，全False才返回False。&lt;/p&gt;

&lt;p&gt;Parallel Hybird Node: 执行完所有子节点，指定数量的Child Node返回True或False后才决定结果。&lt;/p&gt;

&lt;p&gt;并行节点提供了并发性，由于它可以在线程或协程级别提供并发操作，所以在性能上面有能够充分利用CPU提高性能。&lt;/p&gt;

&lt;p&gt;通常情况下，Parallel Node下会并行挂多个Action子树，或者挂多个Condition Node以提供实时性。&lt;/p&gt;

&lt;p&gt;Parallel Node增加性能和方便性的同时，也增加实现和维护复杂度。&lt;/p&gt;

&lt;p&gt;除此以外为了进一步提高AI的复杂度和随机性，Selector 和 Sequence可以进一步提供非线性迭代的加权随机变种。比如，Weight Random Selector，每次执行不同的起点，提供了每次执行不同的First True Child Node的可能。而Weight Random Sequence则每次执行顺序不同，提供了不同的迭代顺序的方式。这在AI术语中称为partial-order，能使AI避免总出现可预期的结果，让结果更加的随机化。&lt;/p&gt;

&lt;h6&gt;2，Decorator Node 修饰节点&lt;/h6&gt;

&lt;p&gt;Decorator Node，它的功能正如它的字面意思：它将它的Child Node执行后返回的结果值做额外修饰处理后，再返回给它的Parent Node。比如反向修饰Decorator Not：将结果反置后返回上级处理，失败修饰Decorator FailUtil：将失败修改后返回上级处理，计数修饰Decorator Counter：将结果计数后返回上级处理，时间修饰Decorator Time：将时间修改后返回上级处理。也可以作为日志处理Decorator Log，动画修饰处理Decorator Animation，甚至Decorator Nothing什么都不干。&lt;/p&gt;

&lt;h6&gt;3，Condition Node 条件节点&lt;/h6&gt;

&lt;p&gt;Condition Node相对比较简单，条件满足则返回Ture，否则返回False。&lt;/p&gt;

&lt;p&gt;各式各样的条件节点，都继承基础条件节点并且返回Ture或False。&lt;/p&gt;

&lt;p&gt;比较常用的条件节点例如，血量判断条件，距离判断条件，状态判断条件，时间间隔判断条件等。&lt;/p&gt;

&lt;h6&gt;4，Action Node 行动节点&lt;/h6&gt;

&lt;p&gt;Action Node，通常都是最后的叶子节点，它完成具体的一次(或一个step)的行为，视需求返回值。&lt;/p&gt;

&lt;p&gt;Action Node可以是执行一次的，也可以视为分步执行很多次的行为。例如，向前进这个行为，可以一直被执行，直到条件不满足。&lt;/p&gt;

&lt;p&gt;也就是说，通过扩展Action Node完全可以不需要借助外在程序或接口，自主定义角色行为。&lt;/p&gt;

&lt;p&gt;常用的Action Node节点的例如，行走到目标地点Action，跟踪目标Action，转换角色方向Action，撤退Action，攻击Action，防御Action，释放技能Action等等。&lt;/p&gt;

&lt;h6&gt;在行为树中任何Node被执行后，必须向其上层的父节点报告执行结果：成功True或失败False。这简单的成功或失败汇报原则被很巧妙地用于控制整棵树的决策方向。&lt;/h6&gt;

&lt;p&gt;行为树能够支撑起对复杂逻辑的AI的原因就是由于使用了这些简单的节点去搭建整个AI模型。由于人脑可以很容易的写出这些简单的单个节点的逻辑，使得节点的功能性扩展变得非常容易，而拼装这些节点，就像是一个搭积木的过程，人脑能搭建多复杂的积木，就能搭建起多复杂的AI。&lt;/p&gt;

&lt;p&gt;整棵行为树中，只有Condition Node和Action Node才能成为Leaf Node叶子节点，而也只有Leaf Node才是需要特别定制的Node。而Composite Node和Decorator Node均用于控制行为树中的决策走向。所以有些资料中也统称Condition Node和Action Node为Behavior Node行为节点，而Composite Node和Decorator Node为Decider Node决策节点。&lt;/p&gt;

&lt;p&gt;在行为树之前，还有决策树这个被遗忘了的AI解决方案。决策树和行为树一样都是树形结构，都是由节点构成。决策的构成是由树形结构的头部开始，从上往下一路判断该往哪走，最后一定会执行到叶子节点，在决策树中只有叶子节点才决定了如何行动，而且在决定后的行动中，无法中途退出，要等到档次行为执行完毕或者被打断后才能开始下一次决策。&lt;/p&gt;

&lt;p&gt;从理念上讲，决策树就是为了制定决策，而行为树是为了控制行为，是两个不同的理念，行为树更加注重变化，而决策树则注重选择。因此行为树可以定制比决策树更加复杂的AI逻辑，而实现的难易程度行为树并没有增加多少，所以决策树被冷落也是情理之中。&lt;/p&gt;

&lt;h6&gt;行为树比状态机更容易编写复杂的AI逻辑就是由于单一节点的易扩展性，以及整个AI树的可搭建能力都是在人脑的可及范围内。但是，再厉害的人脑也有搭建复杂度的极限，无论你对搭建行为树这项技能有多么精通，都有到一个极限的状态，也就是搭建的复杂度超出人类大脑的时候，人类就完全无法继续搭建了，或者说无法完成。例如，如果想完全模拟人类的思维判断逻辑，对不同的人，对不同的事，对不同的景色，对不同的物体，不同的路面，以及以上混合组合的不同组合，就完全超出了人类大脑搭建的极限。像这种特别复杂，完全不能由人类大脑自主搭建的方式形成的AI，就需要引入‘机器学习’这个概念了。由于情况太多，太复杂，唯有‘机器自主学习’才能适应这些复杂的情况时，‘Machine learning机器学习’，‘Deep learning深度学习’，‘Artificial Neural Network神经网络’，就成了解决这些问题的方案。&lt;/h6&gt;

&lt;p&gt;参考:&lt;/p&gt;

&lt;p&gt;《使用行为树(Behavior Tree)实现游戏AI》by AKara 2010&lt;/p&gt;
</description>
               <pubDate>Thu, 28 Mar 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/03/28/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-AI2.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/03/28/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-AI2.html</guid>
            </item>
        
            <item>
               <title>思路探讨(二十一) 生存之战</title>
               <description>&lt;p&gt;22周岁毕业，在杭州工作了4年，26岁带着不甘的心独自去了上海，27岁结了婚，28岁有了第一个孩子，29岁第二个孩子降临，今年要32周岁了。从毕业到现在过去了10个年头，有时偶尔回头望去觉得是精彩的，不过精彩的并不是结果，而是这10年里拼搏的过程，那种奋力前行用尽全力突破自我的精神和逆流而上明知山有虎偏向虎山行的勇气。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;这种勇气和精神，来自于我的内心，不甘心成为一个平庸的人的意识形态，我不愿意自己每天妥协过着看不到尽头的无奈日子，我希望自己改变自己，改变成为自己心中的那个非常强大的人。&lt;/p&gt;

&lt;h6&gt;还没有孩子前我只为我自己奋斗，那时我觉得这样的动力已经很足够了，但我还是too young too naive，在有了孩子后，特别是有第二个孩子之后，我彻底清醒的认识到我过去的行动和能力都是小儿科级别的。&lt;/h6&gt;

&lt;p&gt;特别是最近我读了《富兰克林自传》、《居里夫人自传》、《稻盛和夫自传》、《韩信传》、《林肯传》这些名人传记后，生存的严肃性再次深刻的、深切的、深不见底的印在我记忆的肌肉里。&lt;/p&gt;

&lt;h6&gt;他们都是严肃生活的典范，他们专心，专业，努力，奋力，认真得经营着自己，包括身体、知识、思想、家庭。他们并不埋怨环境，而是改变自己，他们知道环境无法改变，只有改变自己。因此在恶劣的环境下他们任然保持自己前进的节奏，虽然偶尔被环境所打断，甚至被迫害，但他们依然能够不断调整自己回到最初的状态，尽管时常也陷入巨大的瓶颈，但多大的苦难和瓶颈都没能挡得住他们突破自己的步伐。&lt;/h6&gt;

&lt;p&gt;对比我自己，我还是太稚嫩，严肃的不够严肃，认真得不够认真，对生活没有一个清醒的彻底的完全的认识，时常有’休息一下也没事‘、’一天不努力也可以‘、’明天再学也不迟‘的行为和想法，导致原本制定的计划，或者良好的生活习惯，或者良好的学习习惯被一点点侵蚀，最终导致自律能力彻底丧失，彻底沦为浪费时间浪费生命的大懒虫。&lt;/p&gt;

&lt;p&gt;我再次回忆我这年轻的岁月里，浪费了有多少的时日时，时常感叹如果我能早点知道该有多好。&lt;/p&gt;

&lt;h6&gt;不过幸好，每次有这种’早点知道该有多好‘的感叹时，我明白为时还不晚，因为有很多智者都提醒过我，任何时候只要你意识到正确道路的方向时为时都不晚。虽然这些智者我都没见过，他们都存在于书中，广播中，视频中，但却时常能够起到提醒我的作用。&lt;/h6&gt;

&lt;p&gt;正确的道路确实难走，所以人才会跟随人性弱点去选择舒适的但错误的道路。&lt;/p&gt;

&lt;h6&gt;生存之战就是谁能长时间的、长期的、长久的、更长时间的、更长期的、更长久的走在正确道路上的无形的战争。&lt;/h6&gt;

&lt;p&gt;每个人在战争中都走的是自己的路并平行于他人，从来都不跟别人碰撞，但每一步都有好有坏，而每个步都有他们自己来决策。&lt;/p&gt;

&lt;p&gt;让人感到意外又不十分惊奇的是，很多人并不知道他们已经决策了自己的路，他们甚至以为生活的决策是有个缓冲期的，会给到具体的问题和正确的答案。&lt;/p&gt;

&lt;h6&gt;生存之战的残酷性就在这里，它的决策之路很少有具体的标志性的事件或者缓冲期，甚至连问题和答案都没有，所有的人生道路的决策都是由生活中的一言一行，一举一动拼凑而成的。&lt;/h6&gt;

&lt;p&gt;你是怎么生活的，你就是怎么决策着你的道路，容不得我们半点侥幸。根本不会出现，例如有个决策能一下子完全彻底的改变你的人生道路的东西出来，所有你走出来的道路都是由你生活的点滴组合而成，所有导致事件发生的都是由你先前的生活中一举一动的积累导致的量变引起的质变。&lt;/p&gt;

&lt;p&gt;人们口中时常说的残酷是由于人多或者需求多而供应少导致的，我觉得生存之战的残酷比它这种残酷要残酷一百倍。&lt;/p&gt;

&lt;p&gt;生存之战的残酷是没有硝烟的，是看不见摸不着的，但却时时刻刻在战斗，更残酷的是，并不是战斗一年两年就结束的，而是10年，20年，30年，40年，50年，一辈子。直接说一辈子太突兀，所以用前面的数字来做铺垫会让人好受些。&lt;/p&gt;

&lt;p&gt;一辈子持久战的残酷性，我想是我们这个和平年代下最最残酷的残酷战争了吧。&lt;/p&gt;

&lt;h6&gt;我希望能用这篇文章来告知同僚们，提高警惕并且奋斗，这是场最长的持久战，记得身体是第一关键因素，谁在持久战中身体先垮掉谁就第一个败下阵，因此每天运动保持身体免疫系统正常工作是第一要素。有了身体还不够，还要有知识、有技能、有多维度的思维方式、有育人的技巧、有沟通能力、有经验等等等，等着我们去征服。&lt;/h6&gt;

&lt;h6&gt;面对生存之战，需要我们勇敢面对严肃的生活，在严肃的生活中，别放弃，别太多沮丧，哭完了我们继续上！&lt;/h6&gt;
</description>
               <pubDate>Sun, 17 Mar 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/03/17/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A821.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/03/17/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A821.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第八章 AI(1)-状态机构架机器人行为</title>
               <description>&lt;p&gt;AI机器人在游戏中非常普遍，它们常以模仿人类的行为在游戏中活动。游戏中的怪物的自动行为比较普遍，这种简单的人工智能方式可以用几种不同的方式进行编写，这里我们介绍两种方式，一种为容易被人类思维接受的状态机AI编程，另一种为特别为机器人思考方式编写的行为树AI编程。其实还有很多方式来编写AI，比如和行为树差不多的决策树，以及相对比较复杂的神经网络，以及更复杂的机器学习，在此不多做介绍，由于过于复杂甚至超过了项目的周期，研发和维护成本太高，所以在游戏中的应用并不太多，很少有人尝试。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h3&gt;AI-状态机&lt;/h3&gt;

&lt;p&gt;状态机虽然是个比较简单的概念，但在实际编程中花样也是繁多的，不过最终都是围绕着状态这个基础变量来做变化的。&lt;/p&gt;

&lt;p&gt;状态机最符合人类思考的方式，我们喜欢把事物以状态形式进行拆分成：当前状态，前置状态，下一个状态，状态变化需要的条件等。其中每个状态都有自己定义，比如行走，蹲下，躺下，攻击，防守，三连击，俯冲，左移，右移等。&lt;/p&gt;

&lt;p&gt;人们习惯把人或动物的某些连贯的行为定义为状态，所以状态其实不只是一个动作，它可以是好几个动作，或者好几段位移，也就是好几段执行程序。&lt;/p&gt;

&lt;p&gt;这种好几个动作和好几段位移一起组成的组合，在程序中用状态来表示最符合逻辑。每种状态下不只是一个动作或一种位移，而是由很多个动作多段位移组合而成。&lt;/p&gt;

&lt;p&gt;在游戏里，智能的机器人由于都是人设计出来的，行为方式也最符合人类的逻辑，所以状态机的方式制作AI最符合人类思维，也最容易被接受。&lt;/p&gt;

&lt;p&gt;从面向程序的角度来看，状态可以从父类构建开始，并且向不同的方向继承并衍生，最终再把所有的状态类集中到控制状态的状态控制器中。&lt;/p&gt;

&lt;p&gt;下面我们就以图和文的方式构建一个 AI 状态机：&lt;/p&gt;

&lt;p&gt;我们以 AIStateBase 为状态基础类，基础类中有一个识别状态类的变量，可以是整数，也可以是枚举，和三个必要的接口，更新函数 Update() ，进入状态事件引发的事件函数 OnEnter()，退出状态事件引发的事件函数 OnExit()。这三个函数足以概括状态的出、入、以及自我循环更新三个动作，状态机定义下也只有这三个动作可以做。&lt;/p&gt;

&lt;p&gt;接下来，我们开始扩展状态机的功能，以跑步动作状态为例：&lt;/p&gt;

&lt;p&gt;在进入跑步动作状态时，表现为，机器人有跑步动画，并且向前移动。&lt;/p&gt;

&lt;p&gt;实现跑步状态，首先继承父类 AIStateBase 并且把跑步状态类命名为 AIRunState。然后再对 AIRunState 进行编写，在进入状态时也就是 OnEnter 函数中编写机器人播放跑步的动画并让动画不断循环播放，然后在更新函数 Update 中开启不断向前移动的位置变化。当不再需要移动时，也就是退出跑步状态事件中，OnExit 里调用停止播放动画，也可以不停止播放，因为下一个状态肯定会播放其他动画，不如让他们插值过度下动画看起来会更顺滑。&lt;/p&gt;

&lt;p&gt;实现了跑步状态，可以引申出其他和它基本相同的状态，它们可以完全按照跑步状态的方式实现，比如后退，侧移，漫步，打坐，跳跃，攻击等，它们都是只用到播放自身动画和持续位移组合的方式完成状态。对其他复杂状态来说，算是比较基本的状态。&lt;/p&gt;

&lt;p&gt;现在我们来实现稍微复杂点的状态‘追击’状态。追击中有两个动作，一个是追，一个是攻击，不止是这些，我们还必须首先锁定目标，然后寻找追击的路径。当怪物进入‘追击’状态时，会锁定目标，然后不断向目标跑去，当跑到攻击范围内时，进行攻击。&lt;/p&gt;

&lt;p&gt;我们定义一个‘追击’状态类，AIAttackState 类同样继承 AIStateBase。当‘追击’状态开始时，进入 OnEnter 函数时先锁定目标，把目标保存下来，并且寻找追击目标的路径 Path Find，寻路解决方案会在地图与寻路章节中详细介绍。接下来就是‘追击状态’的更新函数，每帧都会调用更新函数 Update，在Update中，检查目标是否已在攻击范围内，如果是则立刻播放攻击动画，并且调用目标的伤害接口使目标受伤，如果不在范围内则检查锁定目标是否移动，如果有移动就重新寻找路径，并且根据路径来进行位移。整个追击状态，在追击中都是在 Update 函数中不断判断和位移的。&lt;/p&gt;

&lt;p&gt;追击状态以追和攻击为主要行为。与追击状态类似的，也比较常用的还有‘巡逻状态’，当怪物进入这个‘巡逻状态’时，怪物会在一个范围内到处行走以查看敌人是否在周围，如果在视野范围内查看到敌人，则退出巡逻状态，进而进入追击状态。&lt;/p&gt;

&lt;p&gt;我们来看看编写‘巡逻状态’的步骤。当进入‘巡逻状态’时，状态进入 OnEnter 函数，在 OnEnter 里找到最近的一个巡逻点，然后在更新函数 Update 中持续循环走向最近的巡逻点，当走到第一个最近的巡逻点后继续按照巡逻点的布置顺序继续往下一个巡逻点走，如此不断循环往复。同时更新每次移动时，都检查一下敌人是否在范围内，如果有敌人在检查范围内，当前‘巡逻状态’就结束，OnExit 被调用，转而进入‘追击状态’。&lt;/p&gt;

&lt;p&gt;至于‘追击状态’返回‘巡逻状态’的条件可以设置为，当追击太远时重新转入’巡逻状态‘，比如在进入’追击状态‘ OnEnter 函数里记录起始追击位置，每次移动时都判断下，与起始位置的距离是否太远，如果太远则退出当前的’追击状态‘转而进入’巡逻状态‘。&lt;/p&gt;

&lt;p&gt;游戏策划常设计Boss怪物进入‘疯狂状态’，例如，这个怪物突然变身，然后开始疯狂得从天空里召唤火球，这些火球像流星一般撞向地面，爆炸，并在爆炸范围内敌人受到伤害，结束后怪物又回到了普通的’追击状态‘。&lt;/p&gt;

&lt;p&gt;我们来分析下这个’疯狂状态‘如何编写。当进入’疯狂状态‘时，状态类被调用进入状态事件函数 OnEnter ，函数里播放立刻Boss怪物的变身动画，因为 OnEnter 只调用一次，所以所有检查都在更新函数 Update 里进行，Update 中检查变身动画结束时更换怪物的模型为变身后的新模型，因为需要新模型播放自己的动画所以必须更换。紧接着更换完变身后的模型后，就用新的模型播放施法动画，同时不断按次序调让火球出现在上空的某个位置，并持续移动向地面，当火球的物理引擎检测碰撞到地面时，销毁火球并生成爆炸特效，同时在爆炸位置范围内，查找到是否与爆炸位置距离小于某个值的敌人，如果有则调用敌人的受伤接口使其受伤。当检测到所有火球都已经爆炸完毕，则完成了此次’疯狂状态‘，退出并转向’追击状态‘。&lt;/p&gt;

&lt;p&gt;无论多少复杂的技能或者行为，都能在一个状态中体现出来，以状态形式的编写好用就在这里。有了众多复杂的状态还不够，我们还需要有控制这些状态的状态控制器。&lt;/p&gt;

&lt;p&gt;状态控制器就是记录，这些状态的状态管理类，我们可以命名为 StateControl类，所有状态都在 StateControl 里有一份实例，而且状态控制器记录了一个变量是当前是什么状态，由于所有状态都是继承与 AIStateBase，所以这个当前状态变量可以为 AIStateBase 以支持所有类型的状态类。又由于所有的状态类的对外接口都是统一，所以只需要基类就能操作所有状态，而且状态的转换也完全可以各自状态的本身来决定。状态控制器，只是起到了对状态实例管理和转换的工具，所以状态控制器没有太多了的逻辑，所有AI逻辑都放在了每个状态类里面，由每个从 AIStateBase 父类继承而来的AI子类来决定如何行动，这种做法大大降低了逻辑的耦合，让代码逻辑更加清晰，维护性强，扩展性强。&lt;/p&gt;

&lt;h6&gt;用状态机编写AI有诸多优点，诸如可维护性强，可扩展性强，逻辑耦合清晰，符合人类思维逻辑易上手。但缺点也很大，由于每个状态都必须由设计人亲自制定，所以在每个状态时编写时要考虑到所有情况，每种情况都要有自己的处理方式，这样就导致当需要设计的AI行为过于复杂的时候，编写的逻辑复杂度和工期长度也呈现指数级的增长，到最后有可能无法承受太复杂的AI行为逻辑，比如人类在战场中的随机应变能力，对于各种各样的爆炸，攻击，冲锋，防御的应变能力需要表现出各种不一样的行为方式时，如果任然用状态机来编写，就会很容易陷入超出人类逻辑的复杂度。&lt;/h6&gt;
</description>
               <pubDate>Sun, 10 Mar 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/03/10/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-AI1.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/03/10/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-AI1.html</guid>
            </item>
        
            <item>
               <title>YOU CAN LIVE YOUR DREAM!</title>
               <description>&lt;p&gt;I don’t know what that dream is that you have.&lt;/p&gt;

&lt;p&gt;I don’t care how disappointing it might have been, as you’ve been working towards that dream.&lt;/p&gt;

&lt;p&gt;That the dream that you’re holding in your mind … that it’s possible.&lt;/p&gt;

&lt;p&gt;That some of you already know that its hard… it’s not easy. Its hard changing your life.&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;That in the process of working on your dreams you are going to incur a lot of disappointment … a lot of failure … a lot of pain … there are moments when you’re going to doubt yourself … and say “ God why? why is this happening to me? I’m just trying to take care of my children and my mother I’m not trying to steal or rob from anybody. How did this have to happen to me ?”&lt;/p&gt;

&lt;p&gt;For those of you that have experienced some hardships, don’t give up on your dream.&lt;/p&gt;

&lt;p&gt;There are rough times that are gonna come but they have not come to stay, they have come to pass.&lt;/p&gt;

&lt;p&gt;Greatness is not this wonderful esoteric, elusive, god like feature that only the special among us will ever taste … it’s something that truly exists in all of us.&lt;/p&gt;

&lt;p&gt;It’s very important for you to believe, that you are the one.&lt;/p&gt;

&lt;p&gt;Most people, they raise a family, they earn a living and then they die.&lt;/p&gt;

&lt;p&gt;They stop growing… they stop working on themselves, they stop stretching, they stop pushing themselves.&lt;/p&gt;

&lt;p&gt;And a lot of people like to complain but they don’t want to do anything about their situation, and most people don’t work on their dreams.&lt;/p&gt;

&lt;p&gt;why? One is because of fear, the fear of failure… “what if things don’t work out?” And the fear of success… “what if they do and I can’t handle it?”. These are not risk takers.&lt;/p&gt;

&lt;p&gt;You spend so much time with other people, you spend so much time trying to get people to like you, you know other people more than you know yourself, you study them… you know about them, you wanna hang out with them, you wanna be just like them.&lt;/p&gt;

&lt;p&gt;And you know what you’ve invested so much time into being like them you don’t know who you are, I challenge you to spend time by yourself.&lt;/p&gt;

&lt;p&gt;It’s necessary that you get the losers out of your life, if you want to live your dream.&lt;/p&gt;

&lt;p&gt;For people who are running towards their dreams, life has a special kind of meaning.&lt;/p&gt;

&lt;p&gt;When you become the right person, what you do is you start separating yourself from other people, you begin to have a certain uniqueness.&lt;/p&gt;

&lt;p&gt;As long as you follow other people and as long as you’re being a copy cat you will never ever be the best copy cat in the world. But you will be the best you can be.&lt;/p&gt;

&lt;p&gt;I challenge you to find your value. That everybody won’t see it, that everybody won’t join you, that everybody won’t have the vision, it’s necessary to know that. That you are an uncommon breed.&lt;/p&gt;

&lt;p&gt;It’s necessary that you align yourself with people and attract people into your business who are hungry.&lt;/p&gt;

&lt;p&gt;People who are unstoppable and unreasonable, people who are refusing to live life just as it is and who want more.&lt;/p&gt;

&lt;p&gt;The people that are living their dream are finding winners to attach themselves to. The people that are living their dreams, are the people that know that if it’s gonna happen it’s up to them.&lt;/p&gt;

&lt;p&gt;If you wanna be more successful, if you wanna do and have stuff that you have never had before, I’m asking you to invest in you.&lt;/p&gt;

&lt;p&gt;Someone’s opinion of you does not have to become your reality … that you don’t have to go through life being a victim. And even if you have to face disappointment, you have to know within yourself, I can do this even if no one else sees this in me I must see it for myself.&lt;/p&gt;

&lt;p&gt;Because you’re still talking about your dream … you’re still talking about your goal …you’ve not done anything … just take the first step … you can touch millions of peoples ‘ lives … and the world will never be the same again … because you came this way.&lt;/p&gt;

&lt;p&gt;Don’t let nobody steal your dreams. If you face a rejection or a no, if you hold a meeting and nobody shows up, if someone says ” you can count on me ” and they don’t come through.&lt;/p&gt;

&lt;p&gt;What if we have that kind of attitude, a cause repossessed, nobody believes in you … you’ve lost again, and again, and again, the lights are cut off … but you’re still looking at your dream, renewing it every day and saying to yourself it’s not over… UNTIL I WIN !&lt;/p&gt;

&lt;p&gt;YOU CAN LIVE YOUR DREAM!&lt;/p&gt;

&lt;h3&gt;Copy from google&lt;/h3&gt;
</description>
               <pubDate>Tue, 19 Feb 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/02/19/you-can-live-your-dream.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/02/19/you-can-live-your-dream.html</guid>
            </item>
        
    </channel>
</rss>