<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title></title>
        <description>技术，哲学，金融</description>
        <link>http://www.luzexi.com</link>
        <atom:link href="http://www.luzexi.com/assets/feed.xml" rel="self" type="application/rss+xml" />
        
            <item>
               <title>向内看自己(十) 反思自己的行为带给人的感觉</title>
               <description>&lt;p&gt;最近发现自己的行为和话语给别人的感觉很不好，这源于我自身的性格问题。&lt;/p&gt;

&lt;p&gt;我有很多性格问题，导致生活中、工作中在与人交往过程中就会遇到障碍或瓶颈。&lt;/p&gt;

&lt;p&gt;我很想弄清楚我到底出了什么问题，但一直没弄明白，于是我想好好剖析一下自己。&lt;/p&gt;

&lt;p&gt;也因为最近在学习冥想，这个看起来有点玄乎的词语，是我最近研究的内容，我会专门写一篇文章来详细说明我对它的理解与感受。&lt;/p&gt;

&lt;p&gt;我发现冥想最大的益处就是让我忽略杂念专注于当前所做的事，在专注过程中不断发现当前事物中以前没有被我发现的细节，这些细节很多时候都是关键中的关键。&lt;/p&gt;

&lt;p&gt;当然最重要的也是最大的问题是我自己本身，于是我边练习冥想技巧边来发现自己的问题。&lt;/p&gt;

&lt;p&gt;自身问题一，我常常会去要求别人却没有用心体会对方的感受，慢慢会引起别人的反感。&lt;/p&gt;

&lt;p&gt;自身问题二，我常常会以炫耀的口吻讲述自己的经历和想法，让对方感觉不愉快。&lt;/p&gt;

&lt;p&gt;自身问题三，我常常会想妥协而装做一副顺从的样子，让别人有了更多负担，也让事情进展有些尴尬。&lt;/p&gt;

&lt;p&gt;自身问题四，我常常心急如焚想立刻搞定某事而选择比较激进的做法，让人会觉得我不靠谱，或者不尊重他们。&lt;/p&gt;

&lt;p&gt;自身问题五，与人交流成为我了的负担，我宁愿自己辛苦点去搞定也不愿意或者说恐惧与人打交道。&lt;/p&gt;

&lt;p&gt;即使我知道这些问题的存在，我仍然不知道该如何去改进，因为我没有找到解决问题的方向。&lt;/p&gt;

&lt;p&gt;就像上学时一直喜欢玩耍没有好好学习一样，我知道好好学习的重要性，但就是坐不下来安静学习。&lt;/p&gt;

&lt;p&gt;我觉得是因为我没有get到某个点。这和我现在所面临的问题有点相似，明知道有问题，明知道该如何如何去做，但就是做不到。&lt;/p&gt;

&lt;p&gt;很多时候我们都是撞的很痛了才下定决心去改，但这时通常已经很迟了，我不想每次都等到我痛到骨子里了才去改。&lt;/p&gt;

&lt;p&gt;于是我问自己，我需要get什么点？&lt;/p&gt;

&lt;h4 id=&quot;我回忆了下长大成人后喜欢上了自律和学习的过程我为什么会有转变我是怎么转变过来的&quot;&gt;我回忆了下，长大成人后喜欢上了自律和学习的过程，我为什么会有转变，我是怎么转变过来的。&lt;/h4&gt;

&lt;h4 id=&quot;我依稀记得长大成人后逐渐喜欢上学习的起点是因为我第一次获得学习上的成就感开始的可能这个成就感是非常微不足道的一点点但足以敲开了我对此感兴趣的大门随着我不断深入研究慢慢的我被一次次的成就感所激励着不断前进许多正向的反馈在我的生活中不断冒出中间也有些许负向的反馈但由于相对正向反馈来说量少我还能克服它们&quot;&gt;我依稀记得，长大成人后，逐渐喜欢上学习的起点，是因为我第一次获得学习上的成就感开始的，可能这个成就感是非常微不足道的一点点，但足以敲开了我对此感兴趣的大门。随着我不断深入研究，慢慢的我被一次次的成就感所激励着不断前进，许多正向的反馈在我的生活中不断冒出，中间也有些许负向的反馈，但由于相对正向反馈来说量少我还能克服它们。&lt;/h4&gt;

&lt;h4 id=&quot;这个过程中最重要的是第一次正向反馈当我感觉到自己的努力有了回报我就更感兴趣去深入研究它们如果在开始的时候一次次又一次的正向反馈不断袭来我就能感觉到我自己找对了方法就像找到了金钥匙那样不断向这个方向前进直到遇到更大的瓶颈当遇到更大的瓶颈时我则需要更换思路和方法如果没有找对思路和方法则会继续原地踏步常常会因为原地踏步时间太久而感到沮丧和气馁因此而懈怠并且开始退步&quot;&gt;这个过程中最重要的是第一次正向反馈，当我感觉到自己的努力有了回报，我就更感兴趣去深入研究它们。如果在开始的时候，一次次又一次的正向反馈不断袭来，我就能感觉到我自己找对了方法，就像找到了金钥匙那样，不断向这个方向前进，直到遇到更大的瓶颈。当遇到更大的瓶颈时，我则需要更换思路和方法，如果没有找对思路和方法，则会继续原地踏步，常常会因为原地踏步时间太久而感到沮丧和气馁，因此而懈怠并且开始退步。&lt;/h4&gt;

&lt;h4 id=&quot;想到这里我想着能不能根据这个途径先去找些改善的行动项做起来从而获得正向反馈再根据这个正向反馈来一步步改善我的行为&quot;&gt;想到这里，我想着能不能根据这个途径，先去找些改善的行动项做起来，从而获得正向反馈，再根据这个正向反馈来一步步改善我的行为。&lt;/h4&gt;

&lt;h4 id=&quot;这当然是很难的起步的时候更是艰难特别是第一次的正向反馈可能需要一段比较长时间的积累我需要保持耐心维持改善行为好一阵&quot;&gt;这当然是很难的，起步的时候更是艰难，特别是第一次的正向反馈可能需要一段比较长时间的积累，我需要保持耐心维持改善行为好一阵。&lt;/h4&gt;

&lt;h4 id=&quot;路漫漫其修远兮吾将上下而求索&quot;&gt;路漫漫其修远兮，吾将上下而求索。&lt;/h4&gt;

&lt;h3 id=&quot;希望大家一起加油同我一样来改善自己&quot;&gt;希望大家一起加油同我一样来改善自己​&lt;/h3&gt;

</description>
               <pubDate>Sat, 21 Nov 2020 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2020/11/21/%E5%90%91%E5%86%85%E7%9C%8B%E8%87%AA%E5%B7%B110</link>
               <guid isPermaLink="true">http://www.luzexi.com/2020/11/21/%E5%90%91%E5%86%85%E7%9C%8B%E8%87%AA%E5%B7%B110</guid>
            </item>
        
            <item>
               <title>读书笔记(十四) 《深度探索C++对象模型》</title>
               <description>&lt;p&gt;看此书的起因是自己想更加深刻的了解底层，最底层的莫不过于汇编了，但只有汇编还不够，因为它需要上层工具语言编译器的支持，编译器怎么去编译程序的，决定了汇编的执行方向，理论上说汇编只是执行编译器编译后的程序内容，因此我认为编译器是关键所在。&lt;/p&gt;

&lt;p&gt;我们大多数人自认为自己已经把面向对象语言已经烂熟于心了，其实台面下的机制，如编译器合成的默认构造函数、对象内存布局等都不是很了解。我也是一样，我对编译器一块知识一直不是清晰，所以想通过这本书来了解我们平时编程时的底层的工作原理是什么。&lt;/p&gt;

&lt;p&gt;作者说第一句话就打动了我，让我认真看完了全书，他说“我的经验告诉我，如果一个程序员了解底层实现模型，他就能够写出效率较高的代码，自信心也比较高。一个人不应该用猜的方式，或者等待某位大师的宣判，才确定何时提供一个copy constructor 而何时不需要。这类问题的解答应该来自于我们自身对对象模型的了解。“&lt;/p&gt;

&lt;p&gt;不管我们是在使用C#、Java、C++，它们都是面相对象的编程语言，因此底层的原理都会有些相似性，特别是内存布局上。我也是抱着这种用C++内存布局去理解其他语言的心态去学习和研究这部分内容的。&lt;/p&gt;

&lt;h2 id=&quot;对象的内存布局&quot;&gt;对象的内存布局&lt;/h2&gt;

&lt;p&gt;一个普通的class，有成员变量、成员函数，静态变量，静态函数，关于它们我们可以话一张图，拿一个简单的Point来举例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	class Point

	成员变量 float x

	成员函数 int PointCount()

	静态变量 static int sMaxCount

	静态函数 static int GetMaxCount()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假如我们实例化一个Point，即 Point * pt = new Point，Point的内存中为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	float x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没错，内存中只有一个浮点数变量的空间大小，那么其他的包括成员函数、静态变量、静态函数都不在Point实例内存中，它们在哪呢？&lt;/p&gt;

&lt;h4 id=&quot;它们被编译器编写在了代码段和数据段中可以被所有point实例共享的内存使用&quot;&gt;它们被编译器编写在了代码段和数据段中，可以被所有Point实例共享的内存使用。&lt;/h4&gt;

&lt;p&gt;我们知道一个可执行程序的内存分布，分为数据段、代码段、栈段，这三个基本都是静态不会被改变的空间段，其他还有中断表、堆内存空间等。&lt;/p&gt;

&lt;p&gt;class的成员函数、静态函数无论是否public还是private修饰，都会被放入代码段中，静态变量则被放入数据段中无论是否public还是private(放入数据段中的内容，每次取值都会做远距离寻址，相对近距离寻址会费一些，因为隔断了内存连续操作)，而成员变量例如Point中的x，无论它是public还是private都会被放入动态内存分配的内存块中。&lt;/p&gt;

&lt;p&gt;实际上计算机内存中、以及机器码中没有public和private之分，我们可以任意的取得任何内存中的内容没有限制，限制我们程序访问的，只是语言和编译器的语法检查器这两者为我们提供的语言方法和规则检查。&lt;/p&gt;

&lt;h4 id=&quot;当class有继承和多态后则有所不同&quot;&gt;当class有继承和多态后则有所不同&lt;/h4&gt;

&lt;p&gt;当class有了继承后，通常都会有多态出现，即虚函数。让我们来举个例子说明：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;class Point
{
public:
	float x;
	virtual int PointCount();
}

class Point2D : public Point
{
public:
	float y;
	virtual int PointCount();
	virtual void PrintPoint();
}

Point pt = new Point2D();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加上继承和多态后，内存布局就有所变化，由于基类和子类都有虚函数，子类重载了函数后，我们在内存中就需要有一张表来存放所有虚函数，以便正确调用。&lt;/p&gt;

&lt;p&gt;如上Point和Point2D的关系，可以将一个Point2D实例内存看作如下结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	- virtual table 虚表地址 --------&amp;gt;   Point2D的虚表空间
										- PointCount()地址
										- PrintPoint()地址
	- x
	- y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和普通class不同的是，当我们有了多态后，我们的一个实例内存中除了数据外，还多了一个变量指向这个类的虚表空间，这个虚表空间已经被编译器编写在了数据段中，是一个静态的并且专门为Point2D制定的空间，这个空间中存放着指向类中所有虚函数地址，空间不会随着多个实例化而增多因为它只有一个，但每个Point2D实例的虚表指针指向着它（Point实例也是类似的内存布局）。&lt;/p&gt;

&lt;p&gt;（这里不得不讲一下struct和class的区别，其实它在不同语言中的语义和用途不太一样，在C++中可能大部分struct都是用来兼容c或当纯数据的内存结构的，很多class有的功能struct也同样能实现，但在其他语言则不同，比如在C#中的用途就是期望struct能更多的做些内存连续优化，因为它是复制类型数据结构，每次赋值和传递参数都会复制一份内存，除非使用引用关键字。）&lt;/p&gt;

&lt;p&gt;此时如果是Point实例则是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	- virtual table 虚表地址 --------&amp;gt;   Point的虚表空间
										- PointCount()地址
	- x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与Point2D相比，少了一个y变量，以及虚表空间中少了一个函数地址。&lt;/p&gt;

&lt;p&gt;(编译器编译中很多时候都会将许多我们看来是动态的访问变为静态，例如子类的强制转换(其实内存上没有做任何操作，只是通知编译器后面的操作是基于某个类开始的，使得编译器在编译时偏移地址较前面有所不同)、前面Point中的静态函数（程序在执行时就会直接跳到代码段的GetMaxCount这个函数的地址上而不会通过实例内存去找）、Templete会在编译期就将代码和指令生成完毕，以及一些编译器对代码的优化会直接将某个公式计算好以数字的形式呈现在机器码里，还有很多排错机制，其实编译器帮我们干了很多本该我们需要检查和手动指定的工作。)&lt;/p&gt;

&lt;p&gt;多重继承的内存布局更为复杂些，会带有好几个虚表地址在内存中，效率也更差，因为每一层的虚表都会间接性降低把处理搬到寄存器执行的优化，我们也不鼓励多重继承的写法，因此这里不做详细讲解。&lt;/p&gt;

&lt;h4 id=&quot;实例化后的类大小真的只有变量大小的总和加一个虚标指针吗还有内存对齐的规则&quot;&gt;实例化后的类大小真的只有变量大小的总和，加一个虚标指针吗？还有内存对齐的规则。&lt;/h4&gt;

&lt;p&gt;在32位计算机上，由于寄存器是32位、总线有32条、一次取内容为32位，因此每次取值时都会取得一个4字节的内存内容，编译器也会遵循32位字节对齐的方式去编译。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;class A
{
	int a; //4字节
	bool b; //1字节
	float c; //4字节
	double d; //8字节
	char e; //1字节
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;	[a 4字节]
	[b 1字节][填充3字节]
	[c 4字节]
	[d 8字节]
	[e 1字节][填充3字节]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;32位计算机中，此对象的内存空间为 4 +（1+3） + 4 + 8 + (1+3) = 24个字节。&lt;/p&gt;

&lt;p&gt;而在64位计算机中，以64位内存对齐的规则时：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	[a 4字节][b 1字节][填充3字节]
	[c 4字节][填充4字节]
	[d 8字节]
	[e 1字节][填充7字节]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此对象实例的内存占用空间为 (4+1+3) + (4+4) + 8 + (1+7) = 32字节，在取a、b变量时可以一次取得，节省一次内存调度。&lt;/p&gt;

&lt;h4 id=&quot;对象在内存上对齐的越紧凑能节省的内存调度次数就会越少程序运行的性能也会因此提高&quot;&gt;对象在内存上对齐的越紧凑，能节省的内存调度次数就会越少，程序运行的性能也会因此提高。&lt;/h4&gt;

&lt;h2 id=&quot;inline-内联&quot;&gt;inline 内联&lt;/h2&gt;

&lt;p&gt;除了对齐内存，inline也能让编译器优化函数，让函数执行更快。那么它是怎么优化的呢？&lt;/p&gt;

&lt;p&gt;一般而言，处理一个inline函数有两个阶段：&lt;/p&gt;

&lt;p&gt;1.分析函数，以决定函数是否具备inline能力。&lt;/p&gt;

&lt;p&gt;如果函数因其复杂度，或因其建构问题，被判断不可成为inline，它会被转为一个static函数，并在“被编译模块”内产生对应的函数定义。&lt;/p&gt;

&lt;p&gt;2.真正的inline函数在调用时展开操作，省去函数调用导致的推栈和入栈寄存器的操作，也一并优化了函数中的计算内容(更少的内存存取次数和更快更少的计算次数)。&lt;/p&gt;

&lt;p&gt;这也导致我们通常给予inline后并不清楚编译器是否真正将其视为inline去优化，只有我们进入汇编中才能看到是否真的实现了inline。&lt;/p&gt;

&lt;h3 id=&quot;inline具体会优化哪些方面呢我们来举几个例子&quot;&gt;inline具体会优化哪些方面呢？我们来举几个例子&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;minval = min(val1, val2); //1
minval = min(1024, 2048); //2
minval = min(foo(), bar() +1); //3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果min是一个inline内联函数：&lt;/p&gt;

&lt;p&gt;第一行会被改为 minval = val1 &amp;lt; val2 ? val1 : val2; 省去了函数调用。&lt;/p&gt;

&lt;p&gt;第二行会被改为 minval = 1024; 编译器直接离线计算好结果用常数代替函数调用。&lt;/p&gt;

&lt;p&gt;第三行会被改为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;int t1 = foo();
int t2 = bar() + 1;
minval = t1 &amp;lt; t2 ? t1 : t2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;增加了临时性的变量，从而替代内联的函数调用。inline函数中的局部变量加上inline自己增加的局部变量，在展开后可能会导致大量临时性的变量产生。&lt;/p&gt;

&lt;p&gt;inline函数对于封装提供了一种必要的支持，可以有效存取装于class中的nonpublic数据。它同时也是C程序中大量使用#define宏处理的一个安全代替品，但如果inline函数被调用太多次的话，会产生大量的扩展代码，使得程序集本身的大小暴涨。&lt;/p&gt;

&lt;h2 id=&quot;template-模板&quot;&gt;Template 模板&lt;/h2&gt;

&lt;p&gt;C++ 中的Template 模板，在许多语言里也称为泛型。自从1991年加入到cfront 3.0之后深深改变了C++编程习惯。它被使用在编译期做些评估和生成代码的工作，也因而带来了重大的效率提升，同时也成为了程序员一个噩梦以及最挫败的主题。&lt;/p&gt;

&lt;h4 id=&quot;那么当我们声明了一个-template-class或者-template-function时究竟会发生什么呢&quot;&gt;那么当我们声明了一个 template class、或者 template function时究竟会发生什么呢？&lt;/h4&gt;

&lt;p&gt;其实什么都不会发生，如果我们不使用它的话，编译器就会忽略它什么都不干。有也只有当我们使用定义的template做事时，编译器才开始工作，我说的使用是指在我们在代码中使用了前面声明的 template class 或者 template function，而不光是定义。&lt;/p&gt;

&lt;p&gt;如果我们使用了一个指针，指向特定的实例，像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;template&amp;lt;class T&amp;gt;
class Point
{
public:
	void Print();
private:
	T x,y,z;
}

Point&amp;lt;float&amp;gt; * ptr = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译器依然什么都不回做，因为一个指向class object的指针本身并不是一个class object，编译器不需要知道与该class有关的任何成员数据或对象布局数据，它只是一个指针，至于指向什么并不重要。&lt;/p&gt;

&lt;p&gt;然而如果带template的class被实例化时，则编译器才真正开始为template产生代码，例如我们定义了一个实体而非指针：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;Point&amp;lt;float&amp;gt; origin;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时origin会被实例化，编译器也检查到了这种情况，则会启动template代码生成器为Point&lt;float&gt;生成一个类，如下面代码生成格式：&lt;/float&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;class Point_float
{
private:
	float x,y,z;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而在编译器生成template代码类时，也并不会将所有template定义的类中的代码都生成出来，编译器只会在代码中生成被使用的函数或者可能使用的函数。例如上述中的Point_float就没有生成Print函数，因为我们并没有使用它。&lt;/p&gt;

&lt;h4 id=&quot;这样做的主要原因是为空间和时间上的效率考虑如果我们的template-class中有100个函数使用中的类型有10个我们只使用了其中5个函数那么原本会生成是100--10--1000个函数现在编译器只会生成-5--10--50-个函数其余的950个函数代码讲会被忽略这大大节省了空间提升了编译效率&quot;&gt;这样做的主要原因是，为空间和时间上的效率考虑，如果我们的template class中有100个函数，使用中的类型有10个，我们只使用了其中5个函数，那么原本会生成是100 * 10 = 1000个函数，现在编译器只会生成 5 * 10 = 50 个函数，其余的950个函数代码讲会被忽略。这大大节省了空间提升了编译效率。&lt;/h4&gt;

&lt;h4 id=&quot;那么编译器是如何生成template代码的呢&quot;&gt;那么编译器是如何生成template代码的呢？&lt;/h4&gt;

&lt;p&gt;首先要发现template使用情况，在.h和.cpp文件中寻找template使用情况，如果有使用则继续生成，否则忽略。&lt;/p&gt;

&lt;p&gt;其次编译器尝试模拟链接操作，检查看看哪一个函数真正需要，将真正需要的生成的函数提取出来，位它们生成具体的函数代码。&lt;/p&gt;

&lt;p&gt;最后编译器要阻止template function在多个.o文件中被生成出来，它会从链接器提供的支持中获取信息，只留下一份代码，其余的都将忽略。&lt;/p&gt;

&lt;h2 id=&quot;rtti-执行期类型识别&quot;&gt;RTTI 执行期类型识别&lt;/h2&gt;

&lt;p&gt;执行期类型识别(Runtime Type Identification)最初是由于支持异常处理(Exception Handling)而产生的，可以说它是异常处理的副产品，后来被大量的使用在执行期代码中。&lt;/p&gt;

&lt;p&gt;C++被吹毛求疵的一点就是，它缺乏一个保证安全的向下转换操作，只有在类型真的可以被转换的情况下，你才能够执行转换。想要实现安全的转换，则需要额外的类信息支持，于是就有了类信息(type information)。&lt;/p&gt;

&lt;p&gt;type_info是C++标准所定义的类型描述器的class名称，该class中放置着待索求的类型信息。虚表空间中的第一个空格就是指向type_info信息的地址。&lt;/p&gt;

&lt;p&gt;因此想要有RTTI功能，则class必须继承type_info类，即&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;class fct: public type_info {...};
class gen: public type_info {...};

class Point: public type_info {...};
class Point2D: public Point {...};

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;- Point 继承 type_info后 Point2D 虚表变化情况
- virtual table 虚表地址 --------&amp;gt;   Point2D的虚表空间
									- type_info ptr 类信息地址
									- PointCount()地址
									- PrintPoint()地址
- x
- y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Point2D和Point的​虚表头，都是type_info的信息地址。这样看来，每次我们使用指针取得class object类型描述器时，其实就是通过虚表指针去取得类信息地址，即如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;((type_info)(pt-&amp;gt;vptr[0]))-&amp;gt;name(); //从虚表指针中的第一个槽位中取得类信息
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;type_info object在C++标准下的定义为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;class type_info
{
public:
	virtual ~type_info();
	bool operator==(const type_info&amp;amp;) const;
	bool operator!=(const type_info&amp;amp;) const;
	bool before(const type_info&amp;amp;) consnt;
	const char* name() const;
	const char* raw_name() const;//返回类名称的编码字符串
private:
    void *_m_data;
    char _m_d_name[1];
	type_info(const type_info&amp;amp;);
	type_info&amp;amp; operator=(const type_info&amp;amp;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了类信息，我们在做向下转换时，就可以用根据类信息来判断是否可以转换，即如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;pfct pf = dynamic_cast&amp;lt;pfct&amp;gt;(pt);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相当于：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;pfct pf = NULL;
type_info type_ptcf = typeid(ptcf);
type_info type_pt = typeid(pt);
if(type_ptcf == type_pt || type_pt.before(&amp;amp;type_ptcf))
{
	pf = pt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;总结class内存分布由成员变量虚表指针组成布局大小会根据计算机的内存对齐方式不同而不同inline内联函数并不一样会真的内联其优化会节省函数调用开始和计算次数开销template模板会根据template-class使用情况生成代码生成步骤是找到使用情况生成代码去除重复想要有rtti执行期类型识别则必须有额外的信息空间支持在c中我们必须继承type_info才能获得rtti的功能或者我们自己写一个执行期类型识别功能来替代标准c有了执行期类型识别功能我们在向下转换时才更加安全&quot;&gt;总结，class内存分布由成员变量+虚表指针组成，布局大小会根据计算机的内存对齐方式不同而不同。inline内联函数并不一样会真的内联，其优化会节省函数调用开始和计算次数开销。Template模板会根据template class使用情况生成代码，生成步骤是找到使用情况、生成代码、去除重复。想要有RTTI执行期类型识别，则必须有额外的信息空间支持，在C++中我们必须继承type_info才能获得RTTI的功能，或者我们自己写一个执行期类型识别功能来替代标准C++，有了执行期类型识别功能，我们在向下转换时才更加安全。&lt;/h4&gt;

</description>
               <pubDate>Fri, 20 Nov 2020 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2020/11/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B014</link>
               <guid isPermaLink="true">http://www.luzexi.com/2020/11/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B014</guid>
            </item>
        
            <item>
               <title>安卓性能分析工具Simpleperf详解与应用</title>
               <description>&lt;h3 id=&quot;本文关注三个问题simpleperf的工作原始里是什么simpleperf该如何使用它如何在unity项目上使用&quot;&gt;本文关注三个问题：Simpleperf的工作原始里是什么？Simpleperf该如何使用？它如何在Unity项目上使用？&lt;/h3&gt;

&lt;p&gt;关注Simpleperf的缘由是，虽然一直使用Xcode Intruments 、 Unity profiler 、Perfdog、以及一些自制的工具（自定义打点+内存快照）来做性能分析，但一直缺少专门针对安卓设备的的函数耗时分析。偶尔间搜到Simpleperf这么好的分析工具，于是开始研究 Simpleperf，最后把它用到项目中去并且建立起日常性能监控流水线。&lt;/p&gt;

&lt;h4 id=&quot;simpleperf是android开源项目aosp的一部分-是一个-cpu-性能剖析工具可以剖析-android-客户端-java-和-c-代码是-android-ndk-工具的一部分其包含两部分simpleperf可执行文件命令行和python脚本&quot;&gt;Simpleperf是Android开源项目（AOSP）的一部分， 是一个 CPU 性能剖析工具，可以剖析 Android 客户端 Java 和 C++ 代码，是 Android NDK 工具的一部分。其包含两部分：Simpleperf可执行文件（命令行）和python脚本。&lt;/h4&gt;

&lt;p&gt;python脚本整合了Simpleperf可执行文件（命令行）和adb的功能，让Simpleperf使用起来更加方便快捷。&lt;/p&gt;

&lt;p&gt;Simpleperf中可执行文件：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image7.png&quot; alt=&quot;1&quot; /&gt;
&lt;img src=&quot;/assets/simpleperf/image21.png&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Simpleperf中整合了命令行的Python脚本：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image23.png&quot; alt=&quot;3&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;simpleper可执行文件支持安卓50及以上的系统但python脚本只支持安卓70及以上的系统&quot;&gt;Simpleper可执行文件支持安卓5.0及以上的系统，但python脚本只支持安卓7.0及以上的系统。&lt;/h4&gt;

&lt;p&gt;这里的Python脚本不仅封装了命令行可执行文件的操作，同时提供了生成测试数据报告，线程消耗图，火焰调用图等功能。由于数据报告生成方面，Simpleperf命令行本身只支持文本数据报告的生成，因此要生成可视化的数据报告，还得依靠python。&lt;/p&gt;

&lt;h4 id=&quot;所以我把数据分析和数据报告生成给拆分开来直接用可执行文件去执行性能分析的任务让simpleperf可以支持更低的安卓系统性能分析完毕后再用python脚本对所得的数据文件来生成可视化的数据报告以及文本数据报告&quot;&gt;所以我把数据分析和数据报告生成给拆分开来，直接用可执行文件去执行性能分析的任务，让Simpleperf可以支持更低的安卓系统。性能分析完毕后，再用python脚本对所得的数据文件来生成可视化的数据报告，以及文本数据报告。&lt;/h4&gt;

&lt;h4 id=&quot;其中数据报告也分成两部分一部分是文本数据报告在生成文本数据报告后对文本数据报告中的数据再加工和筛选筛选出关键的信息上传到性能数据平台作为每日的性能日常报告另一部分是火焰图和消耗图的数据报告用于查看更细致的函数消耗分析&quot;&gt;其中，数据报告也分成两部分，一部分是文本数据报告，在生成文本数据报告后，对文本数据报告中的数据再加工和筛选，筛选出关键的信息上传到性能数据平台作为每日的性能日常报告，另一部分是火焰图和消耗图的数据报告，用于查看更细致的函数消耗分析。&lt;/h4&gt;

&lt;p&gt;我用一个demo做实验，demo的程序就是每帧运行1000w次浮点数和随机数计算，作为实验性能分析数据：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image3.png&quot; alt=&quot;4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以下展示的是性能报告生成后的火焰图和文本数据报告：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image19.png&quot; alt=&quot;5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image12.png&quot; alt=&quot;6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image9.png&quot; alt=&quot;7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面就来详细介绍一下，如何使用Simpleperf来做性能分析。&lt;/p&gt;

&lt;h3 id=&quot;功能概要&quot;&gt;功能概要&lt;/h3&gt;

&lt;p&gt;Simpleperf主要功能分为事件摘要（stat），记录样本(record)和生成数据报告(report)三个功能。stat功能给出了在一个时间段内被分析的进程中发生了多少事件的摘要。record功能必须在Android系统中运行，当Simpleperf运行分析时会不断将数据写入到性能数据文件，所以它可以随时停止，随时拷贝分析数据文件。分析完毕后我们可以需要将输出数据文件拷贝到PC上，再使用report功能解析成数据报告。&lt;/p&gt;

&lt;h3 id=&quot;前提条件&quot;&gt;前提条件&lt;/h3&gt;

&lt;p&gt;Simpleperf需要有权限去做性能采样，所以想要使用Simpleperf做性能分析，需要满足4个条件中的一个就够了。&lt;/p&gt;

&lt;p&gt;1.debug版本，即在manifest中设置了android::debuggable=”true”，并且允许JNI 测试，并且C/C++没有被编译器优化过。也就是Unity构建的Development Build版本。&lt;/p&gt;

&lt;p&gt;2.release版本，如果安卓10以上则需要manifest中加入&lt;profileable android:shell=&quot;true&quot;&gt;&lt;/profileable&gt;就可以。&lt;/p&gt;

&lt;p&gt;3.release版本，如果是安卓8以上则在manifest中加入&amp;lt;application android::debuggable=”true” …&amp;gt;后，把wrap.sh 放入 lib/arch 文件夹中。 wrap.sh 会在没有debug标志给ART的情况下跑app。&lt;/p&gt;

&lt;p&gt;4.release版本，你的手机是root过的，有root权限Simpleperf就会畅通无阻。&lt;/p&gt;

&lt;h3 id=&quot;底层原理&quot;&gt;底层原理&lt;/h3&gt;

&lt;p&gt;现代CPU具有一个硬件组件，称为性能监控单元(PMU)。PMU具有一些硬件计数器，计数一些诸如经历了多少次CPU周期，执行了多少条指令，或发生了多少次缓存未命中等事件。&lt;/p&gt;

&lt;p&gt;Linux内核将这些硬件计数器包装到硬件perf事件 (hardware perf events)中。此外，Linux内核还提供了独立于硬件的软件事件和跟踪点事件。Linux内核通过 perf_event_open 系统调用将这些都暴露给了用户空间，这正是simpleperf所使用的机制。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image25.png&quot; alt=&quot;8&quot; /&gt;&lt;/p&gt;

&lt;p&gt;linux系统在各个层都封装了一套性能接口。图中perf字样的接口主要位于CPU层，系统调用层，系统库层，调度层，内存层中。我们通过simpleperf list可以查看受支持的事件类型，有硬件事件类型和软件事件类型之分。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image6.png&quot; alt=&quot;9&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image1.png&quot; alt=&quot;10&quot; /&gt;&lt;/p&gt;

&lt;p&gt;硬件事件借助现代CPU中的PMU（性能监控单元）部件实现采样，比如cpu-cycle，cache-miss等硬件级数据，kernel会开启PMU的计数器去采集对应进程的数据。&lt;/p&gt;

&lt;h5 id=&quot;pmu是cpu中的部件专门用于性能监控cpu在运行时可以收集关于处理器和内存的各种统计信息对于处理器来说这些统计信息中的事件非常有用这样我们可以利用它们来调试或者剖析代码&quot;&gt;PMU是CPU中的部件，专门用于性能监控，CPU在运行时可以收集关于处理器和内存的各种统计信息。对于处理器来说这些统计信息中的事件非常有用，这样我们可以利用它们来调试或者剖析代码。&lt;/h5&gt;

&lt;h5 id=&quot;软件事件则是系统内核kernel层自行实现统计操作系统相关性能事件在各个功能模块中如内存对齐断层事件线程context-switch上下文切换事件cpu时钟事件cpu迁移事件页断层事件等等&quot;&gt;软件事件则是系统内核kernel层自行实现，统计操作系统相关性能事件在各个功能模块中，如内存对齐断层事件、线程context-switch上下文切换事件、cpu时钟事件、cpu迁移事件、页断层事件等等。&lt;/h5&gt;

&lt;p&gt;事实上SimplePerf就是通过linux系统的perf_event_open接口来获得这些perf数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image17.png&quot; alt=&quot;11&quot; /&gt;&lt;/p&gt;

&lt;p&gt;linux内核perf_event_open接口 https://www.man7.org/linux/man-pages/man2/perf_event_open.2.html&lt;/p&gt;

&lt;h3 id=&quot;那么stat和record是如何工作的呢&quot;&gt;那么stat和record是如何工作的呢？&lt;/h3&gt;

&lt;h4 id=&quot;stat命令给出时&quot;&gt;Stat命令给出时&lt;/h4&gt;

&lt;p&gt;1.simpleperf调用linux系统接口启用perf分析。&lt;/p&gt;

&lt;p&gt;2.设置监控事件和周期。&lt;/p&gt;

&lt;p&gt;3.Linux 内核在调度到被分析进程时启用计数器。&lt;/p&gt;

&lt;p&gt;4.simpleperf从内核读取计数器，并报告计数器摘要。&lt;/p&gt;

&lt;p&gt;cmd_stat.cpp 471行 StatCommand::Run&lt;/p&gt;

&lt;p&gt;https://android.googlesource.com/platform/system/extras/+/master/simpleperf/cmd_stat.cpp&lt;/p&gt;

&lt;h4 id=&quot;record-命令给出时&quot;&gt;Record 命令给出时&lt;/h4&gt;

&lt;p&gt;1.Simpleperf通过对linux内核接口调用加入监控，锁定监控进程对象。&lt;/p&gt;

&lt;p&gt;2.调用linux系统接口启用perf分析。&lt;/p&gt;

&lt;p&gt;3.Simpleperf在simpleperf 和 linux 内核之间创建共享映射缓冲区。&lt;/p&gt;

&lt;p&gt;4.设置需要监控的事件和采样频率，告诉linux 内核将样本数据转储到映射缓冲区。&lt;/p&gt;

&lt;p&gt;5.开启线程不断监控共享映射缓冲区，从映射缓冲区读取数据并写入到数据文件。&lt;/p&gt;

&lt;p&gt;cmd_record.cpp 455行 RecordCommand::PrepareRecording&lt;/p&gt;

&lt;p&gt;https://android.googlesource.com/platform/system/extras/+/master/simpleperf/cmd_record.cpp&lt;/p&gt;

&lt;h3 id=&quot;这里有2个重要的节点我们深入了解下这两个重点能映射出simpleperf是如何在linux系统工作的&quot;&gt;这里有2个重要的节点我们深入了解下，这两个重点能映射出Simpleperf是如何在Linux系统工作的？&lt;/h3&gt;

&lt;h3 id=&quot;第一个它是如何与linux操作系统通信的&quot;&gt;第一个，它是如何与Linux操作系统通信的？&lt;/h3&gt;

&lt;p&gt;通常进程之间通信都是通过共享内存进行，Simpleperf通过创建映射缓冲区来与系统共享一块内存。那么它是怎么创建和映射的呢？&lt;/p&gt;

&lt;p&gt;我们来看看源码中的关键函数，CreateMappedBuffer创建映射缓冲区，其中mmap为Linux系统接口，调用它使得进程之间通过映射同一块内存(或文件)实现共享内存。
Simpleperf调用mmap创建指定的共享内存大小，设置读写权限，设置共享标记，以及设置通道句柄。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image13.png&quot; alt=&quot;12&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有了共享内存，接着Simpleperf需要告诉与系统把性能数据放入共享缓冲中去。&lt;/p&gt;

&lt;p&gt;其中ioctl为Linux系统接口，是设备驱动程序中对设备的I/O通道进行管理的函数。所谓对I/O通道进行管理，就是对设备的一些特性进行控制，例如串口的 传输波特率、马达的转速等等。&lt;/p&gt;

&lt;p&gt;Simpleperf调用ioctl告诉Linux系统将性能数据写入通道缓存。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image2.png&quot; alt=&quot;13&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ioctl调用格式为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int ioctl(int fd, ind cmd, …)；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以通过ioctl的命令码(cmd)告诉Linux驱动程序我们想做什么，至于怎么解释这些命令和怎么实现这些命令，这都是驱动程序要做的事情。
现在我们使用cmd命令码PERF_EVENT_IOC_SET_OUTPUT，告诉系统让内核把性能相关事件数据放入指定缓冲中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image20.png&quot; alt=&quot;14&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;第二个它是如何得到linux操作系统的性能信息的&quot;&gt;第二个，它是如何得到Linux操作系统的性能信息的？&lt;/h3&gt;

&lt;p&gt;Simpleperf通过创建一个线程来监控数据并记录数据，它就是RecordReadThread。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image11.png&quot; alt=&quot;14&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个线程也会不断的接收用户的命令输入，来暂停和恢复数据记录。&lt;/p&gt;

&lt;p&gt;创建线程后，接着实例化需要监控的事件，并开始记录和监控。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image10.png&quot; alt=&quot;15&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此线程不断循环监控共享内存的状况，同时记录性能数据：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image24.png&quot; alt=&quot;16&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;第一个问题中我们说simpleperf通过linux系统接口mmap申请共享内存再通过linux系统接口ioctl告诉内核把性能监控的数据放在共享内存中由于linux系统在各个层都封装了一套perf性能接口于是在接下来的程序运行中linux内核将这些perf事件-perf-events数据放入simpleperf设置的共享内存中而simpleperf又开启了一个线程来不断监控是否有数据加入并将它们放入自己缓存中去最后再通知主线程适当的时候将这些数据写入本地文件&quot;&gt;第一个问题中我们说，Simpleperf通过Linux系统接口mmap申请共享内存，再通过Linux系统接口ioctl告诉内核把性能监控的数据放在共享内存中。由于Linux系统在各个层都封装了一套perf性能接口，于是在接下来的程序运行中，Linux内核将这些perf事件 (perf events)数据放入Simpleperf设置的共享内存中。而Simpleperf又开启了一个线程来不断监控是否有数据加入，并将它们放入自己缓存中去，最后再通知主线程适当的时候将这些数据写入本地文件。&lt;/h4&gt;

&lt;h2 id=&quot;执行性能分析&quot;&gt;执行性能分析&lt;/h2&gt;

&lt;h3 id=&quot;record-命令行说明&quot;&gt;record 命令行说明&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image16.png&quot; alt=&quot;17&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;性能分析命令执行步骤&quot;&gt;性能分析命令执行步骤&lt;/h3&gt;

&lt;p&gt;现在我们用Simpleperf命令行的形式来对安卓系统进行C/C++的性能分析：&lt;/p&gt;

&lt;p&gt;1.将simpleperf可执行文件放入安卓系统&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;adb push .\ndk21\simpleperf\bin\android\arm64\simpleperf /data/local/tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.将可执行文件设置为可执行文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;adb shell chmod a+x /data/local/tmp/simpleperf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.开始执行分析，这里设定一个99秒的持续时间。也可以设定为99999秒，然后用杀进程的方式来终止分析。因为我们前面说过，simpleperf是逐步写入数据文件的，数据文件随时保持完整性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;adb shell /data/local/tmp/simpleperf record -o /data/local/tmp/perf.data -g --app com.xxx.xxx --duration 99 -f 800
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.停止分析&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;adb shell pkill -l 2 simpleperf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.将分析数据文件拷贝出来&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;adb pull /data/local/tmp/perf.data .\report_data\report\perf.data
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;生成数据报告步骤&quot;&gt;生成数据报告步骤&lt;/h3&gt;

&lt;p&gt;有了Simpleperf生成的性能数据后，我们就可以对这份性能数据文件进行分析并生成数据报告。&lt;/p&gt;

&lt;h4 id=&quot;生成报告前我们首先需要准备符号表&quot;&gt;生成报告前，我们首先需要准备符号表。&lt;/h4&gt;

&lt;h4 id=&quot;为什么要准备符号表呢因为这样就可以通过分析数据中调用地址映射到具体的函数名这些都由simpleperf帮我们完成只是我们需要为此准备这个带符号表的so&quot;&gt;为什么要准备符号表呢，因为这样就可以通过，分析数据中调用地址映射到具体的函数名。这些都由Simpleperf帮我们完成，只是我们需要为此准备这个带符号表的so。&lt;/h4&gt;

&lt;p&gt;Unity引擎带符号表so的放在Unity的安装目录下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image8.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;打完apk包后带符号的il2cpp的so在项目的Temp目录下面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image5.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有了这些准备接下我们来开始讲生成数据报告的操作步骤：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image14.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1.准备符号表&lt;/p&gt;

&lt;p&gt;把包地址打印出来，因为真正的包地址可能会在你知道的包名后面加些字符串&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;adb shell pm path com.xxxx.xxx &amp;gt; tmp_appinfo.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把符号表拷贝过去到./binary_cache/data/app/com.xxx.xxxx/lib/arm(或者arm64)/里去&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;python:
cp_src1 = 'libil2cpp.so.debug'
cp_target1 = './binary_cache/data/app/com.xxx.xxxx/lib/arm/libil2cpp.so'
if os.path.exists(cp_src1):
    shutil.copy(cp_src1, cp_target1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里只拷贝了il2cpp的，至少还需要拷贝带符号的libunity.so。符号表是simpleperf用来查找调用函数名的。&lt;/p&gt;

&lt;h4 id=&quot;simpleperf是怎么查到函数名的呢它是通过调用地址与符号表中的函数名对应关系来获得所调用的函数名的我们可以用simpleperf解析后数据打开文本数据获得调用地址来查看到底是怎么回事&quot;&gt;Simpleperf是怎么查到函数名的呢，它是通过调用地址与符号表中的函数名对应关系来获得所调用的函数名的。我们可以用Simpleperf解析后数据，打开文本数据获得调用地址，来查看到底是怎么回事。&lt;/h4&gt;

&lt;p&gt;举个例子，我们查看数据报告中的88.31%的耗时占比函数调用库指令地址为83cb7c：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image18.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在汇编工具IDA中加载libil2cpp带符号的so文件，查看到83cb7c地址恰好是在Random调用地址上：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image4.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;也就是说有8831的消耗在randomrange这个函数上simpleperf就是通过指令调用地址来获取符号表中的函数名的通过调用地址和符号表上的函数名对齐后得到最终的函数名&quot;&gt;也就是说，有88.31%的消耗在Random.Range这个函数上。Simpleperf就是通过指令调用地址来获取符号表中的函数名的，通过调用地址和符号表上的函数名对齐后得到最终的函数名。&lt;/h4&gt;

&lt;p&gt;2.生成普通数据报告&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;python .\ndk21\simpleperf\report.py -i .\perf.data -o .\report.txt -n --full-callgraph --symfs .\binary_cache
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.生成调用者耗时分布数据报告&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shs&quot;&gt;python .\ndk21\simpleperf\report.py -i .\perf.data -o .\report.caller.txt -g caller --full-callgraph --symfs .\binary_cache
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.生成被调用者耗时分布数据报告&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;python .\ndk21\simpleperf\report.py -i .\perf.data -o .\report.callee.txt -g callee --full-callgraph --symfs .\binary_cache
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后生成的文本数据如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image9.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;生成火焰图和消耗图&quot;&gt;生成火焰图和消耗图&lt;/h3&gt;

&lt;p&gt;1.用simpleperf提供的report_html.py生成可视图&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;python .\ndk21\simpleperf\report_html.py -i .\perf.data -o .\report.html --binary_filter .\binary_cache
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.拷贝可视图网页需要用到的js文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;copy  &quot;.\ndk21\simpleperf\report_html.js&quot; &quot;.\report_html.js&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image12.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;日常性能监控流程建设&quot;&gt;日常性能监控流程建设：&lt;/h3&gt;

&lt;p&gt;那么我们是否可以将Simpleperf运用到日常性能监控中去呢？&lt;/p&gt;

&lt;p&gt;经过Simpleperf的性能分析后，我们得到了性能数据文本数据，我们可以对这个文本类型的数据文件再解析，然后将我们需要的重要的函数性能数据加入到后台数据库中，并在每日自动化性能测试报告中体现出来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image22.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们来看看上图中，生成出来的性能数据格式。根据性能数据格式，百分比、采样次数、线程名、库文件名、调用函数名的格式，我们可以将数据解析到内存中，并用http的方式上传到web后台。web后台对数据加工后，可以用趋势图的形式在后台页面上展现出来。例如下面的样例图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simpleperf/image15.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;参考文献&quot;&gt;参考文献：&lt;/h3&gt;

&lt;p&gt;Simpleperf官方地址：&lt;/p&gt;

&lt;p&gt;https://android.googlesource.com/platform/system/extras/+/master/simpleperf/doc/README.md#executable-commands-reference&lt;/p&gt;

&lt;p&gt;Simpleperf源码地址：&lt;/p&gt;

&lt;p&gt;https://android.googlesource.com/platform/system/extras/+/master/simpleperf/&lt;/p&gt;

&lt;p&gt;《SimplePerf 安卓客户端性能剖析及自动化性能测试》&lt;/p&gt;

&lt;p&gt;http://km.oa.com/articles/show/466087?kmref=search&amp;amp;from_page=1&amp;amp;no=1&lt;/p&gt;

&lt;p&gt;《Simpleperf介绍》&lt;/p&gt;

&lt;p&gt;https://blog.csdn.net/tq08g2z/article/details/77311712&lt;/p&gt;

</description>
               <pubDate>Fri, 13 Nov 2020 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2020/11/13/%E5%AE%89%E5%8D%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7Simpleperf%E8%AF%A6%E8%A7%A3</link>
               <guid isPermaLink="true">http://www.luzexi.com/2020/11/13/%E5%AE%89%E5%8D%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7Simpleperf%E8%AF%A6%E8%A7%A3</guid>
            </item>
        
            <item>
               <title>向内看自己(九) 慌乱的内心世界</title>
               <description>&lt;p&gt;来深圳快1年了，我以为我会适应的很快，但恰恰相反。我感觉自己像一个惊弓之鸟，被很多事情震惊到了，包括，今年的疫情、远离亲人、陌生的城市、周围很多牛人、项目重要而又紧迫、孩子们慢慢长大了、感觉自己肩负的责任又重了一些。&lt;/p&gt;

&lt;p&gt;好几次我都迫不及待的坐飞机回家看看老婆孩子，多休息几天跟她们多呆几天是几天，感觉自己在逃避。&lt;/p&gt;

&lt;p&gt;这让我想起了幼年时自己被送去武术学校的那段回忆。父母想给我一些锻炼的机会，他们打听到10公里外有个武术学校可以在暑假时间里收一些学生锻炼一下意志力，于是将我送去了那里。那段时间我很害怕，不知道为何，感觉自己被丢到了一个无人关心的地方，虽然后来我慢慢适应了，但两星期后还是忍不住逃了回来。&lt;/p&gt;

&lt;p&gt;这段回忆好像我现在的样子，恐慌不安，犹如惊弓之鸟，童年的阴影困住了我。所以有时我很苦恼，像是被自己所设的陷阱困住了。&lt;/p&gt;

&lt;p&gt;​长大后我才知道每个人都有这样那样大大小小的童年阴影，起先我一直责怪父母给我了一个不好的童年，自从自己当了父母，特别是看了《自卑与超越》之后，才明朗了些，才知道这些童年阴影无法避免，作为父母在这个社会生存，很多时候也是生不由己，没有人是容易的。&lt;/p&gt;

&lt;p&gt;现在轮到自己了，我成为了别人的父母。我已经在社会上独立了，但仍然被这个社会中的小事所很震惊，我想对于这种恐慌我的父母在我这个岁数时也有过同样的经历。&lt;/p&gt;

&lt;p&gt;想到这一层时，我对自己孩子的教育和关心有更加深刻的理解，我不想犯父母的错误，同时很多错误也无法避免。我该如何去补救和行动，我想我应该更努力的去关心她们，感受她们的心灵，并引导她们往好的方向发展。虽然我在很远的地方不能陪伴她们，但我想我也可以做些力所能及的事情作为补救。&lt;/p&gt;

&lt;p&gt;说到自己恐慌，大多数时候是因为压力导致的，压力导致焦虑，焦虑又破坏了我原本的行动准则，没有了行动准则就变得紊乱没有方向。&lt;/p&gt;

&lt;p&gt;其实都是自己的问题，是我忘了初心。&lt;/p&gt;

&lt;p&gt;​于是我深深的问了自己一下，我的初心是什么？第一反应给我的答案是，我的初心是学习，学习是我最大的愿望，我很享受学习的时间，包括学习如何学习，学习具体的知识和技能，以及学习如何运用所学到的。&lt;/p&gt;

&lt;p&gt;我希望自己不忘初心，不断学习，学习知识，学习心态，学习与他人交流，学习如何认识自己等等等等，这是我最终想要的。&lt;/p&gt;

</description>
               <pubDate>Wed, 04 Nov 2020 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2020/11/04/%E5%90%91%E5%86%85%E7%9C%8B%E8%87%AA%E5%B7%B19</link>
               <guid isPermaLink="true">http://www.luzexi.com/2020/11/04/%E5%90%91%E5%86%85%E7%9C%8B%E8%87%AA%E5%B7%B19</guid>
            </item>
        
            <item>
               <title>给女儿的信(五)</title>
               <description>&lt;p&gt;Hi Sharon Anne，又有1个月没见到你们，爸爸好想你们。&lt;/p&gt;

&lt;p&gt;爸爸最近工作很忙，也碰到了一些问题，想跟你们说说。爸爸的这家公司里有很多比爸爸厉害很多的人，每天他们都跟爸爸一起做事情。&lt;/p&gt;

&lt;p&gt;他们很厉害，懂的比爸爸多，爸爸有段时间很难受，因为爸爸觉得比不过他们，所以显得很垂头丧气的。&lt;/p&gt;

&lt;p&gt;一段时间后，慢慢地爸爸想明白了。其实你看，这个世界上比我厉害的人很多，我能遇上他们，并跟他们一起工作是爸爸的荣幸，所以爸爸要乘这个机会多向他们学习一下。&lt;/p&gt;

&lt;p&gt;现在爸爸常常跟他们交流，学习他们身上的优点，并且平时的时候自己也在努力的看书，为了巩固知识，也会写一些文章做一下总结。&lt;/p&gt;

&lt;p&gt;虽然现在爸爸还是没他们厉害，但爸爸相信我会慢慢赶上来的。&lt;/p&gt;

&lt;p&gt;Sharon，Anne，你们也会遇到很多比你们厉害的人，这个时候不要慌张哦，因为这是很正常的，要向爸爸这样，多向他们学习，并且自己也要努力看书学习哦，这样我们就能慢慢赶上他们。&lt;/p&gt;

</description>
               <pubDate>Mon, 02 Nov 2020 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2020/11/02/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A15</link>
               <guid isPermaLink="true">http://www.luzexi.com/2020/11/02/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A15</guid>
            </item>
        
            <item>
               <title>思路探讨(五十四) 系统性的学习</title>
               <description>&lt;p&gt;前面很多文章对人生哲理的认知比较多，但对系统性的知识则却没有几篇。这也是最近几年犯的错误之一，忙于吸收一些零散的知识，却没有形成体系。&lt;/p&gt;

&lt;h4 id=&quot;把看别人写的文章当作吸收知识的重要来源是我最近几年所犯的重要错误之一&quot;&gt;把看别人写的文章当作吸收知识的重要来源，是我最近几年所犯的重要错误之一。&lt;/h4&gt;

&lt;p&gt;我们写的文章大部分都是写给自己的总结（即使记者在撰写实时新闻时也会夹带有自己的观点和情绪），在写文章的同时总结了我们学到的知识，这些知识无论从书本上还是实践中的来，最后总结完毕后的文章第一个看的人是我们自己，所以从某种意义上来说我们写的文章都是我们写给自己看的，这使得我们可以让自己的知识在脑袋中有了一次整理和巩固的机会，然后这篇文章才顺带的分享给大家，让大家能够知道我们在这个学习过程中经历了什么，有什么样的体会，知识的重点是什么，这对于写文章的人帮助很大。&lt;/p&gt;

&lt;p&gt;对于看文章的人，其吸收的知识其实微乎其微。这句话我一开始也不是很明白，为什么我看别人写的精彩的技术文章就没什么用呢？为什么我看别人写的文章的时候，你怎么知道我吸收的知识就微乎其微了呢？后来我才慢慢发现，这些大部分文章无论是新闻还是技术相当于一种资讯，就像我们每天在xx新闻里看的文章那样，写的都是天下发生的事，可能你觉得新奇会去看一下，但其具体的知识无法进入到你的脑袋中。&lt;/p&gt;

&lt;p&gt;为什么呢？因为你没有系统性的去学习过它，你只是片面的从别人的口中知道了这么一件事。比如某个专家在文章中提到，xx编程语言效率低，你可能就记住了，但其实他讲了很多关于为什么这个语言是低效的内容，你却很难记住，因为这不是你的经历，你无法在这么短的文章中体会到他的所有成功和失败的经历。但当有人问你的时候，你也这么告诉他，就像专家那样。可是你一直没有去研究为什么这种编程语言效率低，没有去系统性的学习编程语言是怎么设计的，是怎样编译成机器码的，在执行时是怎么运行的。所以你的脑袋里只有这么一句话，xx编程语言是低效的。&lt;/p&gt;

&lt;h4 id=&quot;如果你没有从上到下从底层到设计系统性的去学习知识我们可能会迷失在这个充满知识的海洋里&quot;&gt;如果你没有从上到下，从底层到设计，系统性的去学习知识，我们可能会迷失在这个充满知识的海洋里。&lt;/h4&gt;

&lt;p&gt;系统性学习和零散的看些文章的区别，本质上围绕的依然是高效。我们关注的是，“如何才能高效的学习？”和“如何学习才高效？”。答案可能很长，包括且不局限于，练习的技巧、精力管理、目标管理、阅读技巧、心态的调整、教导他人时的方法、自我总结的技巧、以及与他人交流方式等等等。有很多我们需要我们学习的东西，只是这么多东西如果我们抓不住重点，就会迷路。&lt;/p&gt;

&lt;p&gt;就如同我最近在健身中学到的那样，如果我们没有目标的去锻炼肌肉，则通常都是东锻炼一下西锻炼一下，很难形成有效的可见的成果，大部分人都在锻炼一阵后由于看不到成效放弃了健身。我也这样没有目标的锻炼了很久，直到最近我才开始反思，我在想“怎样才能让我锻炼的成果放大”。于是我开始系统性的学习人体的肌肉组成结构，肌肉增长的原理，塑形减脂的原理，慢慢的我去健身时也更加注重肌肉的局部锻炼，把有限的时间花费在几个重要的肌肉锻炼上，饮食上也更加注重搭配和克制，肌肉的增长效果显著。自己看到了成果，就会更加努力学习，向着目标前进。&lt;/p&gt;

&lt;h4 id=&quot;最后总结下零散的知识用处小效率差误导多我们需要系统性的学习某个领域的知识从底层开始因为系统性的知识能带领我们看透事物的本质和底层逻辑这让我们进入一个新的世界一个能抓住重点从而更加高效的世界尽可能自己写文章而不是期盼依靠别人的文章来获得知识&quot;&gt;最后总结下，零散的知识用处小效率差误导多，我们需要系统性的学习某个领域的知识（从底层开始），因为系统性的知识能带领我们看透事物的本质和底层逻辑，这让我们进入一个新的世界，一个能抓住重点从而更加高效的世界。尽可能自己写文章，而不是期盼依靠别人的文章来获得知识。&lt;/h4&gt;

</description>
               <pubDate>Sun, 01 Nov 2020 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2020/11/01/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A854</link>
               <guid isPermaLink="true">http://www.luzexi.com/2020/11/01/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A854</guid>
            </item>
        
            <item>
               <title>向内看自己(八) 团队合作、冥想、精力</title>
               <description>&lt;p&gt;向内看自己，看自己内心的所思所想，找出问题并逐步纠正它。&lt;/p&gt;

&lt;p&gt;很佩服公司里很多同事，他们拥有很好的合作能力，知道如何更加有效的合作，让集体的力量放大很多倍。&lt;/p&gt;

&lt;p&gt;我知道自己有些许性格上的缺陷，这会使得我在平时的工作和生活中与他人合作起来会有障碍，从而导致了团队磨合期较长。这让我万分痛苦，因为年纪越大越知道团队的力量有多重要。&lt;/p&gt;

&lt;p&gt;团队凝聚的力量可以让大事情大难题分解成不同的小事情和小问题，每个小问题都由某成员来处理，综合起来就像，单车道变成了八车道那样并行处理和推进，让整个进度变得更快，让原本看似大的难题被团队良好的合作和分工，分解成了小问题并迅速消化掉。&lt;/p&gt;

&lt;p&gt;每个人擅长的领域不一样，将这些不同领域的人才聚集起来并且形成有效的合作才能迸发出巨大的创造力。团队中有些人擅长分解难题，有些人擅长某个领域的难题，有些人擅长在不同难题领域之间的衔接，难题被分解成各种小领域并在领域之间有人衔接，这是团队分工合作达成大目标的关键。&lt;/p&gt;

&lt;p&gt;​如果人没有合作意识，就会使得团体的效率大大降低，大事办不成，小事争执不断，一盘散沙。&lt;/p&gt;

&lt;h4 id=&quot;团队这个概念无处不在除了公司里的团队外我们还有家庭班级球队兴趣班等等这些团队都需要我们认真对待培养起自己良好的合作观念如何配合队友如何有效分工如何衔接队友与队友之间的成果以及如何培养团队感情一辈子都要学习如何有效合作&quot;&gt;团队这个概念无处不在，除了公司里的团队外，我们还有，家庭、班级、球队、兴趣班等等。这些团队都需要我们认真对待，培养起自己良好的合作观念，如何配合队友，如何有效分工，如何衔接队友与队友之间的成果，以及如何培养团队感情。一辈子都要学习如何有效合作。&lt;/h4&gt;

&lt;hr /&gt;

&lt;p&gt;前段时间压力很大，所以一直睡不着觉，精力也随之变差，工作效率也随之下降，形成了一个恶性循环。失眠一直是我的一个大问题，我相信也是所有在大城市拼搏的人的问题，为了解决这个难题，大家都尝试过很多种方法，我也是。我最近在看《十分钟冥想》（后面看完后会写个简版的笔记），这本书里面讲的些内容让我豁然开朗。&lt;/p&gt;

&lt;p&gt;他说我们睡不着的人大多数都是在想，今天发生的事，以前发生的事，明天即将发生的事，或者今天的困难、明天的困难，总之我们在睡觉时一直在想这想那，注意力不在睡觉上。这是睡不着的主要原因，想太多，脑袋和身体一直处于紧绷状态。到了后半夜当发现我们发现想的太多了，很累的时候想让自己睡觉，就拼命的去抗拒它，试图让脑袋不要去想。但大脑由不得我们，你越抗拒，就越被这种抗拒而不得的情绪折磨。于是在你脑袋中又多了一种运作程序，即抗拒。&lt;/p&gt;

&lt;h4 id=&quot;解决方法是不要抗拒而选择旁观你不要试图去控制它们而是成为一个旁观者就像你在公交站等车时看着路边来来往往的车你不会有兴趣去挡住它们你只是注视着它们来了走了又来了又走了当你成为这样一个傍观者时你会发现这些来来往往的想法很无聊于是慢慢的你的脑袋开始放空最后宁静如水&quot;&gt;解决方法是，不要抗拒而选择旁观。你不要试图去控制它们，而是成为一个旁观者，就像你在公交站等车时看着路边来来往往的车，你不会有兴趣去挡住它们，你只是注视着它们来了走了，又来了又走了。当你成为这样一个傍观者时，你会发现这些来来往往的想法很无聊，于是慢慢的你的脑袋开始放空，最后宁静如水。&lt;/h4&gt;

&lt;p&gt;这就是冥想的过程，做一个自己脑袋的旁观者，让心宁静如水，清澈见底。&lt;/p&gt;

&lt;p&gt;这个过程里有一些技巧，我会在后面的文章中详细解剖一下，我们如何掌握这些技巧，让自己可以随时保持宁静，排除噪音，去除烦恼。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;除了冥想，平时里由于事情太多太杂，特别是在有了孩子后，生活的复杂度上升了一个台阶。生活的复杂度压垮了我很多次，脑袋用不过来。于是我从老婆大人那里学了一个技巧，把自己脑袋里想的都记下来，为脑袋腾出更多空间干别的事。把事都记下来，那样就不会占用你的脑袋了，脑袋里的东西太多，需要有地方放，要么完结掉，要么存起来，我选择存起来，放在印象笔记里，等空了在翻开来想想怎么解决。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;前面有篇文章介绍《精力管理》的读书笔记，自己也在不断的践行中，最近又发现了很多问题。&lt;/p&gt;

&lt;p&gt;生活和工作中总有那么段时期是困难的时期，困难时期最需要我们用精力去支撑。但我发现，越是困难时期越容易对精力的节约和储备放松警惕，于是每次在困难时期都会胡乱的使用精力，去所谓的放松一下，比如玩游戏，ktv，抽烟喝酒等，其实这些反而消耗了精力，增加了负担。&lt;/p&gt;

&lt;p&gt;我也是一样，有段时间总会掉入这个陷阱，在最需要精力去面对困难时会选择去逃避一下，把精力浪费在“轻松一下”上，使得第二天的没有体力，进而使得困难更加难以对付，逐步形成恶性循环，越放松越没有精力去应对困难，事情就变得越来越糟糕。&lt;/p&gt;

&lt;p&gt;最近我试着学习这个克制的技巧，让自己在最困难的时候告诉自己要克制要保存体力，在关键时刻不能浪费精力，锻炼一下并早早睡觉把精力补充的满满的用到第二天去面对困难。&lt;/p&gt;

&lt;p&gt;自从用了这个方法，我的情绪变的好多了，事情也变得更加顺利了，困难也慢慢迎刃而解。每次遇到紧张、压力、焦虑的心情时要保存自己的精力，并设法补充下自己的精力，今天解决不了的事情，就补充下精力到第二天去解决，让自己能有更多保持专注的时间和保持专注的精力去面对困难，&lt;/p&gt;

&lt;h4 id=&quot;坚守理智锻炼并补充精力以应对困难而不是随意的浪费让困难更难以对付&quot;&gt;坚守理智，锻炼并补充精力以应对困难，而不是随意的浪费，让困难更难以对付。&lt;/h4&gt;

</description>
               <pubDate>Sun, 25 Oct 2020 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2020/10/25/%E5%90%91%E5%86%85%E7%9C%8B%E8%87%AA%E5%B7%B18</link>
               <guid isPermaLink="true">http://www.luzexi.com/2020/10/25/%E5%90%91%E5%86%85%E7%9C%8B%E8%87%AA%E5%B7%B18</guid>
            </item>
        
            <item>
               <title>读书笔记(十二) 《汇编语言》</title>
               <description>&lt;p&gt;两个月前看完王爽著的《汇编语言》经过一段时间的休整，今天再次翻开来又有另一番滋味，趁着最近对底层原理这股热情，对书本的内容进行一些整理。&lt;/p&gt;

&lt;h4 id=&quot;我的初衷是希望更多的理解程序集在计算机中执行的原理我中意深度探索c对象模型里作者说的一句话他说我的经验告诉我如果一个程序员了解底层实现模型他就能够写出效率较高的代码自信心也比较高一个人不应该用猜的方式或是等待某大师的宣判才确定何时提供一个copy-constructor-而何时不需要这类问题的解答应该来自于我们自身对对象模型的了解&quot;&gt;我的初衷是希望更多的理解程序集在计算机中执行的原理，我中意《深度探索C++对象模型》里作者说的一句话，他说“我的经验告诉我，如果一个程序员了解底层实现模型，他就能够写出效率较高的代码，自信心也比较高。一个人不应该用猜的方式，或是等待某大师的宣判，才确定”何时提供一个copy constructor 而何时不需要“，这类问题的解答应该来自于我们自身对对象模型的了解”。&lt;/h4&gt;

&lt;p&gt;我们很多时候由于不了解底层的执行原来，导致我们在写代码的时候基本都靠猜，我们自认为的程序在计算机中的执行方式是这样的或是那样的。以前我猜过很长一段时间，但现在我不想猜了，我想了解所有关于计算机底层的执行原理，包括计算机设备的体系结构，计算机机器码的执行原理，面向对象模型的布局和执行原理。&lt;/p&gt;

&lt;h4 id=&quot;以下是我对书本内容的记录和理解&quot;&gt;以下是我对书本内容的记录和理解&lt;/h4&gt;

&lt;p&gt;我把这本书的理解分为，基础知识、总线、寄存器、寻址、跳转、中断，6个部分。书中写了很多案例，总53万字，我把这些知识精简一下，并说出我自己的理解。&lt;/p&gt;

&lt;h3 id=&quot;基础知识&quot;&gt;基础知识&lt;/h3&gt;

&lt;p&gt;我们知道机器指令是一列0和1构成二进制数字，为什么是0和1呢，因为它可以在设备中用高低电平表示。高低电平就是一个晶体管的两个状态，即有电流和没电流。&lt;/p&gt;

&lt;p&gt;一列010101二进制数字如果用数字电路来表示的话，就是一排晶体管。这排晶体管假如要做逻辑判断或计算的话，就需要涉及到逻辑门（即电流的走向逻辑），我们常接触到的逻辑门有，与（and）、非（not）、或（or）这三种逻辑门，除了这三种还有，与非门、或非门、反相器、异或门，通过这六种基础的逻辑门的组合，我们可以制造出很多很多复杂的逻辑门电路，比如加法数字电路、乘法数字电路等，计算器就是由众多逻辑门组合而成的，输入一排电流后得到一排电流的结果。&lt;/p&gt;

&lt;p&gt;由于0101形式的机器码，太难记忆，所以人们发明了汇编，它其实就是机器码的助记符，即某个10101的指令用一个英文符号来表示。因此汇编指令与机器指令的差别在于表示方式上，汇编是机器指令便于记忆的一种书写格式。我们程序员用汇编写出程序后，用汇编编译器将其翻译成机器码，再交由计算机执行。反过来也是一样，翻译完成的机器码（即一个可执行文件）也可以反过来翻译成汇编语言符号。&lt;/p&gt;

&lt;p&gt;我们常用的cpu处理器的发展过程，从8080到奔腾4的过程是，8080、8086/8088、80186、80286、80386、80486、奔腾、奔腾2、奔腾3、奔腾4.&lt;/p&gt;

&lt;p&gt;其中8086/8088开始被使用在了微机上，即我们现在的个人电脑。80386开始在微机上可以做多任务操作，一台个人电脑中的操作系统可以同时处理多项任务。虽然80286也具备了对多任务系统的支持，但它对8086/8088的兼容性支持比较差，所以过度非常困难，于是就有了80386，它既有多任务系统的功能也兼容了8086/8088。&lt;/p&gt;

&lt;h3 id=&quot;总线&quot;&gt;总线&lt;/h3&gt;

&lt;p&gt;CPU是计算机的核心，要让CPU工作就必须向它提供指令和数据，指令和数据存放在内存，因此内存的作用仅次于CPU。而磁盘则不同与内存，磁盘上的数据或程序集如果不读到内存中就无法被CPU使用，所以对CPU来说，磁盘其实是外部设备。计算机设备中除了CPU芯片外，其他设备中也有属于自己的芯片，比如内存芯片、磁盘芯片、键盘芯片、显卡芯片、网络芯片等等，这些芯片都有自己的寄存器，CPU可以通过这些寄存器与其他芯片进行交流。&lt;/p&gt;

&lt;p&gt;设备与CPU之间的交流都是数据交流（也就是不同高低平的电流），CPU在读写数据时要指明，它要对哪一个器件进行操作，进行哪种操作，是从中读出数据还是写入数据。&lt;/p&gt;

&lt;h4 id=&quot;那么cpu是通过什么将数据传到其他设备的芯片中去的呢在计算机中有专门连接cpu和其他芯片的导线电线或电流线我们称它为总线总线又分为3类地址总线控制总线数据总线&quot;&gt;那么CPU是通过什么将数据传到其他设备的芯片中去的呢？在计算机中有专门连接CPU和其他芯片的导线（电线或电流线），我们称它为总线。总线又分为3类，地址总线、控制总线、数据总线。&lt;/h4&gt;

&lt;p&gt;这3根总线的分类职责不同，地址总线用于指定内存单元地址，控制总线用于传输指令，数据总线用于传输数据。&lt;/p&gt;

&lt;p&gt;我们来举个例子，CPU要读取内存中3号单元的数据，CPU先通过地址线将地址信息3发给内存芯片，再通过控制总线发出读取内存的指令，指令中选中存储芯片，并通知它将要从中读取数据，最后内存芯片将3号单元中的数据通过数据线送入CPU。反过来，写的步骤也是类似，先通过地址总线将地址信息3发给内存芯片，再通过控制总线向内存芯片发出写入命令，最后通过数据总线将数据传入内心芯片。&lt;/p&gt;

&lt;h4 id=&quot;我们现在知道了地址总线能传输多少个二进制信息cpu就可以对多少个单元地址进行寻址数据总线也是一样有多少根决定了一次可传二进制数据的大小控制总线是个总称是一些不同控制线的集合有多少根控制总线就意味着cpu提供了对外部器件的多少种控制&quot;&gt;我们现在知道了，地址总线能传输多少个二进制信息，CPU就可以对多少个单元地址进行寻址。数据总线也是一样，有多少根决定了一次可传二进制数据的大小。控制总线是个总称，是一些不同控制线的集合，有多少根控制总线就意味着CPU提供了对外部器件的多少种控制。&lt;/h4&gt;

&lt;p&gt;现在我们一台机子上有很多存储器，包括随机存储器（RAM）、只读存储器（ROM）、显存RAM、网卡ROM等，这些存储器在物理上是独立的器件，它们都与CPU总线相连。&lt;/p&gt;

&lt;p&gt;CPU在地址传输的时候是怎么去识别到底传给哪个存储器的呢？CPU在操控它们的时候，把它们总的当作一个整体的内存空间来看待，相当于若干个存储器排列组成了一个逻辑存储器，每个存储器的存储地址与前一个是紧密连接的，我们称这整个存储空间为，内存地址空间。&lt;/p&gt;

&lt;p&gt;举个例子，假如所有存储器地址加起来为从64KB的空间，即总共0～FFFF的地址，那么主随机存储器的地址空间可能为32KB即 0～7FFF，显存地址空间可能为8KB即 8000～9FFF，其他各个ROM的地址空间为24KB 即 A000～FFFF。如果CPU向内存地址为1000的地址发送数据，就是向主随机存储器发送数据，如果向9000地址写入数据，则为显存空间。&lt;/p&gt;

&lt;p&gt;这里所说的都是外部总线，是CPU连接外部器件的导线集合。其实CPU内部也是有总线把各个部件连接起来的，一个CPU由运算器、控制器、寄存器等器件构成，这些器件就是靠内部总线相连，它们之间相互进行数据传输。&lt;/p&gt;

&lt;h3 id=&quot;寄存器&quot;&gt;寄存器&lt;/h3&gt;

&lt;p&gt;现代的CPU寄存器由很多种，我们拿最常用的一些来讲，即8086的14个寄存器，AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。&lt;/p&gt;

&lt;p&gt;通用寄存器有4个，AX、BX、CX、DX，它们可以存放一般性数据，可以看作是平时程序中的变量。它们中又有高低位寄存器来指向它们的高位和低位，即AH和AL为AX的高8位和低8位，BH和BL为BX的高8位和低8位，CH和CL为CX的高8位和低8位，DH和DL为DX的高8位和低8位。&lt;/p&gt;

&lt;p&gt;8086中可以一次性处理8位和16位数据，即字节（byte）和字（word）。即我们可以向AX中传数据也可以向AH和AL上传数据。&lt;/p&gt;

&lt;p&gt;我们来举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	mov ax,18 将18送入AX寄存器

	mov ah,78 将78送入AH寄存器

	add ax,8 将AX中的值加上8后覆盖AX

	现在ax中的值为86
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;在汇编代码中寄存器的用法有习惯性用法的讲究比如ax寄存器就是存放临时数据的bx则存放偏移地址数据cx存放的是循环计数数据dx则通常用来存放要访问的数据段地址而sidi与bx的作用一样存放的是内存偏移地址只是它们不能拆分为高低位&quot;&gt;在汇编代码中寄存器的用法有习惯性用法的讲究，比如AX寄存器就是存放临时数据的，BX则存放偏移地址数据，CX存放的是循环计数数据，DX则通常用来存放要访问的数据段地址。而SI、DI与BX的作用一样，存放的是内存偏移地址，只是它们不能拆分为高低位。&lt;/h4&gt;

&lt;p&gt;除了通用寄存器外，还有段寄存器，标志寄存器，也是汇编中重要的寄存器。&lt;/p&gt;

&lt;p&gt;段寄存器用于存放，段内存的起始地址和偏移地址。它们包括，CS、IP、SS、SP、BP、DS。&lt;/p&gt;

&lt;h4 id=&quot;其中cs和ip就是代码段寄存器cs指向代码段在内存中的起点ip则指向当前执行指令在内存起点中的偏移位置ip指向的地址就是程序要执行的指令位置&quot;&gt;其中CS和IP就是代码段寄存器，CS指向代码段在内存中的起点，IP则指向当前执行指令在内存起点中的偏移位置，IP指向的地址就是程序要执行的指令位置。&lt;/h4&gt;

&lt;h4 id=&quot;sssp和bp是内存栈的段寄存器其中ss指向栈内存段起点地址sp则指向当前栈顶偏移地址bp有点特殊它和sp联合使用作为sp校准使用因为sp要指向栈顶不能乱动所以sp把地址传给bp由bp来做栈内的寻址&quot;&gt;SS、SP和BP是内存栈的段寄存器，其中SS指向栈内存段起点地址，SP则指向当前栈顶偏移地址，BP有点特殊，它和SP联合使用作为SP校准使用，因为SP要指向栈顶不能乱动，所以SP把地址传给BP，由BP来做栈内的寻址。&lt;/h4&gt;

&lt;p&gt;对于栈操作，计算机有push和pop指令可以使用，即我们先定义号SS和SP好地址后用push和pop操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	mov ax, 123H ;给一个地址

	mov ss, ax ;段寄存器必须用寄存器操作数值

	mov sp, 100H ;设置栈顶，就是设置栈总大小

	push bp ;保存bp指针

	mov bp, sp ;把栈顶置针给bp，这时候如果函数有参数，则[bp + 2*4]就是第一个参数位置，[bp + 3*4]就是第二个参数位置，以此类推。

	mov ax, 22 ;把22给ax

	push ax ;ax中的值推入栈

	pop bx ;把栈中的值推出给bx

	现在bx中数据为22
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;最后是dsds则是静态数据段的寄存器指向静态数据段的起始地址所有在程序中的常量静态变量都被放在静态数据段中有ds数据段地址指向&quot;&gt;最后是DS，DS则是静态数据段的寄存器，指向静态数据段的起始地址，所有在程序中的常量、静态变量都被放在静态数据段中，有DS数据段地址指向。&lt;/h4&gt;

&lt;p&gt;有了指令内存地址，栈内存地址，静态数据内存地址，我们就可以根据数据执行指令，控制栈顶保存函数临时变量。&lt;/p&gt;

&lt;p&gt;标志寄存器则对各种标志位存储，它包括ZF（零标志）、OF（溢出标志）、DF（方向标志）、CF（进位标志）、PF（奇偶标志）、SF（符号标志）、TF（中断标志）、IF（屏蔽标志）等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	ZF 结果是否为0

	OF 加法是否溢出

	DF si、di的增减方向

	CF 进行无符号运算时记录最高有效位的进位值。

	PF 结果是否为偶数

	SF 结果是否为负

	TF 是否有中断程序

	IF 是否屏蔽中断
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些标志位都是被动被计算机赋值的，只有当我们结束某个操作指令后才会需要去查看它们。&lt;/p&gt;

&lt;h3 id=&quot;寻址&quot;&gt;寻址&lt;/h3&gt;

&lt;h4 id=&quot;绝大部分机器指令都是进行数据处理的指令处理大致可分为3类读取写入运算在机器指令这一层来讲并不关心数据的值是多少而关心指令执行前一刻它将要处理的数据所在的位置指令在执行前所要处理的数据可以在3个地方分别是cpu内部内存端口&quot;&gt;绝大部分机器指令都是进行数据处理的指令，处理大致可分为3类：读取、写入、运算。在机器指令这一层来讲，并不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置。指令在执行前，所要处理的数据可以在3个地方，分别是：CPU内部、内存、端口。&lt;/h4&gt;

&lt;p&gt;我们知道CPU通过内存来获得数据，在访问内存时要给出内存的地址，通过地址总线送入存储器芯片必须是一个内存单元的物理地址，于是CPU可访问的内存大小就受到地址总线的限制。&lt;/p&gt;

&lt;p&gt;8086CPU是16位结构的CPU，也就是说8086内部职能一次性处理和传输总长16位的信息，如果将地址从内部简单发出，那么它只能送出16位地址，即只能访问0～FF之间的地址，表现出的寻址能力时64K。&lt;/p&gt;

&lt;h4 id=&quot;这样的寻址能力太少于是cpu采用了一种内部用两个地址合成一个地址的方法来增加寻址能力即段地址偏移地址--物理地址这样就一下子增加了1倍的寻址能力如果地址总线够宽的话可惜8086只有20根总线因此最大寻址能力只能提高到1mb&quot;&gt;这样的寻址能力太少，于是CPU采用了一种内部用两个地址合成一个地址的方法来增加寻址能力，即“段地址+偏移地址 = 物理地址”，这样就一下子增加了1倍的寻址能力，如果地址总线够宽的话。可惜8086只有20根总线，因此最大寻址能力只能提高到1MB。&lt;/h4&gt;

&lt;p&gt;我们现代计算机中也运用了同样的寻址方式，但是现代计算机中地址总线只有32条和40条，即32位CPU处理器原本只能处理4G内存，64位CPU处理器原本只能处理1T内存（而且还要受到其他地址总线的限制，比如内部总线）。&lt;/p&gt;

&lt;p&gt;段地址是重要的标记位置，是一段内存的起点，因此在程序中有专门的寄存器来存储它们，就是我们前面说的，CS、IP、SS、SP、BP、DS、ES。&lt;/p&gt;

&lt;p&gt;寻址方式分，直接寻址、间接寻址、基址变址寻址，即如下：&lt;/p&gt;

&lt;h4 id=&quot;例子1数据段寻址&quot;&gt;例子1，数据段寻址：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;	mov bx, 1000H ;将1000数据送入bx

	mov ds, bx ;将bx里的数据送入ds

	mov al, [0] ;将ds段地址加上0得到的1000H:0，在该内存地址单元中的数据送入al寄存器

	mov [0], bx ;将bx的数据送入1000H:0内存地址单元中
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;例子2寄存器寻址&quot;&gt;例子2，寄存器寻址：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;	mov bx, 1000H ;将1000H送入bx

	mov ax, [bx] ;根据bx中的值去内存中的单元地址中的值，传送给ax

	mov ax, [bx + 123] ;根据bx+123得到的值去内存中的单元地址中取值，传送给ax

	mov ax, [bx + si] ;根据bx + si的到的值去内存中取值，传送给ax

	mov ax, [bx + si + 123] ;根据bx + si + 123得到的值去内存中的单元地址中取值，传送给ax
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;例子3段地址寻址&quot;&gt;例子3，段地址寻址：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;	mov bx, 1000H ;将1000H送入bx

	mov cs, bx ;将bx的值送入cs代码段寄存器

	mov ax, 0 ;将0送入ax

	add ax, cs:[bx] ;用段地址+偏移地址的方式获得cs+bx地址，并从该地址上取得数值送入ax
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;例子4不同类型的数据放入不同的段&quot;&gt;例子4，不同类型的数据放入不同的段：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;	assume cs:code, ds:data, ss:stack

	data segment ; 定义data内容

		dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh ;dw为字内容即2个byte

	data ends

	stack segment ; 定义stack内容

		dw 0,0,0,0,0,0

	stack ends

	code segment ; 定义code内容

		mov ax, statck ; 将statck地址送入ax

		mov ss, ax ; 将ax内容送入ss栈段寄存器

		mov sp, 20h ; 将栈顶定义为20h大小

		mov ax, data ; 将data定义为

		mov ds, ax ; 将ax数据传入ds数据段寄存器

		mov bx, 0 ; 将0传入bx

	code ends

	end start
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;跳转&quot;&gt;跳转&lt;/h3&gt;

&lt;p&gt;计算机执行机器指令时是顺序的并且根据代码段指针在没有跳转的情况下依次执行下去，这个指针就是IP寄存器。因此跳转就是将原本IP寄存器指向的地址改为我们指定的地址，这样计算机根据IP指针指向的机器指令可以随意操控了。&lt;/p&gt;

&lt;p&gt;最常用的跳转就是loop。计算机在执行loop指令时每次都会在先将cx中的值减1，再判断cx是否为0，如果不为零则跳转到指定地址：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	mov cx, 11 ; 将11传送给cx

	mov ax, 1 ; 将1传送给ax

	s: add ax, ax ; 将ax加上ax的值传入ax

	   loop s  ; 先做cx=cx-1操作，再判断cx是否为零，如果不是零则跳转到 s位置，如果是零则继续下一条
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了修改IP来实现跳转外，我们也可以通过就该CS代码段地址来实现跳转。&lt;/p&gt;

&lt;h4 id=&quot;只修改ip实现的跳转我们称为段内跳转也称短跳转因为跳转范围在一个寄存器大小范围内而同时修改cs和ip实现的跳转我们称为段间跳转也称为长跳转&quot;&gt;只修改IP实现的跳转，我们称为段内跳转，也称短跳转，因为跳转范围在一个寄存器大小范围内。而同时修改CS和IP实现的跳转，我们称为段间跳转，也称为长跳转。&lt;/h4&gt;

&lt;p&gt;常用的跳转指令有：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	无条件跳转 jmp

	有条件跳转 je(相等就跳转)，jcxz（判断cx为0就跳转）

	循环跳转   loop

	调用跳转 call，ret（使用栈中数据修改IP内容实现近跳转），retf（用栈中数据修改CS和IP实现远跳转）

	中断跳转   int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面有些一般形式的跳转我们都会理解的比较快，比如jmp，je，jcxz，和loop，都是通过寻址地址跳转，或先做某个判断再跳转。和我们平时写的代码中的，if…else，goto，for循环，switch有很多相似之处，因此理解起来相对比较容易，最多也只是多了一个远近的跳转，也好理解，近跳转只修改IP，远跳转修改了CS和IP。&lt;/p&gt;

&lt;h4 id=&quot;callretretf和我们平时编写的函数有紧密的联系&quot;&gt;call、ret、retf和我们平时编写的函数有紧密的联系。&lt;/h4&gt;

&lt;p&gt;当call被调用时，它先将当前IP或CS和IP推入到栈中，再进行转移。执行call时相当于：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	push IP

	jmp 某寄存器
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而ret和retf在执行时，会先从栈中推出一个数据传送给IP，或推出2个数据传送给CS与IP。&lt;/p&gt;

&lt;p&gt;ret相当于：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	pop IP
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;retf相当于&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	pop IP

	pop CS
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;这两个指令很像我们代码中的函数调用function-call-和-return时的作用我们来看看这两个指令配合起来是如何运作的&quot;&gt;这两个指令很像我们代码中的函数调用function call 和 return时的作用。我们来看看这两个指令配合起来是如何运作的：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;	mov ax, 1 ;将1传送给ax

	mov cx, 3 ;将3传送给cx

	call s ;先push IP 并且 jump s，指令跳到s段地址上

	mov bx, ax ;将ax的值传送给bx

	mov ax, 4c00h ;将4c00h传送给ax

	int 21h ;中断调用，结束

	s: add ax, ax ;将ax值相加传送给ax

	   loop s ;先cx减去1传送给cx，再判断cx是否为0，如果不为0条转到s，如果为0则继续下一个

	   ret ;pop IP，从栈中取的前面call时推入的地址给IP，实现跳转到 call s 那句指令下

	最后结束前，bx为8，loop了跳转了3次，ax从1自增到了8，call跳转到了s做了循环，做完循环ret又回到了call s下。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;有了function和ret的概念我们就可以传递更多参数到栈中在function里去取出栈中的值进行计算在汇编里会变得如何呢我们来看看&quot;&gt;有了function和ret的概念，我们就可以传递更多参数到栈中，在function里去取出栈中的值进行计算，在汇编里会变得如何呢，我们来看看：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;	mov ax 1000 ;将1000传入ax

	mov ds ax ;通过ax设置数据内存单元

	mov [101] 10 ;将10传送到数据内存101地址单元上

	mov [102] 20 ;将20传送到数据内存102地址单元上

	push [101] ;将101数据内存地址单元上的数据推入栈中

	push [102] ;将102数据内存地址单元上的数据推入栈中

	mov ax, 1 ;将1传入ax

	call s ;先push IP，再将IP设置为 s段地址上

	mov bx, ax ;将ax中的数值传送给bx

	mov ax 4c00h ;将4c00h传送给ax

	int 21h ;中断调用，结束

	s: pop bx ;从栈中推出数据给bx，其实就是IP值

	   pop dx ;从栈中推出数据给dx，其实就是[102]的值

	   add ax dx ;将ax和dx相加传送给ax

	   pop dx ;从栈中推出数据给dx，其实就是[101]的值

	   add ax dx ;将ax和dx相加传送给ax

	   jmp bx ;直接跳转到call s的位置
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述程序利用了栈传递数据，在调用 call s之前，在栈中推入了内存地址101和102的值，到s中执行计算时分别推出了IP和两个数据，做完加法后跳转到call s的原位置下，继续执行直到结束。&lt;/p&gt;

&lt;h2 id=&quot;中断&quot;&gt;中断&lt;/h2&gt;

&lt;p&gt;中断分内部中断和外部中断，中断的意思是CPU不再接着向下执行，而是转去处理特殊的信息。&lt;/p&gt;

&lt;p&gt;CPU具备一种能力，可以在执行完当前正在执行的指令后检测到从CPU外部发过来的或者内部产生的一种特殊信息，并立即处理接收到的信息，这就是中断信息。&lt;/p&gt;

&lt;p&gt;内部中断比如CPU在除法时溢出就会触发内部的中断程序，外部中断比如收到键盘的输入数据时会触发中断程序。&lt;/p&gt;

&lt;p&gt;用来处理中断信息的程序被称中断处理程序，一般来说，需要对不同的中断信息编写不同的处理程序。&lt;/p&gt;

&lt;p&gt;每个中断程序都有一个中断码，通过中断码我们可以找到中断程序。在计算机内存中有一块内存是专门存放中断码和对应的中断程序地址的，我们称为中断向量表：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	0号 -&amp;gt; 中断程序入口地址

	1号 -&amp;gt; 中断程序入口地址

	...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当程序引发中断时过程如下，我们假设发生了除法溢出错误，产生了0号中断信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	1.除法溢出，产生中断信息，取得中断码

	2.标志寄存器的值入栈（因为在中断过程中要改变标志寄存器值）

	3.设置标志寄存器TF和IF的值为0

	4.CS和IP入栈

	5.根据中断码从中断向量表中取出中断处理程序的入口地址
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中断程序编写的方法和子程序相似：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	1.保存用到的寄存器

	2.处理中断

	3.恢复用到的寄存器

	4.调用iret指令返回
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;iret指令功能可描述为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	pop IP ;推出地址给指令指针IP

	pop CS ;推出地址给指令段地址给CS

	popf ;推出标志寄存器
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;除了系统自带的中断程序外我们也可以自己安装中断程序例如我们常用的try-cache-和-throw-就是利用安装中断程序来做抓异常的功能的&quot;&gt;除了系统自带的中断程序外，我们也可以自己安装中断程序，例如我们常用的Try cache 和 throw 就是利用安装中断程序来做抓异常的功能的。&lt;/h4&gt;

&lt;p&gt;我们来看看，安装中断程序时如何做的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	mov ax, cs ;将cs地址传入ax

	mov ds, ax ;将ax地址传入ds，为后面拷贝做准备

	mov si, offset ss ;设置ds:si指向地址

	mov ax, 0 ;将0传入ax

	mov es, ax ;将ax传入es

	mov di, 200h ;设置es:di指向目的地址

	mov cx, offset sqrend-offset ss ;设置ss中断程序长度

	cld ;设置传输方向为正

	rep movsb ; 拷贝ds:si到es:di

	mov ax, 0 ; 设置ax为0

	mov es, ax ; 将ax的0传入es

	mov word ptr es:[7ch*4], 200h ; 修改中断编码7ch的中断程序入口地址

	mov word ptr es:[7ch*4 + 2], 0 ; 修改中断编码7ch的中断程序入口地址

	mov ax, 4c00h ;设置ax

	int 21h ; 结束中断

	ss: mul ax ;中断程序，ax乘以ax传入ax

	    iret ;恢复中断
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们将ss这段程序放入了中断向量表7ch中去，当我们执行 int 7ch 时就执行了ss段程序，虽然这个程序执行完毕后就没有在内存了，但ss这段指令已经被拷贝到了内存中。&lt;/p&gt;

&lt;h4 id=&quot;我们来看看bios和dos在启动时时如何安装它们的中断程序的&quot;&gt;我们来看看BIOS和DOS在启动时时如何安装它们的中断程序的。&lt;/h4&gt;

&lt;p&gt;1.开机后，CPU一加电，初始化(CS)=0FFFFh，(IP)=0，自动从FFFF:0单元开始执行程序。FFFF:0出油一条跳转指令，CPU执行该指令后转去执行BIOS中的硬件系统检测和初始化程序。&lt;/p&gt;

&lt;p&gt;2.初始化程序将建立BIOS所支持的中断向量表，将BIOS提供的中断程序的入口地址登记在中断向量中。&lt;/p&gt;

&lt;p&gt;3.硬件系统检测和初始化完成后，调用 int 19h 进行操作系统的引导。从此将计算机交由操作系统控制，DOS开始初始化程序。&lt;/p&gt;

&lt;p&gt;4.DOS启动后，除完成其他工作外，还将它所提供的中断程序装入内存，并添加到相应的中断向量表中。&lt;/p&gt;

&lt;h4 id=&quot;外部中断&quot;&gt;外部中断&lt;/h4&gt;

&lt;p&gt;前面说CPU总线连接了很多芯片，这些芯片都有一组可以由CPU读写的寄存器，虽然这些寄存器都在不同的芯片中，但它们都与总线相连，CPU可以通过控制总线对它们进行读写。&lt;/p&gt;

&lt;p&gt;从CPU的角度看，将这些寄存器都当作端口，对它们进行统一编址，从而建立了一个统一的端口地址空间。每个端口在地址空间中都有一个地址。&lt;/p&gt;

&lt;p&gt;在访问端口时，CPU通过端口地址来定位端口，端口地址范围为0～65535。&lt;/p&gt;

&lt;p&gt;访问端口与访问内存略有不同，访问内存使用mov ax, ds:[8]，将内存地址数据段中的8单元地址上的数据传送到ax，而端口则是 in al, 60h，从60h号端口读入1个字节的数据送入al，out 20h, al 将al上的数据传入到20h端口。&lt;/p&gt;

&lt;p&gt;CPU有了与外部芯片通信的机制，就可以接受外部中断信息。比如，外设的输入到达时，相关芯片就会向CPU发出相应的中断信息。CPU在执行完当前指令后，检测到发过来的中断信息，引发了中断过程，跳转到中断程序处理外设的输入数据。&lt;/p&gt;

&lt;h4 id=&quot;我们来看看计算机时如何处理键盘输入中断的&quot;&gt;我们来看看计算机时如何处理键盘输入中断的：&lt;/h4&gt;

&lt;p&gt;1.键盘上每个键都相当于一个开关，键盘中有一个芯片对键盘上的每个键的开关状态进行扫描。&lt;/p&gt;

&lt;p&gt;2.按下一个键时，开关接通，该芯片就产生了一个扫描码，扫描码被送入主板上的接口芯片(usb接口)的寄存器中，该寄存器的端口地址通常为60h。&lt;/p&gt;

&lt;p&gt;3.松开按下的键时，也会产生一个扫描码，也同样被送入主板上的接口芯片(usb接口)的寄存器中。&lt;/p&gt;

&lt;p&gt;4.当键盘的输入到达60h端口时，接口芯片就会向CPU发送中断码。CPU检测到该中断信息后，如果IF=1则认为是不可屏蔽中断，接着响应中断引发中断过程，转去执行int 9的中断程序。&lt;/p&gt;

&lt;p&gt;5.BIOS提供了int 9的中断程序，读出60h端口中的扫描码，并送入到内存的键盘缓存中，如果是Ctrl之类的控制键则写入内存中存储状态字节单元，接收完成后向接口芯片发出应答信息。&lt;/p&gt;

&lt;p&gt;6.CPU继续根据内存中键盘缓存中的数据执行相关程序，响应键盘的输入。&lt;/p&gt;

&lt;h4 id=&quot;除了键盘外磁盘也是外部设备的一种也同样需要通过端口和中断的形式处理相关程序&quot;&gt;除了键盘外，磁盘也是外部设备的一种，也同样需要通过端口和中断的形式处理相关程序。&lt;/h4&gt;

&lt;p&gt;BIOS和操作系统都提供了访问磁盘的中断程序。当需要向磁盘访问数据时，会先在寄存器和内存上设置访问的地址和大小，再发起中断，中断程序会根据设置在寄存器和内存上的信息从磁盘上传输到内存，传输完毕后结束中断。&lt;/p&gt;

&lt;p&gt;下面这个写入数据到3.5英寸软盘为例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	mov ax, 0

	mov es, ax

	mov bx, 200h ; ex:bx指向写入磁盘的数据

	mov al, 1 ; 读取的扇区数

	mov ch, 0 ; 磁道号

	mov cl, 1 ; 扇区号

	mov dl, 0 ; 驱动器号

	mov dh, 0 ; 磁头号

	mov ah, 3 ; 表示写入

	int 13h ; 执行磁盘写入中断
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CPU首先需要告诉磁盘设备，写入还是读取，接着要告诉磁盘写入的内容，以及写入的地址，中断程序在执行完毕写入操作后，结束中断并返回原地址。&lt;/p&gt;

&lt;h4 id=&quot;总结汇编其实就是机器码的助记符它有很多个寄存器每个寄存器都有不同的用途内存分为几个段不同的内存段有不同的用途通常包括有静态数据段代码段栈空间段我们通过指令可以在内存中寻址也可以在不同的段之间跳转cpu和设备之间用总线连接在一起总线又分为地址总线数据总线控制总线每个设备又都有自己的芯片它们与cpu的通信方式就是通过自己的寄存器cpu统一称它们为端口并为它们做了统一的编号除内存外设备与cpu之间的通信通常使用中断来进行中断程序执行完毕后会跳转到原位置继续执行下面的程序指令&quot;&gt;总结，汇编其实就是机器码的助记符，它有很多个寄存器，每个寄存器都有不同的用途，内存分为几个段，不同的内存段有不同的用途，通常包括有静态数据段、代码段、栈空间段，我们通过指令可以在内存中寻址，也可以在不同的段之间跳转。CPU和设备之间用总线连接在一起，总线又分为地址总线，数据总线，控制总线，每个设备又都有自己的芯片，它们与CPU的通信方式就是通过自己的寄存器，CPU统一称它们为端口并为它们做了统一的编号。除内存外，设备与CPU之间的通信通常使用中断来进行，中断程序执行完毕后会跳转到原位置继续执行下面的程序指令。&lt;/h4&gt;

</description>
               <pubDate>Sun, 18 Oct 2020 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2020/10/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B012</link>
               <guid isPermaLink="true">http://www.luzexi.com/2020/10/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B012</guid>
            </item>
        
            <item>
               <title>读书笔记(十一) 《精力管理》</title>
               <description>&lt;p&gt;前面有一段时间，对时间管理着迷，想着能不能通过自我管理的方式去实现更高效率的学习与工作。&lt;/p&gt;

&lt;p&gt;2019年初，大概有几个月的时间，我用时间限制的方式去履行自己的计划。这段时间非常痛苦，后来我接触了《精力管理》，2019年10月时看完了这本书，发现精力管理比时间管理要好的多，原因是精力管理并不是泯灭人性的，它顺从人性，以精力为基础来告诉我，怎样才能保持活力，扩充精力，打破了时间上的局限。&lt;/p&gt;

&lt;p&gt;去执行时间管理的这段时间，其实没有白跑，给了很多启示和感悟，我也一直在不断调整自己的作息、生活、工作方式。我接触精力管理后虽然认同，但仍然没有完全放弃时间管理，因为我一直认为时间是比较重要的因素，从那时到现在我尝试了，每日任务、时间块记录、时间限制、打卡表的方式去管理我每日的精力。虽然嘴上说着精力管理，但其实对时间管理的相当严格。&lt;/p&gt;

&lt;p&gt;在坚持对时间把控的这段时间，其实出了很多问题，我过分关注时间，过分关注自律，导致我的效率虽然提升了些许，但没有像想象的那么好，情绪上也有过反抗和厌弃。我隐隐的知道对精力管理的理解犯了很多错误，似乎我的行动和计划有点偏离了轨道。“肯定是我理解错了”，我这样告诉我自己。&lt;/p&gt;

&lt;p&gt;我想要的是更高效率的学习、工作和生活，但为什么看似把所有时间利用的很紧凑，也主动去调节自己的情绪和身体的状态，但效率很难提上来，于是我再次阅读了这本书，这次我想把它的弄的明白些。我秉持着不完全相信别人的话的原则去审视这些内容，再次看完后我仍然认为这本书上所讲的值得我们深度参考。&lt;/p&gt;

&lt;p&gt;我现在是怎么想的呢？我认为人应该从各个方面去扩充自己的精力，并且不是每件事都要竭尽全力去完成的，找出最重要的、最关键的、性价比最高的事情，把精力投入进去，现在的我又加入了一个参考事项，即自己最感兴趣的事，当我发现我对某件事特别感兴趣事（感兴趣的程度非常强烈才算），我会投入大量精力去做去学习，此时的学习效率是最高的，因为我对这件事很好奇很喜欢也很开心去做。短期的最重要和长期的最重要又是不同的，积跬步至千里很必要，给自己一个长期的目标和计划去执行，每天都做一些自己认为对自己长期计划有用的事（比如看书、锻炼、写作），这些事最好能在早上完成，对于一天的开始，我们就能信心满满的去面对，每一天的好的开始是一天成功的一半。&lt;/p&gt;

&lt;h3 id=&quot;下面是我对全书的记录和理解&quot;&gt;下面是我对全书的记录和理解&lt;/h3&gt;

&lt;p&gt;全书着重强调的一点是：精力，而非时间，是高效表现的基础。&lt;/p&gt;

&lt;p&gt;它说我们做每件事都需要精力，不管是与同事互动、作出每个决定、陪伴家人都需要精力。有技巧的精力管理是高度表现、健康和幸福的基础。&lt;/p&gt;

&lt;p&gt;事实确实是这样，很多时候我们仅仅希望竭尽所能去完成工作或为生活做出尽可能多的努力，但事实上我们会为眼前的现状作出临时的决策来透支自己，短期这会让现状运作良好，而负面效应却往往在长期的过程中慢慢浮现。面对工作和生活的无尽索取，我们会变得暴躁、易怒，注意力也难以集中，于是结束漫长的一天，我们疲惫的回到家，发现家庭也不再是欢乐和力量的源泉，它成为了超负荷运转的一项负担。&lt;/p&gt;

&lt;p&gt;我们常常会通过减少睡眠、点外卖填饱肚子、用咖啡提神、用酒精和安眠药放松身心等，短期透支自己的方式来确保自己能够完成短期目标。&lt;/p&gt;

&lt;p&gt;短期完成目标确实很重要，但我们每天都很忙，我们总是为一个接一个的短期目标不断的透支自己，停不下来，这是问题的根本。&lt;/p&gt;

&lt;h3 id=&quot;我们人的精力有四个来源体能精力情感精力思维精力意志精力&quot;&gt;我们人的精力有四个来源，体能精力、情感精力、思维精力、意志精力。&lt;/h3&gt;

&lt;p&gt;通过对这4个来源的调整和训练，我们可以掌握精力使用和拓展技巧。&lt;/p&gt;

&lt;h4 id=&quot;体能精力&quot;&gt;体能精力&lt;/h4&gt;

&lt;p&gt;从生理学的角度看，精力来源于氧气和血糖的化学反应。从实际生活来看，精力储备取决于我们的呼吸模式、进食的内容和时间、睡眠的长短和质量、白天间隙恢复的程度以及健康程度。&lt;/p&gt;

&lt;p&gt;因此建立起体能消耗和恢复的节奏性平衡，能够确保精力储备保持在相对稳定的水平。而走出舒适区，然后等待恢复，则是拓展体力的方法，适用于体力无法满足要求的情况。&lt;/p&gt;

&lt;p&gt;为了能让体能精力有用良好的表现，我们需要对自己生活中的体能消耗、恢复、拓展做些调整。&lt;/p&gt;

&lt;p&gt;第一就是调整饮食方式。由于任何一顿丰富的食物都不足以维持4-8小时高效表现，因此我们最好一天内吃5-6餐低热量高营养的食物，少吃多餐并且是低热量高营养，少一些碳水化物和油腻食物，多一些高蛋白食物。进食也需要讲究一下，其一不要让自己感到饥饿才去进食，此时精力早已耗尽。其二不要去追求饱腹感，吃后会感到撑胀，这样会额外消耗一部分我们的精力，补充精力不充分。其三要多喝水，水是调节身体内部运转的有力催化剂。&lt;/p&gt;

&lt;p&gt;第二，调整生理周期和睡眠。充足的睡眠是活力的保障，思维能力，即反应时间、专注力、记忆力、逻辑分析和辩证能力，会随着睡眠不足而衰退。我们人每晚需要7-8小时的睡眠才能在第二天运转良好。除了充足的睡眠，小息也是一种精力恢复的手段，睡眠研究员、心理学家发现每4个小时小睡20-30分钟仍可以保持超过24小时的惊人高效和敏锐。&lt;/p&gt;

&lt;p&gt;第三，增加体能训练。体力丧失是机体衰老和能力下降的显著特征，随着年龄的增长，新陈代谢速度减慢，过了40岁如果没有日常的力量训练，人们将平均每年失去0.5磅的肌肉重量。力量训练可以全面增强精力、加速新陈代谢、强健心脏。&lt;/p&gt;

&lt;h4 id=&quot;精力消耗和再生都是活跃的生理过程从经验上看体能情感思维意志精力的单线化消耗都不利于最优表现甚至会随着时间出现潜在的危害因此我们需要注意在消耗精力的同时加入更多的补充饮食小息锻炼以恢复和拓展精力&quot;&gt;精力消耗和再生都是活跃的生理过程，从经验上看，体能、情感、思维、意志精力的单线化消耗都不利于最优表现，甚至会随着时间出现潜在的危害。因此我们需要注意在消耗精力的同时加入更多的，补充饮食、小息、锻炼，以恢复和拓展精力。&lt;/h4&gt;

&lt;h4 id=&quot;情感精力&quot;&gt;情感精力&lt;/h4&gt;

&lt;p&gt;情感精力可以将威胁转化为挑战，为了发挥出最佳水平，我们必须调动积极愉悦的感情：喜悦的、爱挑战的、爱冒险的，这样才能保持正面积极的精力。在实际应用中，自信、自控、社交技巧及共情能够牵动积极情感的肌肉。&lt;/p&gt;

&lt;p&gt;若要调动情感肌肉塑造最佳表现，也同样要创造定期使用和间歇恢复的平衡，以及拓展情感肌肉。说实在的，这比起体力层面要困难的多。&lt;/p&gt;

&lt;p&gt;压力和负面情绪是消耗情感肌肉的主要途径，那么如何恢复呢？答案是获得正面情感。正面情感可以更有效地支配个人表现，它对团体也有积极的影响。&lt;/p&gt;

&lt;p&gt;第一就是兴趣活动。由于我们人的兴趣各异，这些兴趣可以激发出我们的正面情绪，即享受、满足和安全感。有些人可能喜欢唱歌、园艺、跳舞、亲热、练瑜伽、读书、体育活动、听音乐会，或仅仅静坐自省。&lt;/p&gt;

&lt;h4 id=&quot;这其中的关键是要表达出你对这些兴趣活动的重视并将投入在它们上面的时间视为神圣不可侵犯这些活动对你的吸引力越大程度越丰富生动性越强对情感再生的深度和质量也越好不仅快乐本身便是奖赏从更实际的角度看快乐也是维持最佳表现的重要因素&quot;&gt;这其中的关键是要表达出你对这些兴趣活动的重视，并将投入在它们上面的时间视为神圣不可侵犯。这些活动对你的吸引力越大，程度越丰富，生动性越强，对情感再生的深度和质量也越好。不仅快乐本身便是奖赏，从更实际的角度看，快乐也是维持最佳表现的重要因素。&lt;/h4&gt;

&lt;p&gt;第二，让人际关系促进精力再生。一段健康的友谊可以带来积极的情感精力，例如在工作环境中交一位好友，与好友有丰富的互动，包括付出与回报、倾诉与倾听、珍视他人和被人同等珍视。不仅如此，在家中与妻子的亲密互动，与孩子们的亲密互动，在学校中与同学们以及亲密好友的交头接耳，都可以认为是从人际关系角度促进精力再生的方式。这给我们带来了情感上的滋润、放松、享受。&lt;/p&gt;

&lt;p&gt;第三，积极扩充情感容量。我们可以通过一些仪式习惯来达成，比如定期与同事有深入的交流，定期与家人有一段亲密的互动，定期去做些公益活动，定期去上语言和心理学课程等。&lt;/p&gt;

&lt;h4 id=&quot;情感容量的最高境界是接纳不同情感的能力我们很容易重视某些情绪技巧而忽略了另外一些比如我们可能过于看重强硬而藐视温和也可能恰恰相反其实两种品质对情感肌肉同等重要还有很多相互对立的品质例如自控与积极坦率与感伤慷慨与节俭开放与审慎激情与淡漠耐心与急迫谨慎与鲁莽自信与谦逊等&quot;&gt;情感容量的最高境界是接纳不同情感的能力，我们很容易重视某些情绪技巧而忽略了另外一些。比如我们可能过于看重强硬而藐视温和，也可能恰恰相反。其实两种品质对情感肌肉同等重要。还有很多相互对立的品质，例如自控与积极，坦率与感伤，慷慨与节俭，开放与审慎，激情与淡漠，耐心与急迫，谨慎与鲁莽，自信与谦逊等。&lt;/h4&gt;

&lt;h4 id=&quot;只有接受那些看似相反的品质不逼自己在其间二选一才有可能获得最深刻最丰富的情感能力&quot;&gt;只有接受那些看似相反的品质，不逼自己在其间二选一，才有可能获得最深刻最丰富的情感能力。&lt;/h4&gt;

&lt;h3 id=&quot;思维精力&quot;&gt;思维精力&lt;/h3&gt;

&lt;p&gt;思维精力可以让我们保持专注。为了发挥出最好的水平，我们必须保持专注，在整体方向和局部目标之间灵活游走，一方面我们要看清事物的本质，另一方面我们还要朝着目标成果积极努力。而缺乏思维精力会让我们注意力涣散，过于悲观，思维固化，眼光狭窄。&lt;/p&gt;

&lt;p&gt;体能、情感、思维，三方面的精力是相辅相成的，身体层面睡眠少或亚健康导致的疲倦，会使得注意力难以集中；感情层面的焦虑、挫败、愤怒的情绪也会干扰注意力，损害乐观心态，尤其是面临高强度压力的情况时。&lt;/p&gt;

&lt;p&gt;那么怎么来优化思维精力呢？&lt;/p&gt;

&lt;p&gt;第一，在放松中思考。世界上绝大多数工作环境都充斥着一条或明显或隐晦的错误信息，长时间连续工作是高产出的最佳途径，按时休息不会受到奖励，白天抽时间活动不会得到赞扬等等。这些都错误的认知，只有在放松中思考（或者说间歇性休整）才能真正迸发出创造力。&lt;/p&gt;

&lt;p&gt;《如何像达芬奇一样思考》一书中提出了颇为深意的问题“什么场合你会获得最佳灵感？”，经过多年的收集，最普遍的答案是：沐浴的时候、躺床上的时候、在自然中散步的时候、听音乐的时候、慢跑的时候、冥想的时候、做梦和海边度假的时候等等。&lt;/p&gt;

&lt;p&gt;达芬奇也曾说过“最伟大的天才，有时工作越少成果越出色。时不时离开工作放松一下是个非常好的习惯，当你回到工作时，做出的判断会更加准确。”。&lt;/p&gt;

&lt;h4 id=&quot;精神外科专家罗杰用科学的方式解释了这种现象大脑左半球有语言神经有条理按次序地工作通过逻辑推演得出结论右半球更擅长视觉化和空间概念有更强的全局观能将事物的部分与整体联系起来间隙地让右大脑主持大局可以让我们从占据我们多数工作时间的左脑理性分析模式中脱离出来得到有效恢复&quot;&gt;精神外科专家罗杰用科学的方式解释了这种现象，大脑左半球有语言神经，有条理、按次序地工作，通过逻辑推演得出结论，右半球更擅长视觉化和空间概念，有更强的全局观，能将事物的部分与整体联系起来。间隙地让右大脑主持大局，可以让我们从占据我们多数工作时间的左脑理性分析模式中脱离出来，得到有效恢复。&lt;/h4&gt;

&lt;p&gt;因此为了能够有更多的创造力，我们应该间隙的调动左右半脑交替思考。&lt;/p&gt;

&lt;p&gt;第二，重塑大脑。我们要重点强调的是，积极使用大脑能够提升其运转能力，反之使用不足则会萎缩。不管你处于什么年龄段，都可以持续优化大脑，大脑会因为使用而日益敏锐，越磨越锋利。&lt;/p&gt;

&lt;h4 id=&quot;年轻人的思维具有很强的可塑性学习一门新语言之类的复杂过程都轻而易举随着年龄的增长思维肌肉的调动越来越少学习新语言或新技能就变得更加困难带来了加倍的挫折感为了避免不适感有时是避免丢脸人们很容易放弃结果导致本可避免的大脑退化进一步加重&quot;&gt;年轻人的思维具有很强的可塑性，学习一门新语言之类的复杂过程都轻而易举。随着年龄的增长，思维肌肉的调动越来越少，学习新语言或新技能就变得更加困难，带来了加倍的挫折感。为了避免不适感（有时是避免丢脸），人们很容易放弃，结果导致本可避免的大脑退化进一步加重。&lt;/h4&gt;

&lt;h4 id=&quot;其实每当人们学习新的事物时都会建立起大脑细胞新的联结即使你已经出现老化的征兆甚至部分大脑细胞受损你仍然可以依靠这些新的联结完就部分脑细胞学习新的体育活动可以帮助我们打造新的肌肉学习新的电脑技能新的课程新的语言和单词能够帮助我们锻炼大脑塑造思维肌肉&quot;&gt;其实每当人们学习新的事物时，都会建立起大脑细胞新的联结。即使你已经出现老化的征兆，甚至部分大脑细胞受损，你仍然可以依靠这些新的联结完就部分脑细胞。学习新的体育活动可以帮助我们打造新的肌肉，学习新的电脑技能，新的课程，新的语言和单词，能够帮助我们锻炼大脑，塑造思维肌肉。&lt;/h4&gt;

&lt;h3 id=&quot;意志精力&quot;&gt;意志精力&lt;/h3&gt;

&lt;p&gt;这里需要解释一下，书中的意志精力并不是我们理解的“意志力”或“毅力”。他想表达的是，精神层面的动力，即热情、愿景、意义。&lt;/p&gt;

&lt;p&gt;本质上说，意志精力是一股掌管所有维度行为的独特力量，它是动机最丰富的源泉，通向最深层的价值取向和超越个人利益的意图。&lt;/p&gt;

&lt;p&gt;意志精力能让我们活出人生的意义：我们究竟为了什么而活下去，为了什么而工作，知晓生命的意义，方能忍耐一切。一个人如果有自己的人生目标，他的勇气和信念，即使面对艰难困苦时，会展现出更加积极的一面，这就时意志精力饱满的体现。&lt;/p&gt;

&lt;p&gt;但是人们往往在悲剧发生后才会意识到意志精力的重要性。著名演员克里斯托佛1995年骑马时摔下来不幸瘫痪，绝望的情绪笼罩着他，甚至有过自杀的念头。但他找到了自己的意志精力的来源，想要继续陪伴家人、继续为这个世界贡献力量。这种强烈的意愿帮助他振作起来，在体能严重不足、极易产生脆弱绝望情绪的情况下，最终依靠希望、乐观恢复了专注和清晰的思维。&lt;/p&gt;

&lt;p&gt;实际上意志精力的更新来源于价值观和使命感的启发和带领。&lt;/p&gt;

&lt;p&gt;价值观和使命感也不是那么容易找到，其实我们过分关注了自身的利益，这导致我们的思维受到局限，使得我们往往被自身的生存和不安全感打败，陷入狭隘。&lt;/p&gt;

&lt;p&gt;人们往往认为自身需求迫在眉睫，注意力一旦转移，便会发生原始的生存恐惧。如果我把精力用在别人身上，谁来关照我？但具有讽刺意味的是，自私自利反而会削弱精力，妨碍表现。我们越是被自己的恐惧和担忧掌控，越难调动精力做出正确的举措。&lt;/p&gt;

&lt;h4 id=&quot;将个人利益置后起初会让人倍感不安但实际上这样做回报颇丰你通过帮助他人提升个人价值同时也丰富人生意义因此我们应该更多的想着怎么去帮助他人会更好不是盲目的帮要从本质上帮助他们在未来摆脱困境而不是暂时的摆脱在帮助他人的同时我们能学到和得到比个人利益更大的东西比如人生的意义社会的本质以及群体的利益&quot;&gt;将个人利益置后起初会让人倍感不安，但实际上这样做回报颇丰，你通过帮助他人提升个人价值，同时也丰富人生意义。因此我们应该更多的想着怎么去帮助他人会更好（不是盲目的帮，要从本质上帮助他们在未来摆脱困境，而不是暂时的摆脱），在帮助他人的同时，我们能学到和得到比个人利益更大的东西，比如人生的意义，社会的本质，以及群体的利益。&lt;/h4&gt;

&lt;h6 id=&quot;因此意志精力在深层的价值取向所带来的生活方式是生活的主心骨而且能帮助我们更好地应对各种挑战&quot;&gt;因此意志精力在深层的价值取向所带来的生活方式是生活的主心骨，而且能帮助我们更好地应对各种挑战。&lt;/h6&gt;
</description>
               <pubDate>Sun, 11 Oct 2020 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2020/10/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B011</link>
               <guid isPermaLink="true">http://www.luzexi.com/2020/10/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B011</guid>
            </item>
        
            <item>
               <title>思路探讨(五十二) 无题</title>
               <description>&lt;p&gt;很多时候我们应该付出行动去实践，去打破现有的笼子，而不是光靠脑子想，因为大部分时候脑子想出来的很实际情况是完全不一样的。&lt;/p&gt;

&lt;p&gt;积极的行动和开朗的笑容可以打破现实中的困局，是不可多得的良药，虽然这不是万能的，但我们不应该因为害怕失败而退缩，害怕爱而选择不爱，害怕比赛而不参加，害怕与人比较而避而远之。不要害怕，没什么东西是一定及肯定的，我们要努力去接受不确定性，去选择勇敢的面对失败。&lt;/p&gt;

&lt;p&gt;世界上也没有完美的东西，你可能有些知识但没有钱，你可能有点钱但没有好看的皮囊。接受这个世界的不完美，没有一个人是容易的，不要太在意，但我们可以持续的去努力。如果你太在意很可能扰乱了你的心智，会掉入更大的深渊，不要掉进那个坑。&lt;/p&gt;

&lt;p&gt;《做时间的朋友》里有一句话说到点子上了。“如果你行为上散发着快乐，心理上就不可能存放的了忧郁。有时候即使是装着的，装着装着，也就真的回到了快乐点线上。强迫自己回到快乐，在现实中是可行的。”这就是快速从悲伤中走出来的最好办法。&lt;/p&gt;

&lt;p&gt;失败不可怕，实际上它占据了我们生活的大部分时间，无论是谁都是一样的。我们更应该关注失败后的调整，不管是心态调整还是对这事上的策略的调整，谁能更快的调整过来，谁能更好的从失败中反思到真正的重点，那么谁就会能更快的走出失败的阴影。不过走出失败并不一定代表走向成功，也许只是试错的更快了，但这也让我们更加接近最终的成功，每个人都不一样，试错的长度和速度也不同。&lt;/p&gt;

&lt;p&gt;不要看到别人失败就幸灾乐祸，“专注于吸取教训，而不是幸灾乐祸”，这件事本身都不容易做到，是反人类的行为。人类毕竟是动物，很多时候都不太理智，我们应该时刻想着如何控制自己的脑袋做些更加有意义的事情。&lt;/p&gt;

&lt;p&gt;大部分上面所说的包括积极的行动、开朗的笑容、勇于面对、专注于吸取教训，对大脑来说都是相当困难的，它们都是逆大脑正常运作方向的，这使得它们会损耗大脑许多能量，因此很多时候我们做着做着就做不下去了。唯一的办法就是让它变成一种习惯，在大脑中建立起一个链路，由于习惯就是大脑中的一条链路，没有链路时做起来很生疏也很难受，只要链路建立起来，在执行时脑力就能畅通，这使得我们损耗的能量就会减少许多，就不会那么痛苦了。这根链路就是习惯性积极行动、习惯性乐观开朗、习惯性面对困难、习惯性吸取教训。&lt;/p&gt;

&lt;p&gt;实际上轻松的学习是无效的，就像人家说什么你就信什么那样，完全是错误的，只有经过自己的仔细思考和分析，才能将知识真正的消耗到自己脑袋里。&lt;/p&gt;

&lt;p&gt;《做时间的朋友》说，与其关注成功者，不如反其道而行之，努力从失败者身上汲取经验。不要说模仿成功者，就算观察成功者也很困难，成功者很多，但是，我们身边真正的成功者却很少。成功背后的东西很难看清楚，所谓成功的真实性也很难判断，成功者们又会有意无意地美化和包装他们的经验，而这一切都在干扰我们的判断。不过，观察失败者却相对容易得多，因为失败者的失败往往是明显的、确定的、失败的真正原因也往往很容易查实。并且我们身边失败者的数量显然要多于成功者的数量。如此，我们也就有了更多的观察机会。&lt;/p&gt;

&lt;p&gt;很多时候，不仅归纳经验需要很长时间，通过演绎论证归纳出来的经验可能需要更长的时间，所以一定要保持足够的耐心。要知道有些阶段是无法跨越，很多人不懂等待的必要性，最终的结局是，同样等了，因为心急如焚但不得不等，最终等来的结果却是另外一个，反正不是通过耐心等待应该获得的那个。&lt;/p&gt;

</description>
               <pubDate>Sun, 20 Sep 2020 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2020/09/20/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A852</link>
               <guid isPermaLink="true">http://www.luzexi.com/2020/09/20/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A852</guid>
            </item>
        
    </channel>
</rss>