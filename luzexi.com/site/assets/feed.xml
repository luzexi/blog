<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title></title>
        <description>技术，哲学，金融</description>
        <link>http://www.luzexi.com</link>
        <atom:link href="http://www.luzexi.com/assets/feed.xml" rel="self" type="application/rss+xml" />
        
            <item>
               <title>励志英文(二) Today is yours</title>
               <description>&lt;iframe frameborder=&quot;0&quot; src=&quot;https://v.qq.com/txp/iframe/player.html?vid=t0503w4dby9&quot; allowFullScreen=&quot;true&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h6&gt;这是一篇激励自己的文章，情景是当前运动比赛、考试、测试、考验前的心理准备，长久以来的辛苦要在今天得到结果了，赛前的心理暗示对自我充满信心的鼓舞。&lt;/h6&gt;

&lt;p&gt;文中说，我们已经做好了准备迎接这一刻 “All the training, the hours of preparation, the pain you felt, they have brought you to this moment, they are the armor that you wear.” 所有的训练，所有的准备，所有的忍耐过来的痛苦把我们带到了现在这个时刻，我们已经穿上装甲做好最后的准备。&lt;/p&gt;

&lt;p&gt;然后说，质变即将到来 “It&amp;#39;s about taking all those hours and turning them into the best version of yourself. Today is about being better than you ever dreamed you could be.” 所有训练和花费的精力都将我们变为更好的自己，我们梦想中能达到的更好的自己将要到来。&lt;/p&gt;

&lt;p&gt;接着说，抛开怀疑的态度坚定自己， “Let people doubt you they&amp;#39;ll see with time. Let the obstacle stand, you will run right through them. Let everything in this universe tell you no, you have already told yourself yes.” 让怀疑我们的人们看看我们的实力，让障碍停止在那里，我们会垮过去。当整个世界都对你说不行的时候，我们已经知道自己是可以的。&lt;/p&gt;

&lt;p&gt;然后说，努力提升自己，&amp;quot;you were the god of your world, And in your world you write the script. There is no tired, you left that in the wait room years ago. There is no one sure, push yourself to exhaustion every day took care of that, There is only when, when do you rise up.&amp;quot; 我们是自己世界里的神，可以编写自己的剧本。前几年我们在等候室里不知疲倦。没人会知道我们每天精疲力尽会如何，只有当我们抬升自己时才会感觉到。&lt;/p&gt;

&lt;p&gt;最后说，我们总有一天会向世界证明自己，“It will not disappear with time, it will live on, you have earned today. Go make sure the world knows.” 所有的努力都不会消失，它会存留在那里，我们已经赢得了今天，让世界知道我的努力。&lt;/p&gt;

&lt;h3&gt;以下就是全文：&lt;/h3&gt;

&lt;p&gt;The thing about time is that comes and goes. Tomorrow will make today a distant memory And as quick as you were here, you&amp;#39;ll be gone. What&amp;#39;s in front of you is an opportunity to make right now something you&amp;#39;ll never forget. You have the ability to write history to create a story that will live with you forever.&lt;/p&gt;

&lt;p&gt;Think back to all the days leading up to today. All the training, the hours of preparation, the pain you felt, they have brought you to this moment, they are the armor that you wear.&lt;/p&gt;

&lt;p&gt;Right now is about execution. It&amp;#39;s about taking all those hours and turning them into the best version of yourself. Today is about being better than you ever dreamed you could be. These are the moments you live for.&lt;/p&gt;

&lt;p&gt;Gone are the insecurities the doubt the disbelief, this day is yours. Look your opponents in the eye, they cannot give what you can, you have built this opportunity piece by piece, you have created an unstoppable force and it&amp;#39;s finally time to reveal that to the world.&lt;/p&gt;

&lt;p&gt;Let people doubt you they&amp;#39;ll see with time. Let the obstacle stand, you will run right through them. Let everything in this universe tell you no, you have already told yourself yes.&lt;/p&gt;

&lt;p&gt;The hardest thing in this world to stop is someone who knows they&amp;#39;ve won before the game is started. This is your everything, embracing. Make it, so that you never forget today.&lt;/p&gt;

&lt;p&gt;you were the god of your world, And in your world you write the script. There is no tired, you left that in the wait room years ago. There is no one sure, push yourself to exhaustion every day took care of that, There is only when, when do you rise up.&lt;/p&gt;

&lt;p&gt;There some a point when you just given too much, you sacrifice is too great, to accept anything but the very best, everything else is noise. This is your day.&lt;/p&gt;

&lt;p&gt;It will not disappear with time, it will live on, you have earned today. Go make sure the world knows.&lt;/p&gt;
</description>
               <pubDate>Sun, 12 Jan 2020 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2020/01/12/%E5%8A%B1%E5%BF%97%E8%8B%B1%E6%96%872.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2020/01/12/%E5%8A%B1%E5%BF%97%E8%8B%B1%E6%96%872.html</guid>
            </item>
        
            <item>
               <title>思路探讨(三十二) 2019年我做了哪些金融投资与经济系统的学习和思考</title>
               <description>&lt;p&gt;2019年我做了哪些金融投资与经济系统的学习和思考。&lt;/p&gt;

&lt;p&gt;2019年是继2018后经济回暖的一年，2018年的萧条景象还记忆忧心，在2020年1月这个点我们来回顾和总结下2019年我对金融体系的思考。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/life/idea-talking32-1.png&quot; alt=&quot;且慢投资组合&quot;&gt;&lt;/p&gt;

&lt;p&gt;(图为我在且慢上的投资方案)&lt;/p&gt;

&lt;p&gt;2019年我在金融投资上只有买股票这个操作，从股债房，三个投资方向来看，房价确确实实已经到了一个瓶颈，房价的上升本来就需要国民钱包的支撑，如果国民钱包没有鼓起来，再上升就是不理性的，也更容易出现崩盘的机会，值得庆幸的是国家控制住了房价，以‘房住不炒’的理念来抑制房价过大的起与伏，为中国未来的发展又一次扫平了障碍。&lt;/p&gt;

&lt;p&gt;为什么说扫平障碍呢？基建是国家的命脉，是国家兴旺发展的基础，但房市太活跃升值太快，导致大量资金流入房地产而不是基建，就会伤害实体经济，因为钱是有限的，往房地产市场流入的多，那么在实体经济里的钱就会变少(如果股市太旺也是同样的道理，钱都用来投机倒把)，渐渐的房地产就会成为国家经济支柱，炒房成了国民赚钱手段，这不是道德问题，而是未来发展的问题，钱都去搞房地产的话实体经济就没钱创新和发展，因为没钱在实体经济导致实体经济的发展和创新受到了阻碍。&lt;/p&gt;

&lt;h6&gt;房地产毕竟是靠涨价来吸引投资市场的，而且涨价是有限的，价格不符合国民钱包就会很危险，价格除了涨还有跌，跌下来时伤害的不只是老百姓的钱包，还有国家的经济和对国家经济的信心，所以国家对此处理的很谨慎，也处理的很对，智囊团很厉害。所以总的来说现在房价已经涨到了国民的钱包无法支撑的阶段了，价格的瓶颈也在此停住了，但国家经济仍然支撑的房地产，因此没有恐慌，也没有必要恐慌，只是恢复了平静而已，我们继续各自工作和等待，暂时来说房地产的机会还需要等待。&lt;/h6&gt;

&lt;p&gt;对股市来说2019年是值得欢喜的一年，很多人在2018年所遭受的损失在2019年这一年里弥补了回来，甚至有人还有盈余。股市是国家经济的晴雨表，总体上反应了国家的情况，所以其实可以根据今年的股市来判断我国经济回暖的情况是比较好的。&lt;/p&gt;

&lt;p&gt;2019年里我买了些股票也卖了些股票，对于平民百姓来说想靠股市赚钱就得学习很多知识，分析很多问题，亲身去接触企业，感受企业经营状况。&lt;/p&gt;

&lt;h6&gt;今年我终于明白了，为什么要亲自去感受企业的产品，最好能亲自去他们厂里、店里去感受他们的经营状况。我也开始抛售了一些我不了解的企业的股票，和一些我自己亲自使用过并且体验很差的产品的企业，买入了更多我使用过他们家产品，并且有很好体验的企业。&lt;/h6&gt;

&lt;p&gt;今年我更多的感受到了股票市场的情绪化，更深刻的记住了短期的情绪是导致的价格波动主要原因，于是我开始去情绪化，更加冷静和沉着的看待股票投资。比如，我不再被涨价所心动，也不再被下跌所恐慌，而更多的关注横盘平稳阶段的投资点。&lt;/p&gt;

&lt;h6&gt;我也开始明白，对一个企业来说，财报的局限性，财报是给老板看的，是给大众看的，是给懂事和股东看的，是给领导看的，要好看，否则要你这个财务总监干什么，做账当然是要漂亮一点，所以财报是人为的’漂亮报告‘。但也有实在兜不住的时候，那就破罐子破摔把前两年的问题都暴露出来，一次性把最坏的情况兜底也是常有的事。所以’财报‘不可全信，只能看个大概，30%的内容还是有用的，比如固定负债，流动负债，以及负债率，还有现金流和固定资产，其余的只能相信30-50%。&lt;/h6&gt;

&lt;p&gt;我也开始意识到股东结构的重要性，以及股东作用的局限性。这个机构，这个自然人，为什么要投这个公司，而且还投的这么多，进了前10的股东名单，他们肯定分析过，慎重考虑过，否则不会花这么多钱去玩这场没有把握的游戏，他们是否考虑了5-10甚至20年的投资回报，因此在这个点买入。但即使买入，股东的局限性也很多，因为在市场面前他们无法力挽狂澜，即使红杉集团或腾讯或阿里进入了10大股东列表那又怎么样，只能说他们分析后有几成的把握5年左右有大回报的可能，但毕竟他们的投资有撒网式的嫌疑，把投资额度分成了20-100份，我们看到的只是其中一份而已，对他们而言这一份没有起色还有其他的，因此他们并不是孤注一掷。另外他们看准的是投资回报，还是股票长期分红，或者领域上的战略投资，也是与我们的投资目标有相当大的不一样的。我们老百姓更多期望的是当下的收益，而他们则有多种情况的考虑，并不一定全为了收益，还有战略。&lt;/p&gt;

&lt;h6&gt;我也开始意识到，对股票的理解应该换个角度看问题，比如从宏观角度看股市，股市毕竟是跟随着国家的经济发展而不断前进的，如果国家经济衰落或不稳定，那么股市就会下行或动荡，因此我们都在赌国家兴旺发达，如果国家遭遇灾难或困难，我们就大概率是赌输的。&lt;/h6&gt;

&lt;p&gt;这些都是我们只投资自己国家的视角下的，因为身在祖国，投资祖国是必然的。我们无法决定国家的命运，那么有没可能去别的国家投资股票，现在有老虎证券可以投资美股、港股，不过外汇有额度每年35w左右额度，对于平民百姓也够用了。如果在国内投资国外可以通过基金，或使用ETF来投资纳斯达克指数，标普指数，港股指数，以及德国30的指数。说实话国家并没有封死平民百姓日常的对外投资，只是封锁了富豪的资产外流和转移。&lt;/p&gt;

&lt;h6&gt;从国际经济条件来讲，第一霸主的美国和我国确实有很大的差距，从当下看投资美股确实是稳当的，但这个差距也一直在缩小。但天下哪有稳当的生意，稳当安逸永远都是最危险的处境。难道美国就一直会霸主下去吗，中国就不可能取代它或与它一起成为霸主吗？谁都不知道，所以假如我们投资了美股，则要担心美国是否会犯错，也要担心中国的崛起是否会影响到美国的发展。从这个角度看我们去投资美国，会有诸多问题。&lt;/h6&gt;

&lt;p&gt;况且我们不在美国，不是生活在美国，并不了解美国，就像我前面说的，我们不了解一个企业，却买了它的股票一样，心中的疑惑和担心会与日俱增。我觉得是得不偿失的，我们毕竟是人，首先是要寻求自己内心的平静，如果心是平静的，做事就会更加坚定，投资也是这样，越是了解的越能平静对待，越是陌生的越是猜疑担心。所以我决定主战场还是国内，除非中国腐败到有一天我对国内彻底绝望。&lt;/p&gt;

&lt;h6&gt;我们再换个角度看股市，从涨跌的方向看股市。我们说过股票的涨跌，短期看情绪，中期看业绩，长期看国家经济。那么我们能不能用情绪的涨跌来赚钱呢？答案是能却非常很难，首先因为机会很少，一年可能就出现1次，甚至可能一次都没有，其次很难感受到情绪的反转点，需要老练的经验和冷静的头脑分析，最后选股还要谨慎。对于想躺着赚钱的人来说，根本是不可能的，这种操作需要大量的时间学习和经验积累，专业程度比较高。我的体会是两个点的位置可以尝试，一个是恐慌情绪结束时，一个是回暖情绪起来时，其他时候都不合适，涨跌互现会让我们心力交瘁，得不偿失。&lt;/h6&gt;

&lt;p&gt;再换个角度看问题，其实投资过程中，不只是标的的问题，我们自身也存在诸多的变化，例如，工作上的，生活上的开支使得现金流紧张时，我们自然需要从稳定的角度看现有的整体资金投资比例，可能需要缩小一部分投资金额用于生活。生活中各种层出不穷的情况千变万化，并不是我们想象的有余钱就投这么简单，我们需要平衡生活与投资，需要预留备用金以备正常生活和以便不时之需，因此投资并不是简简单单的买入卖出，它需要根据我们当前生活的状态动态平衡，只有找到平衡，生活才能如意的走下去，如果我们连生活都无法顺畅的走下去，投资带来的情绪会让我们走入地狱。不过，没有什么困难是过不去的，只是大部分人都难过情绪这关，柳暗花明又一村的事常有，我们量力而为。&lt;/p&gt;

&lt;h6&gt;最后我们再来换个角度看问题，分析和执行保持一致的难度。假设说，现在我们确认并且肯定某个买入的机会，无论是股票还是房产，我们是否能做到坚定的去执行，是否应该全力去执行。我想这个问题肯定每个人都不一样，执行前首先我们要清楚没有什么是机会百分百肯定的，如果你想清楚了后果那么无论是否执行都应该坚定得去做。&lt;/h6&gt;

&lt;h6&gt;每个人的理念都不同，我的理念只是其中一个，在我的理念里，我们应该首先保证当前生活能够继续下去的前提下来投资，确保即使彻底失败也不至于无法生活，投资和生活和工作一样是个循序渐进的过程，长期的痛苦才是真痛苦，我们需要用毅力慢慢磨平长时间的痛苦，让快乐回归正途，就像我提倡的在工作上的积累那样，不要幻想短期的就能收到巨大的回报。有很多人就不这么认为，没有对错，有人就会不惜一切代价去赌一把，我们称他们为‘亡命之徒’，就像梭哈那样ALL In一把结束一切痛苦，他们这所谓的痛苦都太短暂根本无法磨练人的意志，只是一味的图个简单方便，痛苦是短了结局不怎么样，当然也有成功的时候，就会一夜暴富传为佳话，但这种毕竟是少数，大部分都是要么抗不过去还没看到黎明就败下阵来，要么就是彻底失败走上邪路从此坑蒙拐骗，要么自毁前程断送性命。&lt;/h6&gt;

&lt;p&gt;我们来看债券市场中2019年并不是很好，继2018后2019的雷暴虽然相对减少了但依然有不少。我们现在应该只关注国债和国家的逆回购比较安全，可以存余额宝等货币基金以度过冬天等待春天。&lt;/p&gt;

&lt;p&gt;投资之道当然没有这么简单，如果能简单到只要随便学习一下就能掌控，那就不是人类社会的。他需要深度学习，不仅如此还需要耐心等待机会，并且在机会到来时小心谨慎的执行。其实没有那么精彩、风光，只是回头看再编一编夸大一下就成了神话。&lt;/p&gt;

&lt;h6&gt;今年我也发现了一个我一直忽视的事，其实我们所有人无论哪个阶层的人，都一直在找能’永远‘躺着赚钱的投资标的(即使只是看起来是‘永远‘)，但能永远躺着赚钱的投资标的，大部分要么很贵、性价比不高，要么是个坑。其实没有完美的投资标的，都是有这样那样的缺陷，我们还是不要盯着缺陷，而是要看是否合适我们自己，我们关注的是什么，是长期分红，是租金，还是当下的涨幅，是短期还是长期，是保值还是想升值，每个人的心态、状态和理念都不一样，找到合适我们的，并且找对标的的长处，是我们的重中之重。&lt;/h6&gt;
</description>
               <pubDate>Fri, 10 Jan 2020 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2020/01/10/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A832.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2020/01/10/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A832.html</guid>
            </item>
        
            <item>
               <title>思路探讨(三十六) 英语励志文章1</title>
               <description>&lt;p&gt;半年前我把这篇文章打印了下来，每天读一遍读了很多遍，每次读都有不同的体会，文字是视频中的对话。很多时候当我们还没到那个高度的时候，催眠自己也不妨是一种途径。&lt;/p&gt;

&lt;iframe frameborder=&quot;0&quot; src=&quot;https://v.qq.com/txp/iframe/player.html?vid=n0147njlz3k&quot; allowFullScreen=&quot;true&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;I dont know what that dream is that you have, I dont care how disappointing it might have been, as you&amp;#39;ve been working towards that dream. But that dream that you&amp;#39;re holding in your mind, that it&amp;#39;s possible.&lt;/p&gt;

&lt;p&gt;That some of you already know that it&amp;#39;s hard. It&amp;#39;s not easy. It&amp;#39;s hard changing your life.&lt;/p&gt;

&lt;p&gt;That in the process of working on your dreams, you are going to incur, incur a lot of disappointment, a lot of failure, a lot of pain , there are moments when you’re going to doubt yourself, you will say “ God why? why is this happening to me? I’m just trying to take care of my children and my mother I’m not trying to steal or rob from anybody. How did this have to happen to me?”&lt;/p&gt;

&lt;p&gt;For those of you who have experienced some hardships, don’t give up on your dream.&lt;/p&gt;

&lt;p&gt;There are rough times that gonna come but they have not come to stay, they have come to pass.&lt;/p&gt;

&lt;p&gt;Greatness is not this wonderful esoteric, elusive, god-like feature that, only the special among us will ever taste, you know, it’s something that truly exists in all of us.&lt;/p&gt;

&lt;p&gt;It’s very important for you to believe, that you are the one!&lt;/p&gt;

&lt;p&gt;Most people, they raise a family, they earn a living and then they die.&lt;/p&gt;

&lt;p&gt;They stop growing, they stop working on themselves. They stop stretching. They stop pushing themselves.&lt;/p&gt;

&lt;p&gt;Then a lot of people like to complain, but they don’t wanna do anything about their situation, and most people don’t work on their dreams. why?&lt;/p&gt;

&lt;p&gt;One is because of fear, the fear of failure, “what if things don’t work out?” And the fear of success, “what if they do and I can’t handle it?”. These are not risk-takers.&lt;/p&gt;

&lt;p&gt;You spend so much time with other people, you spend so much time trying to get people to like you, you know other people more than you know yourself, you&amp;#39;ve studied them, you know about them, you wanna hang out like them, you wanna be JUST LIKE THEM!&lt;/p&gt;

&lt;p&gt;And you know what? You’ve invested so much time in them, you don’t even know who you are, I&amp;#39;m telling you to spend time by yourself.&lt;/p&gt;

&lt;p&gt;It’s necessary that you get the losers out of your life, if you want to live your dream.&lt;/p&gt;

&lt;p&gt;But for people who are running towards their dreams, life has a special kind of meaning.&lt;/p&gt;

&lt;p&gt;When you become the &amp;quot;right person&amp;quot;, what you do is you start separating yourself from other people, you begin to have a certain uniqueness.&lt;/p&gt;

&lt;p&gt;As long as you follow other people, as long as you’re being a copy-cat, you will never ever be the best copy-cat in the world. But you will be the best that you could be. I&amp;#39;m telling you to find your value.&lt;/p&gt;

&lt;p&gt;That everybody won’t see it, that everybody won’t join you, that everybody won’t have the vision, it’s necessary to know that. That you are an uncommon breed!&lt;/p&gt;

&lt;p&gt;It’s necessary that you align yourself with people and attract people into your business, people who are hungry.&lt;/p&gt;

&lt;p&gt;People who are unstoppable and unreasonable, people who are refusing to live life just as it is and who want more.&lt;/p&gt;

&lt;p&gt;The people that are living their dream are fighting winners. They attach themselves to. The people who are living their dreams are the people that know that if it’s gonna happen, it’s up to them.&lt;/p&gt;

&lt;p&gt;If you wanna be more successful, if you wanna do and have stuff you&amp;#39;ve never done before, No.2, I’m asking you to invest in you.&lt;/p&gt;

&lt;p&gt;Someone’s opinion of you does not have to become your reality, that you don’t have to go through life being a victim. And even though you face disappointments, you have to know within yourself that I can do this, even if no one else sees it in me, I must see it for myself.&lt;/p&gt;

&lt;p&gt;This is what I believe and I&amp;#39;m willing to die for it, period.&lt;/p&gt;

&lt;p&gt;No matter how bad it is or how bad it gets, I&amp;#39;m going to make it!&lt;/p&gt;

&lt;p&gt;I wanna represent an idea. I wanna represent possibilities.&lt;/p&gt;

&lt;p&gt;Some of you right now, you wanna be, you wanna say, you wanna go to next level, &amp;quot;I want a council, you know, I wanna be an engineer, I wanna be a doctor.&amp;quot; Listen to me: You can&amp;#39;t get to that level, you can&amp;#39;t get to the level economically where you wanna be, until you start investing in your mind. You are not reading books, I challenge you all to go to the conference. I dare you to invest time, I dare you to be alone, I dare you to spent and hour to get to know yourself. When you become who you are, when you become the person that you are created to be, designed to be, who you were designed to be. When you become an individual, what you do is you take yourself and you start separating yourself from other people. I&amp;#39;m telling you, to get to a place where people do not like you or do not even bother you any more. Why? Cause you are not concerned with trying to make them happy, because you are trying to blow, you are trying to get to the next level. I need you to invest in your mind.&lt;/p&gt;

&lt;p&gt;If you’re still talking about your dream, if you’re still talking about your goal, but you have not done anything, just take the first step. That you can make your parents proud, you can make your school proud, you can touch millions of people‘s lives, and the world will never be the same again, because you came this way.&lt;/p&gt;

&lt;p&gt;Don’t let nobody steal your dreams! After we face a rejection or a &amp;#39;NO&amp;#39; or we have a meeting and no one shows up. or somebody said ” you can count on me ” and they don’t come through.&lt;/p&gt;

&lt;p&gt;What if we have that kind of attitude, that cause reposes, nobody believes in you. You’ve lost again, and again, and again! The lights are cut off, but you’re still looking at your dream, renewing it every day and saying to yourself: IT&amp;#39;S NOT OVER, UNTIL I WIN!&lt;/p&gt;

&lt;p&gt;YOU CAN LIVE YOUR DREAM!&lt;/p&gt;
</description>
               <pubDate>Wed, 08 Jan 2020 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2020/01/08/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A836.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2020/01/08/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A836.html</guid>
            </item>
        
            <item>
               <title>思路探讨(三十五) 合作带来自信</title>
               <description>&lt;p&gt;我们常常会做出强迫别人执行自己的指令，古时有指腹为婚的习惯，今有强制学习、强制加班等。我们的控制欲太强，常常会导致别人有被捆绑被束缚的感觉，这种感觉导致降低了合作的发生几率。我们需要寻求合作，不管是工作上的合作，还是男女朋友或夫妻家庭生活上的合作，亦或我们与孩子之间的合作上，都增进了效率，增加了感情，最终间接提高了生活和工作的效率。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;《自卑与超越》一直围绕着讲的，也是“合作”这个关键词。合作对我们非常重要，但由于我们不好的习惯和思维方式的沉淀，常常不由自主的去破坏合作。&lt;/p&gt;

&lt;h6&gt;婚姻也本该是合作为基础的，合作是婚姻的首要条件。夫妻本身彼此应该像是很要好的朋友，和外界也应该保持良好的亲密的友谊关系。只有这样，他们的孩子才会觉得在他们的家庭之外也有值得信赖的人。&lt;/h6&gt;

&lt;h6&gt;如果每对夫妻对于其伴侣的兴趣都高于对自己的兴趣，那么他们之间便会有真正的平等。如果他们都很诚心地奉献出自己，他们便不会觉得自己低声下气或者受家庭拖累。只有男女双方都有这种态度，平等才有出现的可能。他们两人都应该努力使得对方的生活平稳和富裕，这样他们才会有安全感。他们会觉得自己是有价值的，并且觉得自己是被需要的。&lt;/h6&gt;

&lt;h6&gt;没有人能够心平气和地忍受卑下的地位。伴侣们或者共事的人们必须是平等的，人们只有在平等的时候才能找出克服共同困难的方法，也只有人与人之间感到平等时合作才能激发出最惊人的力量。&lt;/h6&gt;

&lt;h6&gt;如果我们能成为身边的人的好朋友，并有美满的婚姻和有价值的工作，我们就不会觉得自己不如别人，或者被人别所击败。我们会觉得这个世界是个友善的世界，在哪里我们都能坦然处之，我们会遇到很多喜欢我们的人也会遇到很多我们喜欢的人，应付困难时也能得心应手。因为合作，与人合作带给你愉快，与所有人合作愉快带给你实实在在的自信。&lt;/h6&gt;

&lt;p&gt;在我们现代的文化里，人们经常都没有做好合作的准备。我们的教育都太注重个人的成功，都太强调要考虑我们能够从生活中获得什么，而不是我们能付出什么。我们一直都是遵照着我们生活样式做出种种应急的反应，这些反应大都是只考虑自身的利益，因此我们非常不习惯于考虑另一个人的利益、他的目标、他的欲望、他的野心和他的希望。这也是我们因为缺少合作能力而造成的，无法换位思考，导致无法体会到对方的处境和情绪。&lt;/p&gt;

&lt;h6&gt;如果一个人真正对另一个人感兴趣，他会成为对方真诚的友伴，他会勇于负责，他还会使得自己忠实可靠。最坏的情况是一个人只顾及自己的利益，他终日都在盘算着，“我能从中得到什么？”，他会一直要求自由和解脱，从不考虑要怎样才能使对方生活的更轻松或更富裕。虽然如此，但这种情况也不是种罪恶，而只是一种错误的方法。就像所有老谋深算、千方百计想从婚姻中得到什么或者逃脱什么的人一样，最终都走上了错误的道路。&lt;/h6&gt;

&lt;p&gt;这个世界确实并非能够这么理想，也真的有很多邪恶、困难、偏见和悲哀，但这就是我们的世界，它的优点和缺点也是我们自身的优点和缺点。对于我们个人生活而言，在面对周围人和事环境时，无论是顺境还是困境，都必须要以合作的方式来加以改进，这是最有效的方法和途径。&lt;/p&gt;

&lt;p&gt;最后引用一段阿尔佛雷德.阿德勒的话来结束最近几篇对《自卑与超越》的探讨：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    每个人都有不同程度的自卑感，因为没有一个人对其当前的地位感到满意，对优越感的追求是所有人的通性。然而，并不是人人都能超越自卑，关键在于正确对待职业、社会和性，在于正确理解生活。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考文献:&lt;/p&gt;

&lt;p&gt;《自卑与超越》 阿尔佛雷德.阿德勒&lt;/p&gt;
</description>
               <pubDate>Sun, 05 Jan 2020 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2020/01/05/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A835.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2020/01/05/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A835.html</guid>
            </item>
        
            <item>
               <title>思路探讨(三十四) 纠正错误观念</title>
               <description>&lt;p&gt;平时会用‘印象笔记’来记录自己在脑中一闪而过的想法，这些想法很细碎，很难形成连贯的大篇幅的文章，于是我把它们都命名为‘随记’1、2、3、4...到现在已经记录到了60多个随记片段，部分已经写入到文章中已经被删除，留下了45个片段还没有被连接进入大篇幅的文章中。&lt;/p&gt;

&lt;p&gt;在平时写文章的过程中会用到一些片段，但很多片段都没有成形的理论体系，连自己都想不明白也就无法拿出来与大家分享。其中有一些理论在当时看来觉得很对，现在回过头去看却是错误的观念。今天就把一部分记录在‘随记’里的错误观念，拿出来复盘一下，当时自己是怎么想的，为什么错。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h3&gt;记在‘随记3‘中的:&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    大多数成功是可以根据现有的经验推出来的。
    虽然不能说一定成功，不过，一旦有了先前成功经验，就能在大概率上，或者说关键点加强成功概率。

    这样说有点泛泛而谈，有些成功经验确实是没有意义的，比如躺赢，突然被风口吹上天，突然政策转变你刚好被砸中等，一些完全没有自己全程经历过的事情，没有辛苦琢磨过的，都有可能是伪成功经验，这种经验是大坑。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段想法错从本质上就错误的理解了’成功‘。’成功‘就是赚到钱吗？不是的。但当时记录我就是这么认为的，话中透露出我对赚到钱的渴望，这种渴望会诱导我走向错误的道路，比如只关注短期结果，对长期的计划和展望关注度减少，形象到生活中比如只关注与钱有关的事物，而对人与人之间的合作比如情绪、交流、人情交际上关注度减少，最终将导致原本想找捷径更快走向目标’赚钱‘，反而绕了更大的弯路甚至走向了完全相反的方向’费钱‘。&lt;/p&gt;

&lt;h6&gt;其实只对钱感兴趣的必定会和合作之道背道而驰，在这个我们光怪陆离的时代，致富之道何止万千，即使是旁门左道，有时候也会为人带来巨富。对此我们不必感到惊讶，虽然我们绝不敢说做人正直、有所不为的人一定能够成功，但是我们却敢断言，守正道、明事理必能使其勇气保持不坠，并且不失尊严与自信。&lt;/h6&gt;

&lt;h3&gt;记在’随记2‘中的:&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    能力太大就会很容易越过界，造成严重失误。

    枯燥，乏味，充斥着大部分生活，如果没有目标，很快就会陷入困惑，从而降低学习和工作效率。

    游戏太浪费时间和精力，能否找到有效的放松方式很关键，健康的放松方式和方式习惯让人非常受益，每个人每个阶段都不一样。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;言语和文字中看出本质，这段想法的本质是对’个人能力‘的错误理解。我当时太关注’个人能力‘。’个人能力‘能解决所有问题吗？不能。但当时的记录来看我就是这么认为的，认为个人能力可以解决所有问题，至少认为是可以解决所有核心问题。对个人能力的错误理解，其实就是对’人与人合作‘的错误理解，人类是合作的社会，没有合作就没有人类发展，工作、生活也是同样的道理因为它反映了人类生活的结构规则。人类社会得益于分工制度，它为人类生产生活提供巨大效益。如果每个人都是什么都要完全自己来，没有人合作，没有人站在前人的肩膀上工作、学习，那么整个社会就是停留在原始的动物阶段，没有工具、知识、文化的积累，一生下来就是重新开始，只靠着基因进化适应环境，跟动物没有分别。&lt;/p&gt;

&lt;h6&gt;对于合作产生的效益来说，个人能力实在微不足道。工作、生活中亦是如此，我们应该放弃个人能力改变世界的愚蠢想法，转而致力于促进更多的合作，改进合作向更好的合作走去，当每个个人奉献出自己的力量的时，让 1人 加 1人 或者 10人 + 10人 或者更多组合 10人 + 12人 + 18人 + ... = 等于原来结果数倍还多的能量。&lt;/h6&gt;

&lt;h3&gt;记在’随记7‘中的:&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    我们要理解蠢货的存在，不要去计较蠢货的思维逻辑。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;没有人是蠢货，存在即合理。我们心中的世界本质上是围绕我们自己为中心的世界，本来就是一个扭曲的世界，用扭曲的世界看真实的世界，怎么看怎么不合理。归根结底还是我们自己太狭隘，太固执，没有放平心态，敞开怀抱拥抱世界，这种不寻求合作反而倒退去固步自封的想法，是错上加错。&lt;/p&gt;

&lt;h3&gt;记在’随记7‘中的:&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    我的智慧足以教育女儿登顶同龄人成为人生赢家，但我的财力不足以支撑我这么做。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我把教育想的太简单，也高估了自己，这是在我还没有深入接触幼儿教育之前的想法，那时完全由我妻子来负责，而我只负责空想。当我深入接触和了解时则与我想象的完全不同，一下子感觉到了自己的渺小，对方的伟大。《自卑与超越》中写下了大量人类儿童时期的心理过程让我深受启发。一些浅见是，我们应该更多的思考，如何让孩子对周围的环境和人发生足够的兴趣，以使得他们在日常活动中形成更多的合作，我们也应该致力于让孩子尽早了解社会分工制度，尽早确立自己感兴趣的职业方向。&lt;/p&gt;

&lt;h6&gt;其实还有许多愚蠢的想法，愚蠢到自己都羞涩难忍，就放在后面的文章中再一一显露出来好了。写’思维探讨‘的目的就是进阶思维方式和思维角度，靠什么进阶呢，光靠自己空想没用，要多看书而且是精读，再和周围的朋友们多聊聊各自的想法，从中碰撞出思维的火花。&lt;/h6&gt;
</description>
               <pubDate>Thu, 02 Jan 2020 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2020/01/02/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A834.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2020/01/02/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A834.html</guid>
            </item>
        
            <item>
               <title>思路探讨(三十三) 2019年我做了什么</title>
               <description>&lt;p&gt;最近忙了好多事情，原以为休息在家可以轻松点，但依然忙的不可开交，我没常回家的1年多时间里有这么多事情堆积着。原本想着把《算法导论》再看一遍后把关于‘算法’的文章写完，可惜算法这块知识量和知识深度有点大，还需待点时日。&lt;/p&gt;

&lt;p&gt;2019年我做了什么呢？虚的我觉得讲出来可能大家都有不同的意见（什么人生哲学，生活大道理，思维方式，智慧之举等等），我们就讲讲实实在在能看到的，我把这些实实在在能看到的学习生活记录了下来，尽量记录的详尽，虽然有部分遗漏但大部分都被记录了下来。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;一整年我都在使用一个叫‘滴答’的任务app，我在里面设置了每天要做的事情，每天做完把它勾掉，做不完也没事，留到下一天来做。不想给自己太多的压力，也为了放过自己，既然做不完，那就让它过去，第二天里的任务继续有，只要我今天做了一个任务我就把它勾掉。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/life/idea-talking33-3-2.png&quot; alt=&quot;滴答详情&quot;&gt;&lt;/p&gt;

&lt;p&gt;于是就有了上面这张图。其实不止这些，还加入了简简单单就能完成的任务，比如每天白天累了趴下休息10分钟，每天早中晚三餐规律饮食，每天不看娱乐新闻，每天下午3点吃点东西补充能量，每天12点前睡等等等，有28条每日任务。&lt;/p&gt;

&lt;p&gt;我做了这么多年游戏已经彻底清楚的明白对于一个平民玩家，每日任务就是其最宝贵的追上土豪玩家的途径，土豪玩家有钱没毅力快速提升靠钱砸，平民玩家没钱只能靠毅力靠肝靠做任务坚持几个月，最终还是能追上一部分土豪玩家的，毕竟他们整体上来说总是在不断放弃与重新开始中，平民玩家也就只有肝，那么肝之中，每日任务最为精华，其他途径都是效率相对比较低的。结合到实际生活中也是同样的道理，我们可以把人生看成一次游戏，要么你出生就有钱有地位，要么就只有肝这条路。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/life/idea-talking33-3.png&quot; alt=&quot;滴答等级&quot;&gt;&lt;/p&gt;

&lt;p&gt;我每天都会点掉很多任务，也留下了很多任务。每点掉一个任务就会增加一些经验，就像游戏人生一样，我每天做一些任务学一些东西就会增加一些人生阅历和知识经验。这个软件也是一样，于是我就有了如上图所示的经验等级。其实它的满级只有10级，但是在里面用的人真的很厉害，我花了很大的力气，坚持了这么久，还有百分之5的人没有被我击败，可想而知他们该有多努力。&lt;/p&gt;

&lt;p&gt;这是在我去年9月份时看了一本《做时间的朋友》后开始做的事情，当初的想法是把时间利用起来，跟时间一起‘玩’，这样就能让自己每天的生活很充实，也很高效。虽然事情一开始比较顺利，但随着日子一天天过，枯燥和疲惫的冲击，做这些事变得越来越困难，甚至一度停止过。&lt;/p&gt;

&lt;p&gt;这其实跟人生在岔道口的挑战一样，当挑战来临时，有明显的征兆，比如当挑战来临时你一定很疲惫，你一定很痛苦，甚至有时你很无聊。熬过去很多时候会是柳暗花明又一村的另一个美好世界的景象。我想我熬过来了，这个过程我加入了很多反馈机制，来调节我的感官上的感觉，以达到刺激自我感觉的目的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/life/idea-talking33-8.png&quot; alt=&quot;anki&quot;&gt;&lt;/p&gt;

&lt;p&gt;比如这张图，我用Anki软件来背英语单词，每天的背诵量被记录下来，并且用这种日历方格的统计形式展示出来，让我很有成就感，每天都为打满这个图而不懈的坚持，越多越有劲，越坚持越停不下来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/life/idea-talking33-7.png&quot; alt=&quot;github&quot;&gt;&lt;/p&gt;

&lt;p&gt;也比如这张图，这是我在github上写文章的记录，原本计划是每天写半小时文章，但计划并没有顺利的进行，这个任务难度确实很大，我不跟自己死磕到底，我也怕自己的身体受不了，于是我饶了自己，尽自己所能的每天写点，在身体允许的范围下尽量做到每周一篇文章。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/life/idea-talking33-9.jpeg&quot; alt=&quot;github&quot;&gt;&lt;/p&gt;

&lt;p&gt;写书写文章的灵感并不是每天都有的，一开始会有很多灵感，是因为我这么多年积累了很多自己的生活，工作的知识和经验，想说的想表达的，但毕竟我的经历还是单薄，狭窄的世界观有时任然显露无疑，为了能让自己能有更多的知识，更深刻的理论体系，更广泛的见识，我坚持每天看书，每天风雨无阻坚持看半小时-两小时。看书的速度与日俱增，但始终无法敌过我买书的速度，看书的速度越快，买书的量就越凶残，最后导致办公桌上全是书。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/life/idea-talking33-4.png&quot; alt=&quot;github&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/life/idea-talking33-5.png&quot; alt=&quot;github&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/life/idea-talking33-6.png&quot; alt=&quot;github&quot;&gt;&lt;/p&gt;

&lt;p&gt;其中我看了《精力管理》这本书后让我对时间和精力的管理，有了更深刻的认识。先前知识对时间的认识，也只是想着要好好利用时间，提高时间的利用率，但并没有结合人的属性来制定计划和规划。在看了《精力管理》后，对人本身的精力和时间上的规划有了更深刻的认识。先前我不屑于对时间和精力的精确管理，在看了《精力管理》后，让我对时间和精力管理有了更加浓厚的兴趣。于是就有了上面三张图的内容，这是我日常中记录下来的每天做事的大致内容，内容并没有精确细致到细节，但是时间块上的记录让我知道了我每天运用精力都在什么地方上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/life/idea-talking33-1.png&quot; alt=&quot;github&quot;&gt;&lt;/p&gt;

&lt;p&gt;就这样用昨天的记录来调整今天的状态，每天周而复始，从今年3月份开始，记录下了我每天都把精力花在哪了，用每日、每周、每月的统计图表的方式，让自己了解自己的状态如何。于是就有了上图这张，至今为止记录下来的统计图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/life/idea-talking33-10.png&quot; alt=&quot;github&quot;&gt;&lt;/p&gt;

&lt;p&gt;这些记录与练习仍然不够，我在不断发掘自己的缺点，比如我的说话表达能力很差，因为30几年来一直认为‘没什么好说的，成绩和实干决定一切’的错误观念，导致我脸部的肌肉非常糟糕，软软的只能用来装可爱，因为没有得到充分的锻炼，在说话时完全没有脸部肌肉工作的成分，使得说话非常吃力，完全由大脑来控制该说什么话，如何说，如何开口，如何动口，大脑工作得很累，久而久之就会觉得说话很累，不想说话，于是情况更加糟糕。&lt;/p&gt;

&lt;p&gt;为了改进这个缺点，我找到了一个方法，就是朗读，用朗读书本的方式去锻炼脸部的肌肉，当脸部肌肉得到了锻炼在我说话时就不会那么累了，部分词语完全可以用脸部的肌肉记忆代替大脑的工作，减轻大脑的负担。于是就有了上图，在‘喜马拉雅app’上每天对着书朗读10-20分钟，并且上传到个人文件夹保存起来留作纪念，也是一种正向的反馈机制让自己能够更加有兴趣继续下去。&lt;/p&gt;

&lt;h6&gt;我发现我越来越向务实靠近，脱虚务实的趋向越来越严重，这并不是什么绝对的好现象，但至少我现在需要它。最近在公众号上看到的一个人提出来，&amp;quot;心上学，事上练&amp;quot;的口号，我很是赞成。接下来我希望自己少写些，哲学类话题，而更多的是事实在在的从事情上学习、研究、分析，真正能够做到‘事上练，心上学’。&lt;/h6&gt;

&lt;h6&gt;2019年只是一个开始，既然开始了，我不想再停下来，别人说曾国藩自律了20年才有这样的成就，那我可以先试试自律10年。我看见了另一个世界，一个更加积极，更加自律，更加善于合作的世界。&lt;/h6&gt;

&lt;h6&gt;题外话：我很赞同《自卑与超越》里说的，”合作能力是大多数人所缺乏的“，我们要努力成为一个容易合作、能够主动建立合作、帮助别人加入合作的人。&lt;/h6&gt;
</description>
               <pubDate>Sat, 28 Dec 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/12/28/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A833.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/12/28/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A833.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(五) - Projector投影原理</title>
               <description>&lt;h3&gt;Projector 投影的原理与应用&lt;/h3&gt;

&lt;p&gt;Unity3D中的 Projector 投影像是一个很神秘的组件，但其实它依然运用的是以着色器为基准的渲染流程，和普通的3D模型渲染从本质上来看并没有实质上的区别，唯一的区别是它从它自己的视体(视锥体或平视体)中检测到的模型，并根据默认或者自定义的材质球与Shader着色器，将这些物体又重新绘制了一遍。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;从Unity3D引擎上来讲，可以这样解释 Projector：&lt;/p&gt;

&lt;p&gt;根据 Projector 自身的视体的范围，平视体或视锥体，遍历并计算出视体范围内与视体占边的所有物体。&lt;/p&gt;

&lt;p&gt;接着 Projector 取得这些物体模型数据，并计算投影矩阵。&lt;/p&gt;

&lt;p&gt;这个投影矩阵是什么呢，其实就是前面说的 Projector 视体空间的投影矩阵。&lt;/p&gt;

&lt;p&gt;最后将投影矩阵传入Shader中，根据这个投影矩阵，对这些物体再渲染一次。&lt;/p&gt;

&lt;p&gt;投影中的Shader着色器是投影绘制的主要手段，Projector 的工作只是检测了所有范围内的模型，并传递了投影空间的矩阵而已。&lt;/p&gt;

&lt;p&gt;投影Shader中，通常会结合传入的投影矩阵，将顶点转为 Projector 投影空间中，并以此为投影贴图的UV来渲染模型。&lt;/p&gt;

&lt;p&gt;例如这个简单的投影着色器：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sampler2D&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;float4x4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unity_Projector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SV_POSITION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;texc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TEXCOORD0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;appdata_base&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UNITY_MAXTRIX_MVP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;texc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unity_Projector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;COLOR&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tex2Dproj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;texc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 unity&lt;em&gt;Projector 变量就是由 Projector 传入投影矩阵。在顶点着色器中 unity&lt;/em&gt;Projector 矩阵被用来构造投影坐标，和普通的空间投影转换矩阵MVP(Model View Project)不同的是，其中的V是 Projector 空间的相关矩阵，即 Projector 组件所属的 Transform 的 worldToLocalMatrix变量，而P则是和Projector远近裁切相关的矩阵。&lt;/p&gt;

&lt;p&gt;用 unity_Projector 矩阵计算出vertex(顶点)在投影空间中的坐标后，我们就可以以此坐标为uv坐标绘制物体了。&lt;/p&gt;

&lt;p&gt;为什么可以将顶点坐标视为uv坐标呢？当坐标变换到投影空间后，其坐标空间就变成了投影平面视角，在这个视角中如果我们将平面视为纹理大小，就相当于一一匹配上顶点的uv坐标。&lt;/p&gt;

&lt;p&gt;这个转化后的投影空间中的坐标，也就是我们常说的&amp;quot;投影纹理坐标&amp;quot;。&lt;/p&gt;

&lt;p&gt;&amp;quot;投影纹理坐标&amp;quot;不能直接当作uv来作为纹理坐标来使用，需要调用 tex2Dproj 方法来获取纹理坐标:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    tex2Dproj(texture,uvproj);

    这个纹理投影函数，其实就是在使用之前会将该投影纹理坐标除以透视值

    可以等价于按如下方法使用普通二维纹理查询函数

    float4 uvproj = uvproj/uvproj.w;

    tex2D(texture,uvproj);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果如下图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;缺图
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;​###### 投影的技巧还有很多，我们下面介绍几种投影技巧在游戏项目中的运用。&lt;/p&gt;

&lt;h6&gt;平面阴影&lt;/h6&gt;

&lt;p&gt;平面阴影也是投影技巧的一种，它稍微需要运用些图形计算，主要的原理是在着色渲染模型时，另外做一个Pass将模型上顶点转换到平面上再渲染一次，以此作为平面的阴影，无论地上有没地形，都以平面呈现。如下图:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    缺图
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要计算这个平面阴影需要我们从光源点，顶点，法线，平面这些已知数据出发计算顶点转换到平面上的点。&lt;/p&gt;

&lt;p&gt;我们首先已知的是地面法线向量 TerrainNormal，和平面上随便一个初始点点的坐标 TerrainPos，我们假设我们需要计算的点为p点&lt;/p&gt;

&lt;p&gt;由平面表达公式得知，平面上的任意向量与该平面的点乘所得值为0，因此地面上的方向向量 TerrainNormal 与 要投影的坐标与初始点所形成的方向向量点乘为零，即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    (p - TerrainPos) 点乘 TerrainNormal = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;又由于平面映射的P点是由光射到顶点延伸到平面而得到的，所以&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    p = d*L + L0 其中L0为顶点，的l为光到顶点的射线方向，d为L0射到p点的距离。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此根据这两个公式，代入得到:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    (dL + L0 - TerrainPos) 点乘 TerrainNormal = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解析后为&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    dL 点乘 TerrainNormal + (L0 - TerrainPos) 点乘 TerrainNormal = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;于是再得到d为:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    d = ((TerrainPos - L0) 点乘 TerrainNormal) / (l 点乘 TerrainNormal)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再代入进 p = d * l + L0 这个公式得到p，即如下Shader中的顶点函数所写&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CGPROGRAM&lt;/span&gt;

    &lt;span class=&quot;cp&quot;&gt;#pragma vertex vert&lt;/span&gt;
    &lt;span class=&quot;cp&quot;&gt;#pragma fragment frag&lt;/span&gt;
    &lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;quot;UnityCG.cginc&amp;quot;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;appdata&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;vertex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;POSITION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;vertex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SV_POSITION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;            

    &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TerrainPos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TerrainNormal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;vert&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;appdata&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wPos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unity_ObjectToWorld&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 光的方向&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;float3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normalize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_WorldSpaceLightPos0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// d 值的计算&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dist&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TerrainPos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wPos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TerrainNormal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TerrainNormal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 代入 p = d * l + L0 公式&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;wPos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wPos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dist&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 空间顶点转换&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unity_MatrixVP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wPos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;fixed4&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;frag&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SV_Target&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fixed4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ENDCG&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述Shader中，利用了_WorldSpaceLightPos0来确定光的反向，也可以用一个光的坐标与顶点的差值来得到一个光的方向。计算过程的公式转换可以以这张手绘的图作为参考。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/pingmianyinying.png&quot; alt=&quot;平面阴影&quot;&gt;&lt;/p&gt;

&lt;p&gt;图中清晰的标明了所有已知向量，和可计算向量，以及最终需要结算的点，上述所说的这些公式的转换都是基于这个图来做的。&lt;/p&gt;

&lt;h6&gt;利用深度信息计算图片投影&lt;/h6&gt;

&lt;p&gt;图片投影其实就是贴花的动态版，其做法也有很多种，我们在这里简单讲讲其中一种方法为:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    绘制一个box，其纹理的展示方式则以深度信息为依据，纹理贴近其绘制的模型上。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方式可以随着这个box的移动贴到不同物体上。&lt;/p&gt;

&lt;p&gt;大致的方向是，以一个BOX为渲染对象，渲染时在片元着色器中重新判定渲染纹理与渲染坐标。怎么判定呢？&lt;/p&gt;

&lt;p&gt;先从顶点着色器上获得顶点坐标的屏幕坐标，在片元着色器中传入的屏幕坐标时成了片元在屏幕上的坐标，用屏幕坐标获取对应的深度值，再让深度值作为z坐标来形成一个三维坐标，这时三维坐标只是屏幕空间上的坐标，我们让其屏幕空间转换到相机空间，再从相机空间转换到世界空间，再转换到投影空间，这样坐标就到了投影空间，再除以透视值，就得到坐标在0-1范围的坐标值，用这个值去提取纹理上的颜色，最后用这个颜色绘制片元。&lt;/p&gt;

&lt;p&gt;这个方法比较费的点为片元着色器中重新计算渲染坐标，这个坐标会以深度信息为z轴信息需要经过几个空间的转换，导致计算量比较大，不能放在顶点着色器中的原因是因为只有在片元着色器中才能得到片元深度信息。&lt;/p&gt;

&lt;h6&gt;贴花(喷图)&lt;/h6&gt;

&lt;p&gt;贴花的制作，可以以摄像机为节点向外计算一个长方体，所有与长方体有交集的模型上的面上的顶点都被存储起来，另外如果有顶点里外都有的面，则计算与长方体的面相交的新节点并加入进来，最后把所有得到的顶点和三角面制作成一个新的模型，这个模型的顶点转换到立方体空间再除以透视值，则成为了uv点，以此来呈现一个贴花(喷图)的效果。&lt;/p&gt;

&lt;p&gt;参考文献：&lt;/p&gt;

&lt;p&gt;《Unity3D ShaderLab 开发实战详解》&lt;/p&gt;

&lt;p&gt;《维基百科 Line–plane intersection》 https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection&lt;/p&gt;

&lt;p&gt;Planar Shadow http://qiankanglai.me/2016/12/23/planar-shadow/&lt;/p&gt;
</description>
               <pubDate>Tue, 10 Dec 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/12/10/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A610.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/12/10/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A610.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(四) - 多重采样以及着色器编译原理</title>
               <description>&lt;h3&gt;GPU上的多重采样(Multisampling)与反走样(Antialiasing)&lt;/h3&gt;

&lt;p&gt;多重采样(Multisampling)是一种对几何图元的边缘进行平滑处理的技术，也称为反走样技术之一。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;OpenGL支持几种不同的反走样技术，比如线段反走样，多边形反走样，纹理图像压缩的质量以及导数精度设置。事实上这几个反走样技术都是以开关的形式在OpenGL中存在，算法大致是将原本单一的线条或像素块周围填充更多的像素块，具体的填充算法细节比我们想象的要复杂的多，而且不同OpenGL是现在的算法中也有细微的差异，我们在这里不进行深入讨论。&lt;/p&gt;

&lt;p&gt;多重采样的工作方式是对每个像素的几何图元进行多次采样。在多次采样后，每个像素点不仅仅只是单个颜色(以及除了颜色外的深度值、模板值等信息)，还记录了许多样本值。&lt;/p&gt;

&lt;p&gt;这些样本值类似于将一个像素分拆成了更小型的像素，每个像素都存储着颜色、深度值、模板值等信息，当我们需要呈现最终图像的内容时，这个像素的所有样本值会被解析为最终像素的颜色。&lt;/p&gt;

&lt;p&gt;在Unity3D中对这方面的反走样功能也提供了支持，可以通过Quality Settings中的AntiAliasing来设置，它将启用图形接口(OpenGL或DirectX)中的多边形的反走样算法，并且开启多重采样，根据多重采样信息对多边形边缘进行像素填充。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    AntiAliasing 可以设置3档采样质量分别是 2倍, 4倍 and 8倍的多重采样。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;GPU上的反走样代价是消耗更多的GPU算力和显存，庆幸的它并不消耗CPU算力。&lt;/p&gt;

&lt;h3&gt;着色器编译过程与变体&lt;/h3&gt;

&lt;p&gt;我们在知道GPU渲染管线如何运作后，对着色器编译过程仍然需要知晓，我们还是以使用OpenGL为例来学习着色器在Unity3D中从编译到执行的全过程。&lt;/p&gt;

&lt;p&gt;着色程序的编译过程与C语言等编译语言的编译过程非常类似，只是C语言在编译时是以离线的方式进行，而着色器程序的编译则是当引擎需要时，通过引擎调用图形接口(OpenGL或DirectX)的方式来进行编译，整个应用程序只需要编译一次后面可以重复利用，这和我们通常所说的JIT(Just in time 即时编译)有点相似。&lt;/p&gt;

&lt;h6&gt;上面所说的这些都是图形引擎控制和执行的，也就是当需要某个着色器程序时Unity3D引擎通过判断是否存在已经编译好的着色器程序，来决定是否编译着色器代码或是重用已经编译好的着色器程序。&lt;/h6&gt;

&lt;p&gt;那么着色程序从编译到执行过程到底是怎样的呢？让我们来讲一讲。&lt;/p&gt;

&lt;p&gt;首先当引擎得知渲染需要用到的Shader不曾被编译过时，就会调用图形接口 glCreateShader 为着色器创建一个新的着色器对象。&lt;/p&gt;

&lt;p&gt;然后通过程序从Shader文件中获取Shader内容(字符串)并调用 glShaderSource 将源代码(字符串)关联到刚刚创建的着色器对象上。&lt;/p&gt;

&lt;h6&gt;这时着色器对象已经关联了源代码，我们可以通过调用图形接口的编译接口 glCompileShader 对这个着色器对象进行编译。&lt;/h6&gt;

&lt;p&gt;编译完成后，我们可以通过 glGetShaderInfoLog 来获得编译信息以及是否成功的结果。&lt;/p&gt;

&lt;p&gt;到此仅仅是某个着色器对象编译完成，这个着色器对象可能是顶点着色器，也可能是片元着色器，或也许是细分着色器或几何着色器。&lt;/p&gt;

&lt;p&gt;通常情况下，有好几个着色器需要编译，顶点着色器和片元着色器通常都成对出现，则会创建相应的着色器对象来分别编译它们的源代码。&lt;/p&gt;

&lt;p&gt;有了着色器对象还不够，我们需要把这些着色器关联起来。&lt;/p&gt;

&lt;p&gt;首先引擎会使用 glCreateProgram 需要创建一个空的着色器程序。&lt;/p&gt;

&lt;p&gt;然后多次调用 glAttachShader 来一个个地绑定着色器对象。&lt;/p&gt;

&lt;h6&gt;当所有必要的着色器对象关联到着色器程序之后，就可以链接对象来生成可执行程序了，调用 glLinkProgram 将所有关联的着色器对象生成一个完整的着色器程序。&lt;/h6&gt;

&lt;p&gt;当然，着色器对象也可能存在某些问题，因此在链接过程中依然可能失败，引擎通过 glGetProgramiv 来查询链接操作的结果，以及通过 glGetProgramInfoLog 接口来获取程序链接的日志信息，由此我们就可以判断错误原因。&lt;/p&gt;

&lt;p&gt;成功完成了着色器程序的链接后，引擎就可以通过调用 glUseProgram 来运行着色器程序。&lt;/p&gt;

&lt;p&gt;我们平常在Unity3D中用到的Shader中的Pass，每个Pass中都有着色器需要编译，因此每次在绘制不同的Pass时都会对Pass中的顶点着色器和片元着色器进行编译。也就是说，Unity引擎会为每个Pass标签生成一个着色器程序，生成这些着色器程序后，执行顺序仍然按照Pass的先后次序来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader_compile.jpg&quot; alt=&quot;着色器编译流程&quot;&gt;&lt;/p&gt;

&lt;h6&gt;除了着色器的编译流程外，Unity3D中的Shader Varant(变体)在实际开发中也是比较严重的问题&lt;/h6&gt;

&lt;p&gt;那么什么是“变体”呢。其实它是由Unity3D自身的宏编译指令引起的，它为不同情况而编译生成不同的着色器程序。从引擎端的说法来看，Unity3D把不同的编译版本拆分成了不同的着色器源代码，在运行时再通过图形接口将这些着色器源代码编译成不同的着色器程序。&lt;/p&gt;

&lt;p&gt;为什么要使用宏编译指令导致生成这么多的着色器程序呢？因为要简化Shader，让同一个Shader在不同材质球上的应用不同的效果时更加便捷，修改和完善起来也更加高效。&lt;/p&gt;

&lt;h6&gt;假如编写很多同一个风格但不同效果的Shader，在使用和维护过程中会造成诸多的麻烦和不便，为了统一风格，为了提高效率，也为了能更好的打通各部门之间的沟通渠道，以及能让美术同学能更好的发挥对画面效果的调整，将同一个风格不同效果的Shader写在同一个Shader文件里是必不可少的，这样能更加容易的统一美术风格和制作流程，目的就是为了让风格更加统一，沟通更加便捷，效率更加高。&lt;/h6&gt;

&lt;p&gt;那么我们来看看Unity3D是怎么通过编译指令来编写宏以及它是怎么生成着色器源代码的。&lt;/p&gt;

&lt;p&gt;Unity3D的Shader中使用&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#pragma multi_compile&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#pragma shader_feature&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两个指令来实现着色器程序的自定义宏，它既适用于顶点片元着色器也适用于表面着色器。&lt;/p&gt;

&lt;p&gt;在运行时，Unity3D会根据材质(Material)的关键字(Material的对象方法EnableKeyword和DisableKeyword)或者全局着色器关键字(Shader的类方法EnableKeyword和DisableKeyword)&lt;/p&gt;

&lt;p&gt;我们通过 multi_compile 指令编写例如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#pragma multi_compile A_ON B_ON&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;这样会生成并编译两个Shader(变体)，一个是A&lt;em&gt;ON的版本，一个是B&lt;/em&gt;ON的版本。&lt;/h6&gt;

&lt;p&gt;运行的时候Unity3D会根据材质(Material)的关键字或者Shader全局关键字判断应该使用哪个Shader，如果两个关键字都为false，那么会使用第一个(A_ON)Shader变体。&lt;/p&gt;

&lt;p&gt;我们也可以创建多个组合关键字例如:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#pragma multi_compile A B C&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#pragma multi_compile D E&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样会使得Shader的变体成倍的增加，例如上述的预编译方式，会生成 3x2 = 6 个变体，分别是 A+D、 B+D、 C+D、 A+E、 B+E、 C+E 六种。&lt;/p&gt;

&lt;p&gt;假如multi_compile组合多到10行，每行2个，就是2的10次方个Shader(变体)就是1024个，这样生成这1024个Shader(变体)，在打包时会耗费很长在变体的生成上的打包时间。&lt;/p&gt;

&lt;h6&gt;除了 multi&lt;em&gt;compile 之外，另外一个指令 shader&lt;/em&gt;feature 也可以设置预编译宏，与 multi&lt;em&gt;compile 的区别是 shader&lt;/em&gt;feature 不会将没有被使用到的Shader(变体)打包进包内，因此 shader&lt;em&gt;feature 更适合材质球的关键字指定预编译内容，因为Unity3D只生成和编译被使用的预编译情况，而 multi&lt;/em&gt;compile 更适合全局Shader指定关键字，因为它会把所有组合都编译一遍，无论有没有用到。&lt;/h6&gt;

&lt;p&gt;除了这两个自定义预编译指令，Unity3D 本身自带的一些内建的 multi_compile 的快捷写法也会导致Shader变体的产生：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    multi_compile_fwdbase 为前向渲染编译多个变体，不同的变体处理不同的光照贴图的计算，并且控制了主平行光的阴影的开关。

    multi_compile_fwdadd 为前向渲染额外的光照部分编译多个变体，不同的变体处理不同灯光类型，平行光，聚光灯，点光，以及他们附带的cookie纹理版本。

    multi_compile_fwdadd_fullshadows 和 multi_compile_fwdadd 一样，并且包含了灯光的实时阴影功能。

    multi_compile_fog 为处理不同的雾效类型（off/linear/exp/exp2）扩展了多个变体。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;总的来说，无论是 multi&lt;em&gt;compile 还是 shader&lt;/em&gt;feature 亦或内建预编译指令，都会造成 Shader(变体)数量的增多，使得打包时间增加，运行时编译次数增多。当Unity3D在运行时检测到需要渲染的材质球里是不曾被编译的Shader时，则会将与自己匹配的Shader变体拎出来编译一下生成一个着色器程序，因此为了应对变体在运行时的编译消耗，通常会在运行时提前将所有Shader变体编译一下，使得运行中不再有Shader编译的CPU消耗。&lt;/h6&gt;

&lt;p&gt;参考文献:&lt;/p&gt;

&lt;p&gt;《OpenGL编程指南》&lt;/p&gt;

&lt;p&gt;《Unit3D Documentation》 https://docs.unity3d.com/Manual/SL-MultipleProgramVariants.html&lt;/p&gt;
</description>
               <pubDate>Wed, 04 Dec 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/12/04/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A69.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/12/04/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A69.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(三) - 渲染原理与知识3</title>
               <description>&lt;h3&gt;GPU Instancing 的来龙去脉&lt;/h3&gt;

&lt;p&gt;GPU Instancing 初次听到这个名词时还有点疑惑，其实翻译过来应该是GPU多实例化渲染，它本身是GPU的一个功能接口，Unity3D将它变得更简单实用。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;前面讲过一些关于Unity3D的动态合批(Dynamic batching)与静态合批(Static batching)的功能，GPU Instancing 实际上与他们一样都是为了减少Drawcall而存在。&lt;/p&gt;

&lt;p&gt;有了动态合批和静态合批为什么还需要 GPU Instancing 呢，究竟他们之间有什么区别呢，我们不妨来简单回顾一下Unity3D动态合批(Dynamic batching)与静态合批(Static batching)。&lt;/p&gt;

&lt;h6&gt;开启动态合批(Dynamic batching)时，Unity3D引擎检测视野范围内的非动画物体(通过遍历所有渲染模型，计算包围盒在视锥体中的位置，如果完全不在视锥体中则抛弃)，如果在视锥体内并且符合条件的就进行合批操作，将他们的网格合并后与材质球一并传给GPU去绘制。&lt;/h6&gt;

&lt;p&gt;需要符合什么条件呢：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1，900个顶点以下的模型。

    2，如果我们使用了顶点坐标，法线，UV，那么就只能最多300个顶点。

    3，如果我们使用了UV0，UV1，和切线，又更少了，只能最多150个顶点。

    4，如果两个模型缩放大小不同，不能被合批的，即模型之间的缩放必须一致。

    5，如果是不同的材质球实例同样不能被合批，即使他们一模一样。即材质球属性不能被修改，材质球对象实例必须是同一个。

    6，如果他们有lightmap的数据，必须是相同的才有机会合批。

    7，多个pass的Shader是绝对不会被合批。

    8，延迟渲染是无法被合批。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;条件比较苛刻，一不小心就无法达到合并条件。为什么它要使用这么苛刻的条件呢，我们来了解下设计动态合批这个功能的意图。&lt;/p&gt;

&lt;h6&gt;动态合批(Dynamic batching)这个功能的目标是以最小的代价合并小型网格模型，减少Drawcall调用。&lt;/h6&gt;

&lt;p&gt;很多人会想既然合并了为什么不把所有的模型都合并呢，这样不是更减少Drawcall的开销。如果把各种情况的中大型网格都合并进来，就需要消耗巨大的CPU资源，而且在摄像机移动过程中，每帧都要进行合并网格的消耗，CPU算力消耗太大，得不偿失。于是Unity3D就对这种极其消耗CPU算力的功能做了如此多的的限制，就是为了让它在运作时性价比更高。&lt;/p&gt;

&lt;p&gt;与动态合批不同，静态合批(Static batching)并不实时合并网格，而是会在离线状态下生成合并的网格，所有被标记为静态物体的模型，只要拥有相同实例的材质球都会被一并合并成网格。&lt;/p&gt;

&lt;p&gt;静态合批有诸多优点，但也存在不少弊端。被合批的是静态物体，它们是不能被移动旋转和缩放的，也只有这样我们在离线状态下生成的网格才是有效的（离线的网格数据不需要重新计算），生成的离线数据被放在Vertex buffer和Index buffer中。&lt;/p&gt;

&lt;h6&gt;静态合批生成的离线网格将导致存放在内存的网格数据量剧增，因为在静态合批中每个模型都会独立生成一份网格数据，无论他们所使用的网格是否相同，也就是说场景中有多少个静态模型就有多少个网格，与原本只需要一个网格就能渲染所有相同模型的情况不一样了。&lt;/h6&gt;

&lt;p&gt;好处是静态合批后同一材质球实例(材质球实例必须相同，因为材质球的参数要一致)调用Drawcall的数量合并了，另外合批也不会额外消耗CPU算力因为它们是在离线时生成的合批数据(也就是网格数据)，在实时渲染时如果该模型在视锥体范围内，三角形索引被部分提取出来合并后提交，而那些早就被生成的网格将被整体提交(整体网格过大时则会导致CPU和GPU的带宽消耗过大)，最后再一并发送给GPU进行渲染。&lt;/p&gt;

&lt;h6&gt;简而言之，动态合批为了平衡CPU消耗和GPU性能优化，将实时合批条件限制在比较狭窄的范围内。静态合批则牺牲了大量的内存和带宽，以使得合批工作能够快速有效的进行。&lt;/h6&gt;

&lt;p&gt;GPU Instancing 没有动态合批对网格数量的限制，也没有静态网格需要这么大的内存，很好的弥补了这两者的缺陷，但也有存在着比较大的优缺点，我们下面来逐一阐述。&lt;/p&gt;

&lt;p&gt;GPU Instancing 并不像动态和静态合批那样通过对网格的合并操作进行优化，GPU Instancing 的目标是只用一个模型网格绘制很多个地方，这些地方绘制的网格缩放大小，旋转角度和坐标可以不一样，材质球虽然相同但材质球属性可以各自有各自的区别。&lt;/p&gt;

&lt;p&gt;本质上来说 GPU Instancing 调用的是 OpenGL 和 DirectX 里的多实例渲染接口。我们拿 OpenGL 来说:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;glDrawArraysInstanced&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLenum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLsizei&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Glsizei&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;primCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;glDrawElementsInstanced&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLenum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLsizei&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLenum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;indices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLsizei&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;primCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;glDrawElementsInstancedBaseVertex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLenum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLsizei&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLenum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;indices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLsizei&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instanceCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLuint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baseVertex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这三个接口正是 GPU Instancing 调用多实例渲染的接口，第一个是无索引的顶点网格集多实例渲染，第二个是索引网格的多实例渲染，第三个是索引基于偏移的网格多实例渲染。调用这三个接口会向GPU传入渲染数据并开启渲染，与平时渲染多次要多次执行整个渲染管线不同的是，这三个接口会分别将模型渲染多次，并且是在一个渲染管线内。&lt;/p&gt;

&lt;p&gt;如果只是一个坐标上渲染多次模型是没有意义的，我们需要将一个模型渲染到不同的多个地方，并且以不同的缩放大小和旋转角度，以及不同的材质球参数，这才是我们真正需要的。&lt;/p&gt;

&lt;p&gt;GPU Instancing 正我们提供这个功能，上面三个渲染接口告知Shader着色器开启一个叫 InstancingID 的变量，这个变量可以确定在着色计算时使用哪个实例的属性。&lt;/p&gt;

&lt;p&gt;有了这个 InstancingID 就能使得我们在多实例渲染中，辨识到底使用哪个属性参数。Shader的顶点着色器和片元着色器可以通过这个变量来获取模型矩阵、颜色等不同变化的参数。&lt;/p&gt;

&lt;p&gt;我们来看看Unity3D是怎么做的:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shader&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;SimplestInstancedShader&amp;quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Properties&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_Color&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Color&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;SubShader&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Tags&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;RenderType&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Opaque&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;LOD&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;CGPROGRAM&lt;/span&gt;
            &lt;span class=&quot;cp&quot;&gt;#pragma vertex vert&lt;/span&gt;
            &lt;span class=&quot;cp&quot;&gt;#pragma fragment frag&lt;/span&gt;
            &lt;span class=&quot;cp&quot;&gt;#pragma multi_compile_instancing&lt;/span&gt;
            &lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;quot;UnityCG.cginc&amp;quot;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;appdata&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;vertex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;POSITION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;UNITY_VERTEX_INPUT_INSTANCE_ID&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//顶点着色器的 InstancingID定义&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;vertex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SV_POSITION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;UNITY_VERTEX_INPUT_INSTANCE_ID&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//片元着色器的 InstancingID定义&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;UNITY_INSTANCING_BUFFER_START&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 定义多实例变量数组&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;UNITY_DEFINE_INSTANCED_PROP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;UNITY_INSTANCING_BUFFER_END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;appdata&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

                &lt;span class=&quot;n&quot;&gt;UNITY_SETUP_INSTANCE_ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//装配 InstancingID&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;UNITY_TRANSFER_INSTANCE_ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//输入到结构中传给片元着色器&lt;/span&gt;

                &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UnityObjectToClipPos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;fixed4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SV_Target&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;UNITY_SETUP_INSTANCE_ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//装配 InstancingID&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;UNITY_ACCESS_INSTANCED_PROP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//提取多实例中的当前实例的Color属性变量值&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ENDCG&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述是一个很普通的调用 Instancing 的Shader，其中&lt;em&gt;Color 和 unity&lt;/em&gt;ObjectToWorld (模型矩阵)是多实例化的，他们通过 InstancingID 索引来确定取数组中的哪个变量。&lt;/p&gt;

&lt;p&gt;为什么这么说呢？我们来看看Shader中这些包含有 INSTANCE 字样的宏定义。&lt;/p&gt;

&lt;p&gt;首先编译命令 multi&lt;em&gt;compile&lt;/em&gt;instancing 会告知着色器我们将会使用多实例变量。&lt;/p&gt;

&lt;p&gt;其次在顶点着色器和片元着色的输入输出结构中，加入 UNITY&lt;em&gt;VERTEX&lt;/em&gt;INPUT&lt;em&gt;INSTANCE&lt;/em&gt;ID 告知结构中多一个变量即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    uint instanceID : SV_InstanceID;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每个顶点和片元数据结构中都定义了 instanceID 这个变量，这个变量将被用于确定使用多实例数据数组中的哪个实例参数，很关键。&lt;/p&gt;

&lt;p&gt;接着Shader中要把需要用到的多实例变量参数定义起来:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;UNITY_INSTANCING_BUFFER_START&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;UNITY_DEFINE_INSTANCED_PROP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;UNITY_INSTANCING_BUFFER_END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述中的宏很容易从字面看出它们为&amp;quot;开始多实例宏定义&amp;quot;，&amp;quot;对多实例宏属性定义参数&amp;quot;，以及&amp;quot;结束多实例宏定义&amp;quot;。&lt;/p&gt;

&lt;p&gt;这三个宏定义我们可以在 UnityInstancing.cginc 中看到，即:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class=&quot;cp&quot;&gt;#define UNITY_INSTANCING_BUFFER_START(buf)      UNITY_INSTANCING_CBUFFER_SCOPE_BEGIN(UnityInstancing_##buf)&lt;/span&gt;
        &lt;span class=&quot;cp&quot;&gt;#define UNITY_INSTANCING_BUFFER_END(arr)        UNITY_INSTANCING_CBUFFER_SCOPE_END&lt;/span&gt;
        &lt;span class=&quot;cp&quot;&gt;#define UNITY_DEFINE_INSTANCED_PROP(type, var)  type var[UNITY_INSTANCED_ARRAY_SIZE];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以上述的宏定义中理解到，这三个宏可以对多实例的多属性数组进行定义。&lt;/p&gt;

&lt;p&gt;于是在顶点着色器与片元着色中，我们对 InstancingID 进行装配，即宏定义：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    UNITY_SETUP_INSTANCE_ID(v) 和 UNITY_SETUP_INSTANCE_ID(i);

    装配过程其实就是从基数偏移的过程 unity_InstanceID = inputInstanceID + unity_BaseInstanceID;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终我们通过 UNITY&lt;em&gt;SETUP&lt;/em&gt;INSTANCE&lt;em&gt;ID 装配得到了 unity&lt;/em&gt;InstanceID 即当前渲染的多实例索引ID。&lt;/p&gt;

&lt;p&gt;有了多实例的索引ID，我们就可以通过这个变量获取对应的当前实例的属性值，于是就有了以下的宏定义 UNITY&lt;em&gt;ACCESS&lt;/em&gt;INSTANCED_PROP 以及通过这个宏定义获取变量的代码。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#define UNITY_ACCESS_INSTANCED_PROP(arr, var)   var[unity_InstanceID]&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;UNITY_ACCESS_INSTANCED_PROP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//提取多实例中的当前实例的Color属性变量值&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;有了类似_Color的多实例属性操作，在模型矩阵变化中也需要具备同样的操作，我们没看到模型矩阵多实例是因为Unity在Shader编写时用宏定义把它们隐藏起来了，它就是 UnityObjectToClipPos。&lt;/h6&gt;

&lt;p&gt;UnityObjectToClipPos 其实是一个宏定义，当多实例渲染开启时，它被定义成了如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#define unity_ObjectToWorld     UNITY_ACCESS_INSTANCED_PROP(unity_Builtins0, unity_ObjectToWorldArray)&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;UnityObjectToClipPosInstanced&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UNITY_MATRIX_VP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unity_ObjectToWorld&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;UnityObjectToClipPosInstanced&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UnityObjectToClipPosInstanced&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define UnityObjectToClipPos UnityObjectToClipPosInstanced&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个定义也同样可以在 UnityInstancing.cginc 中找到，其中unity_ObjectToWorld是关键，它从多实例数组中取出了当前实例的模型矩阵，再与坐标相乘后计算投影空间的坐标。也就是说当开启 Instancing 多实例渲染时，UnityObjectToClipPos 会从多实例数据数组中取模型矩阵来做模型到投影空间的转换。而当不开启 Instancing 时，UnityObjectToClipPos 则只是用当前独有的模型矩阵来计算顶点坐标投影空间的位置。&lt;/p&gt;

&lt;p&gt;到此我们就从着色器中获取了多实例的属性变量，根据不同实例的不同索引获取不同属性变量包括模型矩阵，从而渲染不同位置，不同的旋转角度，不同的缩放大小，以及更多比如_Color的其他属性，整个过程都是围绕着 InstancingID 来做索引操作。&lt;/p&gt;

&lt;h6&gt;知道了 GPU Instancing 是如何渲染还不够，我们还要知道数据是怎么传进去的。&lt;/h6&gt;

&lt;p&gt;我们还是拿 OpenGL 接口编程来分析。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//获取各属性的索引&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;glGetAttribLocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;position&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normal_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;glGetAttribLocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;normal&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;glGetAttribLocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;color&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matrix_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;glGetAttribLocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;model_matrix&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//按正常流程配置顶点和法线&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glBindBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_ARRAY_BUFFER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position_buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//绑定顶点数组&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glVertexAttribPointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_FLOAT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//定义顶点数据规范&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glEnableVertexAttribArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//按上述规范，将坐标数组应用到顶点属性中去&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glBindBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_ARRAY_BUFFER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normal_buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//绑定发现数组&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glBertexAttribPointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;normal_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_FLOAT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//定义发现数据规范&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glEnableVertexAttribArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;normal_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//按上述规范，将法线数组应用到顶点属性中去&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//开始多实例化配置&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//设置颜色的数组。我们希望几何体的每个实例都有一个不同的颜色，&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//将颜色值置入缓存对象中，然后设置一个实例化的顶点属性&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glBindBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_ARRAY_BUFFER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color_buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//绑定颜色数组&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glVertexAttribPointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_FLOAT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//定义颜色数据在color_loc索引位置的数据规范&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;glEnableVertexAttribArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//按照上述的规范，将color_loc数据应用到顶点属性上去&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;glVertexattribDivisor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//开启颜色属性的多实例化，1表示每隔1个实例时共用一个数据&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;glBindBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_ARRAY_BUFFER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model_matrix_buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//绑定矩阵数组&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//设置矩阵第一行的数据规范&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glVertexAttribPointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matrix_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_FLOAT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mat4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vec4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//将第一行的矩阵数据应用到顶点属性上去&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glEnableVertexAttribArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matrix_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//开启第一行矩阵数据的多实例化，1表示每隔1个实例时共用一个数据&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glVertexattribDivisor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matrix_loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个示例很精准的表达了数据是如何从CPU应用层传输到GPU上再进行实例化的过程。&lt;/p&gt;

&lt;p&gt;我在代码上做了比较详尽的注释，首先获取需要推入顶点属性的数据的索引，再将数组数据与OpenGL
缓存进行绑定，这样才能注入到OpenGL里去，接着告诉 OpenGL 每个数据对应的格式，然后再根据前一步描述的格式应用到顶点属性中去，最后如果做的是 GPU Instancing 多实例的属性数据则开启多实例化属性接口，让 InstancingID 起效。&lt;/p&gt;

&lt;h6&gt;总结，我们解析了 GPU Instancing 在 Unity3D 中的工作方式，得知了它能用同一个模型同一个材质球渲染不同的位置、角度、缩放大小、以及不同颜色等属性。这种没有对模型网格数量限制，没有占用大量内存的性能优化来说，很好的弥补了动态合批(Dynamic batching)与静态合批(Static batching)的不足。&lt;/h6&gt;

&lt;p&gt;但是它毕竟是只能围绕一个模型来操作，只有相同网格(Mesh)和相同的材质球实例(参数可以不同，但必须使用API来设置不同参数)的情况下才能做到多个实例在同一个渲染管线中一次性渲染的优化操作，而动态合批和静态合批却只需要材质球实例一致，网格是可以有差别的。&lt;/p&gt;

&lt;h6&gt;三者利弊各不同，有互相弥补的地方，各自本身也存在着不同程度的限制和优缺点。从整体上来看，GPU Instancing 更适合同一个模型渲染多次的情况，而动态合批(Dynamic batching)更适合同一个材质球并且模型面数小的情况，静态合批(Static batching)更适合当我们能容忍内存扩大的情况。&lt;/h6&gt;
</description>
               <pubDate>Wed, 20 Nov 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/11/20/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A68.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/11/20/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A68.html</guid>
            </item>
        
            <item>
               <title>思路探讨(三十一) 钱、才、运</title>
               <description>&lt;p&gt;最近几年一直在突破自己的认知，可能是我本身从小对世界的认知水平就比较狭小的缘故，努力了好几年才只是普通人的水平，但对我来说已经是很厉害了，我很满足，山外有山，人外有人，一山还有一山高，一水还有一水深，做好自己最重要。&lt;/p&gt;

&lt;p&gt;从小到大一直无法想明白的一件事是，‘有才’为什么不一定有钱，有钱人为什么不是因为‘有才’才赚到钱。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h6&gt;后来才渐渐明白，这是我人生中一个比较大的认知错误，认为钱和才是对等的。&lt;/h6&gt;

&lt;p&gt;钱和才，虽然谈不上完全是两码事，但他们之间的联系确实没有这么紧密，不过‘有才’至少能让你解决温饱问题。&lt;/p&gt;

&lt;h6&gt;一个人有价值(就是有知识，有技能，有经验)和赚到大钱是两码事，很多时候有价值的人能被人看重，但并不一定能赚到钱，因为公司或者说组织不一定能成事，他是厉害了，周围的人不配合不协作，各怀鬼胎，一个人再厉害也无法扭转乾坤，即使周围的人协同性很好而时代潮流不配合也同样无济于事。&lt;/h6&gt;

&lt;p&gt;所以想要赚到大钱，‘天时、地利、人和’一样不能少，这个就是我们俗称的‘运气’。说起来很俗气，‘运气’很神秘，就像神棍一样，没有科学的依据，但确实这个东西真真正正存在我们的周围。&lt;/p&gt;

&lt;p&gt;这个‘运气’，有两种诠释：&lt;/p&gt;

&lt;h6&gt;一种是像稻盛和夫(日本经营之神，创业百分百成功，做什么成什么，企业破产了求他接手，立刻妙手回春)这类的，认为‘运气’是靠自己争取来的，以精神世界为中心，自己积善行德才能积攒足够多的‘运气’，用利他心态来做事，加上不屑努力，最后全社会都会回馈给他以‘运气’，最终靠着这股‘运气’走上成功的道路。&lt;/h6&gt;

&lt;p&gt;另一种是认为‘运气’是随机，就像守株待兔里的农夫，指不定什么时候兔子就自己撞到枪口上了就能有一顿饱肉吃，也像彩票的中奖概率，不知道什么时候就来那么一下，你就什么都有了。&lt;/p&gt;

&lt;p&gt;这两种我更偏向于稻盛和夫的理念，我也一直向他老人家在学习，用利他的心态做事，不屑努力，来感动全宇宙的量子(这个说法是从一本叫做《The Secret》中文叫秘密里看到的，它其实是一部鸡汤成功学的书，它告诉你其实全世界都是量子，你只要拿出你的诚意并且全力拼搏，量子就会被你吸引来帮助你)。&lt;/p&gt;

&lt;p&gt;我们不偏执任何一种，事实上两种都存在，既有自身的因素，也有随机的因素。&lt;/p&gt;

&lt;p&gt;随机的运气也并不是我们表面上看上去那么容易，它很多时候都需要毅力支撑。毅力二字是大多数人成功的秘诀，即使日子再苦再累再无趣，受压迫得再厉害，如果依然能够扛得住，运气就有可能降临到他们身上。&lt;/p&gt;

&lt;p&gt;为什么？因为风险是波动的，当震荡加剧，波幅增大，低谷更低，时间更长时，精神上和肉体上的压力就会增大，无法承受导致崩溃消亡也是正常的现象。大部分人无法承受这种非人的精神压力都选择了退缩，但只要扛过去，通常都是拨云见日，柳暗花明又一村，只是人是脆弱的，99%都选择了退缩，那最后1%中也有一半中途崩溃了，最后剩下的才是苦字熬出头的人，最终运气降临在他们身上，这种看似运气而实非运气的事也很常见。&lt;/p&gt;

&lt;h6&gt;这个世界还是公平的，我们无法把控的‘运气’确实占了成功因素的很大一部分，也只有这样才不是任何人想怎么样就怎么样的么，王思聪有钱有人有才，理论上说没有失败的理由，实际上，他开的公司，创的业，投资标的，不照样该垮的还是垮，”不经历风雨怎能见彩虹，没有人能随随便便成功“。&lt;/h6&gt;

&lt;p&gt;说实在的，我们可以避开赚钱二字不谈，人不一定要赚到足够多的钱才会幸福。&lt;/p&gt;

&lt;p&gt;“没有赚到钱的人生也能幸福”这句话很多人不理解。因为人们把钱看得太重，以至于认为成功就是有钱，有钱才能幸福，把三者划上了等号。&lt;/p&gt;

&lt;p&gt;这个偏执的观念会让人变得很痛苦，人常常会被欲望所控制，越想有钱，越痛苦，越不幸福，是一个恶性循环的开始。&lt;/p&gt;

&lt;h6&gt;我们应该坦然一点才是。​我希望我们能想明白，我们赚钱的目的是什么，如果是养家糊口，那是应该的。如果是追求富足的生活，我觉得该量力而行，别最后钱没赚到人没了情也没了，或者钱有了情没了身体没了，都得不偿失。如果是追求更高的精神境界，我觉得应该有计划的，有进也有退的，以更加稳健的姿态走向目标。&lt;/h6&gt;

&lt;p&gt;我在知乎的问答里看到这么一句话，虽然偏题了但我觉得挺值得深思，他说：”如果一个人到了40几岁，夫妻感情好，每个周还能有性生活，孩子学习成绩好，全家人身体强壮有力，这就是成功“，体会一下。&lt;/p&gt;
</description>
               <pubDate>Sat, 09 Nov 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/11/09/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A831.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/11/09/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A831.html</guid>
            </item>
        
    </channel>
</rss>