<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title></title>
        <description>漫漫人生,记录点滴技术,始于2013</description>
        <link>http://www.luzexi.com</link>
        <atom:link href="http://www.luzexi.com/assets/feed.xml" rel="self" type="application/rss+xml" />
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，Shader(八) - Suferface</title>
               <description>&lt;h6&gt;Surface Shaders 是Unity3D创建的，用来简化手动编写Shader的一种方式。&lt;/h6&gt;

&lt;h6&gt;Surface 能帮我们生成HLSL，不过Surface并不是种语言，可以用开关和指令集来形容Surface，并且我们依然要关注HLSL如何编写。&lt;/h6&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;Surface shader 和 vertex fragment shader 一样需要书写 CGPROGRAM..ENDCG，并且写入#pragma surface 来表明使用Surface，不同的是：Surface 它不能有Pass，所有的Surface编码都写在SubShader中，然后再由shader编译器编译成多个Pass。&lt;/p&gt;

&lt;h6&gt;#pragma surface 的格式如下：&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    #pragma surface surfaceFunction lightModel [可选择参数]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数说明：&lt;/p&gt;

&lt;h6&gt;1，surfaceFunction，是一个有输入输出参数的函数，其格式为&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    void surf (Input IN, inout SurfaceOutput o)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Surface通过这个函数来修改渲染细节，Shader中必须写有这个名字和格式的函数。&lt;/p&gt;

&lt;h6&gt;2，lightModel，选择光照模型。在内置的光照模型中，有以物理为基础的 Standard 和 StandardSpecular，和无物理基础的Lambert (diffuse漫反射) and BlinnPhong (specular镜面反射)。除此之外，还可以定义自己的光照模型。&lt;/h6&gt;

&lt;p&gt;其中内置的光照模型：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Standard 光照模型使用 SurfaceOutputStandard 作为输出结构并且匹配了Unity3D内置的Standard Shader(金属流)。

    StandardSpecular 光照模型使用 SurfaceOutputStandardSpecular 作为输出结构并且匹配了Unity3D内置的Standard Shader(镜面反射)。

    Lambert 和 BlinnPhong 光照模型则不以物理为基础，使用它们时可以在低端设备上运行得更快。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SurfaceOutputStandard 和 SurfaceOutputStandardSpecular 在 UnityPBSLighting.cginc 中有定义。&lt;/p&gt;

&lt;p&gt;Lambert 和 BlinnPhong 在 Lighting.cginc 中有定义，分别是 UnityLambertLight 和 UnityBlinnPhongLight。&lt;/p&gt;

&lt;h6&gt;3，可选择指令。&lt;/h6&gt;

&lt;h6&gt;透明物体 和 alpha testing 功能指令&lt;/h6&gt;

&lt;p&gt;透明物体 和 alpha testing 类型的参数可以控制alpha和alphaTest也就是alpha混合和alpha裁切 的功能。&lt;/p&gt;

&lt;p&gt;透明物体分为两种，一种是传统的alpha混合，另一种是更加物理化的“premultiplied blending”左自乘混合，它能够在半透明上保留适度的镜面反射。&lt;/p&gt;

&lt;p&gt;启用半透明使得surface shader包含了alpha混合功能。而启用alpha cutout 将根据alpha值在生成像素时中裁切掉不符合的片段。&lt;/p&gt;

&lt;p&gt;透明物体和alpha testing的功能指令如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    alpha 或者 alpha:auto，指令意思为，选择渐进透明也就是 alpha:fade 作为简单光照函数，并且选择左自乘透明方式也就是 alpha:premul 作为物理基础的光照函数。

    alpha:blend，开启alpha混合。

    alpha:fade，开启传统的渐进透明函数。

    alpha:premul，开启左自乘alpha透明度。

    alphatest:VariableName，开启alpha cutout裁切功能。将根据跟定的值裁切不符合的alpha片段。裁切后可以通过 addshadow 指令生成阴影。

    keepalpha，保持alpha值，让那些不透明的物体也有alpha通道为1.0的值。这个操作使得灯光函数在不透明物体上也起到alpha的作用。

    decal:add，开启叠加贴花功能，让贴花贴图使用叠加混合。

    decal:blend，开启半透明贴花功能，让贴花贴图使用alpha混合。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;自定义函数，自定义函数可以计算和修改顶点数据，或者计算和修改最终的片元颜色。&lt;/h6&gt;

&lt;p&gt;vertex:VertexFunctionName，自定义修改顶点函数。这个函数被调用来计算和修改模型的每个顶点的数据。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    函数的格式如下：

    void VertexFunctionName(inout appdata_full v, out Input o)

    函数中必须带有两个类型的参数，inout appdata_full 和 out Input。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 appdata_full 在Unity内置的UnityCG.cginc文件中，结构为如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;appdata_full&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;POSITION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tangent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TANGENT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normal&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NORMAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texcoord&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TEXCOORD0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texcoord1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TEXCOORD1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texcoord2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TEXCOORD2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texcoord3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TEXCOORD3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fixed4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;COLOR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UNITY_VERTEX_INPUT_INSTANCE_ID&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;其中 Input 的结构为如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Input结构里当使用某张纹理的uv时，可以使用“uv”加变量名来提取该纹理坐标，或者“uv2”加变量名使用第二纹理uv。（uv2一般用于lightmap）

    float3 viewDir - 视图方向（view direction）。

    float4 with COLOR semantic - 每个顶点插值后的颜色。

    float4 screenPos - 屏幕空间中的位置。

    float3 worldPos - 世界空间中的位置。

    float3 worldRefl - 世界空间中的反射向量。 如果surface 
    shader没有赋值o.Normal，将会包含世界反射向量。

    float3 worldNormal - 世界空间中的法线向量。如果surface 
    shader没有赋值o.Normal，将会包含世界法向量。

    float3 worldRefl; INTERNAL_DATA - 世界空间中的反射向量。如果surface 
    shader没有赋值o.Normal，将会包含这个参数。为了获得逐像素法线贴图的反射向量，请使用WorldReflectionVector 
    (IN, o.Normal)。参见例子： Reflect-Bumped shader。

    float3 worldNormal; INTERNAL_DATA -世界空间中的法线向量。如果surface 
    shader没有赋值o.Normal，将会包含世界法向量。为了获得逐像素法线贴图的法向量，请使用WorldNormalVector 
    (IN, o.Normal)。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;finalcolor:ColorFunctionName，设置自定义函数修改最终颜色。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    函数格式如下：

    void ColorFunctionName(Input IN, SurfaceOutput o, inout fixed4 color)

    函数中必须带有Input IN, SurfaceOutput o, inout fixed4 color，这三个参数。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;finalgbuffer:ColorFunctionName，自定义修改延迟路径gbuffer内容。&lt;/p&gt;

&lt;p&gt;finalprepass:ColorFunctionName，自定义修改旧有的延迟渲染前的路径。&lt;/p&gt;

&lt;h6&gt;阴影和网格细化指令&lt;/h6&gt;

&lt;p&gt;阴影和网格细化这两种指令，可以用来控制处理阴影渲染和网格细分。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    addshadow，生成一个阴影渲染管线。addshadow 经常会与顶点修改函数一起使用，让阴影有一定的动画效果。通常shader不需要任何特殊的方法处理阴影，他们可以用shader caster作为后备方案。

    fullforwardshadows，支持所有正向渲染路径下的灯光阴影。默认情况下shader在正向渲染中只支持1个方向光的阴影渲染。如果你需要在正向渲染中对点光源进行阴影渲染，就得使用这个指令。

    tessellate:TessFunctionName，使用DX11 GPU 网格细化。自定义函数中计算了三角形的边和里面的细分因素。

    网格细分化功能，需要使用Shader Model 4.6 target进行编译，所以只能在 DX11/12, OpenGL Core and PS4/XB1 上使用。

    TessFunctionName的格式为：

    float4 TessFunctionName(appdata v0, appdata v1, appdata v2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;代码生成操作指令&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    exclude_path:deferred, exclude_path:forward, exclude_path:prepass，不生成指定的渲染路径。

    三个指令分别代表延迟渲染, 正向渲染 和 旧式延迟渲染。

    noshadow，关闭所有阴影渲染支持。

    noambient，不使用环境光或者光探测。

    novertexlights，在正向渲染中不使用任何光探测或顶点光照。

    nolightmap，关闭所有烘培光照图。

    nodynlightmap，关闭实时动态全局自发光的支持。

    nodirlightmap，关闭方向光的支持。

    nofog，关闭内置迷雾效果。

    nometa，不生成meta渲染管线。

    noforwardadd，关闭正向渲染增加的渲染管线。

    nolppv，关闭 Light Probe Proxy Volume。

    noshadowmask，关闭 Shadowmask。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;其他指令&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    softvegetation，Suface shader只在 Soft Vegetation 开启时渲染。

    interpolateview，对视向上的做插值操作，替换像素shader里的计算。

    halfasview，替换观察向量为一半方向向量传给光照函数。

    dualforward，在正向渲染中使用双重光照图。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;自定义光照模型&lt;/h3&gt;

&lt;p&gt;光照模型是用来计算光照的，包括，光照影响，阴影，漫反射，镜面反射，环境光等。&lt;/p&gt;

&lt;p&gt;Unity3D内置的光照模型有 Lambert (漫反射光照) 和 BlinnPhong (镜面反射光照) 两种，这两种光照模型被写在Unity3D内置文件 Lighting.cginc 中，可以前往查看，window上的地址为(unity install path)/Data/CGIncludes/Lighting.cginc，Mac上的地址为 /Applications/Unity/Unity.app/Contents/CGIncludes/Lighting.cginc。&lt;/p&gt;

&lt;p&gt;除了这两种光照模型，我们还可以定义自己的光照模型。&lt;/p&gt;

&lt;p&gt;所有自定义的光照模型函数都必须以 Lighting 作为开头定义在Shader文件的 Surface块中。函数定义可以如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    half4 Lighting&amp;lt;Name&amp;gt; (SurfaceOutput s, UnityGI gi); 这种方式使用正向渲染，且没有视向的依赖。

    half4 Lighting&amp;lt;Name&amp;gt; (SurfaceOutput s, half3 viewDir, UnityGI gi); 这种方式使用正向渲染，且依赖视向。

    half4 Lighting&amp;lt;Name&amp;gt;_Deferred (SurfaceOutput s, UnityGI gi, out half4 outDiffuseOcclusion, out half4 outSpecSmoothness, out half4 outNormal); 这种方式使用的是光照延迟渲染。

    half4 Lighting&amp;lt;Name&amp;gt;_PrePass (SurfaceOutput s, half4 light); 这种方式使用的是旧的光照延迟渲染。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;自定义GI模型：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    half4 Lighting&amp;lt;Name&amp;gt;_GI (SurfaceOutput s, UnityGIInput data, inout UnityGI gi);

    如果你想使用内置的GI模型，有 DecodeLightmap 和 ShadeSHPerPixel 两种。他们都写在 UnityGlobalIllumination.cginc 的 UnityGI_Base 里。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Tessellation 网格细分&lt;/h3&gt;

&lt;p&gt;在模型渲染时很容易有锯齿感，Tessellation 网格细分可以改善这种锯齿感，Surface支持Tessellation 网格细分的功能，但只在DirectX 11 / OpenGL Core GPU上有效。&lt;/p&gt;

&lt;p&gt;Tessellation 功能指令为&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    tessellate:FunctionName 这个方法计算三角形的边和里面的细分因素。

    它是在 vertex:FunctionName 之后才被调用的，所以每个顶点都会被替换映射。

    Surface 可以选择使用 phong tessellation 平滑模型表面，而不用替换顶点映射。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;tessellate 有如下限制：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1，只计算三角形，没有方形，没有等值线细分。

    2，当tessellation被使用时，Shader 自动被编译成 Shader Model 4.6 target，意味着这个Shader只在 DX11/12, OpenGL Core and PS4/XB1 下工作。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;tessellate Function 的格式如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    float4 tessellateFunction(appdata v0, appdata v1, appdata v2);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;开启 phong tessellation 功能，需要加入指令：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    tessphong:VariableName

    VariableName 为Phong变量强度。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Unity3D：Writing Surface Shaders
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
               <pubDate>Tue, 21 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/21/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader8.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/21/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader8.html</guid>
            </item>
        
            <item>
               <title>中国，顶住！！</title>
               <description>&lt;h6&gt;在美国主导的加息和减税的政策下，美元强势回流，全球汇率大幅度波动，很多新兴国家混乱不堪，陷入经济危机，金融危机中，国家经济陷入倒退。&lt;/h6&gt;

&lt;h6&gt;中国也没能幸免，今年股，汇，商品，三杀，经济数据糟糕。&lt;/h6&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;确实中国存在很多问题，但美国难道问题不大吗，美国也存在诸多问题，甚至比中国还要多还要大。只是现在它的霸主地位，很多问题被掩盖了。&lt;/p&gt;

&lt;p&gt;而现在在中国，太多人崇洋媚外，特别是这个时候，中国经济最困难的时候，出汉奸的概率很大。&lt;/p&gt;

&lt;p&gt;说实话，美国确实强大，他的霸主地位无人能撼动，这是由历史原因造成的，但也不至于去投靠，连尊严都不要吧。&lt;/p&gt;

&lt;p&gt;我们可以学习，可以借鉴，但不可以放弃尊严选择去无脑膜拜。中国现在是世界经济第2大国，难道这还不足以说明中国的强大吗？！&lt;/p&gt;

&lt;p&gt;中国只需要一个机会就能颠覆美国。只要美国犯一个致命错误，比如次贷危机，内乱内战，或者陷入全面对外战争那种就可以。但这个机会一直没有出现，可能需要等上4，5十年。&lt;/p&gt;

&lt;p&gt;在两国都没有陷入危机的情况下，就会始终保持这种被压制的局面。打破平衡，需要大事件。&lt;/p&gt;

&lt;p&gt;现在最严重的问题是，境内外势力正在合力搞垮中国。那些近几年没赚到钱或者亏钱的人都站在欧美势力上了，汉奸会越来越多。&lt;/p&gt;

&lt;p&gt;真的要当心啊，每个新兴国家，在没达到霸主地位前，任然在发展中的情况下，一直都会有这种问题，不断有崇洋媚外的人冒出来，不顾国家利益的鼓动人民投靠他国。那些无法冷静的，没有独立思考的人民，就会像热锅上的蚂蚁一样乱了阵脚。&lt;/p&gt;

&lt;p&gt;我们任然是新兴国家，被美国收割是正常的，这场风暴是美国一手主导的，目的就是收割新兴国家。但太多人投靠美国，导致信心挫败。&lt;/p&gt;

&lt;p&gt;这几年中国肯定艰难痛苦，反转只能靠政府自己，人民群众是靠不住的。&lt;/p&gt;

&lt;h6&gt;人民只会关心自己的利益，而不顾国家的利益，幸好国家是一党专政制度，否则后果不堪设想：政变，大规模示威游行，甚至军变，内战都有可能。&lt;/h6&gt;

&lt;h6&gt;美国就希望看到中国内乱，内战，这样他的目的就达到了。一旦内乱，经济地位，全球地位就不保，错失了这个地位，未来再重返，将难上加难。&lt;/h6&gt;

&lt;h3&gt;中国千万要顶住！！！！&lt;/h3&gt;
</description>
               <pubDate>Fri, 17 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/17/%E4%B8%AD%E5%9B%BD%E9%A1%B6%E4%BD%8F.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/17/%E4%B8%AD%E5%9B%BD%E9%A1%B6%E4%BD%8F.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，Shader(七) - Fixed Function</title>
               <description>&lt;h3&gt;Fixed-function 是Unity3D官方自己编写的一套API，它与Surface shaders，及vertex and fragment program是区分开来的。Fixed-function，Suface program 和 vertex and fragment programs 三种编写Shader的方法不能同时使用，任何一种方式被编写后，其他两种都将无效。&lt;/h3&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;Fixed-function 相对于Suface 和 Vertex and fragment 来说简单很多，它是由一些简单的开关的函数组成的。我们可以用 Fixed-function 来做一些简单的灯光，贴图的变化。&lt;/p&gt;

&lt;p&gt;下面我们来了解一下这些开关和函数的语法。&lt;/p&gt;

&lt;h6&gt;Pass的第一个指令如果是Fixed-function的命令，则认为是Pass开启Fixed-function program。&lt;/h6&gt;

&lt;p&gt;顶点和灯光的颜色计算在模型渲染中被最先执行，它们在顶点转换上操作，并且计算的基础颜色在贴图使用前就被应用到了顶点上。&lt;/p&gt;

&lt;h6&gt;Material块&lt;/h6&gt;

&lt;p&gt;Material标签，可以用来定义材质球的各种光属性的颜色。格式如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Material
    {
        Diffuse [_Color]
        Ambient [_Color]
        Shininess [_Shininess]
        Specular [_SpecColor]
        Emission [_Emission]
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数如下：&lt;/p&gt;

&lt;p&gt;Diffuse color，漫反射颜色，这是物体的基础颜色。&lt;/p&gt;

&lt;p&gt;Ambient color，环境光颜色，被光照到后反应出来的颜色。&lt;/p&gt;

&lt;p&gt;Specular color，镜面反射的高光颜色。&lt;/p&gt;

&lt;p&gt;Shininess number，高光圈的大小，也就是尖锐度，数值范围在0-1之间。为0时高光圈很大覆盖整个物体，为1时高光圈很小，几乎缩小成一个点。&lt;/p&gt;

&lt;p&gt;Emission color，自身发出的颜色，当没有光照到的时候。&lt;/p&gt;

&lt;p&gt;整个光照颜色的公式为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;color = Ambient * 设置中的Ambient强度 + (灯光颜色 * Diffuse + 灯光颜色 * Specular) + Emission
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中灯光颜色，当多个灯光照射时会叠加多次。&lt;/p&gt;

&lt;h6&gt;Color颜色&lt;/h6&gt;

&lt;p&gt;Color颜色设置不透明物体的颜色。格式如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Color color
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;Lighting 开关&lt;/h6&gt;

&lt;p&gt;Lighting 是一个灯光的开关，Material块, ColorMaterial 和 SeparateSpecular都受到它的影响，如果Lighting 关掉的话，它们都将失效。&lt;/p&gt;

&lt;p&gt;格式如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Lighting On | Off
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;SeparateSpecular 镜面反射开关&lt;/h6&gt;

&lt;p&gt;SeparateSpecular 选项开启后会在最后一个pass后加上一个镜面反射光的pass，这使得镜面放射光不受到贴图的影响。&lt;/p&gt;

&lt;p&gt;格式如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    SeparateSpecular On | Off
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;ColorMaterial Material块中的颜色&lt;/h6&gt;

&lt;p&gt;ColorMaterial可以在每个顶点上替换Material中的颜色，其中AmbientAndDiffuse 替换Material块中的 Ambient 和 Diffuse 的颜色，Emission 替换Material块中 Emission 的颜色。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    ColorMaterial AmbientAndDiffuse | Emission
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;SetTexture 设置贴图&lt;/h6&gt;

&lt;p&gt;Fixed function 的贴图功能可以替换旧有的合并效果。我们可以写很多个 SetTexture 命令在 Pass里，所有的贴图都会依次被应用，就像绘制程序里的层级一样。&lt;/p&gt;

&lt;p&gt;另外，SetTexture 命令必须放在Pass的最后部分。&lt;/p&gt;

&lt;p&gt;SetTexture 格式为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    SetTexture [TextureName] {Texture Block}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 TextureName 为贴图的变量名，{Texture Block} 里面的有两种操作，一种是 combine 为主要操作命令，另一个是 constantColor 命令用来设置一个常量颜色。&lt;/p&gt;

&lt;p&gt;combine 命令在SetTexture里最为重要，它的格式可以为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    combine src1 * src2，src1 与 src2 相乘，颜色叠加。

    combine src1 + src2，src1 与 src2 相加，颜色加白加量。

    combine src1 - src2，src1 减去 src2，获得色差。

    combine src1 lerp (src2) src3，使用src2的alpha值计算src1到src3的插值。

    注意src2的alpha为1时结果为src1，src2的alpha为0时结果为src3。

    combine src1 * src2 + src3，src1 与 src2的alpha相乘，然后加上src3。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;上面所有的 src 属性可以是texture，或者previous，或者constant，或者primary。这几个变量分别是如下意思：&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    texture 是贴图变量TextureName贴图上的颜色。

    previous 是前面计算结果的颜色。

    primary 是顶点经过灯光计算后的颜色。也就是前面Material块中diffuse, ambient and specular colors与灯光的计算结果。

    constant 是常量颜色，可以使用 ConstantColor 在 combine 前设置。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;src变量后面可以跟的参数有&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Double 和 Quad 参数。src后面可以跟随double和quad，分别表示2x，4x的亮度，相当于乘2，乘4的效果。

    lerp 插值，所有src变量都可以使用 lerp 做插值操作。

    alpha 透明通道，src后面跟着alpha参数的话，就表示只使用src的alpha通道。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;合并时对Color和Alpha分开处理&lt;/h6&gt;

&lt;p&gt;有时我们需要对颜色和透明通道分开处理，可以在SetTextue时在颜色处理后面加逗号表示分开处理color和alpha。&lt;/p&gt;

&lt;p&gt;具体处理格式为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    SetTexture [_MainTex] { combine previous * texture, previous + texture }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 previous * texture 为颜色处理部分，previous + texture 为alpha处理部分。&lt;/p&gt;

&lt;h6&gt;Fixed function 所有功能的完整示例&lt;/h6&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shader&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;VertexLit&amp;quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Properties&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_Color&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Main Color&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_SpecColor&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Spec Color&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_Emission&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Emmisive Color&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_Shininess&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Shininess&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Range&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0.01&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.7&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Base (RGB)&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;white&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_ConstantColor&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Main Color&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SubShader&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Material&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Diffuse&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Ambient&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Shininess&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Shininess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Specular&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_SpecColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Emission&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Emission&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Lighting&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;On&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;SeparateSpecular&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;On&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;SetTexture&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;constantColor&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_ConstantColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Combine&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texture&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;primary&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DOUBLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texture&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;primary&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;SetTexture&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;ConstantColor&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;combine&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;constant&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lerp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;texture&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;previous&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;SetTexture&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;combine&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;previous&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texture&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))
    { //移动端
        /*mobile-20:5*/
        var cpro_id = &quot;u3493987&quot;;
        document.write(&quot;\&lt;script type=\&quot;text\/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/cm.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
    else
    {
         /*700*200信息流*/
        var cpro_id = &quot;u3469788&quot;;
        document.write(&quot;\&lt;script type=\&quot;text/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/c.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
&lt;/script&gt;

&lt;h6&gt;Alpha Test 透明裁切&lt;/h6&gt;

&lt;p&gt;Alpha Test 是像素即将要输出到屏幕前的最后一步处理，它通过比较像素的alpha值来决定是否展示。&lt;/p&gt;

&lt;p&gt;格式如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    AlphaTest Off | On

    AlphaTest 操作符号 AlphaValue
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中AlphaValue可以是0-1之间的任何浮点数，也可以是给定的变量。&lt;/p&gt;

&lt;p&gt;操作符号可以为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Greater 只有alpha值 大于 给出的AlphaValue的像素才会被渲染。

    GEqual  只有alpha值 大于等于 给出的AlphaValue的像素才会被渲染。

    Less    只有alpha值 小于 给出的AlphaValue的像素才会被渲染。

    LEqual  只有alpha值 小于等于 给出的AlphaValue的像素才会被渲染。

    Equal   只有alpha值 等于 给出的AlphaValue的像素才会被渲染。

    NotEqual    只有alpha值 不等于 给出的AlphaValue的像素才会被渲染。

    Always  渲染所有像素，相当于AlphaTest Off，关闭了AlphaTest的功能。

    Never   不渲染任何像素。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;AlphaTest 根据Alpha值进行像素的裁切，而不是走alpha混合的路，所以没有深度数据问题，在渲染时不会造成前后渲染排序错乱问题。&lt;/h6&gt;

&lt;p&gt;在使用AlphaTest 制作树和枝叶时，由于AlphaTest裁切过于生硬导致画面上有锯齿感，我们可以采用AlphaTest和Alpha Blend混合使用的方式让画面更加平滑。如下代码：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shader&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;Vegetation&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Properties&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_Color&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Main Color&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(.&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Base (RGB) Alpha (A)&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;white&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_Cutoff&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Base Alpha cutoff&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Range&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,.&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SubShader&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Set up basic lighting&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Material&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Diffuse&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Ambient&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Lighting&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;On&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Render both front and back facing polygons.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Cull&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Off&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// first pass:&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// render any pixels that are more than [_Cutoff] opaque&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;AlphaTest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Greater&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Cutoff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;SetTexture&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;combine&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texture&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;primary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texture&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Second pass:&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// render in the semitransparent details.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// Dont write to the depth buffer&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ZWrite&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;off&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// Don&amp;#39;t write pixels we have already written.&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ZTest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Less&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// Only render pixels less or equal to the value&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;AlphaTest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LEqual&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Cutoff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// Set up alpha blending&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Blend&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SrcAlpha&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OneMinusSrcAlpha&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;SetTexture&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;combine&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texture&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;primary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texture&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;上述代码中两个Pass来渲染树和枝叶，第一Pass对Alpha进行硬裁切，第二个Pass将前面其余没有被裁切的部分进行Alpha混合，这样就能让画面更加平滑，虽然alpha混合会导致渲染排序问题，但主要枝干能够正常排序，剩下的边缘部分只起到平滑作用，牺牲一点排序错位让画面更加柔和。&lt;/p&gt;

&lt;h6&gt;Fog 迷雾颜色&lt;/h6&gt;

&lt;p&gt;Fog 命令可以设置雾颜色，根据与摄像机的不同距离，可以叠加不同的颜色。&lt;/p&gt;

&lt;p&gt;格式如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Fog {Fog Commands}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Fog Commands 有：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Mode Off | Global | Linear | Exp | Exp2

    Mode 可以设置计算公式，Off为关闭，Global为全局，Linear为线性插值计算颜色，Exp为指数公式计算颜色，Exp2为以2 为底的指数公式计算。

    Color ColorValue

    Color 用来设置迷雾颜色。

    Density FloatValue

    Density 用来设置迷雾密度。

    Range FloatValue, FloatValue

    Range 用来设置迷雾的显示范围。近圈距离，外圈距离，他们之间的用线性的方式展示迷雾。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;Fog命令不会与 Vertex Fragment program 和 Surface program 冲突，它是独立于他们之外的功能。&lt;/h6&gt;

&lt;h6&gt;在没有设置Fog的默认情况下，Fog会根据 Lighting Window(Window &amp;gt; Lighting &amp;gt; Settings) 里的设置进行渲染。&lt;/h6&gt;
</description>
               <pubDate>Tue, 14 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/14/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader7.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/14/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader7.html</guid>
            </item>
        
            <item>
               <title>白领投资探讨(四)</title>
               <description>&lt;h1&gt;白领投资探讨(四)&lt;/h1&gt;

&lt;p&gt;流动性探讨&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;从交易流动性谈起，在股票和期货市场上做交易，交易量就是流动性，如果没有流动性，就相当于买卖的人少，从而导致少数人决定大多数人价格的情况。&lt;/p&gt;

&lt;p&gt;打个比方一个市值100亿的企业股票，每天的交易量为100万，今天涨5%，那么就是说，这100万导致了100亿的资金躺着赚了5个亿。一个区区100万，却能影响100亿的资金，是不是很不正常。流动性缺失导致的，因为没人交易所以才会使得100万影响100亿。今天会因为这100万的交易涨5%，明天也会因为这100万的交易量而跌10%，甚至20%，这种可能性很大。&lt;/p&gt;

&lt;p&gt;流动性可以比喻为人流，交易的标的可以比作为一座城市，一座城市如果没有人流那就是个空城，如果有人在一座人烟稀少的城市做生意会如何，一个面包卖1块钱也会可能没人要。即使因为空城导致的供给短缺价格上涨，有人卖100块一个面包，那又怎样，每个月就那么1-2个人来买你这个100块的面包，你永远赚不到大钱，而且随时有亏本的风险，因为这1-2个人随时可能离开，你随时会因为没人来买而亏本破产。在这种城市里做生意是十分危险的，即便你垄断了货物，也有可能破产亏本，因为趋势是空城越来越空，人越来越少，交易越来越少。&lt;/p&gt;

&lt;p&gt;因此流动性差得地方价格特别容易有特别大的起伏，今年1块钱一个，明年100块钱一个，但买卖交易的人永远都只会是那么一两个。大的资金是绝对不会去那种地方的，因为即使在1块钱买进仓库的面包，在价格涨到100块的时候卖出，也卖不了几个，没人来接盘，大量的面包堆积在仓库卖不出去。&lt;/p&gt;

&lt;h3&gt;聪明的富人远离流动性差的投资产品是有道理的，他们知道倘若没人做他们的对手盘，没人愿意接盘怎么做都是死永远赚不到钱，而且随时有把所有钱都亏完的风险，他们何必要冒这么大的风险做这种愚蠢的事。只有没有钱的穷人，眼里只看到价格的穷人，才会冲进去交易厮杀，最终的结果是没人能赢，因为交易本身就是个负和游戏，买卖双方在交易完成时就要交一笔费用，交易税。&lt;/h3&gt;

&lt;p&gt;那么流动性大，到底有什么好处呢？&lt;/p&gt;

&lt;h3&gt;1，当参与者众多的时候，能平摊风险。要明白，交易是人创造出来，人的思维具有多样，有人看多就有人空，否则，怎么会有成交，就因为有人卖有人买才能成交。卖的人看空，买的人看多，人越多，多样性越复杂，随时随地有看空的转为看多，看多的转为看空，多空一直在随着时间的推移不断得变化，人越多这种多样性就越多，变化也就越复杂。&lt;/h3&gt;

&lt;p&gt;所以我们说股价是不可控的，无论你精通多少数学方法，AI计算，宏观经济，企业财报都无法知道股价的走势。这不仅仅是在流动性大的地方不可控，在流动性少的地方也一样不可控，因为交易本身就是由人创造出来的，人这种生物本身就是不可控的，虽然我们因为这种不可控导致获得了很多好处，比如发明新的理论，发现新的大陆等。&lt;/p&gt;

&lt;p&gt;那么越多的多样性怎么就能平摊风险了呢？就因为多样性才能平摊风险，不至于预期一致性，比如一致看空无人看多的情况，一个几百亿市值的公司，一夜市值归零，就是一致看空导致的结果，所有人都不看好，没人看好的结果就是踩踏，挤兑，巨幅下跌。&lt;/p&gt;

&lt;p&gt;但是如果有足够多的多样性会如何？即使再大的坏消息，依然有人看多，那些人认为坏消息固然不好，但是跌的太过，完全超出了坏消息的影响幅度，或者有人认为利空消息是有人恶意编造，或者有人认为利空消息有可能会转折，甚至会有人认为利空消息并不一定是坏消息也有利于管理层认清现实在今后的工作中更加有效对待现有的漏洞。&lt;/p&gt;

&lt;p&gt;这些多样性导致大量的买入操作，从而让更多人相信跌的太多，或者有希望将利空消息转为利好消息，从而随着时间的推移，看空转看好的人越来越多，致使不至于导致非常糟糕的一致性预期，踩踏，挤兑等。&lt;/p&gt;

&lt;p&gt;这就是流动性的好处，让更多的多样性来平摊风险，而不至于让预期一致性发生而导致一瞬间破产。&lt;/p&gt;

&lt;h3&gt;2，吸引更多资金参与，有更多接盘可能的选择。流动性好的地方，因为交易的频繁，导致交易量大，比如1天几十亿资金的交易量，待在里面的1个亿体量的基金会很放心，随时都可以在几天之内把自己手上的股票抛完，也可以在几天之内买进几亿的股票而不让股票大幅上升而增加自己的持仓成本。&lt;/h3&gt;

&lt;p&gt;所以更多的资金愿意参与进来，因为大家知道，自己随时都能套现走人，而不用顾忌被埋，他们更多的专注是企业的内在，企业的核心资产，核心技术，技术壁垒，管理层人员，行业供给等。&lt;/p&gt;

&lt;p&gt;当资金认为这个企业有美好未来时候，它可以毫不犹豫的买入而不影响股价上涨带来的持仓成本抬高，相反，当他们认为美好未来不再，可以随时卖出而不影响股价下跌导致成交价下跌，因为接盘的人随时都有。&lt;/p&gt;

&lt;p&gt;流动性大导致，资金持有人可以不用考虑自己想卖的时候没人要。作为一个投资持有者，无论是你持有股票，还是期货，还是房产，都是一样的，最怕的不是卖的价格太低，而是卖不出去，没人愿意接盘，再低的价格都没人要的情况，因为那时候就相当于你手里持有的是一张废纸。&lt;/p&gt;

&lt;h3&gt;简单的来说，流动性差的地方更容易破产，一瞬间破产的概率较大，流动性大的地方虽然不能保证价格上升但可以保证不会一夜破产，并且会因为多样性多而得到有更多机会。&lt;/h3&gt;
</description>
               <pubDate>Mon, 13 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/13/%E7%99%BD%E9%A2%86%E6%8A%95%E8%B5%84%E6%8E%A2%E8%AE%A84.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/13/%E7%99%BD%E9%A2%86%E6%8A%95%E8%B5%84%E6%8E%A2%E8%AE%A84.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，Shader(六) - Pass(三)Blend</title>
               <description>&lt;h3&gt;Blend，设置颜色混合的方式。&lt;/h3&gt;

&lt;p&gt;Blend 主要作用是颜色混合，颜色混合是在所有渲染完成图像都成型后进行的，这时像素都已经被绘制好了，并且屏幕上也已经有成像的图形，但还没有完全完成，因为是物体各自画各自的已经画完了放入了缓存中，但alpha还没有发挥出效果，这时就需要混合来做补充，这之前的屏幕上所有的图像都是实体的，没有半透明和透明部分。总之Blend最重要的作用就是让alpha起到半透明的作用，当然也可以做到颜色加强，改变，混合，削弱等作用。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader34.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    图1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader34.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    图2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图1为没启用Blend的效果，没有发挥alpha的半透明和透明的作用。&lt;/p&gt;

&lt;p&gt;图2为启用了Blend的效果，贴图上的alpha发挥了应该有的透明效果。&lt;/p&gt;

&lt;p&gt;Blend在Shader上的格式，图1只是注释掉了Blend那一行，图2没有注释任何代码:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shader&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;Test/Blend&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Properties&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Base (RGB) Trans (A)&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;white&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SubShader&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Blend&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SrcAlpha&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OneMinusSrcAlpha&lt;/span&gt; 

            &lt;span class=&quot;n&quot;&gt;SetTexture&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;Combine&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Primary&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Texture&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;上述例子将Alpha混合进颜色中。&lt;/p&gt;

&lt;p&gt;下面我们来看看Blend的使用方法以及它的参数配置。&lt;/p&gt;

&lt;h6&gt;1，Blend Off，关闭混合，默认是关闭颜色混合的。&lt;/h6&gt;

&lt;h6&gt;2，Blend SrcFactor DstFactor。&lt;/h6&gt;

&lt;p&gt;当前物体产生的图像上的颜色与ScrFactor(Source Factor)参数相乘，屏幕上的已经存在的颜色与DstFactor(Destination Factor)参数相乘，两者的结果相加的结果放入帧缓存。&lt;/p&gt;

&lt;p&gt;这里的ScrFactor(Source Factor)和DstFactor(Destination Factor)是固定的系数，ScrFactor中的Source 意味着本物体，代表本物体颜色相关，Destination意味着Blend前已经在屏幕上绘制的颜色相关。&lt;/p&gt;

&lt;p&gt;这些系数说明如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;One，表示完整的颜色，不加修改，无论是本物体的颜色还是屏幕上的颜色。

Zero，表示数据零，本物体和屏幕上的颜色都不要。

SrcColor，表示本物体的颜色。

SrcAlpha，表示本物体的Alpha。

DstColor，表示屏幕上的颜色。

DstAlpha，表示屏幕上的Alpha。

OneMinusSrcColor,表示1-Source Color，即反转本物体上的Color。

OneMinusSrcAlpha,表示1-Source Alpha，即反转本物体上的Alpha。

OneMinusDstColor,表示1-Destination Color，即反转屏幕上的Color。

OneMinusDstAlpha,表示1-Destination Alpha，即反转屏幕上的Alpha。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假设：颜色信息的四个分量（红Red，绿Green，蓝Blue，透明度Alpha）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    （1）“源颜色”  ：（Rs, Gs, Bs, As）

    （2）“目标颜色”：（Rd, Gd, Bd, Ad）

    （3）“源因子”  ：（Sr, Sg, Sb, Sa）

    （4）“目标因子”：（Dr, Dg, Db, Da）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么混合产生的新颜色可以表示为：（Rs&lt;em&gt;Sr + Rd&lt;/em&gt;Dr , Gs&lt;em&gt;Sg + Gd&lt;/em&gt;Dg , Bs&lt;em&gt;Sb + Bd&lt;/em&gt;Db , As&lt;em&gt;Sa + Ad&lt;/em&gt;Da）&lt;/p&gt;

&lt;p&gt;如果颜色的某一分量超过了1.0，则它会被自动截取为1.0，不需要考虑越界的问题。&lt;/p&gt;

&lt;p&gt;混合说的通俗点就是把某一像素位置上原来的颜色和将要画上去的颜色，通过某种公式计算得出另一种颜色，从而实现特殊的效果。&lt;/p&gt;

&lt;p&gt;源图片颜色被称作“源颜色”，而屏幕上已存在的图片颜色则被称作“目标颜色”。&lt;/p&gt;

&lt;h6&gt;3，BlendOp Op，此命令可以改变两个颜色结果相加的操作。&lt;/h6&gt;

&lt;p&gt;颜色混合的最后一步是相加，通过这个命令可以改变最后一步的符号，比如相减，取最小值，取最大值等。&lt;/p&gt;

&lt;p&gt;具体可用的操作符如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;Add，相加，默认的操作符号。

Sub，相减，目标结果 – 源结果。

RevSub，相减，源结果 – 目标结果。

Min，取最小值，目标结果和源结果中取最小值。

Max，取最大值，目标结果和源结果中取最大值。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有一些只能在特定显卡下使用的操作符，比如LogicalClear，LogicalSet等等只能在DX11.1及以上的版本中使用。&lt;/p&gt;

&lt;h6&gt;4，BlendOp OpColor,  OpAlpha，此命令与上面一样也是改变操作符号的，但此命令可以把颜色和Alpha的操作符号分开来改变。&lt;/h6&gt;

&lt;p&gt;OpColor参数代表目标结果和源结果的颜色操作符号，OpAlpha参数代表目标结果和源结果的Alpha操作符号。&lt;/p&gt;

&lt;p&gt;可用的参数与BlendOp Op一样，只是拆分了Color和Alpha。&lt;/p&gt;

&lt;h6&gt;5，当使用Multiple render target(MRT)多管线目标渲染时，还可以针对不同的管线目标进行操作，但仅限于固定级别显卡以上的设备，比如DX11/12, GLCore, Metal, PS4等。&lt;/h6&gt;

&lt;p&gt;下面是可操作的命令格式，N为目标管线索引(0-7)：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Blend N SrcFactor DstFactor

    Blend N SrcFactor DstFactor, SrcFactorA DstFactorA

    BlendOp N Op

    BlendOp N OpColor, OpAlpha
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;6，AlphaToMask On/Off，此命令为开关Alpha To Coverage(A2C)。&lt;/h6&gt;

&lt;p&gt;Alpha To Coverage(A2C)是一种经由流水线完成的“Alpha Test”。&lt;/p&gt;

&lt;p&gt;在使用了多重采样(Multi-sample)的场合下，经由检测当前需要绘制的fragment的alpha值来决定该fragment在对应像素上的sample覆盖率。&lt;/p&gt;

&lt;p&gt;启用AlphaToMask的条件是必须在multisample anti-aliasing(MSAA，在QualitySetting中设置)开启的情况下才有效。&lt;/p&gt;

&lt;p&gt;Alpha To Coverage(A2C)是对Alpha Test和Alpha Blend的两种透明绘制方法的折中改进方法。&lt;/p&gt;

&lt;p&gt;Alpha Test过于粗糙，“非0即1”的强硬手段导致边缘有强烈的锯齿感，这种阈值控制的剔除法在渲染上始终有很多不足。&lt;/p&gt;

&lt;p&gt;Alpha Blend(文中的Blend命令)则可以根据物体本身的纹理上的颜色和透明度柔和的将Alpha混合显示在屏幕上并没有锯齿感，但这种机制不是对每个物件并行处理的，对当前DrawCall产生作用时必然会考虑的是当前“画板上已经画了些什么”即所谓的“已经绘制在屏幕上的图像，即目标结果”。这样最后的结果就与深度信息无关了，混合的结果跟绘制的顺序有关(前文中Queue标签的绘制顺序)。&lt;/p&gt;

&lt;p&gt;所以说对于Alpha Blend，必须让绘制满足从后往前的顺序执行，而无法做场景中深度的排序。&lt;/p&gt;

&lt;p&gt;Alpha To Coverage(A2C)中和了Alpha Test和Alpha Blend的方法，让半透明既不那么粗糙，也有深度数据来判断前后的关系。&lt;/p&gt;

&lt;h3&gt;在介绍常用的Blend混合方法之前，我想有必要介绍下颜色的操作符，即颜色的乘法，加法，减法，最小值，最大值的表现结果。&lt;/h3&gt;

&lt;h6&gt;1，颜色乘法，可以视为颜色（或者说图像）的叠加。&lt;/h6&gt;

&lt;p&gt;为什么乘法颜色节点能够让颜色叠加。&lt;/p&gt;

&lt;p&gt;我们把两个RGBA值转换成为0-1之间的范围就可以明白了。&lt;/p&gt;

&lt;p&gt;比如白色（1,1,1,1），灰色（0.5,0.5,0.5,1），两个颜色相乘得到（0.5,0.5,0.5,1） 还是灰色，也就是说在白色的底板上，画上灰色的颜色，颜色就叠加了，这就是颜色的叠加方法。&lt;/p&gt;

&lt;p&gt;颜色相乘的公式是 Color a, Color b, a*b = new Color(a.r * b.r, a.g * b.g, a.b * b.b, a.a * b.a); 从此公式可以看出，因为所有数字都小于等于1，所以相乘只会让颜色更加深，也就是更加接近黑色，不断的叠加各种各样的颜色，最后都会无限接近黑色(0,0,0,1)或者无限接近黑色透明(0,0,0,0)。&lt;/p&gt;

&lt;h6&gt;2，颜色加法，可以视为颜色（或者说图像）加白(或者说亮)。&lt;/h6&gt;

&lt;p&gt;为什么说加法可以视为颜色的加白操作。因为颜色相加后，不能超过最大值1（或者另一种表达方式的数字255）,超过部分都会被截断。&lt;/p&gt;

&lt;p&gt;加法的公式是：Color a, Color b, a+b = new Color(a.r + b.r, a.g + b.g, a.b + b.b, a.a + b.a); 从此公式可以看出，所有的数字都小于等于1，所以r，g，b，a，随着不断加各种颜色，最终会到达最大值1。也就是不透明白色(1,1,1,1)。&lt;/p&gt;

&lt;p&gt;所以颜色无论加什么颜色都会更加接近白色，也就得到我们的结论，颜色加法可以视为颜色（或者说图像）加白(或者说亮)。&lt;/p&gt;

&lt;h6&gt;3，颜色减法，可以视为颜色(或者说图像)的色差。&lt;/h6&gt;

&lt;p&gt;如果两个一样的颜色比如红色，相减，就变成了(0,0,0)黑色，而两个相差比较大的颜色相减，结果就会无限接近白色(1,1,1)。&lt;/p&gt;

&lt;p&gt;颜色的相减公式为：Color a, Color b, a-b = new Color(a.r - b.r, a.g - b.g, a.b - b.b, a.a - b.a); 相减的结果大于等于0小于等于1，一直做减法操作的话，就会无限接近黑色(0,0,0)或者透明黑色即无色(0,0,0,0)。&lt;/p&gt;

&lt;p&gt;因此我们可以认为，颜色相减，可以视为颜色（或者说图像）的色差。&lt;/p&gt;

&lt;h6&gt;4，颜色最大值，可以视为颜色（或者说图像）的最白(或者说亮)状态。&lt;/h6&gt;

&lt;p&gt;因为RGB的所有颜色都做了最大值操作，无论哪个颜色都会更加接近白色(1,1,1)，所以两个颜色或者图像做最大值操作就是取其最白(或者说亮)的状态。&lt;/p&gt;

&lt;h6&gt;5，颜色最小值，可以视为颜色（或者说图像）的最暗状态。&lt;/h6&gt;

&lt;p&gt;与最大值相同因为RGB的所有颜色都做了最小值操作，无论哪个颜色都会更加接近黑色(0,0,0)，所以两个颜色或者图像做最小值操作就是取其最暗(黑)的状态。&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))
    { //移动端
        /*mobile-20:5*/
        var cpro_id = &quot;u3493987&quot;;
        document.write(&quot;\&lt;script type=\&quot;text\/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/cm.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
    else
    {
         /*700*200信息流*/
        var cpro_id = &quot;u3469788&quot;;
        document.write(&quot;\&lt;script type=\&quot;text/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/c.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
&lt;/script&gt;

&lt;h3&gt;有了这些颜色操作的常识我们就可以更加深入的了解Blend混合方法了。&lt;/h3&gt;

&lt;h3&gt;常用的Blen混合方法：&lt;/h3&gt;

&lt;h6&gt;1， 透明度混合Blend SrcAlpha OneMinusSrcAlpha，即常用半透明物体的混合方式。&lt;/h6&gt;

&lt;p&gt;这时最常用的半透明混合了，首先要保证半透明绘制的顺序比实体的要后面，所以Queue标签是必要的Tags {&amp;quot;Queue&amp;quot; = &amp;quot;Transparent&amp;quot;}。Queue标签告诉着色器此物体是透半透明物体排序。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader36.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;Blend SrcAlpha OneMinusSrcAlpha 我们来解释下，以上图为例，图中油桶是带此Shader的混合目标。&lt;/p&gt;

&lt;p&gt;当绘制油桶时，后面的实体BOX已经绘制好并且放入屏幕里了，所以ScrAlpha与油桶渲染完的图像相乘，部分区域Alpha为0即相乘后为无(颜色)，这时正好另一部分由OneMinusSrcAlpha(也就是1-ScrAlpha)为1即相乘后原色不变，两个颜色相加后就相当于油桶的透明部分叠加后面实体Box的画面，于是就形成了上面的这幅画面。&lt;/p&gt;

&lt;p&gt;反过来也是一样，当ScrAlpha为1时，源图像为不透明状态，则两个颜色在相加前最终变成了，源图像颜色+无颜色=源图像颜色，于是就有了上图中油桶覆盖实体Box的图像部分。&lt;/p&gt;

&lt;h6&gt;2，加白加亮叠加混合 Blend One One，即在原有的颜色上叠加屏幕颜色更加白或亮。&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader37.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;第一参数One代表本物体的颜色。第二个参数代表屏幕上的颜色。两种颜色相加则，导致形成的图像更加亮白。这样我们就看到了一个图像加亮加白的图像了。&lt;/p&gt;

&lt;h6&gt;3，保留原图色彩Blend One Zero，即只显示自身的图像色彩不加任何其他效果。&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader38.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;本物体颜色，加上，零，就是本物体颜色。这是最简单的混合了。&lt;/p&gt;

&lt;h6&gt;4，自我叠加（加深）混合Blend SrcColor Zero，即源图像与源图像自我叠加。&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader39.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;与上面相比，加深了本物体的颜色。第一个参数本物体的颜色与本物体的颜色相乘，加深了颜色，第二个参数为零，使得屏幕颜色不被使用。所以形成的图像为颜色加色的图像。&lt;/p&gt;

&lt;h6&gt;5，目标源叠加（正片叠底）混合Blend DstColor  SrcColor，即把目标图像和源图像叠加显示。&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader40.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;第一个参数，本物体颜色与屏幕颜色相乘，颜色叠加。第二个参数，屏幕颜色与本问题颜色相乘，颜色叠加。两种颜色相加，加亮加白。这个混合效果就如同两张图像颜色叠加后的效果。&lt;/p&gt;

&lt;h6&gt;6，软叠加混合Blend DstColor  Zero，即把目标源图像叠加到前面来。&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader41.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;与前面的叠加混合效果相似，这个只做一次叠加，并不做颜色相加操作，使得图像看起来在叠加部分并没有那么亮白的突出。因为第二个参数为零，表示后面的屏幕颜色与零相乘即为零。&lt;/p&gt;

&lt;h6&gt;7，差值混合BlendOp Sub，Blend One One，即注重黑白通道的差值。&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader42.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;在这个混合中使用了混合操作改变，从默认的加法改成了减法，使得两个颜色从加法变为了减法，不再是变白变亮的操作，而是反其道成为了色差的操作。&lt;/p&gt;

&lt;h3&gt;ColorMask，设置颜色遮罩过滤。&lt;/h3&gt;

&lt;p&gt;ColorMask可以进行颜色的遮罩功能，这相当于在渲染时把某种颜色剔除一样。&lt;/p&gt;

&lt;p&gt;ColorMask可供选择参数 ColorMask RGB | A | 0 | R,G,B,A的任意组合。&lt;/p&gt;

&lt;p&gt;当ColorMask 0 时将关闭所有的颜色通道，相当于没有颜色渲染就没有成型的图像了，实际上你是看不见它的，只是在Editor下可以点选出来看到轮廓。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader43.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;当ColorMask R|G|B|A时我们来看看效果，第一张是RGBA参数时的图，即为全通道颜色渲染的模型图。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader44.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader45.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader46.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader47.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader48.png&quot; alt=&quot;blend&quot;&gt;&lt;/p&gt;

&lt;p&gt;第2张是只开放R(红色)通道其他通道被拒绝，第3张是只开放G(绿色)通道，第4张是只开放B(蓝色)通道，第5张是只开放A (alpha通道)。&lt;/p&gt;

&lt;p&gt;从上图的例子中可以充分的明白了，ColorMask对颜色通道的操作。&lt;/p&gt;

&lt;p&gt;ColorMasks虽然也可以在Multiple render target(MRT)下做一些额外的操作，比如ColorMask RGB 3 后面数字3对RGB通道中进行数字3的遮罩功能，但MRT需要显卡的支持，比如PC显卡中大多数在2006年后支持MRT从GeForce 8XXX，Radeon X2400，Intel G45开始。&lt;/p&gt;

&lt;p&gt;在手机上能支持MRT并不多，而且对MRT的功能也限制了很多，基本可以说在手机平台上无法使用。&lt;/p&gt;
</description>
               <pubDate>Wed, 08 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/08/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader6.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/08/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader6.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，Shader(五) - Pass(二)</title>
               <description>&lt;h3&gt;Render State Command渲染状态指令详解&lt;/h3&gt;

&lt;p&gt;Render State Command 是渲染状态的指令，它在Pass和SubShader都有效，放在Pass就只在当前Pass里有效，放在SubShader中则是多个Pass的共同状态。&lt;/p&gt;

&lt;p&gt;不过不是所有的Render State都可以成为共同拥有的渲染状态的，有些Render State只在Pass中有效，而另一些则可以成为共同渲染状态。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;下面我们来介绍下Pass中的渲染状态Command指令：&lt;/p&gt;

&lt;h3&gt;Cull，前后裁切指令。&lt;/h3&gt;

&lt;p&gt;Cull是种优化的指令，可以让远离屏幕的部分不渲染。所有的物体都有前后两面，比如一个Box箱子你永远都看 不到屏幕另一侧的部分，所以可以对Box箱子后半部分进行裁切不渲染。&lt;/p&gt;

&lt;p&gt;可设置参数如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader20.png&quot; alt=&quot;cull&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    上图为参数 Cull Back，裁切白色Box的后半部分，保留前半部分。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader21.png&quot; alt=&quot;cull&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    上图为参数 Cull Front，裁切白色Box的前半部分，保留后半部分，展示的后半部部分与后面的箱子相交。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader22.png&quot; alt=&quot;cull&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    参数 Cull Off，关闭裁切功能，与Cull Back展示的效果一样，但其实多渲染了后半部分的网格模型。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Cull默认是裁切后半部分的，这样可以达到优化的效果，如果你没有对它进行设置的话。其实裁切后半部分和完全不裁切，在有深度缓存数据时是显示的效果是完全一样的，只是一个做了优化另一个没做而已。&lt;/p&gt;

&lt;h3&gt;ZTest，设置深度缓存测试模式。&lt;/h3&gt;

&lt;p&gt;ZTest的功能是在两个物体相交时渲染绘制中对前后深度进行测试，默认情况下以LEqual小于等于其他物体时测试为不通过，当不通过时就不渲染那部分模型。&lt;/p&gt;

&lt;p&gt;LEqual参数，其实就是测试前面的物体是否挡住了该物体部分，如果挡住了就不渲染的意思，它也是ZTest的默认参数。&lt;/p&gt;

&lt;p&gt;其他参数还包括&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;ZTest Less | Greater | LEqual | GEqual | Equal | NotEqual | Always

参数 小于 | 大于 | 小于 | 小于等于 | 大于等于 | 等于 | 不等于 | 关闭测试
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数解释：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader23.png&quot; alt=&quot;ztest&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;上图中为参数 Less 该物体上的部分深度在其他物体后面时不渲染。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader24.png&quot; alt=&quot;ztest&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;上图中为参数 Greater 该物体上的部分深度在其他物体部分前面时不渲染，也就是被覆盖的显示，没被覆盖的反而不显示。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader25.png&quot; alt=&quot;ztest&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;上图中为参数 Equal 该物体上的部分深度与其他一致时才渲染，否则不渲染。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader26.png&quot; alt=&quot;ztest&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;上图中为参数 NotEqual 该物体上的部分深度与其他物体不一致时才渲染，否则不渲染。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;ZWrite，设置深度缓存写入开关。&lt;/h3&gt;

&lt;p&gt;Zwrite可以控制物体渲染的像素是否写入depth buffer深度缓存数据中。&lt;/p&gt;

&lt;p&gt;如果没有depth buffer深度缓存数据，物体将无法辨识前后关系也就无法实现阻挡物体不绘制的功能。&lt;/p&gt;

&lt;p&gt;这在大多数不透明物体中都是需要depth buffer深度缓存数据来识别前后遮挡的，但在半透明和透明物体中就不需要depth buffer。&lt;/p&gt;

&lt;p&gt;半透明和透明物体没有depth buffer深度缓存数据，所以没有所谓的写入一说，也就是通常在半透明和透明物体的Shader中，ZWrite是关闭的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader27.png&quot; alt=&quot;zwrite&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader28.png&quot; alt=&quot;zwrite&quot;&gt;&lt;/p&gt;

&lt;p&gt;如上两个图，图1为ZWrite On时的效果，黄色Box遮挡住了后面的蓝色Box因为有depth buffer深度缓存的写入，前后关系有依据。&lt;/p&gt;

&lt;p&gt;图2为ZWrite Off的效果，后面蓝色的Box被提到了黄色Box的前面显示，这是因为黄色Box的depth buffer没有写入，在渲染时，面片前后关系没有了依据，导致了错乱。&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))
    { //移动端
        /*mobile-20:5*/
        var cpro_id = &quot;u3493987&quot;;
        document.write(&quot;\&lt;script type=\&quot;text\/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/cm.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
    else
    {
         /*700*200信息流*/
        var cpro_id = &quot;u3469788&quot;;
        document.write(&quot;\&lt;script type=\&quot;text/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/c.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
&lt;/script&gt;

&lt;h3&gt;Offset，设置深度缓存的偏移。&lt;/h3&gt;

&lt;p&gt;Offset允许你设置物体在深度缓冲中的偏移量，这相当于让物体在屏幕显示中提前或者推后显示位置，但实际世界中的位置不变。&lt;/p&gt;

&lt;p&gt;Offset有两个参数，Factor偏移缩放大小和Units偏移量。Factor相当于缓存数据偏移放大的倍数，Units相当于直接偏移的量。&lt;/p&gt;

&lt;p&gt;如果从公式上理解，可以理解为Buffer = (x or y)*Factor + Units。&lt;/p&gt;

&lt;p&gt;举例 Offset 3 , 5，可以理解为偏移放大3倍，并且再偏移5个单位。&lt;/p&gt;

&lt;p&gt;注意，偏移负方向才是离屏幕越近的方向。所以Offset 0 , -1时，两个物体重合部分肯定是拥有Offset 0 , -1的提前显示。&lt;/p&gt;

&lt;p&gt;如果两个物体前后差的比较远，那么想把后面的物体提到前面来显示，那么就要加大偏移量了，比如 Offset 0 , - 1000 或者 Offset -100, -1等。&lt;/p&gt;

&lt;p&gt;下面举例说明Offset的作用：&lt;/p&gt;

&lt;p&gt;对白色的做处理Offset 0 , 0 -------两者重叠，时而显示普通的有贴图的立方体，时而显示白色的立方体，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader29.png&quot; alt=&quot;offset&quot;&gt;&lt;/p&gt;

&lt;p&gt;对白色的做处理Offset 0 , -1------两者重叠部分完全被白色覆盖,因为白色立方体做了偏移量的处理，深度缓存中的坐标离屏幕更近，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader30.png&quot; alt=&quot;offset&quot;&gt;&lt;/p&gt;

&lt;p&gt;对白色的做处理Offset 0 , 0 ---- 现在把两个立方体的距离拉开，正常情况下按透视的距离进行显示，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader31.png&quot; alt=&quot;offset&quot;&gt; &lt;/p&gt;

&lt;p&gt;对白色的做处理Offset 0 , -1000 ---- 现在加重白色立方体的偏移量，深度缓存数据向屏幕偏移，这时很多有贴图的立方体部分被覆盖，因为偏移量加大，提前量就加大了，但绿色立方体其他部分的深度数据还是比偏移后的大，所以那个部分还是无法覆盖，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader32.png&quot; alt=&quot;offset&quot;&gt;&lt;/p&gt;

&lt;p&gt;对白色的做处理Offset -100 , -1000------再次加大偏移量，这次加入了缩放比例的偏移，偏移的更多，使得白色立方体全部覆盖绿色立方体，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader33.png&quot; alt=&quot;offset&quot;&gt;&lt;/p&gt;

&lt;p&gt;注意以上所有图中两个立方体的世界坐标一直都没有更改。如果要让物体向后推也是同样方法，负数变正就可以，所有的偏移都是渲染上的偏移，与物体实际坐标无关。&lt;/p&gt;
</description>
               <pubDate>Wed, 08 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/08/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader5.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/08/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader5.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，Shader(四) - Pass(一)</title>
               <description>&lt;h3&gt;Pass&lt;/h3&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;Pass块的格式，如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;    [Name and Tags]&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;    [Render State]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Pass可以定义自己的名字，和Tag标签，以及渲染状态Render State。&lt;/p&gt;

&lt;p&gt;Pass通过Tag标签来变更渲染引擎里的设置。Pass里的这个Tag和SubShader上的Tag是同一种标签，SubShader起到了共享标签的作用，而Pass里的Tag则是独立的个性化的。&lt;/p&gt;

&lt;h3&gt;Tag标签详解&lt;/h3&gt;

&lt;p&gt;Tag的格式很简单，就同Key-Value一样，每个标签都有一个Key，对应一个Value，Key之间用空格隔开。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { “TagKey1” = “Value1” “TagKey2” = “Value2” }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么究竟有哪些Tag可以供我们使用？&lt;/p&gt;

&lt;p&gt;我们先介绍SubShader和Pass共用的Tag。&lt;/p&gt;

&lt;h6&gt;Queue 标签Tag&lt;/h6&gt;

&lt;p&gt;Queue是渲染顺序的标签。可以用这个标签决定模型在绘制时所用的顺序。&lt;/p&gt;

&lt;p&gt;Shader会在渲染前决定物体属于哪个渲染顺序，从而确保所有透明或半透明物体的绘制顺都排在不透明物体的后面。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    例子，Tags { &amp;quot;Queue&amp;quot; = &amp;quot;Transparent&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下为渲染顺序的定义选择。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Background：这种类型的顺序会排在所有物体的前面。

    Geometry(默认)：大多数物体都使用这种方式。所有不透明物体使用这个类型。

    AlphaTest：使用Alpha Test的物体使用这个类型的渲染顺序。它被排在不透明物体的渲染后面。

    Transparent：排在Geometry和AlphaTest后渲染。所有alpha混合的物体都应该选择这个类型（因为Shader不会入depth buffer）。

    Overlay：这个类型是最后渲染的，比前面所有类型都要置后。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在实际的运用过程中，Render Queue是可以有自己的排序状态的，不同的Shader同一种排序类型可以有不同的前后关系。&lt;/p&gt;

&lt;p&gt;比如在两个物体都使用Geometry类型的渲染顺序，第一个物体使用 Geometry+1 比其他的 Geometry 类型物体更加滞后渲染，第二个物体使用 Geometry+2 写法，比第一个物体还要靠后渲染，目的有可能是需要在其他物体渲染完毕后再对周围环境做出反应。&lt;/p&gt;

&lt;p&gt;这种方式在透明和半透明的物体中特别常用，因为透明和半透明物体没有深度缓存测试，所以他们之间的渲染顺序是混乱的，当两个半透明物体放在前后位置进行渲染时，摄像机看到的是一个比较混乱的排序方式。因此在半透明物体的运用中我们时常人工指定某些物体的排序大小，比如如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { &amp;quot;Queue&amp;quot; = &amp;quot;Transparent+1&amp;quot; }

    Tags { &amp;quot;Queue&amp;quot; = &amp;quot;Transparent+2&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后者比前者在渲染绘制时排在后面，先绘制了+1的半透明物体后，再绘制+2的半透明物体，结果是+2物体会覆盖+1物体而显示得靠前。&lt;/p&gt;

&lt;p&gt;例子中“+1”表达了渲染顺序往后靠一位，+2比+1更往前后，数字越大渲染时越排在后面。&lt;/p&gt;

&lt;p&gt;“Queue”标签在Shader里会提前告诉着色器这个物体的渲染顺序，这样在渲染中就不会因为没有深度缓存数据而导致前后渲染的混乱。&lt;/p&gt;

&lt;p&gt;渲染顺序到2500(“Geometry+500”)是非透明物体和可优化绘制顺序（自动排序）物体最佳的性能位置。&lt;/p&gt;

&lt;p&gt;超过2500是半透明物体和手动排序物体的区间范围。天空盒(Skybox)被排在非透明物体和半透明物体中间。&lt;/p&gt;

&lt;h6&gt;RenderType 标签Tag&lt;/h6&gt;

&lt;p&gt;RenderType 标签是自由识别类标签，他没有自己的标签类型选择，可以为任意字符串。&lt;/p&gt;

&lt;p&gt;RenderType的主要作用是被识别与替代。在Shader替换效果中比较常用，比如场景中有些类型的物体需要在某个时刻替换某种Shader，并且不是真正的替换Shader，而是只针对某个Camera摄像机，其他的Camera摄像机保持原样。这时就需要用到RenderType标签，再用Camera.RenderWithShader或Camera.SetReplacementShader进行替换，因为函数中需要找出某种类型的Shader进而才可以进行替换，所以RenderType就是那个标识记号。&lt;/p&gt;

&lt;p&gt;Camera.RenderWithShader或Camera.SetReplacementShader渲染的规则是，没有RenderType标记的全部替换并渲染，有标记的但跟给定的标记一样的才渲染，否则不渲染。&lt;/p&gt;

&lt;p&gt;Unity内部Shader已经全部标记了RenderType，可以在它的Shader源码内参考。&lt;/p&gt;

&lt;h6&gt;DisableBatching标签&lt;/h6&gt;

&lt;p&gt;DisableBatching可以将该物体上的Draw Call Batching打开或关闭。&lt;/p&gt;

&lt;p&gt;为什么要关闭呢，因为在一些Shader中需要对顶点进行更改达到Mesh变化的目的，而Draw Call Batching会对所有的可合并的模型进行合并后放入场景空间，所以这些对Mesh操作的Shader就不起作用了，需要关闭Draw Call Batching才能重新得到该Shader要的效果。&lt;/p&gt;

&lt;p&gt;DisableBatching有三种类型可以选择。&lt;/p&gt;

&lt;p&gt;第一种是True，标志着Draw Call Batching 功能在这个物体上将被关闭。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { &amp;quot;DisableBatching&amp;quot; = &amp;quot;True&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二种是False，标志着Draw Call Batching 功能在这个物体上不关闭。False是默认值，也就是说如果不去设置它时，Shader模式是不关闭Draw Call Batching的。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { &amp;quot;DisableBatching&amp;quot; = &amp;quot;False&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第三种是LODFading，这个比较特殊，只在LOD fading设置被开启时关闭这个物体上的Draw Call Batching功能。一般常用在树上，会动且有LOD功能。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { &amp;quot;DisableBatching&amp;quot; = &amp;quot;LODFading&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;这里简单介绍下Draw Call Batching功能，后面章节中会有详细的介绍。&lt;/h6&gt;

&lt;p&gt;每个物体都有一个材质球，每个材质球都有一个Shader，每个Shader都起码有 一个Pass渲染管线，每个物体在渲染时，引擎会抓取模型的顶点，网格，颜色，贴图，UV，法线等数据进行一次渲染操作。&lt;/p&gt;

&lt;p&gt;那么如果每个物体都单独走一次渲染管线，几百几千甚至几万个物体一起渲染时，就会因为渲染引擎工作量过大CPU和GPU负荷过高而导致画面渲染次数减少，也就是帧数下降，因为每一帧一个画面。帧数下降导致画面有卡顿感，不流畅。所以要使用Batching批处理进行优化，于是就有了Draw Call Batching。&lt;/p&gt;

&lt;p&gt;它是怎么优化的呢？把所拥有有相同材质球的模型放在一起走一次渲染管线，不同的材质球对应的模型不能进行Draw Call Batching。&lt;/p&gt;

&lt;p&gt;这样大大加强了处理速度，原来一个一次的处理方式，变成了一批一次，达到了优化的目的，绘制画面的次数上去了，每秒的帧数（FPS）也上就去了。&lt;/p&gt;

&lt;p&gt;Draw Call Batching分两种，一种是动态的，一种是静态的。&lt;/p&gt;

&lt;p&gt;要进行动态的Batching批处理要求有点高，比如它要求模型必须少于900个顶点甚至更少，又比如它要求Batching批处理对象的Scale大小是一模一样的否则不予处理，再比如必须使用同一种材质球而且是同一个实例，不同材质球或者同一材质球而不同实例也不行，还有如果有烘培的模型，它的烘培图必须是同一张，甚至Shader中不能使用多个Pass等等苛刻的条件。所以想要做动态批处理还是比较困难的。&lt;/p&gt;

&lt;p&gt;静态Batching就比较好弄了，只有在编辑器的右上角勾选静态标志就可以了，不过一旦勾上静态标志，物体就再也不能动不能旋转和缩放了。&lt;/p&gt;

&lt;p&gt;当然Draw Call Batching本身有很多的限制，但对优化渲染管线还是有一定好处的，如果想要加大加强加快优化的力度，还有其他很多方法，每个部分的优化方案都写进了各个章节中，特别是针对Draw Call Batching的替代方案，在模型章节中有很深入的讲解。&lt;/p&gt;

&lt;h6&gt;ForceNoShadowCasting 标签Tag&lt;/h6&gt;

&lt;p&gt;ForceNoShadowCasting是针对是否强制关闭阴影投射功能的。&lt;/p&gt;

&lt;p&gt;当ForceNoShadowCasting为True时，物体将不会去绘制阴影部分，着色器也不会把时间浪费在阴影的绘制上了。默认为False的，默认状态下，物体会去绘制阴影部分的渲染图。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { &amp;quot;ForceNoShadowCasting&amp;quot; = &amp;quot;True&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;IgnoreProjector 标签Tag&lt;/h6&gt;

&lt;p&gt;IgnoreProjector针对的是投射阴影的开关功能。&lt;/p&gt;

&lt;p&gt;当IgnoreProjector为True时，着色器将关闭Projector投射阴影的绘制功能，这个物体将不会绘制投射阴影部分的渲染。默认状态下是False，默认状态下，物体是能响应Projector投射的阴影绘制的。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { &amp;quot;ForceNoShadowCasting&amp;quot; = &amp;quot;True&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;CanUseSpriteAtlas 标签Tag&lt;/h6&gt;

&lt;p&gt;CanUseSpriteAtlas是针对图集里的元素的，它是UGUI中常使用。当CanUseSpriteAtlas为False时，将不会对打进图集里的贴图进行绘制。默认为True。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { &amp;quot;CanUseSpriteAtlas&amp;quot; = &amp;quot;False&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;PreviewType 标签Tag&lt;/h6&gt;

&lt;p&gt;PreviewType是展示材质球预览形状的默认选项的。编辑器中Material材质球展示预览效果时，默认是球形，通过这个标签，可以设置为Plane面板形状，也可以设置为Skybox天空盒形状。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { &amp;quot;PreviewType&amp;quot; = &amp;quot;Plane&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))
    { //移动端
        /*mobile-20:5*/
        var cpro_id = &quot;u3493987&quot;;
        document.write(&quot;\&lt;script type=\&quot;text\/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/cm.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
    else
    {
         /*700*200信息流*/
        var cpro_id = &quot;u3469788&quot;;
        document.write(&quot;\&lt;script type=\&quot;text/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/c.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
&lt;/script&gt;

&lt;h3&gt;以上是SubShader和Pass共享的Tag标签，下面我们介绍一些只有在Pass里使用的Tag标签。&lt;/h3&gt;

&lt;h6&gt;LightMode 标签Tag&lt;/h6&gt;

&lt;p&gt;通过设置LightMode可以在Pass里设置一个光照模型，主要是针对光的相互作用。&lt;/p&gt;

&lt;p&gt;值类型选择范围有：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Always：一直都渲染，不应用光照作用。

    ForwardBase： 使用正向渲染。环境光，主方向光，vertex/SH lights 和 烘培贴图功能被开启。

    ForwardAdd：使用正向渲染。在ForwardBase的基础上，添加像素光的应用，每个Pass（渲染管线）一个灯管。

    Deferred：使用延迟渲染。着色使用g-buffer。

    ShadowCaster：渲染物体depth到阴影图(Shadowmap)或者一张深度贴图(depth texture)。

    MontionVectors：计算每个物体的运动矢量。

    PrepassBase：使用旧的延迟光照。渲染法线和镜面反射。

    PrepassFinal：使用旧的延迟光照。用合并贴图，光照和发散光，来渲染最终颜色。

    Vertex：当物体不使用烘培贴图时，使用旧的顶点灯光渲染模式。所有顶点光都被开启。

    VertexLMRGBM：当物体使用烘培贴图时，使用旧的顶点灯光渲染模式。PC和Console平台上烘培贴图是RGBM编码格式。

    VertexLM：当物体使用烘培贴图时，使用久的顶点灯光渲染模式。在手机平台上烘培贴图是double-LDR编码。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;PassFlags 标签Tag&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    OnlyDirectional：当使用ForwardBase的Pass标签时，这个标签会只让主方向光和环境光数据通过进入Shader。这意味着不重要的灯光数据，不会被通过进入顶点光或球面谐波Shader变量。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;RequireOptions 标签Tag&lt;/h6&gt;

&lt;p&gt;RequrieOptions可以做到，一个Pass申明当有某种外部条件发生的时候才被渲染。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    SoftVegetation：当软植物(Soft Vegetation)在Quality Settings中被设置时，才渲染这个Pass。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
               <pubDate>Wed, 08 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/08/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader4.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/08/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader4.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，Shader(三) - 渲染管道</title>
               <description>&lt;h3&gt;SubShader模块&lt;/h3&gt;

&lt;p&gt;SubShader相当于子Shader的意思，SubShader在Shader中可以有很多个，每个SubShader都可以针对一种设备，但不是所有SubShader都会被采用。当Unity去展示一个模型时，会从第一个SubShader开始寻找是否匹配当前的设备，如果不匹配则与下一个SubShader继续匹配，直到找到能够匹配该设备为止。如果所有的SubShader都没有匹配上，则会使用 Fallback 标签的Shader。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;格式如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SubShader&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;   [Tags]&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;   [CommonState]&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;   [Pass1]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RenderSetup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;    [Pass2]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RenderSetup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;    [Pass3]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RenderSetup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;    […]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Fallback&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;”&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fallback&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Off&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;SubShader中可以定义了Tag标签，以及与Pass共同拥有的状态(Common State)。&lt;/p&gt;

&lt;p&gt;Pass代表了一个渲染管道，每次通过Pass进行渲染都是通过一次完整渲染管道。&lt;/p&gt;

&lt;p&gt;当一个SubShader被设备选中进行渲染时，定义的每个Pass都会渲染该物体一次，如果有很多灯光相互作用的话可能不止一次。通过Pass渲染一次会承担相当大的代价，所以我们在编写Shader Pass时需要小心，尽量减少Pass的使用，尽量将Pass数量最小化。&lt;/p&gt;

&lt;p&gt;建议只有在我们无法使用单个Pass达到效果时，才启用多个Pass进行Shader编程。&lt;/p&gt;

&lt;p&gt;所有在SubShader块中的渲染状态都可以在Pass中进行特殊化，也就是说定义在SubShader中的渲染状态是所有Pass公有的渲染状态，同时Pass可以定义自己的个性化的渲染状态。&lt;/p&gt;

&lt;p&gt;比如以下例子：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SubShader&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Lighting&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Off&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Cull&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Front&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Cull&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Back&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Fallback&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Diffuse&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;”&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;上述例子中 SubShader 设置了一个共同的渲染状态(Common State)就是把灯光影响关掉，灯光不再影响着色，第一个Pass中使用了独立的渲染状态是，裁切模型前半部分，第二个Pass中也使用了独立的渲染状态，裁切模型模型后半部分，然后他们共同拥有Common State是关闭灯光效果，所以第一个Pass就有了两个状态，一个是关闭灯光效果，第二个是裁切前半部分模型，而第二个Pass的也有两个状态，一个是关闭灯光效果，另一个是裁切后半部分模型。&lt;/p&gt;

&lt;p&gt;SubShader最后还有一个Fallback标识，代表了当所有SubShader都对设备无效时，则选择备用的Shader作为替代。而当你认为无法替代，或者无需替代的时候可以关闭Fallback的功能 Facllbck off 。&lt;/p&gt;

&lt;p&gt;在上面的例子中，Fallback “Diffuse”表示了，当所有SubShader都无法起作用的时候漫反射Diffuse替代当前Shader。&lt;/p&gt;

&lt;p&gt;SubShader本身并不复杂，但里有几个重要的模块，以及这些模块中的标签和用途可能会稍微繁琐一些，下面我们要详细讲一讲Pass块的格式和属性内容。&lt;/p&gt;

&lt;h3&gt;渲染管道&lt;/h3&gt;

&lt;p&gt;提到渲染管道，不得不提到渲染管线流程，一整个渲染管线流程分八个阶段。&lt;/p&gt;

&lt;h6&gt;阶段1， 指定几何对象&lt;/h6&gt;

&lt;p&gt;这个阶段引擎在选择某些几何对象作为渲染目标。&lt;/p&gt;

&lt;p&gt;理论上是一次抓取一个几何对象，但一般引擎都有批处理优化功能，一次抓取一批相同材质球的几何物体进行渲染。&lt;/p&gt;

&lt;h6&gt;阶段2，顶点处理&lt;/h6&gt;

&lt;p&gt;主要工作就是“变换三维顶点坐标”和“光照计算”。&lt;/p&gt;

&lt;p&gt;顶点变换或坐标系变换包括：&lt;/p&gt;

&lt;p&gt;3D中有以下几种空间：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1，Object space，模型坐标

    模型空间也叫本地空间或者建模空间，这是我们定义物体三角形的坐标系，当一个建模人员创建一个物体的三维模型的时候，他选择了一个方便的方向、比例和位置来保存模型的组成顶点，当前物体的模型、空间和其他模型没用任何关系。

    2，World space，世界坐标；

    世界空间的目的就是给你的场景中的物体提供一个绝对的参考。

    3，Eye space，视觉空间（视锥裁剪）

    以摄像机为基准，以摄像机的位置为原点，摄像机朝向Z轴正方向，右边X轴为正方向，上边为Y轴正方向，之所以设置这个坐标系，主要是为了方便投影及裁剪操作。

    ###### 4，Clip and Project space，摄影，裁剪空间坐标（也叫屏幕坐标）

    该空间即世界空间的物体被投影到相应的投影上面之后，继而进行的裁剪操作所在的空间。

    Eye space坐标转换到Clip and Project space坐标的过程其实就是一个投影、剪裁、映射的过程。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了坐标转换和光照计算，第2阶段还做了纹理坐标变换(纹理矩阵)，材质状态纹理坐标生成。&lt;/p&gt;

&lt;p&gt;这个阶段所接收到的数据则是每个顶点的属性特征，输出则是变换后的顶点数据。&lt;/p&gt;

&lt;p&gt;这个阶段也是Shader里，vertex fragment着色器编程中 vertex 顶点转换函数的处理阶段，vetex顶点函数就在这个阶段编写顶点的变化。&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))
    { //移动端
        /*mobile-20:5*/
        var cpro_id = &quot;u3493987&quot;;
        document.write(&quot;\&lt;script type=\&quot;text\/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/cm.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
    else
    {
         /*700*200信息流*/
        var cpro_id = &quot;u3469788&quot;;
        document.write(&quot;\&lt;script type=\&quot;text/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/c.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
&lt;/script&gt;

&lt;h6&gt;阶段3，图元装配&lt;/h6&gt;

&lt;p&gt;在顶点处理之后,顶点的全部属性都已经被确定 在这个阶段顶点将会根据应用程序送往的图元规则.&lt;/p&gt;

&lt;h6&gt;阶段4，图元处理(裁剪 消隐)&lt;/h6&gt;

&lt;p&gt;将图元与用户定义的裁剪平面和模型投影矩阵所建立的视景比较，裁剪且丢弃位于视景和裁剪平面外部的图元，不再予以处理。&lt;/p&gt;

&lt;p&gt;若是采用透视投影，那么将会对每个顶点的x,y,z坐标分别乘以透视矩阵。&lt;/p&gt;

&lt;p&gt;接着由视口变换将顶点坐标变换至窗口坐标。视口变换，即把投影变换后的顶点X,Y坐标，根据用户设定的视口参数，变换到屏幕上对应的坐标。&lt;/p&gt;

&lt;p&gt;最后执行消隐操作，把那些被遮挡的部分进行消除。&lt;/p&gt;

&lt;p&gt;消隐操作，即隐藏面消除，即使经过了裁剪操作，对于每个物体，摄像机只能看到正对着摄像机的一面，对背对着摄像机的一面是看不到的。&lt;/p&gt;

&lt;p&gt;这一步的任务就是把看不到的这一面消除掉，以免继续处理，影响计算机的性能和效率。&lt;/p&gt;

&lt;p&gt;为了确定一个多边形是正对着还是背对着摄像机，就要用到我们在输入集合阶段指定多边形时的顶点顺序了，默认情况下，D3D规定按顺时针指定的三角形属于正面，逆时针为背面。确定顺时针还是逆时针，可以用如下方法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    给出两个向量：E0=V1-V0 E1=V2-V0 对E0和E1进行叉乘操作N=E0XE1，如果N指向摄像机，则为正面，否则为背面。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;阶段5，栅格化&lt;/h6&gt;

&lt;p&gt;三维模型经过了顶点变换已经投影到了二维平面上，而且被装配成图元了，但是屏幕是一个一个细细小小的像素格子组成的，对于一个图片，电脑是怎么知道应该把它搞到哪几个像素上去显示的呢？这就是光栅化。说白了就是，把想看见的图片，搞成像素能显示的。光栅化工作告诉了显卡，哪个格子是你这个图元应该画上的哪个不是。&lt;/p&gt;

&lt;p&gt;传递过来的图元数据，在此将会被分解成更小的单元并对应帧缓冲区的各个像素，这些单元被称之为片元。一个片元可能包含窗口大小，深度，颜色，纹理坐标等属性。&lt;/p&gt;

&lt;p&gt;片元的属性是图元上顶点数据等经过插值而确定的，比如颜色，深度等。&lt;/p&gt;

&lt;p&gt;顶点属性的插值计算，在输入集合阶段用户指定的一系列的多边形，以三角形为例，每个三角形由三个顶点组成，每个顶点包含一系列的属性，如坐标，法线，纹理坐标等等，在经过顶点着色阶段，视口变换后，这个顶点在屏幕上都有对应的坐标。但为了显示该三角形，仅仅三个顶点显然是不够的，为了计算该三角形所覆盖的屏幕上每个像素的属性，要进行正确的插值计算，计算结果填充到片元中去。&lt;/p&gt;

&lt;h6&gt;阶段6，片元处理&lt;/h6&gt;

&lt;p&gt;这个阶段首先对片元上纹理，通过纹理坐标取得纹理内存中相对应的颜色。&lt;/p&gt;

&lt;p&gt;再进行雾化，通过片元与当前视点位置的距离修改颜色。&lt;/p&gt;

&lt;p&gt;最后颜色汇总，将纹理,主定义的颜色,雾化的颜色,次颜色光照阶段计算的颜色汇总一起。&lt;/p&gt;

&lt;p&gt;这个阶段就是vertex fragment着色器编程中 fragment 片元转换函数的处理阶段，fragment 片元函数通过这个阶段的编程对片元进行修改。&lt;/p&gt;

&lt;h6&gt;阶段7，像素操作（Pixel Operation）&lt;/h6&gt;

&lt;p&gt;所有的片元的测试都在这里进行，包括：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    像素所有权测试 -&amp;gt; 裁剪测试 -&amp;gt; alpha测试 -&amp;gt; 模板测试 -&amp;gt; 深度测试 -&amp;gt; 混合 -&amp;gt; 抖动显示 -&amp;gt; 逻辑操作
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;阶段8，帧缓冲区（Frame Buffer）&lt;/h6&gt;

&lt;p&gt;执行帧缓冲的写入等操作，写入帧缓冲区，等待最后产生了显示出来的像素。&lt;/p&gt;

&lt;p&gt;渲染管线的整个过程如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader11.png&quot; alt=&quot;render pipe&quot;&gt;&lt;/p&gt;

&lt;p&gt;上图中 vertex框就是可编程部分的 vertex 函数，它可以修改顶点部分的数据来表现个性化的效果，fragment框也是一样，是 fragment 函数的调用点，修改通过这个fragment函数可以修改片元数据达到需要的效果。&lt;/p&gt;

&lt;p&gt;Unity3D在渲染管线各阶段中所用到的功能，和我们前面所描述的阶段有很相似的地方，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader12.png&quot; alt=&quot;render pipe&quot;&gt;&lt;/p&gt;

&lt;p&gt;上图所要表达的功能和阶段，正是我们要在Shader章节中讲解和说明的部分。&lt;/p&gt;

&lt;p&gt;参考资料&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1，渲染管线流程 作者：不详

    2，【图形学】渲染管道 作者：阵雷
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
               <pubDate>Wed, 08 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/08/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader3.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/08/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader3.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第六章，网络层(三) - 实现UDP</title>
               <description>&lt;h3&gt;实现UDP&lt;/h3&gt;

&lt;p&gt;在前面介绍了如何实现TCP socket，下面要介绍下UDP的实现方式。&lt;/p&gt;

&lt;p&gt;其实两者都是长链接的方式，很多地方都有相识之处，比如两者都需要连接和断开事件支撑，都需要做发送和接收队列缓存，都需要定义数据包协议格式，都需要加密和校验。&lt;/p&gt;

&lt;p&gt;我们来说说TCP有而UDP没有的部分，以及需要我们在UDP上实现的功能。UDP和TCP相比，UDP基本就是TCP的阉割版本，很多TCP有的功能UDP都没有。相同的地方有，都是异步发送和接收，都需要多线程操作，发送和接收都需要缓冲队列，并且发送数据时都需要合并数据包。TCP有而UDP没有的地方有，UDP不会自己校验重发，丢包概率大，数据包接收顺序不确定，而且UDP本身没有连接断开检测机制，也没有连接确认机制。&lt;/p&gt;

&lt;p&gt;所以直接使用UDP来做网络连接，会遇到巨大的问题，可以说直接使用而不加修饰，不确定性太大基本用不了UDP。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h6&gt;连接确认机制&lt;/h6&gt;

&lt;p&gt;TCP有连接的三次握手协议，相当于在连接过程中跟服务器端协商后敲定我们已经建立了连接这个一致预期，而UDP是无状态链接，它并没有三次握手的协议，所以UDP连接其实是一厢情愿的，客户端并不知道是否真正连接成功了。&lt;/p&gt;

&lt;p&gt;所有发送和接受都是建立在连接确认的基础上的，所以我们必须先确认知道我们是否连接成功。能够判断连接是否成功是整个实现UDP的第一步，只有这样才能顺利得进行下面的数据包收发操作。&lt;/p&gt;

&lt;p&gt;怎么确认连接成功呢？&lt;/p&gt;

&lt;p&gt;首先我们来看看TCP连接的三次握手是怎么做的。&lt;/p&gt;

&lt;p&gt;1，  首先客户端向服务器端发送一个数据包，里面包含了Seq=0的变量，表示当前发送数据包的序列号为0，也就是第一个数据包。&lt;/p&gt;

&lt;p&gt;2，  服务器端收到客户端的数据包后，发现Seq=0，说明是第一个包，用来确认连接的，于是给客户端也发送了一个数据包，包含了Seq=0，和Ack=1，表示服务器端已经收到你的连接确认包了，并且回应包Ack序列标记为1。&lt;/p&gt;

&lt;p&gt;3，  客户端收到服务器端给的回应数据包后，知道了服务器端已经知道了我们已经建立连接，于是向服务器端发送了一个数据包，里面包含了Seq=1，Ack=1，表示确认数据包已经收到，连接已经确认，开始发送数据。&lt;/p&gt;

&lt;p&gt;这就是TCP的三次握手来确认连接的流程。&lt;/p&gt;

&lt;p&gt;在UDP下并没有三次握手机制，为了建立更好的确认连接机制，我们可以模仿TCP的形式来确认连接。不过第3次握手有点多余，可以省去最后一次握手的数据包，改为2次握手。步骤如下。&lt;/p&gt;

&lt;p&gt;首先在UDP连接后，在确认连接前不进行任何的其他类型的数据发送并且不接收任何其他数据，我们将这种发送数据包以确认连接成功与否的数据包称为握手包。&lt;/p&gt;

&lt;p&gt;在建立连接后，客户端先向服务器端发送一个握手数据包，代表客户端向服务器端请求连接确认信号的数据包，包内的数据仅仅是一个序列号Seq=0，或者不是序列号也可以，而是一个特殊的字段。当服务器端收到这个握手数据包后，也就是实现了第一次握手。&lt;/p&gt;

&lt;p&gt;服务器端在收到第一次握手数据包后，回应一个握手数据包，里面同样带有客户端能识别的连接确认信号。当客户端接收到时就说明，发出去给服务器端的连接确认数据包有了回应，也就是说第二次握手成功。接收到了第二次握手连接确认响应数据包时，就表明了连接已经成功建立。&lt;/p&gt;

&lt;p&gt;UDP确认连接的整个握手过程，就相当于客户端和服务器端的一次交流，相互认识一下并且示意后面的交流将要开始。&lt;/p&gt;

&lt;p&gt;实现UDP连接确认具体步骤（伪代码）：&lt;/p&gt;

&lt;p&gt;1，  首先使用API建立UDP连接。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SvrEndPoint&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IPEndPoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IPAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;UdpClient&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UdpClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;UdpClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SvrEndPoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;2，  启动接收数据线程。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UdpClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BeginReceive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReceiveCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ReceiveCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IAsyncResult&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mIPEndPoint&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;UdpClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Receive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mIPEndPoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;UdpClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EndReceive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mIPEndPoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;OnData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mUdpClient&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// try to receive again.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mUdpClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BeginReceive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReceiveCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;3，  发送连接确认数据包，并屏蔽其他发送和接收功能。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SendConnectRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;StopSendNormalPackage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;StopReceiveNormalPackage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;4，  等待接收连接确认数据包。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;If&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsConnected&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;If&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IsConnectResponse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;OnEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConnectSuccess&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;IsConnected&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ProcessNormalData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;5，  连接确认包收到，确认连接已经成功建立。开启发送和接收数据包的功能。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ProcessNormalData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;If&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsConnected&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;DealNetworkData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;经过与服务器端数据包的来回，UDP完成了2次握手的确认机制，已经可以认定为连接已经成功建立。&lt;/p&gt;

&lt;h6&gt;断开连接判定机制&lt;/h6&gt;

&lt;p&gt;UDP自己不能判断是否断开，因为它是无状态的连接，需要我们自己来做断线检测，检测的方式与TCP的心跳包类似。&lt;/p&gt;

&lt;p&gt;断开连接的判定机制，也是用数据包来回的形式，不过不是单一一个数据包，而是长时间的心跳包的形式来做持续性的判断连接状态。&lt;/p&gt;

&lt;p&gt;首先，我们要与服务器端有个协定，每隔X秒（比如5秒）发送一个心跳数据包给服务器端，这个客户端发送的心跳数据包里包含了一些客户端信息，包括ID，角色状态，设备信息等，包体不能太大，否则会就加重了宽带负担。&lt;/p&gt;

&lt;p&gt;当服务器端收到心跳数据包时，也立刻回复一个心跳数据回应包，里面包含了，服务器端当前时间，服务器端当前状态等信息。&lt;/p&gt;

&lt;p&gt;当客户端收到此数据包时，说明连接尚在，也能同时同步服务器端的时间和一些基础的信息。&lt;/p&gt;

&lt;p&gt;如果客户端很久没有收到心跳数据回应包时，就表明，连接已经断开了，比如30秒没收到心跳包，可以判断连接已经断开。&lt;/p&gt;

&lt;p&gt;服务器端也是一样操作，当没有收到心跳包很久，就表明客户端的连接已经断开。这时客户端就可以开启相应的重连程序，或重连提示以及步骤。&lt;/p&gt;

&lt;p&gt;具体步骤如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1，  每隔X秒向服务器端发送心跳数据包。

    2，  服务器端收到心跳数据包后回复心跳响应数据包。

    3，  如果，客户端和服务器端都很久没有收到心跳数据包，比如30秒，则判定连接断开。

    4，  主动断开连接，客户端提示用户，或者重新创建连接，服务器端则是处理与之相关数据的处理。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))
    { //移动端
        /*mobile-20:5*/
        var cpro_id = &quot;u3493987&quot;;
        document.write(&quot;\&lt;script type=\&quot;text\/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/cm.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
    else
    {
         /*700*200信息流*/
        var cpro_id = &quot;u3469788&quot;;
        document.write(&quot;\&lt;script type=\&quot;text/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/c.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
&lt;/script&gt;

&lt;h6&gt;数据包校验与重发机制&lt;/h6&gt;

&lt;p&gt;前面说UDP相当于是TCP的阉割版，而最关键的阉割部分就是校验和重发机制。&lt;/p&gt;

&lt;p&gt;没有校验和重发机制，意味着发送端无法知道数据包的发送是否到达或者丢失，甚至丢失了也无法重新发送的机制来补充丢失的数据包。&lt;/p&gt;

&lt;p&gt;所以我们需要自己编写增加对数据的校验和重发机制，来确保数据的可靠性。&lt;/p&gt;

&lt;p&gt;TCP有校验和重发机制，我们可以模仿它的校验和重发机制在UDP上使用，再在此基础上加以改进。这样我们即有了UDP的速度，又有了TCP的可靠性。&lt;/p&gt;

&lt;p&gt;我们来看TCP是如何做数据包的校验和重发的。&lt;/p&gt;

&lt;p&gt;关于Seq和Ack。Seq即Sequence Number，为源端（source）的发送序列号；Ack即Acknowledgment Number，为目的端（destination）的接收确认序列号。&lt;/p&gt;

&lt;p&gt;1，  首先客户端向服务器端发送数据包，里面包含Seq(sequence number)序列号为1(已经发送的数据包的累计大小)，发送的数据包大小为比如264。&lt;/p&gt;

&lt;p&gt;2，  服务器端收数据包后就知道了当前连接的这个数据包的序号为1，也就是连接后第一个数据包。于是向客户端发送了一个确认包，确认包中包含了的Ack=264(接收到的数据包的累计大小)，告诉客户端我服务器端已经收到了数据包，现在累计大小为264的数据包。如果累计大小错误，就需要启动重传机制，退回到最后一次正确的的数据包位置，进行重传，以保证可靠性。&lt;/p&gt;

&lt;p&gt;3，  当客户端再次发送数据包时，里面包含的Seq序列号为265，意思为发送累计数据大小，这次发送的数据包大小为100，服务器端接收到后向客户端发送确认包，确认包中，包含了Ack=365，意思是已经累计收到数据包大小为365。如果累计大小错误，请启动重传机制，确保可靠性。&lt;/p&gt;

&lt;p&gt;4，  接下来由服务器端向客户端发送数据。服务器端向客户端发送数据也是同样的方法和步骤。数据包中包含了服务器端的Seq(已经发送的数据包大小)，比如累计发送了1，seq=1，这次数据包大小为585，客户端接收到服务器端的数据包后，向服务器端发送确认包，包中包含了服务器端发过来的Ack  =586，服务器端收到确认包后，就知道了累计接收的数据包大小已经到了585，也就是说当前的数据包已经发送成功。&lt;/p&gt;

&lt;p&gt;若在规定的时间内收到响应Seq序列号和Ack，表明该报文发送成功，可以发送下一个报文Seq；否则重传（TCP Retransmitssion）。序列号确认机制是TCP可靠性传输的保障。&lt;/p&gt;

&lt;p&gt;借鉴TCP的方法，UDP也可以用此方法来做检测和重传。但是大小累计的检测方式重传的效率太差，不能准确快速的定位重传的数据包，甚至有些已经到达的数据，因为中间数据包的丢包，导致已经到达的数据也需要重传，来确保可靠性。&lt;/p&gt;

&lt;p&gt;在实现UDP的检测和重传时，我们可以进行如下的改进。&lt;/p&gt;

&lt;p&gt;1，  客户端向服务器端发送数据包，数据包中包含Seq=1(表示数据包的发送序列)，发送后将此数据包推入到已经发送但还没有确认的队列里。&lt;/p&gt;

&lt;p&gt;如果服务器接收到Seq=1的数据包，就回应客户端一个确认包，包中Ack=1，表示Seq=1的包已经确认收到。&lt;/p&gt;

&lt;p&gt;如果服务器端没有接收到数据，客户端X秒后发现并没有收到Seq为1的确认包，判定为Seq=1的数据包传输失败，从已经发送但未确认的数据包队列中取出Seq=1的数据包，重新发送。&lt;/p&gt;

&lt;p&gt;2，  客户端向服务器端发送了10个数据包，分别是Seq=1，2，3，4，5，6，7，8，9，10，服务器收到的序列是，1，3，4，5，7，8，9，10，其中有2，6，没有收到数据包。&lt;/p&gt;

&lt;p&gt;客户端在等待确认包超时后，对2，6进行重传。在服务器端接收到数据包后，在处理数据包时，如果数据包顺序有跳跃的现象就表明数据包丢失，等待客户端重传，这时就在断开的序列处停止处理数据包，进行等待操作。&lt;/p&gt;

&lt;p&gt;3，  加快重传确认时间。客户端向服务器端发送5个数据包，分别是Seq=1，2，3，4，5，服务器端收到的包是1，3，4，5，当收到3时，发现2被跳过1次，当收到4时发现2被跳过2次，立刻启动2的重传，不在等确认超时，加快丢包重传速度。&lt;/p&gt;

&lt;h6&gt;丢包问题分析&lt;/h6&gt;

&lt;p&gt;UDP丢包多是很正常现象，这是UDP牺牲质量而提高速度的代价。UDP丢包的原因很多，我们这里做个分析。&lt;/p&gt;

&lt;p&gt;1，  接收端处理时间过长导致丢包：&lt;/p&gt;

&lt;p&gt;调用recv方法接收端收到数据后，处理数据花了一些时间，处理完后再次调用recv方法，在这二次调用间隔里，发过来的包可能丢失。&lt;/p&gt;

&lt;p&gt;对于这种情况可以修改接收端，将包接收后存入一个缓冲区，然后迅速返回继续recv。或者使用前面提到的双队列机制，来缩短锁队列的时间，从而解放了处理包的时间和接收数据包的线程之间的冲突。&lt;/p&gt;

&lt;p&gt;2，  发送的包巨大丢包：&lt;/p&gt;

&lt;p&gt;虽然Send方法会帮你做大包切割成小包发送的事情，但包太大也不行。&lt;/p&gt;

&lt;p&gt;例如超过50K的一个udp包，不切割直接通过send方法发送也会导致这个包丢失。&lt;/p&gt;

&lt;p&gt;发送的包较大，超过接受者缓存导致丢包：包超过mtu size数倍，几个大的udp包可能会超过接收者的缓冲，导致丢包。&lt;/p&gt;

&lt;p&gt;这种情况需要切割成小包再逐个send。报文过大的问题，可以通过控制报文大小来解决，使得每个报文的长度小于MTU。&lt;/p&gt;

&lt;p&gt;以太网的MTU通常是1500 bytes，其他一些诸如拨号连接的网络MTU值为1280 bytes，如果使用speaking这样很难得到MTU的网络，那么最好将报文长度控制在1280 bytes以下。&lt;/p&gt;

&lt;p&gt;3，  发送的包频率太快：&lt;/p&gt;

&lt;p&gt;虽然每个包的大小都小于mtu size 但是频率太快，例如40多个mut size的包连续发送中间不sleep，也有可能导致丢包。&lt;/p&gt;

&lt;p&gt;这种情况可以通过建立Socket接收缓冲队列解决，和建立发送缓冲队列来解决，并且在发送频率过快的时候考虑Sleep作为时间间隔。&lt;/p&gt;

&lt;p&gt;很多人会不理解发送速度过快为什么会产生丢包，原因就是UDP的SendTo不会造成线程阻塞，也就是说，UDP的SentTo不会像TCP中的SendTo那样，直到数据完全发送才会return回调用函数，它不保证当执行下一条语句时数据是否被发送。（SendTo方法是异步的）&lt;/p&gt;

&lt;p&gt;如果要发送的数据过多或者过大，那么在缓冲区满的那个瞬间要发送的报文就很有可能被丢失。至于对“过快”的解释，作者这样说：“A few packets a second are not an issue; hundreds or thousands may be an issue.”（一秒钟几个数据包不算什么，但是一秒钟成百上千的数据包就不好办了）。 &lt;/p&gt;

&lt;p&gt;要解决接收方丢包的问题很简单，首先要保证程序执行后马上开始监听（如果数据包不确定什么时候发过来的话），其次，要在收到一个数据包后最短的时间内重新回到监听状态，其间要尽量避免复杂的操作（比较好的解决办法是使用多线程回调机制）。&lt;/p&gt;

&lt;p&gt;以上是UDP的实现细节，同时阐述了UDP的实现难点和注意点。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1， 基于TCp的数据包传输过程
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
               <pubDate>Tue, 07 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/07/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%823.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/07/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%823.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第六章，网络层(二) - 实现TCP</title>
               <description>&lt;h3&gt;实现TCP长连接。&lt;/h3&gt;

&lt;p&gt;我们先从整体出发，列一下Unity3D实现TCP连接需要的实现哪些方面：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1， 建立连接

    2， 断线检测

    3， 网络协议

    4， 发送和接收队列缓冲

    5， 发送数据合并

    6， 线程死锁策略
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;TCP本身已经有数据包可靠性确认，以及丢包重发机制，数据包的大小也没有限时，我们可以把这些功能称之为免费得到的功能。&lt;/p&gt;

&lt;p&gt;所以在实现TCP的连接中不需要我们再做包体的校验，切割包体，以及重发数据包，省掉了很大一部分麻烦。&lt;/p&gt;

&lt;p&gt;我们只需要做的就是建立连接，发送，以及接收。不过如果不对发送数据进行合并，就会有很多小的数据分批发送，导致发送效率低下。所以我们下文中会提到关于发送合并的问题。&lt;/p&gt;

&lt;p&gt;简单介绍下TCP的API库&lt;/p&gt;

&lt;p&gt;c#的.net库提供了TCP的Socket连接API，我们来看看c#的.net库中的这些API。&lt;/p&gt;

&lt;p&gt;理论上你不会去用阻塞方式连接和接收，因为你不会让你的游戏卡住不动来等待连接，这有可能导致崩溃，所以连接，接收，断开，都是异步的线程操作。同步阻塞的操作可能会周边的工具中会用到，比如编辑器的工具，回放工具，GM的工具等，其他大部分时候都希望异步操作网络连接。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    BeginConnect，开始连接

    BeginReceive，开始接收信息

    BeginSend，开始发送数据

    BeginDisconnect，开始断开

    Disconnect(Boolean)，立刻断开连接
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前四个都是异步的，调用后会开启一个线程来工作，最后一个是同步阻塞式的断开连接。最后一个阻塞式大都在游戏退出时调用，但APP没有退出事件，所以最后一个一般都在Unity3D Eitor下或者windows版本上调用，以保证在开发时强制退出后编辑器不会奔溃。&lt;/p&gt;

&lt;h6&gt;线程锁&lt;/h6&gt;

&lt;p&gt;网络部分基本上所有的操作都是线程级别的，Unity3D的渲染和逻辑是在主线程上运作的，这里就涉及到了主线程和子线程的资源线程锁的问题。&lt;/p&gt;

&lt;p&gt;主线程与子线程一起工作时，如果都需要某个内存块，或者资源，就会同时去读取或者写入资源，这就是造成死锁的情况的根源。因此在调用有冲突的资源时，需要做锁的操作，用以防止线程们在读取或写入操作时对资源错误的争夺。&lt;/p&gt;

&lt;p&gt;例如接收线程，接收到网络数据后将数据push到队列时，在push操作上做锁操作：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;或者主线程在读取网络数据时，在推出一个数据时，在Pop的操作上加一个锁的操作。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;每次对线程共享的资源进行操作时，都需要先进行锁确认的操作，以避免线程争夺资源而造成死锁。&lt;/p&gt;

&lt;h6&gt;缓冲队列&lt;/h6&gt;

&lt;p&gt;网络游戏中，数据会远远不断进行发送和接收，很多时候程序还没处理好当前的数据包，就已经有很多数据包从服务器传送到达了客户端。发送数据也是一样，会瞬间积累很多的需要发送的数据包，所以需要用队列来进行存储和缓冲。&lt;/p&gt;

&lt;p&gt;负责接收的子线程把接收好的网络数据包放入接收缓冲队列，主线程通过Update轮训去检查接收队列里是否有数据，有的话就一个个取出来处理，没有的话继续轮训等待。&lt;/p&gt;

&lt;p&gt;如下面伪代码表达了，主线程每帧检查一下是否有收到信息，检测到就立刻处理，没有的话下一帧继续轮训检测。如果没有信息接收来时，子线程上会阻塞等待直到有消息接收到才会调用接收消息接口，将数据包解析后推入接收队列。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;/////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//接收线程等待接收数据并推入队列&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BeginReceive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Receive_Callback&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LogerType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ERROR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StackTrace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DisConnect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Receive_CallBack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IAsyncResult&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;_result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PushNetworkData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//将数据推入队列&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Receive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//继续接收数据消息&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;///////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//主线程处理数据队列里的数据&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;While&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PopNetworkData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;DealNetworkData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;上面的伪代码中，首先有子线程的等待接收数据，接收到以后就立即将数据推入队列。另一面，主线程一直在轮询是否有已经接收到的网络数据，如果有就立即逐个处理全部数据。&lt;/p&gt;

&lt;h6&gt;双队列结构&lt;/h6&gt;

&lt;p&gt;这里介绍一下双队列数据结构，它能增加些许多线程中队列的读写效率。&lt;/p&gt;

&lt;p&gt;双队列是一种高效的内存数据结构，在多线程编程中，能保证生产者线程的写入和消费者的读出尽量做到最低的影响，避免了共享队列的锁开销。&lt;/p&gt;

&lt;p&gt;具体什么意思呢？其实很简单。&lt;/p&gt;

&lt;p&gt;多个线程都需要对队列读写，接收数据的网络线程会将数据写入队列，而处理数据的主线程会读取队列并删除顶头的一个，两者都会读写队列，导致资源争夺。&lt;/p&gt;

&lt;p&gt;加入了线程锁的机制后，仍然没能很好的解决两个线程同时操作一个队列的问题。例如假设处理数据的主线程需要花很久的时间去处理网络数据，这时接收数据的线程因为接收队列被主线程锁住不能继续自己的接收数据的操作，所以子线程被等待资源使用完毕后才能使用资源，如果这个数据很多很大很耗时，那么子线程就要等很少时间，大大降低了线程了效率。&lt;/p&gt;

&lt;p&gt;用双队列的形式就能让线程处理队列时解放出来，让线程的效率大大增加，使得各线程能够各自处理调用各自的队列处理而不用因为资源锁而等待。&lt;/p&gt;

&lt;p&gt;双队列是如何做到的呢？前面接收数据包部分都是一样的，接收数据线程接收到数据时直接推入接收数据的队列，不一样的地方在，当处理数据的线程轮询时，先将接收数据的队列拷贝到处理数据的队列中并清空接收数据的队列，主线再对拷贝后的数据队列进行处理，于是子线程能够顺利的继续接收数据而无需等待接收队列这个资源。这样就解放了两边的冲突时间了，各自只要处理自己的队列就可以了。&lt;/p&gt;

&lt;p&gt;伪代码如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;/////////////////////////////////////////////&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//子线程中，接收数据线程&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Receive_CallBack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Pushdata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;/////////////////////////////////////////&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//处理数据的主线程&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SwitchQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;receiveQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;produceQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SwitchQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PopQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Deal_with_network_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;伪代码中，首先是对子线程的接收部分描述，当接收到数据包时push到接收队列中，而当主线程需要处理数据时，先切换队列，防止对队列占用过多时间，切换完毕后，再对队列中的全部数据进行处理。&lt;/p&gt;

&lt;p&gt;这样一来，锁的时间变短了，原本要在处理期间全程上锁导致其他线程无法使用，现在只在切换那一瞬间锁上资源，其他时间各线程都能顺畅得各自做自己的工作，大大提高了线程的效率。&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))
    { //移动端
        /*mobile-20:5*/
        var cpro_id = &quot;u3493987&quot;;
        document.write(&quot;\&lt;script type=\&quot;text\/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/cm.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
    else
    {
         /*700*200信息流*/
        var cpro_id = &quot;u3469788&quot;;
        document.write(&quot;\&lt;script type=\&quot;text/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/c.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
&lt;/script&gt;

&lt;h6&gt;发送数据&lt;/h6&gt;

&lt;p&gt;我们前面说发送数据时也需要队列来做缓冲，因为发送的数据包会很多，也有可能很短时间内会积累很多数据包。&lt;/p&gt;

&lt;p&gt;另外，发送时大多数的数据包都是很小很小的数据包，如果每个数据包都发送一次等待接受后再发送就会导致发送效率过低，发送太慢导致延迟过大。&lt;/p&gt;

&lt;p&gt;而如果一下子把全部数据都发送的话，发送的数据可能会太大，导致发送效率很差，因为数据包越大越容易发送失败或丢包，TCP就会全盘否定这次发送的内容，并将整个包都重新发送一次，效率极其糟糕。&lt;/p&gt;

&lt;p&gt;所以我们需要自己建立发送缓冲来保证发送的有序和高效，发送队列以及对发送数据的合并就是很好的策略。&lt;/p&gt;

&lt;p&gt;步骤如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1，每次当你调用发送接口时会把数据包塞入发送队列，发送程序就开始轮训是否有需要发送的信息在队列里，有的话就发送，没有的话就继续轮训等待。

    2，发送时，合并队列里的所有数据包，准备一次性发送多个数据包以提高效率。

    3，对这种合并操作做个限制，如果因为合并而导致数据包太大，也会导致效率差。发送过程中，只要丢失一个数据就要全盘重新发送，数据包很大的话，发送本来就很缓慢的情况下，又重新整体重新发送，就会使得发送效率大大降低。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们既要合并数据包，又不能让数据包太大，这样才能保证发送的效率比较高。&lt;/p&gt;

&lt;p&gt;比如我们做个合并后的数据包大小限制不得超过10K。这样每个数据包大小都处于10K以下的大小，除非单个包大于10K就让他单独发送，且每次发送包含了多个数据包，这样发送效率就有了一定的保证。&lt;/p&gt;

&lt;h6&gt;协议数据定义标准&lt;/h6&gt;

&lt;p&gt;在网络数据传输中协议是比较重要的一个关键点，它是客户端与服务器交流的语言。&lt;/p&gt;

&lt;p&gt;什么是协议，简单来说就是客户端和服务器端商讨后达成一个对数据格式的协定，是客户端与服务器进行交流的语言，比如两边都用Json格式的协议来传输数据。这样两边在发送和收到数据时，都能够按照一定的规则识别数据了。&lt;/p&gt;

&lt;p&gt;我们在实现TCP里需要对协议进行商讨，那么在商讨协议的过程中，关键点是什么呢？&lt;/p&gt;

&lt;p&gt;1，    客户端和服务器都能接受的格式。并不是所有的格式都适合，选择中意的，前后端都能接受的协议格式才是最重要的，因为合作最重要，个人力量和一个协议格式的力量与团体来说都是渺小的。在团队的都理解和一致的情况下，再对协议进行精进，选择更好更高效的协议。&lt;/p&gt;

&lt;p&gt;2，    数据包体大小最小化。尽可能的减少包体大小，选择一些能节省包大小空间的格式，比如google protocol buffer。或者对包主体部分使用压缩算法，我不建议只加压缩算法而不改变协议本身，因为会导致对压缩算法过度依赖而省略了协议本身的浪费空间，比如你用了压缩算法后发现xml或json格式的协议也还过得去就不再更改协议本身了，这样就会导致后期数据量大时数据包变得很大很沉重，传输效率降低。但很多老项目和一些为了加快速度而不去更改协议的项目情况时常发生，所以只启用压缩算法而不改变协议本身很多时候也是无奈之举。&lt;/p&gt;

&lt;p&gt;3，    需要有一定的校验能力。当数据包体不完整时，或者本身包体后面连接着另外的数据包时，能够有校验能力，和识别完整包体范围的能力。很多时候我们在传输数据的时候，收到的并不是一个完整的包体，或者因为网络关系，收到了错误的，甚至被攥改过的数据，我们要有能力去校验他们。&lt;/p&gt;

&lt;p&gt;4，    加密。为了保证网络数据包不被篡改和查看，导致外挂破坏整个游戏平衡，我们需要对发送的网络数据包中的主体部分进行加密。加密算法很多，这里不一一介绍，最简单方式就是对数据做异或处理，发送时做异或处理一次，收到时做一次异或处理，这样就能简单加密解密数据。前面说的这种方式比较单板，因为密钥Key是同一个，而且密钥KEY会暴露在客户端会被查看到，于是非对称加密是加密的首选，这样前后端两边的密钥Key不同且各自保存，即使当后端密钥泄漏时，也可以随时替换。&lt;/p&gt;

&lt;p&gt;我们这里主要聊一下网络数据包的校验能力，各种包体的协议格式下面的章节中会具体讲解，加密也同样会在最后的几节部分做出详细的介绍。&lt;/p&gt;

&lt;p&gt;在接收数据的时候，有时候会是一个不完整的包，或者一个包后面跟着另一段不完整的包，怎么办，怎么识别哪里是头，哪里是尾？嗯，这就有了数据格式的意义，通常的长连接数据格式，以头和数据块，两部分组成，比如头用4个字节组成，这4个字节是数据块得大小size，这样后面数据块得大小就能知道了，因为每次拿到网络数据的时候我先取4个字节，然后就知道了后面数据块大小，再读取size大小的数据块，这样就拿到了数据信息。
再做的复杂点，可以分成，头、固定标识信息、数据块，三个部分。头，存储包体大小信息；标识信息，存储例如句柄编号，序列号，特殊命令编号，校验码等的标识信息；数据块，存储具体的数据信息。&lt;/p&gt;

&lt;p&gt;TCP本身有做一些校验的工作，但为了防止数据被人为攥改、网络错误、以及逻辑本身的错误检测，我们需要做额外的校验工作。&lt;/p&gt;

&lt;p&gt;通常方法有几种&lt;/p&gt;

&lt;p&gt;1，    MD5校验。这种校验方式比较直接，将数据块整个用MD5散列函数生成一个校验字符串，将校验字符串保存在数据包中。当服务器收到数据包时，也做同样的操作，将数据块用MD5散列函数生成一个校验字符串，与数据包中的校验字符串进行比较，如果一致，则认为校验通过，否则就认为被人为修改过。&lt;/p&gt;

&lt;p&gt;2，    奇偶校验。奇偶校验与MD5有点类似，只是所用的函数方法不同。对每个数据进行异或赋值成一个变量，将这个变量保存在数据包中。当服务器收到数据包时，也做同样的操作，将数据快中的数据进行异或赋值成一个变量，然后将这个变量值与数据包中的校验值进行比较，如果数据一致则认为校验正确，否则则认为数据被人攥改过。&lt;/p&gt;

&lt;p&gt;这个校验算法类似于：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uCRC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//校验初始值&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DataLenth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uCRC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;^=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;3，    CRC循环冗余校验。循环冗余校验是利用除法及余数的原理来进行错误检测的.将接收到的码组进行除法运算，如果除尽，则说明数据校验正确；如果未除尽，则表明数据被认为攥改过。&lt;/p&gt;

&lt;p&gt;该算法过程如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1，    前后端约定一个除数。

    2，    将数据块用除数取余。

    3，    将余数保存在数据包中。

    4，    服务器收到数据后，将余数和数据块相加，并进行取余操作。

    5，    余数为0则认为校验正确，否则则认为数据被攥改过。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;断线检测&lt;/h6&gt;

&lt;p&gt;TCP本身就是强连接，所以自身就有断线的检测机制，但是它本身的检测机制还不够用，对断线的判断不够准确，所以我们需要加强断线检测机制，让断线判断变的更加准确和即使。&lt;/p&gt;

&lt;p&gt;为了能有效检测TCP连接是否正常，我们需要服务器和客户端达成一个协议来检测连接。我们可以取名叫心跳包协议，在心跳包协议中，每几秒服务器向客户端发送一个心跳包，包内包含了服务器时间，服务器状态等信息，然后再由客户端发送给服务器一个心跳回应包，包内包含客户端的一些信息例如客户端状态，用户信息等，这样客户端和服务器就都知道连接是有响应的，当前是连接正常。&lt;/p&gt;

&lt;p&gt;倘若没有收到心跳包和心跳回应包，就表示连接存在问题了，有可能已经断开。为了规避一些时候网络的波动，我们可以设置一个有效判断断开连接的时间间隔，比如，10秒内没有收到心跳包和心跳回应包，就表示连接已经断开，这时服务器和客户端主动断开连接，再根据游戏的逻辑寻求再次连接。&lt;/p&gt;

&lt;p&gt;这种在TCP之上，加强断线检测的做法，能更有效快速得检测到断线问题。&lt;/p&gt;
</description>
               <pubDate>Tue, 07 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/07/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%822.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/07/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%822.html</guid>
            </item>
        
    </channel>
</rss>