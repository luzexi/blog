<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title></title>
        <description>技术，哲学，金融</description>
        <link>http://www.luzexi.com</link>
        <atom:link href="http://www.luzexi.com/assets/feed.xml" rel="self" type="application/rss+xml" />
        
            <item>
               <title>读书笔记(三十七) 《心流》#1 - 寻找生命的意义</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484840&amp;amp;idx=1&amp;amp;sn=a56725615b9e43cdb1f8848b1ef54183&amp;amp;chksm=fc2260afcb55e9b9f3ee8b37a78872623bd55ec5e8151779fa477c30fb9be9c601ad3d78b43d&amp;amp;token=1126834365&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;背景&quot;&gt;背景：&lt;/h2&gt;

&lt;p&gt;在2020年初就买了《心流》，直到2021年1月才读完第一遍，刹那间开阔了我的眼界。&lt;/p&gt;

&lt;p&gt;读完本书让我的专注力提高了一个级别，这让我非常兴奋。而这只是我读了第一遍吸收到的10%都不到结果，我想它的魔力远不止于此，于是决定好好复习总结一下书本中的内容，开启了第二遍、第三遍的读书旅程。&lt;/p&gt;

&lt;p&gt;平时我在工作、生活、交流、学习时，常常很难集中注意力，因此我带着好奇心阅读了这本书。我猜大家应该也和我一样希望自己在专注做一件事情的时候能够拥有更高的效率。&lt;/p&gt;

&lt;p&gt;本书的核心是心流的最优体验，当你的心流体验最佳时是学习效率最高的时候同时也是最幸福的时刻，里面讲到了关于学习、工作、运动、交际等方面的心流原理和技巧，下面开始详细讲解一下。&lt;/p&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文：&lt;/h2&gt;

&lt;p&gt;本书的序是我所读过的书中最长的序，也是有最多名人写感悟的序，整整写了63页的序。&lt;/p&gt;

&lt;p&gt;序中写了几位高知在细品本书后的体会与感悟，这些体会与感悟给了我很多启发，同时让我对本书整体思想和逻辑有了一个大致的了解。于是本不想对序的内容进行总结的我，由于这本书的序实在太精彩，不由自主的将序也纳入了书本的内容范围，同时也侧面反映了这本书的精彩程度。&lt;/p&gt;

&lt;p&gt;作者米哈里是一位心理学家，同时他对生物学和社会学也非常关注，他认为这三大学科都是对幸福研究的重要领域。&lt;/p&gt;

&lt;p&gt;他说，动物的技巧总是能配合实际的需要，因为它们的心灵只容纳当下环境中与它们切身相关、能靠直觉判断的资讯。例如：饥饿的狮子只注意能帮助它猎到羚羊的资讯，吃饱的狮子注意力则完全集中在温暖的阳光上。&lt;/p&gt;

&lt;p&gt;人类与动物最大的差别就在于神经系统过于发达。虽然我们感知和摄取比其他动物更多的信息，这样有利于人类生存，但烦恼也更多，多知也多忧。&lt;/p&gt;

&lt;h3 id=&quot;例如金钱就困扰了我们大部分人那么金钱到底是否能让人幸福呢米哈里认为不是&quot;&gt;例如金钱就困扰了我们大部分人，那么金钱到底是否能让人幸福呢？米哈里认为不是。&lt;/h3&gt;

&lt;h3 id=&quot;虽然很多学者也有相同的看法但这其中一部分人走向了另一个极端即将幸福替代金钱将它放在最重要的位置上以前金钱的位置上他们认为幸福才是人生理当直奔的主题米哈里也否认这种判断&quot;&gt;虽然很多学者也有相同的看法，但这其中一部分人走向了另一个极端，即将幸福替代金钱，将它放在最重要的位置上（以前金钱的位置上），他们认为幸福才是人生理当直奔的主题。米哈里也否认这种判断。&lt;/h3&gt;

&lt;p&gt;事实上，幸福感通常根本不是作为目标存在于人们的追求中，它只不过是表现为目标中附带的现象。
米哈里认为，幸福是你全身心投入一桩事物，达到忘我的程度，并由此获得的内心秩序和安宁的状态。&lt;/p&gt;

&lt;p&gt;例如一位攀岩的选手，不断逼身体发挥所有的极限，直到全身隐隐作痛，然后满怀敬畏的回顾自我，回顾所做的一切，那种佩服的感觉简直无法形容。&lt;/p&gt;

&lt;h3 id=&quot;攀岩最终目的是攀岩正如写作的目的是写作一样你唯一征服的是自己的内心而不是为了到达山顶或乌托邦&quot;&gt;攀岩最终目的是攀岩，正如写作的目的是写作一样，你唯一征服的是自己的内心，而不是为了到达山顶或乌托邦。&lt;/h3&gt;

&lt;h3 id=&quot;当你全力争取胜利时其他就不那么重要了甚至连胜利本身都不重要&quot;&gt;当你全力争取胜利时，其他就不那么重要了，甚至连胜利本身都不重要。&lt;/h3&gt;

&lt;p&gt;专注的过程达到忘我的状态，虽说不是幸福的全部，但也是它很重要的一部分。&lt;/p&gt;

&lt;p&gt;练习专注的过程并不容易，我们往往要花三、五年甚至十年二十年的时间来学习剔除外部干扰、克服紧张，使自己的学习或表演能够放松、自然、快乐。可见学习快乐，并不是一件容易的事。&lt;/p&gt;

&lt;p&gt;有人认为专注某项活动精神消耗会更大，米哈里则不这么认为。&lt;/p&gt;

&lt;p&gt;他认为专注让大脑减轻了负担，心流较强的人在专注时会关闭其他资讯通道，只把注意力集中在接收闪光的刺激上。对于这种懂得如何控制意识的人而言，专注反而更轻松。&lt;/p&gt;

&lt;h3 id=&quot;专注通常伴随着挑战如果挑战不是自愿的通常无法达到心流&quot;&gt;专注通常伴随着挑战，如果挑战不是自愿的，通常无法达到心流。&lt;/h3&gt;

&lt;h3 id=&quot;如果目标太难或者太简单也同样会造成心流的消失降低幸福感和体验&quot;&gt;如果目标太难或者太简单，也同样会造成心流的消失，降低幸福感和体验。&lt;/h3&gt;

&lt;p&gt;因此首先我们要自己去寻找目标，其次要去调整目标高度，让目标有一个适合我们的难度。&lt;/p&gt;

&lt;p&gt;例如历史上贵族阶层脱离生产后，缺少了生活上的挑战，从而面临生命不能承受之轻，一部分贵族陷入物欲不能自拔，另一部分选择体育、音乐、诗歌词赋的艺术化生活方式。这种工作而非无所事事的挑战，例如攀岩、舞蹈、下棋、运动、游戏也可以造就心流。&lt;/p&gt;

&lt;p&gt;其中体育具备造就心流的最佳条件：明确的目标、即时的回馈、易学难精带来的上不封顶的挑战。&lt;/p&gt;

&lt;p&gt;它最大的功能是帮助人们控制自己：学习控制自己的身体，学习控制自己的精神，学习控制自己的注意力。&lt;/p&gt;

&lt;p&gt;这种技巧不持续练习是不会提高的，持续下去主要考的也不是耐心，而是不断发现技巧上的微妙差异，靠的是持续存在的关注点。&lt;/p&gt;

&lt;h3 id=&quot;此外书中提到了熵熵是指系统的混乱程度越混乱熵值越高反之系统内部越有规律结构越清晰熵值就越低&quot;&gt;此外，书中提到了熵，熵是指系统的混乱程度，越混乱，熵值越高。反之，系统内部越有规律，结构越清晰，熵值就越低。&lt;/h3&gt;

&lt;p&gt;例如水变成冰时熵值就很低，变成水蒸气后熵值就很大。&lt;/p&gt;

&lt;p&gt;熵延伸到我们的人身上也适用，人如果没有节制，没有经过训练，大脑常常会处于混乱状态，虽然你能意识到的可能只有少数几个念头，但在潜意识里却有很多念头在互相冲突，它们在争夺你的注意力，抢夺你的大脑的控制权，并且试图引导、影响你往南辕北辙的方向走。但是如果你进入了心流状态，那就不一样了，虽然你的大脑仍然在高速运转，但是所有这些念头都是非常有规律、有秩序的，就像一支有纪律的军队，被井井有条地组织了起来，高效地去完成一个任务。&lt;/p&gt;

&lt;h3 id=&quot;心流就是这样一个降熵的过程把原来混乱的心序重新组合成有规律的集体&quot;&gt;心流就是这样一个降熵的过程，把原来混乱的心序重新组合成有规律的集体。&lt;/h3&gt;

&lt;p&gt;当心熵比较高时一片混乱，大脑的做功能力很低，很多心理能量都浪费在内耗上了。一旦进入心流状态，心理能量就围绕着同一个主题组织起来，向同一个方向高效输出，此时人的表现也最好。&lt;/p&gt;

&lt;h3 id=&quot;如果一个人经常经历心流他的心理就会被训练得越来越有秩序以后进入心流就越来越容易即使平时不在心流状态下也不会像一般人那样心猿意马了&quot;&gt;如果一个人经常经历心流，他的心理就会被训练得越来越有秩序，以后进入心流就越来越容易，即使平时不在心流状态下，也不会像一般人那样心猿意马了。&lt;/h3&gt;

&lt;p&gt;降低心熵最典型的例子就是冥想，在冥想中，你摒除杂念，心灵澄净，如一道清澈的心流。&lt;/p&gt;

&lt;p&gt;经过长期练习之后，哪怕不在冥想之中，你的心灵也会比常人更平静，遇到意外变故时能更快地集中注意力，也就是你的心熵整体降低了。&lt;/p&gt;

&lt;p&gt;例如高僧冥想多年后才能达到波澜不惊，而我们也同样需要反复练习才能更容易进入心流，但这一切都是值得的。&lt;/p&gt;

&lt;p&gt;一些虔诚的基督徒也有同样的修为，当他们遇到生活的苦难时，也会难过，但在祷告和与亲友交流后会坦然接受这个苦难，“上帝爱我，他的安排一定自有他的深意”。&lt;/p&gt;

&lt;p&gt;这样一次次苦难中经历信念的动摇和重固的挑战，最终形成更加坚定的信仰，从而更好地指导自己生活的方方面面，这样全神贯注而又平安喜乐，就等于把整个人生过成了一场大心流。&lt;/p&gt;

&lt;p&gt;至于普通人怎么把一生过成心流体验，米哈里的建议是，首先要找一个终生的目标，其次不要害怕其复杂性，这就是对你人生意义的挑战。&lt;/p&gt;

&lt;p&gt;你可以用“行动式生活”和“反省式生活”相结合来逐步应对挑战实现你的目标，只要个人目标与宇宙心流汇合，意义的问题也就迎刃而解了。&lt;/p&gt;

&lt;p&gt;生命的意义会随着你的心流而升级，从简单舒适，到社会价值，从个人发展，到个人与社会的重新整合，不断升级，挑战也滚滚而来，生命就在这些不断挑战和升级中找到意义。&lt;/p&gt;

&lt;h3 id=&quot;其实降熵的过程有高下心流也有高下原本的混沌越多整合进去的元素越复杂这个心流就越伟大&quot;&gt;其实降熵的过程有高下，心流也有高下，原本的混沌越多，整合进去的元素越复杂，这个心流就越伟大。&lt;/h3&gt;

&lt;h3 id=&quot;也就是说那些能够整合无比复杂的人生找到人生意义整合无比复杂的世界形成自己的价值观的人就会有最大的心流&quot;&gt;也就是说，那些能够整合无比复杂的人生、找到人生意义，整合无比复杂的世界、形成自己的价值观的人，就会有最大的心流。&lt;/h3&gt;

&lt;p&gt;当然，过犹不及，米哈里有时也过分强调了集中注意力的好处。新的研究表明“注意力不集中”也是一种对健康至关重要的状态。在注意力不集中的情况下，我们的大脑大部分时间处于默认模式，这种状态是发散思维和创新的必要条件。如果能在专注一段时候后放松一下准备下一段专注，这样的持续效率会更高。&lt;/p&gt;

&lt;p&gt;说到底心流只是一个方法，其背后的逻辑是，“通过锻炼控制自己的意识，去获得真正的幸福”。&lt;/p&gt;

&lt;h3 id=&quot;如果你直接追求的并不是幸福而是把自己变得更复杂在这个变复杂的过程中你就能找到乐趣此时这个状态就是幸福&quot;&gt;如果你直接追求的并不是幸福，而是把自己变得更复杂，在这个变复杂的过程中，你就能找到乐趣，此时这个状态就是幸福。&lt;/h3&gt;

&lt;h3 id=&quot;人生要的不是最后终点的结果而是每时每刻点点滴滴成长的过程其实成长本身就是我们的目的&quot;&gt;人生要的不是最后终点的结果，而是每时每刻点点滴滴成长的过程，其实成长本身就是我们的目的。&lt;/h3&gt;

&lt;p&gt;据我所知，90%的家长在孩子学习的时候设定了过重的目标，且常常过于重视技巧和速成，使得学习成为了孩子的负担，这样孩子们自然无法从中得到快乐。
如果能把精神集中在过程上，比如优美的画面、欢快的节奏，更多的及时反馈，小目标达成的快乐，这样孩子们的体验就会更好，学习的劲头也更足。&lt;/p&gt;

&lt;p&gt;说了这么多，其实只有学会控制心灵的人才能决定自己的生活品质，而如果具备了这种能力，也就相当于接近幸福的境界了。
快乐与否，取决于内心是否和谐，就得从掌握意识着手，学习从生活中创造乐趣，多加练习就能掌握，化无聊为有趣，也就兴趣盎然了。&lt;/p&gt;

&lt;h3 id=&quot;心流的这个态度是真正的以人为本当我们做事的时候如果不在乎结果能不能给自己带来多大的利益而是专注于做这件事本身就能从中获巨大的乐趣&quot;&gt;心流的这个态度是真正的以人为本，当我们做事的时候如果不在乎结果能不能给自己带来多大的利益，而是专注于做这件事本身，就能从中获巨大的乐趣。&lt;/h3&gt;

&lt;p&gt;最后祝大家通过能心流找到人生的意义，我们下篇继续《心流》&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484840&amp;amp;idx=1&amp;amp;sn=a56725615b9e43cdb1f8848b1ef54183&amp;amp;chksm=fc2260afcb55e9b9f3ee8b37a78872623bd55ec5e8151779fa477c30fb9be9c601ad3d78b43d&amp;amp;token=1126834365&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

</description>
               <pubDate>Sun, 25 Jul 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/07/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B037</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/07/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B037</guid>
            </item>
        
            <item>
               <title>读书笔记(三十六) 《张爱玲传记》成就富家才女的落魄家族</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484831&amp;amp;idx=1&amp;amp;sn=844da82b7868b494c0d71c1713a813f5&amp;amp;chksm=fc226098cb55e98e222bcbeff2646b4fed2bbc6eb2416090a75aece54d9064258674990ccfc0&amp;amp;token=1401123908&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;背景&quot;&gt;背景：&lt;/h1&gt;

&lt;p&gt;这是一本张爱玲的他传《张爱玲-民国临水照花人》，读书前我问过自己，为什么要读这本书。&lt;/p&gt;

&lt;p&gt;大概是因为我有两个女儿的关系，使得我迫切想去了解女性的世界，包括她们的成长、她们的心理、她们的困惑、她们的烦恼等。
因此我陆陆续续读完了国民四大才女的传记，《林徽因》，《陆小曼》、《张爱玲》、《三毛》传记，我希望通过这四个民国才女来了解女性在成长和发展过程中需要经历的困惑与煎熬。&lt;/p&gt;

&lt;h3 id=&quot;直到有了女儿我才体会到女性与男性有着完全不同的路径和体验也因此在这些年读了很多关于女性书籍后更深有体会&quot;&gt;直到有了女儿我才体会到女性与男性有着完全不同的路径和体验，也因此在这些年读了很多关于女性书籍后更深有体会。&lt;/h3&gt;

&lt;p&gt;《张爱玲-民国临水照花人》这本书着实也给了我很多震撼，为此我不得不给自己留下一篇回顾性的文章， 以记录下读完此书后给我带来的感受。&lt;/p&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文：&lt;/h1&gt;

&lt;p&gt;张爱玲这一生有很多成就，同时也伴随着很多人对她的负面评价，但无论怎样她都没有被这个世界改变，她一直在活出自己，一直都是那个有才但又羞涩的少女。&lt;/p&gt;

&lt;h3 id=&quot;张爱玲祖上有许多积累她的祖父外祖父曾外祖父都是当时有名的人物比如曾外祖父就是李鸿章外祖父是张佩纶科举中榜并后来受军机处重用位于重要职务&quot;&gt;张爱玲祖上有许多积累，她的祖父、外祖父、曾外祖父都是当时有名的人物，比如曾外祖父就是李鸿章，外祖父是张佩纶科举中榜并后来受军机处重用位于重要职务。&lt;/h3&gt;

&lt;h3 id=&quot;整个家族从父亲张延重开始没落和当时许多高官的子孙一样由于祖辈只留下遗产而没有留下好的教养和精神力量因此寻花问柳和赌博是这些富家子弟的常态&quot;&gt;整个家族从父亲张延重开始没落，和当时许多高官的子孙一样，由于祖辈只留下遗产而没有留下好的教养和精神力量，因此寻花问柳和赌博是这些富家子弟的常态。&lt;/h3&gt;

&lt;h3 id=&quot;父亲张延重与长江水师提督孙女黄逸梵结婚后很快就生下女儿张爱玲后来他们又生了一个弟弟张子静&quot;&gt;父亲张延重与长江水师提督孙女黄逸梵结婚后很快就生下女儿张爱玲，后来他们又生了一个弟弟张子静。&lt;/h3&gt;

&lt;p&gt;母亲和父亲从小的家庭氛围完全不同，父亲更多的是老派作风，性格刻板拘谨，母亲则接受过开明的新式教育，风情漂亮，思想新潮，因此两人格格不入。&lt;/p&gt;

&lt;p&gt;其实张爱玲从小就在学习氛围浓重的家庭长大，父母很小开始就亲自教她读书写字，而且张爱玲也很喜欢读书，三岁就会背唐诗成了父亲的掌上明珠。&lt;/p&gt;

&lt;p&gt;好景不长，在那个动荡的时代每个家庭都处于风雨摇摆之中，虽然张家家底比较殷实没有那么辛苦，但父亲与母亲的矛盾愈演愈烈。&lt;/p&gt;

&lt;h3 id=&quot;父亲希望母亲能对自己言听计从以弥补自己多年来所承受的束缚母亲则为刚逃脱父权压制又落入夫权专横的家庭感到绝望&quot;&gt;父亲希望母亲能对自己言听计从，以弥补自己多年来所承受的束缚；母亲则为刚逃脱父权压制又落入夫权专横的家庭感到绝望。&lt;/h3&gt;

&lt;p&gt;失落和失望中父亲开始堕落，出入风月场所，吸鸦片，还带姨太太回家。母亲则喜欢洋派的派对并到处旅游，东南亚、日本、欧洲，对父亲的行为很少在意。&lt;/p&gt;

&lt;h3 id=&quot;其实最初他们两彼此也曾试图为了靠近对方改变过自己的价值观守旧的父亲为了能追随妻子的思想看起了洋书一心向往新思想的黄逸梵读起了唐诗但最终还是以失败告终&quot;&gt;其实最初他们两彼此也曾试图为了靠近对方改变过自己的价值观，守旧的父亲为了能追随妻子的思想看起了洋书，一心向往新思想的黄逸梵读起了唐诗，但最终还是以失败告终。&lt;/h3&gt;

&lt;p&gt;母亲对张爱玲的教育一直放在心上，她希望女儿得到新思想的熏陶，所以她精心为女儿安排了钢琴、英文和绘画等课程，这为张爱玲营造出了良好的艺术氛围。&lt;/p&gt;

&lt;h3 id=&quot;最终父亲与母亲还是劳燕分飞了离婚前母亲告诉父亲自己心已如木头一般父亲听了心潮涌动想到对方屡次退步已退无可退不如海阔天空放各自一条生路&quot;&gt;最终父亲与母亲还是劳燕分飞了，离婚前母亲告诉父亲自己心已如木头一般，父亲听了心潮涌动，想到对方屡次退步已退无可退不如海阔天空，放各自一条生路。&lt;/h3&gt;

&lt;p&gt;离婚后母亲过的风生水起，旅游、派对、崇尚欧美风格的时尚着装，奢华洋派的生活再一次影响了张爱玲的人生观。&lt;/p&gt;

&lt;p&gt;这些所有的经历都会使人成长，无论最后定型为哪一种性格，都是自然而然的事情，习惯了分离，就会觉得一个人往前走是种常态。&lt;/p&gt;

&lt;p&gt;在这个乱世里体会过不同的感受，张爱玲小小年纪就学会了将喜怒哀乐都转换为坚强。&lt;/p&gt;

&lt;p&gt;因此她一生对任何事情和情感的漠然令人疑惑，殊不知，张爱玲在幼时就已经修炼成风轻云淡的心态，既然要来的早晚要来，不如看淡，走好眼前的路，才是当下最好的生活。&lt;/p&gt;

&lt;p&gt;父亲对女儿的新思想教育不太支持，所以每次张爱玲向父亲要上课的学费时，父亲都是冷漠以待，因为他无法容忍妻子的影子影射到女儿的身上。&lt;/p&gt;

&lt;p&gt;父亲后来娶了新妻子，继母对张爱玲很讨厌，也很讨厌前任妻子，这让原本曾一度父女相依为命的温情在继母的影响下落到不堪的地步。&lt;/p&gt;

&lt;p&gt;最后张爱玲离家出走去了亲身母亲家里，但其实亲生母亲家中并不富有，只能维持现状，无法给张爱玲更好的环境。&lt;/p&gt;

&lt;p&gt;所以张爱玲很小就知道，唯有知识才能改变命运，当别人还在懵懂迷茫的时候，她早已开始谋划未来。&lt;/p&gt;

&lt;p&gt;当然张爱玲与母亲也有很大的隔阂，由于张爱玲从习惯了小富家小姐的环境，懒散又不太会家务，出门连路都不认得，因此让母亲很不满意，时常斥责张爱玲。&lt;/p&gt;

&lt;h3 id=&quot;饱尝巨大落差的张爱玲心里却是介意的觉得母亲是个自私的女人为了享乐还要挥霍有限的金钱对待自己的女儿却要百般计较&quot;&gt;饱尝巨大落差的张爱玲，心里却是介意的，觉得母亲是个自私的女人，为了享乐还要挥霍有限的金钱，对待自己的女儿却要百般计较。&lt;/h3&gt;

&lt;h3 id=&quot;张爱玲所经历的畸形家庭裂变和身边亲人的冷漠自私尤其是在金钱上遭受过的窘迫和难堪都深深地影响了她的人生观&quot;&gt;张爱玲所经历的畸形家庭裂变，和身边亲人的冷漠自私，尤其是在金钱上遭受过的窘迫和难堪，都深深地影响了她的人生观。&lt;/h3&gt;

&lt;p&gt;后来张爱玲在母亲的帮助下苦读，考上了香港大学。当时香港刚好在战火中，一边读书一边听炮火的经历让张爱玲刻骨铭心。&lt;/p&gt;

&lt;p&gt;张爱玲的姑姑是张爱玲生命中重要的亲人，母亲崇尚自由很早就去了国外，留下姑姑与她相伴。&lt;/p&gt;

&lt;h3 id=&quot;姑姑的品位与学识也深深影响着张爱玲在张爱玲离开上海时姑姑正在英商洋行做事后来听了别人建议投资股票失败又遇时局动荡辞职到电台工作了一段时间后又去了大光明戏院做翻译后来供职于外资企业生活还算过的悠闲&quot;&gt;姑姑的品位与学识也深深影响着张爱玲，在张爱玲离开上海时，姑姑正在英商洋行做事，后来听了别人建议投资股票失败又遇时局动荡，辞职到电台工作了一段时间后，又去了大光明戏院做翻译，后来供职于外资企业，生活还算过的悠闲。&lt;/h3&gt;

&lt;p&gt;在大学里张爱玲仍然需要一边读书一边赚取生活费，写稿的紧张节奏令张爱玲逐渐吃不消，于是她决定退学而正是走上写作的道路。&lt;/p&gt;

&lt;h3 id=&quot;在专注创作后不久张爱玲体会到了中文小说的谋篇布局畅意抒怀的创作更让她淋漓尽致发挥自己的才华曾向往的林语堂方式的英文写作远不如她书写生活中的市井生活和身边人的人生百态&quot;&gt;在专注创作后不久，张爱玲体会到了中文小说的谋篇布局，畅意抒怀的创作更让她淋漓尽致发挥自己的才华，曾向往的林语堂方式的英文写作，远不如她书写生活中的市井生活，和身边人的人生百态。&lt;/h3&gt;

&lt;h3 id=&quot;从小读红楼梦长大的张爱玲又在港大将西方作家的作品统统学过将文学精粹炼进自己的文字里形成独树一帜的风格&quot;&gt;从小读《红楼梦》长大的张爱玲，又在港大将西方作家的作品统统学过，将文学精粹炼进自己的文字里，形成独树一帜的风格。&lt;/h3&gt;

&lt;p&gt;张爱玲感情生活中，最著名也是最有争议的一段感情就是与“国民汉奸”胡兰成。&lt;/p&gt;

&lt;p&gt;胡兰成从桂系军阀到汪精卫伪政府一直走的是邪魔歪道的路线，但对于涉世不深的张爱玲来说她并没有意识到胡兰成的问题所在。&lt;/p&gt;

&lt;p&gt;汪精卫以重金拉拢胡兰成于羽翼之下，胡兰成成为他们的御用文人，汪精卫伪政府成立后胡兰成上任宣传部部长。&lt;/p&gt;

&lt;p&gt;当时的张爱玲在感情上相当于一张白纸，而胡兰成则早已经历了风风雨雨无论情场还是职场都是老手了，加之胡兰成在文学上有一些造诣让张爱玲很快就沦陷了。&lt;/p&gt;

&lt;p&gt;胡兰成一介寒士爬到如今的位置，那些上流社会的美好始终在他心中梦一般的存在着，不曾想到这一切在张爱玲心里竟不值一提。&lt;/p&gt;

&lt;p&gt;高傲的张爱玲自有她的万丈光芒，无须以自己的家世来衬托，她的不屑与他的渴望形成了鲜明的讽刺。&lt;/p&gt;

&lt;p&gt;但是胡兰成的细腻还是将张爱玲的骄傲清冷融化，令她产生出多年来从而有过的归属感。他与她之间共生出的默契是张爱玲从未感受过的强烈洪流。&lt;/p&gt;

&lt;p&gt;坊间的俗语，流氓不可怕，就怕流氓有文化，来形容胡兰成很是贴切。而常年孤僻生活和写作的幻想空间，使得张爱玲脱离了现实，她常常拿小说里的经验来判断胡兰成对待她的真伪。&lt;/p&gt;

&lt;p&gt;胡兰成在张爱玲结束前就有三位妻子，结婚后又与女同事出轨，在日本战败后逃离中又与好友家中的寡妇联结，最后张爱玲忍无可忍分手道别。&lt;/p&gt;

&lt;p&gt;可惜已经太晚，张爱玲已经背负了汉奸之妻的身份，出门也要伪装自己以免被人认出。&lt;/p&gt;

&lt;h3 id=&quot;母亲回国后看到张爱玲的样子认为她沉浸在小城市里裹足不前应该去往更远的地方看看世界提高眼界&quot;&gt;母亲回国后看到张爱玲的样子，认为她沉浸在小城市里裹足不前，应该去往更远的地方看看世界，提高眼界。&lt;/h3&gt;

&lt;h3 id=&quot;此时母亲自身的能力非常出色在国外做尼赫鲁两姐妹的社交秘书因此对于沉浸在小情小调文字中的张爱玲不屑一顾甚至有几分怒其不争的愤慨&quot;&gt;此时母亲自身的能力非常出色，在国外做尼赫鲁两姐妹的社交秘书，因此对于沉浸在小情小调文字中的张爱玲不屑一顾，甚至有几分怒其不争的愤慨。&lt;/h3&gt;
&lt;p&gt;那个年轻风情文雅的母亲早已消失不见，站在眼前的是一个强势又自我的老太婆。&lt;/p&gt;

&lt;p&gt;张爱玲太过了解母亲黄逸梵，从小与父母有隔阂的张爱玲羞于喊出“妈妈”这般亲昵的字眼，母亲当年给她心理造成的阴影，让她一直以“婶婶”相称。&lt;/p&gt;

&lt;h3 id=&quot;同时在母亲回来看女儿的时刻张爱玲提出了要用二两金子还清母女之情母亲得知女儿的意思后潸然泪下后婉拒了女儿又踏上了出国的旅程&quot;&gt;同时在母亲回来看女儿的时刻，张爱玲提出了要用二两金子还清母女之情，母亲得知女儿的意思后潸然泪下后婉拒了女儿，又踏上了出国的旅程。&lt;/h3&gt;

&lt;h3 id=&quot;张爱玲一生未育当然也无法体会母亲年轻时候所承受的一切而只是执拗地刺激着给了她生命的母亲&quot;&gt;张爱玲一生未育，当然也无法体会母亲年轻时候所承受的一切，而只是执拗地刺激着给了她生命的母亲。&lt;/h3&gt;

&lt;h3 id=&quot;其实母女两人都是极端自我的女子不同的是黄逸梵不仅学历高交际手腕也高明还有非常远大的追求张爱玲则大学没有上完因此没有大学毕业证更不擅长为人处世&quot;&gt;其实母女两人都是极端自我的女子，不同的是，黄逸梵不仅学历高，交际手腕也高明，还有非常远大的追求；张爱玲则大学没有上完因此没有大学毕业证，更不擅长为人处世。&lt;/h3&gt;

&lt;p&gt;与胡兰成离婚后，张爱玲用剧本拍了几部电影非常火热，还与导演桑弧热恋，桑弧是个非常擅长人情世故的人，这是因为在电影行业里必定要学会处世才能混得风生水起。&lt;/p&gt;

&lt;h3 id=&quot;但谈到结婚生子时张爱玲是抗拒的她往前看似乎能看到未来的路上有一个身影重叠着自己年少时的孤独和恐惧她不想重蹈母亲的覆辙她恨母亲的自私但同时她也是与母亲一样的女人没有能力去爱护幼小的生命&quot;&gt;但谈到结婚生子时，张爱玲是抗拒的，她往前看似乎能看到未来的路上有一个身影，重叠着自己年少时的孤独和恐惧，她不想重蹈母亲的覆辙，她恨母亲的自私，但同时她也是与母亲一样的女人，没有能力去爱护幼小的生命。&lt;/h3&gt;

&lt;p&gt;与导演桑弧分手后张爱玲回到了香港大学，继续漂泊继续流浪，漂泊对她与母亲来说似乎已经成为了一种信仰。&lt;/p&gt;

&lt;h3 id=&quot;在香港她认识了邝文美邝文美相貌不仅秀丽端庄又是个学识有见地的才女她的温柔像一条薄厚相宜的毯子柔软的话语覆盖过来让张爱玲四肢百骸都放松下来像遇见多年未见的幼年伙伴怎么说话也说不完&quot;&gt;在香港她认识了邝文美，邝文美相貌不仅秀丽端庄，又是个学识、有见地的才女，她的温柔像一条薄厚相宜的毯子，柔软的话语覆盖过来，让张爱玲四肢百骸都放松下来，像遇见多年未见的幼年伙伴怎么说话也说不完。&lt;/h3&gt;

&lt;h3 id=&quot;在那个人人都想出人头地的时代邝文美始终以家庭为重将家庭和事业经营得有声有色她放弃了荣华富贵的机遇不攀附权贵却愿意和远在异乡的张爱玲结为知己&quot;&gt;在那个人人都想出人头地的时代，邝文美始终以家庭为重，将家庭和事业经营得有声有色。她放弃了荣华富贵的机遇，不攀附权贵，却愿意和远在异乡的张爱玲结为知己。&lt;/h3&gt;

&lt;h3 id=&quot;邝文美在生活里应付自如的涵养恰到好处地弥补了张爱玲不理俗事的弱点邝文美本就对张爱玲非常欣赏又加之她深谙人性特点在这样的友谊中她不但能理解张爱玲天真的幼稚亦能包容她不明世故的观点&quot;&gt;邝文美在生活里应付自如的涵养，恰到好处地弥补了张爱玲不理俗事的弱点。邝文美本就对张爱玲非常欣赏，又加之她深谙人性特点，在这样的友谊中，她不但能理解张爱玲天真的幼稚，亦能包容她不明世故的观点。&lt;/h3&gt;

&lt;p&gt;1953年美国放开移民政策，张爱玲在麦卡锡的担保下离开了香港去往美国。在那里她邂逅了共度半生的美国作家普德南.赖雅。&lt;/p&gt;

&lt;p&gt;赖雅是位德国移民后裔，在哈弗大学读到文艺硕士毕业后，从事英文教室工作。在艺术方面天赋极高，不仅文学作品优秀，摄影也非常出色。先后担任欧洲战地记者，自由撰稿人，欧洲采访知名作家等，经历非常丰富。&lt;/p&gt;

&lt;p&gt;但此时赖雅已经65岁了，而张爱玲才36岁，她曾坦言：一向对于年纪大一点的人感到亲切，对于和自己年纪差不多的人则有点看不起。&lt;/p&gt;

&lt;p&gt;在美国几年后，收到了母亲病重的来信，而张爱玲只写了封信，寄上100美元的支票安慰母亲，让她好好治病。&lt;/p&gt;

&lt;p&gt;母亲在她心里一直都是个强大的女人，她在追求自由的道路上，是个快乐的女神，怎么会被疾病轻易击垮？多年来在两人之间的隔膜已经深成了跨不过去的沟壑。&lt;/p&gt;

&lt;h3 id=&quot;张爱玲同时也流掉了与丈夫赖雅的孩子这与张爱玲从小缺乏家庭关爱不无关系&quot;&gt;张爱玲同时也流掉了与丈夫赖雅的孩子，这与张爱玲从小缺乏家庭关爱不无关系。&lt;/h3&gt;

&lt;h3 id=&quot;母亲黄逸梵手术后不久就离开了人世张爱玲默然承受着这个结果没能满足母亲最后的愿望张爱玲为此大病一场&quot;&gt;母亲黄逸梵手术后不久，就离开了人世，张爱玲默然承受着这个结果，没能满足母亲最后的愿望，张爱玲为此大病一场。&lt;/h3&gt;

&lt;h3 id=&quot;母亲走了为女儿留下一箱古董黄逸梵在病体难抗的绝境里完全可以卖掉古董来治病一向有见地的她并没有这么做而是留给了女人张爱玲这是母亲对张爱玲最后的眷恋&quot;&gt;母亲走了为女儿留下一箱古董，黄逸梵在病体难抗的绝境里，完全可以卖掉古董来治病，一向有见地的她并没有这么做，而是留给了女人张爱玲，这是母亲对张爱玲最后的眷恋。&lt;/h3&gt;

&lt;p&gt;黄逸梵从张爱玲四岁起就离开了上海前往国外，从此爱上了独自旅行。&lt;/p&gt;

&lt;h3 id=&quot;她跑到欧洲的学校学绘画又去了马来西亚的华侨学校教书在瑞士的阿尔卑斯山上这个三寸金莲的美丽女子勇敢从山顶往下飞滑在游历过程中所邂逅的情人无不是浪漫多情又绅士的外国男子这让她品尝到了爱情的真谛从家庭角度讲黄逸梵并不是个称职的母亲但却对张爱玲的成长有着很深的影响面对封建旧式家庭的规矩她毅然站出来拒绝女儿缠足还自作主张教导女儿英语钢琴从而也使得张爱玲熏陶到良好的西方文化&quot;&gt;她跑到欧洲的学校学绘画，又去了马来西亚的华侨学校教书，在瑞士的阿尔卑斯山上，这个三寸金莲的美丽女子勇敢从山顶往下飞滑。在游历过程中所邂逅的情人，无不是浪漫多情又绅士的外国男子，这让她品尝到了爱情的真谛。从家庭角度讲，黄逸梵并不是个称职的母亲，但却对张爱玲的成长有着很深的影响，面对封建旧式家庭的规矩，她毅然站出来拒绝女儿缠足，还自作主张教导女儿英语、钢琴，从而也使得张爱玲熏陶到良好的西方文化。&lt;/h3&gt;

&lt;h3 id=&quot;虽然母女俩不常见面张爱玲在心里将母亲当作偶像张爱玲对事业的追求和我行我素的风格以及爱情上的观念甚至是后来漂泊海外的流浪旅途都与母亲有着惊人的吻合她们是相爱相杀的母女黄逸梵的洒脱是留给张爱玲的华丽背影也是投射在她心灵深处的阴影&quot;&gt;虽然母女俩不常见面，张爱玲在心里将母亲当作偶像，张爱玲对事业的追求和我行我素的风格，以及爱情上的观念，甚至是后来漂泊海外的流浪旅途都与母亲有着惊人的吻合，她们是相爱相杀的母女，黄逸梵的洒脱是留给张爱玲的华丽背影，也是投射在她心灵深处的阴影。&lt;/h3&gt;

&lt;p&gt;1967年赖雅去世，张爱玲心情降到冰点。但天亮了，张爱玲还要将写作进行下去，生命的真相有时候没必要去追根究底，因为宿命的安排或是性格上的原因，也许是一个人最简单的寄托。&lt;/p&gt;

&lt;h3 id=&quot;张爱玲的弟弟张子静在新中国成立后在上海浦东一所小学任教先后又更换了几所学校于1986年正式退休搬到江苏路的一个14平方米小屋居住这是父亲败光家产后遗留给他的最后遗产&quot;&gt;张爱玲的弟弟张子静在新中国成立后在上海浦东一所小学任教，先后又更换了几所学校，于1986年正式退休搬到江苏路的一个14平方米小屋居住，这是父亲败光家产后遗留给他的最后遗产。&lt;/h3&gt;

&lt;p&gt;1953年父亲张延重肺病去世，继母所依赖房屋被政府回收后的定息也在文革爆发后停止发放。1970年继母双目失明，弟弟给她请了个保姆，1986年离世。&lt;/p&gt;

&lt;p&gt;1983年弟弟联系到张爱玲并劝姐姐回国，但张爱玲拒绝了弟弟的请求，并告诉他能保持书信就好。&lt;/p&gt;

&lt;h3 id=&quot;到了晚年张爱玲再读红楼梦时在书中读出了整个张氏大家族与贾府相似的命运从而让她对世事产生出悲凉之感&quot;&gt;到了晚年，张爱玲再读《红楼梦》时在书中读出了整个张氏大家族与贾府相似的命运，从而让她对世事产生出悲凉之感。&lt;/h3&gt;

&lt;h3 id=&quot;她年轻时争名夺利的性情如风过已是了无痕往事已过去多年她对人生有了新的认识不再是浮于表面的浅薄&quot;&gt;她年轻时争名夺利的性情，如风过，已是了无痕。往事已过去多年，她对人生有了新的认识，不再是浮于表面的浅薄。&lt;/h3&gt;

&lt;h3 id=&quot;虽是个老太太举止言谈间却完全是一个自闭的少女状态但神清里有说不出的柔和恬静遇事的时候也已经能够泰然自若&quot;&gt;虽是个老太太，举止言谈间却完全是一个自闭的少女状态，但神清里有说不出的柔和恬静，遇事的时候也已经能够泰然自若。&lt;/h3&gt;

&lt;p&gt;晚年整理回忆录《对照记》时，选了100多幅她与家人、朋友的照片，母亲、姑姑、闺蜜和她的风华正茂，都定格在光影里。&lt;/p&gt;

&lt;p&gt;其中最为经典的是那张，最具张爱玲风范，她的脸庞轻轻上扬，眼睛望向侧上方，穿着缎子做的高领短袖，如生在世间的一枝兰，高傲贵气又出尘。&lt;/p&gt;

&lt;p&gt;1995年9月8日，张爱玲去世在自己的公寓里，旁边的书桌上是一叠铺开的稿纸和一支未合上的笔。&lt;/p&gt;

&lt;h3 id=&quot;张爱玲在遗嘱中把所有的遗产都留给了邝文美&quot;&gt;张爱玲在遗嘱中把所有的遗产都留给了邝文美。&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484831&amp;amp;idx=1&amp;amp;sn=844da82b7868b494c0d71c1713a813f5&amp;amp;chksm=fc226098cb55e98e222bcbeff2646b4fed2bbc6eb2416090a75aece54d9064258674990ccfc0&amp;amp;token=1401123908&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

</description>
               <pubDate>Sat, 17 Jul 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/07/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B036</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/07/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B036</guid>
            </item>
        
            <item>
               <title>读书笔记(三十五) 《如何高效阅读 - 下》</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484825&amp;amp;idx=1&amp;amp;sn=72548c4cb8aaf9961b3ea77cc0905ba6&amp;amp;chksm=fc22609ecb55e988c328a3a7b71c9614dd6e5d4b0df369ffd8d5275603ab7afd3ec9e01b036a&amp;amp;token=1401123908&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;背景&quot;&gt;背景：&lt;/h1&gt;

&lt;p&gt;与前两本《如何阅读》、《如何阅读一本书》相比《如何有效阅读一本书》这本书更加注重阅读实用技巧，从选书、读书、笔记、重读四个方面详细讲解了作者自己在实践过程中的经验。&lt;/p&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文：&lt;/h1&gt;

&lt;p&gt;全书11万字分为五个部分，选书、读书、笔记、重读、实用技巧。&lt;/p&gt;

&lt;h1 id=&quot;如何选书&quot;&gt;如何选书？&lt;/h1&gt;

&lt;h3 id=&quot;书有很多种好坏也是天差地别坏书不仅会浪费我们很多时间还会灌输我们错误的观念因此如何选书如何选好书就成提高读书效率的关键&quot;&gt;书有很多种，好坏也是天差地别，坏书不仅会浪费我们很多时间，还会灌输我们错误的观念。因此如何选书，如何选好书就成提高读书效率的关键。&lt;/h3&gt;

&lt;p&gt;作者提到选书最重要的是主动选择而不是被动选择，主动去做筛选会比被动的选择遇到好书的概率要大的多。&lt;/p&gt;

&lt;p&gt;有这四个途径可以提高选到好书的概率：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;生活中大众认可的经典书籍&lt;/li&gt;
  &lt;li&gt;自己看过的好书中提到的书&lt;/li&gt;
  &lt;li&gt;告知人书评中提到的好书&lt;/li&gt;
  &lt;li&gt;知识品位高的朋友提到的好书&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;选书的过程中，我们依然要保持警惕，时时刻刻主动选择而不是被动被推荐无脑接受。&lt;/p&gt;

&lt;p&gt;有时候看到好书不一定要买，其实各领域的好书有很多，如果不是你当下需要的书，即使是好书买来也没有用，堆积在那里会成为你的心里负担。&lt;/p&gt;

&lt;h3 id=&quot;我们应该尽量做到当真正需要的时候才购买买回来尽量立即看起来而不是认为是好书就买了堆积在那里给自己造成心里负担其实买了没看也会给自己造成挫败感&quot;&gt;我们应该尽量做到，当真正需要的时候才购买，买回来尽量立即看起来，而不是认为是好书就买了堆积在那里给自己造成心里负担，其实买了没看也会给自己造成挫败感。&lt;/h3&gt;

&lt;p&gt;作者说除了选好书，我们也需要一些能与自己长期共处的书，当失落时、走投无路时，那本书会成为我们的心灵支柱。&lt;/p&gt;

&lt;h1 id=&quot;如何读书&quot;&gt;如何读书？&lt;/h1&gt;

&lt;p&gt;提高读书效率的一个重要指标就是养成好习惯，这个习惯包括：坚持每日读书的习惯，坚持做读书笔记的习惯，坚持重读巩固复习的习惯。&lt;/p&gt;

&lt;p&gt;其中做笔记的方法和技巧，以及重读的技巧特别重要，这两个话题在下面的内容中会详细介绍。&lt;/p&gt;

&lt;h3 id=&quot;前面说要读好书但其实现实中坚持只选好书只读好书可能不太现实我们可以张弛有度地贯彻好书要细细研读其他书则粗读略读原则这样会让读书效率更高&quot;&gt;前面说要读好书，但其实现实中坚持“只选好书，只读好书”可能不太现实，我们可以张弛有度地贯彻“好书要细细研读，其他书则粗读略读”原则，这样会让读书效率更高。&lt;/h3&gt;

&lt;h3 id=&quot;其次在读书过程中积极的跳读和略读并在比较难理解的部分换上低速齿轮认真品读保持读书张弛有度的节奏可以把更多精力集中在好书的精华内容上这样读书效率会更高&quot;&gt;其次在读书过程中，积极的“跳读”和“略读”，并在比较难理解的部分换上低速齿轮认真品读，保持读书张弛有度的节奏，可以把更多精力集中在好书的精华内容上，这样读书效率会更高。&lt;/h3&gt;

&lt;h3 id=&quot;最后读书的目的是用自己的方式去学习而不是模仿别人的方法因此在读书学习过程中用自己的方法吸收学到的知识才是最重要的再根据书中提到的技巧加以改进这样的学习效率会更高&quot;&gt;最后读书的目的是用自己的方式去学习，而不是模仿别人的方法。因此在读书学习过程中，用自己的方法吸收学到的知识才是最重要的，再根据书中提到的技巧加以改进，这样的学习效率会更高。&lt;/h3&gt;

&lt;p&gt;我们可以看到整个读书流程为：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;主动选择好书&lt;/li&gt;
  &lt;li&gt;只购买真正要看的书&lt;/li&gt;
  &lt;li&gt;读书并记录&lt;/li&gt;
  &lt;li&gt;读后总结与评价&lt;/li&gt;
  &lt;li&gt;复习与巩固&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;为什么要做笔记&quot;&gt;为什么要做笔记？&lt;/h1&gt;

&lt;p&gt;我们要学的东西实在太多，而我们的人脑记忆力又非常有限，无法在同一时间记住太多的知识和信息。&lt;/p&gt;

&lt;h3 id=&quot;学了忘忘了学如此往复效率太差笔记就给予了我们快速恢复记忆的途径它不但可以帮助我们快速恢复记忆还可以帮助我们加深记忆让知识记忆的保存时间更长一些&quot;&gt;学了忘，忘了学，如此往复效率太差。笔记就给予了我们快速恢复记忆的途径，它不但可以帮助我们快速恢复记忆，还可以帮助我们加深记忆，让知识记忆的保存时间更长一些。&lt;/h3&gt;

&lt;p&gt;我们在做笔记时就相当于在做归纳和重读，特别是当我们要把笔记写成文章发表出去时，我们会不自觉的更加仔细、小心并且反复琢磨知识要点。&lt;/p&gt;

&lt;p&gt;即使不发表读书文章，你也会发现，在读完一本书后其实记不住多少内容，只有对书中内容做出反应，进行主动思考，才能真正掌握这本书的内容。&lt;/p&gt;

&lt;p&gt;读书笔记就是这种帮助我们升华的工具，可以让读书活动完成从生搬硬套到独创思维的飞跃。&lt;/p&gt;

&lt;p&gt;其实日常生活中说的所谓“理解精髓”就够了只是个美好的愿望，你不把整个知识理顺了并记录下来，即使长期读书的人也会在很长时间后把看过的书忘得一干二净。&lt;/p&gt;

&lt;h3 id=&quot;如果只是这样读过就等于没有读过如果只是用眼睛看过而没有记在脑子里读再多的书也都会忘记&quot;&gt;如果只是这样读过，就等于没有读过。如果只是用眼睛看过，而没有记在脑子里，读再多的书也都会忘记。&lt;/h3&gt;

&lt;h3 id=&quot;读完每本书如果都能有扎实的收获那么每个月读多少本书一本书花几小时读完的能力在这个目标面前都是苍白无力的&quot;&gt;读完每本书如果都能有扎实的收获，那么每个月读多少本书，一本书花几小时读完的能力，在这个目标面前都是苍白无力的。&lt;/h3&gt;

&lt;h3 id=&quot;认真选择每一本满足自己需求的书然后真挚地与每一本书对话努力从书中学到知识这才是明智的做法&quot;&gt;认真选择每一本满足自己需求的书，然后真挚地与每一本书对话，努力从书中学到知识，这才是明智的做法。&lt;/h3&gt;

&lt;p&gt;当达到这样读书后扎实收获的目标后，再去训练更快的读书速度其实也为时不晚。&lt;/p&gt;

&lt;p&gt;当你以思想输出为前提去读书时，思想输入的质量也会提升，亲手写文章的好处比你想象的大很多。&lt;/p&gt;

&lt;p&gt;当你一遍遍思考如何写文章时，不由自主的就多读了几遍书，尤其是对没有读懂的部分，在不断思考和不断重读过程中，你对书本知识的理解也进入到了更深层次的境界。&lt;/p&gt;

&lt;p&gt;如果你以输出为目的去读书，那么读书的质量和效率会很高。&lt;/p&gt;

&lt;h3 id=&quot;如果读书的目标是写读书笔记那么读书效率会比随便读一读要高出很多如果你以发表自己的理解和总结性文章为目标那么你的读书效率会更高如果你以输出讲座为目标那么你的读书效率会特别高&quot;&gt;如果读书的目标是写读书笔记，那么读书效率会比随便读一读要高出很多，如果你以发表自己的理解和总结性文章为目标，那么你的读书效率会更高，如果你以输出讲座为目标，那么你的读书效率会特别高。&lt;/h3&gt;

&lt;h3 id=&quot;道理很简单因为当我们知道自己要在别人面前表达自己的想法后我们才会去调查那些我们从未在意过的出处资料重新审视自己的观点建立起系统的知识体系这时你会发现这个补充学习的过程就像从零学起一样需要费不少功夫而能够正视这些辛苦工作的人最后都不再对知识一知半解了&quot;&gt;道理很简单因为当我们知道自己要在别人面前表达自己的想法后，我们才会去调查那些我们从未在意过的出处、资料，重新审视自己的观点，建立起系统的知识体系。这时你会发现，这个补充学习的过程就像从零学起一样，需要费不少功夫。而能够正视这些辛苦工作的人，最后都不再对知识一知半解了。&lt;/h3&gt;

&lt;h3 id=&quot;因此掌握再多信息如果不去积极输出也无法形成知识体系&quot;&gt;因此掌握再多信息，如果不去积极输出，也无法形成知识体系。&lt;/h3&gt;

&lt;h1 id=&quot;如何做笔记&quot;&gt;如何做笔记？&lt;/h1&gt;

&lt;p&gt;有时你可能感觉到没什么可写的，但只要你拿起笔来随便写两句，说不定就有惊喜等着你。&lt;/p&gt;

&lt;p&gt;读书笔记三步骤：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;读书&lt;/li&gt;
  &lt;li&gt;划重点&lt;/li&gt;
  &lt;li&gt;写读后总结&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;读书阶段，要在书上做一些简单的记号，为写读书笔记做准备。&lt;/p&gt;

&lt;p&gt;这里作者介绍了自己的读书方法：&lt;/p&gt;

&lt;p&gt;第一遍通读时，把有价值的页折起来，&lt;/p&gt;

&lt;p&gt;第二遍重读时只读折起来的部分，并且认为重要的划线或标记，&lt;/p&gt;

&lt;p&gt;第三遍再重读时只读划线和标记部分，认为精华的部分摘抄到笔记里。&lt;/p&gt;

&lt;p&gt;最后把摘抄的精华加上自己的理解把它们写成文章。&lt;/p&gt;

&lt;p&gt;作者自己发明了葱郁火锅笔记法，它有两部分组成：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;摘抄下重要语句&lt;/li&gt;
  &lt;li&gt;下方写上自己的感受&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;即重要的内容摘抄下来，下面写下自己的感想和评论。（摘抄和评论交替进行，趁着自己印象还鲜明写下自己的感想）&lt;/p&gt;

&lt;p&gt;作者认为，自己当下的想法才是最重要的，摘抄这一段文章的原因和自己当时的想法才是日后值得参考的贵重资料。&lt;/p&gt;

&lt;h1 id=&quot;如何重读与巩固&quot;&gt;如何重读与巩固？&lt;/h1&gt;

&lt;p&gt;读完一本书后的时间越长，在读书时产生的环境变化就会越模糊，你就越能冷静地看待书中的观点。&lt;/p&gt;

&lt;p&gt;因此不要在意一本书读完已经搁置了多久，再次重读时会有别样的风味。&lt;/p&gt;

&lt;p&gt;重读笔记的时间点：
睡觉前、洗完澡后、晚饭后、思绪进入死胡同时，可以是碎片时间也最好是安静的环境。&lt;/p&gt;

&lt;p&gt;重读习惯养成：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;量化重读频率，每周一次或者三天一次。&lt;/li&gt;
  &lt;li&gt;多种重读方式交替进行&lt;/li&gt;
  &lt;li&gt;重读后写复习总结并发布到博客上&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;多种重读方式：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;想要简单回顾时，重读读书笔记&lt;/li&gt;
  &lt;li&gt;想回忆起更多时，参考书中的重点段落&lt;/li&gt;
  &lt;li&gt;想从头开始看起时，重读原书&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;每一次的复习总结都是对自己知识的再回顾和再理解把这些复习总结放到博客上同样可以作为思想输出的一部分而且每次复习总结后都会让自己对这部分知识理解的更加透彻记忆也更加久远&quot;&gt;每一次的复习总结都是对自己知识的再回顾和再理解，把这些复习总结放到博客上同样可以作为思想输出的一部分，而且每次复习总结后都会让自己对这部分知识理解的更加透彻，记忆也更加久远。&lt;/h3&gt;

&lt;h1 id=&quot;吸收知识的重要手段主题阅读&quot;&gt;吸收知识的重要手段主题阅读&lt;/h1&gt;

&lt;h3 id=&quot;同一个主题的选出三本以上的书同时阅读或者依次阅读读完记录要点做笔记再把三本笔记合起来写一篇文章这篇文章就相当于是让三个专家围绕某个问题给自己提意见让他们进行讨论而我则思考并听取意见&quot;&gt;同一个主题的选出三本以上的书同时阅读或者依次阅读，读完记录要点，做笔记，再把三本笔记合起来写一篇文章，这篇文章就相当于是让三个专家围绕某个问题给自己提意见，让他们进行讨论而我则思考并听取意见。&lt;/h3&gt;

&lt;p&gt;经过整理和总结后，渐渐的得出一些自己的结论，这些结论是由三个专家共同讨论得出的，这样的结论比较客观且符合当下的情况。&lt;/p&gt;

&lt;h3 id=&quot;让读书百遍更轻松的方法就是阅读读书笔记通过读书笔记缩短复习时间提高记忆恢复速度以笔记内容为线索回忆整个读书过程达到快速恢复记忆的目的&quot;&gt;让读书百遍更轻松的方法就是阅读读书笔记，通过读书笔记缩短复习时间、提高记忆恢复速度，以笔记内容为线索回忆整个读书过程，达到快速恢复记忆的目的。&lt;/h3&gt;

&lt;h1 id=&quot;读书实用技巧&quot;&gt;读书实用技巧&lt;/h1&gt;

&lt;p&gt;作者列举了20条读书实用技巧，这里我筛选了一部分因为有些确实没什么用处，也是结合我实际阅读学习过程中的经验：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;读书过程中多用参考书，地图、图鉴、统计数据、百科全书、年表、词典等帮助自己加深理解书中内容。&lt;/li&gt;
  &lt;li&gt;随机阅读，偶尔阅读一些自己从来没有接触过领域的书籍，打破你的常规思维，有时候这种方式会给你一种豁然开朗的感觉。&lt;/li&gt;
  &lt;li&gt;由浅入深的吃透难懂的书，太难的书会让我们有强烈的挫败感，不如先从入门版、图解版、漫画版、精编版开始阅读，逐步熟悉、理解、渗透，最后再去阅读原著能收获更多的成就感和自信。&lt;/li&gt;
  &lt;li&gt;把书份分类堆放，未阅读的、阅读过的、已经做过笔记的、已经写好总结文章，并且分类摆放，这样会给自己一个方向，随着时间推移读完的和做完笔记的书堆放的会越来越多，会有更多的成就感，也激励自己阅读更多的书。&lt;/li&gt;
  &lt;li&gt;把经典名著放在枕头边，这些书比较难度，我们可以睡觉前看两页慢慢读，反复读几年也非常好，因为这些书是经得起考验的，读的次数阅读读的时间越久，我们从中吸取的知识就越多。&lt;/li&gt;
  &lt;li&gt;同时阅读几本书，为了减少自己在读书时的枯燥感，三本书的领域应该是不一样的，当我们觉得一本书读的很痛苦时就可以换另外一本读，从而增加愉悦感保持心灵舒畅。&lt;/li&gt;
  &lt;li&gt;在办公桌和家里的每个角落都放满书，给自己一个身边满是书的氛围，同时当我们想看书的时候就可以随时抓到一本，不给自己找更多没有书看的理由。&lt;/li&gt;
  &lt;li&gt;去掉外封面让读书变得轻松，有多书的外封面有自己的宣传设计，这些外封面在读书的时候很不舒服，不如去掉它们给自己一个轻松的书。&lt;/li&gt;
  &lt;li&gt;用边撕边读的方式阅读杂志，并不一定要从头到尾顺序读，读完的就撕下来扔进垃圾桶。&lt;/li&gt;
  &lt;li&gt;偶尔的音频、视频读书也是一种读书的一种方式，当读书累的时候可以换一下轻松的方式阅读，特别读不熟悉的领域时这种轻松的方式可能会让我们更加容易的跨过这道门槛。&lt;/li&gt;
  &lt;li&gt;买一支你喜欢的钢笔，读书笔记时一直用它，这会带动我们写文章的热情，会有总想用这支笔写点什么感觉，同时调节钢笔出水、吸墨、擦拭等也能激发我们的写作热情。&lt;/li&gt;
  &lt;li&gt;把自己信奉的名言贴在显眼的位置，让自己更有长远的目标和行动指南。&lt;/li&gt;
  &lt;li&gt;从摘抄开始写作，写文章时时常会遇到瓶颈，我们可以尝试先把喜欢的文章抄写下来，抄写的同时自己想写的东西会从脑中涌现出来。&lt;/li&gt;
  &lt;li&gt;写好的文章打印出来，这样更方便我们随手翻阅，也更容易帮助我们重组知识创建出新的点子。&lt;/li&gt;
  &lt;li&gt;记录读书的时间过程，在书的首页上，记下自己的名字、购买日期、阅读结束日期、标记结束日期、完成读书标记日期，不但让自己的读书过程更清晰，也让这本书完完全全归属了我们。&lt;/li&gt;
  &lt;li&gt;经常整理书籍摆放归类，经常整理自己的读书笔记，会让自己在读书习惯，以及复习巩固时有更好的提升。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484825&amp;amp;idx=1&amp;amp;sn=72548c4cb8aaf9961b3ea77cc0905ba6&amp;amp;chksm=fc22609ecb55e988c328a3a7b71c9614dd6e5d4b0df369ffd8d5275603ab7afd3ec9e01b036a&amp;amp;token=1401123908&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

</description>
               <pubDate>Mon, 12 Jul 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/07/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B035</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/07/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B035</guid>
            </item>
        
            <item>
               <title>读书笔记(三十四) 《C++ Primer》#6</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484819&amp;amp;idx=1&amp;amp;sn=229a9bb2eb6ca5fd7322c8b85bae6d8f&amp;amp;chksm=fc226094cb55e98229f537079c784bcf16f42579928fd034b46a69a953f6ddab28f1b4cf3c1c&amp;amp;token=1401123908&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;背景&quot;&gt;背景：&lt;/h1&gt;

&lt;p&gt;我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意。第三是当我们在巩固时创造出了新的知识，那么这些新的知识和旧的知识将同时变成智慧融合到身体中。&lt;/p&gt;

&lt;p&gt;本系列基于《C++ Primer》学习，由于重点放在“重学”，我略过了滚瓜烂熟的部分，挑出以前常忽略的部分，以及记忆没有那么深刻的部分，特别是那些重要的但没有上心的部分。&lt;/p&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文：&lt;/h1&gt;

&lt;p&gt;本文是全书总结的最后部分，在总结的同时我又重读了一遍整本书，对各个知识点的理解又加深了许多，希望这些回顾对各位都有所帮助。&lt;/p&gt;

&lt;h3 id=&quot;模版编程&quot;&gt;模版编程&lt;/h3&gt;

&lt;p&gt;模版有两种，一种是类型模版参数，另一种是非类型模版参数。&lt;/p&gt;

&lt;p&gt;两种类型模版都是由编译器生成的代码，当两个不同的数据类型使用同一个模版时，会在模版实例化时生成的两份不同的代码。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;template&amp;lt;typename T&amp;gt;
T compare(const T v1, const T v2)
{
    return v1 - v2;
}

count &amp;lt;&amp;lt; compare(1, 0) &amp;lt;&amp;lt; endl; // 编译器会生成 int compare(const int , const int)
count &amp;lt;&amp;lt; compare(1.3F, 2.3F) &amp;lt;&amp;lt;endl; // 编译器会生成 int compare(const float, const float)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译器发现有两种数据类型分别调用了模版函数compare，此时编译器会生成两个版本的compare，应用在Class模版也是同样的道理。&lt;/p&gt;

&lt;p&gt;另一种是非类型模版，意思是参数为指定常量，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;template&amp;lt;unsigned N, unsigned M&amp;gt;
int compare(const char (&amp;amp;p1)[N], const char (&amp;amp;p2)[M])
{
    return strcmp(p1, p2);
}

compare(&quot;hi&quot;,&quot;mon&quot;); // 编译器会生成 int compare(const char (&amp;amp;p1)[3], const char (&amp;amp;p2)[4]);
compare(&quot;hello&quot;, &quot;world&quot;); // 编译器会生成 int compare(const char(&amp;amp;p1)[6], const char (&amp;amp;p2)[6]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非类型参数是一个常量，而且必须是常量或者常量表达式，编译器会根据不同的常量生成不同类型的代码，应用在Class模版上也是同样的道理。&lt;/p&gt;

&lt;p&gt;编译器生成模版代码，当且仅当编译器检测到模版被使用时才发生，即如果一个成员函数没有被使用，则它不会被编译器实例化。&lt;/p&gt;

&lt;p&gt;另外编译器生成模版代码会分三个阶段，第一个阶段是检查语法，第二个阶段是检查模版调用的参数匹配，第三个阶段才是模版实例化，因此链接时发生错误在模版编程时是常有的事。&lt;/p&gt;

&lt;p&gt;在新标准中C++可以通过显示实例化来明确指定某个类或函数实例化。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;extern template declaration; // 显式实例化申明
template declaration; // 显式实例化定义
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当编译器遇到extern模版显式实例化声明时，表明程序会在其他地方有该程序的实例化。
和普通模版实例化不同的是，如果一个类定义了模版显式实例化，则该模版的所有成员包括内联成员函数都会被实例化。&lt;/p&gt;

&lt;p&gt;此外在调用中如果有需要，我们也可以显式指定模版参数类型。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;template&amp;lt;tyepname T1, typename T2, typename T3&amp;gt;
T1 sum(T2, T3);

long long var1 = sum(11,22L); // 编译错误
long long var2 = sum&amp;lt;long long&amp;gt;(22, 33L); // 显式指定返回值为long long
long long var3 = sum&amp;lt;long long, int, float&amp;gt;(23, 34F); // 显式指定返回值和参数分别为 long long, int, float
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述示例告诉我们，如果返回值使用了模版类型，则最好通过显式指定的方式来指定形参类型。&lt;/p&gt;

&lt;h3 id=&quot;理解右值引用stdmove和stdforward&quot;&gt;理解右值引用、std::move和std::forward&lt;/h3&gt;

&lt;p&gt;可以简单理解为，一个&amp;amp;为左值引用，两个&amp;amp;为右值引用，右值引用有些特殊，它转为转移数据而存在，即当右值引用赋值后，原值的内存数据将失效。&lt;/p&gt;

&lt;p&gt;通过右值引用可以做到数据转移的功能，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void f(int v1, int &amp;amp;v2)
{
    count &amp;lt;&amp;lt; v1 &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; ++v2 &amp;lt;&amp;lt; endl;
}

template&amp;lt;typename F, typename T1, typename T2&amp;gt;
void flip1(F f, T1 t1, T2 t2)
{
    f(t2, t1);
}

template&amp;lt;typename F, typename T1, typename T2&amp;gt;
void flip2(F f, T1 &amp;amp;&amp;amp;t1, T2 &amp;amp;&amp;amp;t2)
{
    f(t2, t1);
}

int i = 0;
f(42, i); // i变量被改变
flip1(f, i, 42); // i变量没有被改变
flip2(f, i, 42); // i变量被改变
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述中filp1与flip2的差别是，filp2使用了右值引用，将实参转移到了形参上，进而在f中可以改变i本身的变量。&lt;/p&gt;

&lt;p&gt;模版可以接受右值引用参数，std::move的定义就是模版右值引用定义：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;template&amp;lt;typename T&amp;gt;
typename remove_reference&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp; move(T&amp;amp;&amp;amp; t)
{
    return static_cast&amp;lt;typename remove_reference&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp;&amp;gt;(t);
}

move函数参数T&amp;amp;&amp;amp;是一个指向模版类型的右值引用。通过引用折叠，参数可以与任何类型的实参匹配。
string s1(&quot;hi&quot;), s2;

s2 = std::move(string(&quot;bye&quot;)); // 实例化为 string&amp;amp;&amp;amp; move(string &amp;amp;&amp;amp;t)
s2 = std::move(s1); // 实例化为 string&amp;amp;&amp;amp; move(string &amp;amp;t)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实这两个模版实例化成了不同的函数，根本原因是右值引用可折叠，导致的结果是：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;如果一个函数参数是一个指向模版类型参数的右值引用（如，T&amp;amp;&amp;amp;）则它可以被绑定到一个左值。&lt;/li&gt;
  &lt;li&gt;如果实参是一个左值，则推断出的模版实参类型将是一个左值引用，且函数参数将被实例化为一个（普通）左值引用参数（T&amp;amp;）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;标准库中std::forward可以帮助我们返回实参类型的右值引用，即std::forward&lt;T&gt;的返回类型是T&amp;amp;&amp;amp;。例如：&lt;/T&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;template&amp;lt;type F, typename T1, typename T2&amp;gt;
void flip(F f, T1 &amp;amp;&amp;amp;t1, T2 &amp;amp;&amp;amp;t2)
{
    f(std::forward&amp;lt;T2&amp;gt;(t2), std::forward&amp;lt;T1&amp;gt;(t1));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;模版重载函数与可变参数模版&quot;&gt;模版重载函数与可变参数模版&lt;/h3&gt;

&lt;p&gt;模版重载函数在匹配规则上有些小规则，当有多个重载模版对一个调用提供同样好的匹配时，应选择最特例化的版本。&lt;/p&gt;

&lt;p&gt;对于一个调用，如果一个非函数模版与一个函数模版提供同样好的匹配，则选择非模版版本。&lt;/p&gt;

&lt;p&gt;可变参数模版中，编译器会根据识别到的函数参数类型生成多个不同类型形参的函数。&lt;/p&gt;

&lt;p&gt;可变参数模版可以与sizeof…运算符一起使用，sizeof…运算符也是通过预编译生成的模版函数，返回的是类型数目或者参数数目。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;template&amp;lt;typename T, typename... Args&amp;gt;
ostream &amp;amp;print(ostream &amp;amp;os, const T &amp;amp;t, const Args&amp;amp;... rest)
{
    os &amp;lt;&amp;lt; t &amp;lt;&amp;lt; &quot;,&quot;;
    return print(os, rest...); // 预编译会将函数展开成类似print(os, i, s, 42)
}

string debug_rep(char *p)
{
    return string(p);
}

template&amp;lt;typename... Args&amp;gt;
ostream &amp;amp;errorMsg(ostream &amp;amp;os, const Args&amp;amp;... rest)
{
    return print(os, debug_rep(rest)...); // 预编译会将函数展开成类似print(os, debug_rep(i), debug_rep(s), debug_rep(42));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译器会在预编译时对可变参数展开，因此上述函数在调用展开后类似于 print(os, i, s, 42) 和 print(os, debug_rep(i), debug_rep(s), debug_rep(42))。&lt;/p&gt;

&lt;h3 id=&quot;模版特例化&quot;&gt;模版特例化&lt;/h3&gt;

&lt;p&gt;有时候我们不希望使用模版但又想跟模版的使用方式一样，此时就可以用一个特例化模版来独立定义模版中的一个或者多个参数指定为特定类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;template&amp;lt;typename T, typename U&amp;gt; int compare(const T&amp;amp;, const U&amp;amp;);  // 原模版

template&amp;lt;&amp;gt; int compare(const char* const &amp;amp;p1, const char* const &amp;amp;p2); // 全特例化

template&amp;lt;typename T&amp;gt; int compare(const T&amp;amp;, const char* const &amp;amp;p2); // 部分特例化

int compare(const int const &amp;amp;var1, const int const &amp;amp;var2);   //  普通函数

compare(3F,5F); // 调用源模版
compare(&quot;HI&quot;, &quot;HELLO&quot;); // 调用全特例化
compare(3F,&quot;HELLO&quot;); // 调用部分特例化
compare(3,5); // 调用普通函数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当定义函数模版的特例化版本时，我们本质上接管了编译器的工作。即我们为原模版的一个特殊实例提供了定义。&lt;/p&gt;

&lt;p&gt;重要的是要弄清楚：一个特例化版本本质上是一个实例，而非函数名的一个重载版本，因此特例化不影响函数匹配。&lt;/p&gt;

&lt;p&gt;注意，当一个非模版函数提供与函数模版同样好的匹配时，编译器会选择非模版版本。&lt;/p&gt;

&lt;p&gt;另外特例化也可以应用到类定义上，类上的特例化也同样支持全特例化和部分特例化，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;template&amp;lt;class T, class U&amp;gt; class testClass { // 原类
    public：
    T var1;
    U var2;
    void Func();
}

template&amp;lt;&amp;gt; class testClass&amp;lt;int, double&amp;gt; { // 全特例化
    public：
    int var1;
    double var2;
    void Func();
}

template&amp;lt;T&amp;gt; class testClass&amp;lt;T, double&amp;gt; { // 部分特例化
    public：
    T var1;
    double var2;
    void Func();
}

template&amp;lt;class T, class U&amp;gt; struct testClass { // 对函数成员特例化
    public：
    T var1;
    U var2;
    template&amp;lt;&amp;gt;
    void Func&amp;lt;int, double&amp;gt;(); // 成员函数特例化
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类也可以全特例化和部分特例化，其中成员函数特例化时必须全特例化，不支持部分特例化。&lt;/p&gt;

&lt;h3 id=&quot;标准库中的特殊类型&quot;&gt;标准库中的特殊类型&lt;/h3&gt;

&lt;p&gt;tuple类似pair的模版，不过tuple可以有任意数量的成员，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;tuple&amp;lt;T1, T2, T3...Tn&amp;gt; t; // 一个tuple变量可以有n个成员
T2 item = get&amp;lt;i&amp;gt;(t); // 用索引值获取成员
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;tuple的一个常见用途是从函数返回多值，当使用tuple作为多值返回值时，它相当于是一个可以方便临时构造的数据结构。&lt;/p&gt;

&lt;p&gt;bitset能使得二进制运算的使用更为容易，能处理超过整数大小的位集合。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;bitset&amp;lt;n&amp;gt; b; // b有n位，每一位均为0。
bool item = b[i]; // 访问b中pos处位置的值
b.set(27); // 第27个位置设置为1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正则表达式regex类，这里不多说了，正则表达式网上说明太多。&lt;/p&gt;

&lt;p&gt;标准库中的rand随机数主要解决两类问题，第一是范围内随机，第二是非均匀分布。因此标准库提供了随机数引擎Engine，通过种子来锚定伪随机数。&lt;/p&gt;

&lt;h3 id=&quot;常用程序工具&quot;&gt;常用程序工具&lt;/h3&gt;

&lt;p&gt;异常处理流程通常是从一处抛出异常，不断沿着函数调用链寻找异常匹配，如果没有找到则调用标准库函数terminate终止程序执行。&lt;/p&gt;

&lt;p&gt;其中一条catch语句可以通过重新抛出操作将异常传递给另外一个catch语句，函数也可以通过声明noexcept或throw来承诺不会抛出异常。&lt;/p&gt;

&lt;p&gt;新标准中引入了内联命名空间，内联命名空间中的名字可以被外层命名空间直接使用。&lt;/p&gt;

&lt;p&gt;多重继承，指从多个直接基类中派生类的能力。多重继承的派生类继承了所有父类的属性。&lt;/p&gt;

&lt;p&gt;多重继承的派生类的内存模型其实就是类属性的叠加，不同父类之间通过内存叠加来实现多重继承。&lt;/p&gt;

&lt;p&gt;在构造时按继承顺序调用构造函数，析构时的调用顺序则刚好相反。&lt;/p&gt;

&lt;h3 id=&quot;运行时类型识别rttirun-time-type-identification&quot;&gt;运行时类型识别（RTTI，run-time type identification）&lt;/h3&gt;

&lt;p&gt;RTTI功能由两个运算符实现：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;typeid 运算符，用于返回表达式的类型&lt;/li&gt;
  &lt;li&gt;dynamic_cast 运算符，用于将指针或引用安全地转换为派生类指针或引用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们知道不包含任何虚函数的类在内存模型中是没有虚表的，而虚表是运行时识别的重要关键。&lt;/p&gt;

&lt;p&gt;其实两个运算符都是针对虚函数实现的，其原理就是派生类中有虚表，虚表中有指向type_info的指针和虚函数指针。&lt;/p&gt;

&lt;p&gt;typeid通过虚表取得type_info返回给程序，dynamic_cast则通过比较目标类中的type_info和执行对象虚表中的type_info确定是否可以安全转换。&lt;/p&gt;

&lt;p&gt;有趣的一点是，typeid也可以用于静态类（即没有任何虚函数的类），此时获取的type_info则是通过编译器生成的，因为在编译阶段就能识别该对象类型。&lt;/p&gt;

&lt;h3 id=&quot;类成员指针&quot;&gt;类成员指针&lt;/h3&gt;

&lt;p&gt;与普通指针不同的是类成员指针指向的是成员而非对象。&lt;/p&gt;

&lt;p&gt;类成员指针分为数据成员指针和成员函数指针。&lt;/p&gt;

&lt;p&gt;数据成员指针指向的是数据成员，成员函数指针则指向成员函数，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;class testClass
{
    public:
    string content;
    char * getChar();
}

const string testClass::*pdata = &amp;amp;testClass::content; // pdata为成员指针
const string testClass::*pfunc = &amp;amp;testClass::getChar; //pfunc为成员函数指针

testClass myObj; // 实例对象
testClass *pObj = &amp;amp;myObj; // 指针

string s = myObj.*pdata; // 用成员指针获取实例成员数据
string ss = myObj-&amp;gt;*pdata; //  用成员指针获取指针成员数据

char *c = (myObj.*pfunc)();
char *cc = (myObj-&amp;gt;*pfunc)();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述例子中我们可以清楚的看到pdata，pfunc是testClass成员指针，通过声明testClass + 类型来指定成员指针，用成员指针可以调用或者取得成员数据。&lt;/p&gt;

&lt;p&gt;通过这种成员指针的方式，我们可以将类成员的函数放入一个函数表中以方便逻辑使用，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;class testClass
{
    public:
    using Action = char* (testClass::*)();
    char* getChar1();
    char* getChar2();
    char* getChar3();
}

testClass::Action funcMenu[] = { &amp;amp;testClass::getChar1, &amp;amp;testClass::getChar2, &amp;amp;testClass::getChar3 };
testClass obj;
for(int i = 0; i&amp;lt;3 ; i++)
{
    char * c = (obj.*(funcMenu[i]))();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类成员指针与普通函数指针不同之处在于成员指针并不是一个可调用对象，因此它不支持函数调用运算符。&lt;/p&gt;

&lt;p&gt;这时我们可以用funciton和bind将类成员函数指针封装成可调用对象，这样可以让成员函数指针运用的更加灵活。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;function&amp;lt;bool (const string&amp;amp;)&amp;gt; fcn = &amp;amp;string::empty;
find_if(svec.begin(), svec.end(), fcn);
auto it = find_if(svec.begin(), svec.end(), bind(&amp;amp;string::empty, _1));
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;联合union&quot;&gt;联合union&lt;/h3&gt;

&lt;p&gt;一个union可以有多数据成员，其空间大小为最大的那个数据成员，因为在任意时刻只有一个数据成员有效，当我们给某个成员赋值后，其他成员就变成了未定义状态。&lt;/p&gt;

&lt;p&gt;union可以有自己的构造函数和析构函数，但不能有虚函数不能作为基类更不能派生。&lt;/p&gt;

&lt;p&gt;有时我们需要最终union中存储了什么类型的值，因此通常会自己定义个独立的类对象，通过这个对象来判别union当前类型。&lt;/p&gt;

&lt;h3 id=&quot;其他特性&quot;&gt;其他特性&lt;/h3&gt;

&lt;p&gt;位域，明确了变量的二进制位数，它必须是整数，当一个程序需要向其他程序或者硬件设备传递二进制数据时通常会使用位域，因为设备之间的编译环境不同。&lt;/p&gt;

&lt;p&gt;取地址运算符（&amp;amp;）不能作用于位域，因此任何指针都无法指向类的位域。&lt;/p&gt;

&lt;p&gt;它声明的方式为成名名字之后紧跟冒号和常量，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;class testClass
{
    public:
    int mode: 2; // mode 占2位
    int var1: 4: // var1 占4位
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;volatile，会告诉编译器阻止这个对象优化。&lt;/p&gt;

&lt;p&gt;由于不同设备之间存在差异，因此在移植或不同环境时会有所改变，因此我们需要使用volatile阻止编译器在当前环境下做编译优化，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;volatile int var; // 阻止优化变量
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;volatile用在如下的几个地方：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;中断服务程序中修改的供其它程序检测的变量需要加volatile；&lt;/li&gt;
  &lt;li&gt;多任务环境下各任务间共享的标志应该加volatile；&lt;/li&gt;
  &lt;li&gt;存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;链接指示extern “C”，意味着我们声明了另一个语言的编译器，从而使得我们在编译时让编译器遵守另一个语言的规则（其他兼容例如extern “Ada”，extern “FORTRAN”等）&lt;/p&gt;

&lt;p&gt;所有在链接指示里的内容都被指向该语言编写的链接，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;extern &quot;C&quot;
{
    #include &amp;lt;string.h&amp;gt; // 操作c风格字符串的c函数
}

extern &quot;C&quot; void (*pf)(int); // 当pf被调用时，编译器认定pf为C函数
(*pf)(2);

extern &quot;C&quot; typedef void FC(int); // 定义一个C函数
void f2(FC *); // 将C函数指针作为C++函数的形参
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以通过宏来判断当前编译器是C++编译器还是C编译器，即__cplusplus，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#ifdef __cplusplus
extern &quot;C&quot;
#endif
int strcmp(const char*, const char*);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码通过预处理定义在代码中兼容C和C++。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484819&amp;amp;idx=1&amp;amp;sn=229a9bb2eb6ca5fd7322c8b85bae6d8f&amp;amp;chksm=fc226094cb55e98229f537079c784bcf16f42579928fd034b46a69a953f6ddab28f1b4cf3c1c&amp;amp;token=1401123908&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

</description>
               <pubDate>Sun, 11 Jul 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/07/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B034</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/07/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B034</guid>
            </item>
        
            <item>
               <title>读书笔记(三十一) 《装载、链接与库》#4 内核运行库</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484809&amp;amp;idx=1&amp;amp;sn=89091ecce47229ebf10e4855c0ccceca&amp;amp;chksm=fc22608ecb55e998cdff3952057e6d1c6f099463797d57458ec1f4d37a432d46dc3c5bfcfbb5&amp;amp;token=557108361&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;背景&quot;&gt;背景：&lt;/h2&gt;

&lt;p&gt;看此书的起源是我在了解Linux注入技术的时候翻阅到的，由于注入技术需要用到很多ELF格式的内容，很多网络上的技术文章都指向了同一本书。也刚好周围的同事有此书，便翻阅了一下，这一番翻阅打开了我对程序世界的又一扇大门。&lt;/p&gt;

&lt;p&gt;很快我就自己买了此书并阅读完成，整本书给我很大的震撼，让我对程序从编译到链接到装载有了更深刻的认识。&lt;/p&gt;

&lt;p&gt;我把我的整个学习过程以及对书本的理解，用自己的语言和自己画的图表达出来，让读者能够更容易接受到我所学的知识。&lt;/p&gt;

&lt;h2 id=&quot;目标&quot;&gt;目标：&lt;/h2&gt;

&lt;p&gt;了解编译过程&lt;/p&gt;

&lt;p&gt;了解动态库和静态库的装载细节&lt;/p&gt;

&lt;p&gt;了解可执行程序装载和执行过程&lt;/p&gt;

&lt;p&gt;了解可执行文件和动态库的数据格式&lt;/p&gt;

&lt;h2 id=&quot;疑问&quot;&gt;疑问：&lt;/h2&gt;

&lt;p&gt;c/c++编译器是如何将cpp编译为可执行文件的？&lt;/p&gt;

&lt;p&gt;多个c/c++文件是如何编译成一个可执行文件的？&lt;/p&gt;

&lt;p&gt;操作系统内存是如何初始化和管理的？&lt;/p&gt;

&lt;p&gt;动态库和静态库的链接和装载过程是怎样的？&lt;/p&gt;

&lt;p&gt;操作系统的用户态和内核态是如何运作的？&lt;/p&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文：&lt;/h2&gt;

&lt;p&gt;前面我们介绍了Linux的动态库在装载时的动态链接过程，以及可执行文件的装载过程。这里简单介绍下Windows的动态库的装载过程。&lt;/p&gt;

&lt;p&gt;Windows下的动态链接与Linux下的相比有很多相似之处，但也有很多不同的地方。Windows下的动态库称为DLL（Dynamic-Link Library），它和EXE文件实际上是一个概念，即都是PE格式的文件，区别在于PE文件头的符号位标识位不同，而且DLL文件的扩展名不一定是.dll，也可能是.ocx或.CPL。&lt;/p&gt;

&lt;p&gt;与Linux不同的是Windows有符号导入表和导出表概念，即必须使用“__declspec(dllimport)”和“__declspec(dllexport)”来显式的声明符号的导入与导出。
Window编译器通过收集这些显式声明的导入符号，将它们放在一个导出表（Exprot Table）的符号集中，类似于Linux下的.dynsym段。
动态链接器根据需要导入的符号从导出表上查找到真实的函数地址，这期间导入表则起到了存储符号和记录地址的作用，类似于Linux下的GOT。&lt;/p&gt;

&lt;p&gt;其实DLL中的代码段并不是地址无关的，Windows加载DLL时采用了重定基地址（Rebasing）的方法重定位每个绝对地址引用。
由于DLL内部的地址都是基于基地址或相对于基地址的RVA，因此在重定位时只需要加上一个固定差值就能完成重定位工作。
由于是绝对地址重定位，所以重定基地址比ELF的延迟定位机制要快很多，因为它不需要通过类似的GOT机制，对外部数据和函数的访问不需要每次都计算GOT位置。&lt;/p&gt;

&lt;h3 id=&quot;内存堆与栈&quot;&gt;内存堆与栈&lt;/h3&gt;

&lt;p&gt;前面我们说了很多关于系统内存的，包括虚拟内存、页表、缺页、置换等，而这节主要对堆内存和栈内存进行讲解。&lt;/p&gt;

&lt;p&gt;当我们调用函数时，需要将当前函数的信息保存到栈上以便调用结束回到原来位置时所有数据都能恢复到原样。
我们把这些保存到栈上的数据称为栈帧（Stack Frame），这些数据主要包含：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;调用需要的参数，以及调用结束时函数的返回地址&lt;/li&gt;
  &lt;li&gt;临时变量：包括函数的非静态局部变量以及编译器自动生成的临时变量&lt;/li&gt;
  &lt;li&gt;上下文：当前函数调用的寄存器数据&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意，每种编译器都有自己的调用惯例，比如参数的传递顺序和方式、栈维护的方式、函数的签名规则、返回的寄存器等，在各个编译器之间可能有细微的差别。&lt;/p&gt;

&lt;p&gt;其中几乎所有的编译器调用惯例都将返回值存储在eax寄存器中，对于大于4字节的数据则存储在eax和edx中联合返回。&lt;/p&gt;

&lt;h3 id=&quot;堆内存&quot;&gt;堆内存&lt;/h3&gt;

&lt;p&gt;我们在写内存分配时通常使用内存分配接口malloc或new，这两个接口分配的内存通常都放在.heap堆内存区域中，而动态库文件在加载的时候，则通过mmap将动态库映射到.libraries文件映射区域中。&lt;/p&gt;

&lt;p&gt;注意，malloc分配的内存到.heap段，mmap分配内存到.libraries段，而当malloc请求的内存大于MMAP_THRESHOLD时，则会转而调用mmap，申请的内存则在.libraries区域，这个阈值可以通过mallopt调整。&lt;/p&gt;

&lt;p&gt;这里作者介绍了下堆内存管理的几种方式不是非常详细，简单介绍下（后面会写一个操作系统内存专题）：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;空闲链表法，把空闲的内存块加入到一个链表上，这个链表里全是空闲的内存块地址，当需要使用时就从这里找合适的。&lt;/li&gt;
  &lt;li&gt;分页分块法，把整个内存分成128K大小的XX页，然后再把每页分成32字节大小的内存块，用数组记录每个内存页和内存块的占用情况，这样在分配和释放时查找速度会比较快。&lt;/li&gt;
  &lt;li&gt;固定大小内存池，把整个分为固定大小的内存块，然后用空闲链表记录所有空闲的内存地址，每次分配都从空闲链表里推出一个内存使用。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;运行库&quot;&gt;运行库&lt;/h3&gt;

&lt;p&gt;作者专研的比较细，把进程启动到结束的整个过程都扒了出来，我们也跟着扒一下。&lt;/p&gt;

&lt;p&gt;程序从开始运行到结束的步骤如下：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;操作系统fork（创建）进程，把控制权交到程序入口，这个入口通常都是公共库的某个函数（libc或MSVC）&lt;/li&gt;
  &lt;li&gt;入口函数对运行库和程序运行环境进行初始化，包括堆、I/O、线程、全局变量的构造等等&lt;/li&gt;
  &lt;li&gt;入口函数在完成初始化之后，调用main函数，正式开始执行程序主体部分&lt;/li&gt;
  &lt;li&gt;main函数执行完毕，返回入口函数，入口函数进行清理工作，包括全局变量析构、堆栈销毁、关闭I/O等，然后进程调用系统调用结束进程。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面我们来说说在整个系统调用里各部分是如何运作的。&lt;/p&gt;

&lt;h3 id=&quot;文件句柄原理&quot;&gt;文件句柄原理&lt;/h3&gt;

&lt;p&gt;这里不得不提一下文件句柄的原理，因为我们常常使用文件句柄，却不知道文件句柄究竟是什么，以及是什么产生了文件句柄。&lt;/p&gt;

&lt;p&gt;文件句柄总是和内核的文件对象相关联，内核可以通过句柄来计算出内核里文件对象的地址。
在内核中，每个进程都有一个私有的“打开文件表”，这个表是一个指针数组，每一个元素都指向一个内核的打开文件对象，文件句柄就是数组的下标。
当用户打开一个文件时，内核就会在内部生成一个文件对象，并在这个表里找到一个空项，让这一项指向生成的打开文件对象，并返回这一项的下标作为句柄值。
由于这个“打开文件表”处于内核，并且用户无法访问到，因此用户即使拥有句柄值，也无法直接打开文件对象的地址，只能通过系统提供的函数来操作。
Windows的句柄稍有不同，虽然类似于文件表的下标但它并不是下标而是经过某种线性变换的结果。&lt;/p&gt;

&lt;p&gt;注意，文件表数组前三个元素填充的是stdin、stdout、stderr这三个内核对象。&lt;/p&gt;

&lt;h3 id=&quot;读取文件实现原理&quot;&gt;读取文件实现原理&lt;/h3&gt;

&lt;p&gt;我们知道标准库中，文件在写入时会有缓冲区，因此在写入完毕后可以手动调用刷新接口来将缓冲取的内容清空到文件。&lt;/p&gt;

&lt;p&gt;其实读取文件也是同样的道理，如果读取文件时总是对文件操作，那么每次都需要进入内核模式，完成后再回到用户模式。
很明显这样的读取方式消耗的比较大，因此读取文件也需要自己的缓冲，以提高文件读取效率。&lt;/p&gt;

&lt;p&gt;那么标准库是如何实现文件读取的呢？&lt;/p&gt;

&lt;p&gt;标准库中文件读取时的执行步骤：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;每个文件读取时都会有一个缓冲区，缓冲区存储了已经读取的文件数据和还未读取的文件数据，&lt;/li&gt;
  &lt;li&gt;当读取文件时，先判断缓冲区中是否有此数据，&lt;/li&gt;
  &lt;li&gt;如果缓冲区中有我们需要的数据，则直接取得后返回即可，&lt;/li&gt;
  &lt;li&gt;如果没有我们需要的数据或者数据不够，则读取文件并将其后的数据一并读取放入到缓冲区中后再返回&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;变长参数的实现方式&quot;&gt;变长参数的实现方式&lt;/h3&gt;

&lt;p&gt;这里作者说明了printf这种函数可变参数的实现方式：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;编译时将多个实参打包成byte数组传入函数&lt;/li&gt;
  &lt;li&gt;在函数中根据下标和大小从byte数组指针中提取形参数据&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;glibc的组成&quot;&gt;glibc的组成&lt;/h3&gt;

&lt;p&gt;glibc中的内容由两部分组成，一部分是头文件，比如stdio.h、stdlib.h等，它们位于/usr/include，另一部分则是库的二进制文件，/lib/libc.so，或者/usr/lib/libc.a。&lt;/p&gt;

&lt;p&gt;事实上glibc还有3个重要的运行库，&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;/usr/lib/crt1.o，包含了入口程序，负责调用__libc_start_main初始化libc，并调用main函数进入真正的程序主体。&lt;/li&gt;
  &lt;li&gt;/usr/lib/crti.o，包含了_init()部分的程序初始化指令， 所有的.init都会被收集起来在这里调用&lt;/li&gt;
  &lt;li&gt;/usr/lib/crtn.o，包含了_finit()部分的程序销毁指令，所有的.finit都会被收集起来在这里调用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意，收集全局构造函数和析构函数的过程是，在链接时，将各个目标文件中.ctors段中的构造函数和析构函数合并为一个数组，在初始化和销毁时依次调用&lt;/p&gt;

&lt;p&gt;由于crti.o必须保证在用户目标文件和系统库之前，crtn.o必须在用户目标文件和系统库之后，因此链接器输入文件顺序必须是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;ld crt1.o crti.o [user_objects] [system_libraries] crtn.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，前面说的都是C语言，在C++中则提供了crtbeginT.o和crtend.o来配合glibc实现C++的全局构造和析构。&lt;/p&gt;

&lt;h3 id=&quot;线程局部存储tlsthread-local-storage&quot;&gt;线程局部存储(TLS，Thread Local Storage)&lt;/h3&gt;

&lt;p&gt;线程也可以拥有私有数据，这就是线程局部存储机制(TLS，Thread Local Storage)。
TLS的用法很简单，只需要在它定义的时候加上关键字__thread就可以，在MSVC里为__declspec(thread)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;// Linux
__thread in number;

// MSVC
__declspec(thread) int number;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦一个全局变量被定义为TLS类型，那么每个线程都会拥有这个变量的副本，任何线程对该变量的修改都不会影响其他线程中该变量的副本。&lt;/p&gt;

&lt;p&gt;在Windows中TLS的实现方式为：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;编译器把__declspec(thread)定义的线程私有变量放到.tls段中&lt;/li&gt;
  &lt;li&gt;当进程启动一个线程时，在进程堆中分配一块足够大小的空间&lt;/li&gt;
  &lt;li&gt;把.tls段中的内容复制到这块空间中&lt;/li&gt;
  &lt;li&gt;于是每个线程都有自己独立的一个.tls数据副本&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意，在.rdata表中有一个TLS表，它保存了所有的TLS变量的构造和析构函数地址，在线程启动和退出时都会对TLS变量进行构造和析构。除了使用添加关键字定义TLS变量外，还可以通过系统接口的方式，实时申请TLS类型变量。&lt;/p&gt;

&lt;h3 id=&quot;系统内核调用原理&quot;&gt;系统内核调用原理&lt;/h3&gt;

&lt;p&gt;为了安全操作系统将操作分为两种模式，一种用户模式，一种是内核模式，用户模式操作范围被限制在用户空间上，而内核模式的程序涉及的范围会更广一些，但也主要集中内核空间中。由于内核模式操作的权限更大，因此内核程序编写时需要更加谨慎并严格测试，通常我们都接触不到内核程序，除非自己编写或修改操作系统。&lt;/p&gt;

&lt;p&gt;当用户模式要调用内核模式中的程序，要先通过EAX寄存器设置调用号，再调用中断指令，内核通过中断向量表找到系统调用程序，系统调用程序根据系统调用表查找到系统函数，最后执行系统调用。
x86下中断指令为0x80，通过寄存器EAX指定系统调用的调用号，内核程序根据EAX中的值找到系统函数最后执行。&lt;/p&gt;

&lt;p&gt;举例创建进程时的系统调用过程：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;用户调用创建进程函数，&lt;/li&gt;
  &lt;li&gt;创建进程函数设置eax寄存器并调用中断指令进入内核态，&lt;/li&gt;
  &lt;li&gt;中断指令根据0x80和中断向量表找到系统调用程序，&lt;/li&gt;
  &lt;li&gt;系统调用程序根据eax寄存器和系统调用表找到需要调用的函数，&lt;/li&gt;
  &lt;li&gt;系统调用完毕返回用户态函数返回地址。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当用户态和内核态切换时，首先SS要指向内核栈，ESP指向内核栈顶，这样才能让程序当前的栈从用户栈切换到内核栈。&lt;/p&gt;

&lt;p&gt;其实每个进程都有两个栈，用户栈和内核栈，在切换到内核栈时要保存当前上下文，因此要向内核栈中推入ESP、SS、EFLASHS、CS、EIP的值，以便切回用户态时再弹出恢复。
除了这几个特殊的寄存器，向内核栈中推入的还有EBX、ECX、EDX、ESI、EDI和EBP这6个寄存器，而这6个寄存器刚好可以被系统调用函数用于实参。&lt;/p&gt;

&lt;h3 id=&quot;实现自定义crtc-runtime&quot;&gt;实现自定义CRT（C Runtime）&lt;/h3&gt;

&lt;p&gt;作者根据前面的理论知识，实现了一个自己的CRT（C Runtime），在不使用标准库的情况下，支持自定义自己的函数入口、进程初始化与销毁、堆内存分配与释放、文件读取与写入、格式化输出。&lt;/p&gt;

&lt;p&gt;我们这里讲解下实现CRT的几个关键点。&lt;/p&gt;

&lt;h3 id=&quot;关键点一&quot;&gt;关键点一：&lt;/h3&gt;

&lt;p&gt;入口函数可以使用编译命令来指定，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;gcc -nostartfiles -e myentry source.c -o source
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-e：设置程序的入口函数&lt;/p&gt;

&lt;h3 id=&quot;关键点二&quot;&gt;关键点二：&lt;/h3&gt;

&lt;p&gt;进入main函数前要初始化堆内存，堆内存的管理分配与释放要自己来实现，比如实现一个FreeList空闲链表来存储销毁的堆内存以便下次使用。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;//自定义堆内存块结构
typedef struct _heap_header
{
    unsigned size;
    struct _heap_header * next;
    struct _heap_header * prev;
} heap_header;

//空闲内存链表
static heap_header * freelist_head = NULL;

//自定义内存释放函数
void free(void * ptr)
{
    ....
}

//自定义堆内存申请函数
void * malloc(unsigned size)
{
    ....
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;关键点三&quot;&gt;关键点三：&lt;/h3&gt;

&lt;p&gt;堆内存的扩容可以通过brk系统调用设置进程的数据段边界，而sbrk可以移动进程的数据段边界，其实将数据段边界后移就相当于分配了一个定量的内存。&lt;/p&gt;

&lt;p&gt;由brk/sbrk分配的内存仅仅分配了虚拟空间，这些空间是不会提交的（即不分配物理内存页），当进程访问某个地址时才会与物理页关联。&lt;/p&gt;

&lt;h3 id=&quot;关键点四&quot;&gt;关键点四：&lt;/h3&gt;

&lt;p&gt;由于不使用标准库，因此文件系统也必须自己重写，重写文件读写底层时，我们可以用汇编写系统调用来实现。&lt;/p&gt;

&lt;p&gt;其中系统调用中，打开文件的系统调用号是5、读取文件的系统调用号是3、写入文件的系统调用号是4、关闭文件的系统调用号是6。
因此在调用int 0x80前，设置eax为各调用号就可以，同时用ebx、ecx、edx将参数传入系统调用。&lt;/p&gt;

&lt;p&gt;举例打开文件的系统调用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;asm(&quot;movl $5, %%eax \n\t&quot; // 设置eax的调用号
    &quot;movl %1, %%ebx \n\t&quot; // 设置参数1
    &quot;movl %2, %%ecx \n\t&quot; // 设置参数2
    &quot;movl %3, %%edx \n\t&quot; // 设置参数3
    &quot;int $0x80 \n\t&quot; // 调用0x80系统中断
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面我们说标准输入输出是文件表的前3个句柄，因此句柄0，1，2为标准输入、标准输出、标准错误的句柄。&lt;/p&gt;

&lt;h3 id=&quot;关键点五&quot;&gt;关键点五：&lt;/h3&gt;

&lt;p&gt;实现全局构造和析构时，从.ctors段中读取构造和析构函数数据，将构造和析构函数都合并到指针数组中，依次调用函数指针数组中的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;typedef void (*ctor_func)(void);

ctor_func ctors_begin[1] __attribute__ ((section(&quot;.ctors&quot;))) = 
{
    (ctor_func) -1;
};

void run_ctors()
{
    const ctor_func * list = ctors_begin;
    while( (int)*++list != -1 )
    {
        (**list)();
    }
}
&lt;/code&gt;&lt;/pre&gt;

</description>
               <pubDate>Sun, 04 Jul 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/07/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B033</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/07/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B033</guid>
            </item>
        
            <item>
               <title>读书笔记(三十二) 《C++ Primer》#5</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484794&amp;amp;idx=1&amp;amp;sn=03be5eab5f7014e7d612ffee2a193cb9&amp;amp;chksm=fc22607dcb55e96bd6f1dd010815d3e382cbcacca18bb1a4c69ff96ca3c4644c3d2f6240f7ef&amp;amp;token=557108361&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;背景&quot;&gt;背景：&lt;/h2&gt;

&lt;p&gt;我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意。第三是当我们在巩固时创造出了新的知识，那么这些新的知识和旧的知识将同时变成智慧融合到身体中。&lt;/p&gt;

&lt;p&gt;本系列基于《C++ Primer》学习，由于重点放在“重学”，我略过了滚瓜烂熟的部分，挑出以前常忽略的部分，以及记忆没有那么深刻的部分，特别是那些重要的但没有上心的部分。&lt;/p&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文：&lt;/h2&gt;

&lt;h3 id=&quot;关联容器&quot;&gt;关联容器&lt;/h3&gt;

&lt;p&gt;关联容器包括map、set以及相应的扩展容器，包括可容纳重复关键字的multimap和multiset容器，以及用unordered为前缀的无序容器。&lt;/p&gt;

&lt;p&gt;注意，对map使用下标操作时，如果关键字在容器中不存在，则会添加一个关键字在容器中。&lt;/p&gt;

&lt;p&gt;无序容器大都使用哈希方式来做查找工作，它在存储上组织为一个数组，我们可以比喻为桶管理，每个数组中的元素为桶，它保存0个或多个元素，用哈希函数将元素映射到桶中，当一个桶保存多个元素时，需要顺序搜索这些元素来查找正确的那个。因此无序容器的性能通常依赖于哈希函数的质量和数组的大小。&lt;/p&gt;

&lt;h3 id=&quot;智能指针&quot;&gt;智能指针&lt;/h3&gt;

&lt;p&gt;新的标准库中有两种智能指针，一种允许多个指针指向同一个对象shared_ptr，另一种则“独占”所指向的对象unique_ptr，标准库还提供了一个名为weak_ptr的弱引用方式，来指向shared_ptr所管理的对象。&lt;/p&gt;

&lt;p&gt;其实智能指针也是模版，它通过模版并重载=、+/-、==运算符来实现智能指针的逻辑。
智能指针的逻辑很简单，通过计数器来记录现在有多少个shared_ptr指向相同的对象，当计数为0时它就会自动释放对象。&lt;/p&gt;

&lt;p&gt;智能指针可以帮助我们管理内存对象的销毁时机，但智能指针不是万能的，如果你忘记销毁了智能指针，则同样会造成内存泄漏。
因此我们应该明白内存管理方式有很多种，用来防止内存泄漏的方法也不只智能指针这一种。&lt;/p&gt;

&lt;h3 id=&quot;动态内存管理&quot;&gt;动态内存管理&lt;/h3&gt;

&lt;p&gt;我们常常自己来管理内存，内存泄漏也是常用的事，分配了内存但没有释放，或者没有及时释放堆积的太多等问题都是比较普遍的。&lt;/p&gt;

&lt;p&gt;常用的new和delete运算符，在分配内存的同时，也负责调用构造函数和析构函数。&lt;/p&gt;

&lt;p&gt;如果我们想更好的管理内存，提高内存使用效率，让内存泄漏更容易分析，那么我们就得设计内存分配器来管理内存，例如固定大小内存分配器、环形内存分配器、双端内存分配器等等，这里不详细介绍。&lt;/p&gt;

&lt;p&gt;阻止对象拷贝&lt;/p&gt;

&lt;p&gt;用“=delete”定义删除函数来阻止拷贝和赋值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;struct NoCopy
{
  NoCopy() = default; // 默认构造函数
  NoCopy(const NoCopy&amp;amp;) = delete; // 阻止拷贝
  NoCopy &amp;amp;operator = (const NoCopy&amp;amp;) = delete; // 阻止赋值
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关键字“= delete”通知了编译器，告知它我们不希望定义这些成员。
注意，析构函数不能被删除，因此不能被定义删除函数。
另外父类和子类对删除函数具有一致性，即父类定义了删除函数时子类也同样具备。&lt;/p&gt;

&lt;p&gt;我们也常通过private来控制拷贝，即将构造函数和赋值运算符声明为private来阻止拷贝。&lt;/p&gt;

&lt;h3 id=&quot;对象移动&quot;&gt;对象移动&lt;/h3&gt;

&lt;p&gt;在内置对象中常发生对象拷贝的情况，如果想避免拷贝又想移动对象，则可以考虑右值引用。
所谓右值引用，就是必须绑定到右值的引用，我们可以通过&amp;amp;&amp;amp;（而不是&amp;amp;）来获得右值引用。
右值引用有一个重要性质，即只能绑定到一个将要销毁的对象。&lt;/p&gt;

&lt;p&gt;使用新标准库中move函数移动对象：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;int &amp;amp;&amp;amp;rr1 = 42; 
int &amp;amp;&amp;amp;rr3 = std::move(rr1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;std::move函数除了获取rr1右值引用外，还负责销毁，因此std::move后我们将不能再使用它了。
由于一个移后源对象具有不确定的状态，对其调用std::move是危险的，所以当我们使用move时，必须绝对确认移动后源对象没有其他用户。&lt;/p&gt;

&lt;p&gt;为了让自定义类支持移动操作，我们可以为其定义移动构造函数和移动赋值运算符。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;// 移动构造函数
testClass::testClass(testClass &amp;amp;&amp;amp;s) noexcept
{
  var1 = s.var1; // 移动var1
  var2 = s.var2; // 移动var2
  s.var1 = s.var2 = nullptr; // 移动后置空
}

// 移动赋值运算符
testClass &amp;amp; testClass::operator = (testClass &amp;amp;&amp;amp;s) noexcept
{
  var1 = s.var1; // 移动var1
  var2 = s.var2; // 移动var2
  s.var1 = s.var2 = nullptr; // 移动后置空
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与构造函数不同的是，移动构造函数不分配任何新内存，它会接管给定对象中的内存。
在接管内存后，它将给定对象中的指针都置为 nullptr 以便在后续在销毁源对象时不会销毁这部分内存。
编译器也会帮助我们合成默认的移动构造函数和移动赋值运算符，当然必须是编译器发现移动操作被用到的时候，而且只有当一个类没有定义任何自己版本的拷贝控制成员且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成默认的移动构造函数或移动赋值运算符。&lt;/p&gt;

&lt;h3 id=&quot;可调用对象&quot;&gt;可调用对象&lt;/h3&gt;

&lt;p&gt;可调用对象包括，函数、函数指针、lambda表达式、bind创建的对象、以及重载了的运算符。
从机器指令角度上来理解，函数实质是没有类型之分的，但实际调用时，仍然会需要对齐参数和返回值，因此区别在于参数数量、参数类型、返回值类型。
编译器在识别两个可调用对象是否一致时，其实并不关注它是函数指针或者其他，而关心它们的形参和返回值是否相同。&lt;/p&gt;

&lt;p&gt;这样说来，任意两个可调用对象可以共享同一种调用形式，这使得建立函数表成为了可能，前提是它们的参数和返回类型相同。&lt;/p&gt;

&lt;p&gt;标准库提供了这样一个模版封装，function&lt;T&gt;，让相同的可调用对象能够转换成同一类型指针，其中T为函数类型可以用lambda表达式。&lt;/T&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;function&amp;lt;int(int, int)&amp;gt; f1 = add; // 加法函数指针
function&amp;lt;int(int, int)&amp;gt; f2 = divide(); // 除法函数
function&amp;lt;int(int, int)&amp;gt; f3 = [](int i, int j){ return i*j;}; // lambda表达式

count &amp;lt;&amp;lt; f1(4,2) &amp;lt;&amp;lt; endl; // 打印6
count &amp;lt;&amp;lt; f2(4,2) &amp;lt;&amp;lt; endl; // 打印2
count &amp;lt;&amp;lt; f3(4,2) &amp;lt;&amp;lt; endl; // 打印8
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;虚函数&quot;&gt;虚函数&lt;/h3&gt;

&lt;p&gt;OOP的核心是多态，多态的核心就是虚函数，我们知道通过虚函数可以在运行时动态确定要调用的函数，派生类的虚函数会直接覆盖基类。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;class testClass1
{
   public:
       int var1;
       virtual int testFunc();
}

class testClass2
{
    public:
        virtual int testFunc();
}

testClass1 * point = new testClass2();

point-&amp;gt;testFunc(); // 调用派生类函数
point-&amp;gt;testClass1::testFunc(); // 调用父类函数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虚函数原理是在虚函数调用时根据虚表来的确定，虚表中存放了当前类的虚函数，每次调用虚函数都会按固定偏移在虚表中提取函数，所以派生类覆盖了父类后，在虚表中固定偏移的函数就成了派生类的函数了。&lt;/p&gt;

&lt;p&gt;既然派生类覆盖了父类的虚函数，派生类又怎么去调用父类的虚函数呢？其实是由于代码显式的指明了调用方向，所以在编译时编译器就已经知道要调用的哪个函数，也就不需要动态借助虚表来定位了，编译时直接静态绑定父类中函数便可。&lt;/p&gt;

&lt;p&gt;小知识，我们还可以通过final关键字，阻止虚函数派生类覆盖。&lt;/p&gt;

&lt;p&gt;虚函数在构造函数和析构函数中调用要特别小心，因为此时部分成员没有被初始化，例如在父类中调用虚函数，由于此时调用的是子类虚函数，而子类成员还未被初始化，调用虚函数有可能导致不可预测的错误，因此通常在构造和析构函数内执行虚函数时用显式的方式调用当前类的虚函数。&lt;/p&gt;

&lt;h3 id=&quot;改变类成员的访问规则&quot;&gt;改变类成员的访问规则&lt;/h3&gt;

&lt;p&gt;用using声明可以改变基类的成员访问级别&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;class Base
{
  private:
    void testFunc();
  public:
    void testFunc2();
}

class Derived : private Base
{
  public:
    using Base::testFunc;
  protected:
    using Base::testFunc2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述例子中，基类中的testFunc和testFunc2在派生类中的访问级别都被改变了，testFunc从private改为了public，而testFunc2从public改为了protected。&lt;/p&gt;

&lt;p&gt;其实成员变量的访问规则只是编译器的规则，在进程的内存和指令中没有做任何限制，在汇编里你完全可以随意访问所谓的私有变量，限制你的只是编译器。&lt;/p&gt;

</description>
               <pubDate>Sat, 03 Jul 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/07/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B032</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/07/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B032</guid>
            </item>
        
            <item>
               <title>读书笔记(三十一) 《装载、链接与库》#3 动态链接与装载</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484788&amp;amp;idx=1&amp;amp;sn=8e4f7f36e4ddf6dd2f7c086463c089de&amp;amp;chksm=fc226073cb55e965e5ab259f04293c48f718a2fd72858b11397852d8ba8c7fab656b0f46e248&amp;amp;token=283688006&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;背景&quot;&gt;背景：&lt;/h3&gt;

&lt;p&gt;看此书的起源是我在了解Linux注入技术的时候翻阅到的，由于注入技术需要用到很多ELF格式的内容，很多网络上的技术文章都指向了同一本书。也刚好周围的同事有此书，便翻阅了一下，这一番翻阅打开了我对程序世界的又一扇大门。&lt;/p&gt;

&lt;p&gt;很快我就自己买了此书并阅读完成，整本书给我很大的震撼，让我对程序从编译到链接到装载有了更深刻的认识。&lt;/p&gt;

&lt;p&gt;我把我的整个学习过程以及对书本的理解，用自己的语言和自己画的图表达出来，让读者能够更容易接受到我所学的知识。&lt;/p&gt;

&lt;h3 id=&quot;目标&quot;&gt;目标：&lt;/h3&gt;

&lt;p&gt;了解编译过程
了解动态库和静态库的装载细节
了解可执行程序装载和执行过程
了解可执行文件和动态库的数据格式&lt;/p&gt;

&lt;h3 id=&quot;疑问&quot;&gt;疑问：&lt;/h3&gt;

&lt;p&gt;c/c++编译器是如何将cpp编译为可执行文件的？&lt;/p&gt;

&lt;p&gt;多个c/c++文件是如何编译成一个可执行文件的？&lt;/p&gt;

&lt;p&gt;操作系统内存是如何初始化和管理的？&lt;/p&gt;

&lt;p&gt;动态库和静态库的链接和装载过程是怎样的？&lt;/p&gt;

&lt;p&gt;操作系统的用户态和内核态是如何运作的？&lt;/p&gt;

&lt;h3 id=&quot;正文&quot;&gt;正文：&lt;/h3&gt;

&lt;p&gt;前面我们说了ELF格式，以及ELF格式的静态链接过程，Windows也有自己的二进制文件格式，这里简单说一下Windows部分的格式。&lt;/p&gt;

&lt;p&gt;Windows的二进制文件格式称为PE（Protable executable），PE文件格式与ELF同根同源，都是COFF格式发展而来。
Windows平台使用Visual C++编译器产生的目标文件使用COFF文件，它们的结构很大程度上都是相同的。
“cl”是Visual C++的编译器，即“Compiler”的缩写，Visual C++还提供了用于查看目标文件和可执行文件的工具“dumpbin”。&lt;/p&gt;

&lt;h3 id=&quot;可执行文件装载&quot;&gt;可执行文件装载&lt;/h3&gt;

&lt;p&gt;在讲解执行文件装载前先简单介绍下虚拟空间，因为可执行文件装载需要虚拟空间支持，那么什么是虚拟空间呢？&lt;/p&gt;

&lt;h3 id=&quot;虚拟空间&quot;&gt;虚拟空间&lt;/h3&gt;

&lt;p&gt;虚拟空间很多人都认为是一个真实的空间，其实不然，它是我们想象出来的空间，其实并不存在。
而我们在理解的时候却需要承认这个空间的存在，即每个进程都拥有一个自己想象的虚拟空间，地址从0到0xFFFFFFFFF（32位设备）&lt;/p&gt;

&lt;p&gt;操作系统上的使用的内存空间都是虚拟地址空间，而非实际物理空间，它是由操作系统虚构出来的一个地址空间。&lt;/p&gt;

&lt;p&gt;这就像是操作系统给了每个进程一个世界那样，在这个世界里，进程可以自由的申请和释放内存，而不需要理会物理内存如何分配和释放。&lt;/p&gt;

&lt;p&gt;每个进程中的内存从虚拟地址都从0开始，到0xFFFFFFFF结束，其中有1G的空间专门为内核空间所用，用户空间也做了不同的分段。因此整个虚拟空间地址可以分为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;.kernel 内核空间段
.stack 栈内存段
.libraries  动态库映射段（文件映射段）
.heap 堆内存段
.bass 未初始化的全局/静态变量段
.data 已初始化全局/静态变量段
.text 程序指令字节段
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中栈内存大小是固定的，只有1MB内存，栈会不断向下分配内存，回收时只需要调整栈顶指针，因此它的分配和回收效率很高，而堆内存则不断向上分配内存，效率相对较低，回收时也容易产生内存碎片。&lt;/p&gt;

&lt;p&gt;对于Windows操作系统来说，它的进程虚拟地址空间划分是操作系统占用2GB，用户空间剩下2GB。&lt;/p&gt;

&lt;p&gt;从硬件层面上来说原先的总线32位地址只能访问最多4GB物理内存。但自从扩展至36位地址线之后，Intel修改了页映射的方式，使得新的映射方式可以访问到更多的物理内存，这个扩展方式叫做PAE（Physical Address Extension）。原理就是多块物理内存随时交换映射为同一个虚拟内存地址，这样应用程序就不需要管超出部分的内存空间了。不过这只是在32位机时代的补救办法，现在逐渐淘汰了，但这个方法在其他领域里仍然在被使用。&lt;/p&gt;

&lt;p&gt;Linux和Windows操作系统都使用页映射方式管理虚拟内存和物理内存之间的关系&lt;/p&gt;

&lt;h3 id=&quot;虚拟内存与物理内存之间由一个页表作为映射连接它们之间的关系&quot;&gt;虚拟内存与物理内存之间由一个页表作为映射连接它们之间的关系&lt;/h3&gt;

&lt;p&gt;当我们访问一块虚拟空间时，操作系统发现没有这块地址没有被连接到真实的物理地址，此时才真正从真实物理内存中找到一块内存块用页表连接起来，这才真正分配成功并且可以使用。&lt;/p&gt;

&lt;p&gt;每次分配实际物理内存，也并不是分配一整块申请的虚拟内存空间，而是按页大小来分配。即，实际物理空间在使用到时才真正分配，而虚拟空间则已经先行分配。&lt;/p&gt;

&lt;p&gt;因此我们在虚拟内存上申请的连续内存，有可能在物理内存上是不连续的。当然，申请连续内存获得实际连续内存的概率要大很多。&lt;/p&gt;

&lt;p&gt;对虚拟空间来说，一块内存只是一个数据结构，没有实际的占用，也没有真正的空间之说，只是我们说起来容易理解一些。&lt;/p&gt;

&lt;p&gt;程序启动时虚拟内存中很多内存地址都没有被用到，因此也没有对应的物理页，只有当使用到该虚拟内存页时，发现有物理内存缺页的情况，才会发起物理内存申请和映射。&lt;/p&gt;

&lt;p&gt;除了虚拟内存，不一定有实际的物理内存外，实际的物理地址上的内存，也不一定在实际物理内存中。
操作系统又在实际物理内存上加了一个系统用于更好的利用实际物理内存空间，即Swap。&lt;/p&gt;

&lt;p&gt;当检测到某些物理内存上一次使用时间过长时，则会被Swap置换到硬盘空间，为实际物理内存腾出更多空间给其他进程使用。&lt;/p&gt;

&lt;p&gt;我们前文提到，在虚拟存储中，现代的硬件MMU提供了地址转换功能，帮助我们在虚拟地址和物理地址之间的转换。&lt;/p&gt;

&lt;h3 id=&quot;那么执行文件是怎么被装载进进程的呢&quot;&gt;那么执行文件是怎么被装载进进程的呢？&lt;/h3&gt;

&lt;p&gt;大致过程为，先创建一个进程，然后将可执行文件装载进进程，再开始运行程序。&lt;/p&gt;

&lt;p&gt;其中装载可执行文件时需要分三步：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;创建一个独立的虚拟地址空间&lt;/li&gt;
  &lt;li&gt;读取可执行文件头，并建立虚拟空间与可执行文件的映射关系&lt;/li&gt;
  &lt;li&gt;将CPU的指令寄存器设置成可执行文件的入口地址，开始运行&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意，创建一个虚拟空间实际上并不是创建空间，而是创建映射函数所需要的相应的数据结构。在i386的Linux下，创建虚拟地址空间实际上只是分配一个页目录就可以了。&lt;/p&gt;

&lt;p&gt;另外，可执行文件与虚拟空间建立映射关系时，不会有磁盘和内存的装载，当我们读取可执行文件内容时才发生“缺页”并从磁盘中读取文件内容，装载到虚拟内存再通过页表分配实际物理内存。
因此，由于可执行文件在装载时实际上是被映射的虚拟空间地址，所以可执行文件很多时候被称为映像文件（Image）。&lt;/p&gt;

&lt;p&gt;ELF可执行文件引入了Segment的概念，Segment段合并了多个Section，这样的好处是装载时能更高效且方便。
所有相同属性的Section都会归类到一个Segment并映射到同一个匿名虚拟内存区域中（VMA，Anonymous Virtual Memory Area）。&lt;/p&gt;

&lt;h3 id=&quot;linux内核装载elf过程&quot;&gt;Linux内核装载ELF过程&lt;/h3&gt;

&lt;p&gt;内核装载ELF的过程可以描述为如下步骤：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;调用fork()创建一个新的进程&lt;/li&gt;
  &lt;li&gt;新的进程调用execve()执行指定的ELF文件&lt;/li&gt;
  &lt;li&gt;进入execve()后，Linux内核就开始进行真正的装载工作&lt;/li&gt;
  &lt;li&gt;先调用sys_execve()进行一些参数检查与复制&lt;/li&gt;
  &lt;li&gt;再调用do_execve()，它会先查找被执行的文件，去读文件的前128个字节做文件检查，比如魔数的检查。&lt;/li&gt;
  &lt;li&gt;调用search_binary_handle()搜索和匹配合适的可执行文件装载处理过程，比如ELF可执行文件的装载处理过程为load_elf_binary()，以及装载可执行脚本程序的处理过程叫做load_script()。&lt;/li&gt;
  &lt;li&gt;load_elf_binary()执行完毕后由于把系统调用的返回地址改为了装载ELF程序的入口地址，&lt;/li&gt;
  &lt;li&gt;所以当sys_execve()从内核态返回到用户态时，EIP寄存器直接跳转到ELF程序的入口地址，&lt;/li&gt;
  &lt;li&gt;于是新的程序开始执行，ELF可执行文件装载完成。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中load_elf_binary()执行过程为：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;检查ELF可执行文件的有效性，比如魔数、ELF头数据中与Segment的数量&lt;/li&gt;
  &lt;li&gt;获取动态链接的“.interp”段，并设置动态链接器路径。&lt;/li&gt;
  &lt;li&gt;根据ELF可执行文件的头描述，对ELF文件进行映射，比如代码、数据、只读数据。&lt;/li&gt;
  &lt;li&gt;初始化ELF进程环境，比如进程启动时EDX寄存器的地址应该是DT_FINI的地址。&lt;/li&gt;
  &lt;li&gt;将系统调用的返回地址修改成ELF可执行文件的入口点，入口点对于静态链接来说就是ELF头中的e_entry所指的地址，对于动态链接的ELF可执行文件入口点就是动态链接器。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Windows PE的装载过程比ELF简单一些：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;读取文件第一页，里面包含了DOS头、PE文件头和段表&lt;/li&gt;
  &lt;li&gt;检查进程地址空间中目标地址是否可用。如果不可用则另外选一个装载地址，这里可执行文件装载不存在问题，主要针对DLL装载。&lt;/li&gt;
  &lt;li&gt;获取段表中提供的信息，将PE文件中所有的段一一映射到地址空间中相应的位置。&lt;/li&gt;
  &lt;li&gt;如果装载地址不是目标地址，则进行Rebasing重定位。&lt;/li&gt;
  &lt;li&gt;装载所有PE文件所需要的DLL文件。&lt;/li&gt;
  &lt;li&gt;对PE文件中的所有导入符号进行解析。&lt;/li&gt;
  &lt;li&gt;根据PE头中指定的参数，建立初始化栈和堆空间。&lt;/li&gt;
  &lt;li&gt;建立主线程并启动进程。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;动态链接&quot;&gt;动态链接&lt;/h3&gt;

&lt;p&gt;注意，静态链接和动态链接，与静态库和动态库是两个概念，前者说的是程序链接，后者说的是库的不同组装方式。&lt;/p&gt;

&lt;p&gt;静态链接由于必须在编译时就确定好库文件而且每个进程都需要载入一份内存，所以它的缺点是更多内存、更多磁盘空间、模块更新困难。&lt;/p&gt;

&lt;p&gt;我们可以想象一下，每个程序内部都增加一份1MB库程序的内存，那么100个进程就要浪费近100MB的内存，如果磁盘中有2000个这样的程序，就要浪费近2GB磁盘空间，而且在编译后还不能及时更新某个模块，弊端确实挺大的。&lt;/p&gt;

&lt;p&gt;动态链接就很好的解决了这个问题，它不仅可以使得不同进程之间共享一个库内存，还可以减少物理页的换入换出，也可以增加CPU缓存的命中率。
当我们升级程序库时，只要简单的覆盖原文件而无须将所有程序再重新链接一遍，当程序下次运行时新版本库文件就会自动装载到内存完成升级目标。&lt;/p&gt;

&lt;p&gt;注意，动态链接与静态链接在内存分布上也不同。静态链接后的库程序是可执行文件内不可分割的整体，动态链接后的库程序则有自己的独立内存模块。&lt;/p&gt;

&lt;h3 id=&quot;动态库的动态链接过程&quot;&gt;动态库的动态链接过程&lt;/h3&gt;

&lt;p&gt;其实在需要进行动态装载动态库的可执行文件中，已经装载好了一个ld-2.6.so动态库，它实际上就是Linux下的动态链接器。&lt;/p&gt;

&lt;p&gt;我们在开启一个进程时，在装载完执行文件后，进程首先会把控制权交给动态链接器，由它完成所有的动态链接工作，再把控制权交给进程开始执行。&lt;/p&gt;

&lt;p&gt;当我们在代码中写下动态库的函数时，在程序模块动态装载时，应该不需要因为装载地址的改变而改变。
所以实现动态链接的基本想法就是把指令中那些需要被修改的部分分离出来，放到数据那里去，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。&lt;/p&gt;

&lt;p&gt;这种方案称为，地址无关代码（PIC，Position-independent Code）技术方案，通常我们在编译时会加上PIC这个标记，就是告诉编译器，我们这个库是地址无关的。&lt;/p&gt;

&lt;p&gt;如果一个库不是以地址无关（PIC）模式编译的，那么毫无疑问，它需要在装载时被重定位，即在启动执行时就需要装载库文件并且重定位所有与库文件有关的函数调用地址。&lt;/p&gt;

&lt;p&gt;如果一个库是以地址无关（PIC）模式编译的，那么就不会在装载时对整个库函数相关调用进行重定位，而是会用延迟绑定（PLT）的方式实时定位函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;static int a;
extern int b;
extern void ext();

void bar()
{
  a = 1; // 模块内数据访问
  b = 2; // 外部模块数据访问
}

void foo()
{
  bar(); // 模块内函数调用
  ext(); // 外部模块函数调用
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上图为例模块内和模块间的数据访问和函数调用方法，&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;模块内的函数调用使用相对地址调用&lt;/li&gt;
  &lt;li&gt;模块内的数据访问使用相对寻址方式&lt;/li&gt;
  &lt;li&gt;模块外的数据访问，由于无法知道外部数据的具体地址，所以需要借助全局偏移表（GOT）获取外部数据&lt;/li&gt;
  &lt;li&gt;模块外的函数调用，由于无法知道外部函数的具体地址，所以需要借助全局偏移表（GOT）获取外部函数地址后再调用&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;这样说来got就是关键中的关键那么got是怎么工作的呢&quot;&gt;这样说来GOT就是关键中的关键，那么GOT是怎么工作的呢？&lt;/h3&gt;

&lt;p&gt;大致的方案得从编译说起，我们知道在使用printf，scanf()，strlen()这样的公用库函数时都需要加载公共库libc.so，但公共库并没有被合并到可执行文件中，也就没有可依赖的地址规则。&lt;/p&gt;

&lt;p&gt;所以编译器在编译这些外部函数的时候，其实并不知道它们的调用地址是多少，无法填充真实地址。
但编译器会填充一个地址指向一段动态程序，当这个函数真正被调用时，先调用到动态程序，再由动态程序去寻找真正的调用地址，最后再调用真实地址的函数。&lt;/p&gt;

&lt;p&gt;这种方法就是延迟绑定（PLT），即进程启动加载外部so后并不立刻对任何调用到so函数的指令做重定位，而是当这些外部函数被调用到时才去寻找并且绑定函数与真实地址的关系。&lt;/p&gt;

&lt;p&gt;动态链接对全局和静态数据的访问要进行复杂的GOT定位，然后再间接寻址，对外部模块中的函数调用先定位GOT，然后再进行间接跳转。&lt;/p&gt;

&lt;h3 id=&quot;got延迟绑定plt运行原理&quot;&gt;GOT延迟绑定（PLT）运行原理&lt;/h3&gt;

&lt;p&gt;从上图中我们可以知道PLT有3个关键点：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;跳转到动态绑定程序&lt;/li&gt;
  &lt;li&gt;查找外部函数地址的程序&lt;/li&gt;
  &lt;li&gt;GOT表中数据的存储与读取&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们就从这三个关键点入手说明PLT的运行原理&lt;/p&gt;

&lt;p&gt;当我们在代码里编写外部模块函数，在编译时编译器为我们留下的其实是PLT程序的地址，这个地址就是专门为这个外部函数服务的动态绑定程序，在.plt段里，符号以@plt结尾。&lt;/p&gt;

&lt;p&gt;动态绑定程序中有3条指令：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;第一条就是跳转到GOT中去获取真实地址，如果有就直接跳转，没有就再跳转回来到第二条。&lt;/li&gt;
  &lt;li&gt;第二条和第三条指令是去查找函数真实地址，找到函数真实地址后把数据写入GOT中并跳转到真实地址。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;.plt段里动态绑定程序才是真实的查找函数地址的过程，其查找函数真实地址步骤为：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;将重定位表（.rel.plt）下标传入动态链接器_dl_runtime_resove()，&lt;/li&gt;
  &lt;li&gt;由它来完成符号解析和重定位工作，&lt;/li&gt;
  &lt;li&gt;再将函数的真实地址写入到GOT表中，最后跳转到真实地址。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ELF将GOT拆分成两个表，“.got”和“.got.plt”，其中“.got”用来保存全局变量引用地址，“.got.plt”用来保存函数引用地址。&lt;/p&gt;

&lt;p&gt;其中“.got.plt”的前三项有着特殊意义：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;第一项保存的是“.dynamic”段地址，该段描述了本模块动态链接相关的信息。&lt;/li&gt;
  &lt;li&gt;第二项保存的是本模块的ID。&lt;/li&gt;
  &lt;li&gt;第三项保存的是_dl_runtime_resolve()地址。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;三项中的第二项和第三项由动态链接器在装载模块时将它们填充。
第四项也稍有些特殊，通常会将跳转指令的通用程序放在第四项中以减少代码重复，因此“.got.plt”基本上前4项都是确定的内容。&lt;/p&gt;

&lt;h3 id=&quot;动态链接相关的数据结构&quot;&gt;动态链接相关的数据结构&lt;/h3&gt;

&lt;p&gt;在整个PLT绑定、查找和定位过程中用到了好几个数据段，这里介绍一下。&lt;/p&gt;

&lt;p&gt;.interp段里保存了一个字符串，这个字符串就是可执行文件件所需要的动态链接器的路径，Linux下动态链接器通常都在“/lib/ld-linux.so.2”，它通常是个软连接指向真正的库。&lt;/p&gt;

&lt;p&gt;.dynamic段是ELF动态链接最重要的结构，里面保存了动态链接器所需要的基本信息，比如依赖于哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。&lt;/p&gt;

&lt;p&gt;它有点像ELF文件头，只是ELF文件头中保存的是静态链接时需要的信息，比如符号表、重定位表等，.dynamic可以看成是动态链接下所需要的信息。&lt;/p&gt;

&lt;p&gt;.dynsym段是动态符号表，与.symtab符号表不同的是，.dynsym动态符号表只保存了与链接相关的符号，也就是外部接口符号表，对于那些模块内部的符号则不保存。&lt;/p&gt;

&lt;p&gt;为了在.dynsym中查找到对应的符号，会有一个动态符号字符串表.dynstr和符号哈希表.hash来辅助定位和查找符号字符串，加快了符号查找过程。&lt;/p&gt;

&lt;p&gt;.rel.dyn和.rel.plt段位动态链接时的重定位表，与我们之前在静态链接里介绍的.rel.text和.rel.data的用途类似，存储的是需要重定位的符号和全局数据。&lt;/p&gt;

&lt;p&gt;与.rel.text和.rel.data的区别在于，.rel.dyn实际上只是修正地址的引用，并不是实际数据地址，他修正的位置其实位于.got以及数据段中；同样的，.rel.plt修正的也只是函数地址的引用，而不是实际地址，其真正地址位于.got.plt中。&lt;/p&gt;

&lt;p&gt;了解了这几个段的用途，我们可以把调用动态库的延迟重定位的整个过程串连起来了：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;程序调用动态库中函数&lt;/li&gt;
  &lt;li&gt;跳转到PLT程序集中&lt;/li&gt;
  &lt;li&gt;从GOT中获取真实函数地址，有则直接跳转&lt;/li&gt;
  &lt;li&gt;没有则从.rela.plt中获取相关信息并调用_dl_runtime_resolve()查找真实函数地址&lt;/li&gt;
  &lt;li&gt;_dl_runtime_resolve()根据查找到的so中的.dynsym动态符号表找到真实函数地址&lt;/li&gt;
  &lt;li&gt;将真实地址填充到GOT中并跳转&lt;/li&gt;
  &lt;li&gt;库函数调用结束&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;动态链接器自己重定位&quot;&gt;动态链接器自己重定位&lt;/h3&gt;

&lt;p&gt;我们说动态链接器本身就是一个库文件（ld-linux.so），所以在进程把控制权交给动态链接器前必须先要将这个库装载到进程中，由于此时又没有程序能去重定位这个动态链接器的库，因此动态链接库必须自己来给自己做重定位，这个重定位过程称为“自举”。&lt;/p&gt;

&lt;p&gt;自举的过程可以简单描述为：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;通过自己的.dynamic段，找到它自己的重定位表和符号表&lt;/li&gt;
  &lt;li&gt;再根据重定位表和符号表，重定位所有符号表&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;自举期间不能调用函数，因为模块内函数调用必须采用GOT/PLT方式，但GOT/PLT没有被重定位，因此自举代码不可以使用任何全局变量或调用函数。&lt;/p&gt;

&lt;p&gt;动态链接器自举完成后，就可以通过.dynamic段获取所有需要装载的动态库依次装载、解析、重定位。
每个需要被装载的动态库，在装载完成后它的符号表都会被合并到全局符号表（Global Symbol Table）中，全局符号表包含了进程中所有动态链接需要的符号。&lt;/p&gt;

&lt;h3 id=&quot;运行时链接&quot;&gt;运行时链接&lt;/h3&gt;

&lt;p&gt;前面说的静态链接和动态链接都是在程序还未完全启动前做的事情，运行时链接则是在程序进行中加载动态库的一种方式。&lt;/p&gt;

&lt;p&gt;运行时链接的接口有4个，分别是：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;dlopen，装载指定动态库&lt;/li&gt;
  &lt;li&gt;dlsym，获取动态库中的某个符号的地址&lt;/li&gt;
  &lt;li&gt;dlerror，获取上次调用的错误信息&lt;/li&gt;
  &lt;li&gt;dlclose，关闭并卸载动态库&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;运行时链接与动态链接的一模一样（除了自举部分），区别一个在启动时装载，另一个则在程序运行时装载。&lt;/p&gt;

&lt;p&gt;注意，由于所有加载的动态库中的符号都会合并到全局符号表，因此在加载多个库时如果有重复的符号，则后加载的符号可以根据参数选择是否覆盖前面的符号表，默认是不覆盖的。&lt;/p&gt;

&lt;p&gt;这里作者做了一个试验，因为在Windows中有个rundll的小程序可以直接调用DLL中的函数并返回结果，所以作者想在Linux上也实现一个。
于是自己写代码读取动态库so中的函数并调用后打印返回结果，其原理就是利用这4个函数，先dlopen加载指定so，再根据函数名调用dlsym找到函数地址并且调用，最后调用dlerror卸载动态库。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484788&amp;amp;idx=1&amp;amp;sn=8e4f7f36e4ddf6dd2f7c086463c089de&amp;amp;chksm=fc226073cb55e965e5ab259f04293c48f718a2fd72858b11397852d8ba8c7fab656b0f46e248&amp;amp;token=283688006&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

</description>
               <pubDate>Sun, 27 Jun 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/06/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B031</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/06/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B031</guid>
            </item>
        
            <item>
               <title>读书笔记(三十) 《C++ Primer》#4</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484770&amp;amp;idx=1&amp;amp;sn=417618b18d6a0bf34b5fa720031f6312&amp;amp;chksm=fc226065cb55e973587b7a3e372b71acf1def7cb7b04ce3ba2d43a5e4871582f72459bcb962d&amp;amp;token=283688006&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;背景&quot;&gt;背景：&lt;/h3&gt;

&lt;p&gt;我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意。第三是当我们在巩固时创造出了新的知识，那么这些新的知识和旧的知识将同时变成智慧融合到身体中。&lt;/p&gt;

&lt;p&gt;本系列基于《C++ Primer》学习，由于重点放在“重学”，我略过了滚瓜烂熟的部分，挑出以前常忽略的部分，以及记忆没有那么深刻的部分，特别是那些重要的但没有上心的部分。&lt;/p&gt;

&lt;h3 id=&quot;正文&quot;&gt;正文&lt;/h3&gt;

&lt;h3 id=&quot;类相关定义&quot;&gt;类相关定义&lt;/h3&gt;

&lt;p&gt;注意，this指针是常量指针，因为我们不允许改变this指针中保存的地址。&lt;/p&gt;

&lt;p&gt;当我们定义类相关的非成员函数时，即如果函数在概念上属于类但不定义在类中，则它一般应与类声明在同一个头文件中。
这种方式下，当用户使用接口的任何部分都只需要引用一个文件，举例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;//testClass.h

//类声明
class testClass {
  //test class
  public:
    int testVar;
}

//类相关的非成员函数
int readFrom_testClass(const testClass &amp;amp; item);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认合成的构造函数&lt;/p&gt;

&lt;p&gt;编译器创建的默认构造函数称为，合成的默认构造函数（synthesized default constructor），它的规则如下：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;如果存在类内的初始值，用它来初始化成员。&lt;/li&gt;
  &lt;li&gt;否则，默认初始化该成员。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;合成的默认构造函数只适合非常简单的类，其他某些类不能依赖于合成默认构造函数，原因有三：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;编译器只有在发现类不包含任何构造函数的情况下才替我们生成一个默认的构造函数。&lt;/li&gt;
  &lt;li&gt;类中含有内置类型或者复合类型成员的类应该在类的内部初始化这些成员，否则使用默认构造函数可能得到未定义值。&lt;/li&gt;
  &lt;li&gt;类中含有其他类型成员且成员类型没有默认构造函数，则默认构造函数无法初始化这个成员。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当然最好是我们自己定义每个类的构造函数而不是让编译器使用默认构造函数，如果你不能使用类内初始化值，则所有构造函数都应该显式地初始化每个内置类型的成员。&lt;/p&gt;

&lt;h3 id=&quot;class和struct的区别&quot;&gt;Class和Struct的区别&lt;/h3&gt;

&lt;p&gt;与C#、Java不同，C++中Class和Struct几乎一样，只是关键字不同和使用习惯不同而已。
唯一的微小区别就是，使用Class的默认访问模式为private，而struct的默认访问模式是public。&lt;/p&gt;

&lt;h3 id=&quot;友元&quot;&gt;友元&lt;/h3&gt;

&lt;p&gt;友元允许其他类或函数访问自己的非公有成员，这个大家都知道就不多说了。
需要注意的是友元关系不存在传递性，也就是说子类的友元并不能理所当然的访问父类。
而且想要所有重载函数成为友元关系，必须为每个重载函数做一次友元声明。&lt;/p&gt;

&lt;p&gt;不过在编译时，友元的声明仅仅指定了访问的权限，它只是标记编译的语法规则好让编译器在语法检查时能知道友元标记的存在，实际上编译器并没有做任何内存上和寄存器上的修改。&lt;/p&gt;

&lt;h3 id=&quot;构造函数初始值列表&quot;&gt;构造函数初始值列表&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;class testClass
{
  public:
      testClass(int ii);
  private:
      int i;
      const int ci;
      int &amp;amp;ri;
}

testClass::testClass(intii):
    i(ii),ci(ii),ri(i)
{
  //do something
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在类中常使用以上这种构造函数来初始化成员，其实这就相当于成员的初始化顺序，即先初始化i，然后ci，然后ri。&lt;/p&gt;

&lt;h3 id=&quot;隐式的类构造转换&quot;&gt;隐式的类构造转换&lt;/h3&gt;

&lt;p&gt;在对象构造时，也会出现隐式的构造情况，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;class Test_data
{
   Test_data(const string str);
}

string test_str = &quot;test&quot;;
Vector&amp;lt;Test_data&amp;gt; item;
item.push(test_str);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果构造函数只接受一个实参，则实际上它同时也定义了转换为此类类型的隐式转换机制，我们把这种构造函数称为，转换构造函数（converting constructor）。&lt;/p&gt;

&lt;p&gt;上面例子中传入的string对象从而引发了Test_data的转换构造函数，构造出对象后再传入，其实这些隐式转换和构造都是在编译时离线计算的，根本不会放到运行时去发生。&lt;/p&gt;

&lt;p&gt;如果你不想让隐式构造发生，可以通过在构造函数前加 explicit 声明来阻止隐式转换，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;class Test_data
{
   explicit Test_data(const string str);
}

string test_str = &quot;test&quot;;
Vector&amp;lt;Test_data&amp;gt; item;
item.push_back(test_str); // 编译错误

item.push_back(Test_data(test_str)); // 编译正确
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;声明了explicit的构造函数，只能以直接初始化的形式使用，编译器将不会再进行隐式的自动转换这些构造函数。&lt;/p&gt;

&lt;h3 id=&quot;io库&quot;&gt;IO库&lt;/h3&gt;

&lt;p&gt;这里有些零散的知识需要注意下。&lt;/p&gt;

&lt;p&gt;IO库定义了很多标记，这些标记可以帮助我们访问和操作流，例如由于流可能处于错误状态，我们在操作之前先去检查它是否处于良好状态。
其中badbit标记相对用的比较多，它表示系统级错误，例如不可恢复的读写错误。通常情况下，一旦badbit被置位，流就无法再使用了。&lt;/p&gt;

&lt;p&gt;IO流有缓冲机制，这可以提升IO的性能，当刷新时才将数据写入到文件中。&lt;/p&gt;

&lt;p&gt;导致缓冲刷新的几种情况为：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;程序正常结束，main函数return操作。&lt;/li&gt;
  &lt;li&gt;缓冲区满时，需要刷新缓冲。&lt;/li&gt;
  &lt;li&gt;使用操作符endl来显式刷新缓冲区。&lt;/li&gt;
  &lt;li&gt;使用操作符unitbuf设置流的内部状态，清空缓冲区。&lt;/li&gt;
  &lt;li&gt;一个输出流被关联到另一个流时，输出流会被刷新。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意，如果程序崩溃了，输出流的缓冲区是不会被刷新的，这也是为什么崩溃时部分数据没有被写入文件的原因。&lt;/p&gt;

&lt;h3 id=&quot;顺序容器&quot;&gt;顺序容器&lt;/h3&gt;

&lt;p&gt;顺序容器指，vector，deque，list，array，string，它们都可以用迭代器访问元素。
如果我们不需要写访问元素，则应该使用cbegin和cend来获取常量迭代指针。&lt;/p&gt;

&lt;p&gt;顺序容器中有一个方法比较有趣assign（array除外），它可以用参数所指定的元素（拷贝形式）替换容器中的所有元素。
seq.assign(b,e); // 将seq替换为迭代器b到e范围内的元素
seq.assign(il); // 将seq替换为容器列表il中的元素
seq.assign(il); // 将seq替换为n个t值的元素&lt;/p&gt;

&lt;p&gt;注意，当我们用一个对象来初始化容器，或者将一个对象插入到容器中时，实际上放入到容器中的是对象的拷贝，而不是对象本身。就像我们将一个对象传递给非引用参数一样，容器中的元素与提供值的对象之间没有任何关联。&lt;/p&gt;

&lt;p&gt;另外我们也要注意向容器中添加元素或删除元素的操作，可能会使得指向容器的指针、引用、迭代器失效，进而导致运行时错误。&lt;/p&gt;

&lt;h3 id=&quot;泛型算法&quot;&gt;泛型算法&lt;/h3&gt;

&lt;p&gt;标准库并没有给每个容器添加大量功能，而是提供了一组算法，这些算法大多是通用算法，可以独立于任何特定的容器。&lt;/p&gt;

&lt;p&gt;归纳总结下来，泛型算法有4个特点：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;大多是通用算法，可以独立于任何特定的容器&lt;/li&gt;
  &lt;li&gt;虽然独立于任何容器，但有些算法依赖于元素类型（例如累加算法依赖于带有加法运算的对象类型）。&lt;/li&gt;
  &lt;li&gt;不会直接操作容器，而是运行于迭代器之上，执行的是迭代器的操作。&lt;/li&gt;
  &lt;li&gt;算法可能改变容器中保存的值，或移动容器中的元素，但永远不会直接添加或者删除元素。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;lambda函数&quot;&gt;lambda函数&lt;/h3&gt;

&lt;p&gt;当定义一个lambda函数时，编译器生成一个与lambda对应的新（未命名的）类类型。&lt;/p&gt;

&lt;p&gt;也就是说当向一个函数传递一个lambda函数时，编译器同时定义了一个新类型和该类型的一个对象，传递的参数就是此编译器生成的类类型的未命名对象，而不是传入的对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void func1()
{
  int v1 = 41;
  auto f = [v1] {return v1;}; // 值捕获
  v1 = 0;
  auto j = f(); // j 为 41

  auto f2 = [&amp;amp;v1] {return v1;} // 引用捕获
  v1 = 2;
  auto j = f2(); // j 为 2
}


transform(v1.begin(), vi.end(), vi.begin(), [](int i) -&amp;gt; int { if (i &amp;lt; 0) return -i; else return i; }); // lambda函数指定了int返回值和int形参
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，如上代码中，如果lambda形参为引用则需要我们注意实参的生命周期，因为在lambda执行时，如果该对象已经被销毁则可能引起运行时错误。&lt;/p&gt;

&lt;p&gt;除了使用lambda创建快速创建函数外，也可以使用标准库里bind函数来生成函数，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;// 格式： auto newCallable = bind(callable, arg_list);

void func1(int a, int b)
{
  return a + b;
}

int aa = 1;
int bb = 2;
auto newFunc1 = bind(func1, aa, bb); // 生成一个新的可调用对象来适配算法
auto wc = find_if(words.begin(), words.end(), newFunc1); // bind生成了一个适配泛型算法的函数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bind可以看做是一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484770&amp;amp;idx=1&amp;amp;sn=417618b18d6a0bf34b5fa720031f6312&amp;amp;chksm=fc226065cb55e973587b7a3e372b71acf1def7cb7b04ce3ba2d43a5e4871582f72459bcb962d&amp;amp;token=283688006&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

</description>
               <pubDate>Sat, 26 Jun 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/06/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B030</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/06/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B030</guid>
            </item>
        
            <item>
               <title>读书笔记(二十九) 《装载、链接与库》#2 静态链接过程</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484763&amp;amp;idx=1&amp;amp;sn=f1b3d678c1309a66d44b64b7ff22a002&amp;amp;chksm=fc22605ccb55e94a53558e85fdbe196fc58612fe20c88f35f8c0f4098e240ef48bcd2da099b0&amp;amp;token=535520395&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;背景&quot;&gt;背景：&lt;/h3&gt;

&lt;p&gt;看此书的起源是我在了解Linux注入技术的时候翻阅到的，由于注入技术需要用到很多ELF格式的内容，很多网络上的技术文章都指向了同一本书。也刚好周围的同事有此书，便翻阅了一下，这一番翻阅打开了我对程序世界的又一扇大门。&lt;/p&gt;

&lt;p&gt;很快我就自己买了此书并阅读完成，整本书给我很大的震撼，让我对程序从编译到链接到装载有了更深刻的认识。&lt;/p&gt;

&lt;p&gt;我把我的整个学习过程以及对书本的理解，用自己的语言和自己画的图表达出来，让读者能够更容易接受到我所学的知识。&lt;/p&gt;

&lt;h3 id=&quot;目标&quot;&gt;目标：&lt;/h3&gt;

&lt;p&gt;了解编译过程&lt;/p&gt;

&lt;p&gt;了解动态库和静态库的装载细节&lt;/p&gt;

&lt;p&gt;了解可执行程序装载和执行过程&lt;/p&gt;

&lt;p&gt;了解可执行文件和动态库的数据格式&lt;/p&gt;

&lt;h3 id=&quot;疑问&quot;&gt;疑问：&lt;/h3&gt;

&lt;p&gt;c/c++编译器是如何将cpp编译为可执行文件的？&lt;/p&gt;

&lt;p&gt;多个c/c++文件是如何编译成一个可执行文件的？&lt;/p&gt;

&lt;p&gt;操作系统内存是如何初始化和管理的？&lt;/p&gt;

&lt;p&gt;动态库和静态库的链接和装载过程是怎样的？&lt;/p&gt;

&lt;p&gt;操作系统的用户态和内核态是如何运作的？&lt;/p&gt;

&lt;h3 id=&quot;正文&quot;&gt;正文：&lt;/h3&gt;

&lt;p&gt;前文《链接、装载与库-回顾基础》说了计算机设备的架构，硬盘的存储方式，内存虚拟空间的意义，多线程调度和安全的本质，以及代码编译的整体流程。&lt;/p&gt;

&lt;p&gt;我们平常用C++代码编译出来的可执行文件、静态库、动态库，看上去它们的不一样的东西，其实它们的数据格式是相同的。&lt;/p&gt;

&lt;p&gt;现代流行的操作系统分Windows和Linux两种，因此我们主要介绍这两种平台下的文件格式。在Windows下的可执行文件格式称为PE（Portable Executable），在Linux下则称为ELF（Executable Linkable Format），其实它们都是COFF（Common file format）格式的变种。&lt;/p&gt;

&lt;p&gt;不光是可执行文件，动态链接库（DLL，Dynamic Linking Library）和静态链接库（Static Linking Library）都是按照可执行文件格式存储的。&lt;/p&gt;

&lt;p&gt;静态链接库稍有不同，它把很多目标文件捆绑在一起形成一个文件，可以简单把它理解为一个包含很多目标文件的文件包。&lt;/p&gt;

&lt;p&gt;单个目标文件简单的结构介绍&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int global_init_var = 84; // 已初始化全局变量
int global_uninit_var; // 未初始化全局变量

//全局函数
void func1( int i)
{
    printf(&quot;%d\n&quot;,i);
}

//入口函数
int main(void)
{
    static int static_var = 85; // 已初始化静态变量
    static int static_var2; // 未初始化静态变量

    int a = 1; // 已初始化局部变量
    int b; // 未初始化局部变量
    func1(static_var + static_var2 + a + b); // 调用全局函数

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们先以目标文件为例，来举一个简单的文件ELF结构。目标文件是最常见的编译单位，它将指令代码、数据以Section的形式存储在文件中。&lt;/p&gt;

&lt;p&gt;上图中我们简单说明了程序、已初始化全局数据、未初始化全局数据在目标文件中的存放位置。
其中.data段保存的是已初始化了的全局静态变量和局部静态变量，这些数据是可写可读的，而只读数据则存放在.rodata中，例如const修饰的变量和字符串常量。
用.rodata单独保存只读数据能够更加好的保护数据，任何修改.rodata中的数据都会作为非法操作处理。&lt;/p&gt;

&lt;p&gt;类似的Section段有很多，我们列举一些重要的来说：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;.bss：包含程序运行时未初始化的数据（全局变量和静态变量）。当程序运行时，这些数据初始化为0。
.data和.data1，包含初始化的全局变量和静态变量。
.dynamic，包含了动态链接的信息，包括链接器地址、需要的动态库、段地址信息，类型为SHT_DYNAMIC。
.dynstr，包含了动态链接用的字符串，通常是和符号表中的符号关联的字符串，类型为SHT_STRTAB。
.dynsym，包含动态链接函数符号表和地址，没有地址的则为0，标志SHF_ALLOC，类型为SHT_DYNSYM。
.fini，正常结束时要执行的析构程序，类型为SHT_PROGBITS。
.got，全局偏移表(global offset table)，类型为SHT_PROGBITS。
.hash，包含符号hash表，用于快速查找函数名的。标志SHF_ALLOC，类型为SHT_HASH。
.init，程序运行或加载时初始化程序。类型为SHT_PROGBITS。
.interp，该节内容是一个字符串，指定了程序链接器的路径名。如果文件中有一个可加载的segment包含该节，属性就包含SHF_ALLOC，否则不包含。类型为SHT_PROGBITS。
.plt 过程链接表（Procedure Linkage Table），类型为SHT_PROGBITS。
.rodata和.rodata1， 包含只读数据，组成不可写的段。标志SHF_ALLOC，类型为SHT_PROGBITS。
.shstrtab，包含section的名字，真正的字符串存储在.shstrtab中，其他都是索引。类型为SHT_STRTAB。
.strtab，包含字符串，通常是符号表中符号对应的变量名字和函数名。类型为SHT_STRTAB。
.symtab，Symbol Table，符号表。包含了所有符号信息，包括变量、函数、定位、重定位符号定义和引用时需要的信息。符号表是一个数组，Index 0 第一个入口，它的含义是undefined symbol index， STN_UNDEF。
.rela.dyn，包含了除PLT以外的 RELA 类型的动态库重定向信息。
.rela.plt，包含了PLT中的 RELA 类型的动态库重定向信息
.rela.text 代码重定位表
.rela.data 数据重定位表
.line，调试时的行号表，即源代码行号与编译后指令的对应表
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们想自定义些Section，可以用__attribute__((section(“name”)))把相应的变量或函数放到“name”作为段名的段中，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;__attribute__((section(&quot;GlobalTest&quot;))) int global = 42;

__attribute__((section(&quot;FuncTest&quot;))) void foo()
{
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么ELF结构在文件中是以怎样的形式存在的呢？&lt;/p&gt;

&lt;h3 id=&quot;下面是elf文件的大致布局&quot;&gt;下面是ELF文件的大致布局&lt;/h3&gt;

&lt;p&gt;（来源ELF描述文档 http://www.skyfree.org/linux/references/ELF_Format.pdf）&lt;/p&gt;

&lt;p&gt;左边是ELF的链接视图，可以理解为是目标代码文件的内容布局。右边是ELF的执行视图，可以理解为可执行文件的内容布局。
目标代码文件（编译过程中的.o文件）的内容是由Section组成的，而可执行文件（二进制可执行文件或库文件）的内容是由Segment段组成的。&lt;/p&gt;

&lt;p&gt;ELF header的定义可以在 /usr/include/elf.h 中找到。Elf32_Ehdr是32位 ELF header的结构体。Elf64_Ehdr是64位ELF header的结构体。
    （Linker and Libraries Guide：https://docs.oracle.com/cd/E19120-01/open.solaris/819-0690/chapter6-43405/index.html）&lt;/p&gt;

&lt;p&gt;其中e_ident的前4个字节是魔数，魔数是固定的，它用来确认文件的类型，操作系统在加载可执行文件时会确认魔数是否正确，如果不正确则说明文件不是ELF格式，则拒绝加载。&lt;/p&gt;

&lt;h3 id=&quot;elf的整体结构&quot;&gt;ELF的整体结构&lt;/h3&gt;

&lt;p&gt;现在我们知道了，ELF Header描述了Program header table 和 Section header table，Program header table 又描述了Segment摘要，Section header table 又描述了Section摘要。&lt;/p&gt;

&lt;h3 id=&quot;那么-program-header-table-和-section-header-table-究竟是怎么去描述segment和section摘要的呢&quot;&gt;那么 Program header table 和 Section header table 究竟是怎么去描述Segment和Section摘要的呢？&lt;/h3&gt;

&lt;p&gt;前面我们说ELF Header里已经有了Program header table 和 Section header table的位置的偏移量，有了它们每个table的大小，以及有多少个table，我们就能知道Program header table 和 Section header table的起始地址、每个结构体的位置、以及它们的范围。&lt;/p&gt;

&lt;p&gt;也就是说，每个Program header table 和 Section header table是一个由固定大小结构体组成的数组，于是可以根据ELF Header来确定它们的数据内容和范围。&lt;/p&gt;

&lt;p&gt;我们来看下它们的结构体，Program header结构：&lt;/p&gt;

&lt;p&gt;Section header结构：&lt;/p&gt;

&lt;p&gt;这里特别从重要的几个Section中挑出几个特别重要的字段来重点说明下。&lt;/p&gt;

&lt;h3 id=&quot;重定位表&quot;&gt;重定位表&lt;/h3&gt;

&lt;p&gt;任何需要重定位的Section都需要一个重定位表，例如&lt;/p&gt;

&lt;p&gt;.text需要.rel.text来辅助重定位
.data需要.rel.data来辅助重定位
.rela.dyn，用于动态重定位变量的表
.rela.plt，则用于动态重定位函数的表&lt;/p&gt;

&lt;p&gt;重定位分为两种&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一种是静态编译时重定位，在编译时重定位&lt;/li&gt;
  &lt;li&gt;另一种是动态加载时重定位，在执行时重定位&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;重定位我们放后面详细介绍&quot;&gt;重定位我们放后面详细介绍&lt;/h3&gt;

&lt;h3 id=&quot;字符串表&quot;&gt;字符串表&lt;/h3&gt;

&lt;p&gt;字符串主要用于匹配函数和变量名，但不同用途的字符串也会分开存放。&lt;/p&gt;

&lt;p&gt;.shstrtab，包含section名字的字符串存储在.shstrtab中
.strtab，包含符号表中符号对应的变量名字和函数名的字符串
.symtab，Symbol Table符号表，包含了所有符号信息，包括变量、函数、定位、重定位符号定义和引用时需要的信息，这里所有的字符串都只有索引指向.strtab中的内容。
.dynstr，包含了动态链接用的字符串，通常是和符号表中的符号关联的字符串
.hash，包含符号hash表，用于快速查找函数名和变量名&lt;/p&gt;

&lt;p&gt;字符串表中包含了存储字符串的表、存储索引的表、以及hash表，它们的用途分别是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;存储字符串的表目的是存储真实字符串数据&lt;/li&gt;
  &lt;li&gt;其他表有需要字符串的都用索引表示以节省内存&lt;/li&gt;
  &lt;li&gt;hash表则主要用于快速查找和比较字符串&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;符号表&quot;&gt;符号表&lt;/h3&gt;

&lt;p&gt;符号表主要用于记录函数名、变量名和地址，例如：&lt;/p&gt;

&lt;p&gt;.symtab，Symbol Table符号表，包含了所有符号信息，包括变量、函数、定位、重定位符号定义和引用时需要的信息
.dynsym，包含动态链接函数符号表和地址，没有地址的则为0&lt;/p&gt;

&lt;p&gt;这两者的区别是，symtab记录了所有符号，包括内部的和外部的函数和变量，而.dynsym则只包含了对外动态加载时需要提供的函数和变量，可以.dynsym是.symtab的阉割版。&lt;/p&gt;

&lt;p&gt;symtab的数据结构为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;typedef struct{
  Elf32_Word st_name; // 符号名在符号表中的索引
  Elf32_Addr st_value; // 符号相对应的值，是地址或者其他值
  Elf32_Word st_size; // 符号大小，包含数据的符号，该值为占用大小
  unsigned char st_info; // 符号类型和绑定信息
  unsigned char st_other; // 无用，值为0
  Elf32_Half st_shndx; // 符号所在段的索引
} Elf32_Sym;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;函数签名规则&quot;&gt;函数签名规则&lt;/h3&gt;

&lt;p&gt;前面说函数名就是符号名，会存储在符号表中，但C++中函数名常常会有相同的时候，因此编译器在编译时会对函数名进行处理，以区别不同范围内的函数。&lt;/p&gt;

&lt;p&gt;我们称这种改变符号名的机制为函数签名（Function Signature）。
签名后的函数名，包含了函数名、它的参数类型、它所在的类和命名空间以及其他信息。&lt;/p&gt;

&lt;p&gt;签名规则每种编译器都不一样，GCC编译器的规则为，所有符号以“_Z”开头，对于嵌套的名字后面紧跟“N”，然后是各个名称空间和类的名字，每个名字前是名字字符串长度，再以“E”结尾，“E”后面是参数列表，对于int类型来说就是字母“i”，float类型来说就是字母“f”，以此类推。&lt;/p&gt;

&lt;p&gt;来举几个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;* int func(int)  签名后--&amp;gt; _Z4funci --&amp;gt; _Z开头，4个字符的函数名func，参数是i整型
* float func(float) 签名后--&amp;gt; _Z4funcf --&amp;gt; _Z开头，4个字符的函数名func，参数是f浮点型
* int C::func(int) 签名后--&amp;gt; _ZN1C4funcEi --&amp;gt; _Z开头，嵌套1个字符C，接4个字符的函数名func，E结尾，参数是i整型
* int C::C2::func(int) 签名后--&amp;gt; _ZN1C2C24funcEi --&amp;gt; _Z开头，嵌套1个字符C，再嵌套2个字符C2，接4个字符的函数名func，E结尾，参数是i整型
* int N::func(int) 签名后--&amp;gt; _ZN1N4funcEi --&amp;gt; _Z开头，嵌套1个字符N，接4个字符函数名func，E结尾，参数是i整型
* int N::C::func(int) 签名后--&amp;gt; _ZN1N1C4funcEi --&amp;gt; _Z开图，嵌套1个字符N，再嵌套1个字符C，接4个字符func，E结尾，参数是i整型
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于不同编译器的签名规则不同，所以当我们要使用C语言写的外部函数时，就需要告诉编译器使用C语言的命名规则&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extern &quot;C&quot;{
  int func(int);
  int var;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们在C++中没有使用extern “C”申明会如何？
如果我们没有正确告知编译器外部引用函数的编译器规则，则在链接器链接时就会因为符号不匹配而无法链接，因此对于C++引用C函数来说，必须使用extern “C”来声明编译器规则。&lt;/p&gt;

&lt;h3 id=&quot;强符号弱符号强引用弱引用&quot;&gt;强符号弱符号，强引用弱引用&lt;/h3&gt;

&lt;p&gt;通常我们定义的变量和函数都是强符号和强引用，意思是当符号冲突时会直接覆盖原来的符号，而弱符号和弱引用则是当符号冲突时不覆盖原来的。
在编写通用库、共享库程序时，弱符号和弱引用，可以起到替换和被替换的作用。
例如库中定义的弱符号被用户定义的强符号覆盖，从而使得程序可以使用自定义版本的库函数；或者扩展某个功能模块时，弱引用被新模块接口覆盖，从而使得程序可以在正常使用的情况下扩展功能。
&lt;strong&gt;attribute&lt;/strong&gt;((week)) week_var = 2;
&lt;strong&gt;attribute&lt;/strong&gt;((weekref)) void func();&lt;/p&gt;

&lt;p&gt;Linux提供了几个工具来帮助我们了解ELF格式内容&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;readelf，可以帮助我们读取ELF文件中Section的内容&lt;/li&gt;
  &lt;li&gt;objdump，可以帮助我们翻译二进制指令和数据&lt;/li&gt;
  &lt;li&gt;c++filt，可以帮助我们解析被修饰过的名称&lt;/li&gt;
  &lt;li&gt;编译时通过加 -g 参数，可以让编译器在产生目标文件时加上调试信息&lt;/li&gt;
  &lt;li&gt;strip，可以通过这个命令把ELF中的调试信息都去除&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;静态链接&quot;&gt;静态链接&lt;/h3&gt;

&lt;p&gt;静态链接的过程其实就是把目标文件中的数据归档到一个文件中，其归档步骤有两步。&lt;/p&gt;

&lt;h3 id=&quot;第一步空间与地址分配&quot;&gt;第一步，空间与地址分配&lt;/h3&gt;

&lt;p&gt;扫描所有输入的目标文件，获取它们的各Section的数据，合并各段数据并建立映射关系。
同时把所有目标文件中的符号和符号定义都收集起来放到全局符号表中。&lt;/p&gt;

&lt;h3 id=&quot;第二步符号解析与重定位&quot;&gt;第二步，符号解析与重定位&lt;/h3&gt;

&lt;p&gt;根据第一步收集到的信息，包括Section和符号表信息，进行符号解析与重定位，调整代码中的地址。&lt;/p&gt;

&lt;h3 id=&quot;在重定位时由于各个符号的在section内的位置是相对固定的所以只要计算出section的偏移量就可以知道合并后的符号实际位置&quot;&gt;在重定位时，由于各个符号的在Section内的位置是相对固定的，所以只要计算出Section的偏移量就可以知道合并后的符号实际位置。&lt;/h3&gt;

&lt;h3 id=&quot;在第一步完成空间分配后就可以确定所有符号的虚拟地址了但这时目标文件内含有其他目标文件函数则需要另外通过符号表来重定位&quot;&gt;在第一步完成空间分配后，就可以确定所有符号的虚拟地址了，但这时目标文件内含有其他目标文件函数，则需要另外通过符号表来重定位。&lt;/h3&gt;

&lt;h3 id=&quot;由于在完成空间分配后全局符号表内的符号都确定了地址因此在重定位时可以使用全局符号表中的地址替换未定位地址&quot;&gt;由于在完成空间分配后，全局符号表内的符号都确定了地址，因此在重定位时可以使用全局符号表中的地址替换未定位地址。&lt;/h3&gt;

&lt;p&gt;每个目标文件都可能定义一些符号，也可能引用到定义在其他目标文件的符号。链接器在重定位的过程中，每个重定位的入口都是一个符号的引用，当需要对某个符号的引用进行重定位时，就要确定这个符号的目标地址。这时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位。&lt;/p&gt;

&lt;h3 id=&quot;注意在未确定外部符号地址时编译器把这部分地址暂时用0x00000000和0xfffffffc来代替在链接时再由链接器将计算好的地址填充进来&quot;&gt;注意：在未确定外部符号地址时，编译器把这部分地址暂时用“0x00000000”和“0xFFFFFFFC”来代替，在链接时再由链接器将计算好的地址填充进来。&lt;/h3&gt;

&lt;h3 id=&quot;重定位表-1&quot;&gt;重定位表&lt;/h3&gt;

&lt;p&gt;我们前面说过每个需要重定位的Section都有一个重定位表，例如“.text”有“.rel.text”，“.data”有“.rel.data”。&lt;/p&gt;

&lt;p&gt;每个重定位表里的数据为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;typedef struct{
  Elf32_Addr r_offset; // 相对于当前Section的相对位置
  Elf32_Word r_info; // 低8位表示重定位入口类型，高24位表示重定位入口符号的索引
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单来说就是，重定位表数据中有一个需要重定位的位置和一个重定位的符号名字符串索引，有了这两个数据，链接器就能在链接时从全局符号表中找到合并后的真实虚拟地址。&lt;/p&gt;

&lt;p&gt;在符号地址修正时，也分绝对寻址修正和相对寻址修正，它们的区别是绝对寻址修正后的地址为该符号的实际虚拟地址，相对寻址修正后的地址为符号距离被修正位置的地址差，因此它们分别服务的是不同类型的指令。&lt;/p&gt;

&lt;h3 id=&quot;全局构造和析构表&quot;&gt;全局构造和析构表&lt;/h3&gt;

&lt;p&gt;.init段中保存的初始化代码。当一个程序开始运行时在main函数调用之前Glibc的初始化程序会执行这个段中的代码。
.fini段中保存的析构代码。当一个进程的main函数正常退出时Glibc会安排执行这个段中的代码。
这两个段有特别的目的，.init在main函数前执行，.fini则在main函数后执行，利用这两个特性C++的全局构造和析构函数就由此实现。&lt;/p&gt;

&lt;h3 id=&quot;将不同编译器的编译结果链接&quot;&gt;将不同编译器的编译结果链接&lt;/h3&gt;

&lt;p&gt;那么有没有可能将不同编译器的编译结果链接成一个可执行文件呢？其实可以的，但非常困难。&lt;/p&gt;

&lt;p&gt;目标文件必须满足以下条件：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;目标文件的数据格式兼容&lt;/li&gt;
  &lt;li&gt;符号签名规则兼容&lt;/li&gt;
  &lt;li&gt;变量的内存分布方式兼容&lt;/li&gt;
  &lt;li&gt;函数调用方式兼容&lt;/li&gt;
  &lt;li&gt;堆栈分布方式兼容&lt;/li&gt;
  &lt;li&gt;寄存器使用阅读兼容&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们把这种链接时的兼容性相关内容称为ABI（Application Binary Interface）。与API不同的是，ABI是指二进制层面的接口兼容性更加严格，而API则只是源代码级别上的的接口。
其实不同编译器链接成可执行文件的最大问题就是，各种硬件平台、编程语言、编译器、链接器和操作系统之间的ABI互不兼容。由于ABI的不兼容，导致各个目标文件之间无法互相链接。&lt;/p&gt;

&lt;h3 id=&quot;静态库与链接&quot;&gt;静态库与链接&lt;/h3&gt;

&lt;p&gt;其实静态库可以简单看成一组目标文件的集合，在制作静态库时只是将所有目标文件打包压缩后归档为一个文件而已。&lt;/p&gt;

&lt;p&gt;Linux下可以使用“ar”这个工具命令来归档目标文件，“ar”压缩程序将所有目标文件压缩到一起并对其进行编号和索引，以便于查找和检索，就形成了xxx.a静态库文件。Visual C++也提供了类似ar的工具，叫lib.exe，这个程序可以用来创建、提取、查看.lib文件中的内容。&lt;/p&gt;

&lt;p&gt;在静态库链接时，Linux下的链接器ld会自动寻找需要的静态库，并从中解压出来目标文件，再最终将这些目标文件链接在一起成为可执行文件。&lt;/p&gt;

&lt;p&gt;从这个规则上看来，我们在编写静态库的时候，最好是每个函数独立存放在一个目标文件中，因此这样可以尽量减少空间浪费，因为没有被用到的目标文件就不会链接到最终的输出文件中。&lt;/p&gt;

&lt;h3 id=&quot;中间件bfd库&quot;&gt;中间件BFD库&lt;/h3&gt;

&lt;p&gt;我们说各种操作系统平台都遵循类似ELF格式的文件格式，虽然是相似的ELF格式但在不同软硬件平台都有着不同的变种。
种种差异导致编译器和链接器很难处理不同平台之间的目标文件，因此最好有一种统一的接口来处理不同格式的文件。
BFD库（Binary File Dexcriptor library）就是为了这个目的存在的，它的目标就是用一种统一接口来处理不同的目标文件格式。&lt;/p&gt;

&lt;p&gt;现在GCC编译器、链接器ld、调试器gdb、binutils等工具都是通过BFD库来处理文件，而不直接操作目标文件。
这样做的好处是将编译器和链接器与具体的目标文件格式隔离开来，一旦我们需要支持一种新的目标文件格式，只需要在BFD库里添加一种格式就可以了，而不需要再去修改编译器和链接器。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484763&amp;amp;idx=1&amp;amp;sn=f1b3d678c1309a66d44b64b7ff22a002&amp;amp;chksm=fc22605ccb55e94a53558e85fdbe196fc58612fe20c88f35f8c0f4098e240ef48bcd2da099b0&amp;amp;token=535520395&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;
</description>
               <pubDate>Sun, 20 Jun 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/06/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B029</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/06/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B029</guid>
            </item>
        
            <item>
               <title>读书笔记(二十八) 《C++ Primer》#3</title>
               <description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484764&amp;amp;idx=1&amp;amp;sn=edc0beab7722d092571c8f88a9a38bd6&amp;amp;chksm=fc22605bcb55e94d95e3445b7449c42f87450a2fcc8dd16d63f44a242b17e63b6f5051e91dcd&amp;amp;token=535520395&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;背景&quot;&gt;背景：&lt;/h3&gt;

&lt;p&gt;我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意。第三是当我们在巩固时创造出了新的知识，那么这些新的知识和旧的知识将同时变成智慧融合到身体中。&lt;/p&gt;

&lt;p&gt;本系列基于《C++ Primer》学习，由于重点放在“重学”，我略过了滚瓜烂熟的部分，挑出以前常忽略的部分，以及记忆没有那么深刻的部分，特别是那些重要的但没有上心的部分。&lt;/p&gt;

&lt;h3 id=&quot;开始&quot;&gt;开始&lt;/h3&gt;

&lt;h3 id=&quot;左值和右值&quot;&gt;左值和右值&lt;/h3&gt;

&lt;p&gt;这两个名词是从C语言继承过来的，原本是为了帮助记忆即：左值可以位于赋值语句的左侧，右值则不能。
在C++语言中则没那么简单了，可以简单归纳为：
当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。&lt;/p&gt;

&lt;p&gt;不同运算符对运算对象的要求不同，有的需要左值运算对象、有的则需要右值运算对象。
因此有个重要原则：在需要右值的地方可以用左值来代替，但不能把右值当左值（也就是位置）使用。当一个左值被当成右值使用时，实际使用的是它的内容（就是值）。&lt;/p&gt;

&lt;p&gt;举几个例子：
	赋值运算符，是左值运算，因为结果是值（内容）
	取地址符，是右值运算，因为结果的是指针或地址
	解引用运算符、下标运算符，是左值运算，因为运算结果是值（内容）
	递增运算，是左值运算，因为运算结果是值（内容）&lt;/p&gt;

&lt;h3 id=&quot;关于后置&quot;&gt;关于后置++&lt;/h3&gt;

&lt;p&gt;这里有个小提示，后置++版本会多浪费一个寄存器，但是编译器会帮我们优化掉，不过对于迭代器来说则不同，编译器通常不会优化迭代器的后置++，因此我们在使用迭代器后置++时要注意一下代码的优化。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;cout&amp;lt;&amp;lt; *iter++ &amp;lt;&amp;lt; endl;
==&amp;gt; 优化
count&amp;lt;&amp;lt; *iter &amp;lt;&amp;lt; endl;
++iter;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;sizeof运算符&quot;&gt;sizeof运算符&lt;/h3&gt;

&lt;p&gt;sizeof有离线计算和实时运算之分，通常情况下有些值在离线时就能知道的类型的大小，这时编译器都会在编译时就将其替换成固定值。&lt;/p&gt;

&lt;p&gt;举例说明sizeof运算符的结果取决于其作用类型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对char类型表达式执行sizeof运算，结果为1。编译器离线计算&lt;/li&gt;
  &lt;li&gt;对引用类型执行sizeof，结果为被引用对象所占空间大小。编译器离线计算&lt;/li&gt;
  &lt;li&gt;对指针执行sizeof运算，结果为指针本身空间大小。编译器离线计算&lt;/li&gt;
  &lt;li&gt;对解引用指针执行sizeof，结果为指针指向的对象的空间大小。编译器离线计算&lt;/li&gt;
  &lt;li&gt;对数组执行sizeof运算，结果是整个数组所占空间大小。编译器离线计算&lt;/li&gt;
  &lt;li&gt;对string对象或vector对象执行sizeof运算，结果为该类型固定部分的大小。实时计算空间大小&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;强制类型转换&quot;&gt;强制类型转换&lt;/h3&gt;

&lt;p&gt;强制类型转换的根本目的就是告诉编译器，该变量的类型改变了，符合后面的逻辑运算，好让在编译器在编译时能够不误解逻辑运算，所以编译器并没有对内存内容做任何的改变，它只是为了迎合编译器。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;//旧式的强制类型转换
type (expr); // 函数形式的强制类型转换
(type) expr; // c语言风格的强制类型转换

//新式的强制类型转换
static_cast&amp;lt;type&amp;gt;(expression); // 静态转换
dynamic_cast&amp;lt;type&amp;gt;(expression); // 运行时转换
const_cast&amp;lt;type&amp;gt;(expression); // 常量转换
reinterpret_cast&amp;lt;type&amp;gt;(expression); // 低阶类型转换
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;强制转换分为static_cast静态转换dynamic_cast运行时转换const_cast常量转换reinterpret_cast低阶类型转换4种&quot;&gt;强制转换分为，static_cast（静态转换），dynamic_cast（运行时转换），const_cast（常量转换），reinterpret_cast（低阶类型转换）4种&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;static_cast静态转换，直接将对象转换成指定类型对象。&lt;/li&gt;
  &lt;li&gt;dynamic_cast运行时转换，通常用于继承对象，运行时转换会先通过RTTI的方式判断是否能进行父子转换，如果可以再进行执行转换。&lt;/li&gt;
  &lt;li&gt;const_cast常量转换，只能改变运算对象的底层const无法改变具体类型，可以将const变量转换为非const变量，这样编译器就不再阻止我们对该对象进行写操作了。&lt;/li&gt;
  &lt;li&gt;reinterpret_cast低阶类型转换，通常为运算对象的位模式提供低层次上的解释。例如将int转换为char*等低阶模式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;注意使用reinterpret_cast比较危险的是使用reinterpret_cast强制转换后编译器不会怀疑所转换的类型如果类型错误则会因调用混乱而崩溃而编译器在编译时不会发出任何警告或错误因此reinterpret_cast通常适合比较底层转换工作&quot;&gt;注意：使用reinterpret_cast比较危险的是，使用reinterpret_cast强制转换后编译器不会怀疑所转换的类型，如果类型错误则会因调用混乱而崩溃，而编译器在编译时不会发出任何警告或错误，因此reinterpret_cast通常适合比较底层转换工作。&lt;/h3&gt;

&lt;h3 id=&quot;异常处理&quot;&gt;异常处理&lt;/h3&gt;

&lt;p&gt;当异常被抛出时，首先在该函数中寻找匹配的catch子句，如果没有找到则终止该函数并在调用该函数的函数中继续寻找，以此类推沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。
如果最终还是没能找到任何匹配的catch子句，程序会转到名为terminate的标准库函数中。该函数的行为与系统有关，一般情况下，执行该函数会导致程序非正常退出。
如果当程序没有使用try catch语句且发生了异常，系统会直接调用terminate函数并终止当前程序的执行。&lt;/p&gt;

&lt;h3 id=&quot;分离式编译&quot;&gt;分离式编译&lt;/h3&gt;

&lt;p&gt;分离式编译的意思就是，多个源文件在编译中可以只顾自己编译，最后再统一链接到执行文件或库文件中。&lt;/p&gt;

&lt;p&gt;在分离式编译中，如果我们修改了其中一个源文件，那么只需要重新编译那个改动了的文件，再重新链接就可以。
现代大多数编译器提供了分离式编译每个文件的机制，这一过程通常会产生一个后缀名是.obj（windows）或.o(UNIX)的目标文件，再用链接器将所有目标文件链接成可执行文件或库文件。&lt;/p&gt;

&lt;h3 id=&quot;参数传递&quot;&gt;参数传递&lt;/h3&gt;

&lt;p&gt;解释下，实参就是要传递的数据变量，形参就是传递后函数中的参数变量。&lt;/p&gt;

&lt;p&gt;参数传递分引用传递和值传递&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;引用传递，通过传递引用的方式避免了对象拷贝。&lt;/li&gt;
  &lt;li&gt;值传递，则都是通过拷贝对象传递数据的。其中指针形参也是值传递，只不过传递时拷贝的是指针数据而非具体对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;函数设置参数时，我们要注意尽量使用const常量引用或指针作为形参，因为这样既避免了对象拷贝，又可以限制对象的修改。&lt;/p&gt;

&lt;h3 id=&quot;可变形参&quot;&gt;可变形参&lt;/h3&gt;

&lt;p&gt;使用initializer_list类型的形参可以做到传递可变数量的实参。和Vector不一样的是，initializer_list中的元素永远都是常量值。&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;void test_func(initializer_list&amp;lt;string&amp;gt; li)
{
  for(auto beg = li.begin(); beg != li.end() ; ++beg)
      cout&amp;lt;&amp;lt; *beg &amp;lt;&amp;lt; &quot; &quot;;
}

test_func(&quot;1&quot;,&quot;3&quot;,&quot;4&quot;);
test_func(&quot;2&quot;,&quot;3&quot;);
test_func(&quot;2&quot;,&quot;4&quot;,&quot;6&quot;,&quot;8&quot;,&quot;10&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;值返回和引用返回&quot;&gt;值返回和引用返回&lt;/h3&gt;

&lt;p&gt;与值传递和引用传一样，在函数返回时，我们也需要注意拷贝操作。&lt;/p&gt;

&lt;p&gt;例如字符串拼接后的返回值就会造成对象拷贝的消耗：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;string test_func(string &amp;amp;a, string &amp;amp;b)
{
   return a + b;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了避免拷贝我们会使用引用返回或指针，但要注意，使用引用返回或指针时如果返回的是局部对象则会引起内存使用错误。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;string &amp;amp;test_func()
{
   string test = &quot;test&quot;;
   return test; // 错误的返回了局部变量，导致内存使用错误
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;函数重载&quot;&gt;函数重载&lt;/h3&gt;

&lt;p&gt;函数重载的特点是函数名字相同参数列表不同且在同一个作用域。&lt;/p&gt;

&lt;p&gt;在重载函数调用时，可能与我们想象的不同，其实编译器在离线时就区分了不同重载函数的调用地址。
当调用重载函数时，编译器会根据传递的实参类型去比较每个重载函数的参数直到匹配成功或失败。
我们知道虽然重载函数名字相同，但参数列表不同，这导致函数签名时的实际名字是不同，也就相当于调用的是不同名字的函数。&lt;/p&gt;

&lt;p&gt;举例说明重载函数的函数签名后命名不同：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;int func(int); //  函数签名后--&amp;gt; _Z4funci 
int func(float); // 函数签名后--&amp;gt; _Z4funcf

func(3); // -&amp;gt; 匹配 _Z4funci
func(3.5F); // -&amp;gt; 匹配 _Z4funcf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重载函数的匹配过程为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;收集所有重载函数&lt;/li&gt;
  &lt;li&gt;比较实参与所有重载函数的形参，寻找最佳匹配函数&lt;/li&gt;
  &lt;li&gt;匹配规则为精准匹配和转换匹配两种，精准匹配要求实参与形参高度一致，转换则可以通过const转换、类型提升、算术类型转换来实现匹配。&lt;/li&gt;
  &lt;li&gt;匹配成功后替换为匹配函数的函数签名&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;至于函数签名的规则，其实每种编译器都不同，不过也是大同小异的。例如上述我们举例代码中的GCC编译器的规则为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所有符号以“_Z”开头，&lt;/li&gt;
  &lt;li&gt;对于嵌套的名字后面紧跟“N”，&lt;/li&gt;
  &lt;li&gt;然后紧跟各个名称空间和类的名字，每个名字前是名字字符串长度，&lt;/li&gt;
  &lt;li&gt;再以“E”结尾，“E”后面是所有参数，&lt;/li&gt;
  &lt;li&gt;参数以简写代替，例如对于int类型来说就是字母“i”，float类型来说就是字母“f”，以此类推。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;内联函数&quot;&gt;内联函数&lt;/h3&gt;

&lt;p&gt;我们知道函数在调用时会先保存当前寄存器、拷贝实参值、并在返回时拷贝恢复，这些都是函数调用的消耗。&lt;/p&gt;

&lt;p&gt;内联函数则可以避免函数调用的消耗，其原理是就地展开函数，这样能省去了函数调用前和后的一系列操作。
我们可以通过内联关键字inline告诉编译器该函数需要在编译器时展开，但这也只是向编译器发出请求而已，如果编译器认为该内敛展开后性价比不高可以选择忽略这个请求。&lt;/p&gt;

&lt;p&gt;常量表达函数constexpr，我们可以通过constrexpr定义常量表达式的函数，与普通内联函数不同的是，编译器会把constexpr函数的调用替换成实际结果，简单来说就是离线计算好结果并替换调用函数。&lt;/p&gt;

&lt;p&gt;对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致，基于这个原因，内联函数和constexpr函数通常定义在头文件中。&lt;/p&gt;

&lt;h3 id=&quot;调试辅助指令&quot;&gt;调试辅助指令&lt;/h3&gt;

&lt;p&gt;assert是常见的调试工具，它其实是一个预处理宏，通过判断表达式来终止程序执行。&lt;/p&gt;

&lt;p&gt;assert的行为依赖于一个名为NDEBUG的预处理变量。如果定义了NDEBUG，则assert什么也不做。
默认状态下没有定义NDEBUG，我们可以使用#define来定义NDEBUG从而关闭调试状态，或者使用编译器的预处理指令
cc -D NDEBUG main.c&lt;/p&gt;

&lt;p&gt;除了assert，C++编译器还定义了多个帮助我们调试的变量，例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;func&lt;/strong&gt;，存放的是当前函数名字&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;FILE&lt;/strong&gt;，存放的是当前文件名&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;LINE&lt;/strong&gt;，存放的是当前代码行号&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;TIME&lt;/strong&gt;，存放的是当前文件编译时间&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;DATA&lt;/strong&gt;，存放的是当前文件编译日期&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;函数指针&quot;&gt;函数指针&lt;/h3&gt;

&lt;p&gt;函数指针指向的是函数地址，它的类型由它的返回值类型、形参类型共同决定，编译器会检查函数类型与函数指针类型之间的一致性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;bool (*point_func)(const string &amp;amp;, const string &amp;amp;);
// point_func前面有个*，因此point_func是指针，这里括号不能少。
// point_func右侧是形参列表，表示point_func指向的是，两个const string引用为参数、并且返回值是bool的函数类型。

bool lenCompare(const string &amp;amp;, const string &amp;amp;);

point_func = lenCompare; //指向lenCompare
point_func = &amp;amp;lenCompare; //等价于赋值
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在指向不同函数类型的指针间不存在转换规则，也就是说，不同类型函数之间无法转换，即我们无法将一个类型函数转换到另一个类型函数指针。&lt;/p&gt;

&lt;p&gt;在将函数指针用于形参、返回值、重载函数时，都必须遵循函数类型与函数指针一致性的原则，编译器不会自动将函数类型转换成我们想要的类型，因为转换是不允许的。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;amp;mid=2247484764&amp;amp;idx=1&amp;amp;sn=edc0beab7722d092571c8f88a9a38bd6&amp;amp;chksm=fc22605bcb55e94d95e3445b7449c42f87450a2fcc8dd16d63f44a242b17e63b6f5051e91dcd&amp;amp;token=535520395&amp;amp;lang=zh_CN#rd&quot;&gt;已发布在微信公众号上，点击跳转&lt;/a&gt;&lt;/p&gt;

</description>
               <pubDate>Sat, 19 Jun 2021 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com/2021/06/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B028</link>
               <guid isPermaLink="true">http://www.luzexi.com/2021/06/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B028</guid>
            </item>
        
    </channel>
</rss>