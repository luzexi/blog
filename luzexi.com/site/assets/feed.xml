<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title></title>
        <description>漫漫人生,记录点滴技术,始于2013</description>
        <link>http://www.luzexi.com</link>
        <atom:link href="http://www.luzexi.com/assets/feed.xml" rel="self" type="application/rss+xml" />
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第六章，网络层(六) - 网络同步解决方案</title>
               <description>&lt;p&gt;当前网络游戏中网络同步方案有三种，即状态同步，预测信息同步，帧同步。三种方式并不是完全互相排斥的，很多时候我们在开发的时候，为了能都让游戏显得更加逼真，会让多种的同步方案一起使用。例如魔兽世界这种开放世界的多人在线RPG游戏，就使用了状态同步和预测信息同步两种方案，绝地求生、和平精英等战地竞技类游戏，也同时使用了状态同步与预测信息同步方案，而传奇世界、热血传奇等传奇类游戏因为不需要预测信息就只使用状态同步，王者荣耀等一批5v5地图类竞技游戏则使用了帧同步方案。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;同步方案的目标是在针对多人游戏中如何用更少的信息同步量来逼真的’模拟‘其他玩家的一举一动，让我们在玩游戏的时候能知道其他人的位置、动作、以及状态。这里有个关键词’模拟‘，我们获取的信息由于网络因素的关系通常都是延后的，如何通过这些延迟的信息来模拟是关键的关键。&lt;/p&gt;

&lt;p&gt;在同步的解决方案中不仅涉及到信息同步还涉及到同步的范围，比如魔兽世界、绝地求生、和平精英、传奇世界、热血传奇，如果他们每次都同步地图上所有玩家的信息，那么同步的数据量太大，不仅客户端承载不了渲染压力和信息通信压力，服务器也同样承受巨大的数据传输压力。因此同步方案对游戏来说只是一个方面的解决方案，除了有同步方案，还需要其他解决方案来支撑和优化同步数据压力才得以实现良好的游戏体验。&lt;/p&gt;

&lt;h3&gt;状态同步&lt;/h3&gt;

&lt;p&gt;为什么要状态同步？如果每帧(每秒30帧)都同步信息，传输的信息量就太大了，而且信息到位也不及时，为了能更逼真的模拟其他玩家的行为，我们把每个人的行为动作都切分成若干个状态。比如站立状态，所有人都一样，站在某个位置不断循环播放某个动画，只要告诉玩家说我在某个位置进入了站立状态，只要状态不变，我们就知道这个玩家就是一直在原地播放站立动画。&lt;/p&gt;

&lt;p&gt;在状态同步里，人身上每个状态就相当于一个固定的行为模式，这个固定行为模式就像个黑盒，只要给到需要的数据，就能表现出固定的行为，比如攻击，就是播放一个攻击动画，并在某个时间点判定攻击效果，攻击完毕后就进入站立状态，比如打坐休息，就是循环播放一个动画，并每隔一个是时间段加一次血量，又比如行走，就是从某点到某点做A星的寻路操作，并边播放行走动画边跟随路线移动到各个路线节点，最终移动到目的地。&lt;/p&gt;

&lt;p&gt;这些状态只要给予需要的固定数据就能展现出相同画面的个体效果。如果我们要让这些状态连贯起来拼凑成一个可操控的人，我们可以向这个人发送各种各样的指令，告诉它你应该触发这状态，应该触发那状态，指令中包含了状态需要的数据。&lt;/p&gt;

&lt;p&gt;在状态同步中，服务器端扮演了幕后操纵木偶人的那个大老板，而客户端里渲染的对象就是那个木偶人，服务器端发出指令说ID为5的木偶人开始攻击，客户端里那个ID为5的木偶人就开始进入攻击状态并且播放攻击动画。&lt;/p&gt;

&lt;p&gt;当动画播放到一半服务器端又发来指令说，被攻击的那个ID的怪兽受伤了并受到500点伤害，这时客户端就会在指定的怪物头上冒出500点的伤害值并且让怪物进入受伤状态播放受伤动画。&lt;/p&gt;

&lt;p&gt;当攻击动画播放完毕时，服务器又发来指令说继续攻击，ID为5的木偶人就又从站立状态切换到了攻击状态，这次攻击到一半服务器发来指令说，这个怪物受到600点伤害并且死了，于是客户端在怪物头上冒出600点伤害的数字并且让怪物进入死亡状态播放死亡动画。木偶人也在播放完攻击动画后，进入了空闲状态播放站立动画。&lt;/p&gt;

&lt;p&gt;服务器扮演着发送指令操控木偶人的角色，这个木偶人也包括玩家自己的角色，即玩家操控着’我‘自己的在游戏中的人物，也同样需要经过服务器的同意，并发送指令给玩家当前的角色进行状态的切换和模拟。&lt;/p&gt;

&lt;p&gt;有时候也未必要一定要经过服务器同意，为了让玩家能够在网络环境糟糕的时候也能够看起来比较顺畅，玩家可以随意操控自己的角色，并不受限于服务器的延迟指令，但是在稍后的服务器校验时再对玩家进行矫正，比如我们玩传奇世界是状态同步，在网络很卡时我们任然能不停的移动，但是过一段时间，服务器把正确的数据发送到客户端后，客户端进行了位置和状态的矫正。&lt;/p&gt;

&lt;p&gt;状态同步的特点是状态是固定的，除非状态改变，否则相同的状态数据得到的是相同的个体状态结果，人物角色实体的行为都是通过状态切换来表现画面。&lt;/p&gt;

&lt;h3&gt;预测信息同步&lt;/h3&gt;

&lt;p&gt;在一些竞技游戏中，人物的行动速度和旋转速度需要不断的变化，要实时更新这些信息，状态同步不能满足这样需求，因为我们速度和旋转的变化太快，我们无法每帧都同步状态信息来模拟。&lt;/p&gt;

&lt;p&gt;但是状态同步依然可以用于除了移动和旋转意外的同步，因为除了移动和旋转，其他信息都没有这样快速、多样的变化，并且它们仍旧遵守原有的规则，完全可以继续用状态来划分，所以状态同步常常与预测信息同步同时存在。&lt;/p&gt;

&lt;p&gt;预测信息同步方案的主要特点是，位置、旋转信息都是由客户端决定的，客户端将自身的位置、旋转信息发给服务器端，再由服务器端分发给其他玩家，当其他玩家收到位置、旋转信息后根据收到的位置和旋转信息预测其当前的位置，速度，加速度，以及旋转角度，旋转速度，旋转加速度并进行模拟和展示。&lt;/p&gt;

&lt;p&gt;在这种竞技性比较强，移动速度比较快的游戏中，通常都需要玩家不停的改变移动速度和旋转角度来体现其控制角色的灵活性。比较常见为枪战类游戏CS，玩家不停在变化自己的移动和旋转的速度以适应战术的需要。或者跑跑卡丁车中，玩家要在高速移动下，不停的调整自己的方向和速度，让自己能够躲过众多障碍，同时在急弯处要旋转自己的车进行漂移等。还有在类似魔兽世界这种开放世界下的RPG游戏，需要不停的改变自己的速度与旋转角度来让战斗显得更加丰富和灵活。&lt;/p&gt;

&lt;p&gt;为了能更加逼真的同步模拟这种变化频率很高的人物移动和旋转，我们不得不让客户端来决定其位置和旋转角度，牺牲一些数据的安全性来让画面模拟的更加流畅。&lt;/p&gt;

&lt;p&gt;每个玩家的客户端会在1秒内发送15-30次左右自身的移动和旋转数据给服务器端，为的就是能更加顺畅的模拟玩家在游戏中的移动旋转的表现，也只有这样，才能让其他客户端不停的更新玩家的位置和旋转信息。&lt;/p&gt;

&lt;p&gt;不过只是单纯的更新位置和旋转数据，会导致玩家在屏幕中不停的闪跳，而用速度的方式表示则更加流畅，所以计算速度和预测速度，以及加速度，让模拟的对象按速度和加速度的形式在屏幕中运动，而不是只更新位置信息，会让角色在画面中模拟行走的位置和方向会更加流畅。&lt;/p&gt;

&lt;p&gt;预测信息同步的算法和公式并不复杂，首先要取已经收到的该玩家的位置信息前5个除以间隔时间，就能得到一个平均的速度，再取这样5个一组的3-5组，就能得到一个平均的加速度，根据这个速度和加速，就能让角色在屏幕中模拟跑动了。&lt;/p&gt;

&lt;p&gt;但方向还不对，没有方向怎么跑都是错的，在角度的同步上也依然可以按照这种速度和加速度的方式去预测，取最近5个角度的值得到平均旋转速度，再取5个一组的3-5组这样的数据计算得到旋转加速度。&lt;/p&gt;

&lt;p&gt;但是还是有偏差，即使预测和模拟了速度和方向，由于数据的量不够多，网络延迟大且不稳定，所以很容易造成位移的偏差，所以定时的矫正比较是必须的。&lt;/p&gt;

&lt;p&gt;矫正可以在生硬的基础上加入一些当前数据的预测，比如每秒矫正一次，每隔1秒重新计算一次从最近收到一个位置上到现在这个时间点的预测位置，如果网络延迟比较小的时候，由于原本预测的位置和矫正的位置是差不多的，所以角色矫正时的抖动现象完全无法用肉眼看出来，但如果网络延迟比较大的时候，矫正的位置和预测的位置就会偏离的比较远，角色看起来总是一闪一闪的不停抖动甚至飞来飞去。&lt;/p&gt;

&lt;p&gt;这也正是为什么我们在玩CF穿越火线，跑跑卡丁车这类游戏时，假如对方的网络比较卡，就会看到对方角色不停的一闪而过，因为预测数据和矫正数据偏离的太多了，客户端在不断的矫正角色的位置和速度。&lt;/p&gt;

&lt;h3&gt;帧同步&lt;/h3&gt;

&lt;p&gt;状态同步既能控制数据计算的安全性，也能保证所有客户端的同步性，不过在位置和角度变化很快的竞技游戏中，状态同步无法承受这样又多又快的位置和旋转变化，所以就加入了预测信息同步的解决方案，这种解决方案放弃了玩家的位置和旋转角度的强校验，使得各个客户端能更加顺利和准确的模拟其他玩家的位置和旋转角度。&lt;/p&gt;

&lt;p&gt;但是更加严格的同步要求下预测信息同步也无能为力，因为每个玩家的手机和电脑端的设备好坏不一样，网络环境也不同，一台好的机子和手机，同一时间段能位移的距离可能也不一样，预测信息同步解决方案无法在差异性巨大的设备和网络通信之间做到精准的同步，也无法保证数据校验的安全性，帧同步解决方案就很好的解决了预测信息同步解决不了的问题。&lt;/p&gt;

&lt;p&gt;在同步性和安全性要求很高的游戏中，例如王者荣耀，拳皇类格斗游戏，游戏中的每一帧都是非常关键的，一两帧都有可能决定胜负，对于这种类型的游戏，同步的要求性高，安全性也有很高的要求，所以帧同步的解决方案正好契合这种类型游戏。&lt;/p&gt;

&lt;p&gt;与状态同步和预测信息同步不同的是，帧同步的逻辑不再由客户端本身的逻辑帧Update来决定，而是转由从网络收到帧数据包来驱动执行逻辑更新，所有逻辑更新都放在了收到帧数据包时的操作中，包括人物角色的移动，攻击，释放技能等，每收到一个服务器发过来的帧数据包，就更新一帧，如果服务器端发过来的帧数据到达的比较慢，就有可能像放慢动作一样，一帧一帧的播放走路，攻击的慢动作动画。&lt;/p&gt;

&lt;p&gt;帧同步的服务器需要向每个客户端每秒发送20-30个帧数据包，每隔0.033-0.05秒发送一个，即使没有任何信息也会发送空的帧数据，因为客户端要根据这些帧数据包来‘演算’游戏逻辑。&lt;/p&gt;

&lt;p&gt;为什么要说‘演算’呢，一个比较容易理解的比喻是原来在客户端的Update里角色每帧移动xx米的逻辑，转移到放在了从网络收到的帧数据包里，每收到一个帧数据包，角色就移动一步，这样使得每台游戏设备在拥有不同的帧率的情况下，执行了相同数量的逻辑帧，也执行了相同时间点的逻辑指令，因为指令时存在帧数据里的，帧数据的执行顺序一致，则指令执行的时间点也是一致的。&lt;/p&gt;

&lt;p&gt;当玩家有操作指令时，把指令发给服务器，服务器在随后下发的帧数据中，某一帧中带有我们上传的指令数据。因此在帧数据里除了有指令数据外，其他时候都是空的。&lt;/p&gt;

&lt;p&gt;随着客户端不断收到网络数据帧，执行到某一帧带有指令数据时，就执行该指令，比如指令数据表示某角色以每帧1米速度向前移动，那么客户端就开始启动移动状态执行该指令，不过不是在客户端自己的Update中执行，而是从网络中每收到一个帧数据就执行一次，比如后面总共收到20帧的网络空数据帧，那么就执行了20次每帧1米的行走状态，直到玩家再次操作，停止移动指令，并把该停止指令发送给服务器，服务器在再以帧数据的形式发送给所有玩家，当玩家收到这个带有停止指令的帧数据时，才停止移动。&lt;/p&gt;

&lt;p&gt;逻辑在网络数据帧中执行，就相当于服务器控制了所有玩家的播放的帧数，让所有玩家收到的帧数据的数量是相同的，那些需要执行的指令在第几个逻辑帧的位置也是相同的，由于执行帧的时间点，和执行的逻辑的次数是相同的，从而使得所有收到帧数据的客户端做出的表现也是相同的，这就是帧同步的基本原理，由服务器发送的帧数据来完成所有客户端的同步执行操作，在每个客户端设备中所使用来‘演算’的算法是一致的，执行的次数一致，执行的指令数据和时间点一致，执行的算法一致，使得执行的结果一致，那么在画面上所表现的出来的也就是一致的。&lt;/p&gt;

&lt;h3&gt;同步快进&lt;/h3&gt;

&lt;p&gt;不过现实是并不是所有客户端的网络都是流畅的，通常的网络环境都是时好时坏的，客户端在收帧数据时，经常都是不平稳的，偶尔一堆帧数据涌过来，或者又忽然完全没有了帧数据。&lt;/p&gt;

&lt;p&gt;所以如何及时同步落后的客户端画面成了客户端解决同步问题的一个关键。&lt;/p&gt;

&lt;p&gt;最简单的方式是我们可以一下子执行全部堆积在队列里的网络帧，这样我们一下子就能到达画面的最后一帧，然后继续等待网路发送过来的数据帧。&lt;/p&gt;

&lt;p&gt;但是这样一次性执行所有的帧的方式，如果堆积的数据帧太多，会导致游戏卡住很久，画面会停止不动而很久，游戏体验比较差。所以我们可以在渲染帧中每次执行N帧(N大于10)来让画面快速推进，这样一来玩家又能看到动态的画面，又能快速的跟上最后的同步帧数据，同步完所有的帧数据后，再把执行速度降下来，继续按每收到一个网络帧来同步画面。&lt;/p&gt;

&lt;p&gt;不过如果落后太多太多，比如落后了几千几万帧的时候，快进的方法也不管用了，因为执行的帧数落后太多，按普通快进的节奏得要快进很久，如果快进得太快则画面卡住的时间太久，体验太差用户无法接受。&lt;/p&gt;

&lt;p&gt;这时就只能用快照方式做同步操作，快照的意思是把某一帧下面的所有数据，包括玩家，怪物，可破坏的障碍等动态物体的数据像照片一样记录下来存储在服务器，当客户端需要时，打包发给客户端，客户端直接使用该快照数据来渲染画面，因为这一帧的快照离最后需要同步的帧数最近，中间可能跨越了几千几万的帧数，所以如果从快照那一帧数据出发，从该帧数据开始快进到最近的数据帧，相对于从头开始快进来说要快的多，也节省了许多网络流量。&lt;/p&gt;

&lt;p&gt;在同步数据帧时会用以上的快进处理方式，但是如果发送的指令过于频繁也会造成网络数据的灾难，比如玩家控制角色不断释放技能或者不停的旋转奔跑，就会导致客户端以渲染帧的速度每帧大量的向服务器发送指令数据像机关枪一样扫射式的发射，这种数据发送量无法承受。&lt;/p&gt;

&lt;p&gt;在不与帧同步冲突的规则下，我们可以选择把需要发送的指令存起来，等到收到一个网络帧时再发送，如果有很多指令则不断替换未发送的指令直到收到网络帧并发送。这也符合多端帧同步的规则，其实是我们限制了每帧只能有一个操作，就像定制了一个两个规则为‘不能在同一帧有多个操作’的规则。这个规则使得，不能在同一帧中既前进又后退，也不能在同一帧中既释放技能又取消技能。这样的话操作指令的数据包也跟随着同步的数据帧规则一起发送。&lt;/p&gt;

&lt;p&gt;但这里又出现问题了，如果等到有网路数据帧时再发送，那么位移类和旋转的指令就不那么灵活了，因为在实际操作中，旋转和位移的变化是非常快的。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，我们可以加大每秒发送网络数据帧的数量，比如每秒到30帧甚至50帧，但这样网络宽带的消耗量又变的很大了，有时候会得不偿失，因此我们需要优化和权衡一下。由于需要向所有客户端每秒广播数据30-50次的数据，所以发送数据的频率非常高，如果每次广播的数据要足够的小，能在一个MTU以下，这样就能有效的降低底层网络的延迟，既加大了逻辑帧的数量，提高了画面渲染的流畅度，增加了操作的灵活性，网络宽带的占用率也没有这么高。&lt;/p&gt;

&lt;h3&gt;精度问题&lt;/h3&gt;

&lt;p&gt;帧同步的核心战斗的演算算法都是在各自设备的客户端中进行的，前面说了所有设备执行的帧数一致，执行的指令和时间点一致，执行的算法一致，就能得出相同的结果。但是这里又出现一个由于不同设备之间的采用不同的算法来计算浮点数的问题，‘精度’。&lt;/p&gt;

&lt;p&gt;浮点数在各不同设备上的计算结果有细微的差异，导致随着计算的增多，差异变得越来越大，虽然执行次数、时间、算法都一致，最终计算出来的结果还是会由于浮点数计算结果不同而导致不同步的问题。&lt;/p&gt;

&lt;p&gt;所以浮点数的精确计算也是帧同步在同步问题上的一大困难，归根结底，是因为把帧同步方案把计算结果交给不同设备而导致的问题。&lt;/p&gt;

&lt;p&gt;其实也并不是什么难题，市面上有很多用浮点数精度问题的解决方案，比如定点数就是其中之一，所谓定点数，就是把小数部分当整数来计算，这样计算起来就不会有误差了。&lt;/p&gt;

&lt;p&gt;通常的浮点数(即有整数部分和小数部分)在计算机中的表示法是 V = (-1)^s x (1.x) x 2^(E-f) 也就是说浮点数的表达其实是模糊的，它用了另一个数的指数来表示当前的数。而定点数则不同，它把整数部分和小数部分拆分开来，都用整数的形式表示，这样计算和表达都使用整数的方式，整数的计算是确定的，这样就不会存在误差，缺点是占用的字节数多了，计算的范围也缩小了。&lt;/p&gt;

&lt;p&gt;用定点数来替换浮点数计算就能保证在各设备上的计算结果一致性，不过直接使用c#自带的decimal定点数在使用时也存在很多问题，比如无法和浮点数随意的互相转换，所以在计算上也会需要进行一定的封装，又比如无法控制末尾小数点，使得精度还是无法根据项目需求来控制，无法控制内存大小，大量使用使得堆栈内存增加。&lt;/p&gt;

&lt;p&gt;因此大部分项目都是自己实现定点数的，把整数和小数拆开来都用整数表示封装在某个类中，再写一些额外的数学库的编写。其实也没那么恐怖的，就是把定点数与其他类型数字的加减乘除重写一下，如果涉及到更多的数学运算，则再建立一个定点数的数学库，存放一些数学运算的函数。&lt;/p&gt;

&lt;p&gt;最最最快速简单，性价比最高的的方式，其实是将所有数字乘以1000，或者10000，再以整数的方式来计算结果，所有需要计算的数字都以这种方式存储，只有显示的时候才除回来回到浮点数，这样即控制了精度的一致性，也不用这么麻烦去实现定点数的封装，而且浮点数还能继续用，因为在大部分帧同步游戏中，200万的数字，甚至20万都已经是足够大了，所以他们无需劳心费神的去封装一个定点数以及定点数数学库，而且这个定点数还无法与表现层有很好的连接。直接乘一下就能达到一样的效果，大大降低了研发成本。&lt;/p&gt;

&lt;p&gt;这里也了解下同步锁的机制。在更加严格的同步类游戏中，比如星际争霸1中，如果有玩家网络环境不好，希望能够等待该玩家的进度，就会使用同步锁的机制。&lt;/p&gt;

&lt;p&gt;同步锁的机制，要求每个客户端每隔一段时间都发送一个锁帧数据，类似‘心跳’数据包，服务器端在帧数据中嵌入心跳包，告诉其他玩家该玩家仍然在线并正常游戏中，如果客户端在接受帧数据时超过50帧没有收到某个玩家的锁帧数据的话则停止播放网络帧数据，等待该玩家跟上大部队后，再所有客户端同时从最近的一次锁帧数据点开始，以该点为最后一数据帧，一起继续各自演算。&lt;/p&gt;

&lt;!-- 

网络流量大小，状态同步大，帧同步小。

回放文件大小，状态同步大，帧同步小。

安全性，状态同步好，帧同步弱。

服务器压力大小，状态同步大，帧同步小。

战斗校验，状态同步校验容易，帧同步校验难

网络卡顿表现，瞬移掉血，回撤。

实现，状态验证与插值预测，所有碰撞位移都要程序自己控制；还要写状态的回撤。

六．  长连接和短连接的优缺点
（https://www.zhihu.com/question/39849641/answer/83774680）
tcp:
tcp的好处就是“可靠”，会将体积大的数据包进行分片，保证不会让ip协议进行分片。
会检测数据包是否丢包，丢包重传，有序地发送数据包等等，
坏处就是数据包头比较臃肿，至少有20+的字节（不要小看这20+字节),
在丢包重传时，会阻塞后面的数据包，而且tcp需要保持连接状态才能进行通讯，
在连接数较多时，服务器光在handle这些连接状态上就要消耗不少的性能。
题主所说的“长连接”应该指的是tcp socket，tcp socket是操作系统为tcp协议的实现（说白了就是操作系统为tcp提供的api) 

http: http处于应用层，是基于tcp的实现。它继承了tcp的所有优点。
跟tcp有些不同,http不会一直的保持连接状态，
在早期的http 1.0时期，http请求在得到响应后会立即断开连接，
这样就导致了每次的http请求都必须去进行tcp握手（在数据报文很小时，握手时间甚至会超过数据传送时间），
在1.1版本后使用同一个连接进行多次的http请求，在一段时间内没有再次进行http请求时，会自动断开，
这样就减轻了服务器维护大量链接所产生的开销问题，但是http是应用层，它会产生新的数据报头，在数据包的容量上会更大。

udp: udp 是“不可靠”的：不会丢包重传，会导致ip分片从而丢包，数据包不会按序送达，
只保证到达的包数据是完整的，它的好处就是,不会产生tcp丢包时的队列阻塞，
数据报头较小，只有8个字节，是一个无连接协议。

手游用什么协议？有啥优缺点
tcp：
优点就是tcp的功能太强大了，基本上没有tcp做不了的事，而且基于tcp的第三方库也非常多而且稳定，
开发起来比较顺心。但tcp的缺点也很多，数据报头有20+字节，在一些动作类游戏中，需要非常频繁地与服务器进行交互，
而且通常一个操作指令会很小（基本上都小于20个字节 :P),这就代表一半的带宽开销被用在了数据报头上。
其次就是tcp需要保持连接状态，这个在pc上可能不是问题，在手机上问题就大了。
手机信号不稳定，ios操作系统会将后台非特殊进程挂起，导致游戏断线需要断线重连，也就是重新登陆一次，
做过网游的同学都知道，游戏登陆操作对服务器的开销往往是最大的。
再一个就是tcp丢包重传的特性引起的，每次发送数据包需要check是否包已到达，
队列后的数据包需要等待前一个数据包成功发送后才能进行发送，这样会导致严重的lag，
在手机信号不好时尤为明显。由于大量的tcp连接会带来开销，基于tcp的游戏通常在线人数会有limit,
当然，使用分布式架构或者游戏滚服会解决掉这个问题（tcp分布式架构人人都会做，做的好不好，这个得看功力）。

http：
因为http不需要持续地保持连接，是一个无状态的连接，不会产生tcp所产生的断线重连的问题，
服务器也不需要维护过多的连接。缺点就是需要经常的进行tcp握手操作（不会影响玩家体验），
而且由于http的无状态性，通常游戏数据需要实时保存，不过现在的内存数据库 nosql的兴起和计算机性能的提升，这块劣势已经不存在，
而且越来越多的游戏都采用实时数据保存，防止游戏服务器宕机数据回档的风险。
再一个就是服务器无法主动向客户端推送数据，导致在某些功能上会无法实现。
由于http的无状态性，需要做心跳处理，基于http的游戏服务器可以横向扩展（每一个游戏服务器进程就是一个单纯的逻辑计算器），
数据库架构设计的好的话，一个游戏服很容易实现1亿+的玩家同服的情况。

udp：
优点就是“快”和“小”，udp不会产生tcp的数据包队列阻塞的问题，而且报头数据量很小，
在某些对速度和网络io量有较大要求的玩法时，这2个优点显得尤为重要，而且udp是无连接的，不会产生断线问题，也可以横向扩展。
缺点就是udp的不可靠性，一些实现可靠的udp协议的第三方库很少，而且往往满足不了自己项目的需求，所以要实现可靠的udp要自己动手造一遍轮子，
需要一定的网络基础知识和敢于踩坑的精神 。

推荐方案
方案1 ：完全使用udp，几个项目下来，觉得使用udp做手游服务端真的是perfect match。
没有断线问题，流量小，响应速度快。无奈手游环境开发商们心态比较浮躁，都以稳定来追求利益最大化，市面上完全使用udp的游戏非常少。 

方案2 ：http+udp，这种相对保守一些，逻辑相关的使用http协议，保证游戏逻辑不会出通讯上的问题，推送类的使用udp，
比如聊天，世界公告等等，这些就算你的udp协议写的烂，也不会产生严重问题。
如果实时性要求非常高的战斗功能，请使用udp。

方案 3：tcp+udp，这种方式为了加强连接的可靠性，tcp断了可以用udp继续游戏，两种连接来加强连接的可靠性。在手游MMORPG类型的长连接的游戏中更为合适。




八．  网络加密与压缩
短连接可以用md5前面的所有参数作为校验依据，防止篡改。
加密方式
支持IP6以符合苹果审核，用域名
九．  优化
*短连接用www，做队列，单任务作业，合并请求和回调(每个请求有编号，对应回调)
*长连接自己写，协议可以用protobuff，缩小协议长度
*短连接用md5，token验证参数正确性
*两边加密可以把公钥写在so文件里
*长连接自己写，做队列，锁，多任务作业 --&gt;
</description>
               <pubDate>Sun, 14 Jul 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/07/14/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%826.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/07/14/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%826.html</guid>
            </item>
        
            <item>
               <title>思路探讨(二十五) 困境中的中产</title>
               <description>&lt;p&gt;还是聊聊关于钱的事吧，人生哲学聊多了也没什么立竿见影的效果，能理解的瞬间就能懂，理解不了也只能等那灵光一现的时候。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;最近股市很动荡，中国经济很动荡，L型的经济走势一直没有走完，还不断得被破坏和骚扰。我猜大部分人都在痛苦得挣扎，社会经济似乎走上了萧条的环境，周遭的环境和人们的积极性越来查差，埋怨的越来越多，人们开始怀疑中国的是否能崛起，其实我也一样，不过我知道未来总是不确定的，无论崛起与否我们自身都需要保持积极和乐观，即使有余钱的少部分人，手里拿着钱也是不知所措的，投哪都是亏惨的结局，所以现在这个环境，没有赢家。&lt;/p&gt;

&lt;p&gt;想尽快突围，只有一条路，打铁还需自身硬，乘着大环境不好，我们有理由不去追逐名利，那就沉下心来多多自我修行，多多学习，多多看书，多多磨炼。&lt;/p&gt;

&lt;p&gt;我为什么要弄明白经济运作规律，就是想在未来的人生道路上走的更有方向性，并不一定说要变富有，但至少能少走点邪魔歪道。&lt;/p&gt;

&lt;p&gt;其实最惨的就是中产阶级了，中产阶级即想往上冲，又背负着最沉重的债务，真的难。&lt;/p&gt;

&lt;p&gt;在经济不景气的时候大部分人都要面临债务危机。由于在经济繁盛的时候人们的心里装的都是怎么赚到更多的钱，而对大量的债务风险视而不见，当萧条和不景气来临时，就发现当前的债务过大，利息过多，原来在经济繁盛时很容易偿还和导手的资金，变得很艰难，因此债务压力变得越来越沉重。一不小心，几代人的血与泪以及奋斗积攒的财富，在一瞬间里全部消散了。&lt;/p&gt;

&lt;p&gt;这也是为什么中产阶级最难的原因，背负的债务与收入严重不匹配。在萧条期，最先倒下的就是中产，最容易倒下的也是中产，最快倒下的是中产。&lt;/p&gt;

&lt;p&gt;什么原因导致中产总是最先倒下，难道是中产的人笨吗？又为什么偏偏是中产阶级呢，就不能是其他层阶级或者富人阶级吗？&lt;/p&gt;

&lt;h6&gt;中产有许多自己的阶级特征，大部分的这些特征都说明了，这个阶级没有自主权，不够灵活。&lt;/h6&gt;

&lt;p&gt;不够灵活体现在这几个方面：&lt;/p&gt;

&lt;h3&gt;1，资产量不大，却大部分集中在单一投资方向上。&lt;/h3&gt;

&lt;p&gt;中产阶级的资产大部分比较集中房产上，与房地产行业捆绑紧密。并且是某一个市的一处房子上。&lt;/p&gt;

&lt;p&gt;或者有的中产买些股票，基本都是把大量资金集中在某只股票上。&lt;/p&gt;

&lt;p&gt;资产的升降直接与某个标的绑定的很牢固。只要这个标的一旦崩溃，就可能直接破产。&lt;/p&gt;

&lt;h3&gt;2，债务量与自身收入不成比例。&lt;/h3&gt;

&lt;p&gt;中产阶级创业的最多，超负荷负债买房的也最多。&lt;/p&gt;

&lt;p&gt;职场并不是所有中产阶级都能呆到退休的地方，这一点大部分人都没有意识到问题的严重性，年级大了想找份工作都是难事，年轻人的竞争力更强更有活力。只有职场上的赢家才能继续呆到退休，赢家很多种，技能上的，情商智商上的，还有运气上的。&lt;/p&gt;

&lt;p&gt;所以大部分中产阶级都需要通过自主创业的形式来获得更加稳固持久的收入来源，但创业哪有这么容易，基本都是赔钱，很多中产选择借钱维持，利滚利，加上，继续入不敷出，就会陷入一个更加大的泥潭，不止财务上出现大的问题，精神上也会出现大的问题。&lt;/p&gt;

&lt;p&gt;所以债务导致的破产，在中产阶级数不胜数。&lt;/p&gt;

&lt;h3&gt;3，财富迁移难度大。&lt;/h3&gt;

&lt;p&gt;中产阶级虽然有财富，但毕竟是不是富有人家，无法轻易的迈过一些高门槛的迁移动作。&lt;/p&gt;

&lt;p&gt;比如从二三线城市，甚至从三四线城市，向一线城市迁移就很难，这些其他线城市的房价卖掉后，在一线城市也很难买到几平米，更不用说由于迁移引发的一系列的家庭和生活的问题，挡住了大部分家庭的决心。&lt;/p&gt;

&lt;p&gt;其实不管从心里和现实的角度看，迁到一线城市这种动作，都是需要付出沉重代价的。沉重的代价背后，是否值得，对于每个不同家庭情况来说，都是不一样的。&lt;/p&gt;

&lt;p&gt;又比如移民到拥有更好的经济环境的国家去，这种大级别的迁向更好环境的动作非常难,门槛也非常高。迁移到比中国环境更加弱的国家去是毫无意义的，因为经常听到有人迁移到东欧，以及西欧部分不发达国家，甚至东南亚地区，根本就是自找苦吃。&lt;/p&gt;

&lt;p&gt;唯有迁到世界第一的美国，才是所有迁移选择中最值得的，迁移到美国的门槛比较高，要么技术很牛逼，要么钱很多，500w以上是正常的迁移及投资费用，对于囊中羞涩的中产来说希望渺茫。&lt;/p&gt;

&lt;h3&gt;4，急功近利的思想居多。&lt;/h3&gt;

&lt;p&gt;严重缺钱的中产，其实比其他各层阶级都缺钱，这种缺钱的氛围时常影响着中产家庭的整个人生，这很容易滋生暴富思想。&lt;/p&gt;

&lt;p&gt;很多中产的人总是希望通过借用杠杆来达到一夜暴富。坚信，深信，只要机会一来，自己就能暴富。&lt;/p&gt;

&lt;p&gt;所以中产也是最好骗的，错的，假的，危险的机会，中产们很容易受其诱惑，一旦试图抓住这些机会，他们总想着暴富，不顾一切的投入，全部资产还不够，甚至还借用杠杆，试图一夜暴富。最终，醒过来时，一切已晚，财富早已化为乌有，消散而去。&lt;/p&gt;

&lt;p&gt;其实不能说中产素质不够，辨识不了真假和风险的高低，因为即使博士毕业在这样一个氛围的圈子里也同样会被蒙蔽了双眼，学历越高的人对自己做出的选择坚信不疑的程度越高。&lt;/p&gt;

&lt;h6&gt;那么中产就没有办法了吗？&lt;/h6&gt;

&lt;h6&gt;这个世界能突出重围的人毕竟是少数，无论在哪个圈子，哪个层级，都是一样一样的，因为人性不变，金字塔就不会变，中产更是普遍持有其特点的人群。&lt;/h6&gt;

&lt;h6&gt;因为能看清经济发展规律并降低财富抬升期望的人毕竟是少数。&lt;/h6&gt;

&lt;h6&gt;能持续不断分散投资，多维度考察和思考投资思路和角度的人毕竟是少数。&lt;/h6&gt;

&lt;h6&gt;能沉下心来，排除杂音，专心做好事情，以及专心做自己的人毕竟是少数。&lt;/h6&gt;

&lt;h6&gt;能推开暴富机会诱惑的，不嫉妒那几十万分之一概率中赢得财富的人毕竟是少数。&lt;/h6&gt;

&lt;h6&gt;能持之以恒，不为外界纷扰所动的人毕竟是少数。&lt;/h6&gt;

&lt;h6&gt;如果我们能做到这些少数人才能做到的，我相信量变造成质变会在多年后发生在我们身上。&lt;/h6&gt;
</description>
               <pubDate>Sat, 06 Jul 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/07/06/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A825.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/07/06/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A825.html</guid>
            </item>
        
            <item>
               <title>思路探讨(二十六) 我们真的聪明吗</title>
               <description>&lt;h3&gt;更多时候，我们不是败给了外界，而是败给了自己。&lt;/h3&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h6&gt;我们都是认为自己是聪明的人，没有人会认为自己是那个笨蛋。但聪明真的用在了刀口上吗，不是的，更多时候，聪明被用在刀背上，而愚蠢却常常用在刀口上。&lt;/h6&gt;

&lt;p&gt;“骄傲使人落后”这句话一点都没说错，人很容易没有警惕心理，在没有了谨小慎微的态度后，人总是不自觉的陷入当前环境的假想中，认为当前状况是永远可持续的。&lt;/p&gt;

&lt;p&gt;举个例子，在繁荣时期，人人都有工作的时间，社会上到处都是工作，赚钱也很容易，投个股票，买个基金，放贷给个人，投个P2P，坐等收钱就行了。&lt;/p&gt;

&lt;p&gt;人会不自觉的陷入我不缺工作，我很聪明，我很能赚钱，我很厉害的心理状态和自我认识。&lt;/p&gt;

&lt;p&gt;所以在繁荣时期，人们都会觉得自己很聪明，很能赚钱，我们会认为是因为我们的聪明所以工作很容易找到，赚钱很容易，却从来不认为是繁荣的环境造就了我们。&lt;/p&gt;

&lt;h6&gt;但在萧条时期就不同了，我们会很难找到工作，赚钱也很难，亏钱很容易，原来在繁荣时期浪费的时间，浪费的钱，在萧条时期就开始了对我们的大规模的惩罚。这对人自身的打击不是一点点，能彻底醒悟的人还是不多，能冷静下来一步步脚踏实地积累和沉淀的更少，骄傲没有这么容易败下阵来。&lt;/h6&gt;

&lt;p&gt;那么有人说，我在繁荣时期不去凑这个热闹，自己一步步脚踏实地的积累和沉淀，走自己的路，让别人去赚它自己的钱，不就可以了么。&lt;/p&gt;

&lt;p&gt;其实并没有这么容易，还是同样的话，人很难不受当前环境所影响，在大家都大把大把地赚钱，大把大把的挥霍的时候，我们是很难不受他们影响而不去追随他们的，嫉妒心和贪念的放大致使我们无法控制自己，在贪婪的时刻疯狂的去追求一些虚无缥缈的价值。&lt;/p&gt;

&lt;p&gt;其实退一步说，即使我们能忍住不去嫉妒、不去贪婪，我们周围的亲朋好友肯定没有我们这么好的定力，他们可能会不断得劝我们，骚扰我们，甚至指责我们的无能，指责我们在别人都疯狂的享受盛宴的时候我们却让这么大好的机会错过。&lt;/p&gt;

&lt;p&gt;像这样的假象在生活当中其实有很多。我们年轻的时候，会有股很强烈的意识，认为我们的时间和精力会一直像现在这么多，所以我们在年轻时，时常会大把大把的浪费我们的时间和精力在一些根本毫无意义的事情上，而对于那些需要我们沉下心来学习和积累的事情却认为时间很多以后也能去做。&lt;/p&gt;

&lt;p&gt;随着时间的流逝，精力的下降，年龄的增大，量变成了质变，突然会意识到，我们已经不再年轻，已经不再拥有这么多精力，而原本应该学习和积累的才干却一点都没有做到，原来大把大把的消磨时光和浪费的精力，已经一去不复返了。&lt;/p&gt;

&lt;p&gt;对于青春貌美的年轻人也是同样，几乎所有的年轻人都在这个年轻的姿态下，总是会不自觉的认为我会永远这样年轻貌美，进而无节制的用当下的年轻貌美的优势来享受当下的快乐，等过几年发现年轻貌美一去不复返时，却什么都没有留下。&lt;/p&gt;

&lt;h6&gt;就因为我们并没有意识到当下的我们其实是暂时的，我们的聪明和貌美只是环境造就的，而非我们自己本身的努力，所以总是表现出一副傲人的姿态。&lt;/h6&gt;

&lt;p&gt;我们真的聪明吗，确实不笨，但总是聪明反被聪明误。&lt;/p&gt;

&lt;h6&gt;除了在好环境中无法感知自身的不足外，在辛苦的环境也，也会无法感知自身的进步。&lt;/h6&gt;

&lt;p&gt;人总是无法在当前情景中察觉到自己的位置和状态，就像古诗说的，不识庐山真面目，只缘身在此山中。&lt;/p&gt;

&lt;p&gt;我们在辛苦和充实的日子里，经常会感到乏味、枯燥、苦楚，因为辛苦的日子里天天做着重复的事情，天天面对的自己无法克服的障碍，天天面对从来没有面对过的困难，天天跟自己较劲，天天突破自己的极限，以及天天突破自己的三观和认知。而我们却很难察觉这种辛苦和枯燥对我们的帮助有多大。就因为无法察觉导致我们时常想要摆脱辛苦的状态，总想着早早放弃。&lt;/p&gt;

&lt;p&gt;有时候也要冷静下来，细心想想，这些辛苦的日子里，我到底学到了什么，及时的让自己感受到进步。如果能在辛苦的时候察觉到自己的进步，这种及时的良好的反馈，能让自己不受精神的阻扰，勇往直前。&lt;/p&gt;

&lt;h6&gt;苦中作乐，其实是最好的状态，但关键还是我们要能感受到’乐‘的存在，如果感受不到’乐‘而只感受到’苦‘，那么即使是在一个很好的、很难得的环境下，可能我们也很难坚持下去。&lt;/h6&gt;
</description>
               <pubDate>Mon, 24 Jun 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/06/24/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A826.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/06/24/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A826.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第十章，地图与寻路(一) A星算法及优化</title>
               <description>&lt;p&gt;寻路一直是游戏项目中的热门功能，寻路算法用的最多的就是A星算法，其他也有，比如 Dijkstra算法 与 Floyd 算法，但是他们的在时间和空间上的复杂度都太高，Dijkstra算法时间复杂度为O(N^2)，空间复杂度也是O(N^2)，Floyd的时间复杂度更高有O(N^3)，空间复杂度也在O(N^2)，这种复杂度的算法寻路算法如果应用在游戏中稍微大一点的范围、大面积、稍微高一点的频率的寻路需求是CPU是无法承受的。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;A星算法其实并不是最短路径算法，它找到的路径并不是最短的，它的目标首先是能以最快的速度找到通往目的地的路，它的时间复杂度为O(NLogN)，最差的情况是从起点出发把所有的格子都走了一遍，最后才找到目的地。&lt;/p&gt;

&lt;h6&gt;用一句话概括A星：用最贪婪的方法寻找目的地的路径。&lt;/h6&gt;

&lt;p&gt;怎么个贪婪法呢，我们要拿方格来描述A星算法，因为用方格描述A星寻路的方式很容易理解。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;[][][][][]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[][][][][]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][][][]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[][][][][]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[][][][][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上图中s为start起点(3,2)，e为end终点(5,5)。&lt;/p&gt;

&lt;h6&gt;用最贪婪的方法去找目的地：在所有得到的点中，找到与目的地e距离最短的那个，就是离目的地e最接近的，继续用这个点向前探索，直到找到目的地。&lt;/h6&gt;

&lt;h6&gt;简单来说从s点开始取出它周围的4个点，上，下，左，右，计算下它们与终点e的距离，哪个离e的距离最短，就取那个点的周围4个元素继续进行同样的操作，直到找到目的地e。&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;[-][-][-][-][-]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[-][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][-]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[-][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[-][-][-][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上图中，s开始取到周围的4个点标记为1，计算距离，并推入到一个队列，把这个队列按到e点距离值从小到大排序一下，取出离e点距离最短的点，再从该元素周围取出4个元素标记为2，推入到队列，并对它们计算与e的最短距离，再排序一下，取出离e点距离最近的那个标记为3，依次重复这种操作，直到找到e目的地。所有被标记过的都不能再被重复标记。&lt;/p&gt;

&lt;p&gt;我们来看看复杂点的A星寻路例子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;[-][-][-][-][-]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][+][+][-][-]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[-][+][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][-][-]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[-][+][-][-][-]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[-][-][-][-][-]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从s出发到e，图中‘+’为障碍物，用贪婪的A星寻路会怎么找到e呢，如下图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][-][-][-][-]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][+][+][-][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][+][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][+][+][+][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;1.先取s周围的点标记1&lt;/h6&gt;

&lt;h6&gt;2.取标记里最近的且没被取过的点，即下面这个1点，取它周围点标记为2&lt;/h6&gt;

&lt;h6&gt;3.取标记里最近的且没被取过的点，即点3也可以是上面的1，但我们定个规则一样的距离以下面为标准，取它周围的点标记为点4&lt;/h6&gt;

&lt;h6&gt;4.离e点最近的还是4，继续取它周围的标记为5&lt;/h6&gt;

&lt;h6&gt;5.离e点最近的还是5，继续取周围点标记为6&lt;/h6&gt;

&lt;h6&gt;6.离e点最近的还是6，取它周围的点标记为7&lt;/h6&gt;

&lt;h6&gt;7.离e点最近的还是7，取它最近的点标记为8&lt;/h6&gt;

&lt;h6&gt;8.离e点最近的是8，取它周围的点标记为9&lt;/h6&gt;

&lt;h6&gt;9.离e点最近的是9，取它周围的点标记为10&lt;/h6&gt;

&lt;h6&gt;10.离e点最近的为左边的10，取它周围的点时发现到达目的地e，结束。&lt;/h6&gt;

&lt;p&gt;上述过程明晰的阐述了A星算法贪婪的全过程，即只选择当前的最优选择，因为只关注当前的最优解，就忽视了对全局的最优解，走‘弯路’是常有的事。&lt;/p&gt;

&lt;p&gt;体现在代码上为如下伪代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;        function find_path(s,e)
        {
            open = new list(); //没有被取到过的点
            close = new list(); //已经被取过的点

            open.add(s); //从s点开始

            for(!open.IsEmpty()) //重复遍历直到没有点可以取
            {
                open.sort(); //排序一下

                p = open.pop(); //把最近的点推出来

                if(p == e)
                {
                    //找到终点
                    break;
                }

                p1 = p.left(); //取左边的点
                p2 = p.right(); //取右边的点
                p3 = p.top(); //取上边的点
                p4 = p.down(); //取下边的点

                //是否已经被取过
                if(p1 != null &amp;amp;&amp;amp; p1.IsNotInClose())
                {
                    //加入到没被取过的列表里
                    open.add(p1);
                }

                //是否已经被取过
                if(p2 != null &amp;amp;&amp;amp; p2.IsNotInClose())
                {
                    //加入到没被取过的列表里
                    open.add(p2);
                }

                //是否已经被取过
                if(p3 != null &amp;amp;&amp;amp; p3.IsNotInClose())
                {
                    //加入到没被取过的列表里
                    open.add(p3);
                }

                //是否已经被取过
                if(p4 != null &amp;amp;&amp;amp; p4.IsNotInClose())
                {
                    //加入到没被取过的列表里
                    open.add(p4);
                }

                //p点已经被取过了
                p.setClose(false);
                close.add(p);
            }
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述伪代码完整的诠释了A星寻路的全过程。&lt;/p&gt;

&lt;p&gt;当地图很大的时候，或者使用A星算法的寻路频率很高的时候，普通的A星算法就会消耗大量的CPU性能急剧下降，普通的A星性能还是不过关。接下来我们讲讲A星寻路在遇到性能瓶颈时的优化方案。&lt;/p&gt;

&lt;h3&gt;一、长距离导航&lt;/h3&gt;

&lt;p&gt;当距离很大，中间有很多障碍物时，A星的算法就会遇到瓶颈，不断加入的可行走点使得排序速度越来越慢，最后可能造成CPU阻塞无法动弹。&lt;/p&gt;

&lt;p&gt;当寻路距离太大时怎么办？&lt;/p&gt;

&lt;p&gt;其实路径不是非得实时计算出来才好，我们可以把一些常用的路径，在离线下算好放在数据文件中，游戏开启时放在内存里，当需要寻路到那个节点或者那个节点附近时，就可以取出来直接使用，而不再需要计算。&lt;/p&gt;

&lt;p&gt;比如 A到B 我们已经算法路径并存放在了内存里，当我们在A附近，要寻路到B附近时，就可以先寻路到A，再调出A到B的路径，再计算B到目的的路径。&lt;/p&gt;

&lt;p&gt;以这种方式来规避一些计算量特别大，或者计算频率特别高的寻路算法调用，在大型世界的RPG游戏里特别常用。&lt;/p&gt;

&lt;p&gt;另一种方法为制作导航点的方式。什么是导航点呢？就是去目的地的必经的点位。&lt;/p&gt;

&lt;p&gt;比如在一座城市里，有4个出口点，这个4个出口点就可以称为导航点，去目的地的路上肯定会经过这4个点的其中一个，我们在寻路时可以先寻找到最近的一个出口的导航点，当到达导航点后，再次寻找到目的地去的路径，有可能在这条路径上，还有一些导航点，继续寻找最近的导航点，依次类推，直到没有导航点可寻时，则直接寻路到目的地。&lt;/p&gt;

&lt;h3&gt;二、A星的排序算法优化&lt;/h3&gt;

&lt;p&gt;每次插入open列表的点后，open就不再是有序的队列了，所以每次去拿最小值时都需要重新排序。排序的时间消耗随着队列长度的增大而增大，其实有很大一部分A星的性能消耗都在排序上。&lt;/p&gt;

&lt;p&gt;那么是不是可以不排序，其实可以不排序，而使用找到插入位置并插入的方法，让队列永远保持有序状态。&lt;/p&gt;

&lt;p&gt;因为open队列在插入前是有序的，所以我们可以选用二分查找算法来找到插入的位置。&lt;/p&gt;

&lt;p&gt;每次插入时都使用二分查找算法查找插入点，那么每次的插入复杂度为O(logN)，比快排一次的O(NlogN)要快很多。&lt;/p&gt;

&lt;h3&gt;三、优化排序判断依据的预测值计算方法&lt;/h3&gt;

&lt;p&gt;前面用图所举的例子中，都是以当前点p与终点e之间的距离来作为预测值，这种方法简单但也不科学，导致A星寻找更好的点位时总是要绕很大的弯路。&lt;/p&gt;

&lt;p&gt;我们可以改变一下这个策略，选用一个更科学的方法， F 预测值= G 当前最近步数 + H 预测当前点到终点的步数 的方法。&lt;/p&gt;

&lt;p&gt;F 为预测值，G为起点s到当前点p的最近步数，H为当前点p到终点e的预测值，它们相加为F预测值。&lt;/p&gt;

&lt;p&gt;其中G应该是已经计算好并放入节点中的值，该值就是计算过程中起点s到当前点的步数。我们可以把每步计算好的步数都放入节点中，以待需要计算时使用。&lt;/p&gt;

&lt;p&gt;这个方法相当于，原来只关注当前点到终点的距离，变为关注起点s经过当前点p路径到终点e的距离，虽然还是贪婪的简单预测算法，但比起原来只关注当前点p与终点e的距离，更加科学化，能更快的找到更好更近的点位。&lt;/p&gt;

&lt;p&gt;为什么要改善这个预测值，改善预测值有什么意义呢？&lt;/p&gt;

&lt;p&gt;其实预测值的计算方法代表了在寻路过程中的走法，如果预测值只关注在于终点距离最近的点上，那么在寻路过程中的选择点位的顺序就会偏向于与终点更近的点。而如果预测值计算公式，关注的是整个距离较近的点位上，那么在寻路过程中在选择点位上也就会偏向整条路径短的方向上去靠。&lt;/p&gt;

&lt;h3&gt;四、多次频繁A星寻路的优化&lt;/h3&gt;

&lt;p&gt;多次频繁寻路中，对A星算法中每个运算，每行代码的运算细节都会有比较重大的考验。&lt;/p&gt;

&lt;p&gt;比如我们在查看一个节点是否为被取过的节点，即是否为Close，很多人都会在Close里取寻找该节点是否存在，这个操作明显就没有考虑到性能的消耗，要在Close列表中找节点，就相当于遍历一遍所有已经找过的节点，Close里的节点越多，越浪费CPU，而且是不只一次浪费，每个循环都会浪费一次，性能消耗巨大。&lt;/p&gt;

&lt;p&gt;因此我们通常的做法是把节点作为一个实例，在实例中添加IsClose的变量，来判断是否被取过，或者说是否Close。&lt;/p&gt;

&lt;p&gt;但这种方法还是不够，因为IsClose变量是要初始化的，每次寻路都要将前面寻路过的痕迹抹去才能开始全新的寻路过程。&lt;/p&gt;

&lt;p&gt;这就是又一个被很多人忽视的初始化的性能消耗，每次在A星寻路开始前，需要将IsClose的变量初始化为false，就需要遍历整个数据来初始化。&lt;/p&gt;

&lt;p&gt;每次都要遍历整个数据的话，A星算法无论优化的多快都无济于事了，因为初始化的性能消耗就已经将A星的性能消耗完全盖掉了。如果初始化的性能消耗需要遍历整个数据，那么优化A星算法的意义何在。&lt;/p&gt;

&lt;p&gt;其实可以用一个变量就能判断IsClose的方法，无需初始化。&lt;/p&gt;

&lt;p&gt;我们可以在寻路类中设置一个属性变量FindIndex，或者专门为寻路服务的静态变量也可以，而每个寻路节点中也存有一个变量FindIndex，每次寻路前都对FindIndex++，在判断IsClose时，当节点中的FindIndex与寻路类中FindIndex一致时说明已经被当次寻路算法取出过，否则两者不一样，说明这个节点没有被取出过，当节点被取出时，节点里的FindIndex则设置为当前寻路类中的FindIndex值，以表明该节点已经被这次寻路算法取出过。&lt;/p&gt;

&lt;p&gt;用一个变量和整数的比较就能知道IsClose的结果，省去了巨量的初始化操作。&lt;/p&gt;

&lt;h6&gt;在A星算法这种经常用频繁用的算法中，一个小小的性能消耗就能放大很多倍，特别注意调用的函数的复杂度，公式的复杂度，以及运算的优化，尽量做到能不调用函数的不调用函数，能简化公式的尽量简化公式，能用&amp;amp;|&amp;lt;&amp;gt;位运算符号代替加减乘除的尽量用位运算代替，节省A星算法的性能开销。&lt;/h6&gt;

&lt;h6&gt;我也看过所谓的B星算法过程，其实世上没有B星，所谓的B星其实就是我们A星的优化版本，而且互联网中所阐述的B星算法存在一定几率无法寻到路径的问题，即它只关注所谓的‘前方‘，而忽略了其实’后方‘也有路，如果只有后方有路时，B星就无法找到路径。&lt;/h6&gt;
</description>
               <pubDate>Sat, 22 Jun 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/06/22/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E5%9C%B0%E5%9B%BE%E4%B8%8E%E5%AF%BB%E8%B7%AF1.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/06/22/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E5%9C%B0%E5%9B%BE%E4%B8%8E%E5%AF%BB%E8%B7%AF1.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第六章，网络层(五) - 剖析数据协议原理</title>
               <description>&lt;h6&gt;协议包的格式，json, msgpack, protobuf 以及自定义格式&lt;/h6&gt;

&lt;p&gt;项目的网路层在建设中，除了选择长短连接TCP，UDP，HTTP方式外，还需要选择在传输过程中使用什么样的协议格式。&lt;/p&gt;

&lt;p&gt;前面分析了TCP，UDP，HTTP的原理与应用，现在我们来了解下在传输层和应用层之上的逻辑层中，信息传递格式的选择与利弊。&lt;/p&gt;

&lt;p&gt;我们将深入剖析JSON，MessagePack，Protobuf的原理，包括它们都是由什么组成的，怎么序列化的，怎么反序列化的，数据格式究竟是由哪些元素构成的，使我们对网络数据协议的理解更加透彻清晰。&lt;/p&gt;

&lt;p&gt;我们以最常见的JSON格式作为切入点，一步步深入了解更加有效却复杂的传递格式。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h6&gt;JSON&lt;/h6&gt;

&lt;p&gt;JSON：JavaScript 对象表示法（JavaScript Object Notation）。它是存储和交换文本信息的语法。类似 XML，但比 XML 更小、更快，更易解析。&lt;/p&gt;

&lt;p&gt;JSON 是轻量级的文本数据交换格式，它独立于语言，具有自我描述性，更易理解。&lt;/p&gt;

&lt;p&gt;JSON 是属于纯文本，具有“自我描述性”（人类可读），具有层级结构（值中存在值）&lt;/p&gt;

&lt;p&gt;JSON与同时纯文本类型格式的XML相比较，JSON不需要结束标签，JSON更短，JSON解析和读写的速度更快，在JavaScript中能够使用内建的 JavaScript eval() 方法进行解析，JSON还可以使用数组，切不使用保留字（&amp;amp;，&amp;lt;，&amp;gt;，&amp;#39;，&amp;quot;）。&lt;/p&gt;

&lt;p&gt;JSON 语法规则：&lt;/p&gt;

&lt;p&gt;JSON 数据的书写格式是：名称/值对。&lt;/p&gt;

&lt;p&gt;名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值：&lt;/p&gt;

&lt;p&gt;&amp;quot;firstName&amp;quot; : &amp;quot;John&amp;quot;&lt;/p&gt;

&lt;p&gt;JSON数据由逗号分隔，它的值可以是：&lt;/p&gt;

&lt;p&gt;数字（整数或浮点数）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;{
  &amp;quot;number&amp;quot; : 1,
  &amp;quot;number2&amp;quot; : 11.5
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;字符串（在双引号中）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;{
  &amp;quot;str1&amp;quot; : &amp;quot;1&amp;quot;,
  &amp;quot;str2&amp;quot; : &amp;quot;11&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;逻辑值（true 或 false）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;{
  &amp;quot;logic1&amp;quot; : true,
  &amp;quot;logic2&amp;quot; : false
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;数组（在方括号中）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;{
   &amp;quot;array1&amp;quot; : [1,2,3],
   &amp;quot;array2&amp;quot; : [{&amp;quot;str1&amp;quot;,1},{&amp;quot;str2&amp;quot;,2},{33,44}]
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对象（在花括号中）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;{
  &amp;quot;obj1&amp;quot; : {1, &amp;quot;str1&amp;quot;, true},
  &amp;quot;obj2&amp;quot; : {&amp;quot;str2&amp;quot;, 2, false},
  &amp;quot;obj3&amp;quot; : null
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JSON 对象在花括号中书写：&lt;/p&gt;

&lt;p&gt;对象可以包含多个名称/值对：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;{ &amp;quot;firstName&amp;quot;:&amp;quot;John&amp;quot; , &amp;quot;lastName&amp;quot;:&amp;quot;Doe&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JSON 数组在方括号中书写：&lt;/p&gt;

&lt;p&gt;数组可包含多个对象：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;{
    &amp;quot;employees&amp;quot;: [
        { &amp;quot;firstName&amp;quot;:&amp;quot;John&amp;quot; , &amp;quot;lastName&amp;quot;:&amp;quot;Doe&amp;quot; },
        { &amp;quot;firstName&amp;quot;:&amp;quot;Anna&amp;quot; , &amp;quot;lastName&amp;quot;:&amp;quot;Smith&amp;quot; },
        { &amp;quot;firstName&amp;quot;:&amp;quot;Peter&amp;quot; , &amp;quot;lastName&amp;quot;:&amp;quot;Jones&amp;quot; }
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JSON 文件的文件类型通常是 &amp;quot;xxx.json&amp;quot; 用来扩展名用来说明是json格式的文本文件&lt;/p&gt;

&lt;p&gt;JSON 文本的 MIME 类型是 &amp;quot;application/json&amp;quot; (MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准。MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。)&lt;/p&gt;

&lt;p&gt;JSON 解析器可以用些比较常用的，比如simpleJson，MiniJson，DataContractJsonSerializer，JArray，JObject等等，都是非常通用高效的插件。&lt;/p&gt;

&lt;h6&gt;自定义二进制流协议格式&lt;/h6&gt;

&lt;p&gt;大部分的网络协议都具有一定的通用性，JSON是最典型的案例，XML，MessagePack，Protobuf都具有一定的通用性，但自定义二进制流协议格式则不是，它完全不通用，因为它不需要顾及通用性。&lt;/p&gt;

&lt;p&gt;我们在存储一串数据的时候，无论这串数据里包含了哪些数据以及哪些数据类型，当我们拿到这串数据在解析的时候能够知道该怎么解析，这是定义协议格式的目标。&lt;/p&gt;

&lt;p&gt;简单的来说就是，当你传给我一串数据的时候，我是用什么样的规则知道这串数据里的内容的。JSON就制定了这么一个规则，这个规则以字符串KEY-VALUE，以及一些辅助的符号‘{’,&amp;#39;}&amp;#39;,&amp;#39;[&amp;#39;,&amp;#39;]&amp;#39;组合而成，这个规则非常通用，以至于任何人拿到任何JSON数据都能知道里面有什么数据。&lt;/p&gt;

&lt;p&gt;自定义二进制流协议格式则不具有通用性，不是任何人拿到数据都能知道里面装的是什么的，有且只有两端在私下协定的双方才知道该如何解析收到的数据，对于破解自定义二进制流的内容也只有靠猜，虽然猜的难度也不是非常大。&lt;/p&gt;

&lt;p&gt;一个自定义二进制流协议格式，分成三部分：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;数据大小|协议编号|具体数据
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;数据大小、协议编号、具体数据，这三者构成了一个完整的协议内容，这一整个协议内容少了谁都不成，不过有时数据大小和协议编号的前后顺序可以交换。&lt;/p&gt;

&lt;p&gt;我们举例来描述这个协议格式，假设我们客户端有这样一个数据结构需要传输到服务端去：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;struct test
{
  int test1;
  float test2;
  bool test3;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;服务端拿到数据时，其实完全不知道当前拿到的数据是什么，也不知道数据是否完整，有可能只拿到一半的数据，或者一部分的数据。&lt;/p&gt;

&lt;p&gt;首先我们要确定的是，我们收到的数据包它的完整的大小有多大，只有知道完整的包体大小才能确定我当前收到的数据在大小上是否完整，我们是要等待继续接受后面的数据，还是现在就可以进行解析操作了。&lt;/p&gt;

&lt;p&gt;为了确定包的完整性，我们必须先向二进制流中读取4个比特，组合成一个无符号整数，这个整数总共32位，也就是说我们的数据包的大小最大为2的32次减1个byte，然后再用来确定接下来的完整包体大小。&lt;/p&gt;

&lt;p&gt;例如我现在接受到了20个byte，读取前4个，组成一个整数后为24，说明我接受到的后面16个byte是一个不完整的包体，我应该继续等待后续的数据到来。&lt;/p&gt;

&lt;p&gt;其次我们要确定的是收到的数据包是属于哪个格式的协议。&lt;/p&gt;

&lt;p&gt;于是再读取4个byte大小的数据，组成一个无符号整数，用来确定协议号。比如这个无符号整数位为1002，就代表是编号为1002的协议。&lt;/p&gt;

&lt;p&gt;假设我们上面这个test结构的协议号是1002，那么接下来连着这个协议号的所有数据直到包体大小的末尾，都是这个test结构的数据。&lt;/p&gt;

&lt;p&gt;在解析这个具体数据的时候，要根据生成这个数据的顺序来解析。&lt;/p&gt;

&lt;p&gt;假设在生成这个二进制流数据时，我们的顺序是，先推入test1，再推入test2，再推入test3。test1是4个byte的整数，test2是4个byte的浮点数，test3是1个byte的布尔值，于是就有了&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;xxxx|xxxx|x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样一个形状的二进制流，每个‘x’为一个byte，这里4个byte组成一个int或float数据，1个byte组成布尔数据，‘|’只是为了解释说明用的分隔符不存在于数据内，这个数据其实就是由9个byte组成，其中前4个为test1，中间4个为test2，后面1个为test3。&lt;/p&gt;

&lt;p&gt;那么在网络传输过程中整个test结构的数据包格式为如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;13|1002|test1|test2|test3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;13为接下来的数据大小，1002位协议编号，test1|test2|test3为具体数据。&lt;/p&gt;

&lt;p&gt;我们在解析的时候也需要按照生成时的顺序来解析，先读取前4个byte组成一个整数赋值给test1，接着再读取4个byte组成一个浮点数赋值给test2，接着再读取1个byte赋值给test3，完成数据解析。&lt;/p&gt;

&lt;p&gt;对于数组形式的数据则要在原来的基础上多增加一个长度标志，比如 int[]类型数据，在生成时先推入一个长度，再连续推入所有内容，在解析的时候做同样的反向操作，先读取4个byte的长度标志，再对连续读取N个具体数据，这个N为长度标志。&lt;/p&gt;

&lt;p&gt;举例int[]为3个整数数组则二进制为如下效果：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;xxxx|xxxx|xxxx|xxxx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前4个byte为长度，接着3次4个byte为数组内的整数数据。&lt;/p&gt;

&lt;p&gt;自定义二进制流协议格式为最不通用的格式，但也是最节省流量的协议，因为每个数据都可以用最小的方式进行定义，比如协议号不需要4个byte，2个byte大小2的16次-1就够用了，长度有可能也不需要4个byte，只要2个甚至1个byte就够用了，有些数据不需要4个byte组成int整数，只需要2个byte数组short就够用了，甚至有些可以组合起来使用，比如协议结构中有4个bool，可以拼成一个byte来传递，这些都可以完全由我们来控制包体的大小不受到任何规则的限制，这也是自定义二进制协议格式最吸引人的地方。&lt;/p&gt;

&lt;p&gt;自定义二进制流协议格式最大的缺点是不通用，当我们需要更换一个协议格式的时候，旧的协议格式就无法解析了，特别是当新的协议解析旧的协议时就会报错。我们也可以做些补救这种问题的措施，为了能让旧的协议格式还能继续使用，我们在每个数据头部都加入一个2个byte的整数代表版本号，由版本号来决定该读取哪个版本的协议，这样旧的协议也照样可以兼容新的协议，只是处理起来的时候需要注意些初始化问题，那些旧协议没有的而新协议有的数据则要尽可能的初始化成默认值以免造成逻辑报错。&lt;/p&gt;

&lt;h6&gt;MessagePack&lt;/h6&gt;

&lt;p&gt;MessagePack 是一个介乎于JSON和自定义二进制流之间的协议格式，他的理念是 ‘It’s like JSON. but fast and small.’ 。&lt;/p&gt;

&lt;p&gt;与JSON相同的是MessagePack也有采用Key-Value形式的Map映射类型，不同的是MessagePack用byte形式存储整数、浮点数、布尔值，并且在Map映射类型外加入了更多单独类型（非KEY-VALUE形式）的数据类型，其中也包括了自定义二进制流的数据类型。&lt;/p&gt;

&lt;p&gt;其中map映射类型是比较常用，也是比较通用的存储形式类型，也因为它的通用性被很多程序员所喜爱。&lt;/p&gt;

&lt;p&gt;使用起来能和JSON用起来一样，并且数据大小比JSON小，解析速度又比JSON快，是MessagePack最大的特点。&lt;/p&gt;

&lt;p&gt;非map类型的数据，其实和自定义二进制流的存储方式差不多，只是把原来的‘数据大小|数据’的形式改为了‘类型|数据’，比如存储一个4个byte也就是32位的整数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;+--------+--------+--------+--------+--------+
|  0xd2  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|
+--------+--------+--------+--------+--------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个byte的值0xd2代表32位整数类型，它表示后面4个byte组合起来是整数类型的数据。&lt;/p&gt;

&lt;p&gt;再举个列子，32位的浮点数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;+--------+--------+--------+--------+--------+
|  0xca  |XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|
+--------+--------+--------+--------+--------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个byte的值0xca代表32位浮点数类型，它表示后面4个byte组合起来是浮点数类型的数据。&lt;/p&gt;

&lt;p&gt;以此类推，nil，bool，8位无符号整数，16位无符号整数，32位无符号整数，64位无符号整数，8位有符号整数，16位有符号整数，32位有符号整数，64位有符号整数等，以及32位浮点数，64位浮点数，都用这种类似的方式表示。&lt;/p&gt;

&lt;p&gt;其实用MessagePack并不是冲着这些单独的数据类型去的，因为这些单独的数据类型完全可以用自定义二进制流代替，我们最关心的其实是它的map类型数据。&lt;/p&gt;

&lt;p&gt;我们专门来看看，MessagePack的map类型的存储机制，为什么就比JSON快，为什么就比JSON小，它是如何存储和解析的。&lt;/p&gt;

&lt;p&gt;在map之前我们看看数组类型的格式：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;+--------+--------+--------+~~~~~~~~~~~~~~~~~+
|  0xdc  |YYYYYYYY|YYYYYYYY|    N objects    |
+--------+--------+--------+~~~~~~~~~~~~~~~~~+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个byte的值0xdc代表是个总共可以存储16位长度的数组，也就是最大为2的16次-1个元素的数组，后面2个byte组合起来成为一个无符号的整数代表后面有多少个元素，接着后面N个为相同类型的元素的数据。&lt;/p&gt;

&lt;p&gt;假设说这N个为32位整数类型，那么就是如下格式&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;+--------+--------+--------+~~~~~~~~~~~~~~~~~+
|  0xdc  |00000000|00000011|  0xd2|00001001|0xd2|00001101|...(3 objects)
+--------+--------+--------+~~~~~~~~~~~~~~~~~+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个数组中指定了数组类型，以及数组元素的个数，接下来的数据就是单个元素的数据了，每个数据都包含了‘类型|数据’格式。&lt;/p&gt;

&lt;p&gt;其实map类型就是Array数组类型的变种，在数组类型上每个元素，多加了个KEY字符串，我们来看下map的格式：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;+--------+--------+--------+~~~~~~~~~~~~~~~~~+
|  0xde  |YYYYYYYY|YYYYYYYY|   N*2 objects   |
+--------+--------+--------+~~~~~~~~~~~~~~~~~+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个byte的值0xde代表是最大个数为16位的map类型数据，接着2个byte组合起来表示有多少个元素，再接着N乘2个元素为数据元素，其中以2个元素为一个组合，第一元素一定是字符串KEY，第二个元素为单独的任意的数据类型。&lt;/p&gt;

&lt;p&gt;我们用官方的例子来分析下：&lt;/p&gt;

&lt;p&gt;一个JSON类型的数据：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;{&amp;quot;compact&amp;quot;:true, &amp;quot;schema&amp;quot;:0}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在MessagePack中的map格式为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;82|A7|&amp;#39;c&amp;#39;|&amp;#39;o&amp;#39;|&amp;#39;m&amp;#39;|&amp;#39;p&amp;#39;|&amp;#39;a&amp;#39;|&amp;#39;c&amp;#39;|&amp;#39;t&amp;#39;|C3|A6|&amp;#39;s&amp;#39;|&amp;#39;c&amp;#39;|&amp;#39;h&amp;#39;|&amp;#39;e&amp;#39;|&amp;#39;m&amp;#39;|&amp;#39;a&amp;#39;|00|
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中8位前半个byte的值代表是个15个以内的map类型数据，8后面的2是后半个byte的值，代表总共有2个元素。&lt;/p&gt;

&lt;p&gt;接着A为前半个byte的值，代表是是个31个以内的字符串，A后面的7代表这个字符串拥有7个字符。&lt;/p&gt;

&lt;p&gt;接着7个元素都是字符。&lt;/p&gt;

&lt;p&gt;接着C3是KEY-VALUE的VALUE，这个VALUE是一个bool型的ture值。&lt;/p&gt;

&lt;p&gt;接着A6，A为前半个byte代表是31个以内的字符串，A后面的6代表这个字符串有6个字符。&lt;/p&gt;

&lt;p&gt;接着6个元素都是字符。&lt;/p&gt;

&lt;p&gt;最后00，前面0为前半个byte，表示类型为7位以内的整数，接着的0位后半个byte，代表数据为0。&lt;/p&gt;

&lt;p&gt;MessagePack整个map就是以这种“类型|数据”或者&amp;quot;类型|大小|数据&amp;quot;的方式存储。由于存储的方式是顺序，所以在解析的时候不需要排序，不需要解析符号和类型，数据的类型直接可以用byte来表示，能用byte存储绝不用字符串形式存储，能减少byte使用个数的尽量减少byte的使用个数，能合并的尽量合并为一个byte。&lt;/p&gt;

&lt;p&gt;因此MessagePack对于JSON来说，比JSON减少了大量的解析，比JSON减少了更多的数据空间，使得MessagePack能比起JSON来更快并且更小，就像它自己所说的那样 ‘It’s like JSON. but fast and small.’。&lt;/p&gt;

&lt;h3&gt;Protocol Buffer&lt;/h3&gt;

&lt;p&gt;虽然Proto3在Proto2之上又做了更多的改进，但我们这里以Proto2为基准来讲解Protocal buffer的内在机制。&lt;/p&gt;

&lt;p&gt;MessagePack在JSON之上做了优化，其实可以看做是，把JSON和自定义二进制的合并做法，既汲取了JSON这种KEY-VALUE(键值对)通用性的优点，又汲取了自定义二进制流格式无需解析和存储空间小的特点。&lt;/p&gt;

&lt;p&gt;不过MessagePack的Map毕竟是kEY-VALUE形式的KEY值还是使用了字符串类型，它的KEY还是逃脱不了字符串string占用太多存储空间的弊端。&lt;/p&gt;

&lt;p&gt;Google Protocol Buffer 的出现就弥补了MessagePack的这个缺点，但是Google Protocol Buffer也有自身不可忽视的缺点，我们来看究竟Google Protocol Buffer是怎么的一种数据协议。&lt;/p&gt;

&lt;p&gt;Google Protocol Buffer( 简称 Protobuf) 是 Google 公司内部的混合语言数据标准，它们用于 RPC 系统和持续数据存储系统。&lt;/p&gt;

&lt;p&gt;Protobuf 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。&lt;/p&gt;

&lt;p&gt;常有人推崇说 Protocol Buffer 比JSON、MessagePack要好，那么它究竟好在哪里呢？我们就来分析下，为什么有这么多人推崇它。&lt;/p&gt;

&lt;p&gt;我们选择数据协议的目的主要关注的点是，它是否能更简单上手，解析数据是否能更快，存储空间是否能更小，通用性是否能更强。对于这些特点，Protocol Buffer 是否能都做到，还是说它只是在部分几个方面做到了，下面我们来透彻的对它剖析。&lt;/p&gt;

&lt;h6&gt;Protocol Buffer消息定义&lt;/h6&gt;

&lt;p&gt;创建扩展名为.proto的文件，如：MyMessage.proto，并将以下内容存入该文件中。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;message LoginReqMessage {
  required int64 acct_id = 1;
  required string passwd = 2;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;message是消息定义的关键字，等同于C#中的struct/class。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LoginReqMessage为消息的名字，等同于结构体名或类名。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;required前缀表示该字段为必要字段。即在序列化和反序列化之前该字段必须已经被赋值。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;与required相似的功能还存在另外两个类似的关键字，optional和repeated。&lt;/p&gt;

&lt;p&gt;optional表示该字段为可选字段，即在序列化和反序列化前可以不进行赋值。&lt;/p&gt;

&lt;p&gt;相比于optional，repeated主要用于表示数组字段。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;int64和string分别表示64位长整型和字符串型的消息字段。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在Protocol Buffer中存在一张类型对照表，既Protocol Buffer中的数据类型与其他编程语言(C#/Java/C++)中所用类型的对照。&lt;/p&gt;

&lt;p&gt;该对照表中还将给出在不同的数据场景下，哪种类型更为高效。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;acct_id 和 passwd 分别表示消息字段名，等同于C#中的域变量名。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;标签数字 1 和 2 表示不同的字段在序列化后的二进制数据中的布局位置。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在该例中，passwd 字段编码后的数据一定位于 acct_id 之后。需要注意的是该值在同一message中不能重复。&lt;/p&gt;

&lt;p&gt;对于Protocol Buffer而言，标签值为 1 到 15 的字段在编码时可以得到优化，即标签值和类型信息仅占有一个byte，标签范围是 16 到 2047 的将占有两个bytes，而Protocol Buffer可以支持的字段数量则为2的29次方减1。有鉴于此，我们在设计消息结构时，可以尽可能考虑让repeated类型的字段标签位于1到15之间，这样便可以有效的节省编码后的字节数量。&lt;/p&gt;

&lt;h6&gt;嵌套Protocol Buffer&lt;/h6&gt;

&lt;p&gt;我们可以在同一个.proto文件中定义多个message，这样便可以很容易的实现嵌套消息的定义。如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;required&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;required&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;optional&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;email&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

      &lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PhoneType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;MOBILE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;HOME&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;WORK&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

      &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PhoneNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;required&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;optional&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PhoneType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

      &lt;span class=&quot;n&quot;&gt;repeated&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PhoneNumber&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phones&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;repeated&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weight_recent_months&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;packed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AddressBook&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;repeated&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;people&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;AddressBook消息的定义中包含另外一个消息类型作为其字段Person，Person又包含了另一个消息类型作为字段PhoneNumber。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其中的 AddressBook 和 Person 被定义在同一个.proto文件中，也可以被分开来定义在各自的.proto文件中。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Protocol Buffer提供了另外一个关键字import，相当于 C++ 的Include，这样我们便可以将很多通用的message定义在同一个.proto文件中，而其他各模块功能的消息体定义在其他文件中，再通过import的方式将需要的结构体文件中定义的消息包含进来，如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;import &amp;quot;myproject/CommonMessages.proto&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;限定符 required、optional、repeated 的规则&lt;/h6&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在每个消息中必须至少有一个required类型的字段，保证数据中一定有至少一个数据。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;required限定符表示该字段为必要字段。即在序列化和反序列化之前该字段必须已经被赋值。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个消息中可以包含0个或多个optional类型的字段。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;optional表示该字段为可选字段，即在序列化和反序列化前可以不进行赋值，如果没有赋值则表示该数据为空。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;repeated表示的字段可以包含0个或多个重复的数据。注意，是重复的数据，可以等价于我们常使用的数组和列表，并且可以不赋值，则表示0个数据。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5&gt;Protocol Buffer 原理-序列化和反序列化&lt;/h5&gt;

&lt;p&gt;Protocol Buffer 是怎么识别和存储数据的，是序列化和反序列的关键。&lt;/p&gt;

&lt;p&gt;JSON 和 MessagePack 都使用了字符串的KEY作为映射到程序变量的关键字，变量和字符串用比较字符串的是否相等来判断是否为该变量，避免不了字符串太多而浪费空间。&lt;/p&gt;

&lt;p&gt;Protocol Buffer 则用数字编号来作为KEY的关键字，每个变量都必须有个不能重复的标签号(即数字编号)，用变量后面跟着的数字编号来映射到数据中的数字编号，进而读取数据。&lt;/p&gt;

&lt;p&gt;Protocol Buffer为每个变量都定义了一个标签号(即数字编号)，这个数字编号就代表了程序变量与指定编号数据的映射关系。&lt;/p&gt;

&lt;p&gt;有了这个规则还不够，因为程序在读取的时候，是不知道某个变量到底对应哪个标签号的，比如上面的Person的 name 变量，在程序里的 name 变量是不知道到底该读取哪个编号的数据的，除非在程序里写死。&lt;/p&gt;

&lt;p&gt;Protocol Buffer 就是使用了这种简单粗暴的方法，‘在程序里写死’的这种方式让事情变得更简单。&lt;/p&gt;

&lt;p&gt;‘在程序里写死’这种粗暴的方式最讲究周边工具了，Protocol Buffer就为很多种语言定制了生成序列化和反序列化程序代码的工具。只需要通过提供.proto文件就能生成相应语音的程序代码，在代码中把编号‘写死’，这一切代码都是自动生成的，我们只需要关心.proto文件中的结构。&lt;/p&gt;

&lt;p&gt;以就是说，当Protocol Buffer生成的解析代码在读数据的时候，一旦读取到编号为1的数据时，就把数据解析给 name 这个程序变量，这些都写死在代码中，而代码由Protocol Buffer工具生成。&lt;/p&gt;

&lt;h6&gt;我们使用上面提到的 AddressBook 数据结构来序列化一个 Protocol Buffer 数据。&lt;/h6&gt;

&lt;p&gt;加入数据的伪代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AddressBook&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address_book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address_book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add_people&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set_id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Jack&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set_email&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Jack@qq.com&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;PhoneNumber&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phone_number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_phones&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;phone_number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set_number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;123456&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;phone_number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;phone_number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add_phones&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;phone_number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set_number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;234567&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;phone_number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MOBILE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_weight_recent_months&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_weight_recent_months&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;52&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_weight_recent_months&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;54&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成出来的二进制数据流如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// (1 &amp;lt;&amp;lt; 3) + 2 = 0a，1为people的标签号,2为嵌入结构对应的类型号&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 0x3c = 60，表示接下来60个字节为Person的数据&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 下面进入到 repeated Person 数组的数据结构&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// (1 &amp;lt;&amp;lt; 3) + 2 = 0a，Person的第一个字段name的标签号为1，2为string(字符串)对应的类型号&lt;/span&gt;
&lt;span class=&quot;mo&quot;&gt;04&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// name字段的字符串长度为4&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;61&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;63&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// &amp;quot;Jack&amp;quot; 的ascii编码&lt;/span&gt;

&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// (2 &amp;lt;&amp;lt; 3) + 0 = 10，字段id的标签号为2，0为int32对应的类型号&lt;/span&gt;
&lt;span class=&quot;mo&quot;&gt;01&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// id的整型数据为1&lt;/span&gt;

&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// (3 &amp;lt;&amp;lt; 3) + 2 = 1a，字段email的标签号为3，2为string对应的类型号&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 0x0b = 11 email字段的字符串长度为11&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;61&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;63&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;71&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;71&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;63&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;6f&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;6d&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// &amp;quot;Jack@qq.com&amp;quot;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//第1个PhoneNumber，嵌套message&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// (4 &amp;lt;&amp;lt; 3) + 2 = 22，phones字段，标签号为4，2为嵌套结构对应的类型号&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 0a = 10，接下来10个字节为PhoneNumber的数据&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// (1 &amp;lt;&amp;lt; 3) + 2 =  0a, PhoneNumber的number，标签号为1，2为string对应的类型号&lt;/span&gt;
    &lt;span class=&quot;mo&quot;&gt;06&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// number字段的字符串长度为6&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;33&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;34&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;35&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;36&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// &amp;quot;123456&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// (2 &amp;lt;&amp;lt; 3) + 0 = 10，PhoneType type字段，0为enum对应的类型号&lt;/span&gt;
    &lt;span class=&quot;mo&quot;&gt;01&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// HOME，enum被视为整数&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 第2个PhoneNumber，嵌套message&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;06&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;33&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;34&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;35&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;36&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;37&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;00&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//信息解读同上，最后的00为MOBILE&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;06&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 1010 0010 0000 0110 varint方式，weight_recent_months的key&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//  010 0010  000 0110 → 000 0110 0100 010 little-endian存储&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// (100 &amp;lt;&amp;lt; 3) + 2 = a2 06，100为weight_recent_months的标签号&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//  2为 packed repeated field的类型号&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 0c = 12，后面12个字节为float的数据，每4个字节一个数据&lt;/span&gt;
&lt;span class=&quot;mo&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;48&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// float 50&lt;/span&gt;
&lt;span class=&quot;mo&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// float 52&lt;/span&gt;
&lt;span class=&quot;mo&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;58&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// float 54&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整个数据看下来都是遵循了简单的规则，即，标签号 + 类型号，最为头部标识，数据大小标识，作为可选标识，最后放入具体数据：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;标签号 + 类型号|数据大小|具体数据
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体数据中再嵌套不同种类的数据，也同样遵循 ‘标签号 + 类型号|数据大小|具体数据’ 这样的规则。&lt;/p&gt;

&lt;h6&gt;二进制数据流中反序列化为程序对象数据，我们重点看看其中 Person 结构的反序列过程：&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MergeFrom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CodedInputStream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ReadTag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_unknownFields&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UnknownFieldSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MergeFieldFrom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_unknownFields&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ReadString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ReadInt32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;email&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ReadString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;phones_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;AddEntriesFrom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_repeated_phones_codec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;weight_recent_months_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;AddEntriesFrom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_repeated_weight_recent_months_codec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上述Protocol Buffer生成的代码我们了解到，所有的对象变量都通过.proto文件中的标签号来识别数据是否与该变量有映射关系的，当拿到具体数据时，先判定属于哪个变量，再针对该变量的类型读取数据。&lt;/p&gt;

&lt;h6&gt;Protocol Buffer 不同版本消息的兼容问题&lt;/h6&gt;

&lt;p&gt;在实际的开发中会存在这样一种应用场景，即消息格式因为某些需求的变化而不得不进行必要的修改或者说升级，但是有些使用原有消息格式的应用程序暂时又不能被立刻升级，这便要求我们在升级消息格式时要遵守一定的规则，从而可以保证基于新老消息格式的新老程序能够同时运行。规则如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不要修改已经存在字段的标签号，即变量后面的数字，保证旧数据协议能够继续从数据中读取指定标签号的正确数据。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;任何新添加的字段必须是optional和repeated限定符，保证在旧数据无法加入新数据的情况下，新的协议还能够在旧数据协议之下继续顺利解析，否则无法保证新老程序在互相传递消息时的消息兼容性。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在原有的消息中，不能移除已经存在的required字段，虽然optional和repeated类型的字段可以被移除，但是他们之前使用的标签号必须被保留，不能被新的字段重用。因为旧协议在执行时还是会在旧的标签号中加入自己的数据，新协议如果使用了旧的标签号，就会导致新旧协议数据解析错误的问题。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;int32、uint32、int64、uint64和bool等类型之间是兼容的，sint32和sint64是兼容的，string和bytes是兼容的，fixed32和sfixed32，以及fixed64和sfixed64之间是兼容的，这意味着如果想修改原有字段的类型时，为了保证兼容性，只能将其修改为与其原有类型兼容的类型，否则就将打破新老消息格式的兼容性。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h6&gt;Protocol Buffer 的优点&lt;/h6&gt;

&lt;p&gt;Protobuf 全程使用二进制流形式，用整数代替了KEY来映射变量，比 XML、Json、MessagePack它们更小、更快、也更简单。&lt;/p&gt;

&lt;p&gt;我们可以定义自己的数据结构，然后使用Protobuf代码生成器生成的代码来读写这个数据结构。甚至可以在无需重新部署程序的情况下更新数据结构。只需使用 Protobuf 对数据结构进行一次描述，即可利用各种不同语言或从各种不同数据流中对你的结构化数据轻松读写。&lt;/p&gt;

&lt;p&gt;使用 Protobuf 无需学习复杂的文档对象模型，Protobuf 的编程模式比较友好，简单易学，同时它拥有良好的文档和示例，对于喜欢简单事物的人们而言，Protobuf 比其他的技术更加有吸引力。&lt;/p&gt;

&lt;p&gt;Protobuf 语义更清晰，无需类似 XML，JSON 解析器的东西，简化了解析的操作，减少了解析的消耗。&lt;/p&gt;

&lt;p&gt;Protobuf 数据使用二进制形式，把原来在JSON,XML里用字符串存储的数字换成用byte存储，大量减少了浪费的存储空间。与MessagePack相比，Protobuf减少了Key的存储空间，让原本用字符串来表达Key的方式换成了用整数表达，不但减少了存储空间也加快了反序列化的速度。&lt;/p&gt;

&lt;h6&gt;Protocol Buffer 的不足&lt;/h6&gt;

&lt;p&gt;Protbuf 与 XML 相比也有不足之处。它功能简单无法用来表示复杂的概念。&lt;/p&gt;

&lt;p&gt;XML 已经成为多种行业标准的编写工具，Protobuf 只是运用在数据传输与存储上，在通用性上还差很多。&lt;/p&gt;

&lt;p&gt;由于 XML 具有某种程度上的自解释性，它可以被人直接读取编辑，在这一点上 Protobuf 不行，它以二进制的方式存储，除非你有 .proto 定义，否则你没法直接读出 Protobuf 的任何内容。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;p&gt;《Protocol Buffers：阅读一个二进制文件》&lt;/p&gt;
</description>
               <pubDate>Sun, 16 Jun 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/06/16/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%825.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/06/16/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%825.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第六章，网络层(四) - 封装HTTP</title>
               <description>&lt;h3&gt;HTTP协议原理&lt;/h3&gt;

&lt;p&gt;HTTP俗称短连接，由于其连接的时间较短，不受前端所控制，所以在互联网开发圈内，通常被以‘短’字开头。&lt;/p&gt;

&lt;p&gt;在Unity3D短连接可以用.NET库来编写，也可以用U3D的内置API的WWW来写。差别不是很大，WWW对.Net做了封装，其功能已经完全够用在游戏开发上了，即使有情况不够用再用.NET补充也是很容易的事。(WWW在2018及以后的版本中都被废弃了，取代它的是UnityWebRequest，应该说封装的更好，但自定义部分则被削弱了。)&lt;/p&gt;

&lt;p&gt;其两者的区别主要还是WWW把.NET库封装后再加了层用协程使得我们开发者在使用时更加的便捷，.NET库则直接用了线程，导致开发者还需要关注主线程与子线程的资源锁。另外WWW里面已经实现了IP6转换，而使用.Net库则还需要自己解析IP6地址，虽然对程序员来说自己用.NET实现更加接近底层实现，但同时也带来了更多需要花精力关注的地方，夺走了程序员些许宝贵的精力。&lt;/p&gt;

&lt;p&gt;不管协程还是线程，其实两边都需要缓存和队列，如果没有缓存和队列，当网络请求量放大时就会出现数据丢失的情况。所以缓存机制在网络层是不可或缺的。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;我们所说的HTTP，最形象的描述就是网页(Web)形式的请求与回调。它被运用在最多的就是网页(Web)请求上，它是网页(Web) 上进行数据交换的基础。&lt;/p&gt;

&lt;p&gt;HTTP是一种 请求/响应式 的协议。也就是说，请求通常是由像浏览器这样的User-
Agent发起的，当像浏览器接收方收到数据后，再通过数据来处理相应的逻辑，每个请求都是一一对应的，一个请求有且最多只能得到一个响应。&lt;/p&gt;

&lt;p&gt;当我们要要展现一个网页时，浏览器首先发送一个请求，目的是从服务器获取页面的HTML文档，再解析文档中的资源信息然后才发送其他请求，例如获取可执行脚本或CSS样式来进行页面布局渲染，以及一些其它页面资源（如图片和视频等）。&lt;/p&gt;

&lt;p&gt;浏览器将这些资源整合到一起，展现出一个完整的网页。浏览器执行的脚本可以在之后的阶段发起更多的请求来获取更多信息和资源，从而可以不断的叠加、更新到当前的网页内容上来。&lt;/p&gt;

&lt;p&gt;我们常常会在游戏项目中把这套 请求/响应式 协议搬到了游戏中运用，那么为什么要用HTTP呢，用HTTP有什么好处呢？&lt;/p&gt;

&lt;p&gt;其最重要的原因是HTTP简单易用，上手成本低，功能扩展难度低，因此被广大互联网程序员所喜爱。&lt;/p&gt;

&lt;p&gt;HTTP是应用层上的协议，它并不需要其底层的传输层协议是面向连接的，只需要它是可靠的，或不丢失消息的（至少返回错误）。因此，HTTP依赖于面向连接的TCP进行消息传递，但HTTP本身对连接的需求并不是必须的，也就是说它本身是无状态的。&lt;/p&gt;

&lt;p&gt;HTTP本身并没有检测是否连接，数据是否传输准确，是否有数据到达等的机制，而是依赖于TCP协议，由TCP协议来做这些传输层的事情。HTTP在TCP之上，制定了自己的规则。&lt;/p&gt;

&lt;p&gt;HTTP在TCP之上制定了自己的规则：&lt;/p&gt;

&lt;p&gt;1.HTTP有自己的协议，HEADS和BODY&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    GET /root1/module?name1=value1&amp;amp;name2=value2 HTTP/1.1
    Host: localhost:8080
    Accept-Language: fr
    //这里HEADS 和 BODY一定是用空行隔开的
    body content
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 GET为方式，HTTP有很多种方式，其中GET和POST最为常用。GET方式是把参数值放在地址中，而POST则是把参数值放在协议数据包中，并且POST可以使用二进制作为参数值，而GET则不能。其两者的实质是一样的，都是以Key1=Value1&amp;amp;Key2=Value2的形式作为请求内容，他们两请求的参数都会被写入请求包体中。&lt;/p&gt;

&lt;p&gt;其协议中 HTTP/1.1为HTTP协议的版本号，我们现在常用的协议为1.1，也有少部分还在使用1.0。HTTP1.1兼容了1.0，并且在1.0之上改进了诸多内容，比如同一个地址不同host，增加了cache特性，增加Chunked transfer-coding标志切割数据块等。而2.0由于和1.1差别太大，不能兼容1.0和1.1，因此世界被分成了两块，HTTP2.0主要运用在HTTPS上，而HTTP1.1和1.0则运行在原有的HTTP上。&lt;/p&gt;

&lt;p&gt;body content是主要存储请求内容的，POST内容都放在这里。&lt;/p&gt;

&lt;p&gt;服务器收到请求处理相应逻辑后发送响应数据，其数据格式为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    HTTP/1.1 200
    Date:Mon,31Dec200104:25:57GMT
    Server:Apache/1.3.14(Unix)
    Content-type:text/html
    Last-modified:Tue,17Apr200106:46:28GMT
    Content-length:xxx

    //这里HEADS 和 BODY一定是用空行隔开的
    body content
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中200为响应后代表请求成功的错误码，其他常用的错误码可以简单理解为 404 找不到请求页，500 服务器程序报错，400 访问请求参数错误，403 被拒绝访问。&lt;/p&gt;

&lt;p&gt;2.HTTP是无状态但有会话的，两个执行成功的请求之间是没有关系的。&lt;/p&gt;

&lt;p&gt;无状态，是指对于事务处理没有记忆能力，前后两次的请求并没有任何相关性，可以是不同的连接，也可以是不同的客户端，服务器在处理无状态请求时，只关注当下这个连接请求时的可获取到的数据，不会去关心也没有记忆去关联上一次请求的状态。&lt;/p&gt;

&lt;p&gt;HTTP的访问请求一般都由软硬件做负载均衡来决定访问哪台物理服务器，进而两次同样地址的访问请求，有可能选择的服务器是不同的。&lt;/p&gt;

&lt;p&gt;无状态很好的匹配了这种近乎随机的访问方式，也就是说HTTP客户端可以任意选择一个部署在不同区域的服务器进行访问，得到的结果是相同的。&lt;/p&gt;

&lt;p&gt;3.HTTP每次请求访问结束会断开连接。&lt;/p&gt;

&lt;p&gt;HTTP是依据什么来断开连接的呢？content-length。&lt;/p&gt;

&lt;p&gt;content-length为 heads 上的标记，表示 body 内容长度。&lt;/p&gt;

&lt;p&gt;带content-length，body长度是可知的，客户端在接收body内容时，就可以依据这个长度来接受数据。接受完毕后，就表示这个请求完毕了。客户端主动调用close进入四次挥手断开连接。&lt;/p&gt;

&lt;p&gt;假如没有content-length 标记，那么body内容长度是不可知的，客户端会一直接受数据，直到服务端主动断开。&lt;/p&gt;

&lt;p&gt;HTTP1.1在这个断开规则之上又扩展了一种新规则，即增加了Transfer-encoding标记。如果Transfer-encoding为chunked，则表示body是流式输出，body会被分成多个块，每块的开始会标识出当前块的长度，此时body不需要通过content-length长度来指定了。&lt;/p&gt;

&lt;p&gt;HEADS上带有Transfer-encoding:chunked 就表示body被分成很多块，每块的长度也是可知的，当客户端根据长度接受完毕数据后，就会主动断开连接。&lt;/p&gt;

&lt;p&gt;假如说Transfer-encoding 和 content-length 这两个标记都没有，那么就只能一直接受数据直到服务器主动断开连接。&lt;/p&gt;

&lt;p&gt;那么有没有一种可能，既想使用HTTP协议又不想断开连接的？&lt;/p&gt;

&lt;p&gt;使用keep-alive标识，keep-alive标识会让客户端与服务器的连接保持状态，直到服务器发现空闲时间结束而断开连接，在结束时间内我们仍然能发送数据。也在就是说，可以减少多次的与服务器3次握手建立连接，以及多次与服务器4次握手断开连接，提高了传输效率。&lt;/p&gt;

&lt;p&gt;而在服务器端上，Nginx的 keepalive&lt;em&gt;timeout，和Apache的 KeepAliveTimeout 都能设置 Keep-alive 的空闲时间大小，当httpd守护进程发送完一个响应后，理应马上主动关闭相应的TCP连接，但设置 keepalive&lt;/em&gt;timeout后，httpd守护进程会说：”再等等吧，看看客户端还有没有请求过来”，这一等，便是 keepalive_timeout时间。如果守护进程在这个等待的时间里，一直没有收到客户端发过来HTTP请求，则关闭这个HTTP连接。&lt;/p&gt;

&lt;p&gt;但也不一定说使用keep-alive标识能提高效率，有时也会反而降低了效率。比如经常会没有数据需要发送，导致长时间的Tcp连接保持导致系统资源无效占用，浪费系统资源，巨量的保持连接会浪费巨量的资源。&lt;/p&gt;

&lt;p&gt;如果客户端使用keep-alive，则需要在连续发送数据时，使用同一个HTTP连接实例。并且在发送完毕后要记录空闲时间，以便再次发送时，可以判断是否继续使用该连接，因为通常服务器端主动断开连接后并没有被客户端及时的得知，所以自行判断是否有可能已经被服务器端断开连接为好。还有一个问题是，如果网络环境不好导致发送请求无法到达时，则要尽可能的自己记录和判断，哪些数据是需要重发的。这几个问题增加了HTTP作为keep-alive来保持连接的操作难度，将本来简单便捷的HTTP，推向了有点长连接的味道。&lt;/p&gt;

&lt;h6&gt;在Unity3D中的HTTP封装&lt;/h6&gt;

&lt;p&gt;Unity3D的2018版本中原本经常用的WWW类已经被废弃，取而代之的是UnityWebRequest。&lt;/p&gt;

&lt;p&gt;API改了但功能都是一样的，我们主要还是围绕HTTP的原理来写程序，也只有这样才能真正写出程序的精髓。&lt;/p&gt;

&lt;p&gt;UnityWebRequest里有几个接口对我们来说比较重要，一个是Post(string uri, WWWForm postData)接口用来创建一个带有地址和Post数据的UnityWebRequest实例，一个是SendWebRequest()用来开始发送请求和迭代请求的接口，另一个是SetRequestHeader(string name, string value)用来设置HTTP头的，其中它说下面这些HEAD标记不支持设置：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    These headers cannot be set with custom values on any platform: accept-charset, access-control-request-headers, access-control-request-method, connection, date, dnt, expect, host, keep-alive, origin, referer, te, trailer, transfer-encoding, upgrade, via.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些标记都是什么意思呢，&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    accept-charset: 用于告诉服务器，客户机采用的编码格式

    access-control-request-headers: 在预检请求中，用于通知服务器在真正的请求中会采用哪些请求首部

    access-control-request-method: 在预检请求中，用于通知服务器在真正的请求中会采用哪种 HTTP 方法

    connection: 处理完这次请求后是否断开连接还是继续保持连接

    date: 当前时间值

    dnt:  (Do Not Track) 表明了用户对于网站追踪的偏好。

    expect: 是一个请求消息头，包含一个期望条件，表示服务器只有在满足此期望条件的情况下才能妥善地处理请求。服务器开始检查请求消息头，可能会返回一个状态码为 100 (Continue) 的回复来告知客户端继续发送消息体，也可能会返回一个状态码为417 (Expectation Failed) 的回复来告知对方要求不能得到满足。

    host: 请求头指明了服务器的域名(对于虚拟主机来说)，以及服务器监听的TCP端口号。

    keep-alive: 允许消息发送者暗示连接的状态，还可以用来设置超时时长和最大请求数。

    origin: 指示了此次请求发起者来自于哪个站点。

    referer: 表示当前页面是通过此来源页面里的链接进入的，与origin相似。

    te: 指定用户代理希望使用的传输编码类型

    trailer: 允许发送方在分块发送的消息后面添加额外的元信息，这些元信息可能是随着消息主体的发送动态生成的，比如消息的完整性校验，消息的数字签名，或者消息经过处理之后的最终状态等。

    transfer-encoding: 指明了将 entity 安全传递给用户所采用的编码形式。transfer-encoding是一个逐跳传输消息首部，即仅应用于两个节点之间的消息传递，而不是所请求的资源本身。一个多节点连接中的每一段都可以应用不同的Transfer-Encoding 值。

    upgrade: 升级为其他协议

    via: 代理服务器相关的信息
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上这些由HEAD扩展的HTTP功能都不能进行自主的选择，其中包括了我们比较关心的标识 connection 和 keep-alive 保持连接的功能，代表了我们无法用UnityWebRequest来实现一次连接发送多次数据的需求。&lt;/p&gt;

&lt;p&gt;另外我们最关心的content-length也不能被自定义设置，而是由API本身来自动设置。&lt;/p&gt;

&lt;p&gt;与原来WWWW的API不同的是，UnityWebRequest更加简洁方便，但也失去了一些自定义的功能。接下来我们来使用UnityWebRequest封装HTTP网络层。&lt;/p&gt;

&lt;p&gt;我们必须设计一个类，比如建个名称为HTTPRequest的类，每次请求服务器都调用这个类的方法来处理一个请求的操作。把地址，参数，回调传进去，等待服务器相应和回调。&lt;/p&gt;

&lt;p&gt;短连接接口相对较少，其中POST,GET,HEAD,Start，这几个接口最为关键。在UnityWebRequest中对应的是&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    POST: UnityWebRequest UnityWebRequest.Post(string uri, WWWForm postData) (静态函数)

    GET: UnityWebRequest UnityWebRequest.Get(string uri) (静态函数)

    HEAD: UnityWebRequest.SetRequestHeader(string name, string value) (非静态函数)

    Start: UnityWebRequest.SendWebRequest() (非静态函数)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用这四个API就能实现HTTP基本的发送与接收。&lt;/p&gt;

&lt;p&gt;在调用UnityWebRequest发送请求时可以用协程也可以在逻辑更新中进行判断收发过程。&lt;/p&gt;

&lt;p&gt;不过在协程中不太可控，并且每次都起一个携程来发送数据也浪费资源，并且协程结束时随着函数调用结束而结束的，而我们时常会有需要暂停，继续等操作。所以一般都会把HTTP的收发判断移到逻辑更新中的Update里去，这样做更容易理解，也更容易掌控。&lt;/p&gt;

&lt;p&gt;下面我们建立一个类来封装UnityWebRequest的收发过程：&lt;/p&gt;

&lt;p&gt;1.建立实例开始连接和发送请求，设置好这次请求回应的回调句柄。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    void StartRequest(string url, Callback _callback)
    {
        this.web_request = UnityWebRequest.Get(url);
        this.Callback =  _callback;
        this.web_request.SendWebRequest();
    }

    or POST

    void StartRequest(string url, WWWForm wwwform, Callback _callback)
    {
        this.web_request = UnityWebRequest.POST(url, wwwform);
        this.Callback =  _callback;
        this.web_request.SendWebRequest();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.判断是否完成或者说发送请求是否完毕,并且调用回调函数&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    void Update()
    {
        if(web_request != null)
        {
            if(web_request.isDone)
            {
                ProcessResponse(web_request);
                web_request.Dispose();
                web_request = null;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.处理数据，先判断有错误存在，如果没有错误则对数据进行处理，HTTP回应的数据格式比较多，比如Json格式的，Xml格式等等。对数据进行解析后变为具体的类实例，再传给相应的函数句柄进行调用。所以这里数据格式协议也是关键。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    void ProcessResponse(UnityWebRequest _WebRequest)
    {
        if(_WebRequest.error != null)
        {
            NetworkErrorReport(_www.error);
            return;
        }
        CallbackResponse(_WebRequest.downloadHandler.text);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上是用UnityWebRequest做HTTP请求的基本步骤。在具体项目中看似简单的连接，发送，接收过程中也有不少事情需要我们做。特别是游戏逻辑中，大量多次，频繁发送HTTP请求的问题的延伸和提出的解决方案。&lt;/p&gt;

&lt;p&gt;多次或者连续发送HTTP请求引起的问题&lt;/p&gt;

&lt;p&gt;多次或者连续请求HTTP在具体项目中比价常见，比如客户端向服务器请求角色信息，并且请求军团信息，并且请求每日任务信息，然后再显示主界面。&lt;/p&gt;

&lt;p&gt;这种连续的多次的请求HTTP，会同时触发多个线程向服务器做请求操作，建立连接，发送请求，关闭连接，而得到服务器返回时，却不知道哪个在先哪个在后，例如军团信息有可能先得到响应，然后再是每日任务信息得到了响应，再是角色信息得到了响应，因为是多个线程发起的多个连接，服务端接受到的数据也是没有顺序的，即使服务器端接受的顺序刚好没有打乱顺序，在处理和回调的时机也是不可知的，导致回调的顺序不可知，所以并不能确定响应的顺序与请求的顺序是一样的。&lt;/p&gt;

&lt;p&gt;当接受数据的顺序无法确定时，如果还用顺序接受数据的方式处理出具则有风险，比如我们在发送，军团，任务，角色数据请求后，希望能够在三者都到齐的情况下执行某个程序逻辑，如果得到的数据是顺序的，则我们可以确定在收到角色数据后表明所有的数据都到齐了，于是我们再执行逻辑程序。&lt;/p&gt;

&lt;h6&gt;解决方案1：多开线程发送请求数据，等待所有数据到齐再调用执行逻辑。&lt;/h6&gt;

&lt;p&gt;每个HTTP(也可以认为是UnityWebRequest)请求都会开一个线程来向服务器请求数据，多个HTTP请求同时开启，相当于多个线程同时工作提高了网络效率。&lt;/p&gt;

&lt;p&gt;我们可以用HTTP这种开线程的方式做，当需要多个请求的回应数据时，开启多个HTTP请求，等到数据全部得到相应后再处理逻辑。&lt;/p&gt;

&lt;p&gt;这里有一个限制，我们需要假设多次请求之间没有且不需要逻辑顺序，则可以使用同时发起多次HTTP请求，并且等待所有请求结束后再做逻辑处理。&lt;/p&gt;

&lt;p&gt;多次请求的响应数据的需求问题，其本质是‘如何判断我们需要的多条数据是否已经都到达’。&lt;/p&gt;

&lt;p&gt;为了能更快的，更高效的得到HTTP请求数据，在同一时间同时向服务器发起多个HTTP请求，并且等待所有请求都得到响应后才执行逻辑程序，即等待并辨认多次请求是否全数收到。&lt;/p&gt;

&lt;p&gt;在Unity3D上伪代码及注释如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    class multiple_request
    {
        void StartRequest( request_list, call_back )
        {
            lst_req = new List&amp;lt;UnityWebRequest&amp;gt;();
            for( url,wwwform in request_list )
            {
                //开启多个HTTP请求
                UnityWebRequest req = UnityWebRequest.Post(url, wwwform);
                req.SendWebRequest();

                //记录请求实例
                lst_req.Add(req);
            }

            //记录回调函数
            Callback = call_back;
        }

        void Update()
        {
            if(lst_req == null || lst_req.Count &amp;lt;= 0) return;

            for( UnityWebRequest req in lst_req)
            {
                //判断是否完成该请求，只要有一个没完成就继续等待
                if(!req.isDone)
                {
                    return;
                }
            }

            //当全部请求都完成时，执行回调
            Callback(lst_req);

            //请求结束并清空
            lst_req.Clear();
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方式同时开启多个HTTP连接来向服务器请求数据，极大程度地加速了数据的响应速度，最大限度的提高了服务器端的CPU利用率，但请求彼此之间必须没有顺序关系，只有这样服务器端的执行顺序才无序担心。&lt;/p&gt;

&lt;p&gt;如果请求之间是有顺序要求的，服务器端执行顺序无法保障则容易出现逻辑顺序问题，比如会有多个这样的请求，购买物品，出售物品，使用物品，三个请求一起被发起，服务器接受到的请求顺序有可能是，使用物品，出售物品，再购买物品，当顺序不同时就有可能存在逻辑问题，与我们原本设想的逻辑存在偏差，物品可能先被使用或出售，而不是被先购买，导致没有物品可被使用或出售，跟我们的所预期不一致。&lt;/p&gt;

&lt;p&gt;提高了网络效率，服务器的CPU利用率，却无法保证预期的逻辑顺序，在需要顺序的功能上必出现诸多错误。&lt;/p&gt;

&lt;p&gt;因此这种解决方案在需要逻辑顺序的连接请求上无法运作，但在不需要逻辑顺的连接请求上可以极大的提高网络连接利用率。&lt;/p&gt;

&lt;h6&gt;解决方案2：逐个发起请求，保证顺序。&lt;/h6&gt;

&lt;p&gt;逐个发送请求的方式最常见也比较普遍的做法，在网页端，安卓原生端，苹果原生端都使用这种方式来做请求，即每次只处理一个请求，当这个请求结束后再发起下一个请求，即一个请求对应一个功能模块，结束当前功能模块后再发起下一个请求。&lt;/p&gt;

&lt;p&gt;例如前面所描述的例子，请求角色信息，并且请求军团信息，并且请求每日任务信息，每次只做一件事，收到角色信息数据后，再发起请求军团信息，收到军团信息后，再发起请求任务信息，收到任务信息后再显示在界面，每个请求都会被动态的分配一个回调函数，当某个请求的数据需要做别的事情的时候，就分配一个不同回调函数。&lt;/p&gt;

&lt;p&gt;也就是说，当请求角色信息前，我们可以分配一个自定义句柄，当接受到数据后，回调执行这个自定义句柄。在自定义句柄里，可以继续发送我们需要请求的数据或功能，或者执行其他逻辑。&lt;/p&gt;

&lt;p&gt;伪代码为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    void on_button_click()
    {
        //请求角色数据
        function_request_roleinfo( callback_function1 ) 
    }

    void callback_function1( data )
    {
        //记录角色信息
        role_info.Add(data);

        //请求军团信息
        function_request_groupinfo( callback_function2 )
    }

    void callback_function2( data )
    {
        //记录军团信息
        group_info.Add( data );

        //请求任务信息
        function_request_task( callback_funciton3 );
    }

    void callback_function3( data )
    {
        //记录任务信息
        task_info.Add( data);

        //展示UI
        show_ui();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;伪代码展示了发送请求的逻辑顺序，这种逐个发送请求的方式，保证了逻辑顺序，同时也满足了对多样化功能的扩展，同一个请求可以在不同逻辑处拥有自己的自定义回调。&lt;/p&gt;

&lt;p&gt;单个连接的自定义方式确实保证了顺序，但也降低了网络连接效率，多个请求需要发起多个TPC连接，每个连接都需要等待上一个连接请求完毕后才能开始下一个请求，每次收到消息后都需要发起4次握手的断开连接‘仪式’，每次发起请求时又必须进行3次握手的建立连接‘仪式’，消耗网络连接资源降低了收发效率。&lt;/p&gt;

&lt;p&gt;另一种逐个发送请求的方式，为了保证请求的顺序进行，可以使用发送队列和接收队列来做逐个发送的模式。&lt;/p&gt;

&lt;p&gt;队列在请求和响应中起到了缓冲的作用，当连续使用HTTP请求，连续收到HTTP响应的时候，能够依次处理相应的逻辑。&lt;/p&gt;

&lt;p&gt;因为全程是只有1个线程在做请求处理，所以并不需要线程锁之类的操作。发送时，向队列推送请求实例。在逻辑更新上，判断是否有请求在队列里，有的话推出来，做HTTP请求操作，并将请求的相关信息存起来，当得到服务器响应时，调用请求信息中的回调函数，处理回调句柄。&lt;/p&gt;

&lt;p&gt;发送和接收队列的伪代码:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    //将请求推入队列
    void RequestHttp(Request req)
    {
        ListRequest.Push(req);
    }

    //逻辑更新
    void Update()
    {
        //是否完成HTTP
        If( IsHttpFinished() )
        {
            //开始新的请求
            Request  req = ListRequest.Pop();
            mCurrentRequest = req;
            StartHttpRequest(req);
        }
        else
        {
            //是否收到响应
            If(HttpIsDone())
            {
                //根据响应数据处理逻辑
                ProcessResponse(data);

                //完成HTTP
                FinishHttp();
            }
        }
    }

    //根据数据处理逻辑
    void ProcessResponse(Response data)
    {
        If(mCurrentRequest != null
            &amp;amp;&amp;amp; mCurrentRequest.Callback != null)
        {
            //回调句柄
            mCurrentRequest.Callback(data);
            mCurrentRequest = null;
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上阐述了，在发送HTTP请求时的推入队列操作和在收到请求后的句柄响应操作，队列使我们做到了逐个请求以及逐个响应。&lt;/p&gt;

&lt;h6&gt;解决方案3：多连接与逐个发送，并行使用。&lt;/h6&gt;

&lt;p&gt;多连接提高网络请求效率但没有一致的响应顺序，逐个发送有一致的响应顺序网络请求效率则不够好。&lt;/p&gt;

&lt;p&gt;两者之间没有排斥关系，可以并行使用，既提高了网络请求效率，又保证了顺序。&lt;/p&gt;

&lt;p&gt;仍然使用前面解决方案1中的类 multiple&lt;em&gt;request ，原本 multiple&lt;/em&gt;request 类可以传入多个请求数据，并等待全部相应结束后再执行回调。然后再在 multiple_request 中回调中执行下一个请求。&lt;/p&gt;

&lt;p&gt;伪代码如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    //界面按钮
    void on_click()
    {
        //新建一个请求对象
        request1 = new request();
        request1.url = url1;
        request1.wwwform = new wwwform();
        request1.wwwform.AddField(&amp;quot;name1&amp;quot;,&amp;quot;value1&amp;quot;);

        //加入请求列表
        lst_request.Add(request1);

        //兴建一个请求对象
        request2 = new request();
        request2.url = url2;
        request2.wwwform = new wwwform();
        request2.wwwform.AddField(&amp;quot;name21&amp;quot;,&amp;quot;value21&amp;quot;);

        //加入请求列表
        lst_request.Add(request2);

        //新建一个请求对象
        request2 = new request();
        request2.url = url3;
        request2.wwwform = new wwwform();
        request2.wwwform.AddField(&amp;quot;name22&amp;quot;,&amp;quot;value22&amp;quot;);

        //加入请求列表
        lst_request.Add(request3);

        //新建多请求实例
        multiple_request req = new multiple_request();

        //开始多个请求对象开启HTTP请求
        req.StartRequest(lst_request, callback_function1);
    }

    void callback_fucntion1(lst_request)
    {
        //做些逻辑
        do_some_function(lst_request);

        //新建一个请求对象
        request1 = new request();
        request1.url = url1;
        request1.wwwform = new wwwform();
        request1.wwwform.AddField(&amp;quot;name1&amp;quot;,&amp;quot;value1&amp;quot;);

        //加入请求列表
        lst_request.Add(request1);

        //兴建一个请求对象
        request2 = new request();
        request2.url = url2;
        request2.wwwform = new wwwform();
        request2.wwwform.AddField(&amp;quot;name21&amp;quot;,&amp;quot;value21&amp;quot;);

        //新建多请求实例
        multiple_request req = new multiple_request();

        //开始多个请求对象开启HTTP请求
        req.StartRequest(lst_request, callback_function2);
    }

    void callback_function2(lst_request)
    {
        //将信息展示到UI
        show_ui(lst_request);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;伪代码中展示了如何多请求与逐个请求的并行使用，将多个请求看成一个请求的变体，将多个请求看成一个完整的功能块，就有了多请求与逐个请求的并行使用过程。&lt;/p&gt;

&lt;p&gt;伪代码中展示的编码过程太过繁琐，展示出每一步的编码是为了让读者能更容易理解，多请求连接与逐个请求并行使用的理念。&lt;/p&gt;

&lt;p&gt;在现实项目中，完全可以为每个网络功能新建一个类，继承 multiple_request 类，并且将所有参数写进子类中，一并发送，并且可以多次使用在多个地方。&lt;/p&gt;

&lt;p&gt;伪代码:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    //新建个父类继承 multiple_request 专门用来做某个功能，这个功能里需要请求多条数据
    class do_something : multiple_request
    {
        void StartRequest( int val1 , int val2, int val3, call_back )
        {
            //新建一个请求对象
            request1 = new request();
            request1.url = url1;
            request1.wwwform = new wwwform();
            request1.wwwform.AddField(&amp;quot;name1&amp;quot;,&amp;quot;value1&amp;quot;);

            //加入请求列表
            request_list.Add(request1);

            //兴建一个请求对象
            request2 = new request();
            request2.url = url2;
            request2.wwwform = new wwwform();
            request2.wwwform.AddField(&amp;quot;name21&amp;quot;,&amp;quot;value21&amp;quot;);

            //加入请求列表
            request_list.Add(request2);

            //新建一个请求对象
            request2 = new request();
            request2.url = url3;
            request2.wwwform = new wwwform();
            request2.wwwform.AddField(&amp;quot;name22&amp;quot;,&amp;quot;value22&amp;quot;);

            base.StartRequest(request_list, call_back);
        }
    }

    //ui上的按钮
    void on_click()
    {
        //实例化功能对象
        do_something = new do_something();

        //开始请求
        do_something.StartRequest(1,2,3, call_back_function1);
    }

    //回调1
    void call_back_function1(lst_request)
    {
        //做点事
        do_something(lst_requset);

        //实例化功能2的对象
        do_something2 = do_something2();

        //开始请求
        do_something2.StartRequest(3,2, call_back_function2);
    }

    //回调2
    void call_back_function2(lst_request)
    {
        //展示UI
        show_ui(lst_request);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上所描述的，在实际项目中可以用子类继承父类功能的方法，复用了请求的步骤，使得需要某个功能时使用起来更加便捷。&lt;/p&gt;

&lt;h6&gt;解决方案4：合并请求，并逐个发送合并后的请求包。&lt;/h6&gt;

&lt;p&gt;多个请求与逐一发送合并的解决方案，确实既提高了发送效率，又保证了顺序，但还是有几个缺点。&lt;/p&gt;

&lt;p&gt;缺点1，多开连接，连接数增多，服务器建立和断开连接的压力增大。&lt;/p&gt;

&lt;p&gt;缺点2，使用操作不方便，必须手动建立新功能类。&lt;/p&gt;

&lt;p&gt;缺点3，多功能间的顺序，必须手动排列顺序。&lt;/p&gt;

&lt;p&gt;客户端更希望的是多次请求能够被同时发出，收到的响应顺序也要按原来请求的顺序响应，并且要可以自定义回调句柄满足多样化的功能扩展。&lt;/p&gt;

&lt;p&gt;合并请求就成了更好的解决方案。合并多个请求的数据进一个请求中，再发起请求，一次打包多个请求，只发一次能全部响应回来，发送这个合并包则可以做到与发起多个连接同样的效果，并且响应也可以做到顺序一致性。&lt;/p&gt;

&lt;p&gt;合并请求，减少了连接数量，提高了网络效率，同时也可以保证顺序的一致性。&lt;/p&gt;

&lt;p&gt;如何实现呢？&lt;/p&gt;

&lt;p&gt;这需要服务端程序员一些配合，服务端需要将原本多个地址，每个地址对应的功能块的模式，改为同一个地址，并且改为用commoand id 字段来对应不同的功能块。&lt;/p&gt;

&lt;p&gt;我们以json为例，HTTP数据使用json格式，服务器响应也是json格式。每次请求，客户端都会发送格式给服务器，服务器收到后解析json格式数据，然后提取变量。&lt;/p&gt;

&lt;p&gt;我们在对多个请求进行合并时，可以将多个json请求格式，推入一个大的json数据中，为每个json数据添加一个序列号，以代表请求顺序，如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    //请求1
    {
        &amp;quot;request-order&amp;quot; : 1,
        &amp;quot;command&amp;quot; : 1001,
        &amp;quot;data1&amp;quot; : &amp;quot;i am text&amp;quot;,
        &amp;quot;data2&amp;quot; : &amp;quot;i am num&amp;quot;,
    }

    //请求2
    {
        &amp;quot;request-order&amp;quot; : 2,
        &amp;quot;command&amp;quot; : 2011,
        &amp;quot;book&amp;quot; : &amp;quot;i am text&amp;quot;,
        &amp;quot;chat&amp;quot; : &amp;quot;i am num&amp;quot;,
        &amp;quot;level&amp;quot; : 1，
    }

    //请求3
    {
        &amp;quot;request-order&amp;quot; : 3,
        &amp;quot;command&amp;quot; : 3105,
        &amp;quot;image&amp;quot; : &amp;quot;i am text&amp;quot;,
        &amp;quot;doc&amp;quot; : &amp;quot;i am num&amp;quot;,
    }

    //将1，2，3合并后的请求数据为
    {
        &amp;quot;data&amp;quot;:
        [
            {
                &amp;quot;request-order&amp;quot; : 1,
                &amp;quot;command&amp;quot; : 1001,
                &amp;quot;data1&amp;quot; : &amp;quot;i am text&amp;quot;,
                &amp;quot;data2&amp;quot; : &amp;quot;i am num&amp;quot;,
            }
            ,
            {
                &amp;quot;request-order&amp;quot; : 2,
                &amp;quot;command&amp;quot; : 2011,
                &amp;quot;book&amp;quot; : &amp;quot;i am text&amp;quot;,
                &amp;quot;chat&amp;quot; : &amp;quot;i am num&amp;quot;,
                &amp;quot;level&amp;quot; : 1;
            }
            ,
            {
                &amp;quot;request-order&amp;quot; : 3,
                &amp;quot;command&amp;quot; : 3105,
                &amp;quot;image&amp;quot; : &amp;quot;i am text&amp;quot;,
                &amp;quot;doc&amp;quot; : &amp;quot;i am num&amp;quot;,
            }
        ],
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;合并后多个json被推入数组中发送给服务器，服务器拿到数据后对data中的数据进行提取和处理，处理顺序按照request-order来做，每个数据块都有一个command字段，用这个字段来判断使用哪个功能模块，将数据传给该功能模块处理。&lt;/p&gt;

&lt;p&gt;每个功能模块处理完毕后，将所有响应数据都推入同一个json实例中，并且附上与请求数据中相同的request-order，再把整个响应数据发送给客户端，当客户端收到数据时，就可以通过request-order知道响应数据的顺序了，按照request-order排序后，再进行解析和回调，得到了与请求顺序一致的响应顺序。&lt;/p&gt;

&lt;p&gt;合并响应后的例子如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    //响应数据1
    {
        &amp;quot;response-order&amp;quot; : 1,
        &amp;quot;command&amp;quot; : 1001,
        &amp;quot;data1&amp;quot; : &amp;quot;response text&amp;quot;,
        &amp;quot;data2&amp;quot; : &amp;quot;response num&amp;quot;,
        &amp;quot;error_code&amp;quot; : &amp;quot;0&amp;quot;, 
    }

    //响应数据2
    {
        &amp;quot;response-order&amp;quot; : 2,
        &amp;quot;command&amp;quot; : 2011,
        &amp;quot;data1&amp;quot; : &amp;quot;response text&amp;quot;,
        &amp;quot;data2&amp;quot; : &amp;quot;response num&amp;quot;,
        &amp;quot;error_code&amp;quot; : &amp;quot;1&amp;quot;,
    }

    //响应数据3
    {
        &amp;quot;response-order&amp;quot; : 3
        &amp;quot;command&amp;quot; : 3105,
        &amp;quot;data1&amp;quot; : &amp;quot;response text&amp;quot;,
        &amp;quot;data2&amp;quot; : &amp;quot;response num&amp;quot;,
        &amp;quot;error_code&amp;quot; : &amp;quot;2&amp;quot;,
    }

    //合并后的响应数据
    {
        &amp;quot;error_code&amp;quot; : 0,
        &amp;quot;data&amp;quot;:
        [
            {
                &amp;quot;response-order&amp;quot; : 1,
                &amp;quot;command&amp;quot; : 1001,
                &amp;quot;data1&amp;quot; : &amp;quot;response text&amp;quot;,
                &amp;quot;data2&amp;quot; : &amp;quot;response num&amp;quot;,
                &amp;quot;error_code&amp;quot; : &amp;quot;0&amp;quot;, 
            }
            ,
            {
                &amp;quot;response-order&amp;quot; : 2,
                &amp;quot;command&amp;quot; : 2011,
                &amp;quot;data1&amp;quot; : &amp;quot;response text&amp;quot;,
                &amp;quot;data2&amp;quot; : &amp;quot;response num&amp;quot;,
                &amp;quot;error_code&amp;quot; : &amp;quot;1&amp;quot;,
            }
            ,
            {
                &amp;quot;response-order&amp;quot; : 3
                &amp;quot;command&amp;quot; : 3105,
                &amp;quot;data1&amp;quot; : &amp;quot;response text&amp;quot;,
                &amp;quot;data2&amp;quot; : &amp;quot;response num&amp;quot;,
                &amp;quot;error_code&amp;quot; : &amp;quot;2&amp;quot;,
            }
        ]
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得到合并后的响应数据后，客户端要先提取data数据中的所有数据，以respose-order为基准进行排序，头部最小序号的先处理，解析，回调。&lt;/p&gt;

&lt;p&gt;不仅仅是合并，我们还要保证发送的顺序，多个合并请求一同发送则会遇到大麻烦，也就是顺序问题，所以需要用队列来规避。&lt;/p&gt;

&lt;p&gt;用了队列的方式保证请求的有序性，并且在队列之上进行操作请求合并，能更有效更便捷的进行合并。&lt;/p&gt;

&lt;p&gt;队列与合并结合的伪代码如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    //将请求推入队列
    void RequestHttp(Request req)
    {
        ListRequest.Push(req);
    }

    //逻辑更新
    void Update()
    {
        //是否完成HTTP
        If( IsHttpFinished() )
        {
            //推出多个请求进行合并
            lst_combine_req.Clear();
            for(int i = 0 ; i&amp;lt;10 ; i++)
            {
                Request  req = ListRequest.Pop();
                lst_combine_req.Add(req);
            }

            combine_request = CombineRequest(lst_combine_req);
            StartHttpRequest(req);
        }
        else
        {
            //是否收到响应
            If(HttpIsDone())
            {
                //排序
                sort(combine_request.lst_response);

                //循环处理每个响应逻辑
                for(int i = 0 ; i&amp;lt;combine_request.lst_response.count ; i++)
                {
                    //根据响应数据处理逻辑
                    data = combine_request.lst_response[i];
                    ProcessResponse(data);
                }

                //完成HTTP
                FinishHttp();
            }
        }
    }

    //根据数据处理逻辑
    void ProcessResponse(Response data)
    {
        If(mCurrentRequest != null
            &amp;amp;&amp;amp; mCurrentRequest.Callback != null)
        {
            //回调句柄
            mCurrentRequest.Callback(data);
            mCurrentRequest = null;
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体逻辑中的操作伪代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    //按钮事件
    void on_click()
    {
        //请求玩家数据
        request_roleinfo( call_back_function1 );

        //请求军团数据
        request_groupinfo( call_back_function2 );

        //请求任务数据
        request_taskinfo( call_back_function3 );
    }

    //先回调的是这个句柄
    void call_back_function1( data )
    {
        //保存玩家数据
        save_roleinfo(data);
    }

    //再回调的是这个句柄
    void call_back_function2( data )
    {
        //保存军团数据
        save_groupinfo(data);
    }

    //最后收到任务数据时，表明前面的数据都已经收到了，就可以做一些逻辑处理
    void call_back_function3( data )
    {
        //保存任务数据
        save_taskinfo(data);

        do_something();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述伪代码中表现了，客户端可以随意的发送请求而不需要去关心顺序的问题，大大提高了程序员的网络逻辑编程效率。&lt;/p&gt;

&lt;p&gt;对多个请求进行合并后减少HTTP请求的次数，对速度的提升很有效果，但这里还有一些细节问题，比如多少个开始进行合并，或者多少时间内合并一次。&lt;/p&gt;

&lt;p&gt;为了让HTTP最大效率的得到提升，必须每次请求得到响应后就应该立即进行下一次HTTP请求，如果有等待合并间隔，反而减低了网络效率。不过每次合并数量可以做一些限制，比如有1000个请求，我们不能统统合并了，为了保证发送数据大小和回调数据大小合适，也保证服务器不会为了一下子需要处理1000个数据请求而当机，我们必须限制一次性合并的个数，比如每次最多合并10个请求数据包，来保证减少连接次数减少的情况下，服务器不会在瞬间压力过大。&lt;/p&gt;
</description>
               <pubDate>Sun, 02 Jun 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/06/02/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%824.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/06/02/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%824.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第五章，3D模型与动画(四) - 3D模型的变与换4</title>
               <description>&lt;p&gt;前面讲解了些骨骼动画的基础知识，我们在基础知识上可以理解骨骼动画的原理。在骨骼原理之后，我们又对人物模型动画的换皮换装的原理了剖析一下，因为有了骨骼动画的基础知识支撑，我们在对换装换皮的方法和技巧上理解起来就更加的清晰了。&lt;/p&gt;

&lt;p&gt;其实看一遍是不够的，要看很多遍，而且要边想边看边实践，这样才有效果。要不怎么说理论这东西用处不够大呢，如果只有理论，那么这就是纸上谈兵，解决不了实际问题，反过来也是一样，只有实践则无法彻底了解原理和机制，我们就无法精进，总是觉得有什么东西被蒙在鼓里，运用起来不能得心应手。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h6&gt;有原理和又有实践，其实依然不行，还需要多思考多举一反三。要彻底理解一个知识点，真的难。在这条学习的道路上我们不能放弃，即使放弃了，也要想着什么时候能重新捡回来。人无完人，大家都一样，所有人都要经历失败，放弃，再重新捡起来，再失败，再放弃，再重新捡起来的过程，谁能更快的重新捡起来，就成了取胜的关键了，失败是必然的，就看谁能先重新站起来，再失败也是必然的，就看谁能一次次失败后还能站得住。&lt;/h6&gt;

&lt;p&gt;本篇我们要讲在骨骼动画原理之上，做些更高级的技巧，这些技巧都是基于上篇和上上篇的基础知识之上的。&lt;/p&gt;

&lt;p&gt;网格主要由顶点，三角形索引数组，uv这三个基础数据组成，也可以有顶点的法线和颜色数据。其中uv用于贴图，法线用于展示凹凸效果，顶点颜色则有其他多种用途。&lt;/p&gt;

&lt;p&gt;蒙皮骨骼动画，也就是SkinnedMeshRenderer，除了有这些网格数据外，又多了骨骼点和骨骼权重数据。骨骼点，是以父子或兄弟的关系相连的节点，它在Unity3D里的表象就相当于许多GameObject相互挂载并放在根节点下，除了这些看得见的GameObject节点外，骨骼点还需要旋转矩阵bindPoses，它主要是为了当父节点旋转移位时能更快的计算得到自身位移和旋转的结果矩阵，每个矩阵都是其父节点矩阵相乘所得到的结果。最后每个顶点都有自己的顶点数据，现在在顶点数据之上又多了些数据来表达被哪些骨骼的影响权重值，这就是顶点的骨骼权重数据。&lt;/p&gt;

&lt;p&gt;用最简洁的语言回顾了一下基础的知识。&lt;/p&gt;

&lt;h3&gt;6.捏脸&lt;/h3&gt;

&lt;p&gt;捏脸是一种行为方式，用以表达对对方的喜爱之情或对其某行为作出惩罚。网络游戏中泛指对虚拟角色样貌进行DIY的数据操作。&lt;/p&gt;

&lt;p&gt;捏脸看起来像是很复杂的技巧，在我们剖析一下后就会觉得也没有想象中的困难。&lt;/p&gt;

&lt;h6&gt;首先，捏脸最重要的部分就是换部位。&lt;/h6&gt;

&lt;p&gt;角色身上可以替换的部位有，不同形状的头，不同形状的上身，不同形状的腿，不同形状的脚，不同形状的手，其实还可以细分到更多，比如嘴，耳朵，胸，头发等，这些部件都可以从整体模型中拆分出来，单独成立一个模型，然后再选出来后拼装到整体模型上去。&lt;/p&gt;

&lt;p&gt;拆分出不同部位的模型，有了多个相同部位不同形状的模型后，我们就有了很多个模型部件可以替换，在捏脸时就可以选择不同的形状的部件。&lt;/p&gt;

&lt;p&gt;替换的过程其实就是上篇我们讲到的换装的过程，我们再来简单回顾下。&lt;/p&gt;

&lt;p&gt;我们必须所有模型都使用同一套骨骼，把骨骼以SkinnedMeshRenderer组件的方式实例化出来，我们暂时称它为‘根节点’，并挂上动画组件和动画文件，当播放动画时就可以看到骨骼会跟随每帧动画数据而变动。&lt;/p&gt;

&lt;p&gt;但此时还没有任何模型展示，我们把选中的部件模型也以SkinnedMeshRenderer组件的形式实例化出来，并挂载在‘根节点’下。&lt;/p&gt;

&lt;p&gt;现在挂载在‘根节点’下的部件模型只是静止的不会动的模型，虽然其自身有顶点的骨骼权重数据，但没有骨骼点的数据是无法计算出骨骼变化后的模型变化的。&lt;/p&gt;

&lt;p&gt;因此我们再把‘根节点’里的骨骼点数据赋值给这些模型部件，让他们能在每帧渲染前根据骨骼点的变化结合自身的骨骼权重数据计算出自身的网格变化情况。&lt;/p&gt;

&lt;p&gt;做完这些操作后，我们就算成功合成了一个由自己选择的人体部件并带骨骼动画的角色模型实例。&lt;/p&gt;

&lt;p&gt;当需要更换人体部件时，所需要的操作与合成一个角色模型的步骤一样，只是在这之上有了些小的变化，因为只替换某个部件，所以‘根节点’与其他没有更换的部件不需要被销毁，是可以重复利用的，只需要删除替换的部件实例。&lt;/p&gt;

&lt;p&gt;合成完模型看看这个角色，这么多部件都使用了SkinnedMeshRenderer，每个SkinnedMeshRenderer都有一定计算和drawcall的消耗，怎么办？合并。&lt;/p&gt;

&lt;p&gt;一种简单的办法就是仍然使用多个材质球进行渲染，在合并Mesh时使用子网格(SubMesh)模式，相当于只减少了SkinnedMeshRenderer组件的数量，并没有减少其他的消耗。&lt;/p&gt;

&lt;p&gt;另一种办法稍微复杂点，不使用子网格(SubMesh)模型，而是将所有模型合并成一个Mesh网格，使用同一个材质球。不过我们还是得保证有相同Shader的材质球进行合并，不相同的Shader的材质球不合并的原则，以保证角色渲染效果不变。&lt;/p&gt;

&lt;p&gt;把这么多材质球合并成一个的困难之处在于，贴图怎么办，uv怎么办？贴图我们采用实时合并贴图的方式，为了降低Drawcall，我们的办法实质上就是内存换CPU的方式，每次合成角色、更换部件时都重新合成一遍贴图，同时把uv设置在合并贴图后的某个范围内，因为uv的相对位置是不变的，所以只要整体移动到某个范围内就可以正常显示。&lt;/p&gt;

&lt;p&gt;这样模型的更换与合并，让角色捏脸系统有了基础的功能，而材质球、贴图的合并，优化了性能效果让这个系统更加完美。&lt;/p&gt;

&lt;h6&gt;其次是更换贴图&lt;/h6&gt;

&lt;p&gt;不同颜色的头发，不同颜色的手套，不同颜色相同形状的衣服，不同贴图相同形状的眼睛等，这些可以简单的使用贴图来达到目标的动作，就直接更换材质球里的贴图就可以了，不需要太复杂的操作，如果是采用贴图合并的方式来做的合并，那么就再重新合并一次贴图，uv则不需要任何变化。&lt;/p&gt;

&lt;h6&gt;再者是骨骼移动、旋转、缩放&lt;/h6&gt;

&lt;p&gt;除了更换部件、更换颜色的操作外，捏脸还有一个重要的功能，就是用户可以自由随意的DIY去塑造模型。例如把鼻子抬高点，把嘴巴拉宽点，把腰压细一点，把腿拉长一点等。&lt;/p&gt;

&lt;p&gt;由于模型的网格(Mesh)是根据骨骼点来变化的，每个组成网格的顶点都有自己的骨骼权重数据，所以只要骨骼点移动了，它们也跟着移动，骨骼点旋转了，它们也跟着旋转，骨骼点缩放了，它们也跟着缩放。于是我们可以利用这个特性来做一些操作，来让‘捏泥人’更加容易。&lt;/p&gt;

&lt;p&gt;不过问题也来了，骨骼点是随着动画一起动的，动画数据里的关键帧决定了骨骼点的变化，我们实时改变骨骼点位置是无法达到效果的，因为动画数据会强行恢复骨骼点，致使我们的操作变得无效。&lt;/p&gt;

&lt;p&gt;我们既要整个模型网格仍然依照原来的动画数据去变动，又要用某个骨骼点去影响某些网格怎么办？&lt;/p&gt;

&lt;p&gt;额外增加一些骨骼点，这些骨骼点是专门为用户可操作服务的骨骼点，并且这些骨骼点不加入到动画数据里。&lt;/p&gt;

&lt;p&gt;也就是说动画数据不会影响到这些骨骼点，动画播放时这些骨骼点是不会动的。&lt;/p&gt;

&lt;p&gt;然后为了能让网格随着，操作这些骨骼点儿发生变化，在顶点的骨骼权重数据里给这些骨骼点一些权重，这个权重能达到玩家操作效果就可以了，其他都由动画去决定变化，SkinnedMeshRenderer会在每帧根据骨骼点的变化计算出所有顶点的位置，也就是网格的变化形状。&lt;/p&gt;

&lt;p&gt;这样操作下来，我们就达到了先前说的，既要整个模型网格仍然依照原来的动画数据去变动，又可以让用户自定义操作骨骼点去影响网格变化。&lt;/p&gt;

&lt;h6&gt;最后是改变原始Mesh凹凸形状&lt;/h6&gt;

&lt;p&gt;只操作骨骼点来改变模型的捏脸效果还是不够的，因为毕竟骨骼点数量不能太多，顶点的骨骼权重数据也是有限的，无法通过增加大量的骨骼点来达到模型复杂变化的效果。&lt;/p&gt;

&lt;p&gt;于是，只能再另寻它方，这次我们回到了最基础的网格变化，由于蒙皮网格在每帧都从原始的网格加上骨骼点的变化数据来计算现在网格的形状的，那么改变原始网格的顶点数据，也同样可以改变网格在动画时的模型变化。&lt;/p&gt;

&lt;p&gt;对原始网格数据里的顶点进行变化，例如凹陷，拉伸，偏移等都可以影响整个模型在动画时的变化，因为蒙皮网格每帧的变化是根据原始网格而来的。&lt;/p&gt;

&lt;h6&gt;其实我们一直在围绕着基础知识做技术研究，基础知识和原理是核心，当我们实践时巩固了对基础知识和原理的理解，理论与实践相结合，并且不停地交替学习，逐渐得我们就能得心应手，运用自如，甚至还能厉害到无剑胜有剑的境界。&lt;/h6&gt;

&lt;h3&gt;7.动画优化&lt;/h3&gt;

&lt;p&gt;蒙皮动画太消耗CPU，为什么？&lt;/p&gt;

&lt;p&gt;因为所有蒙皮网格的变化都是由CPU计算得到的，并且无法利用多线程，也无法交给GPU去做，也就是没有谁能分担这项任务。&lt;/p&gt;

&lt;p&gt;更糟糕的是，游戏需要大量的蒙皮动画来达到丰富效果的目的。基本上所有项目都会极致得用尽动画功能，让游戏看起来很生动，很动感，很丰富，很饱满，很火热。&lt;/p&gt;

&lt;p&gt;效果再好，性能不行，只有高端机才能承受渲染压力的游戏，就无法对普罗大众产生吸引力，也就无法开启吸引力效应。所以对每个项目来说，对动画的优化也是迫在眉睫。&lt;/p&gt;

&lt;p&gt;本节就来说说3D模型动画的优化技巧。&lt;/p&gt;

&lt;h6&gt;用着色器代替动画&lt;/h6&gt;

&lt;p&gt;蒙皮动画说到实质处，就是网格顶点的变化，根据骨骼点与权重数据计算网格变化，它只是人们发明的一种每帧改变网格的方法而已，最终的目标都是，怎么让网格每帧发生变化，并且这种变化的形状是我们所期望的。&lt;/p&gt;

&lt;p&gt;只要达到这个目标，无论什么方法都是可行的。&lt;/p&gt;

&lt;p&gt;只要能想到这步，那么我们就有了另一种途径，即着色器(Shader)中的顶点着色器也可以改变网格顶点的位置。&lt;/p&gt;

&lt;p&gt;于是利用顶点着色器，与相应的算法就等得到一个随着时间变化的模型动画。&lt;/p&gt;

&lt;p&gt;利用着色器制造的动画，这种方式已经在许多项目中得到了利用，最常见就是随风摆动的草，会飘动的旗子，飘动的头发，左右摇摆的树，河流的波浪等。&lt;/p&gt;

&lt;p&gt;这些算法不在这里一一讲解了，全部搬到Shader着色器章节中去深入剖析，但大部分这些算法都利用了，游戏时间，噪声算法(noise)，数学公式(sin、cos等)来表达顶点的偏移量。&lt;/p&gt;

&lt;p&gt;除了顶点动画，还可以利用uv来做动画，比如不断流淌的水流就属于uv位移动画，又比如火焰效果中不断更换uv范围达到序列帧动画效果的uv序列帧动画，再比如不停旋转的面片动画，就可以用uv旋转来代替面片旋转，把CPU的消耗转入到GPU去消耗。&lt;/p&gt;

&lt;p&gt;uv动画的具体算法也不再这里一一讲解，都统一挪到Shader着色器章节中去了。&lt;/p&gt;

&lt;p&gt;用着色器代替动画实质上，就是用GPU消耗来分担CPU的效果，让两个芯片能更好的发挥其作用，而不是让某一个闲着没事干(大部分时候都是GPU很空)，另一个则忙的要死(大部分时候都是CPU很忙)。&lt;/p&gt;

&lt;p&gt;但用顶点动画，uv动画的算法来代替动画方式毕竟是有限的复杂度，当需要代替的动画复杂到没有固定算法规律可寻时，则需要寻求其他途径。&lt;/p&gt;

&lt;h6&gt;离线Bake每帧的模型网格，然后用更换网格的方式绘制每一帧，用内存换CPU&lt;/h6&gt;

&lt;p&gt;上面介绍了用着色器算法来动画，从而将CPU的消耗转移到了GPU消耗使得动画性能得以优化，但这样做的动画的复杂度是有限的，因为很多复杂的动画无法用算法来表达。&lt;/p&gt;

&lt;p&gt;这次我们不打算用算法了，即抛弃算法。我们来场无剑胜有剑的战斗，‘没有算法就是最大的算法’。&lt;/p&gt;

&lt;p&gt;我们想，动画的实质是，每帧显示的内容不一样，而每帧显示的内容不一样，就需要每帧都计算出一个不一样的形状。&lt;/p&gt;

&lt;p&gt;那么能不能，不计算？能。&lt;/p&gt;

&lt;p&gt;我们可以每帧都准备一个模型，每帧都展示一个已经准备好的不一样的模型，于是就有了每帧都有不同形状的模型需要展示，这不就是动画么。&lt;/p&gt;

&lt;p&gt;比如这是个5秒的蒙皮动画，每秒30帧，总共需要150个画面，我们需要准备150个模型来依次在每帧中播放。&lt;/p&gt;

&lt;p&gt;是不是代价很大，本来一个模型只要一个网格就够了，现在要准备150个网格，这就是内存换CPU的想法，到底值不值得这么做呢？&lt;/p&gt;

&lt;p&gt;假设这个场景只有2-3个模型在播放这个动画，那么为了这2-3个模型动画，我们就需要额外准备150个模型来播放动画，本来只要一个模型+骨骼就可以办到的事情，我们却要用150个模型来代替，加载这150个模型也是需要时间的，更何况内存额外加大了150倍。确实不值得。&lt;/p&gt;

&lt;p&gt;我们又假设，这个模型同时播放的这个动画的数量很多，比如100个以上，计算机每帧都需要通过模型+骨骼的方式计算出一个模型的变化，而且要重复计算100次，这时我们再用150个模型来代替这每帧持续的CPU消耗，就非常值得了。&lt;/p&gt;

&lt;h6&gt;计算机不再需要大量计算相同模型网格的变化，而只是在读取这150个模型时内存消耗以及加载的消耗，换来的是持续的高效的动画效果，这就是值得的。&lt;/h6&gt;

&lt;h6&gt;将每帧的网格偏移数据导出到图片，在Shader中让GPU通过图片里的数据来偏移顶点。&lt;/h6&gt;

&lt;p&gt;离线Bake每帧的模型网格，再通过直接改变网格数据来实时渲染动画，确实在大量渲染相同动画时起到了非常大的优化作用。&lt;/p&gt;

&lt;p&gt;但毕竟是还是会有大量的Drawcall的，每个模型一个Drawcall，100个模型100个Drawcall，GPU的压力很大。&lt;/p&gt;

&lt;p&gt;那么有没种方法合并这些drawcall？利用GPU Instancing。&lt;/p&gt;

&lt;p&gt;什么是GPU Instancing？这是GPU渲染API提供的一种技术，如果绘制1000个物体，它将一个模型的vbo提交给一次给显卡，至于1000个物体不同的位置，状态，颜色等等将他们整合成一个per instance attribute的Buffer给GPU，在显卡上区别绘制，它大大减少提交次数，这种技术对于绘制大量的相同模型的物体由于有硬件实现，所以效率高，更灵活，也避免了合批而造成内存浪费，并且原则上可以做GPU Skinning来实现骨骼动画的instancing。&lt;/p&gt;

&lt;p&gt;GPU Instancing最重要的一个特点是只要提交一次，就可以绘制1000个物体，把原本要提交1000次的流程，简化成了只需要提交1次，1000个Drawcall瞬间降为了1次。&lt;/p&gt;

&lt;p&gt;当然没那么简单，它是有条件的，首先条件是模型的着色器(Shader)要支持GPU Instancing，其次是这1000个模型他们位置、角度可以不一样，但都使用同一个模型数据，最后他们每帧都使用的是同样的模型数据，这样才能提交一次渲染全部。&lt;/p&gt;

&lt;p&gt;GPU Instancing 的条件有点苛刻，Shader要相同，材质球要相同，模型要相同，还不能有变形(就是不能有动画)。&lt;/p&gt;

&lt;p&gt;对于我们来说，要用GPU Instancing，就不能变模型了，怎么办？&lt;/p&gt;

&lt;p&gt;我们原来的方法是准备150个模型，每帧都渲染一个，现在换成，把这150个模型的顶点数据放入一张贴图里去，这张图总共有150行，每行都写入了所有顶点的坐标，每个像素数据 RGB 都分别代表 xyz 的顶点坐标，比如总共有3000个顶点，那么每行就有3000个像素，总共150行，这张图总共有 3000 * 150 个像素。&lt;/p&gt;

&lt;p&gt;然后把这张图，也相当于是网格的顶点数据传入着色器(Shader)，着色器根据传入的图中的每个像素去设置顶点，让GPU去改变网格而不是CPU，这样每次渲染前，所有模型都使用的是同一个模型，同一个材质球，同一个Shader着色器，符合了开启GPU Instancing的条件，只要提交一次模型数据，就能渲染1000个模型并且有动画，瞬间降低1000个Drawcall到个位数字。&lt;/p&gt;

&lt;p&gt;此时，我们不再需要骨骼了，也不需要SkinnedMeshRenderer了，只需要MeshRenderer来渲染模型就可以了，动画里的顶点变化交给了着色器去做，也可以认为是变相的顶点动画。&lt;/p&gt;

&lt;p&gt;这个着色器并不复杂，只是比普通的顶点着色器在传入参数时，多了个变量‘顶点索引’，根据这个顶点索引，来计算得到传入的贴图中的顶点坐标。&lt;/p&gt;

&lt;p&gt;伪代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    v2f vert(appdata v, uint v_index : SV_VertexID)
    {
            UNITY_SETUP_INSTANCE_ID(v); // gpu instance

            float f = _Time.y / _AnimLength;
            fmod(f, 1.0);

            float animMap_x = (v_index + 0.5) * _AnimWidth;
            float animMap_y = f;

            float4 pos = tex2Dlod(_AnimTexture, float4(animMap_x, animMap_y, 0, 0));

            v2f o;
            o.uv = TRANSFORM_TEX(v.uv, _MainTex);
            o.vertex = UnityObjectToClipPos(pos);
            return o;
    }

    fixed4 frag (v2f i) : SV_Target
    {
            fixed4 col = tex2D(_MainTex, i.uv);
            return col;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;顶点着色器中，用时间和动画长度计算出y的位置，也就是行数，再用顶点索引计算出列数，从而得到动画数据贴图中属于自己位置的像素，也就是顶点的坐标信息。&lt;/p&gt;

&lt;p&gt;取出这个像素后，就是这个顶点的坐标了，与世界坐标轴转换后即可使用。Shader中没有复杂的公式和原理，就是从图片中取出值来作为坐标去传递。&lt;/p&gt;

&lt;h6&gt;我们用这种操作方式，利用GPU Instancing 的功能，达到了合并Drawcall的目的，但同样也有很多缺陷，比如最重大的缺陷是，每个人物的动画都是一样的，不会错开来，也就是同一时间，很多模型，做相同的动作。&lt;/h6&gt;

&lt;h6&gt;又比如精度问题，如果要求模型动画有好的表现，就必须提高图片的精度，因为每个像素RGB的颜色就代表了顶点坐标信息，如果要求GPU支持float类型的贴图，一般需要gles3.0以上级别的机器，虽然现在也已经算比较普遍，但毕竟也有部分底端机器无法实现，是否降低动画精度，或者放弃些低端机也需要根据项目不同而深思熟虑下。&lt;/h6&gt;

&lt;h6&gt;LOD，动画LOD，网格LOD&lt;/h6&gt;

&lt;p&gt;借用GPU Instancing 的优势来合并Drawcall有好有坏，最大的坏处就是单个模型无法播放属于自己专有的动画而与其他相同的模型错开来。&lt;/p&gt;

&lt;p&gt;无法错开来播放动画，这个是最糟糕的。想要错开来播放属于自己的动画，那么事情又回来了我们最初的原点，骨骼蒙皮动画。&lt;/p&gt;

&lt;p&gt;对于1000个骨骼动画，并且每个人都必须有属于自己的动画序列，不能合并模型，不能合并材质球，只能用1000个Drawcall来支撑这巨大的消耗。&lt;/p&gt;

&lt;p&gt;也不是没有办法，不过首先我们要‘认命’，这1000个Drawcall是躲不过了，但可以退而求其次，用方法去降低消耗。&lt;/p&gt;

&lt;p&gt;骨骼蒙皮动画的最大消耗是，计算网格变化。那么这个计算网格的变化，究竟有哪些因素决定的？&lt;/p&gt;

&lt;p&gt;我们再一次回到了基础知识的原点，网格的变化是由，骨骼点与顶点的权重数据计算得到的。&lt;/p&gt;

&lt;p&gt;也就是说，有多少顶点，有多少骨骼，有多少权重数据，就有多少CPU要消耗。CPU的消耗与这三者任何一个都成正比。&lt;/p&gt;

&lt;p&gt;也就是说，顶点越少，骨骼数越少，权重数据越少，CPU的消耗就越少。&lt;/p&gt;

&lt;p&gt;但是顶点数少了，模型就不那么精细了，而骨骼数少了，动画就补那么精细了，而权重数据少了，网格变化就不那么精细了。&lt;/p&gt;

&lt;h6&gt;这是要用画面的质量来换取性能啊，伤筋动骨的事情还是少干干，毕竟游戏最重要画面质量不可动摇，这就相当于拿生命换钱一样，不可为。&lt;/h6&gt;

&lt;p&gt;我们还有LOD(Level of Detail)可以用，用远近的视觉差来优化性能开销，用内存来换取CPU。&lt;/p&gt;

&lt;p&gt;LOD的视觉差是利用，离摄像机太远的东西精细不精细无法分辨，精细和粗糙，在距离远的情况下效果是同样的。&lt;/p&gt;

&lt;p&gt;就这个视觉差效果，我们可以这么做LOD：&lt;/p&gt;

&lt;h6&gt;第一，为每个模型准备3-5套简化的模型，这些模型都一定以及肯定要带有骨骼权重数据，否则无法与骨骼关联播放动画，当摄像机与模型的距离拉远时启用较简单的网格，减少顶点数量。当摄像机拉近时则再次启用复杂的网格，加强表现。&lt;/h6&gt;

&lt;h6&gt;第二，同样的手法，准备多套骨骼，当摄像机拉远时启用较为简单的骨骼，减少骨骼数量。当摄像机拉近时则再次启用复杂的骨骼，加强表现。&lt;/h6&gt;

&lt;h6&gt;第三，SkinnedMeshRenderer的 SkinQuality 是决定顶点受多少根骨骼(最多4根)影响的变量，当摄像机拉远时设置为2根或者1根，当摄像机拉近时再恢复过来。&lt;/h6&gt;

&lt;p&gt;LOD也可以用到极致，LOD不只为了静态模型服务的，也同样可以为动画模型服务，虽然我们并没有用LOD降低任何Drawcall，但我们还是同样降低了很大的CPU开销，和降低Drawcall相比也有着异曲同工之妙。&lt;/p&gt;
</description>
               <pubDate>Sat, 18 May 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/05/18/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB7.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/05/18/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB7.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第五章，3D模型与动画(四) - 3D模型的变与换3</title>
               <description>&lt;p&gt;简单叙述下上篇的内容。&lt;/p&gt;

&lt;p&gt;上篇我们了解到，一个简化模型的算法，以及普通网格和蒙皮网格的区别。其中蒙皮网格是专门用来制作动画的，它除了普通网格所需要的顶点，三角形，uv数据外，还需要骨骼数据，和每个顶点的骨骼权重数据。&lt;/p&gt;

&lt;p&gt;其中骨骼动画是由骨骼点组成的，每个骨骼点之间的关系，要么是父子关系，要么就是平行的兄弟关系，要么就是没有关系，这些骨骼点在Unity3D中对应到模型上的GameObject点。在这种骨骼结构下，当父节的骨骼点位移，旋转时，子节点的骨骼也同时相对于父节点位移和旋转。所以骨骼点之间的结构就是父子关系或平行结构关系。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;那么骨骼点是怎么影响到顶点的呢，又是如何判断影响哪些顶点的呢？&lt;/p&gt;

&lt;p&gt;骨骼动画中，需要顶点的骨骼权重数据，每个顶点都受到骨骼的影响，一个顶点最多被4个骨骼影响，所以在Unity3D中每个顶点都有一个BoneWeight实例，实例中描述了当前这个顶点对分别4个骨骼有多少权重，因为最多4个，每个顶点一个，所以顶点数组有多长，BoneWeight数组就有多长，当骨骼点移动时，将使用这些顶点权重值来计算顶点的旋转和偏移量。&lt;/p&gt;

&lt;p&gt;简单来说就是，用顶点上的骨骼权重数据，来确定该点会被哪些骨骼点所影响。&lt;/p&gt;

&lt;h6&gt;蒙皮动画分两步：第一步是用3DMax，Maya等3D模型软件在几何模型上建立一系列的骨骼点(bones)，并计算好几何模型的每个顶点受这些骨骼点的影响权重(BoneWeight)；&lt;/h6&gt;

&lt;h6&gt;第二步则是在Unity3D中用户或关键帧动画持续改变一系列骨骼点位置，几何模型随着骨骼点发生相应变形。&lt;/h6&gt;

&lt;p&gt;通常我们使用的都是关键帧动画，就是Unity3D里的Animation动画文件，在某个时间点上对需要改变的骨骼做一个关键帧，而并不是在每帧上都做关键帧的操作。&lt;/p&gt;

&lt;p&gt;使用关键帧作为骨骼的旋转位移点的好处是不需要每帧去设置骨骼点的位置变化，在关键帧与关键帧之间的骨骼位置，是由Animation动画组件做了平滑的插值计算得到，这样可以减少大量的人力劳动，相当于关键帧之间做了‘补间动画’，这些‘补间动画’的目的就是对需要改变的骨骼做平滑的位移或者旋转插值计算，得到相应的位置和旋转角度。&lt;/p&gt;

&lt;h6&gt;’补间动画‘在每帧都只对骨骼动画做了位置和旋转的改变，然后蒙皮网格组件(SkinnedMeshRender)在每帧必须重新计算骨骼与网格的关系，所以最终就有了‘补间动画’每帧改变一些列骨骼点，骨骼点被(SkinnedMeshRender)重新计算得到模型网格变化，于是每帧就呈现出不同的网格变化，于是就有了3D模型网格动画。&lt;/h6&gt;

&lt;p&gt;整个骨骼动画的呈现流程清晰了，我们来用Unity3D的API来整理下，让我们理解的更加透彻。&lt;/p&gt;

&lt;p&gt;举例代码和解释如下，重点在注释的解释：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    //新建个动画组件和蒙皮组件
    gameObject.AddComponent&amp;lt;Animation&amp;gt;();
    gameObject.AddComponent&amp;lt;SkinnedMeshRenderer&amp;gt;();
    SkinnedMeshRenderer rend = GetComponent&amp;lt;SkinnedMeshRenderer&amp;gt;();
    Animation anim = GetComponent&amp;lt;Animation&amp;gt;();

    //新建个网格组件，并编入4个顶点形成一个矩形形状的网格
    Mesh mesh = new Mesh();
    mesh.vertices = new Vector3[] {new Vector3(-1, 0, 0), new Vector3(1, 0, 0), new Vector3(-1, 5, 0), new Vector3(1, 5, 0)};
    mesh.uv = new Vector2[] {new Vector2(0, 0), new Vector2(1, 0), new Vector2(0, 1), new Vector2(1, 1)};
    mesh.triangles = new int[] {0, 1, 2, 1, 3, 2};
    mesh.RecalculateNormals();

    //新建个漫反射的材质球
    rend.material = new Material(Shader.Find(&amp;quot;Diffuse&amp;quot;));

    //为每个顶点定制相应的骨骼权重
    BoneWeight[] weights = new BoneWeight[4];
    weights[0].boneIndex0 = 0;
    weights[0].weight0 = 1;
    weights[1].boneIndex0 = 0;
    weights[1].weight0 = 1;
    weights[2].boneIndex0 = 1;
    weights[2].weight0 = 1;
    weights[3].boneIndex0 = 1;
    weights[3].weight0 = 1;

    //把骨骼权重赋值给网格组件
    mesh.boneWeights = weights;

    //创建新的骨骼点，设置骨骼点的位置，父节点，和位移旋转矩阵
    Transform[] bones = new Transform[2];
    Matrix4x4[] bindPoses = new Matrix4x4[2];

    bones[0] = new GameObject(&amp;quot;Lower&amp;quot;).transform;
    bones[0].parent = transform;
    bones[0].localRotation = Quaternion.identity;
    bones[0].localPosition = Vector3.zero;
    bindPoses[0] = bones[0].worldToLocalMatrix * transform.localToWorldMatrix;

    bones[1] = new GameObject(&amp;quot;Upper&amp;quot;).transform;
    bones[1].parent = transform;
    bones[1].localRotation = Quaternion.identity;
    bones[1].localPosition = new Vector3(0, 5, 0);
    bindPoses[1] = bones[1].worldToLocalMatrix * transform.localToWorldMatrix;

    mesh.bindposes = bindPoses;

    //把骨骼点和网格赋值给蒙皮组件
    rend.bones = bones;
    rend.sharedMesh = mesh;

    //定制几个关键帧
    AnimationCurve curve = new AnimationCurve();
    curve.keys = new Keyframe[] {new Keyframe(0, 0, 0, 0), new Keyframe(1, 3, 0, 0), new Keyframe(2, 0.0F, 0, 0)};

    //创建帧动画
    AnimationClip clip = new AnimationClip();
    clip.SetCurve(&amp;quot;Lower&amp;quot;, typeof(Transform), &amp;quot;m_LocalPosition.z&amp;quot;, curve);

    //把帧动画赋值给动画组件，并播放动画
    anim.AddClip(clip, &amp;quot;test&amp;quot;);
    anim.Play(&amp;quot;test&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上的Unity3D代码就呈现了，几何模型数据，蒙皮动画数据，从无到有的过程。&lt;/p&gt;

&lt;p&gt;我们再返回去看在蒙皮动画第一步中权重的计算决定了蒙皮算法的效果，如果想要几何模型发生自然、高质量的形变，必须得有一种高效准确的权重计算方法。&lt;/p&gt;

&lt;p&gt;这里简单讲一下蒙皮的计算方式，以了解下计算原理。&lt;/p&gt;

&lt;p&gt;线性混合蒙皮（Linear Blending Skinning，LBS)是最最常用的蒙皮计算方式，由于它的计算速度优势使得其成为商业应用中最主要的方法之一。&lt;/p&gt;

&lt;p&gt;什么是线性混合蒙皮计算方式呢？简单说就是，当前顶点位置变化 = 初始位置 + 骨骼点变化1 * 骨骼权重1 + 骨骼点变化2 * 骨骼权重2 ....&lt;/p&gt;

&lt;p&gt;那么直接使用这种线性混合计算蒙皮的方式效果有点粗糙，为了更好的效果。[Jacobson et al. 2011]提出了一种有界双调和权重（Bounded Biharmonic Weights，BBW）的计算方法，该权重能使得几何模型发生平滑变形，这个算法后来就成为了我们现在最常使用的骨骼蒙皮动画的计算方式。&lt;/p&gt;

&lt;p&gt;他大概的意思就是说，既然网格数据的变化计算量大，线性混合计算的速度又是最快的，我们可以在线性计算的基础上加以改进。在线性蒙皮混合计算公式中，初始位位置无法改变，骨骼点的变化也无法改变，所以权重计算骨骼点的变化的量决定了最终效果是否好的关键。&lt;/p&gt;

&lt;p&gt;于是他就提出了，有界双调和权重的计算方法，其数学表达式如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/5/bone-bbw.jpg&quot; alt=&quot;有界双调和权重的计算方法&quot;&gt;&lt;/p&gt;

&lt;h6&gt;由于蒙皮动画是每帧都通过骨骼点来计算网格的变化的，如果骨骼点很多，网格很复杂(顶点或者面数很多)那么消耗的CPU就很多，因为网格里的顶点都需要通过蒙皮算法来算出顶点的变化，这些都是靠CPU来计算的。因此在制作模型动画的时候，特别要注意，同屏里有多少蒙皮动画在播放，以及每个蒙皮动画中，骨骼的数量有多少，网格的面数有多复杂，如果太多太复杂就会巨量的消耗CPU。&lt;/h6&gt;

&lt;h3&gt;5.人物3D模型动画换皮换装&lt;/h3&gt;

&lt;p&gt;有了上面的这些3D模型和骨骼动画的知识，我们在3D模型动画换装这种常见的游戏功能的编码设计上，就显得简单的多了。&lt;/p&gt;

&lt;h6&gt;首先，为了达到模型动画的动态拼接，我们必须一个人物只使用一套骨骼。&lt;/h6&gt;

&lt;h6&gt;其次，把骨骼和模型部件拆分开来，骨骼文件只有骨骼数据，每个部件的模型文件只包含了它自己的模型数据，同时它也必须包含了顶点上的骨骼权重数据。&lt;/h6&gt;

&lt;p&gt;用Unity3D的术语来说就是，把一个人物模型拆分成有很多个Fbx，其中一个Fbx只有骨骼数据，其他Fbx是每个部件的模型数据，它们都带有已经计算好的骨骼权重数据。&lt;/p&gt;

&lt;h6&gt;然后，把骨骼数据和模型动画都动态拼接起来。&lt;/h6&gt;

&lt;p&gt;具体步骤是，用骨骼Fbx模型数据实例化成一个SkinnedMeshRenderer，这样基础的骨骼数据就包含在这个实例里了。再把需要显示的各个部件Fbx模型数据实例化出来，拥有自己的SkinnedMeshRenderer，然后把骨骼信息从前面骨骼SkinnedMeshRenderer里取出来赋值给自己。&lt;/p&gt;

&lt;p&gt;这样每个部件都进行了SkinnedMeshRenderer实例化，SkinnedMeshRenderer可以渲染出自己的模型效果，并且自己的SkinnedMeshRenderer有了自己的骨骼数据，每个部件模型上也都有骨骼的权重数据，使每个模型部件针对骨骼动画是有效的。&lt;/p&gt;

&lt;h6&gt;再然后，在骨骼的SkinnedMeshRenderer上挂上Animator来播放动画文件，动画改变的是骨骼点，当动画播放时骨骼点会针对动画关键帧进行位移和渲染，由于部件模型的骨骼数据都是从骨骼的SkinnedMeshRenderer上映射过来的，所以当骨骼点动起来时就能带动众多的模型部件一起动起来。&lt;/h6&gt;

&lt;p&gt;当骨骼动画的SkinnedMeshRenderer上的动画文件开始播放时，每个部件也会随着骨骼点的变动而不断的计算出网格模型的变动情况，进而在渲染上体现出部件模型的动画效果。&lt;/p&gt;

&lt;h6&gt;最后，当我们需要更换人物上的某个部件模型时，只需要把原有的部件模型实例删除，再实例化出那个我们需要的部件模型，并把骨骼数据赋值给它就完成了操作，更换的操作看上去很简单，在表现上就是更换了人物的某个部件，脸，或腿，或手，或腰，或脚。&lt;/h6&gt;

&lt;p&gt;这种方式虽然是最简单的，但并不是最好的方式，比如人物拆分成了5个部件，头，手，身体，腿，脚，就需要6个SkinnedMeshRenderer来支撑，其中1个为骨骼动画的SkinnedMeshRenderer，其他5个为部件模型的SkinnedMeshRenderer，看上去很不友好，也就是说一个人物要至少5个Drawcall来支撑。&lt;/p&gt;

&lt;p&gt;骨骼动画已经很消耗性能了，还需要5个材质球去消耗5个drawcall，加重了性能消耗的力度。&lt;/p&gt;

&lt;p&gt;我们有更好的办法，我们希望一个人物动画只使用一个drawcall，那么我们就需要把这5个部件合并成一个模型，他们都使用同一个材质球，模型合并好办，使用Unity3D的Mesh.CombineMeshes就可以实现。&lt;/p&gt;

&lt;p&gt;那么贴图怎么办？也同样合并。在每次初始化拼接一个人物模型时，或者更换人物的部件模型时，将5张贴图动态的合并成一张，并在合并贴图的同时需要改变每个模型部件的uv，将他们的uv偏移到这张合并整图的某个范围内。&lt;/p&gt;

&lt;p&gt;这样一来，每个人物模型只需要消耗1个drawcall，减轻了gpu的负担。从CPU消耗来看，拼接的操作只存在于人物初始化，和更换部件模型时才会有消耗，所以合并贴图和模型的消耗并不频繁。&lt;/p&gt;

&lt;p&gt;伪代码为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    function change_role_part( list of part_fbx )
    {
        root = new SkinnedMesh(&amp;#39;role_bone.fbx&amp;#39;);

        combine_mesh = new Mesh();
        combine_tex = new Texture();

        for( item in part_fbx )
        {
            item.mesh.uv = item.uv + offset;

            combine_mesh.combine(item.mesh);

            combine_tex.combine(item.texture);
        }

        root.mesh = combine_mesh;
        root.texture = combine_tex;

        return root;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
               <pubDate>Sun, 12 May 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/05/12/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB6.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/05/12/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB6.html</guid>
            </item>
        
            <item>
               <title>思路探讨(二十四) 要勇敢的相信自己</title>
               <description>&lt;p&gt;你是很厉害的人物，就像是无所不能的一样，但凡你接触到的都能成功搞定。&lt;/p&gt;

&lt;p&gt;我很确信的知道所有看我文章的读者都是很聪明的人，我认为你们就应该这么认为自己。&lt;/p&gt;

&lt;p&gt;我为什么要这么认为？&lt;/p&gt;

&lt;p&gt;因为我知道人与人之间的区别就是思想上的区别。你在想什么，怎么想的，决定了你的现在和你的未来。&lt;/p&gt;

&lt;p&gt;就比如现在我就是这么认为，你们是很聪明的，很棒的，很有能力的一群人，我认为读我的文章的人，都是这个世界上很厉害的人，无论你们来自哪个地方，都那个地方的佼佼者。&lt;/p&gt;

&lt;p&gt;这也同时映射出我是很棒的，是聪明的，是厉害的人。&lt;/p&gt;

&lt;p&gt;我不是反夸自己，因为我相信自己是个厉害的人物，是个聪明的人，是个很棒的人，不论现在是不是，未来一定是。在变成未来那个很厉害的人之前，所有阻碍和困哪，都不值得去太在意。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h6&gt;我只关注那个未来画面里的我要成为的那个厉害的人，我只关注我是如何变成那个人的这个过程，只关注我要如何可以更快更好的变成未来那个人的方法，只关注我有没有按照变成未来那个人的方向去行动。&lt;/h6&gt;

&lt;h6&gt;除了上面这些，其他的一切都不值得我在意，因为我很坚信我能成为我心中的那个很棒的人。钱没了就没了，再去赚，下次小心点，贵重物丢了就丢了，再买一个，下次小心点，事情失败了就失败了，再来一次，下次小心点，事情变遭了，尽力修复，下次小心点。&lt;/h6&gt;

&lt;p&gt;你看，我并没有把注意力聚焦在那些阻碍我发展的事情上，而是把所有的注意力都集中在了我相信的那个事情上。其他所有的阻碍、困难、失败，都被我轻描淡写的掠过了，而我则在这些苦难后还在继续向前走。&lt;/p&gt;

&lt;p&gt;这就不就是，我们生活中一直幻想着的那个，聪明的，冷静的，有远见的，不斤斤计较的，充满智慧的人么。我们每天都在期盼有一个这样厉害的家伙成为自己的合作伙伴。&lt;/p&gt;

&lt;p&gt;成为这样的人其实很简单，只要你想，就能成。&lt;/p&gt;

&lt;h6&gt;是的，只要你把注意力集中在你想的那个东西上，其他事物都是次要的。如果我们把注意集中在未来的美好事物上，我们就能在当下成为一个聪明智慧的人，并且在未来成为画面里那个很棒的人。&lt;/h6&gt;

&lt;p&gt;不知道你有没有和我有同样的体会：回忆过去的时候，发现，很多很多事情都是因为我们不相信，所以才没有成，也有很多很多事情只是因为我们相信我们能成才成就的。我们能否做成一件事，全靠我们有多少的相信（即我相信的力度），我‘有点’相信，这个事情成功的概率就有是‘有点’，如果我‘非常’相信，那么这个事情的成功率就有‘非常’高。&lt;/p&gt;

&lt;p&gt;我相信我今天存进银行的钱，明天就能取出来，那么明天确实能取出来。&lt;/p&gt;

&lt;p&gt;如果我不相信我今天存进银行的钱能取出来，那么明天真的有可能取不出来。（如果有一天社会动荡到你完全不相信存进银行的钱是安全的时候，明天银行就会因挤兑而倒闭）&lt;/p&gt;

&lt;p&gt;我不是神棍，而是告诉大家，让人相信某件事是很难的，让人不相信某件事业也同样很难。就比如我如何让你不相信，存进银行的钱，明天取不出来，这件事，很难。因为现在的社会环境让你非常相信，存进银行的钱，明天就能取出来，我是很难改变你的想法的。就像我无法让你相信，你以后会竞选总理并且获胜一样，很难让你有这种相信的想法。但我能让你相信，我的想法是对，并且对你很有用，这个相对容易点，但也不是针对每个人都有效。&lt;/p&gt;

&lt;h3&gt;让一个人相信一件事，或者让一个人不相信一件事都非常难，概括可以说，要改变一个人的想法非常难。&lt;/h3&gt;

&lt;p&gt;我想了很久，关于人与人之间的区别到底在哪里的问题。&lt;/p&gt;

&lt;p&gt;是钱么？&lt;/p&gt;

&lt;p&gt;如果是钱，那么为什么有钱的人也同样迷茫，也同样冲动，也同样不知所措，同样犯与没钱的人一样的错误，也同样无知。&lt;/p&gt;

&lt;p&gt;是知识么？&lt;/p&gt;

&lt;p&gt;如果是知识，那么为什么博士以及博士后不是在掌控世界，理论上说他们的知识量是最大的，为什么依旧与普通人一样，迷茫，冲动，不知所措，也同样表现的无知。&lt;/p&gt;

&lt;p&gt;其实都不是。人与人之间的区别就是思维，和，想法。你怎么想的，决定了你怎么做，你想的是什么，决定了你最终会成为什么样人。&lt;/p&gt;

&lt;p&gt;如果你每天想着，我基因不好，我老是身体不好，我总是生病，我比较笨，我不会运动，我很穷，我被穷困所限制，老是有人和我作对，我的人生是苦难的，我有才但始终没有伯乐，我每次都被别人抛弃，我在变老，我怕我会破产，我总是迟到，我总是经不住诱惑，别人老是来占我便宜。等等等等。&lt;/p&gt;

&lt;p&gt;那么你就会成为你所想的，你的基因一定不好，你的身体肯定会坏，你肯定总是生病，你肯定比较笨，你肯定不擅长运动，你肯定富不起来，你的人生肯定是苦难的，你肯定遇不到伯乐，你肯定每次都被抛弃，你肯定老的很快，你肯定破产，你肯定迟到.....&lt;/p&gt;

&lt;p&gt;你想什么，就是你希望得到的，事情就会往这个方向发展，最终就会实现你所想。&lt;/p&gt;

&lt;p&gt;反之，如果我们的想法能更加积极点，乐观点，美好点，光明点，那么事情就会向更加积极，乐观，美好，光明的方向去走。&lt;/p&gt;

&lt;p&gt;如果我每天都认为，我的人生是完美的，我拥有很好的基因，我身体很棒，我免疫力很好，我很会运动，我总是很幸运，我总能遇到伯乐，我总是能和大家搞好关系，我永远都是那么年轻，我会越来越富有，我总是很准时的赴约，我总是很理智，别人都很喜欢跟我合作，我的知识会越来越渊博，我很智慧，我总是很受人照顾，我会很厉害。等等等等。&lt;/p&gt;

&lt;p&gt;那么事情就会真的向我想象的方向发展，我的基因很完美，我很健康，我很理智，我总是很受欢迎，我总是能遇到伯乐，我变得越来越富有，我很幸运，我看上去一直很年轻。&lt;/p&gt;

&lt;h6&gt;难道说真的有什么外在因素在决定这些事情的发生吗？并没有，原因在人的内心：我怎么想，决定了事情怎么走。&lt;/h6&gt;

&lt;h3&gt;人与人之间最大的区别就在这里，可以用很简单的一句话概括：你相信什么？信则有，不信则无。&lt;/h3&gt;

&lt;h3&gt;你所相信的，就是你能得到的。同样的，你所不相信的，就是你得不到的。&lt;/h3&gt;

&lt;h3&gt;无论你遭遇什么境况，都要勇敢的相信自己，我是健康的人，我是幸运的人，我是厉害的人，我是受欢迎的人，我是幸福的人。&lt;/h3&gt;
</description>
               <pubDate>Wed, 01 May 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/05/01/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A824.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/05/01/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A824.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第五章，3D模型与动画(四) - 3D模型的变与换2</title>
               <description>&lt;p&gt;上一篇介绍了一些3D模型的渲染基础知识，并且将这些基础知识运用在了3D模型的切割、拉伸、扭曲当中。&lt;/p&gt;

&lt;h6&gt;技术原理是最重要的核心点，人只要理解了技术原理，就能将技术表象解释清楚，在实际项目中将这种技术运用自如。&lt;/h6&gt;

&lt;h6&gt;实际中并没有这么容易，理解和运用自如之间，还是有一段很大的差距的，在实际项目过程中，理解只是理解，只是能解释这种表象是如何发生的，运用自如，则是熟知了原理的优缺点，不再对这种技术有任何的偏见，能做什么不能做什么，做什么有什么优势，有什么有什么劣势，有了更加深入的理解，当没有了这么多的偏见，运用起来自然得心应手。&lt;/h6&gt;

&lt;h6&gt;理论上说，我们每个人把所有精力先放在理解原理上，然后再去做技术实现不就轻松了吗。理论上是这样的，但人类头脑的进化毕竟还没到那么高级的程度，还不能轻松的把抽象的事物短时间内在脑中有条不紊的整理清楚，这还没把人的情绪影响算进去，人性毕竟是弱点多于优点的，虽然表面上能处理一些看上去相对复杂的事物，但从学习知识的角度看，人类的大脑还是不够高级，说实话应该说是有点低级。&lt;/h6&gt;

&lt;h6&gt;对于这么低级的大脑，我们只能通过反复的学习，然后实践，再学习，再实践，很多遍后才能对原理的理解推进那么一点点，我们也只能依靠长时间的、漫长时间的、很长很长时间的磨练，从有兴趣到放弃，再重新拿起到再放下，再拾取再举起再抛向天空，反反复复但始终不离弃，才能最终到达运用自如的境界。人之间没有聪明与不聪明之分，有的人善于思考，善于举一反三是因为前面很长一段时间他都一直在练习这种多思考和举一反三的方式，当我们看到他时他的思维方式已经成型，这些并不是先天就有，而是通过后天努力得来。天才这东西，不管它是否真的存在，我们都应该忽略它，转而更加专注于自己的努力上。&lt;/h6&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h3&gt;3.简化模型&lt;/h3&gt;

&lt;p&gt;经常在项目中看到有模型有几万个面，甚至几十万个面的情况，模型面数多的好处是能表现的更加精细，画面更细腻，但坏处却是加重了渲染压力，渲染的面数越多压力越重，帧率越低。所以一般都会对场景中的单个3D模型进行限制，或者对整体场景面数进行限制。&lt;/p&gt;

&lt;p&gt;画面质量和性能需要权衡，通常都是要求模型降低面数而画面质量不变，LOD(Level Of Detail)在这里就可以发挥巨大的作用，随着镜头的靠近逐级更换更细腻的模型很好的解决这种需求。&lt;/p&gt;

&lt;p&gt;简化模型在LOD中用到的最多，有手动用3D模型软件简化的，也有用程序工具式的简化模型，手动简化更加平滑但费时间，时间成本大，而用程序工具去简化则快速，但不平滑。我们可以根据项目的需求，规模，画质等要求来权衡是否使用程序工具去简化模型，或者更加灵活点，一部分不太需要细致的模型使用程序工具简化，而另一部分比较需要细节化的模型使用手动简化，这样即照顾到了画质，又照顾到了工期。&lt;/p&gt;

&lt;p&gt;这里我们来具体讲述下简化模型的算法。虽然市面上简化模型的插件和工具很多，但如果我们对原理有了更深入了解，在实际的项目中运用这些工具会更加自如且得心应手。&lt;/p&gt;

&lt;p&gt;3D模型是由点，线，面组成。面由点和线组成，减面相当于减点和线，单纯的减去点和线容易引起模型变化不受控制，收缩线上的两顶点成为一个顶点则更加靠谱些。[Garland et al. 1997]提出了一种基于二次项误差作为度量代价的边收缩算法，其计算速度快并且简化质量较高。&lt;/p&gt;

&lt;p&gt;该方法是去选择一条合适的边进行收缩时，定义一个边的收缩都是有代价的，每个顶点也有自己的代价，对于网格中的每个顶点v，我们预先定义一个4×4的对称误差矩阵Q，那么顶点v=[x y z 1]的代价为其二次项形式Δ(v)=vQ。&lt;/p&gt;

&lt;p&gt;同时也定义了边收缩的代价公式，假设对于一条收缩边(v1,v2)，其收缩后v1，v2顶点收缩为v3，我们定义顶点v3的误差矩阵Q3为Q3=Q1 + Q2，也就说是v1，v2的这条边的收缩为v3后代价为Δ(v3) = v3(Q1 + Q2)，以此类推每条边都有一个代价。&lt;/p&gt;

&lt;p&gt;有了上面的代价公式，下面的网格简化算法就容易理解多了：&lt;/p&gt;

&lt;p&gt;1，对所有的初始顶点都计算它们各自的Q矩阵.&lt;/p&gt;

&lt;p&gt;2，选择所有有效的边（这里取的是两点有连线的边，也可以将两点有连线且距离小于某个阈值的边归为有效边）&lt;/p&gt;

&lt;p&gt;3，对每一条有效边(v1,v2)，计算最优收缩目标v3.误差(Q1+Q2)是收缩这条边的代价（cost）&lt;/p&gt;

&lt;p&gt;4，将所有的边按照cost的权值都放在队列中从小到大进行排序。&lt;/p&gt;

&lt;p&gt;5，每次移除队列顶部的代价（cost）最小的边，也就是收缩最小代价的边，删除v1，v2，并用v3替换。&lt;/p&gt;

&lt;p&gt;6，重复1-5步骤，直到顶点数少于某个设定的值，或者所有cost代价大于某个值，则停止收缩算法。&lt;/p&gt;

&lt;p&gt;整个算法并不复杂，关键这里有两个核心问题需要解决，一个是每个顶点的初始Q矩阵如何计算，另一个是v1，v2收缩为v3时的坐标位置该怎么计算。&lt;/p&gt;

&lt;p&gt;在原始网格模型中，每个顶点可以认为是其周围三角片所在平面的交集，也就是这些平面的交点就是顶点位置，因此我们定义顶点的误差为顶点到这些平面的距离平方和。&lt;/p&gt;

&lt;p&gt;由此定义我们可以计算出每个顶点的初始误差矩阵Q：Δ(v)为顶点误差值 = vQ = 0，因为初始顶点的误差值为0，因为是它与相交平面的距离平方和为0，那么初始顶点的误差矩阵Q也可以由此计算出来。&lt;/p&gt;

&lt;p&gt;至于v1，v2收缩为v3时如何选择最优的坐标，简单的方法就是取v1，v2，和中点(v1+v2)/2的三个中收缩代价最小的一个为最优选择，另一种策略则是数值计算顶点v3位置使得Δ(v3)最小，由于Δ的表达式是一个二次项形式，因此令一阶导数为0。&lt;/p&gt;

&lt;p&gt;按照这个算法步骤，不停的收缩最小代价的边，直到顶点数量小于某个值时停止，最终将得到一个简化的模型。&lt;/p&gt;

&lt;h3&gt;4.蒙皮骨骼动画&lt;/h3&gt;

&lt;p&gt;有了3D模型，又会有3D模型动画，那么3D模型和3D模型动画之间到底有什么区别，我们先做个了解。&lt;/p&gt;

&lt;p&gt;为了能让读者们更直观的了解模型与模型动画的不同，我们从 Unity3D 的 MeshRenderer 和 SkinnedMeshRenderer 上作为切入点。&lt;/p&gt;

&lt;p&gt;在Unity3D中，MeshRenderer 与 SkinnedMeshRenderer 分别用于渲染 3D模型 和 3D模型动画。&lt;/p&gt;

&lt;p&gt;普通网格(MeshRenderer)渲染的是模型，由3D模型数据组成，蒙皮网格(SkinnedMeshRenderer)渲染的也是模型，也是由3D模型数据组成。&lt;/p&gt;

&lt;p&gt;不过蒙皮网格被创造出来主要是为了动作动画服务的，所以蒙皮网格除了3D模型数据外还有骨骼数据以及顶点权重数据。&lt;/p&gt;

&lt;p&gt;假设说蒙皮网格(SkinnedMeshRenderer)上没放置任何骨骼数据，那么它和普通网格的作用没有任何区别，都只能渲染静止不动的3D模型。&lt;/p&gt;

&lt;p&gt;有很多人并没有理解骨骼动画的原理，所以在实际项目中对3D模型骨骼动画的运用有很多误区，这里我们有必要阐述一下骨骼动画的原理，以及在Unity3D的SkinnedMeshRenderer上骨骼动画是如何组装和组成的。通过对骨骼动画的原理解剖和对 SkinnedMeshRenderer 的解剖，我们能彻底的明白骨骼动画的计算和渲染其实并不复杂，揭开这层薄薄的面纱后是一片平坦的开阔地。&lt;/p&gt;

&lt;p&gt;我们知道3D模型要做动作，首先是模型上的点，线，面要动起来，只有点，线，面动起来了，在每帧渲染的时候才能在每帧渲染时有不同的3D模型形状。&lt;/p&gt;

&lt;p&gt;那么怎么让点，线，面动起来呢？有两种方法，一种是用一个算法来改变顶点位置，叫顶点动画，另一种是用骨骼机制去影响顶点，叫骨骼动画。&lt;/p&gt;

&lt;p&gt;这两种都是通过每一帧改变模型上的各个顶点位置，从而让模型变形，进而形成动画的效果，每一帧模型的形状不一样，播放时形成动画，只是方法不同。&lt;/p&gt;

&lt;p&gt;模型上成千上万的顶点，如果每个都要手动来调整，每一帧都要手动调整一次，这种量级的劳动力，人类无法承受，所以在最初，还没有骨骼动画这个概念的时候，只能用程序写一个顶点走向算法去改变每个顶点的位置，或者用着色器(Shader)在顶点函数中去改变顶点位置成为动画效果，这种动画效果现在很多游戏中都还在使用，这种方法已经成为节省骨骼动画开销的必要手段，比如草、树在风中的左右摆动，丝带或国旗在空中自然飘动等。至于如何在着色器(Shader)中编写顶点动画，我们会在OpenGL渲染章节中讲解。&lt;/p&gt;

&lt;p&gt;骨骼动画的出现让3D模型的动画效果就变得越来越丰富多彩。为什么这么说？因为它是由简单的几个骨骼点组成，一般骨骼动画的骨骼数量都不会超过50个，是人类能够承受的操控范围之内。通过这一些简单的骨骼点操作，加上3DMAX，Maya这样的好用的动画工具，让人类能够创造出许许多多丰富多彩的动画效果。&lt;/p&gt;

&lt;p&gt;首先，骨骼动画由骨骼点组成，每个骨骼动画可以由许多个骨骼，现代手机游戏中每个人物的骨骼动画的数量一般都会在30个左右，PC单机游戏中会更多点到达40-50个左右。骨骼数量越多，表现出来的动画越细腻越有质感，但同时也消耗掉更多的CPU计算。&lt;/p&gt;

&lt;p&gt;其次，一个骨骼可以有很多个子骨骼，每个子骨骼都与父节点拥有相同的功能，只是当父节点移动、旋转、缩放时子节点也随着父节点的一起移动、旋转、缩放，他们的相对位置、相对角度、相对比例不变。这一点与Unity3D中的 GameObject 的节点很相似，父子节点有着相对位置的关系，所以骨骼点在Unity3D中的表现是由类似GameObject的形式存在的，我们可以直观的从带有骨骼的模型中看到骨骼点的挂载结构。&lt;/p&gt;

&lt;p&gt;在 SkinnedMeshRenderer 中就有 bones 这个变量来记录所有骨骼点，骨骼点的表现在 SkinnedMeshRenderer 中就是 Transform 数组，因此 bones 这个变量就是 Transform[] 类型。&lt;/p&gt;

&lt;p&gt;另外，一个骨骼点可以影响周围一定范围内的所有顶点，单一一个顶点，也可以受到多个骨骼的影响。在Unity3D中的 Quality setting 图形质量设置中，我们可以看到关于Blend Weights的设置，就是关于一个顶点能被多少骨骼影响的参数设置。选项中，有1 Bone，2 Bones，4 Bones，意思是一个顶点能被1个骨骼影响，或者被2个骨骼影响，或者被4个骨骼影响，能被影响的骨骼数越多，CPU消耗在骨骼计算蒙皮的时间越长，消耗量越大。&lt;/p&gt;

&lt;p&gt;最后，模型中每个顶点都有对它顶点本身影响的最多4个骨骼的权重值，在Unity3D中这4个骨骼权重被记录在了 BoneWeight 这个类中，每个 Mesh类 都有一个 boneWeights 变量来记录所有顶点的骨骼权重值，而无骨骼动画的 Mesh 是不需要这些数据的。&lt;/p&gt;

&lt;p&gt;每个顶点都有一个BoneWeight 类实例，BoneWeight 中boneIndex0，boneIndex1，boneIndex2，boneIndex3分别代表被影响的骨骼索引值，而weight0，weight1，weight2，weight3则是分别代表被影响的权重值，权重最大为1，最小为0，所有权重分量之和为1。&lt;/p&gt;

&lt;h3&gt;未完，篇幅有限，下篇继续&lt;/h3&gt;
</description>
               <pubDate>Sat, 27 Apr 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/04/27/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB5.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/04/27/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB5.html</guid>
            </item>
        
    </channel>
</rss>