<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title></title>
        <description>漫漫人生,记录点滴技术,始于2013</description>
        <link>http://www.luzexi.com</link>
        <atom:link href="http://www.luzexi.com/assets/feed.xml" rel="self" type="application/rss+xml" />
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，Shader(五) - Pass(二)</title>
               <description>&lt;h3&gt;Render State Command渲染状态指令详解&lt;/h3&gt;

&lt;p&gt;Render State Command 是渲染状态的指令，它在Pass和SubShader都有效，放在Pass就只在当前Pass里有效，放在SubShader中则是多个Pass的共同状态。&lt;/p&gt;

&lt;p&gt;不过不是所有的Render State都可以成为共同拥有的渲染状态的，有些Render State只在Pass中有效，而另一些则可以成为共同渲染状态。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;下面我们来介绍下Pass中的渲染状态Command指令：&lt;/p&gt;

&lt;h3&gt;Cull，前后裁切指令。&lt;/h3&gt;

&lt;p&gt;Cull是种优化的指令，可以让远离屏幕的部分不渲染。所有的物体都有前后两面，比如一个Box箱子你永远都看 不到屏幕另一侧的部分，所以可以对Box箱子后半部分进行裁切不渲染。&lt;/p&gt;

&lt;p&gt;可设置参数如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader20.png&quot; alt=&quot;cull&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    上图为参数 Cull Back，裁切白色Box的后半部分，保留前半部分。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader21.png&quot; alt=&quot;cull&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    上图为参数 Cull Front，裁切白色Box的前半部分，保留后半部分，展示的后半部部分与后面的箱子相交。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader22.png&quot; alt=&quot;cull&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    参数 Cull Off，关闭裁切功能，与Cull Back展示的效果一样，但其实多渲染了后半部分的网格模型。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Cull默认是裁切后半部分的，这样可以达到优化的效果，如果你没有对它进行设置的话。其实裁切后半部分和完全不裁切，在有深度缓存数据时是显示的效果是完全一样的，只是一个做了优化另一个没做而已。&lt;/p&gt;

&lt;h3&gt;ZTest，设置深度缓存测试模式。&lt;/h3&gt;

&lt;p&gt;ZTest的功能是在两个物体相交时渲染绘制中对前后深度进行测试，默认情况下以LEqual小于等于其他物体时测试为不通过，当不通过时就不渲染那部分模型。&lt;/p&gt;

&lt;p&gt;LEqual参数，其实就是测试前面的物体是否挡住了该物体部分，如果挡住了就不渲染的意思，它也是ZTest的默认参数。&lt;/p&gt;

&lt;p&gt;其他参数还包括&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;ZTest Less | Greater | LEqual | GEqual | Equal | NotEqual | Always

参数 小于 | 大于 | 小于 | 小于等于 | 大于等于 | 等于 | 不等于 | 关闭测试
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数解释：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader23.png&quot; alt=&quot;ztest&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;上图中为参数 Less 该物体上的部分深度在其他物体后面时不渲染。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader24.png&quot; alt=&quot;ztest&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;上图中为参数 Greater 该物体上的部分深度在其他物体部分前面时不渲染，也就是被覆盖的显示，没被覆盖的反而不显示。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader25.png&quot; alt=&quot;ztest&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;上图中为参数 Equal 该物体上的部分深度与其他一致时才渲染，否则不渲染。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader26.png&quot; alt=&quot;ztest&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;上图中为参数 NotEqual 该物体上的部分深度与其他物体不一致时才渲染，否则不渲染。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;ZWrite，设置深度缓存写入开关。&lt;/h3&gt;

&lt;p&gt;Zwrite可以控制物体渲染的像素是否写入depth buffer深度缓存数据中。&lt;/p&gt;

&lt;p&gt;如果没有depth buffer深度缓存数据，物体将无法辨识前后关系也就无法实现阻挡物体不绘制的功能。&lt;/p&gt;

&lt;p&gt;这在大多数不透明物体中都是需要depth buffer深度缓存数据来识别前后遮挡的，但在半透明和透明物体中就不需要depth buffer。&lt;/p&gt;

&lt;p&gt;半透明和透明物体没有depth buffer深度缓存数据，所以没有所谓的写入一说，也就是通常在半透明和透明物体的Shader中，ZWrite是关闭的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader27.png&quot; alt=&quot;zwrite&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader28.png&quot; alt=&quot;zwrite&quot;&gt;&lt;/p&gt;

&lt;p&gt;如上两个图，图1为ZWrite On时的效果，黄色Box遮挡住了后面的蓝色Box因为有depth buffer深度缓存的写入，前后关系有依据。&lt;/p&gt;

&lt;p&gt;图2为ZWrite Off的效果，后面蓝色的Box被提到了黄色Box的前面显示，这是因为黄色Box的depth buffer没有写入，在渲染时，面片前后关系没有了依据，导致了错乱。&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))
    { //移动端
        /*mobile-20:5*/
        var cpro_id = &quot;u3493987&quot;;
        document.write(&quot;\&lt;script type=\&quot;text\/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/cm.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
    else
    {
         /*700*200信息流*/
        var cpro_id = &quot;u3469788&quot;;
        document.write(&quot;\&lt;script type=\&quot;text/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/c.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
&lt;/script&gt;

&lt;h3&gt;Offset，设置深度缓存的偏移。&lt;/h3&gt;

&lt;p&gt;Offset允许你设置物体在深度缓冲中的偏移量，这相当于让物体在屏幕显示中提前或者推后显示位置，但实际世界中的位置不变。&lt;/p&gt;

&lt;p&gt;Offset有两个参数，Factor偏移缩放大小和Units偏移量。Factor相当于缓存数据偏移放大的倍数，Units相当于直接偏移的量。&lt;/p&gt;

&lt;p&gt;如果从公式上理解，可以理解为Buffer = (x or y)*Factor + Units。&lt;/p&gt;

&lt;p&gt;举例 Offset 3 , 5，可以理解为偏移放大3倍，并且再偏移5个单位。&lt;/p&gt;

&lt;p&gt;注意，偏移负方向才是离屏幕越近的方向。所以Offset 0 , -1时，两个物体重合部分肯定是拥有Offset 0 , -1的提前显示。&lt;/p&gt;

&lt;p&gt;如果两个物体前后差的比较远，那么想把后面的物体提到前面来显示，那么就要加大偏移量了，比如 Offset 0 , - 1000 或者 Offset -100, -1等。&lt;/p&gt;

&lt;p&gt;下面举例说明Offset的作用：&lt;/p&gt;

&lt;p&gt;对白色的做处理Offset 0 , 0 -------两者重叠，时而显示普通的有贴图的立方体，时而显示白色的立方体，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader29.png&quot; alt=&quot;offset&quot;&gt;&lt;/p&gt;

&lt;p&gt;对白色的做处理Offset 0 , -1------两者重叠部分完全被白色覆盖,因为白色立方体做了偏移量的处理，深度缓存中的坐标离屏幕更近，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader30.png&quot; alt=&quot;offset&quot;&gt;&lt;/p&gt;

&lt;p&gt;对白色的做处理Offset 0 , 0 ---- 现在把两个立方体的距离拉开，正常情况下按透视的距离进行显示，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader31.png&quot; alt=&quot;offset&quot;&gt; &lt;/p&gt;

&lt;p&gt;对白色的做处理Offset 0 , -1000 ---- 现在加重白色立方体的偏移量，深度缓存数据向屏幕偏移，这时很多有贴图的立方体部分被覆盖，因为偏移量加大，提前量就加大了，但绿色立方体其他部分的深度数据还是比偏移后的大，所以那个部分还是无法覆盖，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader32.png&quot; alt=&quot;offset&quot;&gt;&lt;/p&gt;

&lt;p&gt;对白色的做处理Offset -100 , -1000------再次加大偏移量，这次加入了缩放比例的偏移，偏移的更多，使得白色立方体全部覆盖绿色立方体，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader33.png&quot; alt=&quot;offset&quot;&gt;&lt;/p&gt;

&lt;p&gt;注意以上所有图中两个立方体的世界坐标一直都没有更改。如果要让物体向后推也是同样方法，负数变正就可以，所有的偏移都是渲染上的偏移，与物体实际坐标无关。&lt;/p&gt;
</description>
               <pubDate>Wed, 08 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/08/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader5.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/08/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader5.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，Shader(四) - Pass(一)</title>
               <description>&lt;h3&gt;Pass&lt;/h3&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;Pass块的格式，如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;    [Name and Tags]&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;    [Render State]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Pass可以定义自己的名字，和Tag标签，以及渲染状态Render State。&lt;/p&gt;

&lt;p&gt;Pass通过Tag标签来变更渲染引擎里的设置。Pass里的这个Tag和SubShader上的Tag是同一种标签，SubShader起到了共享标签的作用，而Pass里的Tag则是独立的个性化的。&lt;/p&gt;

&lt;h3&gt;Tag标签详解&lt;/h3&gt;

&lt;p&gt;Tag的格式很简单，就同Key-Value一样，每个标签都有一个Key，对应一个Value，Key之间用空格隔开。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { “TagKey1” = “Value1” “TagKey2” = “Value2” }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么究竟有哪些Tag可以供我们使用？&lt;/p&gt;

&lt;p&gt;我们先介绍SubShader和Pass共用的Tag。&lt;/p&gt;

&lt;h6&gt;Queue 标签Tag&lt;/h6&gt;

&lt;p&gt;Queue是渲染顺序的标签。可以用这个标签决定模型在绘制时所用的顺序。&lt;/p&gt;

&lt;p&gt;Shader会在渲染前决定物体属于哪个渲染顺序，从而确保所有透明或半透明物体的绘制顺都排在不透明物体的后面。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    例子，Tags { &amp;quot;Queue&amp;quot; = &amp;quot;Transparent&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下为渲染顺序的定义选择。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Background：这种类型的顺序会排在所有物体的前面。

    Geometry(默认)：大多数物体都使用这种方式。所有不透明物体使用这个类型。

    AlphaTest：使用Alpha Test的物体使用这个类型的渲染顺序。它被排在不透明物体的渲染后面。

    Transparent：排在Geometry和AlphaTest后渲染。所有alpha混合的物体都应该选择这个类型（因为Shader不会入depth buffer）。

    Overlay：这个类型是最后渲染的，比前面所有类型都要置后。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在实际的运用过程中，Render Queue是可以有自己的排序状态的，不同的Shader同一种排序类型可以有不同的前后关系。&lt;/p&gt;

&lt;p&gt;比如在两个物体都使用Geometry类型的渲染顺序，第一个物体使用 Geometry+1 比其他的 Geometry 类型物体更加滞后渲染，第二个物体使用 Geometry+2 写法，比第一个物体还要靠后渲染，目的有可能是需要在其他物体渲染完毕后再对周围环境做出反应。&lt;/p&gt;

&lt;p&gt;这种方式在透明和半透明的物体中特别常用，因为透明和半透明物体没有深度缓存测试，所以他们之间的渲染顺序是混乱的，当两个半透明物体放在前后位置进行渲染时，摄像机看到的是一个比较混乱的排序方式。因此在半透明物体的运用中我们时常人工指定某些物体的排序大小，比如如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { &amp;quot;Queue&amp;quot; = &amp;quot;Transparent+1&amp;quot; }

    Tags { &amp;quot;Queue&amp;quot; = &amp;quot;Transparent+2&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后者比前者在渲染绘制时排在后面，先绘制了+1的半透明物体后，再绘制+2的半透明物体，结果是+2物体会覆盖+1物体而显示得靠前。&lt;/p&gt;

&lt;p&gt;例子中“+1”表达了渲染顺序往后靠一位，+2比+1更往前后，数字越大渲染时越排在后面。&lt;/p&gt;

&lt;p&gt;“Queue”标签在Shader里会提前告诉着色器这个物体的渲染顺序，这样在渲染中就不会因为没有深度缓存数据而导致前后渲染的混乱。&lt;/p&gt;

&lt;p&gt;渲染顺序到2500(“Geometry+500”)是非透明物体和可优化绘制顺序（自动排序）物体最佳的性能位置。&lt;/p&gt;

&lt;p&gt;超过2500是半透明物体和手动排序物体的区间范围。天空盒(Skybox)被排在非透明物体和半透明物体中间。&lt;/p&gt;

&lt;h6&gt;RenderType 标签Tag&lt;/h6&gt;

&lt;p&gt;RenderType 标签是自由识别类标签，他没有自己的标签类型选择，可以为任意字符串。&lt;/p&gt;

&lt;p&gt;RenderType的主要作用是被识别与替代。在Shader替换效果中比较常用，比如场景中有些类型的物体需要在某个时刻替换某种Shader，并且不是真正的替换Shader，而是只针对某个Camera摄像机，其他的Camera摄像机保持原样。这时就需要用到RenderType标签，再用Camera.RenderWithShader或Camera.SetReplacementShader进行替换，因为函数中需要找出某种类型的Shader进而才可以进行替换，所以RenderType就是那个标识记号。&lt;/p&gt;

&lt;p&gt;Camera.RenderWithShader或Camera.SetReplacementShader渲染的规则是，没有RenderType标记的全部替换并渲染，有标记的但跟给定的标记一样的才渲染，否则不渲染。&lt;/p&gt;

&lt;p&gt;Unity内部Shader已经全部标记了RenderType，可以在它的Shader源码内参考。&lt;/p&gt;

&lt;h6&gt;DisableBatching标签&lt;/h6&gt;

&lt;p&gt;DisableBatching可以将该物体上的Draw Call Batching打开或关闭。&lt;/p&gt;

&lt;p&gt;为什么要关闭呢，因为在一些Shader中需要对顶点进行更改达到Mesh变化的目的，而Draw Call Batching会对所有的可合并的模型进行合并后放入场景空间，所以这些对Mesh操作的Shader就不起作用了，需要关闭Draw Call Batching才能重新得到该Shader要的效果。&lt;/p&gt;

&lt;p&gt;DisableBatching有三种类型可以选择。&lt;/p&gt;

&lt;p&gt;第一种是True，标志着Draw Call Batching 功能在这个物体上将被关闭。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { &amp;quot;DisableBatching&amp;quot; = &amp;quot;True&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二种是False，标志着Draw Call Batching 功能在这个物体上不关闭。False是默认值，也就是说如果不去设置它时，Shader模式是不关闭Draw Call Batching的。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { &amp;quot;DisableBatching&amp;quot; = &amp;quot;False&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第三种是LODFading，这个比较特殊，只在LOD fading设置被开启时关闭这个物体上的Draw Call Batching功能。一般常用在树上，会动且有LOD功能。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { &amp;quot;DisableBatching&amp;quot; = &amp;quot;LODFading&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;这里简单介绍下Draw Call Batching功能，后面章节中会有详细的介绍。&lt;/h6&gt;

&lt;p&gt;每个物体都有一个材质球，每个材质球都有一个Shader，每个Shader都起码有 一个Pass渲染管线，每个物体在渲染时，引擎会抓取模型的顶点，网格，颜色，贴图，UV，法线等数据进行一次渲染操作。&lt;/p&gt;

&lt;p&gt;那么如果每个物体都单独走一次渲染管线，几百几千甚至几万个物体一起渲染时，就会因为渲染引擎工作量过大CPU和GPU负荷过高而导致画面渲染次数减少，也就是帧数下降，因为每一帧一个画面。帧数下降导致画面有卡顿感，不流畅。所以要使用Batching批处理进行优化，于是就有了Draw Call Batching。&lt;/p&gt;

&lt;p&gt;它是怎么优化的呢？把所拥有有相同材质球的模型放在一起走一次渲染管线，不同的材质球对应的模型不能进行Draw Call Batching。&lt;/p&gt;

&lt;p&gt;这样大大加强了处理速度，原来一个一次的处理方式，变成了一批一次，达到了优化的目的，绘制画面的次数上去了，每秒的帧数（FPS）也上就去了。&lt;/p&gt;

&lt;p&gt;Draw Call Batching分两种，一种是动态的，一种是静态的。&lt;/p&gt;

&lt;p&gt;要进行动态的Batching批处理要求有点高，比如它要求模型必须少于900个顶点甚至更少，又比如它要求Batching批处理对象的Scale大小是一模一样的否则不予处理，再比如必须使用同一种材质球而且是同一个实例，不同材质球或者同一材质球而不同实例也不行，还有如果有烘培的模型，它的烘培图必须是同一张，甚至Shader中不能使用多个Pass等等苛刻的条件。所以想要做动态批处理还是比较困难的。&lt;/p&gt;

&lt;p&gt;静态Batching就比较好弄了，只有在编辑器的右上角勾选静态标志就可以了，不过一旦勾上静态标志，物体就再也不能动不能旋转和缩放了。&lt;/p&gt;

&lt;p&gt;当然Draw Call Batching本身有很多的限制，但对优化渲染管线还是有一定好处的，如果想要加大加强加快优化的力度，还有其他很多方法，每个部分的优化方案都写进了各个章节中，特别是针对Draw Call Batching的替代方案，在模型章节中有很深入的讲解。&lt;/p&gt;

&lt;h6&gt;ForceNoShadowCasting 标签Tag&lt;/h6&gt;

&lt;p&gt;ForceNoShadowCasting是针对是否强制关闭阴影投射功能的。&lt;/p&gt;

&lt;p&gt;当ForceNoShadowCasting为True时，物体将不会去绘制阴影部分，着色器也不会把时间浪费在阴影的绘制上了。默认为False的，默认状态下，物体会去绘制阴影部分的渲染图。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { &amp;quot;ForceNoShadowCasting&amp;quot; = &amp;quot;True&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;IgnoreProjector 标签Tag&lt;/h6&gt;

&lt;p&gt;IgnoreProjector针对的是投射阴影的开关功能。&lt;/p&gt;

&lt;p&gt;当IgnoreProjector为True时，着色器将关闭Projector投射阴影的绘制功能，这个物体将不会绘制投射阴影部分的渲染。默认状态下是False，默认状态下，物体是能响应Projector投射的阴影绘制的。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { &amp;quot;ForceNoShadowCasting&amp;quot; = &amp;quot;True&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;CanUseSpriteAtlas 标签Tag&lt;/h6&gt;

&lt;p&gt;CanUseSpriteAtlas是针对图集里的元素的，它是UGUI中常使用。当CanUseSpriteAtlas为False时，将不会对打进图集里的贴图进行绘制。默认为True。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { &amp;quot;CanUseSpriteAtlas&amp;quot; = &amp;quot;False&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;PreviewType 标签Tag&lt;/h6&gt;

&lt;p&gt;PreviewType是展示材质球预览形状的默认选项的。编辑器中Material材质球展示预览效果时，默认是球形，通过这个标签，可以设置为Plane面板形状，也可以设置为Skybox天空盒形状。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Tags { &amp;quot;PreviewType&amp;quot; = &amp;quot;Plane&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))
    { //移动端
        /*mobile-20:5*/
        var cpro_id = &quot;u3493987&quot;;
        document.write(&quot;\&lt;script type=\&quot;text\/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/cm.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
    else
    {
         /*700*200信息流*/
        var cpro_id = &quot;u3469788&quot;;
        document.write(&quot;\&lt;script type=\&quot;text/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/c.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
&lt;/script&gt;

&lt;h3&gt;以上是SubShader和Pass共享的Tag标签，下面我们介绍一些只有在Pass里使用的Tag标签。&lt;/h3&gt;

&lt;h6&gt;LightMode 标签Tag&lt;/h6&gt;

&lt;p&gt;通过设置LightMode可以在Pass里设置一个光照模型，主要是针对光的相互作用。&lt;/p&gt;

&lt;p&gt;值类型选择范围有：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Always：一直都渲染，不应用光照作用。

    ForwardBase： 使用正向渲染。环境光，主方向光，vertex/SH lights 和 烘培贴图功能被开启。

    ForwardAdd：使用正向渲染。在ForwardBase的基础上，添加像素光的应用，每个Pass（渲染管线）一个灯管。

    Deferred：使用延迟渲染。着色使用g-buffer。

    ShadowCaster：渲染物体depth到阴影图(Shadowmap)或者一张深度贴图(depth texture)。

    MontionVectors：计算每个物体的运动矢量。

    PrepassBase：使用旧的延迟光照。渲染法线和镜面反射。

    PrepassFinal：使用旧的延迟光照。用合并贴图，光照和发散光，来渲染最终颜色。

    Vertex：当物体不使用烘培贴图时，使用旧的顶点灯光渲染模式。所有顶点光都被开启。

    VertexLMRGBM：当物体使用烘培贴图时，使用旧的顶点灯光渲染模式。PC和Console平台上烘培贴图是RGBM编码格式。

    VertexLM：当物体使用烘培贴图时，使用久的顶点灯光渲染模式。在手机平台上烘培贴图是double-LDR编码。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;PassFlags 标签Tag&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    OnlyDirectional：当使用ForwardBase的Pass标签时，这个标签会只让主方向光和环境光数据通过进入Shader。这意味着不重要的灯光数据，不会被通过进入顶点光或球面谐波Shader变量。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;RequireOptions 标签Tag&lt;/h6&gt;

&lt;p&gt;RequrieOptions可以做到，一个Pass申明当有某种外部条件发生的时候才被渲染。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    SoftVegetation：当软植物(Soft Vegetation)在Quality Settings中被设置时，才渲染这个Pass。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
               <pubDate>Wed, 08 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/08/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader4.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/08/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader4.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，Shader(三) - 渲染管道</title>
               <description>&lt;h3&gt;SubShader模块&lt;/h3&gt;

&lt;p&gt;SubShader相当于子Shader的意思，SubShader在Shader中可以有很多个，每个SubShader都可以针对一种设备，但不是所有SubShader都会被采用。当Unity去展示一个模型时，会从第一个SubShader开始寻找是否匹配当前的设备，如果不匹配则与下一个SubShader继续匹配，直到找到能够匹配该设备为止。如果所有的SubShader都没有匹配上，则会使用 Fallback 标签的Shader。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;格式如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SubShader&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;   [Tags]&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;   [CommonState]&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;   [Pass1]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RenderSetup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;    [Pass2]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RenderSetup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;    [Pass3]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RenderSetup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;    […]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Fallback&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;”&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fallback&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Off&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;SubShader中可以定义了Tag标签，以及与Pass共同拥有的状态(Common State)。&lt;/p&gt;

&lt;p&gt;Pass代表了一个渲染管道，每次通过Pass进行渲染都是通过一次完整渲染管道。&lt;/p&gt;

&lt;p&gt;当一个SubShader被设备选中进行渲染时，定义的每个Pass都会渲染该物体一次，如果有很多灯光相互作用的话可能不止一次。通过Pass渲染一次会承担相当大的代价，所以我们在编写Shader Pass时需要小心，尽量减少Pass的使用，尽量将Pass数量最小化。&lt;/p&gt;

&lt;p&gt;建议只有在我们无法使用单个Pass达到效果时，才启用多个Pass进行Shader编程。&lt;/p&gt;

&lt;p&gt;所有在SubShader块中的渲染状态都可以在Pass中进行特殊化，也就是说定义在SubShader中的渲染状态是所有Pass公有的渲染状态，同时Pass可以定义自己的个性化的渲染状态。&lt;/p&gt;

&lt;p&gt;比如以下例子：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SubShader&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Lighting&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Off&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Cull&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Front&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Cull&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Back&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Fallback&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Diffuse&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;”&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;上述例子中 SubShader 设置了一个共同的渲染状态(Common State)就是把灯光影响关掉，灯光不再影响着色，第一个Pass中使用了独立的渲染状态是，裁切模型前半部分，第二个Pass中也使用了独立的渲染状态，裁切模型模型后半部分，然后他们共同拥有Common State是关闭灯光效果，所以第一个Pass就有了两个状态，一个是关闭灯光效果，第二个是裁切前半部分模型，而第二个Pass的也有两个状态，一个是关闭灯光效果，另一个是裁切后半部分模型。&lt;/p&gt;

&lt;p&gt;SubShader最后还有一个Fallback标识，代表了当所有SubShader都对设备无效时，则选择备用的Shader作为替代。而当你认为无法替代，或者无需替代的时候可以关闭Fallback的功能 Facllbck off 。&lt;/p&gt;

&lt;p&gt;在上面的例子中，Fallback “Diffuse”表示了，当所有SubShader都无法起作用的时候漫反射Diffuse替代当前Shader。&lt;/p&gt;

&lt;p&gt;SubShader本身并不复杂，但里有几个重要的模块，以及这些模块中的标签和用途可能会稍微繁琐一些，下面我们要详细讲一讲Pass块的格式和属性内容。&lt;/p&gt;

&lt;h3&gt;渲染管道&lt;/h3&gt;

&lt;p&gt;提到渲染管道，不得不提到渲染管线流程，一整个渲染管线流程分八个阶段。&lt;/p&gt;

&lt;h6&gt;阶段1， 指定几何对象&lt;/h6&gt;

&lt;p&gt;这个阶段引擎在选择某些几何对象作为渲染目标。&lt;/p&gt;

&lt;p&gt;理论上是一次抓取一个几何对象，但一般引擎都有批处理优化功能，一次抓取一批相同材质球的几何物体进行渲染。&lt;/p&gt;

&lt;h6&gt;阶段2，顶点处理&lt;/h6&gt;

&lt;p&gt;主要工作就是“变换三维顶点坐标”和“光照计算”。&lt;/p&gt;

&lt;p&gt;顶点变换或坐标系变换包括：&lt;/p&gt;

&lt;p&gt;3D中有以下几种空间：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1，Object space，模型坐标

    模型空间也叫本地空间或者建模空间，这是我们定义物体三角形的坐标系，当一个建模人员创建一个物体的三维模型的时候，他选择了一个方便的方向、比例和位置来保存模型的组成顶点，当前物体的模型、空间和其他模型没用任何关系。

    2，World space，世界坐标；

    世界空间的目的就是给你的场景中的物体提供一个绝对的参考。

    3，Eye space，视觉空间（视锥裁剪）

    以摄像机为基准，以摄像机的位置为原点，摄像机朝向Z轴正方向，右边X轴为正方向，上边为Y轴正方向，之所以设置这个坐标系，主要是为了方便投影及裁剪操作。

    ###### 4，Clip and Project space，摄影，裁剪空间坐标（也叫屏幕坐标）

    该空间即世界空间的物体被投影到相应的投影上面之后，继而进行的裁剪操作所在的空间。

    Eye space坐标转换到Clip and Project space坐标的过程其实就是一个投影、剪裁、映射的过程。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了坐标转换和光照计算，第2阶段还做了纹理坐标变换(纹理矩阵)，材质状态纹理坐标生成。&lt;/p&gt;

&lt;p&gt;这个阶段所接收到的数据则是每个顶点的属性特征，输出则是变换后的顶点数据。&lt;/p&gt;

&lt;p&gt;这个阶段也是Shader里，vertex fragment着色器编程中 vertex 顶点转换函数的处理阶段，vetex顶点函数就在这个阶段编写顶点的变化。&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))
    { //移动端
        /*mobile-20:5*/
        var cpro_id = &quot;u3493987&quot;;
        document.write(&quot;\&lt;script type=\&quot;text\/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/cm.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
    else
    {
         /*700*200信息流*/
        var cpro_id = &quot;u3469788&quot;;
        document.write(&quot;\&lt;script type=\&quot;text/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/c.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
&lt;/script&gt;

&lt;h6&gt;阶段3，图元装配&lt;/h6&gt;

&lt;p&gt;在顶点处理之后,顶点的全部属性都已经被确定 在这个阶段顶点将会根据应用程序送往的图元规则.&lt;/p&gt;

&lt;h6&gt;阶段4，图元处理(裁剪 消隐)&lt;/h6&gt;

&lt;p&gt;将图元与用户定义的裁剪平面和模型投影矩阵所建立的视景比较，裁剪且丢弃位于视景和裁剪平面外部的图元，不再予以处理。&lt;/p&gt;

&lt;p&gt;若是采用透视投影，那么将会对每个顶点的x,y,z坐标分别乘以透视矩阵。&lt;/p&gt;

&lt;p&gt;接着由视口变换将顶点坐标变换至窗口坐标。视口变换，即把投影变换后的顶点X,Y坐标，根据用户设定的视口参数，变换到屏幕上对应的坐标。&lt;/p&gt;

&lt;p&gt;最后执行消隐操作，把那些被遮挡的部分进行消除。&lt;/p&gt;

&lt;p&gt;消隐操作，即隐藏面消除，即使经过了裁剪操作，对于每个物体，摄像机只能看到正对着摄像机的一面，对背对着摄像机的一面是看不到的。&lt;/p&gt;

&lt;p&gt;这一步的任务就是把看不到的这一面消除掉，以免继续处理，影响计算机的性能和效率。&lt;/p&gt;

&lt;p&gt;为了确定一个多边形是正对着还是背对着摄像机，就要用到我们在输入集合阶段指定多边形时的顶点顺序了，默认情况下，D3D规定按顺时针指定的三角形属于正面，逆时针为背面。确定顺时针还是逆时针，可以用如下方法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    给出两个向量：E0=V1-V0 E1=V2-V0 对E0和E1进行叉乘操作N=E0XE1，如果N指向摄像机，则为正面，否则为背面。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;阶段5，栅格化&lt;/h6&gt;

&lt;p&gt;三维模型经过了顶点变换已经投影到了二维平面上，而且被装配成图元了，但是屏幕是一个一个细细小小的像素格子组成的，对于一个图片，电脑是怎么知道应该把它搞到哪几个像素上去显示的呢？这就是光栅化。说白了就是，把想看见的图片，搞成像素能显示的。光栅化工作告诉了显卡，哪个格子是你这个图元应该画上的哪个不是。&lt;/p&gt;

&lt;p&gt;传递过来的图元数据，在此将会被分解成更小的单元并对应帧缓冲区的各个像素，这些单元被称之为片元。一个片元可能包含窗口大小，深度，颜色，纹理坐标等属性。&lt;/p&gt;

&lt;p&gt;片元的属性是图元上顶点数据等经过插值而确定的，比如颜色，深度等。&lt;/p&gt;

&lt;p&gt;顶点属性的插值计算，在输入集合阶段用户指定的一系列的多边形，以三角形为例，每个三角形由三个顶点组成，每个顶点包含一系列的属性，如坐标，法线，纹理坐标等等，在经过顶点着色阶段，视口变换后，这个顶点在屏幕上都有对应的坐标。但为了显示该三角形，仅仅三个顶点显然是不够的，为了计算该三角形所覆盖的屏幕上每个像素的属性，要进行正确的插值计算，计算结果填充到片元中去。&lt;/p&gt;

&lt;h6&gt;阶段6，片元处理&lt;/h6&gt;

&lt;p&gt;这个阶段首先对片元上纹理，通过纹理坐标取得纹理内存中相对应的颜色。&lt;/p&gt;

&lt;p&gt;再进行雾化，通过片元与当前视点位置的距离修改颜色。&lt;/p&gt;

&lt;p&gt;最后颜色汇总，将纹理,主定义的颜色,雾化的颜色,次颜色光照阶段计算的颜色汇总一起。&lt;/p&gt;

&lt;p&gt;这个阶段就是vertex fragment着色器编程中 fragment 片元转换函数的处理阶段，fragment 片元函数通过这个阶段的编程对片元进行修改。&lt;/p&gt;

&lt;h6&gt;阶段7，像素操作（Pixel Operation）&lt;/h6&gt;

&lt;p&gt;所有的片元的测试都在这里进行，包括：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    像素所有权测试 -&amp;gt; 裁剪测试 -&amp;gt; alpha测试 -&amp;gt; 模板测试 -&amp;gt; 深度测试 -&amp;gt; 混合 -&amp;gt; 抖动显示 -&amp;gt; 逻辑操作
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;阶段8，帧缓冲区（Frame Buffer）&lt;/h6&gt;

&lt;p&gt;执行帧缓冲的写入等操作，写入帧缓冲区，等待最后产生了显示出来的像素。&lt;/p&gt;

&lt;p&gt;渲染管线的整个过程如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader11.png&quot; alt=&quot;render pipe&quot;&gt;&lt;/p&gt;

&lt;p&gt;上图中 vertex框就是可编程部分的 vertex 函数，它可以修改顶点部分的数据来表现个性化的效果，fragment框也是一样，是 fragment 函数的调用点，修改通过这个fragment函数可以修改片元数据达到需要的效果。&lt;/p&gt;

&lt;p&gt;Unity3D在渲染管线各阶段中所用到的功能，和我们前面所描述的阶段有很相似的地方，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader12.png&quot; alt=&quot;render pipe&quot;&gt;&lt;/p&gt;

&lt;p&gt;上图所要表达的功能和阶段，正是我们要在Shader章节中讲解和说明的部分。&lt;/p&gt;

&lt;p&gt;参考资料&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1，渲染管线流程 作者：不详

    2，【图形学】渲染管道 作者：阵雷
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
               <pubDate>Wed, 08 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/08/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader3.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/08/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader3.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第六章，网络层(三) - 实现UDP</title>
               <description>&lt;h3&gt;实现UDP&lt;/h3&gt;

&lt;p&gt;在前面介绍了如何实现TCP socket，下面要介绍下UDP的实现方式。&lt;/p&gt;

&lt;p&gt;其实两者都是长链接的方式，很多地方都有相识之处，比如两者都需要连接和断开事件支撑，都需要做发送和接收队列缓存，都需要定义数据包协议格式，都需要加密和校验。&lt;/p&gt;

&lt;p&gt;我们来说说TCP有而UDP没有的部分，以及需要我们在UDP上实现的功能。UDP和TCP相比，UDP基本就是TCP的阉割版本，很多TCP有的功能UDP都没有。相同的地方有，都是异步发送和接收，都需要多线程操作，发送和接收都需要缓冲队列，并且发送数据时都需要合并数据包。TCP有而UDP没有的地方有，UDP不会自己校验重发，丢包概率大，数据包接收顺序不确定，而且UDP本身没有连接断开检测机制，也没有连接确认机制。&lt;/p&gt;

&lt;p&gt;所以直接使用UDP来做网络连接，会遇到巨大的问题，可以说直接使用而不加修饰，不确定性太大基本用不了UDP。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h6&gt;连接确认机制&lt;/h6&gt;

&lt;p&gt;TCP有连接的三次握手协议，相当于在连接过程中跟服务器端协商后敲定我们已经建立了连接这个一致预期，而UDP是无状态链接，它并没有三次握手的协议，所以UDP连接其实是一厢情愿的，客户端并不知道是否真正连接成功了。&lt;/p&gt;

&lt;p&gt;所有发送和接受都是建立在连接确认的基础上的，所以我们必须先确认知道我们是否连接成功。能够判断连接是否成功是整个实现UDP的第一步，只有这样才能顺利得进行下面的数据包收发操作。&lt;/p&gt;

&lt;p&gt;怎么确认连接成功呢？&lt;/p&gt;

&lt;p&gt;首先我们来看看TCP连接的三次握手是怎么做的。&lt;/p&gt;

&lt;p&gt;1，  首先客户端向服务器端发送一个数据包，里面包含了Seq=0的变量，表示当前发送数据包的序列号为0，也就是第一个数据包。&lt;/p&gt;

&lt;p&gt;2，  服务器端收到客户端的数据包后，发现Seq=0，说明是第一个包，用来确认连接的，于是给客户端也发送了一个数据包，包含了Seq=0，和Ack=1，表示服务器端已经收到你的连接确认包了，并且回应包Ack序列标记为1。&lt;/p&gt;

&lt;p&gt;3，  客户端收到服务器端给的回应数据包后，知道了服务器端已经知道了我们已经建立连接，于是向服务器端发送了一个数据包，里面包含了Seq=1，Ack=1，表示确认数据包已经收到，连接已经确认，开始发送数据。&lt;/p&gt;

&lt;p&gt;这就是TCP的三次握手来确认连接的流程。&lt;/p&gt;

&lt;p&gt;在UDP下并没有三次握手机制，为了建立更好的确认连接机制，我们可以模仿TCP的形式来确认连接。不过第3次握手有点多余，可以省去最后一次握手的数据包，改为2次握手。步骤如下。&lt;/p&gt;

&lt;p&gt;首先在UDP连接后，在确认连接前不进行任何的其他类型的数据发送并且不接收任何其他数据，我们将这种发送数据包以确认连接成功与否的数据包称为握手包。&lt;/p&gt;

&lt;p&gt;在建立连接后，客户端先向服务器端发送一个握手数据包，代表客户端向服务器端请求连接确认信号的数据包，包内的数据仅仅是一个序列号Seq=0，或者不是序列号也可以，而是一个特殊的字段。当服务器端收到这个握手数据包后，也就是实现了第一次握手。&lt;/p&gt;

&lt;p&gt;服务器端在收到第一次握手数据包后，回应一个握手数据包，里面同样带有客户端能识别的连接确认信号。当客户端接收到时就说明，发出去给服务器端的连接确认数据包有了回应，也就是说第二次握手成功。接收到了第二次握手连接确认响应数据包时，就表明了连接已经成功建立。&lt;/p&gt;

&lt;p&gt;UDP确认连接的整个握手过程，就相当于客户端和服务器端的一次交流，相互认识一下并且示意后面的交流将要开始。&lt;/p&gt;

&lt;p&gt;实现UDP连接确认具体步骤（伪代码）：&lt;/p&gt;

&lt;p&gt;1，  首先使用API建立UDP连接。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SvrEndPoint&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IPEndPoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IPAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;UdpClient&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UdpClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;UdpClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SvrEndPoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;2，  启动接收数据线程。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UdpClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BeginReceive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReceiveCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ReceiveCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IAsyncResult&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mIPEndPoint&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;UdpClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Receive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mIPEndPoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;UdpClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EndReceive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mIPEndPoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;OnData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mUdpClient&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// try to receive again.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mUdpClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BeginReceive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReceiveCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;3，  发送连接确认数据包，并屏蔽其他发送和接收功能。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SendConnectRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;StopSendNormalPackage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;StopReceiveNormalPackage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;4，  等待接收连接确认数据包。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;If&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsConnected&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;If&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IsConnectResponse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;OnEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConnectSuccess&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;IsConnected&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ProcessNormalData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;5，  连接确认包收到，确认连接已经成功建立。开启发送和接收数据包的功能。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ProcessNormalData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;If&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsConnected&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;DealNetworkData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;经过与服务器端数据包的来回，UDP完成了2次握手的确认机制，已经可以认定为连接已经成功建立。&lt;/p&gt;

&lt;h6&gt;断开连接判定机制&lt;/h6&gt;

&lt;p&gt;UDP自己不能判断是否断开，因为它是无状态的连接，需要我们自己来做断线检测，检测的方式与TCP的心跳包类似。&lt;/p&gt;

&lt;p&gt;断开连接的判定机制，也是用数据包来回的形式，不过不是单一一个数据包，而是长时间的心跳包的形式来做持续性的判断连接状态。&lt;/p&gt;

&lt;p&gt;首先，我们要与服务器端有个协定，每隔X秒（比如5秒）发送一个心跳数据包给服务器端，这个客户端发送的心跳数据包里包含了一些客户端信息，包括ID，角色状态，设备信息等，包体不能太大，否则会就加重了宽带负担。&lt;/p&gt;

&lt;p&gt;当服务器端收到心跳数据包时，也立刻回复一个心跳数据回应包，里面包含了，服务器端当前时间，服务器端当前状态等信息。&lt;/p&gt;

&lt;p&gt;当客户端收到此数据包时，说明连接尚在，也能同时同步服务器端的时间和一些基础的信息。&lt;/p&gt;

&lt;p&gt;如果客户端很久没有收到心跳数据回应包时，就表明，连接已经断开了，比如30秒没收到心跳包，可以判断连接已经断开。&lt;/p&gt;

&lt;p&gt;服务器端也是一样操作，当没有收到心跳包很久，就表明客户端的连接已经断开。这时客户端就可以开启相应的重连程序，或重连提示以及步骤。&lt;/p&gt;

&lt;p&gt;具体步骤如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1，  每隔X秒向服务器端发送心跳数据包。

    2，  服务器端收到心跳数据包后回复心跳响应数据包。

    3，  如果，客户端和服务器端都很久没有收到心跳数据包，比如30秒，则判定连接断开。

    4，  主动断开连接，客户端提示用户，或者重新创建连接，服务器端则是处理与之相关数据的处理。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))
    { //移动端
        /*mobile-20:5*/
        var cpro_id = &quot;u3493987&quot;;
        document.write(&quot;\&lt;script type=\&quot;text\/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/cm.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
    else
    {
         /*700*200信息流*/
        var cpro_id = &quot;u3469788&quot;;
        document.write(&quot;\&lt;script type=\&quot;text/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/c.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
&lt;/script&gt;

&lt;h6&gt;数据包校验与重发机制&lt;/h6&gt;

&lt;p&gt;前面说UDP相当于是TCP的阉割版，而最关键的阉割部分就是校验和重发机制。&lt;/p&gt;

&lt;p&gt;没有校验和重发机制，意味着发送端无法知道数据包的发送是否到达或者丢失，甚至丢失了也无法重新发送的机制来补充丢失的数据包。&lt;/p&gt;

&lt;p&gt;所以我们需要自己编写增加对数据的校验和重发机制，来确保数据的可靠性。&lt;/p&gt;

&lt;p&gt;TCP有校验和重发机制，我们可以模仿它的校验和重发机制在UDP上使用，再在此基础上加以改进。这样我们即有了UDP的速度，又有了TCP的可靠性。&lt;/p&gt;

&lt;p&gt;我们来看TCP是如何做数据包的校验和重发的。&lt;/p&gt;

&lt;p&gt;关于Seq和Ack。Seq即Sequence Number，为源端（source）的发送序列号；Ack即Acknowledgment Number，为目的端（destination）的接收确认序列号。&lt;/p&gt;

&lt;p&gt;1，  首先客户端向服务器端发送数据包，里面包含Seq(sequence number)序列号为1(已经发送的数据包的累计大小)，发送的数据包大小为比如264。&lt;/p&gt;

&lt;p&gt;2，  服务器端收数据包后就知道了当前连接的这个数据包的序号为1，也就是连接后第一个数据包。于是向客户端发送了一个确认包，确认包中包含了的Ack=264(接收到的数据包的累计大小)，告诉客户端我服务器端已经收到了数据包，现在累计大小为264的数据包。如果累计大小错误，就需要启动重传机制，退回到最后一次正确的的数据包位置，进行重传，以保证可靠性。&lt;/p&gt;

&lt;p&gt;3，  当客户端再次发送数据包时，里面包含的Seq序列号为265，意思为发送累计数据大小，这次发送的数据包大小为100，服务器端接收到后向客户端发送确认包，确认包中，包含了Ack=365，意思是已经累计收到数据包大小为365。如果累计大小错误，请启动重传机制，确保可靠性。&lt;/p&gt;

&lt;p&gt;4，  接下来由服务器端向客户端发送数据。服务器端向客户端发送数据也是同样的方法和步骤。数据包中包含了服务器端的Seq(已经发送的数据包大小)，比如累计发送了1，seq=1，这次数据包大小为585，客户端接收到服务器端的数据包后，向服务器端发送确认包，包中包含了服务器端发过来的Ack  =586，服务器端收到确认包后，就知道了累计接收的数据包大小已经到了585，也就是说当前的数据包已经发送成功。&lt;/p&gt;

&lt;p&gt;若在规定的时间内收到响应Seq序列号和Ack，表明该报文发送成功，可以发送下一个报文Seq；否则重传（TCP Retransmitssion）。序列号确认机制是TCP可靠性传输的保障。&lt;/p&gt;

&lt;p&gt;借鉴TCP的方法，UDP也可以用此方法来做检测和重传。但是大小累计的检测方式重传的效率太差，不能准确快速的定位重传的数据包，甚至有些已经到达的数据，因为中间数据包的丢包，导致已经到达的数据也需要重传，来确保可靠性。&lt;/p&gt;

&lt;p&gt;在实现UDP的检测和重传时，我们可以进行如下的改进。&lt;/p&gt;

&lt;p&gt;1，  客户端向服务器端发送数据包，数据包中包含Seq=1(表示数据包的发送序列)，发送后将此数据包推入到已经发送但还没有确认的队列里。&lt;/p&gt;

&lt;p&gt;如果服务器接收到Seq=1的数据包，就回应客户端一个确认包，包中Ack=1，表示Seq=1的包已经确认收到。&lt;/p&gt;

&lt;p&gt;如果服务器端没有接收到数据，客户端X秒后发现并没有收到Seq为1的确认包，判定为Seq=1的数据包传输失败，从已经发送但未确认的数据包队列中取出Seq=1的数据包，重新发送。&lt;/p&gt;

&lt;p&gt;2，  客户端向服务器端发送了10个数据包，分别是Seq=1，2，3，4，5，6，7，8，9，10，服务器收到的序列是，1，3，4，5，7，8，9，10，其中有2，6，没有收到数据包。&lt;/p&gt;

&lt;p&gt;客户端在等待确认包超时后，对2，6进行重传。在服务器端接收到数据包后，在处理数据包时，如果数据包顺序有跳跃的现象就表明数据包丢失，等待客户端重传，这时就在断开的序列处停止处理数据包，进行等待操作。&lt;/p&gt;

&lt;p&gt;3，  加快重传确认时间。客户端向服务器端发送5个数据包，分别是Seq=1，2，3，4，5，服务器端收到的包是1，3，4，5，当收到3时，发现2被跳过1次，当收到4时发现2被跳过2次，立刻启动2的重传，不在等确认超时，加快丢包重传速度。&lt;/p&gt;

&lt;h6&gt;丢包问题分析&lt;/h6&gt;

&lt;p&gt;UDP丢包多是很正常现象，这是UDP牺牲质量而提高速度的代价。UDP丢包的原因很多，我们这里做个分析。&lt;/p&gt;

&lt;p&gt;1，  接收端处理时间过长导致丢包：&lt;/p&gt;

&lt;p&gt;调用recv方法接收端收到数据后，处理数据花了一些时间，处理完后再次调用recv方法，在这二次调用间隔里，发过来的包可能丢失。&lt;/p&gt;

&lt;p&gt;对于这种情况可以修改接收端，将包接收后存入一个缓冲区，然后迅速返回继续recv。或者使用前面提到的双队列机制，来缩短锁队列的时间，从而解放了处理包的时间和接收数据包的线程之间的冲突。&lt;/p&gt;

&lt;p&gt;2，  发送的包巨大丢包：&lt;/p&gt;

&lt;p&gt;虽然Send方法会帮你做大包切割成小包发送的事情，但包太大也不行。&lt;/p&gt;

&lt;p&gt;例如超过50K的一个udp包，不切割直接通过send方法发送也会导致这个包丢失。&lt;/p&gt;

&lt;p&gt;发送的包较大，超过接受者缓存导致丢包：包超过mtu size数倍，几个大的udp包可能会超过接收者的缓冲，导致丢包。&lt;/p&gt;

&lt;p&gt;这种情况需要切割成小包再逐个send。报文过大的问题，可以通过控制报文大小来解决，使得每个报文的长度小于MTU。&lt;/p&gt;

&lt;p&gt;以太网的MTU通常是1500 bytes，其他一些诸如拨号连接的网络MTU值为1280 bytes，如果使用speaking这样很难得到MTU的网络，那么最好将报文长度控制在1280 bytes以下。&lt;/p&gt;

&lt;p&gt;3，  发送的包频率太快：&lt;/p&gt;

&lt;p&gt;虽然每个包的大小都小于mtu size 但是频率太快，例如40多个mut size的包连续发送中间不sleep，也有可能导致丢包。&lt;/p&gt;

&lt;p&gt;这种情况可以通过建立Socket接收缓冲队列解决，和建立发送缓冲队列来解决，并且在发送频率过快的时候考虑Sleep作为时间间隔。&lt;/p&gt;

&lt;p&gt;很多人会不理解发送速度过快为什么会产生丢包，原因就是UDP的SendTo不会造成线程阻塞，也就是说，UDP的SentTo不会像TCP中的SendTo那样，直到数据完全发送才会return回调用函数，它不保证当执行下一条语句时数据是否被发送。（SendTo方法是异步的）&lt;/p&gt;

&lt;p&gt;如果要发送的数据过多或者过大，那么在缓冲区满的那个瞬间要发送的报文就很有可能被丢失。至于对“过快”的解释，作者这样说：“A few packets a second are not an issue; hundreds or thousands may be an issue.”（一秒钟几个数据包不算什么，但是一秒钟成百上千的数据包就不好办了）。 &lt;/p&gt;

&lt;p&gt;要解决接收方丢包的问题很简单，首先要保证程序执行后马上开始监听（如果数据包不确定什么时候发过来的话），其次，要在收到一个数据包后最短的时间内重新回到监听状态，其间要尽量避免复杂的操作（比较好的解决办法是使用多线程回调机制）。&lt;/p&gt;

&lt;p&gt;以上是UDP的实现细节，同时阐述了UDP的实现难点和注意点。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1， 基于TCp的数据包传输过程
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
               <pubDate>Tue, 07 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/07/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%823.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/07/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%823.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第六章，网络层(二) - 实现TCP</title>
               <description>&lt;h3&gt;实现TCP长连接。&lt;/h3&gt;

&lt;p&gt;我们先从整体出发，列一下Unity3D实现TCP连接需要的实现哪些方面：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1， 建立连接

    2， 断线检测

    3， 网络协议

    4， 发送和接收队列缓冲

    5， 发送数据合并

    6， 线程死锁策略
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;TCP本身已经有数据包可靠性确认，以及丢包重发机制，数据包的大小也没有限时，我们可以把这些功能称之为免费得到的功能。&lt;/p&gt;

&lt;p&gt;所以在实现TCP的连接中不需要我们再做包体的校验，切割包体，以及重发数据包，省掉了很大一部分麻烦。&lt;/p&gt;

&lt;p&gt;我们只需要做的就是建立连接，发送，以及接收。不过如果不对发送数据进行合并，就会有很多小的数据分批发送，导致发送效率低下。所以我们下文中会提到关于发送合并的问题。&lt;/p&gt;

&lt;p&gt;简单介绍下TCP的API库&lt;/p&gt;

&lt;p&gt;c#的.net库提供了TCP的Socket连接API，我们来看看c#的.net库中的这些API。&lt;/p&gt;

&lt;p&gt;理论上你不会去用阻塞方式连接和接收，因为你不会让你的游戏卡住不动来等待连接，这有可能导致崩溃，所以连接，接收，断开，都是异步的线程操作。同步阻塞的操作可能会周边的工具中会用到，比如编辑器的工具，回放工具，GM的工具等，其他大部分时候都希望异步操作网络连接。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    BeginConnect，开始连接

    BeginReceive，开始接收信息

    BeginSend，开始发送数据

    BeginDisconnect，开始断开

    Disconnect(Boolean)，立刻断开连接
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前四个都是异步的，调用后会开启一个线程来工作，最后一个是同步阻塞式的断开连接。最后一个阻塞式大都在游戏退出时调用，但APP没有退出事件，所以最后一个一般都在Unity3D Eitor下或者windows版本上调用，以保证在开发时强制退出后编辑器不会奔溃。&lt;/p&gt;

&lt;h6&gt;线程锁&lt;/h6&gt;

&lt;p&gt;网络部分基本上所有的操作都是线程级别的，Unity3D的渲染和逻辑是在主线程上运作的，这里就涉及到了主线程和子线程的资源线程锁的问题。&lt;/p&gt;

&lt;p&gt;主线程与子线程一起工作时，如果都需要某个内存块，或者资源，就会同时去读取或者写入资源，这就是造成死锁的情况的根源。因此在调用有冲突的资源时，需要做锁的操作，用以防止线程们在读取或写入操作时对资源错误的争夺。&lt;/p&gt;

&lt;p&gt;例如接收线程，接收到网络数据后将数据push到队列时，在push操作上做锁操作：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;或者主线程在读取网络数据时，在推出一个数据时，在Pop的操作上加一个锁的操作。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;每次对线程共享的资源进行操作时，都需要先进行锁确认的操作，以避免线程争夺资源而造成死锁。&lt;/p&gt;

&lt;h6&gt;缓冲队列&lt;/h6&gt;

&lt;p&gt;网络游戏中，数据会远远不断进行发送和接收，很多时候程序还没处理好当前的数据包，就已经有很多数据包从服务器传送到达了客户端。发送数据也是一样，会瞬间积累很多的需要发送的数据包，所以需要用队列来进行存储和缓冲。&lt;/p&gt;

&lt;p&gt;负责接收的子线程把接收好的网络数据包放入接收缓冲队列，主线程通过Update轮训去检查接收队列里是否有数据，有的话就一个个取出来处理，没有的话继续轮训等待。&lt;/p&gt;

&lt;p&gt;如下面伪代码表达了，主线程每帧检查一下是否有收到信息，检测到就立刻处理，没有的话下一帧继续轮训检测。如果没有信息接收来时，子线程上会阻塞等待直到有消息接收到才会调用接收消息接口，将数据包解析后推入接收队列。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;/////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//接收线程等待接收数据并推入队列&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BeginReceive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Receive_Callback&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LogerType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ERROR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StackTrace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DisConnect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Receive_CallBack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IAsyncResult&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;_result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PushNetworkData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//将数据推入队列&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Receive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//继续接收数据消息&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;///////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//主线程处理数据队列里的数据&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;While&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PopNetworkData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;DealNetworkData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;上面的伪代码中，首先有子线程的等待接收数据，接收到以后就立即将数据推入队列。另一面，主线程一直在轮询是否有已经接收到的网络数据，如果有就立即逐个处理全部数据。&lt;/p&gt;

&lt;h6&gt;双队列结构&lt;/h6&gt;

&lt;p&gt;这里介绍一下双队列数据结构，它能增加些许多线程中队列的读写效率。&lt;/p&gt;

&lt;p&gt;双队列是一种高效的内存数据结构，在多线程编程中，能保证生产者线程的写入和消费者的读出尽量做到最低的影响，避免了共享队列的锁开销。&lt;/p&gt;

&lt;p&gt;具体什么意思呢？其实很简单。&lt;/p&gt;

&lt;p&gt;多个线程都需要对队列读写，接收数据的网络线程会将数据写入队列，而处理数据的主线程会读取队列并删除顶头的一个，两者都会读写队列，导致资源争夺。&lt;/p&gt;

&lt;p&gt;加入了线程锁的机制后，仍然没能很好的解决两个线程同时操作一个队列的问题。例如假设处理数据的主线程需要花很久的时间去处理网络数据，这时接收数据的线程因为接收队列被主线程锁住不能继续自己的接收数据的操作，所以子线程被等待资源使用完毕后才能使用资源，如果这个数据很多很大很耗时，那么子线程就要等很少时间，大大降低了线程了效率。&lt;/p&gt;

&lt;p&gt;用双队列的形式就能让线程处理队列时解放出来，让线程的效率大大增加，使得各线程能够各自处理调用各自的队列处理而不用因为资源锁而等待。&lt;/p&gt;

&lt;p&gt;双队列是如何做到的呢？前面接收数据包部分都是一样的，接收数据线程接收到数据时直接推入接收数据的队列，不一样的地方在，当处理数据的线程轮询时，先将接收数据的队列拷贝到处理数据的队列中并清空接收数据的队列，主线再对拷贝后的数据队列进行处理，于是子线程能够顺利的继续接收数据而无需等待接收队列这个资源。这样就解放了两边的冲突时间了，各自只要处理自己的队列就可以了。&lt;/p&gt;

&lt;p&gt;伪代码如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;/////////////////////////////////////////////&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//子线程中，接收数据线程&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Receive_CallBack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Pushdata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;/////////////////////////////////////////&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//处理数据的主线程&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SwitchQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;receiveQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;produceQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SwitchQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PopQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Deal_with_network_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;伪代码中，首先是对子线程的接收部分描述，当接收到数据包时push到接收队列中，而当主线程需要处理数据时，先切换队列，防止对队列占用过多时间，切换完毕后，再对队列中的全部数据进行处理。&lt;/p&gt;

&lt;p&gt;这样一来，锁的时间变短了，原本要在处理期间全程上锁导致其他线程无法使用，现在只在切换那一瞬间锁上资源，其他时间各线程都能顺畅得各自做自己的工作，大大提高了线程的效率。&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))
    { //移动端
        /*mobile-20:5*/
        var cpro_id = &quot;u3493987&quot;;
        document.write(&quot;\&lt;script type=\&quot;text\/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/cm.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
    else
    {
         /*700*200信息流*/
        var cpro_id = &quot;u3469788&quot;;
        document.write(&quot;\&lt;script type=\&quot;text/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/c.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
&lt;/script&gt;

&lt;h6&gt;发送数据&lt;/h6&gt;

&lt;p&gt;我们前面说发送数据时也需要队列来做缓冲，因为发送的数据包会很多，也有可能很短时间内会积累很多数据包。&lt;/p&gt;

&lt;p&gt;另外，发送时大多数的数据包都是很小很小的数据包，如果每个数据包都发送一次等待接受后再发送就会导致发送效率过低，发送太慢导致延迟过大。&lt;/p&gt;

&lt;p&gt;而如果一下子把全部数据都发送的话，发送的数据可能会太大，导致发送效率很差，因为数据包越大越容易发送失败或丢包，TCP就会全盘否定这次发送的内容，并将整个包都重新发送一次，效率极其糟糕。&lt;/p&gt;

&lt;p&gt;所以我们需要自己建立发送缓冲来保证发送的有序和高效，发送队列以及对发送数据的合并就是很好的策略。&lt;/p&gt;

&lt;p&gt;步骤如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1，每次当你调用发送接口时会把数据包塞入发送队列，发送程序就开始轮训是否有需要发送的信息在队列里，有的话就发送，没有的话就继续轮训等待。

    2，发送时，合并队列里的所有数据包，准备一次性发送多个数据包以提高效率。

    3，对这种合并操作做个限制，如果因为合并而导致数据包太大，也会导致效率差。发送过程中，只要丢失一个数据就要全盘重新发送，数据包很大的话，发送本来就很缓慢的情况下，又重新整体重新发送，就会使得发送效率大大降低。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们既要合并数据包，又不能让数据包太大，这样才能保证发送的效率比较高。&lt;/p&gt;

&lt;p&gt;比如我们做个合并后的数据包大小限制不得超过10K。这样每个数据包大小都处于10K以下的大小，除非单个包大于10K就让他单独发送，且每次发送包含了多个数据包，这样发送效率就有了一定的保证。&lt;/p&gt;

&lt;h6&gt;协议数据定义标准&lt;/h6&gt;

&lt;p&gt;在网络数据传输中协议是比较重要的一个关键点，它是客户端与服务器交流的语言。&lt;/p&gt;

&lt;p&gt;什么是协议，简单来说就是客户端和服务器端商讨后达成一个对数据格式的协定，是客户端与服务器进行交流的语言，比如两边都用Json格式的协议来传输数据。这样两边在发送和收到数据时，都能够按照一定的规则识别数据了。&lt;/p&gt;

&lt;p&gt;我们在实现TCP里需要对协议进行商讨，那么在商讨协议的过程中，关键点是什么呢？&lt;/p&gt;

&lt;p&gt;1，    客户端和服务器都能接受的格式。并不是所有的格式都适合，选择中意的，前后端都能接受的协议格式才是最重要的，因为合作最重要，个人力量和一个协议格式的力量与团体来说都是渺小的。在团队的都理解和一致的情况下，再对协议进行精进，选择更好更高效的协议。&lt;/p&gt;

&lt;p&gt;2，    数据包体大小最小化。尽可能的减少包体大小，选择一些能节省包大小空间的格式，比如google protocol buffer。或者对包主体部分使用压缩算法，我不建议只加压缩算法而不改变协议本身，因为会导致对压缩算法过度依赖而省略了协议本身的浪费空间，比如你用了压缩算法后发现xml或json格式的协议也还过得去就不再更改协议本身了，这样就会导致后期数据量大时数据包变得很大很沉重，传输效率降低。但很多老项目和一些为了加快速度而不去更改协议的项目情况时常发生，所以只启用压缩算法而不改变协议本身很多时候也是无奈之举。&lt;/p&gt;

&lt;p&gt;3，    需要有一定的校验能力。当数据包体不完整时，或者本身包体后面连接着另外的数据包时，能够有校验能力，和识别完整包体范围的能力。很多时候我们在传输数据的时候，收到的并不是一个完整的包体，或者因为网络关系，收到了错误的，甚至被攥改过的数据，我们要有能力去校验他们。&lt;/p&gt;

&lt;p&gt;4，    加密。为了保证网络数据包不被篡改和查看，导致外挂破坏整个游戏平衡，我们需要对发送的网络数据包中的主体部分进行加密。加密算法很多，这里不一一介绍，最简单方式就是对数据做异或处理，发送时做异或处理一次，收到时做一次异或处理，这样就能简单加密解密数据。前面说的这种方式比较单板，因为密钥Key是同一个，而且密钥KEY会暴露在客户端会被查看到，于是非对称加密是加密的首选，这样前后端两边的密钥Key不同且各自保存，即使当后端密钥泄漏时，也可以随时替换。&lt;/p&gt;

&lt;p&gt;我们这里主要聊一下网络数据包的校验能力，各种包体的协议格式下面的章节中会具体讲解，加密也同样会在最后的几节部分做出详细的介绍。&lt;/p&gt;

&lt;p&gt;在接收数据的时候，有时候会是一个不完整的包，或者一个包后面跟着另一段不完整的包，怎么办，怎么识别哪里是头，哪里是尾？嗯，这就有了数据格式的意义，通常的长连接数据格式，以头和数据块，两部分组成，比如头用4个字节组成，这4个字节是数据块得大小size，这样后面数据块得大小就能知道了，因为每次拿到网络数据的时候我先取4个字节，然后就知道了后面数据块大小，再读取size大小的数据块，这样就拿到了数据信息。
再做的复杂点，可以分成，头、固定标识信息、数据块，三个部分。头，存储包体大小信息；标识信息，存储例如句柄编号，序列号，特殊命令编号，校验码等的标识信息；数据块，存储具体的数据信息。&lt;/p&gt;

&lt;p&gt;TCP本身有做一些校验的工作，但为了防止数据被人为攥改、网络错误、以及逻辑本身的错误检测，我们需要做额外的校验工作。&lt;/p&gt;

&lt;p&gt;通常方法有几种&lt;/p&gt;

&lt;p&gt;1，    MD5校验。这种校验方式比较直接，将数据块整个用MD5散列函数生成一个校验字符串，将校验字符串保存在数据包中。当服务器收到数据包时，也做同样的操作，将数据块用MD5散列函数生成一个校验字符串，与数据包中的校验字符串进行比较，如果一致，则认为校验通过，否则就认为被人为修改过。&lt;/p&gt;

&lt;p&gt;2，    奇偶校验。奇偶校验与MD5有点类似，只是所用的函数方法不同。对每个数据进行异或赋值成一个变量，将这个变量保存在数据包中。当服务器收到数据包时，也做同样的操作，将数据快中的数据进行异或赋值成一个变量，然后将这个变量值与数据包中的校验值进行比较，如果数据一致则认为校验正确，否则则认为数据被人攥改过。&lt;/p&gt;

&lt;p&gt;这个校验算法类似于：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uCRC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//校验初始值&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DataLenth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uCRC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;^=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;3，    CRC循环冗余校验。循环冗余校验是利用除法及余数的原理来进行错误检测的.将接收到的码组进行除法运算，如果除尽，则说明数据校验正确；如果未除尽，则表明数据被认为攥改过。&lt;/p&gt;

&lt;p&gt;该算法过程如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1，    前后端约定一个除数。

    2，    将数据块用除数取余。

    3，    将余数保存在数据包中。

    4，    服务器收到数据后，将余数和数据块相加，并进行取余操作。

    5，    余数为0则认为校验正确，否则则认为数据被攥改过。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;断线检测&lt;/h6&gt;

&lt;p&gt;TCP本身就是强连接，所以自身就有断线的检测机制，但是它本身的检测机制还不够用，对断线的判断不够准确，所以我们需要加强断线检测机制，让断线判断变的更加准确和即使。&lt;/p&gt;

&lt;p&gt;为了能有效检测TCP连接是否正常，我们需要服务器和客户端达成一个协议来检测连接。我们可以取名叫心跳包协议，在心跳包协议中，每几秒服务器向客户端发送一个心跳包，包内包含了服务器时间，服务器状态等信息，然后再由客户端发送给服务器一个心跳回应包，包内包含客户端的一些信息例如客户端状态，用户信息等，这样客户端和服务器就都知道连接是有响应的，当前是连接正常。&lt;/p&gt;

&lt;p&gt;倘若没有收到心跳包和心跳回应包，就表示连接存在问题了，有可能已经断开。为了规避一些时候网络的波动，我们可以设置一个有效判断断开连接的时间间隔，比如，10秒内没有收到心跳包和心跳回应包，就表示连接已经断开，这时服务器和客户端主动断开连接，再根据游戏的逻辑寻求再次连接。&lt;/p&gt;

&lt;p&gt;这种在TCP之上，加强断线检测的做法，能更有效快速得检测到断线问题。&lt;/p&gt;
</description>
               <pubDate>Tue, 07 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/07/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%822.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/07/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%822.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，Shader(二) - Property</title>
               <description>&lt;h3&gt;编写Shader的几种方式&lt;/h3&gt;

&lt;p&gt;着色器部分的编写是客户端的精髓，如果说架构表现了逻辑整合能力，算法展现了数学能力，那么着色器编写展现了表现能力，在游戏项目中三者缺一不可，特别是作为主程或者说资深的U3D人员来说是极其重要的。&lt;/p&gt;

&lt;p&gt;Unity3D使用了自己创造的语言命名为ShaderLab来编写图形Shader。在ShaderLab里模拟了类似CgFX和Direct3D Effects(.FX)的语言，从而可以编写绝大部分的图形渲染材质。&lt;/p&gt;

&lt;p&gt;ShaderLab编写的Shader属性会在Unity的材质球编辑器中显示，ShaderLab可以实现基于多种目标硬件的能力，并且每个ShaderLab完全能够编写图形硬件渲染状态，以及使用vertex和fragment编程。Shader的编写是基于高级Cg/HLSL编程语言基础上的。&lt;/p&gt;

&lt;p&gt;下面几节中，我们会详细的讲解，如何用ShaderLab去写Unity Shader，包括Surface Shader, fixed-function Shader,vertex和fragment的Shader编程。&lt;/p&gt;

&lt;p&gt;Shader编程需要一些基本的OpenGL或Direct3D渲染状态的知识，还有一些HLSL,Cg,GLSL或者Metal Shader编程语言的知识。如果并没有掌握也没有关系，我们将以通俗易懂的语言解释大部分的图形渲染知识。&lt;/p&gt;

&lt;p&gt;编写Unity Shader的几种形式：&lt;/p&gt;

&lt;h6&gt;1，fixed-function，这种形式的Shader使用了Unity自己编制的比较简单的图形语言来编写Shader。&lt;/h6&gt;

&lt;p&gt;编写完毕后在导入和编译时，Unity内部会将这个fixed-function形式的代码，转化成vertex和fragment编程形式。&lt;/p&gt;

&lt;p&gt;因为fixed-function形式编写起来比较简单易懂，所以一些简单的Shader可以用fixed-function来编写，可以节省很多学习底层图形学的时间也增加了不少效率。缺点是，功能并不是很全，复杂一点的或者说个性化点的Shader就需要用其他的方式实现。&lt;/p&gt;

&lt;h6&gt;2，Surface shaders 是Unity建立的一种新的Shader编程方式，目的是让Shader编程更加简单。&lt;/h6&gt;

&lt;p&gt;在Surface Shader里没有任何的自定义语言，贴图，或者变量。它会生成所有你需要手写的代码，让你专注于编写渲染部分的规则，其中一个特色是Surface Shader不需要写Pass，它会自动帮你编译成为多个你需要的多个Pass。&lt;/p&gt;

&lt;p&gt;Surface Shader编译器最终会将所有代码转换成vertex-fragment类型的Shader。&lt;/p&gt;

&lt;h6&gt;3，vertex and fragment shaders是ShaderLab Shader包含的几种不同的编写方式中最最底层的编码方式，它使用的HLSL语言编程，我们称之为底层硬件着色器着色编程。&lt;/h6&gt;

&lt;p&gt;使用vertex-fragment方式只是ShaderLab的理念中的其中一部分，fixed-function和suface都是其理念的一部分，并不一定说要使用vertex-fragment底层的才好，其他方式也同样能帮助你节省很多时间。&lt;/p&gt;

&lt;p&gt;比如你想对灯光作用进行着色编程，你完全可以使用Surface Shader去实现你的想法，如果只想对贴图上色和混合，你使用fixed-function更为简单省事，如果你想对顶点颜色，或对顶点坐标进行更改，或者片元的着色需要更改等一些更复杂的图形操作，那你就需要使用vertex-fragment Shader进行编程。&lt;/p&gt;

&lt;p&gt;针对不同的复杂度，不同的项目，不同领域的着色渲染，我们完全可以选择不同的方式来编写Shader。&lt;/p&gt;

&lt;p&gt;无论你用哪种方式编写Shader，其实都是在ShaderLab语言结构下的，前面说过ShaderLab是Unity指定的组织Shader的官方编程语言，所以在Unity编写Shader首先要学会如何使用ShaderLab。&lt;/p&gt;

&lt;p&gt;了解了基本的ShaderLab语言结构和语法，再去学习surface和vertex-fragment就会相对比较容易。而fixed-function是完全基于ShaderLab语法结构编写的，所以fixed-function形式的写法完全可以参照ShaderLab的使用方法来编写。&lt;/p&gt;

&lt;h3&gt;ShaderLab语法与参数详解&lt;/h3&gt;

&lt;p&gt;我们需要着重介绍下ShaderLab的格式，Unity3D中所有的Shader编程方式都是基于ShaderLab的，因此ShaderLab语法是基础。&lt;/p&gt;

&lt;h6&gt;Shader的开头&lt;/h6&gt;

&lt;p&gt;“Shader” 是Shader文件的根命令。每个文件必须定义一个且只有一个Shade命令，它可以定义一个Shader的名字，是一个Shader的开头。&lt;/p&gt;

&lt;p&gt;在“Shader”里面你才可以表达有哪些属性，有哪些渲染模式被开启和关闭，有多少条渲染管线等等那些你需要的定义以及变化。&lt;/p&gt;

&lt;p&gt;格式：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Shader “name”
    {
        [Properties属性]
        Subshaders
        [Fallback]
        [CustomEditor]
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义了一个Shader后，Shader的Name就会出现在Unity编辑器的材质球视窗的Shader列表里，可供你选择。Shader中定义的属性，供Shader计算使用，并且这些属性会显示在材质球编辑器的视窗中。&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))
    { //移动端
        /*mobile-20:5*/
        var cpro_id = &quot;u3493987&quot;;
        document.write(&quot;\&lt;script type=\&quot;text\/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/cm.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
    else
    {
         /*700*200信息流*/
        var cpro_id = &quot;u3469788&quot;;
        document.write(&quot;\&lt;script type=\&quot;text/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/c.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
&lt;/script&gt;

&lt;h6&gt;Properties属性&lt;/h6&gt;

&lt;p&gt;Shader中可以自己定义一些属性用来在后面的渲染计算中使用。比如数字，颜色，方向，坐标，贴图。&lt;/p&gt;

&lt;p&gt;Properties格式：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Properties
    {
        PropertyName1 (“display name名字”，type类型) = value默认值
        PropertyName2 (“display name名字”，type类型) = value默认值
        PropertyName3 (“display name名字”，type类型) = value默认值
        …
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Properties属性格式需要中括号框起来，大括号内都是属性的详细说明。&lt;/p&gt;

&lt;p&gt;其中PropertyName和 display name是不一样的，Property Name是属性的真正名字，可以用来通过材质球才程序中更改和赋值，或者在后面的渲染计算中使用。而display name 只是在编辑器中显示该属性名的名字，没有其他用途。&lt;/p&gt;

&lt;p&gt;下面举例来说明各种类型的书写方式。&lt;/p&gt;

&lt;p&gt;数字&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Name属性名 (“display name显示名”, Range(最小值,最大值)) = 默认值

    上述属性块定义了一个数字，起始有一个默认值，该值可以在最大值和最小值范围内，不得超出最大和最小值，定义后可以在材质球的编辑器中滑动的来选择值的大小。

    Name属性名 (“display name显示名”, Float) = 默认值

    上述属性块定义了一个浮点数数值，具有一个默认值，同样定义后，可以在材质球的编辑器中输入浮点数来重新赋值。

    Name属性名 (“display name显示名”, Int) = 默认值

    上述属性块定义了一个整数数值，具有一个默认值，同样定义后，可以在材质球的编辑器中输入整数来重新赋值。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;颜色&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Name属性名 (“display name显示名”, Color) = (R,G,B,A)

    上述属性块定义了一个颜色，具有一个RGBA(红，绿，黑，alpha)的默认值，定义后可以在材质球的编辑器中选择一个颜色来重新赋值。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方向和坐标&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Name属性名 (“display name显示名”, Vector) = (0,0,0,0)

    上述属性块定义了一个方向或者坐标，具有一个默认值，定义后可以在材质球的编辑器中填写4个值来重新赋值。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;贴图&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Name属性名 (“display name显示名”, 2D) = “white” {}

    上述属性块定义了一个2D贴图，具有一个纯白色的默认贴图，定义后可以在材质球的编辑器中选择新的贴图来重新赋值。

    Name属性名 (“display name显示名”, Cube) = {}

    上述属性块定义了一个Cube镜面盒子，空的默认值，定义后可以在材质球的编辑器中选择新的Cube镜面盒子来重新赋值。

    Name属性名 (“display name显示名”, 3D) = “white” {}

    上述属性块定义了一个3D贴图，具有一个纯白色的默认贴图，定义后可以在材质球的编辑器中选择新的3D贴图来重新赋值。这个3D Texture不是普通的3D模型的贴图，而是图像后处理形成的3D颜色校正效果贴图。3D Texture由脚本或者着色器产生，而非手绘制造的。可参考Unity API中的Texture3D类。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;综合上面的表述，我们可以制作一个全属性Properties例子。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Properties&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_Scale&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Scale&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Range&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.02&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.15&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.07&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_PahLength&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Path Length&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.5&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_OrderNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Order Number&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;53&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_RefrColor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Refraction color&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.34&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.85&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.92&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;_Direction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Direction&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;4.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;_RefractionTex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Environment Refraction&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2D&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;white&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_RefractionMap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Refraction Map&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cube&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;black&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;”&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;这个全属性例子包含了上面所有属性，在编辑器上展示的属性如下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader9.png&quot; alt=&quot;shader全属性&quot;&gt;&lt;/p&gt;

&lt;p&gt;注意，这里为什么属性前都要加一个”_”，这是个习惯性写法，没有任何强制性，只是大部分程序员在书写Shader属性变量的习惯，逐渐形成了一个传统。&lt;/p&gt;

&lt;p&gt;如果硬要套个说法，那就只能是”_”代表内部变量。就像我们书写代码变量时会有一些小习惯和规则一样，没有其他影响。&lt;/p&gt;

&lt;h6&gt;Property属性默认值&lt;/h6&gt;

&lt;p&gt;每个Property属性都有一个默认值，默认值是必须填写的，否则Shader编译器不会通过编译。这里我们说明一下所有属性的默认值。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1，Number类型。Range，默认值必须在最大和最小值之间，比如Range(0,1)时值为默认值必须为0到1之间。Float，默认值可以为任意浮点数。Int，默认值可以为任意整数，且仅仅只能是整数，不能是浮点数。

    2，Color颜色类型。Color，默认值为4个浮点数，按照RGBA的顺序，第一个代表红色，第二个代表绿色，第三个代表蓝色，第四个代表透明度alpha。

    3，Vector方向坐标类型。Vector，默认值为4个浮点数，按照xyzw的顺序，第一个代表X坐标，第二个代表Y坐标，第三个代表Z坐标，第四个代表角度，深度等其他意义。Vector四个坐标完全可以代表任意值，比如前两个代表2D的X和Y，后面两个代表宽度和长度，再比如，前两个代表uv，后两个代表宽度和长度，或者比如前三个表示x，y，z，最后一个代表透明度alpha。

    4，2D Texture贴图类型。2D Texture，默认值有一个默认的颜色，”white”代表(RGBA:1,1,1,1)白色，”black”代表(RGBA:0,0,0,0)黑色，”gray”代表(RGBA:0.5,0.5,0.5,0.5)灰色，”bump”代表(RGBA:0.5,0.5,1,0.5)灰黄色，”red”代表(RGBA:1,0,0,0)红色。

    5，Cube，3D Texture，2DArray非2D贴图类型。默认值为空，当材质球编辑器中没有设置他们的实例时，他们使用灰色(RGBA:0.5,0.5,0.5,0.5)做默认值。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每个属性值的值在Material材质上都会被序列化后写入Material材质球的Meta文件。&lt;/p&gt;

&lt;p&gt;Shader里实际上可以有很多参数，比如矩阵，数组等，但这些都需要在Shader实时运行中设置和获取的变量，不能成为Property的一部分，因为他们不是Property属性的一部分，也不会被记录存储在Mate文件里。&lt;/p&gt;

&lt;p&gt;在Mate文件里的属性，我们不但可以通过Unity编辑器视窗中来赋值和变更，也可以通过脚本程序来赋值和改变，例如Material.SetFloat可以用来设置Shader中Float类型的属性，Material.SetColor用来设置Color类型的属性，Material. SetTexture可以用来设置 Texture类型的属性。&lt;/p&gt;

&lt;p&gt;没有在Property中的属性类型或变量也同样可以使用Material.SetXXX(“PropertyName”,value)来设置，比如我们可以通过Material. SetMatrix设置矩阵类型在Shader中的变量，虽然矩阵没有在属性块中，我们照样可以设置，只要它在Shader程序变量中声明过就可以。&lt;/p&gt;

&lt;p&gt;下面代码就是一个很好的例子：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MonoBehaviour&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rotateSpeed&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;30f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Update&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rot&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Euler&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rotateSpeed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Matrix4x4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matrix4x4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TRS&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;one&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;GetComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Renderer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;material&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SetMatrix&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;_TextureRotation&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;///// Shader部分&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Shader&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;RotatingTexture&amp;quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Properties&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Base (RGB)&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;white&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SubShader&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Pass&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;CGPROGRAM&lt;/span&gt;
            &lt;span class=&quot;cp&quot;&gt;#pragma vertex vert&lt;/span&gt;
            &lt;span class=&quot;cp&quot;&gt;#pragma fragment frag&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;v2f&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;float2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uv&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TEXCOORD0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SV_POSITION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;float4x4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_TextureRotation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;vert&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;POSITION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uv&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TEXCOORD0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UnityObjectToClipPos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uv&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_TextureRotation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;sampler2D&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;fixed4&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;frag&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v2f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SV_Target&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tex2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ENDCG&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;上述代码中，_TextureRotation 并不是Property属性块中的变量，SetMatrix也同样可以通过材质球实例在程序运行时进行设置。&lt;/p&gt;

&lt;p&gt;这就告诉我们，程序运行时设置Shader中的变量，并不是一定要在Property属性块中声明的。&lt;/p&gt;

&lt;p&gt;其他比如获取Material中的变量可以通过Material.GetXXX(“PropertyName”)来获得，比如Material. GetTexture，Material.GetColor，Material.GetFloat等等。关于Material的很多功能可以通过查看Material的API来了解，这里不再详细介绍。&lt;/p&gt;

&lt;h6&gt;属性的Attributes特性和Drawers绘制工具&lt;/h6&gt;

&lt;p&gt;在书写属性时可以加入一些特性来让属性的用途更加明显，属性的特性有如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [HideInInspector] 在视窗中隐藏。

    [NoScaleOffse] 不显示贴图的tiling/offset属性。

    [Normal] 表明这张贴图是张法线贴图。

    [HDR] 表明这贴图是张高动态范围贴图。

    [Gamma] 表明这个Float或者Vector属性是个RGB类型的颜色，可能会需要转换成以符合的格式使用。

    [PerRendererData] 表明这张贴图每帧都会被MaterialPropertyBlock重新设置。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;书写方式就是在属性前加入这些特性，如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Properties&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;    [HideInInspector]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Scale&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Scale&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Range&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0.02&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0.15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.07&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_PahLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Path Length&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1.5&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_OrderNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Order Number&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;53&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;    [Gamma]&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;_RefrColor&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Refraction color&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0.34&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.85&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.92&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;_Direction&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Direction&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1.2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3.3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;na&quot;&gt;    [NoScaleOffse]&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;_RefractionTex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Environment Refraction&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;white&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_RefractionMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Refraction Map&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cube&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;black&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;”&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Drawers绘制特性列举：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    Drawer和Attribute的区别就是Drawer主要关注点在工具的绘制上，而不是对属性的限制。

    [Toggle] 表明此数字为开关类型，只有0，或1的选择。

    [Enum] 表明此变量只能从几个选项中选择。

    [KeywordEnum] 表明只能在选项中选择关键字，这个特性通常用在开关Shader的部分功能。

    [PowerSlider] 显示一个非线性的属性选择范围。

    [IntRange] 显示一个数字范围，这个数字范围内必须是整数。

    [Space] 在视窗中的属性前创建一个垂直的空隙。

    [Header] 在视窗的属性前展示一个文字说明。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例如下面的属性绘制特性&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Properties&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;        [PowerSlider]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Scale&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Scale&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Range&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0.02&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0.15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.07&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;        [Space(100)]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_PahLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Path Length&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1.5&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;        [Toggle]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_OrderNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Order Number&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;53&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;        [Enum(small,1,big,2,huge,10)]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;size&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_Direction&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Direction&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1.2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3.3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;na&quot;&gt;        [Header(ok head)]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_RefractionTex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Environment Refraction&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;white&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_RefractionMap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Refraction Map&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cube&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;black&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;绘制结果截图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader10.png&quot; alt=&quot;Drawer绘制&quot;&gt; &lt;/p&gt;
</description>
               <pubDate>Tue, 07 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/07/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader2.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/07/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader2.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第七章，Shader(一) - 常用的Shader</title>
               <description>&lt;h3&gt;常用的Shader&lt;/h3&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h6&gt;1， Standard Shader是Unity5中新加入的一个Shader，它被设计的目的是为了替代很多旧版本里表现“真实世界”的Shader，比如石头，木头，玻璃，塑料，金属等材质。&lt;/h6&gt;

&lt;p&gt;它被设置为Unity3D的默认Shader，当创建一个新的材质球时，你不需要去一个很长的列表里在这么多样式中挑选Shader，你直接可以使用Standard Shader，因为它包含了他们大部分的功能比如反射，凹凸贴图，透贴等。&lt;/p&gt;

&lt;p&gt;Standard Shader支持了大部分的功能，并且这些功能可以被自由的打开和关闭。&lt;/p&gt;

&lt;p&gt;Standard Shader还包括了一个高级的灯光模式叫Physically Based Shading。&lt;/p&gt;

&lt;p&gt;Physically Based Shading(缩写PBS)类似于在材质和等之间相互作用来模拟真实世界灯光反射效果，它在需要渲染真实世界的场景里非常适用。&lt;/p&gt;

&lt;h6&gt;2， Diffuse漫反射。&lt;/h6&gt;

&lt;p&gt;最简单的Shader之一，它使用 Lambertian 漫反射灯光模式计算灯光，亮度只依赖于灯光和表面的角度，并且不随着摄像头的移动而变化。&lt;/p&gt;

&lt;p&gt;漫反射主要用于粗糙表面的物体，比如植物，墙体，衣服等，其表面看起来是平滑的，但用放大镜仔细观察，就会看到其表面是凹凸不平的，所以平行的光线照射过去后，被这些粗糙的表面反射向不同的方向，就像是散漫无规则的扫射一样。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader1.png&quot; alt=&quot;镜面反射&quot;&gt;&lt;/p&gt;

&lt;p&gt;当物体被使用漫反射的Shader后，他的亮度会显得比较散漫和暗淡，因为反射光线并不会集中摄入摄像机，而是散漫开来。所以使用Diffuse大大减弱了光照的强度，使得光在物体上体现的并不是很强烈。&lt;/p&gt;

&lt;p&gt;人眼之所以能看清物体的全貌，主要是靠漫反射光在眼内的成像。如是全部单向反射的物体表面，不但看不清物体的外貌，还会引起某一方向上的眩光干扰现象。人们依靠漫反射现象才能从不同方向看到物体。在环境光学中，常把无光泽的饰面材料近似地看作均匀漫反射表面。&lt;/p&gt;

&lt;h6&gt;3， Specular镜面反射。&lt;/h6&gt;

&lt;p&gt;镜面反射是指反射面比较光滑，当平行入射的光线射到这个反射面时，仍会平行地向一个方向反射出来，这种反射就属于镜面反射。&lt;/p&gt;

&lt;p&gt;镜面反射其反射波的方向与反射平面的法线夹角（反射角），与入射波方向与该反射平面法线的夹角（入射角）相等，且入射波、反射波，及平面法线同处于一个平面内。&lt;/p&gt;

&lt;p&gt;摄影时应避免镜面反射光线进入摄影机镜头，由于镜面反射光线极强，在像片上将形成一片白色亮点，影响地物本身在像片上的显现。&lt;/p&gt;

&lt;p&gt;镜面反射遵循光的反射定律。反射所成像的性质是正立的，等大的，位于物体异侧的虚像。镜面反射入射的光线是平行光线，反射到光滑的镜面，又以平行光线出去。&lt;/p&gt;

&lt;p&gt;镜面反射和Diffuse一样使用了 Lambertian 光线计算模式，并且在此基础上加入了一个取决于观察者的高亮反射，我们称之为 Blinn-Phong 光线模式。&lt;/p&gt;

&lt;p&gt;Blinn-Phong 有一个高亮镜面反射它取决于表面角度，光线角度，和观察角度。高亮点实际上只是用实时适应的方式去模拟模糊映像的光源。高亮点的模糊级别可以通过控制亮点滑块来调整。&lt;/p&gt;

&lt;p&gt;另外 Specular Shader 中，主贴图的 alpha 通道扮演了镜面反射图的角色（也可以称为光泽图），alpha通道描述了物体的哪些区域有更强烈的反射效果，哪些区域反射效果比较暗淡。&lt;/p&gt;

&lt;p&gt;alpha为0时（即黑色的区域，把alpha单独提出来成为一副图的话就是黑色的部分），区域内没有反射效果，alpha为1即白色的区域，区域内反射效果为最强烈。&lt;/p&gt;

&lt;p&gt;如果你想在不同区域内有不同的反射效果，这种类型的光泽图对你来说很有用。比如生锈的金属的高亮反射比较弱，光滑的金属则有强烈的高亮点反射。再比如口红的镜面反射比皮肤大，而皮肤的镜面反射又比衣服大。&lt;/p&gt;

&lt;p&gt;所以我们可以制作不同区域的光泽图来表现不同区域的高亮反射。前面说在Specular Shader中的主图的alpha已经扮演了这个光泽图的功能，所以我们只要用alpha来表现不同区域的高亮反射效果就可以了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader2.png&quot; alt=&quot;镜面反射&quot;&gt;&lt;/p&gt;

&lt;p&gt;镜面反射和漫反射，反射角度和入射角相等，都遵循光的反射定律，唯一的区别，就是镜面反射的反射面比较平，因而光束比较统一而且反射方向比较一致，漫反射的反射平面高低不平导致反射光的光束也杂乱无章。两者都符合反射定律。&lt;/p&gt;

&lt;h6&gt;4， Vertex-Lit  顶点渲染。&lt;/h6&gt;

&lt;p&gt;Vertex-Lit 是所有常用Shader里最最简单的一个Shader。&lt;/p&gt;

&lt;p&gt;无论有多少灯光，Vertex-Lit只接受一个灯光，在渲染时只做顶点计算的光效果。&lt;/p&gt;

&lt;p&gt;它是顶点光计算方式，不会渲染像素级别的效果，例如点光线纹理，法线贴图，阴影等。&lt;/p&gt;

&lt;p&gt;它只会关注模型的形状，如果你想要参入其他因素的，就必须使用其他类型的Shader做替代，比如Pixel-Lit像素渲染。&lt;/p&gt;

&lt;p&gt;Vertex-Lit就像是最朴素的渲染者，没有反射光的互相影响作用，只做顶点的光计算并且只接受一个光。&lt;/p&gt;

&lt;h6&gt;5， Transparent 半透明。&lt;/h6&gt;

&lt;p&gt;Transparent 类型的Shader被用在全透明和半透明的物体上，因为可以透过物体看到物体背后的东西，所以具有特殊性，例如玻璃瓶，玻璃窗，水，眼镜，酒，水晶等。&lt;/p&gt;

&lt;p&gt;Transparent 的Shader主图上的alpha通道可以决定哪些区域是透明的，透明到什么程度。用它可以制作出效果丰富的玻璃类型的物体，或者显示器表面，或者科幻的效果。&lt;/p&gt;

&lt;p&gt;主图的alpha通道里，如果alpha为0（黑色区域）时会表现为是全透明，否则alpha为1（白色区域）时会表现为不透明。如果你的主图没有alpha通道，物体就相当于是个完全的不透明物体。&lt;/p&gt;

&lt;p&gt;半透明物体的排序问题。&lt;/p&gt;

&lt;p&gt;使用Transparent的物体在游戏中常常会有一些诡异的问题，这是由于传统显卡程序导致的透明物体的排序问题。&lt;/p&gt;

&lt;p&gt;例如当我们透过两扇透明的玻璃窗看东西的时候，会发现这两扇玻璃窗有点问题，似乎后面的玻璃在前面但窗又被挡在后面。&lt;/p&gt;

&lt;p&gt;这个问题直到现在还一直都存在而且并没有什么完美的方案解决它，我们只能通过编写Shader的规则来告诉显卡，哪扇窗户在前面，哪扇窗户在后面才能让处理器正确的显示玻璃前后这个半透明物体的排序情况。&lt;/p&gt;

&lt;p&gt;为此，我们在使用半透明物体的时候，就应该明白不能过度使用半透明物体，过多的半透明物体将导致很多排序问题。如果设计中不可避免，就应该提醒美术设计师注意半透明物体的排序，让他们在遇到问题前有所准备。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader3.png&quot; alt=&quot;镜面反射&quot;&gt;&lt;/p&gt;

&lt;p&gt;用裁切 Cutout 做半透明。&lt;/p&gt;

&lt;p&gt;用裁切Cutout做半透明，是半透明物体的另一种特殊形式，对Cutout来说只渲染两种情况，物体上的某部位要么完全透明要么完全不透明。&lt;/p&gt;

&lt;p&gt;它使用在一些某些不需要半透明但又需要全透明的物体上，这些物体上的部位通常都是要么完全透明，要么完全不透明，比如说栏杆，铁环，有很多洞的盒子等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader4.png&quot; alt=&quot;镜面反射&quot;&gt;&lt;/p&gt;

&lt;p&gt;Cutout本身就是为了节省模型细节的替代物，大多数使用Cutout作为Shader的物体都可以用重新制作模型细节并且挖空裁切模型的做法来替代。&lt;/p&gt;

&lt;p&gt;制作这样的细节非常耗费美术资源，也增加了巨量的三角面数和顶点数，导致增加内存和CPU的压力，于是用Cutout来替代挖空和裁切能更好的优化内存和CPU，也同样节省了不少3D的工作量。&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))
    { //移动端
        /*mobile-20:5*/
        var cpro_id = &quot;u3493987&quot;;
        document.write(&quot;\&lt;script type=\&quot;text\/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/cm.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
    else
    {
         /*700*200信息流*/
        var cpro_id = &quot;u3469788&quot;;
        document.write(&quot;\&lt;script type=\&quot;text/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/c.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
&lt;/script&gt;

&lt;p&gt;6，    Self-Illuminated 自发光。&lt;/p&gt;

&lt;p&gt;这里称述下自发光的意思，很多人对自发光有很多误解，比如自己会产生光源影响周围环境，自己会产生光晕效果等都是错误的。&lt;/p&gt;

&lt;p&gt;自发光的意义很简单，不受光源影响，自己能够独自呈现高亮的效果，并且不影响周围环境。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader5.png&quot; alt=&quot;镜面反射&quot;&gt;&lt;/p&gt;

&lt;p&gt;Self-Illuminated 自发光允许我们自己定义模型的哪些部位是亮的哪些部位是暗的。&lt;/p&gt;

&lt;p&gt;这个Shader能够通过自发光贴图的alpha通道对物体某部分的光亮进行调整，让某部分的亮度看起来很亮或者很暗，就像是自己有发光体一样。&lt;/p&gt;

&lt;p&gt;其实Self-Illuminated通过alpha值在调整亮度使得不需要任何的光源都能展示足够的亮度，当没有光照着模型的时候模型本身也具备了类似光源照射的足够亮度，而当有光源照射时，任何顶点光或者像素光都只是简单的对 Self-Illuminated 的光量进行简单的相加。&lt;/p&gt;

&lt;p&gt;所以无论光源有没有照射到自发光模型，模型都会根据自发光贴图进行自发光，并且加上灯光照射的亮度。&lt;/p&gt;

&lt;p&gt;Self-illuminate 常常用在模型某个部位需要自己加亮的物体上。比如，部分墙上的贴图能用自发光来模拟灯光的，天花板的LED小灯，汽车仪表盘，大型建筑上的广告牌，或者高楼大厦上每个窗户的灯光等。&lt;/p&gt;

&lt;p&gt;但凡能够自己发光的，并且不影响其他物体的光线的，都可以使用自发光Self-Illuminate来替代灯光。&lt;/p&gt;

&lt;p&gt;由于点光源或者聚光灯都是非常消耗GPU和CPU的，一旦大量使用就会对性能造成成吨的伤害(CPU消耗)导致画面延迟卡顿。&lt;/p&gt;

&lt;p&gt;平行光，点光源和聚光灯对周围物体的影响也是很难控制的，一旦大量使用就很难调控某个特殊物体或部位的亮度。&lt;/p&gt;

&lt;p&gt;使用Self-Illuminate很好的解决了这些问题，不仅节省了大量因为点光源和聚光灯导致的性能开销，而且对物体局部光亮的把控更精准到位。&lt;/p&gt;

&lt;h6&gt;7， Reflective 球面反射环境模拟。&lt;/h6&gt;

&lt;p&gt;Reflective 球面反射Shader使用一个Cubemap来对周围的环境进行反射模拟。&lt;/p&gt;

&lt;p&gt;我们可以通过改变主贴图上的alpha通道来对镜面反射度进行调整，比如玻璃，油水，铂金类质地的物体的镜面反射度高，所以主图的alpha就相对大，而金属类，液体类或者显示屏表面镜面反射度小，所以主图的alpha就可以相对小。&lt;/p&gt;

&lt;p&gt;Reflective 主要是模拟球面反射后在镜面上的出现的环境，常用在汽车玻璃，建筑玻璃镜子，金属制品的镜面反射等。&lt;/p&gt;

&lt;p&gt;Reflective 渲染时需要一个模拟周围环境的Cubemap，Cubemap是由6张图拼成的一个定义周围环境的立方图。周围环境是如何展示的都由Cubemap来定义，它有顶，底，左，右，前，后，6个面。&lt;/p&gt;

&lt;p&gt;Reflective 关键点在Cubemap，这里简单说下制作Cubemap的几种方式：&lt;/p&gt;

&lt;p&gt;1，    使用贴图制作 Cubemap。最方便的制作Cubemap的方式就是通过设置图片的类型将一张贴图设置为Cubemap来让Unity自己识别和拆分。&lt;/p&gt;

&lt;p&gt;如图为 Cubemap 资源：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader6.png&quot; alt=&quot;镜面反射&quot;&gt;&lt;/p&gt;

&lt;p&gt;那么Unity是如何识别上下左右前后的6个面的呢？如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader7.png&quot; alt=&quot;镜面反射&quot;&gt;&lt;/p&gt;

&lt;p&gt;Unity支持这4种布局的图片，只要你按照这四种布局的一种来布置图片的顺序就能得到正确的Cubemap图。&lt;/p&gt;

&lt;p&gt;2，    通过设置Cubemap资源中的图来制作Cubemap。&lt;/p&gt;

&lt;p&gt;先创建一个Cubemap资源，对Cubemap里的属性进行设置，前后左右上下的6张图，以及大小，是否使用MipMap等。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/7/shader8.png&quot; alt=&quot;镜面反射&quot;&gt;&lt;/p&gt;

&lt;p&gt;3，    使用Unity的API来创建Cube图。&lt;/p&gt;

&lt;p&gt;Camera.RenderToCubemap函数可以记录在场景的某个点上记录6个面的图，从而我们可以通过Camera.RenderToCubemap创建的6张环境图来导出自己需要Cubemap图。&lt;/p&gt;

&lt;p&gt;代码例子：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RenderCubemapWizard&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ScriptableWizard&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;renderFromPosition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cubemap&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cubemap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnWizardUpdate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;helpString&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;Select transform to render from and cubemap to render into&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isValid&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;renderFromPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cubemap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnWizardCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// create temporary camera for rendering&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;GameObject&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GameObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;CubemapCamera&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AddComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Camera&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;();&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// place it on the object&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;renderFromPosition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;identity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// render into cubemap&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Camera&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RenderToCubemap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cubemap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// destroy temporary camera&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;DestroyImmediate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;    [MenuItem(&amp;quot;GameObject/Render into Cubemap&amp;quot;)]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RenderCubemap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ScriptableWizard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DisplayWizard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RenderCubemapWizard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&amp;quot;Render cubemap&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;Render!&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
</description>
               <pubDate>Tue, 07 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/07/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader1.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/07/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-Shader1.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第六章，网络层(一) - TCP还是UDP</title>
               <description>&lt;h3&gt;有哪些网络协议可以用&lt;/h3&gt;

&lt;p&gt;TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。&lt;/p&gt;

&lt;p&gt;一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，只简单的描述下这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接并要求同步的数据包（同步就是两台主机一个在发送，一个在接收，协调工作）：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;TCP建立连接要进行3次握手,而断开连接要进行4次：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1 当主机A完成数据传输后,将控制位FIN置1,提出停止TCP连接的请求

    2 主机B收到FIN后对其作出响应,确认这一方向上的TCP连接将关闭,将ACK置1

    3 由B 端再提出反方向的关闭请求,将FIN置1

    4 主机A对主机B的请求进行确认,将ACK置1,双方向的关闭结束.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由TCP的三次握手和四次断开可以看出，TCP使用面向连接的通信方式，大大提高了数据通信的可靠性，使发送数据端和接收端在数据正式传输前就有了交互，为数据正式传输打下了可靠的基础。&lt;/p&gt;

&lt;p&gt;名词解释：
        ACK  TCP报头的控制位之一,对数据进行确认.确认由目的端发出,用它来告诉发送端这个序列号之前的数据段都收到了.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    比如,确认号为X,则表示前X-1个数据段都收到了,只有当ACK=1时,确认号才有效,当ACK=0时,确认号无效,这时会要求重传数据,保证数据的完整性.

    SYN  同步序列号,TCP建立连接时将这个位置1

    FIN  发送端完成发送任务位,当TCP完成数据传输需要断开时,提出断开连接的一方将这位置1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;TCP的包头结构：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    源端口 16位

    目标端口 16位

    序列号 32位

    回应序号 32位

    TCP头长度 4位

    reserved 6位

    控制代码 6位

    窗口大小 16位

    偏移量 16位

    校验和 16位

    选项  32位(可选)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们得出了TCP包头的最小长度，为20字节。&lt;/p&gt;

&lt;p&gt;UDP（User Data Protocol，用户数据报协议）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    （1） UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。

    （2） 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息。

    （3） UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。

    （4） 吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。

    （5）UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表（这里面有许多参数）。

    （6）UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。&lt;/p&gt;

&lt;p&gt;UDP的包头结构：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    源端口 16位

    目的端口 16位

    长度 16位

    校验和 16位
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;TCP与UDP的区别：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1，基于连接与无连接；

    2，对系统资源的要求（TCP较多，UDP少）；

    3，UDP程序结构较简单；

    4，流模式与数据报模式 ；

    5，TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))
    { //移动端
        /*mobile-20:5*/
        var cpro_id = &quot;u3493987&quot;;
        document.write(&quot;\&lt;script type=\&quot;text\/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/cm.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
    else
    {
         /*700*200信息流*/
        var cpro_id = &quot;u3469788&quot;;
        document.write(&quot;\&lt;script type=\&quot;text/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/c.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
&lt;/script&gt;

&lt;h3&gt;用TCP，还是用UDP？&lt;/h3&gt;

&lt;p&gt;从原理上，TCP的优势有，简单直接的长连接，可靠的信息传输，能确保数据到达有确认机制，并且数据到达后是有序的，数据包的大小没有限制，不需要自己切分数据包，网络协议本身就已经帮助你切分。&lt;/p&gt;

&lt;p&gt;UDP是基于数据包构建，这意味着在某些方面需要你完全颠覆在TCP下的观念。&lt;/p&gt;

&lt;p&gt;UDP只使用一个socket进行通信，不像TCP需要为每一个客户端建立一个socket连接，这是UDP还不错的地方。&lt;/p&gt;

&lt;p&gt;但是大多数情况下你需要的仅仅是一些连接的概念罢了，一些基本的包序功能，以及所谓的连接可靠性。可惜的是，这些功能UDP都没有办法简单的提供给你，而你使用TCP却都可以免费得到。&lt;/p&gt;

&lt;p&gt;这就是人们为什么经常推荐TCP的原因，在用TCP的时候你可以不考虑这些问题，直到你需要同步连接的数量级达到500以上的时候。&lt;/p&gt;

&lt;p&gt;所以是的，UDP没有提供所有的解决方法，但是就像你看到的那样，这也正是UDP好用的地方。在某种意义上来说，TCP对UDP就好比是Hibernate和手写SQL的区别。&lt;/p&gt;

&lt;p&gt;容易造成巨大的延迟问题是TCP的性质决定的，在发生丢包的时候，会产生巨大的延迟，因为TCP首先会去检测哪些包发生了丢失，然后重发所有丢失的包，直到他们都被接收到。&lt;/p&gt;

&lt;p&gt;UDP也是有延迟的，但是由于它是在UDP的基础之上建立的通信协议，所以可以通过多种方式来减少延迟，不像TCP，所有的东西都要依赖于TCP协议本身而无法被更改。&lt;/p&gt;

&lt;p&gt;就这一点来讲，一些人要开始提到Nagle算法了，实际上它是你在实现任意一个对延迟敏感的TCP模型时首先需要禁止使用的。&lt;/p&gt;

&lt;p&gt;那么为什么魔兽世界采用TCP呢？首先我们需要解释这个问题。这个问题其实是“为什么魔兽世界有的时候1000毫秒以上的延迟还能够运行？”&lt;/p&gt;

&lt;p&gt;魔兽世界以及其他的一些游戏是怎么处理延迟问题的呢？&lt;/p&gt;

&lt;p&gt;方法也很简单，他们能够隐藏掉延迟带来的影响。&lt;/p&gt;

&lt;p&gt;我们看一下魔兽世界的战斗就会发现，玩家的攻击指令发送给服务器的操作，一些类似发起攻击动作和释放技能特效就能够在没有收到服务器确认的情况下就直接执行，比如展现冰冻技能的效果就可以在服务器没有返回数据前在客户端就做出来。&lt;/p&gt;

&lt;p&gt;客户端直接开始进行计算而不等待服务端确认是一种典型的隐藏延迟的技术。这也意味着，我们到底是使用TCP还是UDP取决于我们能否隐藏延迟。&lt;/p&gt;

&lt;p&gt;那么到底是用UDP还是TCP呢？提供如下参考：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    如果是由客户端间歇性的发起无状态的查询，并且偶尔发生延迟是可以容忍，那么使用HTTP/HTTPS吧。

    如果客户端和服务器都可以独立发包，但是偶尔发生延迟可以容忍（比如：在线的纸牌游戏，许多MMO类的游戏），那么使用TCP长连接吧。

    如果客户端和服务器都可以独立发包，而且无法忍受延迟（比如：大多数的多人动作类游戏，一些MMO类游戏），那么使用UDP吧。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
               <pubDate>Mon, 06 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/06/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%821.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/06/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%821.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第五章，3D模型与动画(三) - 状态机</title>
               <description>&lt;h2&gt;如何用状态机模拟人物行为动作。&lt;/h2&gt;

&lt;p&gt;什么是状态机？&lt;/p&gt;

&lt;p&gt;状态机有两种，一种是有限状态机，一种是无限状态机。有限状态机运用的地方比较多，而无限状态机我还没看见过有在游戏项目中运用的。我们这里讲的状态机都是有限状态机。&lt;/p&gt;

&lt;p&gt;有限状态机简单描述下，实例本身有很多种状态，实例从一种状态切换到另一种状态的动作就是状态机转换，而转换是有条件的，这个条件就是状态机之间的连线。&lt;/p&gt;

&lt;p&gt;打个比方，人有三个状态健康，感冒，康复中。触发的条件有淋雨（t1），吃药（t2），打针（t3），休息（t4）。状态机的连接图可以是这样，健康-（t4休息）-&amp;gt;健康；健康-（t1淋雨）-&amp;gt;感冒；感冒-（t3打针）-&amp;gt;健康；感冒-（t2吃药）-&amp;gt;康复中；康复中-（t4休息）-&amp;gt;健康，等等。状态在不同的条件下跳转到自己或不同状态中去。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;状态机可归纳为4个要素，即现态、条件、动作、次态。这样的归纳主要是出于对状态机的内在因果关系的考虑。“现态”和“条件”是因，“动作”和“次态”是果。详解如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;①现态：是指当前所处的状态。

②条件：又称为“事件”，当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移。

③动作：条件满足后执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接迁移到新状态。

④次态：条件满足后要迁往的新状态。“次态”是相对于“现态”而言的，“次态”一旦被激活，就转变成新的“现态”了。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;游戏中人物行为动作中使用状态机&lt;/h3&gt;

&lt;p&gt;游戏中状态机的关键是事件和控制状态的控制类。状态机的数量和作用都会因系统的不同而不同，触发条件也各异的，唯有事件机制和控制类是状态机的不变的功能。&lt;/p&gt;

&lt;p&gt;事件机制在进入状态和退出状态时，触发进入事件和退出事件，这个是状态启动运作和停止运作的起点。&lt;/p&gt;

&lt;p&gt;状态在满足转换条件后，退出状态前向当前状态发起退出事件，告诉当前状态机，你将停止运行，停止运行前需要处理什么逻辑请赶快做，然后再向新状态发起进入事件，告诉新状态你将要开始运作，运作前的有什么逻辑或者准备工作请尽快做。这样每次状态的切换都能合理的告诉当前状态和将要切换的状态进行事件的调用。&lt;/p&gt;

&lt;p&gt;状态机在游戏中哪些地方会使用到？&lt;/p&gt;

&lt;p&gt;所有能够构成独立状态的系统或者功能都能使用状态机来表现：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1，    场景切换。

    场景是独立的，只能有一个场景展示在游戏中，所以场景的切换可以用状态机来表示。比如当前是登录场景，点击登录后切换到游戏场景，这时需要把登录场景的UI销毁，UI的销毁工作是登录场景状态在退出时触发的退出事件中做的事。

    之后进入到游戏场景状态时，要先把游戏场景的UI创建出来，这是游戏场景状态在触发启动事件时要做的事。

    2，    人物行为状态切换。

    人物只能做一个动作状态，比如攻击动作状态，比如防守动作状态，比如死亡状态，又比如人物跑步状态，这些行为都只能用单独的一个状态来表示，但也有人物边跑步边吃东西的时候，这时我们也会有几种方式去构建，比如我们把人物跑步且吃东西另外创建一个状态来运行，也可以把跑步状态里加一个吃东西的参数，让跑步这个状态机来运行不一样的跑步动作。

    3，    宝箱，机关等具有多动画的元素都可以构成独立的状态。

    每个动画的播放都可以成为一个状态，比如打开状态下的宝箱，比如触发机关时的状态等等。

    4，    AI。

    用状态机来封装AI是最常见到的，每个AI状态都是独立运行的。比如激怒状态，此状态中会不断向周围的敌人发起攻击，如果20秒后恢复到平静状态不再攻击，又比如巡逻状态，在某个点周围或者按一定路线进行走动，如果5米内发现敌人，就进去激怒状态等等。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))
    { //移动端
        /*mobile-20:5*/
        var cpro_id = &quot;u3493987&quot;;
        document.write(&quot;\&lt;script type=\&quot;text\/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/cm.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
    else
    {
         /*700*200信息流*/
        var cpro_id = &quot;u3469788&quot;;
        document.write(&quot;\&lt;script type=\&quot;text/javascript\&quot; src=\&quot;//cpro.baidustatic.com/cpro/ui/c.js\&quot;\&gt;\&lt;\/script\&gt;&quot;);
    }
&lt;/script&gt;

&lt;p&gt;我们先按常见的需求把人物行为动作划分一下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1，    休息状态。原地不动，并且重复做一个休息的动画。

    2，    攻击状态。播放攻击动画，并且对目标或前方进行攻击。

    3，    技能状态。技能稍微复杂点，因为每个技能都不一样，所以技能状态里面的逻辑可以由不同的技能类来实现。比如建个技能基类class SkillBase，里面有几个统一的接口，然后子类对基类进行继承后，细化技能的细节。

    4，    防御状态。播放防御动画，当受到攻击时，不切换受伤状态。

    5，    受伤状态。播放受伤动画，完毕后自动进入休息状态。

    6，    行走与跑步状态。播放行走或跑步动画，并根据操作输入移动方向。

    7，    跳跃状态。播放跳跃动画，并上下移动人物进行跳跃，下落时底部受到碰撞就进入休息状态。

    8，    死亡状态。播放死亡动画，并且不再受到任何指令而转入任何状态。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里对每个状态编写一些伪代码来描述状态机在人物行为中的运作，如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BaseState&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnEnter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnExit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IdleState&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnEnter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;role&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;playAnimation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idle&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;”&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HurtState&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnEnter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;role&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;playAnimation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hurt&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;”&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Once&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;Public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;If&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Role&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsPlayingAnimation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hurt&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;”&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;HurtFinish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnExit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;GotoIdleState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttackState&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnEnter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Role&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;playAnimation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attack&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;”&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;once&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;If&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Role&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsPlayingAnimation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attack&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;”&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;AttackStateFinish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnExit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;GotoIdleState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MoveState&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnEnter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Role&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;playAnimation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;walk&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;”&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnExit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;GotoIdleState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;上述代码表达了对状态的描述，其中空闲状态，在没有收到任何指令时只循环播放Idle动画其他什么都不干；攻击状态，进入时播放攻击动画，并在动画结束后返回Idle状态并等待指令；移动状态在进入时播放walk动画并移动，在退出时进入Idle状态。&lt;/p&gt;

&lt;p&gt;除了事件对状态起了关键的作用外，控制状态的控制类也是关键，它就像是状态的管理类，用于管理状态的入口和出口。&lt;/p&gt;

&lt;p&gt;以下是伪代码：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RoleStateController&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IdleState&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idleState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MoveState&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moveState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AttackState&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attackState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HurtState&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hurtState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BaseState&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;Public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnHurt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ReduceHP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;If&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentState&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hurtState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ChangeToHurtState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;InputAttack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;If&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentState&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hurtState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//受伤状态下不可攻击&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;If&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentState&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attackState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//攻击状态还没结束时不可重新开始攻击&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ChangeToAttackState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;InputMove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;在状态机控制类中，存储了各个状态，并且提供了输入的接口，这种输入的事件是由状态机外部提供的，比如发起攻击，比如受到伤害，比如向前向后移动等等，在外部需要状态机触发状态改变时，发起了对状态机的输入事件。&lt;/p&gt;

&lt;p&gt;这样就是状态机控制类需要做的事，简单来说就是存储状态，并提供输入事件接口。&lt;/p&gt;

&lt;p&gt;有了状态机的控制类就有了状态机的管理，就可以对各种逻辑的控制，比如硬值，受伤中不可行走和攻击，攻击中不可移动等，这些当状态在切换时的条件限制，是阻挡还是通过，该切换什么状态，都是由控制类来决定的，它就是状态机系统的大脑。&lt;/p&gt;
</description>
               <pubDate>Mon, 06 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/06/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB3.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/06/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB3.html</guid>
            </item>
        
            <item>
               <title>被封纪念帖</title>
               <description>&lt;p&gt;www.luzexi.com 博客 被关小黑屋了，原因是自己架了梯子，还写文章教别人怎么架梯子。被冠以双重罪，直接封服务器了，不仅仅是域名，服务器也不给用了。&lt;/p&gt;

&lt;p&gt;这是不给程序员活路么，不学习外来技术怎么振兴中华。&lt;/p&gt;

&lt;p&gt;但是我想通了，生活在中国就要按照中国的规矩办事，政治觉悟要有。&lt;/p&gt;

&lt;p&gt;被封让我彻底放弃了阿里云，也放弃了国外的服务器，转而用国内，也同时放弃了自建某些服务器，感觉也轻松了很多，并且又多了一个域名，luzexi.cn 因为原来的域名不知道什么时候恢复，暂时用这个吧。&lt;/p&gt;

&lt;p&gt;我想明白了在中国还是需要按中国的套路走，如果你移民在国外也一样，要拼劲全力融入当地的风俗民习，都不容易。&lt;/p&gt;

&lt;p&gt;所以那些在国外的说国内不好的，或者在国内说国外不好的，都是井底之蛙，过于偏见纠结问题的表面。&lt;/p&gt;

&lt;p&gt;做好自己，在规矩下办事，在规则下取胜才是关键，不要去秀下限，而是要努力去突破上限。&lt;/p&gt;

&lt;p&gt;放个连接吧，总不至于白写。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/luzexi/blog/blob/master/luzexi.com/hyde-master/_posts/2018-08-01-%E8%A2%AB%E5%B0%81%E7%9A%84%E5%B8%96%E5%AD%90.md&quot;&gt;被封的说明书&lt;/a&gt;&lt;/p&gt;
</description>
               <pubDate>Fri, 03 Aug 2018 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2018/08/03/%E8%A2%AB%E5%B0%81%E7%BA%AA%E5%BF%B5%E5%B8%96.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2018/08/03/%E8%A2%AB%E5%B0%81%E7%BA%AA%E5%BF%B5%E5%B8%96.html</guid>
            </item>
        
    </channel>
</rss>