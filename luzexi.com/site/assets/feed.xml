<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title></title>
        <description>漫漫人生,记录点滴技术,始于2013</description>
        <link>http://www.luzexi.com</link>
        <atom:link href="http://www.luzexi.com/assets/feed.xml" rel="self" type="application/rss+xml" />
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第六章，网络层(五) - 剖析数据协议原理</title>
               <description>&lt;h6&gt;协议包的格式，json, msgpack, protobuf 以及自定义格式&lt;/h6&gt;

&lt;p&gt;项目的网路层在建设中，除了选择长短连接TCP，UDP，HTTP方式外，还需要选择在传输过程中使用什么样的协议格式。&lt;/p&gt;

&lt;p&gt;前面分析了TCP，UDP，HTTP的原理与应用，现在我们来了解下在传输层和应用层之上的逻辑层中，信息传递格式的选择与利弊。&lt;/p&gt;

&lt;p&gt;我们以最常见的JSON格式作为切入点，一步步深入了解更加有效却复杂的传递格式。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h6&gt;JSON&lt;/h6&gt;

&lt;p&gt;JSON：JavaScript 对象表示法（JavaScript Object Notation）。它是存储和交换文本信息的语法。类似 XML，但比 XML 更小、更快，更易解析。&lt;/p&gt;

&lt;p&gt;JSON 是轻量级的文本数据交换格式，它独立于语言，具有自我描述性，更易理解。&lt;/p&gt;

&lt;p&gt;JSON 是属于纯文本，具有“自我描述性”（人类可读），具有层级结构（值中存在值）&lt;/p&gt;

&lt;p&gt;JSON与同时纯文本类型格式的XML相比较，JSON不需要结束标签，JSON更短，JSON解析和读写的速度更快，在JavaScript中能够使用内建的 JavaScript eval() 方法进行解析，JSON还可以使用数组，切不使用保留字（&amp;amp;，&amp;lt;，&amp;gt;，&amp;#39;，&amp;quot;）。&lt;/p&gt;

&lt;p&gt;JSON 语法规则：&lt;/p&gt;

&lt;p&gt;JSON 数据的书写格式是：名称/值对。&lt;/p&gt;

&lt;p&gt;名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值：&lt;/p&gt;

&lt;p&gt;&amp;quot;firstName&amp;quot; : &amp;quot;John&amp;quot;&lt;/p&gt;

&lt;p&gt;JSON数据由逗号分隔，它的值可以是：&lt;/p&gt;

&lt;p&gt;数字（整数或浮点数）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;{
  &amp;quot;number&amp;quot; : 1,
  &amp;quot;number2&amp;quot; : 11.5
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;字符串（在双引号中）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;{
  &amp;quot;str1&amp;quot; : &amp;quot;1&amp;quot;,
  &amp;quot;str2&amp;quot; : &amp;quot;11&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;逻辑值（true 或 false）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;{
  &amp;quot;logic1&amp;quot; : true,
  &amp;quot;logic2&amp;quot; : false
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;数组（在方括号中）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;{
   &amp;quot;array1&amp;quot; : [1,2,3],
   &amp;quot;array2&amp;quot; : [{&amp;quot;str1&amp;quot;,1},{&amp;quot;str2&amp;quot;,2},{33,44}]
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对象（在花括号中）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;{
  &amp;quot;obj1&amp;quot; : {1, &amp;quot;str1&amp;quot;, true},
  &amp;quot;obj2&amp;quot; : {&amp;quot;str2&amp;quot;, 2, false},
  &amp;quot;obj3&amp;quot; : null
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JSON 对象在花括号中书写：&lt;/p&gt;

&lt;p&gt;对象可以包含多个名称/值对：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;{ &amp;quot;firstName&amp;quot;:&amp;quot;John&amp;quot; , &amp;quot;lastName&amp;quot;:&amp;quot;Doe&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JSON 数组在方括号中书写：&lt;/p&gt;

&lt;p&gt;数组可包含多个对象：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;{
    &amp;quot;employees&amp;quot;: [
        { &amp;quot;firstName&amp;quot;:&amp;quot;John&amp;quot; , &amp;quot;lastName&amp;quot;:&amp;quot;Doe&amp;quot; },
        { &amp;quot;firstName&amp;quot;:&amp;quot;Anna&amp;quot; , &amp;quot;lastName&amp;quot;:&amp;quot;Smith&amp;quot; },
        { &amp;quot;firstName&amp;quot;:&amp;quot;Peter&amp;quot; , &amp;quot;lastName&amp;quot;:&amp;quot;Jones&amp;quot; }
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JSON 文件的文件类型通常是 &amp;quot;xxx.json&amp;quot; 用来扩展名用来说明是json格式的文本文件&lt;/p&gt;

&lt;p&gt;JSON 文本的 MIME 类型是 &amp;quot;application/json&amp;quot; (MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准。MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。)&lt;/p&gt;

&lt;p&gt;JSON 解析器可以用些比较常用的，比如simpleJson，MiniJson，DataContractJsonSerializer，JArray，JObject等等，都是非常通用高效的插件。&lt;/p&gt;

&lt;h6&gt;自定义二进制流协议格式&lt;/h6&gt;

&lt;p&gt;大部分的网络协议都具有一定的通用性，JSON是最典型的案例，XML，MessagePack，Protobuf都具有一定的通用性，但自定义二进制流协议格式则不是，它完全不通用，因为它不需要顾及通用性。&lt;/p&gt;

&lt;p&gt;我们在存储一串数据的时候，无论这串数据里包含了哪些数据以及哪些数据类型，当我们拿到这串数据在解析的时候能够知道该怎么解析，这是定义协议格式的目标。&lt;/p&gt;

&lt;p&gt;简单的来说就是，当你传给我一串数据的时候，我是用什么样的规则知道这串数据里的内容的。JSON就制定了这么一个规则，这个规则以字符串KEY-VALUE，以及一些辅助的符号‘{’,&amp;#39;}&amp;#39;,&amp;#39;[&amp;#39;,&amp;#39;]&amp;#39;组合而成，这个规则非常通用，以至于任何人拿到任何JSON数据都能知道里面有什么数据。&lt;/p&gt;

&lt;p&gt;自定义二进制流协议格式则不具有通用性，不是任何人拿到数据都能知道里面装的是什么的，有且只有两端在私下协定的双方才知道该如何解析收到的数据，对于破解自定义二进制流的内容也只有靠猜，虽然猜的难度也不是非常大。&lt;/p&gt;

&lt;p&gt;一个自定义二进制流协议格式，分成三部分：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;数据大小|协议编号|具体数据
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;数据大小、协议编号、具体数据，这三者构成了一个完整的协议内容，这一整个协议内容少了谁都不成，不过有时数据大小和协议编号的前后顺序可以交换。&lt;/p&gt;

&lt;p&gt;我们举例来描述这个协议格式，假设我们客户端有这样一个数据结构需要传输到服务端去：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;struct test
{
  int test1;
  float test2;
  bool test3;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;服务端拿到数据时，其实完全不知道当前拿到的数据是什么，也不知道数据是否完整，有可能只拿到一半的数据，或者一部分的数据。&lt;/p&gt;

&lt;p&gt;首先我们要确定的是，我们收到的数据包它的完整的大小有多大，只有知道完整的包体大小才能确定我当前收到的数据在大小上是否完整，我们是要等待继续接受后面的数据，还是现在就可以进行解析操作了。&lt;/p&gt;

&lt;p&gt;为了确定包的完整性，我们必须先向二进制流中读取4个比特，组合成一个无符号整数，这个整数总共32位，也就是说我们的数据包的大小最大为2的32次减1个byte，然后再用来确定接下来的完整包体大小。&lt;/p&gt;

&lt;p&gt;例如我现在接受到了20个byte，读取前4个，组成一个整数后为24，说明我接受到的后面16个byte是一个不完整的包体，我应该继续等待后续的数据到来。&lt;/p&gt;

&lt;p&gt;其次我们要确定的是收到的数据包是属于哪个格式的协议。&lt;/p&gt;

&lt;p&gt;于是再读取4个byte大小的数据，组成一个无符号整数，用来确定协议号。比如这个无符号整数位为1002，就代表是编号为1002的协议。&lt;/p&gt;

&lt;p&gt;假设我们上面这个test结构的协议号就是1002，那么接下来连着这个协议号的所有数据直到包体大小的末尾，都是这个test结构的数据。&lt;/p&gt;

&lt;p&gt;在解析这个具体数据的时候，要根据生成这个数据的顺序来解析。&lt;/p&gt;

&lt;p&gt;假设在生成这个二进制流数据时，我们的顺序是，先推入test1，再推入test2，再推入test3。test1是4个byte的整数，test2是4个byte的浮点数，test3是1个byte的布尔值，于是就有了&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;xxxx|xxxx|x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样一个形状的二进制流，每个‘x’为一个byte，‘|’只是为了解释说明用的分隔符不存在于数据内，这个数据其实就是由9个byte组成，其中前4个为test1，中间4ge为test2，后面1个为test3。&lt;/p&gt;

&lt;p&gt;我们在解析的时候也需要按照生成时的顺序来解析，先读取前4个byte组成一个整数赋值给test1，接着再读取4个byte组成一个浮点数赋值给test2，接着再读取1个byte赋值给test3，完成数据解析。&lt;/p&gt;

&lt;p&gt;对于数组形式的数据则要在原来的基础上多增加一个长度标志，比如 int[]类型数据，在生成时先推入一个长度，再连续推入所有内容，在解析的时候做同样的反向操作，先读取4个byte的长度标志，再对连续读取N个具体数据，这个N为长度标志。&lt;/p&gt;

&lt;p&gt;举例int[]为3个整数数组则二进制为如下效果：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;xxxx|xxxx|xxxx|xxxx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前4个byte为长度，接着3次4个byte为数组内的整数数据。&lt;/p&gt;

&lt;p&gt;自定义二进制流协议格式为最不通用的格式，但也是最节省流量的协议，因为每个数据都可以用最小的方式进行定义，比如协议号不需要4个byte，2个byte大小2的16次-1就够用了，长度有可能也不需要4个byte，只要2个甚至1个byte就够用了，有些数据不需要4个byte组成int整数，只需要2个byte数组short就够用了，甚至有些可以组合起来使用，比如协议结构中有4个bool，可以拼成一个byte来传递，这些都可以完全由我们来控制包体的大小不受到任何规则的限制，这也是自定义二进制协议格式最吸引人的地方。&lt;/p&gt;

&lt;p&gt;自定义二进制流协议格式最大的缺点是不通用，当我们需要更换一个协议格式的时候，旧的协议格式就无法解析了，特别是当新的协议解析旧的协议时就会报错。我们也可以做些补救这种问题的措施，为了能让旧的协议格式还能继续使用，我们在每个数据头部都加入一个2个byte的整数代表版本号，由版本号来决定该读取哪个版本的协议，这样旧的协议也照样可以兼容新的协议，只是处理起来的时候需要注意些初始化问题，那些旧协议没有的而新协议有的数据则要尽可能的初始化成默认值以免造成逻辑报错。&lt;/p&gt;

&lt;h6&gt;MessagePack&lt;/h6&gt;

&lt;p&gt;MessagePack 是一个介乎于JSON和自定义二进制流之间的协议格式，他的理念是 ‘It’s like JSON. but fast and small.’ 。&lt;/p&gt;

&lt;p&gt;与JSON相同的是MessagePack也有采用Key-Value形式的Map映射类型，不同的是MessagePack用byte形式存储整数、浮点数、布尔值，并且在Map映射类型外加入了更多单独类型（非KEY-VALUE形式）的数据类型，其中也包括了自定义二进制流的数据类型。&lt;/p&gt;

&lt;p&gt;其中map映射类型是比较常用，也是比较通用的存储形式类型，也因为它的通用性被很多程序员所喜爱。&lt;/p&gt;

&lt;p&gt;使用起来能和JSON用起来一样，并且数据大小比JSON小，解析速度又比JSON快，是MessagePack最大的特点。&lt;/p&gt;

&lt;p&gt;非map类型的数据，其实和自定义二进制流的存储方式差不多，只是把原来的‘数据大小|数据’的形式改为了‘类型|数据’，比如存储一个4个byte也就是32位的整数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;+--------+--------+--------+--------+--------+
|  0xd2  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|
+--------+--------+--------+--------+--------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个byte的值0xd2代表32位整数类型，它表示后面4个byte组合起来是整数类型的数据。&lt;/p&gt;

&lt;p&gt;再举个列子，32位的浮点数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;+--------+--------+--------+--------+--------+
|  0xca  |XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|
+--------+--------+--------+--------+--------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个byte的值0xca代表32位浮点数类型，它表示后面4个byte组合起来是浮点数类型的数据。&lt;/p&gt;

&lt;p&gt;以此类推，nil，bool，8位无符号整数，16位无符号整数，32位无符号整数，64位无符号整数，8位有符号整数，16位有符号整数，32位有符号整数，64位有符号整数等，以及32位浮点数，64位浮点数，都用这种类似的方式表示。&lt;/p&gt;

&lt;p&gt;其实用MessagePack并不是冲着这些单独的数据类型去的，因为这些单独的数据类型完全可以用自定义二进制流代替，我们最关心的其实是它的map类型数据。&lt;/p&gt;

&lt;p&gt;我们专门来看看，MessagePack的map类型的存储机制，为什么就比JSON快，为什么就比JSON小，它是如何存储和解析的。&lt;/p&gt;

&lt;p&gt;在map之前我们看看数组类型的格式：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;+--------+--------+--------+~~~~~~~~~~~~~~~~~+
|  0xdc  |YYYYYYYY|YYYYYYYY|    N objects    |
+--------+--------+--------+~~~~~~~~~~~~~~~~~+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个byte的值0xdc代表是个总共可以存储16位长度的数组，也就是最大为2的16次-1个元素的数组，后面2个byte组合起来成为一个无符号的整数代表后面有多少个元素，接着后面N个为相同类型的元素的数据。&lt;/p&gt;

&lt;p&gt;假设说这N个为32位整数类型，那么就是如下格式&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;+--------+--------+--------+~~~~~~~~~~~~~~~~~+
|  0xdc  |00000000|00000011|  0xd2|00001001|0xd2|00001101|...(3 objects)
+--------+--------+--------+~~~~~~~~~~~~~~~~~+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个数组中指定了数组类型，以及数组元素的个数，接下来的数据就是单个元素的数据了，每个数据都包含了‘类型|数据’格式。&lt;/p&gt;

&lt;p&gt;其实map类型就是Array数组类型的变种，在数组类型上每个元素，多加了个KEY字符串，我们来看下map的格式：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;+--------+--------+--------+~~~~~~~~~~~~~~~~~+
|  0xde  |YYYYYYYY|YYYYYYYY|   N*2 objects   |
+--------+--------+--------+~~~~~~~~~~~~~~~~~+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个byte的值0xde代表是最大个数为16位的map类型数据，接着2个byte组合起来表示有多少个元素，再接着N乘2个元素为数据元素，其中以2个元素为一个组合，第一元素一定是字符串KEY，第二个元素为单独的任意的数据类型。&lt;/p&gt;

&lt;p&gt;我们用官方的例子来分析下：&lt;/p&gt;

&lt;p&gt;一个JSON类型的数据：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;{&amp;quot;compact&amp;quot;:true, &amp;quot;schema&amp;quot;:0}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在MessagePack中的map格式为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;82|A7|&amp;#39;c&amp;#39;|&amp;#39;o&amp;#39;|&amp;#39;m&amp;#39;|&amp;#39;p&amp;#39;|&amp;#39;a&amp;#39;|&amp;#39;c&amp;#39;|&amp;#39;t&amp;#39;|C3|A6|&amp;#39;s&amp;#39;|&amp;#39;c&amp;#39;|&amp;#39;h&amp;#39;|&amp;#39;e&amp;#39;|&amp;#39;m&amp;#39;|&amp;#39;a&amp;#39;|00|
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中8位前半个byte的值代表是个15个以内的map类型数据，8后面的2是后半个byte的值，代表总共有2个元素。&lt;/p&gt;

&lt;p&gt;接着A为前半个byte的值，代表是是个31个以内的字符串，A后面的7代表这个字符串拥有7个字符。&lt;/p&gt;

&lt;p&gt;接着7个元素都是字符。&lt;/p&gt;

&lt;p&gt;接着C3是KEY-VALUE的VALUE，这个VALUE是一个bool型的ture值。&lt;/p&gt;

&lt;p&gt;接着A6，A为前半个byte代表是31个以内的字符串，A后面的6代表这个字符串有6个字符。&lt;/p&gt;

&lt;p&gt;接着6个元素都是字符。&lt;/p&gt;

&lt;p&gt;最后00，前面0为前半个byte，表示类型为7位以内的整数，接着的0位后半个byte，代表数据为0。&lt;/p&gt;

&lt;p&gt;MessagePack整个map就是以这种“类型|数据”或者&amp;quot;类型|大小|数据&amp;quot;的方式存储。由于存储的方式是顺序，所以在解析的时候不需要排序，不需要解析符号和类型，数据的类型直接可以用byte来表示，能用byte存储绝不用字符串形式存储，能减少byte使用个数的尽量减少byte的使用个数，能合并的尽量合并为一个byte。&lt;/p&gt;

&lt;p&gt;因此MessagePack对于JSON来说，比JSON减少了大量的解析，比JSON减少了更多的数据空间，使得MessagePack能比起JSON来更快并且更小，就像它自己所说的那样 ‘It’s like JSON. but fast and small.’。&lt;/p&gt;

&lt;h3&gt;Protocol Buffer&lt;/h3&gt;

&lt;p&gt;MessagePack在JSON之上做了优化，其实可以看做是，把JSON和自定义二进制的合并做法，既汲取了JSON这种KEY-VALUE(键值对)通用性的优点，又汲取了自定义二进制流格式无需解析和存储空间小的特点。&lt;/p&gt;

&lt;p&gt;不过MessagePack的Map毕竟是kEY-VALUE形式的KEY值还是使用了字符串类型，它的KEY还是逃脱不了字符串string占用太多存储空间的弊端。&lt;/p&gt;

&lt;p&gt;Google Protocol Buffer 的出现就弥补了MessagePack的这个缺点，但是Google Protocol Buffer也有自身不可忽视的缺点，我们来看究竟Google Protocol Buffer是怎么的一种数据协议。&lt;/p&gt;

&lt;p&gt;Google Protocol Buffer( 简称 Protobuf) 是 Google 公司内部的混合语言数据标准，它们用于 RPC 系统和持续数据存储系统。&lt;/p&gt;

&lt;p&gt;Protobuf 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。&lt;/p&gt;

&lt;p&gt;常有人推崇说 Protocol Buffer 比JSON、MessagePack要好，那么它究竟好在哪里呢？我们就来分析下，为什么有这么多人推崇它。&lt;/p&gt;

&lt;p&gt;我们选择数据协议的目的主要关注的点是，它是否能更简单上手，解析数据是否能更快，存储空间是否能更小，通用性是否能更强。对于这些特点，Protocol Buffer 是否能都做到，还是说它只是在部分几个方面做到了，下面我们来透彻的对它剖析。&lt;/p&gt;

&lt;h6&gt;Protocol Buffer消息定义&lt;/h6&gt;

&lt;p&gt;创建扩展名为.proto的文件，如：MyMessage.proto，并将以下内容存入该文件中。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;message LoginReqMessage {
  required int64 acct_id = 1;
  required string passwd = 2;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;message是消息定义的关键字，等同于C#中的struct/class。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LoginReqMessage为消息的名字，等同于结构体名或类名。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;required前缀表示该字段为必要字段。即在序列化和反序列化之前该字段必须已经被赋值。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;与required相似的功能还存在另外两个类似的关键字，optional和repeated。&lt;/p&gt;

&lt;p&gt;optional表示该字段为可选字段，即在序列化和反序列化前可以不进行赋值。&lt;/p&gt;

&lt;p&gt;相比于optional，repeated主要用于表示数组字段。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;int64和string分别表示64位长整型和字符串型的消息字段。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在Protocol Buffer中存在一张类型对照表，既Protocol Buffer中的数据类型与其他编程语言(C#/Java/C++)中所用类型的对照。&lt;/p&gt;

&lt;p&gt;该对照表中还将给出在不同的数据场景下，哪种类型更为高效。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;acct_id 和 passwd 分别表示消息字段名，等同于C#中的域变量名。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;标签数字 1 和 2 表示不同的字段在序列化后的二进制数据中的布局位置。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在该例中，passwd 字段编码后的数据一定位于 acct_id 之后。需要注意的是该值在同一message中不能重复。&lt;/p&gt;

&lt;p&gt;对于Protocol Buffer而言，标签值为 1 到 15 的字段在编码时可以得到优化，即标签值和类型信息仅占有一个byte，标签范围是 16 到 2047 的将占有两个bytes，而Protocol Buffer可以支持的字段数量则为2的29次方减1。有鉴于此，我们在设计消息结构时，可以尽可能考虑让repeated类型的字段标签位于1到15之间，这样便可以有效的节省编码后的字节数量。&lt;/p&gt;

&lt;h6&gt;嵌套Protocol Buffer&lt;/h6&gt;

&lt;p&gt;我们可以在同一个.proto文件中定义多个message，这样便可以很容易的实现嵌套消息的定义。如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;required&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;required&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;optional&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;email&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

      &lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PhoneType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;MOBILE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;HOME&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;WORK&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

      &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PhoneNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;required&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;optional&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PhoneType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

      &lt;span class=&quot;n&quot;&gt;repeated&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PhoneNumber&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phones&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;repeated&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weight_recent_months&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;packed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AddressBook&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;repeated&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;people&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;AddressBook消息的定义中包含另外一个消息类型作为其字段Person，Person又包含了另一个消息类型作为字段PhoneNumber。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其中的 AddressBook 和 Person 被定义在同一个.proto文件中，也可以被分开来定义在各自的.proto文件中。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Protocol Buffer提供了另外一个关键字import，相当于 C++ 的Include，这样我们便可以将很多通用的message定义在同一个.proto文件中，而其他各模块功能的消息体定义在其他文件中，再通过import的方式将需要的结构体文件中定义的消息包含进来，如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;import &amp;quot;myproject/CommonMessages.proto&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;限定符 required、optional、repeated 的规则&lt;/h6&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在每个消息中必须至少有一个required类型的字段，保证数据中一定有至少一个数据。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;required限定符表示该字段为必要字段。即在序列化和反序列化之前该字段必须已经被赋值。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个消息中可以包含0个或多个optional类型的字段。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;optional表示该字段为可选字段，即在序列化和反序列化前可以不进行赋值，如果没有赋值则表示该数据为空。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;repeated表示的字段可以包含0个或多个重复的数据。注意，是重复的数据，可以等价于我们常使用的数组和列表，并且可以不赋值，则表示0个数据。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5&gt;Protocol Buffer 原理-序列化和反序列化&lt;/h5&gt;

&lt;p&gt;Protocol Buffer 是怎么识别和存储数据的，是序列化和反序列的关键。&lt;/p&gt;

&lt;p&gt;JSON 和 MessagePack 都使用了字符串的KEY作为映射到程序变量的关键字，变量和字符串用比较字符串的是否相等来判断是否为该变量，避免不了字符串太多而浪费空间。&lt;/p&gt;

&lt;p&gt;Protocol Buffer 则用数字编号来作为KEY的关键字，每个变量都必须有个不能重复的标签号(即数字编号)，用变量后面跟着的数字编号来映射到数据中的数字编号，进而读取数据。&lt;/p&gt;

&lt;p&gt;Protocol Buffer为每个变量都定义了一个标签号(即数字编号)，这个数字编号就代表了程序变量与指定编号数据的映射关系。&lt;/p&gt;

&lt;p&gt;有了这个规则还不够，因为程序在读取的时候，是不知道某个变量到底对应哪个标签号的，比如上面的Person的 name 变量，在程序里的 name 变量是不知道到底该读取哪个编号的数据的，除非在程序里写死。&lt;/p&gt;

&lt;p&gt;Protocol Buffer 就是使用了这种简单粗暴的方法，‘在程序里写死’的这种方式让事情变得更简单。&lt;/p&gt;

&lt;p&gt;‘在程序里写死’这种粗暴的方式最讲究周边工具了，Protocol Buffer就为很多种语言定制了生成序列化和反序列化程序代码的工具。只需要通过提供.proto文件就能生成相应语音的程序代码，在代码中把编号‘写死’，这一切代码都是自动生成的，我们只需要关心.proto文件中的结构。&lt;/p&gt;

&lt;p&gt;以就是说，当Protocol Buffer生成的解析代码在读数据的时候，一旦读取到编号为1的数据时，就把数据解析给 name 这个程序变量，这些都写死在代码中，而代码由Protocol Buffer工具生成。&lt;/p&gt;

&lt;h6&gt;我们使用上面提到的 AddressBook 数据结构来序列化一个 Protocol Buffer 数据。&lt;/h6&gt;

&lt;p&gt;加入数据的伪代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AddressBook&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address_book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address_book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add_people&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set_id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Jack&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set_email&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Jack@qq.com&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;PhoneNumber&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phone_number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_phones&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;phone_number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set_number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;123456&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;phone_number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;phone_number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add_phones&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;phone_number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set_number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;234567&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;phone_number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MOBILE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_weight_recent_months&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_weight_recent_months&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;52&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_weight_recent_months&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;54&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成出来的二进制数据流如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// (1 &amp;lt;&amp;lt; 3) + 2 = 0a，1为people的标签号,2为嵌入结构对应的类型号&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 0x3c = 60，表示接下来60个字节为Person的数据&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 下面进入到 repeated Person 数组的数据结构&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// (1 &amp;lt;&amp;lt; 3) + 2 = 0a，Person的第一个字段name的标签号为1，2为string(字符串)对应的类型号&lt;/span&gt;
&lt;span class=&quot;mo&quot;&gt;04&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// name字段的字符串长度为4&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;61&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;63&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// &amp;quot;Jack&amp;quot; 的ascii编码&lt;/span&gt;

&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// (2 &amp;lt;&amp;lt; 3) + 0 = 10，字段id的标签号为2，0为int32对应的类型号&lt;/span&gt;
&lt;span class=&quot;mo&quot;&gt;01&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// id的整型数据为1&lt;/span&gt;

&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// (3 &amp;lt;&amp;lt; 3) + 2 = 1a，字段email的标签号为3，2为string对应的类型号&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 0x0b = 11 email字段的字符串长度为11&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;61&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;63&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;71&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;71&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;63&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;6f&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;6d&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// &amp;quot;Jack@qq.com&amp;quot;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//第1个PhoneNumber，嵌套message&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// (4 &amp;lt;&amp;lt; 3) + 2 = 22，phones字段，标签号为4，2为嵌套结构对应的类型号&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 0a = 10，接下来10个字节为PhoneNumber的数据&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// (1 &amp;lt;&amp;lt; 3) + 2 =  0a, PhoneNumber的number，标签号为1，2为string对应的类型号&lt;/span&gt;
    &lt;span class=&quot;mo&quot;&gt;06&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// number字段的字符串长度为6&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;33&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;34&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;35&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;36&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// &amp;quot;123456&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// (2 &amp;lt;&amp;lt; 3) + 0 = 10，PhoneType type字段，0为enum对应的类型号&lt;/span&gt;
    &lt;span class=&quot;mo&quot;&gt;01&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// HOME，enum被视为整数&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 第2个PhoneNumber，嵌套message&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;06&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;33&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;34&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;35&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;36&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;37&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;00&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//信息解读同上，最后的00为MOBILE&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;06&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 1010 0010 0000 0110 varint方式，weight_recent_months的key&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//  010 0010  000 0110 → 000 0110 0100 010 little-endian存储&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// (100 &amp;lt;&amp;lt; 3) + 2 = a2 06，100为weight_recent_months的标签号&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//  2为 packed repeated field的类型号&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 0c = 12，后面12个字节为float的数据，每4个字节一个数据&lt;/span&gt;
&lt;span class=&quot;mo&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;48&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// float 50&lt;/span&gt;
&lt;span class=&quot;mo&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// float 52&lt;/span&gt;
&lt;span class=&quot;mo&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;58&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// float 54&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整个数据看下来都是遵循了简单的规则，即，标签号 + 类型号，最为头部标识，数据大小标识，作为可选标识，最后放入具体数据：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;标签号 + 类型号|数据大小|具体数据
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体数据中再嵌套不同种类的数据，也同样遵循 ‘标签号 + 类型号|数据大小|具体数据’ 这样的规则。&lt;/p&gt;

&lt;h6&gt;二进制数据流中反序列化为程序对象数据，我们重点看看其中 Person 结构的反序列过程：&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MergeFrom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CodedInputStream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ReadTag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_unknownFields&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UnknownFieldSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MergeFieldFrom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_unknownFields&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ReadString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ReadInt32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;email&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ReadString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;phones_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;AddEntriesFrom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_repeated_phones_codec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;weight_recent_months_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;AddEntriesFrom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_repeated_weight_recent_months_codec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上述Protocol Buffer生成的代码我们了解到，所有的对象变量都通过.proto文件中的标签号来识别数据是否与该变量有映射关系的，当拿到具体数据时，先判定属于哪个变量，再针对该变量的类型读取数据。&lt;/p&gt;

&lt;h6&gt;Protocol Buffer 不同版本消息的兼容问题&lt;/h6&gt;

&lt;p&gt;在实际的开发中会存在这样一种应用场景，即消息格式因为某些需求的变化而不得不进行必要的修改或者说升级，但是有些使用原有消息格式的应用程序暂时又不能被立刻升级，这便要求我们在升级消息格式时要遵守一定的规则，从而可以保证基于新老消息格式的新老程序能够同时运行。规则如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不要修改已经存在字段的标签号，即变量后面的数字，保证旧数据协议能够继续从数据中读取指定标签号的正确数据。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;任何新添加的字段必须是optional和repeated限定符，保证在旧数据无法加入新数据的情况下，新的协议还能够在旧数据协议之下继续顺利解析，否则无法保证新老程序在互相传递消息时的消息兼容性。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在原有的消息中，不能移除已经存在的required字段，虽然optional和repeated类型的字段可以被移除，但是他们之前使用的标签号必须被保留，不能被新的字段重用。因为旧协议在执行时还是会在旧的标签号中加入自己的数据，新协议如果使用了旧的标签号，就会导致新旧协议数据解析错误的问题。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;int32、uint32、int64、uint64和bool等类型之间是兼容的，sint32和sint64是兼容的，string和bytes是兼容的，fixed32和sfixed32，以及fixed64和sfixed64之间是兼容的，这意味着如果想修改原有字段的类型时，为了保证兼容性，只能将其修改为与其原有类型兼容的类型，否则就将打破新老消息格式的兼容性。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h6&gt;Protocol Buffer 的优点&lt;/h6&gt;

&lt;p&gt;Protobuf 全程使用二进制流形式，用整数代替了KEY来映射变量，比 XML、Json、MessagePack它们更小、更快、也更简单。&lt;/p&gt;

&lt;p&gt;我们可以定义自己的数据结构，然后使用Protobuf代码生成器生成的代码来读写这个数据结构。甚至可以在无需重新部署程序的情况下更新数据结构。只需使用 Protobuf 对数据结构进行一次描述，即可利用各种不同语言或从各种不同数据流中对你的结构化数据轻松读写。&lt;/p&gt;

&lt;p&gt;使用 Protobuf 无需学习复杂的文档对象模型，Protobuf 的编程模式比较友好，简单易学，同时它拥有良好的文档和示例，对于喜欢简单事物的人们而言，Protobuf 比其他的技术更加有吸引力。&lt;/p&gt;

&lt;p&gt;Protobuf 语义更清晰，无需类似 XML，JSON 解析器的东西，简化了解析的操作，减少了解析的消耗。&lt;/p&gt;

&lt;p&gt;Protobuf 数据使用二进制形式，把原来在JSON,XML里用字符串存储的数字换成用byte存储，大量减少了浪费的存储空间。与MessagePack相比，Protobuf减少了Key的存储空间，让原本用字符串来表达Key的方式换成了用整数表达，不但减少了存储空间也加快了反序列化的速度。&lt;/p&gt;

&lt;h6&gt;Protocol Buffer 的不足&lt;/h6&gt;

&lt;p&gt;Protbuf 与 XML 相比也有不足之处。它功能简单无法用来表示复杂的概念。&lt;/p&gt;

&lt;p&gt;XML 已经成为多种行业标准的编写工具，Protobuf 只是运用在数据传输与存储上，在通用性上还差很多。&lt;/p&gt;

&lt;p&gt;由于 XML 具有某种程度上的自解释性，它可以被人直接读取编辑，在这一点上 Protobuf 不行，它以二进制的方式存储，除非你有 .proto 定义，否则你没法直接读出 Protobuf 的任何内容。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;p&gt;《Protocol Buffers：阅读一个二进制文件》&lt;/p&gt;
</description>
               <pubDate>Sun, 16 Jun 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/06/16/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%825.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/06/16/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%825.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第六章，网络层(四) - 封装HTTP</title>
               <description>&lt;h3&gt;HTTP协议原理&lt;/h3&gt;

&lt;p&gt;HTTP俗称短连接，由于其连接的时间较短，不受前端所控制，所以在互联网开发圈内，通常被以‘短’字开头。&lt;/p&gt;

&lt;p&gt;在Unity3D短连接可以用.NET库来编写，也可以用U3D的内置API的WWW来写。差别不是很大，WWW对.Net做了封装，其功能已经完全够用在游戏开发上了，即使有情况不够用再用.NET补充也是很容易的事。(WWW在2018及以后的版本中都被废弃了，取代它的是UnityWebRequest，应该说封装的更好，但自定义部分则被削弱了。)&lt;/p&gt;

&lt;p&gt;其两者的区别主要还是WWW把.NET库封装后再加了层用协程使得我们开发者在使用时更加的便捷，.NET库则直接用了线程，导致开发者还需要关注主线程与子线程的资源锁。另外WWW里面已经实现了IP6转换，而使用.Net库则还需要自己解析IP6地址，虽然对程序员来说自己用.NET实现更加接近底层实现，但同时也带来了更多需要花精力关注的地方，夺走了程序员些许宝贵的精力。&lt;/p&gt;

&lt;p&gt;不管协程还是线程，其实两边都需要缓存和队列，如果没有缓存和队列，当网络请求量放大时就会出现数据丢失的情况。所以缓存机制在网络层是不可或缺的。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;我们所说的HTTP，最形象的描述就是网页(Web)形式的请求与回调。它被运用在最多的就是网页(Web)请求上，它是网页(Web) 上进行数据交换的基础。&lt;/p&gt;

&lt;p&gt;HTTP是一种 请求/响应式 的协议。也就是说，请求通常是由像浏览器这样的User-
Agent发起的，当像浏览器接收方收到数据后，再通过数据来处理相应的逻辑，每个请求都是一一对应的，一个请求有且最多只能得到一个响应。&lt;/p&gt;

&lt;p&gt;当我们要要展现一个网页时，浏览器首先发送一个请求，目的是从服务器获取页面的HTML文档，再解析文档中的资源信息然后才发送其他请求，例如获取可执行脚本或CSS样式来进行页面布局渲染，以及一些其它页面资源（如图片和视频等）。&lt;/p&gt;

&lt;p&gt;浏览器将这些资源整合到一起，展现出一个完整的网页。浏览器执行的脚本可以在之后的阶段发起更多的请求来获取更多信息和资源，从而可以不断的叠加、更新到当前的网页内容上来。&lt;/p&gt;

&lt;p&gt;我们常常会在游戏项目中把这套 请求/响应式 协议搬到了游戏中运用，那么为什么要用HTTP呢，用HTTP有什么好处呢？&lt;/p&gt;

&lt;p&gt;其最重要的原因是HTTP简单易用，上手成本低，功能扩展难度低，因此被广大互联网程序员所喜爱。&lt;/p&gt;

&lt;p&gt;HTTP是应用层上的协议，它并不需要其底层的传输层协议是面向连接的，只需要它是可靠的，或不丢失消息的（至少返回错误）。因此，HTTP依赖于面向连接的TCP进行消息传递，但HTTP本身对连接的需求并不是必须的，也就是说它本身是无状态的。&lt;/p&gt;

&lt;p&gt;HTTP本身并没有检测是否连接，数据是否传输准确，是否有数据到达等的机制，而是依赖于TCP协议，由TCP协议来做这些传输层的事情。HTTP在TCP之上，制定了自己的规则。&lt;/p&gt;

&lt;p&gt;HTTP在TCP之上制定了自己的规则：&lt;/p&gt;

&lt;p&gt;1.HTTP有自己的协议，HEADS和BODY&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    GET /root1/module?name1=value1&amp;amp;name2=value2 HTTP/1.1
    Host: localhost:8080
    Accept-Language: fr
    //这里HEADS 和 BODY一定是用空行隔开的
    body content
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 GET为方式，HTTP有很多种方式，其中GET和POST最为常用。GET方式是把参数值放在地址中，而POST则是把参数值放在协议数据包中，并且POST可以使用二进制作为参数值，而GET则不能。其两者的实质是一样的，都是以Key1=Value1&amp;amp;Key2=Value2的形式作为请求内容，他们两请求的参数都会被写入请求包体中。&lt;/p&gt;

&lt;p&gt;其协议中 HTTP/1.1为HTTP协议的版本号，我们现在常用的协议为1.1，也有少部分还在使用1.0。HTTP1.1兼容了1.0，并且在1.0之上改进了诸多内容，比如同一个地址不同host，增加了cache特性，增加Chunked transfer-coding标志切割数据块等。而2.0由于和1.1差别太大，不能兼容1.0和1.1，因此世界被分成了两块，HTTP2.0主要运用在HTTPS上，而HTTP1.1和1.0则运行在原有的HTTP上。&lt;/p&gt;

&lt;p&gt;body content是主要存储请求内容的，POST内容都放在这里。&lt;/p&gt;

&lt;p&gt;服务器收到请求处理相应逻辑后发送响应数据，其数据格式为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    HTTP/1.1 200
    Date:Mon,31Dec200104:25:57GMT
    Server:Apache/1.3.14(Unix)
    Content-type:text/html
    Last-modified:Tue,17Apr200106:46:28GMT
    Content-length:xxx

    //这里HEADS 和 BODY一定是用空行隔开的
    body content
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中200为响应后代表请求成功的错误码，其他常用的错误码可以简单理解为 404 找不到请求页，500 服务器程序报错，400 访问请求参数错误，403 被拒绝访问。&lt;/p&gt;

&lt;p&gt;2.HTTP是无状态但有会话的，两个执行成功的请求之间是没有关系的。&lt;/p&gt;

&lt;p&gt;无状态，是指对于事务处理没有记忆能力，前后两次的请求并没有任何相关性，可以是不同的连接，也可以是不同的客户端，服务器在处理无状态请求时，只关注当下这个连接请求时的可获取到的数据，不会去关心也没有记忆去关联上一次请求的状态。&lt;/p&gt;

&lt;p&gt;HTTP的访问请求一般都由软硬件做负载均衡来决定访问哪台物理服务器，进而两次同样地址的访问请求，有可能选择的服务器是不同的。&lt;/p&gt;

&lt;p&gt;无状态很好的匹配了这种近乎随机的访问方式，也就是说HTTP客户端可以任意选择一个部署在不同区域的服务器进行访问，得到的结果是相同的。&lt;/p&gt;

&lt;p&gt;3.HTTP每次请求访问结束会断开连接。&lt;/p&gt;

&lt;p&gt;HTTP是依据什么来断开连接的呢？content-length。&lt;/p&gt;

&lt;p&gt;content-length为 heads 上的标记，表示 body 内容长度。&lt;/p&gt;

&lt;p&gt;带content-length，body长度是可知的，客户端在接收body内容时，就可以依据这个长度来接受数据。接受完毕后，就表示这个请求完毕了。客户端主动调用close进入四次挥手断开连接。&lt;/p&gt;

&lt;p&gt;假如没有content-length 标记，那么body内容长度是不可知的，客户端会一直接受数据，直到服务端主动断开。&lt;/p&gt;

&lt;p&gt;HTTP1.1在这个断开规则之上又扩展了一种新规则，即增加了Transfer-encoding标记。如果Transfer-encoding为chunked，则表示body是流式输出，body会被分成多个块，每块的开始会标识出当前块的长度，此时body不需要通过content-length长度来指定了。&lt;/p&gt;

&lt;p&gt;HEADS上带有Transfer-encoding:chunked 就表示body被分成很多块，每块的长度也是可知的，当客户端根据长度接受完毕数据后，就会主动断开连接。&lt;/p&gt;

&lt;p&gt;假如说Transfer-encoding 和 content-length 这两个标记都没有，那么就只能一直接受数据直到服务器主动断开连接。&lt;/p&gt;

&lt;p&gt;那么有没有一种可能，既想使用HTTP协议又不想断开连接的？&lt;/p&gt;

&lt;p&gt;使用keep-alive标识，keep-alive标识会让客户端与服务器的连接保持状态，直到服务器发现空闲时间结束而断开连接，在结束时间内我们仍然能发送数据。也在就是说，可以减少多次的与服务器3次握手建立连接，以及多次与服务器4次握手断开连接，提高了传输效率。&lt;/p&gt;

&lt;p&gt;而在服务器端上，Nginx的 keepalive&lt;em&gt;timeout，和Apache的 KeepAliveTimeout 都能设置 Keep-alive 的空闲时间大小，当httpd守护进程发送完一个响应后，理应马上主动关闭相应的TCP连接，但设置 keepalive&lt;/em&gt;timeout后，httpd守护进程会说：”再等等吧，看看客户端还有没有请求过来”，这一等，便是 keepalive_timeout时间。如果守护进程在这个等待的时间里，一直没有收到客户端发过来HTTP请求，则关闭这个HTTP连接。&lt;/p&gt;

&lt;p&gt;但也不一定说使用keep-alive标识能提高效率，有时也会反而降低了效率。比如经常会没有数据需要发送，导致长时间的Tcp连接保持导致系统资源无效占用，浪费系统资源，巨量的保持连接会浪费巨量的资源。&lt;/p&gt;

&lt;p&gt;如果客户端使用keep-alive，则需要在连续发送数据时，使用同一个HTTP连接实例。并且在发送完毕后要记录空闲时间，以便再次发送时，可以判断是否继续使用该连接，因为通常服务器端主动断开连接后并没有被客户端及时的得知，所以自行判断是否有可能已经被服务器端断开连接为好。还有一个问题是，如果网络环境不好导致发送请求无法到达时，则要尽可能的自己记录和判断，哪些数据是需要重发的。这几个问题增加了HTTP作为keep-alive来保持连接的操作难度，将本来简单便捷的HTTP，推向了有点长连接的味道。&lt;/p&gt;

&lt;h6&gt;在Unity3D中的HTTP封装&lt;/h6&gt;

&lt;p&gt;Unity3D的2018版本中原本经常用的WWW类已经被废弃，取而代之的是UnityWebRequest。&lt;/p&gt;

&lt;p&gt;API改了但功能都是一样的，我们主要还是围绕HTTP的原理来写程序，也只有这样才能真正写出程序的精髓。&lt;/p&gt;

&lt;p&gt;UnityWebRequest里有几个接口对我们来说比较重要，一个是Post(string uri, WWWForm postData)接口用来创建一个带有地址和Post数据的UnityWebRequest实例，一个是SendWebRequest()用来开始发送请求和迭代请求的接口，另一个是SetRequestHeader(string name, string value)用来设置HTTP头的，其中它说下面这些HEAD标记不支持设置：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    These headers cannot be set with custom values on any platform: accept-charset, access-control-request-headers, access-control-request-method, connection, date, dnt, expect, host, keep-alive, origin, referer, te, trailer, transfer-encoding, upgrade, via.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些标记都是什么意思呢，&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    accept-charset: 用于告诉服务器，客户机采用的编码格式

    access-control-request-headers: 在预检请求中，用于通知服务器在真正的请求中会采用哪些请求首部

    access-control-request-method: 在预检请求中，用于通知服务器在真正的请求中会采用哪种 HTTP 方法

    connection: 处理完这次请求后是否断开连接还是继续保持连接

    date: 当前时间值

    dnt:  (Do Not Track) 表明了用户对于网站追踪的偏好。

    expect: 是一个请求消息头，包含一个期望条件，表示服务器只有在满足此期望条件的情况下才能妥善地处理请求。服务器开始检查请求消息头，可能会返回一个状态码为 100 (Continue) 的回复来告知客户端继续发送消息体，也可能会返回一个状态码为417 (Expectation Failed) 的回复来告知对方要求不能得到满足。

    host: 请求头指明了服务器的域名(对于虚拟主机来说)，以及服务器监听的TCP端口号。

    keep-alive: 允许消息发送者暗示连接的状态，还可以用来设置超时时长和最大请求数。

    origin: 指示了此次请求发起者来自于哪个站点。

    referer: 表示当前页面是通过此来源页面里的链接进入的，与origin相似。

    te: 指定用户代理希望使用的传输编码类型

    trailer: 允许发送方在分块发送的消息后面添加额外的元信息，这些元信息可能是随着消息主体的发送动态生成的，比如消息的完整性校验，消息的数字签名，或者消息经过处理之后的最终状态等。

    transfer-encoding: 指明了将 entity 安全传递给用户所采用的编码形式。transfer-encoding是一个逐跳传输消息首部，即仅应用于两个节点之间的消息传递，而不是所请求的资源本身。一个多节点连接中的每一段都可以应用不同的Transfer-Encoding 值。

    upgrade: 升级为其他协议

    via: 代理服务器相关的信息
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上这些由HEAD扩展的HTTP功能都不能进行自主的选择，其中包括了我们比较关心的标识 connection 和 keep-alive 保持连接的功能，代表了我们无法用UnityWebRequest来实现一次连接发送多次数据的需求。&lt;/p&gt;

&lt;p&gt;另外我们最关心的content-length也不能被自定义设置，而是由API本身来自动设置。&lt;/p&gt;

&lt;p&gt;与原来WWWW的API不同的是，UnityWebRequest更加简洁方便，但也失去了一些自定义的功能。接下来我们来使用UnityWebRequest封装HTTP网络层。&lt;/p&gt;

&lt;p&gt;我们必须设计一个类，比如建个名称为HTTPRequest的类，每次请求服务器都调用这个类的方法来处理一个请求的操作。把地址，参数，回调传进去，等待服务器相应和回调。&lt;/p&gt;

&lt;p&gt;短连接接口相对较少，其中POST,GET,HEAD,Start，这几个接口最为关键。在UnityWebRequest中对应的是&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    POST: UnityWebRequest UnityWebRequest.Post(string uri, WWWForm postData) (静态函数)

    GET: UnityWebRequest UnityWebRequest.Get(string uri) (静态函数)

    HEAD: UnityWebRequest.SetRequestHeader(string name, string value) (非静态函数)

    Start: UnityWebRequest.SendWebRequest() (非静态函数)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用这四个API就能实现HTTP基本的发送与接收。&lt;/p&gt;

&lt;p&gt;在调用UnityWebRequest发送请求时可以用协程也可以在逻辑更新中进行判断收发过程。&lt;/p&gt;

&lt;p&gt;不过在协程中不太可控，并且每次都起一个携程来发送数据也浪费资源，并且协程结束时随着函数调用结束而结束的，而我们时常会有需要暂停，继续等操作。所以一般都会把HTTP的收发判断移到逻辑更新中的Update里去，这样做更容易理解，也更容易掌控。&lt;/p&gt;

&lt;p&gt;下面我们建立一个类来封装UnityWebRequest的收发过程：&lt;/p&gt;

&lt;p&gt;1.建立实例开始连接和发送请求，设置好这次请求回应的回调句柄。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    void StartRequest(string url, Callback _callback)
    {
        this.web_request = UnityWebRequest.Get(url);
        this.Callback =  _callback;
        this.web_request.SendWebRequest();
    }

    or POST

    void StartRequest(string url, WWWForm wwwform, Callback _callback)
    {
        this.web_request = UnityWebRequest.POST(url, wwwform);
        this.Callback =  _callback;
        this.web_request.SendWebRequest();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.判断是否完成或者说发送请求是否完毕,并且调用回调函数&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    void Update()
    {
        if(web_request != null)
        {
            if(web_request.isDone)
            {
                ProcessResponse(web_request);
                web_request.Dispose();
                web_request = null;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.处理数据，先判断有错误存在，如果没有错误则对数据进行处理，HTTP回应的数据格式比较多，比如Json格式的，Xml格式等等。对数据进行解析后变为具体的类实例，再传给相应的函数句柄进行调用。所以这里数据格式协议也是关键。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    void ProcessResponse(UnityWebRequest _WebRequest)
    {
        if(_WebRequest.error != null)
        {
            NetworkErrorReport(_www.error);
            return;
        }
        CallbackResponse(_WebRequest.downloadHandler.text);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上是用UnityWebRequest做HTTP请求的基本步骤。在具体项目中看似简单的连接，发送，接收过程中也有不少事情需要我们做。特别是游戏逻辑中，大量多次，频繁发送HTTP请求的问题的延伸和提出的解决方案。&lt;/p&gt;

&lt;p&gt;多次或者连续发送HTTP请求引起的问题&lt;/p&gt;

&lt;p&gt;多次或者连续请求HTTP在具体项目中比价常见，比如客户端向服务器请求角色信息，并且请求军团信息，并且请求每日任务信息，然后再显示主界面。&lt;/p&gt;

&lt;p&gt;这种连续的多次的请求HTTP，会同时触发多个线程向服务器做请求操作，建立连接，发送请求，关闭连接，而得到服务器返回时，却不知道哪个在先哪个在后，例如军团信息有可能先得到响应，然后再是每日任务信息得到了响应，再是角色信息得到了响应，因为是多个线程发起的多个连接，服务端接受到的数据也是没有顺序的，即使服务器端接受的顺序刚好没有打乱顺序，在处理和回调的时机也是不可知的，导致回调的顺序不可知，所以并不能确定响应的顺序与请求的顺序是一样的。&lt;/p&gt;

&lt;p&gt;当接受数据的顺序无法确定时，如果还用顺序接受数据的方式处理出具则有风险，比如我们在发送，军团，任务，角色数据请求后，希望能够在三者都到齐的情况下执行某个程序逻辑，如果得到的数据是顺序的，则我们可以确定在收到角色数据后表明所有的数据都到齐了，于是我们再执行逻辑程序。&lt;/p&gt;

&lt;h6&gt;解决方案1：多开线程发送请求数据，等待所有数据到齐再调用执行逻辑。&lt;/h6&gt;

&lt;p&gt;每个HTTP(也可以认为是UnityWebRequest)请求都会开一个线程来向服务器请求数据，多个HTTP请求同时开启，相当于多个线程同时工作提高了网络效率。&lt;/p&gt;

&lt;p&gt;我们可以用HTTP这种开线程的方式做，当需要多个请求的回应数据时，开启多个HTTP请求，等到数据全部得到相应后再处理逻辑。&lt;/p&gt;

&lt;p&gt;这里有一个限制，我们需要假设多次请求之间没有且不需要逻辑顺序，则可以使用同时发起多次HTTP请求，并且等待所有请求结束后再做逻辑处理。&lt;/p&gt;

&lt;p&gt;多次请求的响应数据的需求问题，其本质是‘如何判断我们需要的多条数据是否已经都到达’。&lt;/p&gt;

&lt;p&gt;为了能更快的，更高效的得到HTTP请求数据，在同一时间同时向服务器发起多个HTTP请求，并且等待所有请求都得到响应后才执行逻辑程序，即等待并辨认多次请求是否全数收到。&lt;/p&gt;

&lt;p&gt;在Unity3D上伪代码及注释如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    class multiple_request
    {
        void StartRequest( request_list, call_back )
        {
            lst_req = new List&amp;lt;UnityWebRequest&amp;gt;();
            for( url,wwwform in request_list )
            {
                //开启多个HTTP请求
                UnityWebRequest req = UnityWebRequest.Post(url, wwwform);
                req.SendWebRequest();

                //记录请求实例
                lst_req.Add(req);
            }

            //记录回调函数
            Callback = call_back;
        }

        void Update()
        {
            if(lst_req == null || lst_req.Count &amp;lt;= 0) return;

            for( UnityWebRequest req in lst_req)
            {
                //判断是否完成该请求，只要有一个没完成就继续等待
                if(!req.isDone)
                {
                    return;
                }
            }

            //当全部请求都完成时，执行回调
            Callback(lst_req);

            //请求结束并清空
            lst_req.Clear();
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方式同时开启多个HTTP连接来向服务器请求数据，极大程度地加速了数据的响应速度，最大限度的提高了服务器端的CPU利用率，但请求彼此之间必须没有顺序关系，只有这样服务器端的执行顺序才无序担心。&lt;/p&gt;

&lt;p&gt;如果请求之间是有顺序要求的，服务器端执行顺序无法保障则容易出现逻辑顺序问题，比如会有多个这样的请求，购买物品，出售物品，使用物品，三个请求一起被发起，服务器接受到的请求顺序有可能是，使用物品，出售物品，再购买物品，当顺序不同时就有可能存在逻辑问题，与我们原本设想的逻辑存在偏差，物品可能先被使用或出售，而不是被先购买，导致没有物品可被使用或出售，跟我们的所预期不一致。&lt;/p&gt;

&lt;p&gt;提高了网络效率，服务器的CPU利用率，却无法保证预期的逻辑顺序，在需要顺序的功能上必出现诸多错误。&lt;/p&gt;

&lt;p&gt;因此这种解决方案在需要逻辑顺序的连接请求上无法运作，但在不需要逻辑顺的连接请求上可以极大的提高网络连接利用率。&lt;/p&gt;

&lt;h6&gt;解决方案2：逐个发起请求，保证顺序。&lt;/h6&gt;

&lt;p&gt;逐个发送请求的方式最常见也比较普遍的做法，在网页端，安卓原生端，苹果原生端都使用这种方式来做请求，即每次只处理一个请求，当这个请求结束后再发起下一个请求，即一个请求对应一个功能模块，结束当前功能模块后再发起下一个请求。&lt;/p&gt;

&lt;p&gt;例如前面所描述的例子，请求角色信息，并且请求军团信息，并且请求每日任务信息，每次只做一件事，收到角色信息数据后，再发起请求军团信息，收到军团信息后，再发起请求任务信息，收到任务信息后再显示在界面，每个请求都会被动态的分配一个回调函数，当某个请求的数据需要做别的事情的时候，就分配一个不同回调函数。&lt;/p&gt;

&lt;p&gt;也就是说，当请求角色信息前，我们可以分配一个自定义句柄，当接受到数据后，回调执行这个自定义句柄。在自定义句柄里，可以继续发送我们需要请求的数据或功能，或者执行其他逻辑。&lt;/p&gt;

&lt;p&gt;伪代码为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    void on_button_click()
    {
        //请求角色数据
        function_request_roleinfo( callback_function1 ) 
    }

    void callback_function1( data )
    {
        //记录角色信息
        role_info.Add(data);

        //请求军团信息
        function_request_groupinfo( callback_function2 )
    }

    void callback_function2( data )
    {
        //记录军团信息
        group_info.Add( data );

        //请求任务信息
        function_request_task( callback_funciton3 );
    }

    void callback_function3( data )
    {
        //记录任务信息
        task_info.Add( data);

        //展示UI
        show_ui();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;伪代码展示了发送请求的逻辑顺序，这种逐个发送请求的方式，保证了逻辑顺序，同时也满足了对多样化功能的扩展，同一个请求可以在不同逻辑处拥有自己的自定义回调。&lt;/p&gt;

&lt;p&gt;单个连接的自定义方式确实保证了顺序，但也降低了网络连接效率，多个请求需要发起多个TPC连接，每个连接都需要等待上一个连接请求完毕后才能开始下一个请求，每次收到消息后都需要发起4次握手的断开连接‘仪式’，每次发起请求时又必须进行3次握手的建立连接‘仪式’，消耗网络连接资源降低了收发效率。&lt;/p&gt;

&lt;p&gt;另一种逐个发送请求的方式，为了保证请求的顺序进行，可以使用发送队列和接收队列来做逐个发送的模式。&lt;/p&gt;

&lt;p&gt;队列在请求和响应中起到了缓冲的作用，当连续使用HTTP请求，连续收到HTTP响应的时候，能够依次处理相应的逻辑。&lt;/p&gt;

&lt;p&gt;因为全程是只有1个线程在做请求处理，所以并不需要线程锁之类的操作。发送时，向队列推送请求实例。在逻辑更新上，判断是否有请求在队列里，有的话推出来，做HTTP请求操作，并将请求的相关信息存起来，当得到服务器响应时，调用请求信息中的回调函数，处理回调句柄。&lt;/p&gt;

&lt;p&gt;发送和接收队列的伪代码:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    //将请求推入队列
    void RequestHttp(Request req)
    {
        ListRequest.Push(req);
    }

    //逻辑更新
    void Update()
    {
        //是否完成HTTP
        If( IsHttpFinished() )
        {
            //开始新的请求
            Request  req = ListRequest.Pop();
            mCurrentRequest = req;
            StartHttpRequest(req);
        }
        else
        {
            //是否收到响应
            If(HttpIsDone())
            {
                //根据响应数据处理逻辑
                ProcessResponse(data);

                //完成HTTP
                FinishHttp();
            }
        }
    }

    //根据数据处理逻辑
    void ProcessResponse(Response data)
    {
        If(mCurrentRequest != null
            &amp;amp;&amp;amp; mCurrentRequest.Callback != null)
        {
            //回调句柄
            mCurrentRequest.Callback(data);
            mCurrentRequest = null;
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上阐述了，在发送HTTP请求时的推入队列操作和在收到请求后的句柄响应操作，队列使我们做到了逐个请求以及逐个响应。&lt;/p&gt;

&lt;h6&gt;解决方案3：多连接与逐个发送，并行使用。&lt;/h6&gt;

&lt;p&gt;多连接提高网络请求效率但没有一致的响应顺序，逐个发送有一致的响应顺序网络请求效率则不够好。&lt;/p&gt;

&lt;p&gt;两者之间没有排斥关系，可以并行使用，既提高了网络请求效率，又保证了顺序。&lt;/p&gt;

&lt;p&gt;仍然使用前面解决方案1中的类 multiple&lt;em&gt;request ，原本 multiple&lt;/em&gt;request 类可以传入多个请求数据，并等待全部相应结束后再执行回调。然后再在 multiple_request 中回调中执行下一个请求。&lt;/p&gt;

&lt;p&gt;伪代码如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    //界面按钮
    void on_click()
    {
        //新建一个请求对象
        request1 = new request();
        request1.url = url1;
        request1.wwwform = new wwwform();
        request1.wwwform.AddField(&amp;quot;name1&amp;quot;,&amp;quot;value1&amp;quot;);

        //加入请求列表
        lst_request.Add(request1);

        //兴建一个请求对象
        request2 = new request();
        request2.url = url2;
        request2.wwwform = new wwwform();
        request2.wwwform.AddField(&amp;quot;name21&amp;quot;,&amp;quot;value21&amp;quot;);

        //加入请求列表
        lst_request.Add(request2);

        //新建一个请求对象
        request2 = new request();
        request2.url = url3;
        request2.wwwform = new wwwform();
        request2.wwwform.AddField(&amp;quot;name22&amp;quot;,&amp;quot;value22&amp;quot;);

        //加入请求列表
        lst_request.Add(request3);

        //新建多请求实例
        multiple_request req = new multiple_request();

        //开始多个请求对象开启HTTP请求
        req.StartRequest(lst_request, callback_function1);
    }

    void callback_fucntion1(lst_request)
    {
        //做些逻辑
        do_some_function(lst_request);

        //新建一个请求对象
        request1 = new request();
        request1.url = url1;
        request1.wwwform = new wwwform();
        request1.wwwform.AddField(&amp;quot;name1&amp;quot;,&amp;quot;value1&amp;quot;);

        //加入请求列表
        lst_request.Add(request1);

        //兴建一个请求对象
        request2 = new request();
        request2.url = url2;
        request2.wwwform = new wwwform();
        request2.wwwform.AddField(&amp;quot;name21&amp;quot;,&amp;quot;value21&amp;quot;);

        //新建多请求实例
        multiple_request req = new multiple_request();

        //开始多个请求对象开启HTTP请求
        req.StartRequest(lst_request, callback_function2);
    }

    void callback_function2(lst_request)
    {
        //将信息展示到UI
        show_ui(lst_request);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;伪代码中展示了如何多请求与逐个请求的并行使用，将多个请求看成一个请求的变体，将多个请求看成一个完整的功能块，就有了多请求与逐个请求的并行使用过程。&lt;/p&gt;

&lt;p&gt;伪代码中展示的编码过程太过繁琐，展示出每一步的编码是为了让读者能更容易理解，多请求连接与逐个请求并行使用的理念。&lt;/p&gt;

&lt;p&gt;在现实项目中，完全可以为每个网络功能新建一个类，继承 multiple_request 类，并且将所有参数写进子类中，一并发送，并且可以多次使用在多个地方。&lt;/p&gt;

&lt;p&gt;伪代码:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    //新建个父类继承 multiple_request 专门用来做某个功能，这个功能里需要请求多条数据
    class do_something : multiple_request
    {
        void StartRequest( int val1 , int val2, int val3, call_back )
        {
            //新建一个请求对象
            request1 = new request();
            request1.url = url1;
            request1.wwwform = new wwwform();
            request1.wwwform.AddField(&amp;quot;name1&amp;quot;,&amp;quot;value1&amp;quot;);

            //加入请求列表
            request_list.Add(request1);

            //兴建一个请求对象
            request2 = new request();
            request2.url = url2;
            request2.wwwform = new wwwform();
            request2.wwwform.AddField(&amp;quot;name21&amp;quot;,&amp;quot;value21&amp;quot;);

            //加入请求列表
            request_list.Add(request2);

            //新建一个请求对象
            request2 = new request();
            request2.url = url3;
            request2.wwwform = new wwwform();
            request2.wwwform.AddField(&amp;quot;name22&amp;quot;,&amp;quot;value22&amp;quot;);

            base.StartRequest(request_list, call_back);
        }
    }

    //ui上的按钮
    void on_click()
    {
        //实例化功能对象
        do_something = new do_something();

        //开始请求
        do_something.StartRequest(1,2,3, call_back_function1);
    }

    //回调1
    void call_back_function1(lst_request)
    {
        //做点事
        do_something(lst_requset);

        //实例化功能2的对象
        do_something2 = do_something2();

        //开始请求
        do_something2.StartRequest(3,2, call_back_function2);
    }

    //回调2
    void call_back_function2(lst_request)
    {
        //展示UI
        show_ui(lst_request);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上所描述的，在实际项目中可以用子类继承父类功能的方法，复用了请求的步骤，使得需要某个功能时使用起来更加便捷。&lt;/p&gt;

&lt;h6&gt;解决方案4：合并请求，并逐个发送合并后的请求包。&lt;/h6&gt;

&lt;p&gt;多个请求与逐一发送合并的解决方案，确实既提高了发送效率，又保证了顺序，但还是有几个缺点。&lt;/p&gt;

&lt;p&gt;缺点1，多开连接，连接数增多，服务器建立和断开连接的压力增大。&lt;/p&gt;

&lt;p&gt;缺点2，使用操作不方便，必须手动建立新功能类。&lt;/p&gt;

&lt;p&gt;缺点3，多功能间的顺序，必须手动排列顺序。&lt;/p&gt;

&lt;p&gt;客户端更希望的是多次请求能够被同时发出，收到的响应顺序也要按原来请求的顺序响应，并且要可以自定义回调句柄满足多样化的功能扩展。&lt;/p&gt;

&lt;p&gt;合并请求就成了更好的解决方案。合并多个请求的数据进一个请求中，再发起请求，一次打包多个请求，只发一次能全部响应回来，发送这个合并包则可以做到与发起多个连接同样的效果，并且响应也可以做到顺序一致性。&lt;/p&gt;

&lt;p&gt;合并请求，减少了连接数量，提高了网络效率，同时也可以保证顺序的一致性。&lt;/p&gt;

&lt;p&gt;如何实现呢？&lt;/p&gt;

&lt;p&gt;这需要服务端程序员一些配合，服务端需要将原本多个地址，每个地址对应的功能块的模式，改为同一个地址，并且改为用commoand id 字段来对应不同的功能块。&lt;/p&gt;

&lt;p&gt;我们以json为例，HTTP数据使用json格式，服务器响应也是json格式。每次请求，客户端都会发送格式给服务器，服务器收到后解析json格式数据，然后提取变量。&lt;/p&gt;

&lt;p&gt;我们在对多个请求进行合并时，可以将多个json请求格式，推入一个大的json数据中，为每个json数据添加一个序列号，以代表请求顺序，如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    //请求1
    {
        &amp;quot;request-order&amp;quot; : 1,
        &amp;quot;command&amp;quot; : 1001,
        &amp;quot;data1&amp;quot; : &amp;quot;i am text&amp;quot;,
        &amp;quot;data2&amp;quot; : &amp;quot;i am num&amp;quot;,
    }

    //请求2
    {
        &amp;quot;request-order&amp;quot; : 2,
        &amp;quot;command&amp;quot; : 2011,
        &amp;quot;book&amp;quot; : &amp;quot;i am text&amp;quot;,
        &amp;quot;chat&amp;quot; : &amp;quot;i am num&amp;quot;,
        &amp;quot;level&amp;quot; : 1，
    }

    //请求3
    {
        &amp;quot;request-order&amp;quot; : 3,
        &amp;quot;command&amp;quot; : 3105,
        &amp;quot;image&amp;quot; : &amp;quot;i am text&amp;quot;,
        &amp;quot;doc&amp;quot; : &amp;quot;i am num&amp;quot;,
    }

    //将1，2，3合并后的请求数据为
    {
        &amp;quot;data&amp;quot;:
        [
            {
                &amp;quot;request-order&amp;quot; : 1,
                &amp;quot;command&amp;quot; : 1001,
                &amp;quot;data1&amp;quot; : &amp;quot;i am text&amp;quot;,
                &amp;quot;data2&amp;quot; : &amp;quot;i am num&amp;quot;,
            }
            ,
            {
                &amp;quot;request-order&amp;quot; : 2,
                &amp;quot;command&amp;quot; : 2011,
                &amp;quot;book&amp;quot; : &amp;quot;i am text&amp;quot;,
                &amp;quot;chat&amp;quot; : &amp;quot;i am num&amp;quot;,
                &amp;quot;level&amp;quot; : 1;
            }
            ,
            {
                &amp;quot;request-order&amp;quot; : 3,
                &amp;quot;command&amp;quot; : 3105,
                &amp;quot;image&amp;quot; : &amp;quot;i am text&amp;quot;,
                &amp;quot;doc&amp;quot; : &amp;quot;i am num&amp;quot;,
            }
        ],
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;合并后多个json被推入数组中发送给服务器，服务器拿到数据后对data中的数据进行提取和处理，处理顺序按照request-order来做，每个数据块都有一个command字段，用这个字段来判断使用哪个功能模块，将数据传给该功能模块处理。&lt;/p&gt;

&lt;p&gt;每个功能模块处理完毕后，将所有响应数据都推入同一个json实例中，并且附上与请求数据中相同的request-order，再把整个响应数据发送给客户端，当客户端收到数据时，就可以通过request-order知道响应数据的顺序了，按照request-order排序后，再进行解析和回调，得到了与请求顺序一致的响应顺序。&lt;/p&gt;

&lt;p&gt;合并响应后的例子如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    //响应数据1
    {
        &amp;quot;response-order&amp;quot; : 1,
        &amp;quot;command&amp;quot; : 1001,
        &amp;quot;data1&amp;quot; : &amp;quot;response text&amp;quot;,
        &amp;quot;data2&amp;quot; : &amp;quot;response num&amp;quot;,
        &amp;quot;error_code&amp;quot; : &amp;quot;0&amp;quot;, 
    }

    //响应数据2
    {
        &amp;quot;response-order&amp;quot; : 2,
        &amp;quot;command&amp;quot; : 2011,
        &amp;quot;data1&amp;quot; : &amp;quot;response text&amp;quot;,
        &amp;quot;data2&amp;quot; : &amp;quot;response num&amp;quot;,
        &amp;quot;error_code&amp;quot; : &amp;quot;1&amp;quot;,
    }

    //响应数据3
    {
        &amp;quot;response-order&amp;quot; : 3
        &amp;quot;command&amp;quot; : 3105,
        &amp;quot;data1&amp;quot; : &amp;quot;response text&amp;quot;,
        &amp;quot;data2&amp;quot; : &amp;quot;response num&amp;quot;,
        &amp;quot;error_code&amp;quot; : &amp;quot;2&amp;quot;,
    }

    //合并后的响应数据
    {
        &amp;quot;error_code&amp;quot; : 0,
        &amp;quot;data&amp;quot;:
        [
            {
                &amp;quot;response-order&amp;quot; : 1,
                &amp;quot;command&amp;quot; : 1001,
                &amp;quot;data1&amp;quot; : &amp;quot;response text&amp;quot;,
                &amp;quot;data2&amp;quot; : &amp;quot;response num&amp;quot;,
                &amp;quot;error_code&amp;quot; : &amp;quot;0&amp;quot;, 
            }
            ,
            {
                &amp;quot;response-order&amp;quot; : 2,
                &amp;quot;command&amp;quot; : 2011,
                &amp;quot;data1&amp;quot; : &amp;quot;response text&amp;quot;,
                &amp;quot;data2&amp;quot; : &amp;quot;response num&amp;quot;,
                &amp;quot;error_code&amp;quot; : &amp;quot;1&amp;quot;,
            }
            ,
            {
                &amp;quot;response-order&amp;quot; : 3
                &amp;quot;command&amp;quot; : 3105,
                &amp;quot;data1&amp;quot; : &amp;quot;response text&amp;quot;,
                &amp;quot;data2&amp;quot; : &amp;quot;response num&amp;quot;,
                &amp;quot;error_code&amp;quot; : &amp;quot;2&amp;quot;,
            }
        ]
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得到合并后的响应数据后，客户端要先提取data数据中的所有数据，以respose-order为基准进行排序，头部最小序号的先处理，解析，回调。&lt;/p&gt;

&lt;p&gt;不仅仅是合并，我们还要保证发送的顺序，多个合并请求一同发送则会遇到大麻烦，也就是顺序问题，所以需要用队列来规避。&lt;/p&gt;

&lt;p&gt;用了队列的方式保证请求的有序性，并且在队列之上进行操作请求合并，能更有效更便捷的进行合并。&lt;/p&gt;

&lt;p&gt;队列与合并结合的伪代码如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    //将请求推入队列
    void RequestHttp(Request req)
    {
        ListRequest.Push(req);
    }

    //逻辑更新
    void Update()
    {
        //是否完成HTTP
        If( IsHttpFinished() )
        {
            //推出多个请求进行合并
            lst_combine_req.Clear();
            for(int i = 0 ; i&amp;lt;10 ; i++)
            {
                Request  req = ListRequest.Pop();
                lst_combine_req.Add(req);
            }

            combine_request = CombineRequest(lst_combine_req);
            StartHttpRequest(req);
        }
        else
        {
            //是否收到响应
            If(HttpIsDone())
            {
                //排序
                sort(combine_request.lst_response);

                //循环处理每个响应逻辑
                for(int i = 0 ; i&amp;lt;combine_request.lst_response.count ; i++)
                {
                    //根据响应数据处理逻辑
                    data = combine_request.lst_response[i];
                    ProcessResponse(data);
                }

                //完成HTTP
                FinishHttp();
            }
        }
    }

    //根据数据处理逻辑
    void ProcessResponse(Response data)
    {
        If(mCurrentRequest != null
            &amp;amp;&amp;amp; mCurrentRequest.Callback != null)
        {
            //回调句柄
            mCurrentRequest.Callback(data);
            mCurrentRequest = null;
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体逻辑中的操作伪代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    //按钮事件
    void on_click()
    {
        //请求玩家数据
        request_roleinfo( call_back_function1 );

        //请求军团数据
        request_groupinfo( call_back_function2 );

        //请求任务数据
        request_taskinfo( call_back_function3 );
    }

    //先回调的是这个句柄
    void call_back_function1( data )
    {
        //保存玩家数据
        save_roleinfo(data);
    }

    //再回调的是这个句柄
    void call_back_function2( data )
    {
        //保存军团数据
        save_groupinfo(data);
    }

    //最后收到任务数据时，表明前面的数据都已经收到了，就可以做一些逻辑处理
    void call_back_function3( data )
    {
        //保存任务数据
        save_taskinfo(data);

        do_something();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述伪代码中表现了，客户端可以随意的发送请求而不需要去关心顺序的问题，大大提高了程序员的网络逻辑编程效率。&lt;/p&gt;

&lt;p&gt;对多个请求进行合并后减少HTTP请求的次数，对速度的提升很有效果，但这里还有一些细节问题，比如多少个开始进行合并，或者多少时间内合并一次。&lt;/p&gt;

&lt;p&gt;为了让HTTP最大效率的得到提升，必须每次请求得到响应后就应该立即进行下一次HTTP请求，如果有等待合并间隔，反而减低了网络效率。不过每次合并数量可以做一些限制，比如有1000个请求，我们不能统统合并了，为了保证发送数据大小和回调数据大小合适，也保证服务器不会为了一下子需要处理1000个数据请求而当机，我们必须限制一次性合并的个数，比如每次最多合并10个请求数据包，来保证减少连接次数减少的情况下，服务器不会在瞬间压力过大。&lt;/p&gt;
</description>
               <pubDate>Sun, 02 Jun 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/06/02/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%824.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/06/02/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%824.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第五章，3D模型与动画(四) - 3D模型的变与换4</title>
               <description>&lt;p&gt;前面讲解了些骨骼动画的基础知识，我们在基础知识上可以理解骨骼动画的原理。在骨骼原理之后，我们又对人物模型动画的换皮换装的原理了剖析一下，因为有了骨骼动画的基础知识支撑，我们在对换装换皮的方法和技巧上理解起来就更加的清晰了。&lt;/p&gt;

&lt;p&gt;其实看一遍是不够的，要看很多遍，而且要边想边看边实践，这样才有效果。要不怎么说理论这东西用处不够大呢，如果只有理论，那么这就是纸上谈兵，解决不了实际问题，反过来也是一样，只有实践则无法彻底了解原理和机制，我们就无法精进，总是觉得有什么东西被蒙在鼓里，运用起来不能得心应手。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h6&gt;有原理和又有实践，其实依然不行，还需要多思考多举一反三。要彻底理解一个知识点，真的难。在这条学习的道路上我们不能放弃，即使放弃了，也要想着什么时候能重新捡回来。人无完人，大家都一样，所有人都要经历失败，放弃，再重新捡起来，再失败，再放弃，再重新捡起来的过程，谁能更快的重新捡起来，就成了取胜的关键了，失败是必然的，就看谁能先重新站起来，再失败也是必然的，就看谁能一次次失败后还能站得住。&lt;/h6&gt;

&lt;p&gt;本篇我们要讲在骨骼动画原理之上，做些更高级的技巧，这些技巧都是基于上篇和上上篇的基础知识之上的。&lt;/p&gt;

&lt;p&gt;网格主要由顶点，三角形索引数组，uv这三个基础数据组成，也可以有顶点的法线和颜色数据。其中uv用于贴图，法线用于展示凹凸效果，顶点颜色则有其他多种用途。&lt;/p&gt;

&lt;p&gt;蒙皮骨骼动画，也就是SkinnedMeshRenderer，除了有这些网格数据外，又多了骨骼点和骨骼权重数据。骨骼点，是以父子或兄弟的关系相连的节点，它在Unity3D里的表象就相当于许多GameObject相互挂载并放在根节点下，除了这些看得见的GameObject节点外，骨骼点还需要旋转矩阵bindPoses，它主要是为了当父节点旋转移位时能更快的计算得到自身位移和旋转的结果矩阵，每个矩阵都是其父节点矩阵相乘所得到的结果。最后每个顶点都有自己的顶点数据，现在在顶点数据之上又多了些数据来表达被哪些骨骼的影响权重值，这就是顶点的骨骼权重数据。&lt;/p&gt;

&lt;p&gt;用最简洁的语言回顾了一下基础的知识。&lt;/p&gt;

&lt;h3&gt;6.捏脸&lt;/h3&gt;

&lt;p&gt;捏脸是一种行为方式，用以表达对对方的喜爱之情或对其某行为作出惩罚。网络游戏中泛指对虚拟角色样貌进行DIY的数据操作。&lt;/p&gt;

&lt;p&gt;捏脸看起来像是很复杂的技巧，在我们剖析一下后就会觉得也没有想象中的困难。&lt;/p&gt;

&lt;h6&gt;首先，捏脸最重要的部分就是换部位。&lt;/h6&gt;

&lt;p&gt;角色身上可以替换的部位有，不同形状的头，不同形状的上身，不同形状的腿，不同形状的脚，不同形状的手，其实还可以细分到更多，比如嘴，耳朵，胸，头发等，这些部件都可以从整体模型中拆分出来，单独成立一个模型，然后再选出来后拼装到整体模型上去。&lt;/p&gt;

&lt;p&gt;拆分出不同部位的模型，有了多个相同部位不同形状的模型后，我们就有了很多个模型部件可以替换，在捏脸时就可以选择不同的形状的部件。&lt;/p&gt;

&lt;p&gt;替换的过程其实就是上篇我们讲到的换装的过程，我们再来简单回顾下。&lt;/p&gt;

&lt;p&gt;我们必须所有模型都使用同一套骨骼，把骨骼以SkinnedMeshRenderer组件的方式实例化出来，我们暂时称它为‘根节点’，并挂上动画组件和动画文件，当播放动画时就可以看到骨骼会跟随每帧动画数据而变动。&lt;/p&gt;

&lt;p&gt;但此时还没有任何模型展示，我们把选中的部件模型也以SkinnedMeshRenderer组件的形式实例化出来，并挂载在‘根节点’下。&lt;/p&gt;

&lt;p&gt;现在挂载在‘根节点’下的部件模型只是静止的不会动的模型，虽然其自身有顶点的骨骼权重数据，但没有骨骼点的数据是无法计算出骨骼变化后的模型变化的。&lt;/p&gt;

&lt;p&gt;因此我们再把‘根节点’里的骨骼点数据赋值给这些模型部件，让他们能在每帧渲染前根据骨骼点的变化结合自身的骨骼权重数据计算出自身的网格变化情况。&lt;/p&gt;

&lt;p&gt;做完这些操作后，我们就算成功合成了一个由自己选择的人体部件并带骨骼动画的角色模型实例。&lt;/p&gt;

&lt;p&gt;当需要更换人体部件时，所需要的操作与合成一个角色模型的步骤一样，只是在这之上有了些小的变化，因为只替换某个部件，所以‘根节点’与其他没有更换的部件不需要被销毁，是可以重复利用的，只需要删除替换的部件实例。&lt;/p&gt;

&lt;p&gt;合成完模型看看这个角色，这么多部件都使用了SkinnedMeshRenderer，每个SkinnedMeshRenderer都有一定计算和drawcall的消耗，怎么办？合并。&lt;/p&gt;

&lt;p&gt;一种简单的办法就是仍然使用多个材质球进行渲染，在合并Mesh时使用子网格(SubMesh)模式，相当于只减少了SkinnedMeshRenderer组件的数量，并没有减少其他的消耗。&lt;/p&gt;

&lt;p&gt;另一种办法稍微复杂点，不使用子网格(SubMesh)模型，而是将所有模型合并成一个Mesh网格，使用同一个材质球。不过我们还是得保证有相同Shader的材质球进行合并，不相同的Shader的材质球不合并的原则，以保证角色渲染效果不变。&lt;/p&gt;

&lt;p&gt;把这么多材质球合并成一个的困难之处在于，贴图怎么办，uv怎么办？贴图我们采用实时合并贴图的方式，为了降低Drawcall，我们的办法实质上就是内存换CPU的方式，每次合成角色、更换部件时都重新合成一遍贴图，同时把uv设置在合并贴图后的某个范围内，因为uv的相对位置是不变的，所以只要整体移动到某个范围内就可以正常显示。&lt;/p&gt;

&lt;p&gt;这样模型的更换与合并，让角色捏脸系统有了基础的功能，而材质球、贴图的合并，优化了性能效果让这个系统更加完美。&lt;/p&gt;

&lt;h6&gt;其次是更换贴图&lt;/h6&gt;

&lt;p&gt;不同颜色的头发，不同颜色的手套，不同颜色相同形状的衣服，不同贴图相同形状的眼睛等，这些可以简单的使用贴图来达到目标的动作，就直接更换材质球里的贴图就可以了，不需要太复杂的操作，如果是采用贴图合并的方式来做的合并，那么就再重新合并一次贴图，uv则不需要任何变化。&lt;/p&gt;

&lt;h6&gt;再者是骨骼移动、旋转、缩放&lt;/h6&gt;

&lt;p&gt;除了更换部件、更换颜色的操作外，捏脸还有一个重要的功能，就是用户可以自由随意的DIY去塑造模型。例如把鼻子抬高点，把嘴巴拉宽点，把腰压细一点，把腿拉长一点等。&lt;/p&gt;

&lt;p&gt;由于模型的网格(Mesh)是根据骨骼点来变化的，每个组成网格的顶点都有自己的骨骼权重数据，所以只要骨骼点移动了，它们也跟着移动，骨骼点旋转了，它们也跟着旋转，骨骼点缩放了，它们也跟着缩放。于是我们可以利用这个特性来做一些操作，来让‘捏泥人’更加容易。&lt;/p&gt;

&lt;p&gt;不过问题也来了，骨骼点是随着动画一起动的，动画数据里的关键帧决定了骨骼点的变化，我们实时改变骨骼点位置是无法达到效果的，因为动画数据会强行恢复骨骼点，致使我们的操作变得无效。&lt;/p&gt;

&lt;p&gt;我们既要整个模型网格仍然依照原来的动画数据去变动，又要用某个骨骼点去影响某些网格怎么办？&lt;/p&gt;

&lt;p&gt;额外增加一些骨骼点，这些骨骼点是专门为用户可操作服务的骨骼点，并且这些骨骼点不加入到动画数据里。&lt;/p&gt;

&lt;p&gt;也就是说动画数据不会影响到这些骨骼点，动画播放时这些骨骼点是不会动的。&lt;/p&gt;

&lt;p&gt;然后为了能让网格随着，操作这些骨骼点儿发生变化，在顶点的骨骼权重数据里给这些骨骼点一些权重，这个权重能达到玩家操作效果就可以了，其他都由动画去决定变化，SkinnedMeshRenderer会在每帧根据骨骼点的变化计算出所有顶点的位置，也就是网格的变化形状。&lt;/p&gt;

&lt;p&gt;这样操作下来，我们就达到了先前说的，既要整个模型网格仍然依照原来的动画数据去变动，又可以让用户自定义操作骨骼点去影响网格变化。&lt;/p&gt;

&lt;h6&gt;最后是改变原始Mesh凹凸形状&lt;/h6&gt;

&lt;p&gt;只操作骨骼点来改变模型的捏脸效果还是不够的，因为毕竟骨骼点数量不能太多，顶点的骨骼权重数据也是有限的，无法通过增加大量的骨骼点来达到模型复杂变化的效果。&lt;/p&gt;

&lt;p&gt;于是，只能再另寻它方，这次我们回到了最基础的网格变化，由于蒙皮网格在每帧都从原始的网格加上骨骼点的变化数据来计算现在网格的形状的，那么改变原始网格的顶点数据，也同样可以改变网格在动画时的模型变化。&lt;/p&gt;

&lt;p&gt;对原始网格数据里的顶点进行变化，例如凹陷，拉伸，偏移等都可以影响整个模型在动画时的变化，因为蒙皮网格每帧的变化是根据原始网格而来的。&lt;/p&gt;

&lt;h6&gt;其实我们一直在围绕着基础知识做技术研究，基础知识和原理是核心，当我们实践时巩固了对基础知识和原理的理解，理论与实践相结合，并且不停地交替学习，逐渐得我们就能得心应手，运用自如，甚至还能厉害到无剑胜有剑的境界。&lt;/h6&gt;

&lt;h3&gt;7.动画优化&lt;/h3&gt;

&lt;p&gt;蒙皮动画太消耗CPU，为什么？&lt;/p&gt;

&lt;p&gt;因为所有蒙皮网格的变化都是由CPU计算得到的，并且无法利用多线程，也无法交给GPU去做，也就是没有谁能分担这项任务。&lt;/p&gt;

&lt;p&gt;更糟糕的是，游戏需要大量的蒙皮动画来达到丰富效果的目的。基本上所有项目都会极致得用尽动画功能，让游戏看起来很生动，很动感，很丰富，很饱满，很火热。&lt;/p&gt;

&lt;p&gt;效果再好，性能不行，只有高端机才能承受渲染压力的游戏，就无法对普罗大众产生吸引力，也就无法开启吸引力效应。所以对每个项目来说，对动画的优化也是迫在眉睫。&lt;/p&gt;

&lt;p&gt;本节就来说说3D模型动画的优化技巧。&lt;/p&gt;

&lt;h6&gt;用着色器代替动画&lt;/h6&gt;

&lt;p&gt;蒙皮动画说到实质处，就是网格顶点的变化，根据骨骼点与权重数据计算网格变化，它只是人们发明的一种每帧改变网格的方法而已，最终的目标都是，怎么让网格每帧发生变化，并且这种变化的形状是我们所期望的。&lt;/p&gt;

&lt;p&gt;只要达到这个目标，无论什么方法都是可行的。&lt;/p&gt;

&lt;p&gt;只要能想到这步，那么我们就有了另一种途径，即着色器(Shader)中的顶点着色器也可以改变网格顶点的位置。&lt;/p&gt;

&lt;p&gt;于是利用顶点着色器，与相应的算法就等得到一个随着时间变化的模型动画。&lt;/p&gt;

&lt;p&gt;利用着色器制造的动画，这种方式已经在许多项目中得到了利用，最常见就是随风摆动的草，会飘动的旗子，飘动的头发，左右摇摆的树，河流的波浪等。&lt;/p&gt;

&lt;p&gt;这些算法不在这里一一讲解了，全部搬到Shader着色器章节中去深入剖析，但大部分这些算法都利用了，游戏时间，噪声算法(noise)，数学公式(sin、cos等)来表达顶点的偏移量。&lt;/p&gt;

&lt;p&gt;除了顶点动画，还可以利用uv来做动画，比如不断流淌的水流就属于uv位移动画，又比如火焰效果中不断更换uv范围达到序列帧动画效果的uv序列帧动画，再比如不停旋转的面片动画，就可以用uv旋转来代替面片旋转，把CPU的消耗转入到GPU去消耗。&lt;/p&gt;

&lt;p&gt;uv动画的具体算法也不再这里一一讲解，都统一挪到Shader着色器章节中去了。&lt;/p&gt;

&lt;p&gt;用着色器代替动画实质上，就是用GPU消耗来分担CPU的效果，让两个芯片能更好的发挥其作用，而不是让某一个闲着没事干(大部分时候都是GPU很空)，另一个则忙的要死(大部分时候都是CPU很忙)。&lt;/p&gt;

&lt;p&gt;但用顶点动画，uv动画的算法来代替动画方式毕竟是有限的复杂度，当需要代替的动画复杂到没有固定算法规律可寻时，则需要寻求其他途径。&lt;/p&gt;

&lt;h6&gt;离线Bake每帧的模型网格，然后用更换网格的方式绘制每一帧，用内存换CPU&lt;/h6&gt;

&lt;p&gt;上面介绍了用着色器算法来动画，从而将CPU的消耗转移到了GPU消耗使得动画性能得以优化，但这样做的动画的复杂度是有限的，因为很多复杂的动画无法用算法来表达。&lt;/p&gt;

&lt;p&gt;这次我们不打算用算法了，即抛弃算法。我们来场无剑胜有剑的战斗，‘没有算法就是最大的算法’。&lt;/p&gt;

&lt;p&gt;我们想，动画的实质是，每帧显示的内容不一样，而每帧显示的内容不一样，就需要每帧都计算出一个不一样的形状。&lt;/p&gt;

&lt;p&gt;那么能不能，不计算？能。&lt;/p&gt;

&lt;p&gt;我们可以每帧都准备一个模型，每帧都展示一个已经准备好的不一样的模型，于是就有了每帧都有不同形状的模型需要展示，这不就是动画么。&lt;/p&gt;

&lt;p&gt;比如这是个5秒的蒙皮动画，每秒30帧，总共需要150个画面，我们需要准备150个模型来依次在每帧中播放。&lt;/p&gt;

&lt;p&gt;是不是代价很大，本来一个模型只要一个网格就够了，现在要准备150个网格，这就是内存换CPU的想法，到底值不值得这么做呢？&lt;/p&gt;

&lt;p&gt;假设这个场景只有2-3个模型在播放这个动画，那么为了这2-3个模型动画，我们就需要额外准备150个模型来播放动画，本来只要一个模型+骨骼就可以办到的事情，我们却要用150个模型来代替，加载这150个模型也是需要时间的，更何况内存额外加大了150倍。确实不值得。&lt;/p&gt;

&lt;p&gt;我们又假设，这个模型同时播放的这个动画的数量很多，比如100个以上，计算机每帧都需要通过模型+骨骼的方式计算出一个模型的变化，而且要重复计算100次，这时我们再用150个模型来代替这每帧持续的CPU消耗，就非常值得了。&lt;/p&gt;

&lt;h6&gt;计算机不再需要大量计算相同模型网格的变化，而只是在读取这150个模型时内存消耗以及加载的消耗，换来的是持续的高效的动画效果，这就是值得的。&lt;/h6&gt;

&lt;h6&gt;将每帧的网格偏移数据导出到图片，在Shader中让GPU通过图片里的数据来偏移顶点。&lt;/h6&gt;

&lt;p&gt;离线Bake每帧的模型网格，再通过直接改变网格数据来实时渲染动画，确实在大量渲染相同动画时起到了非常大的优化作用。&lt;/p&gt;

&lt;p&gt;但毕竟是还是会有大量的Drawcall的，每个模型一个Drawcall，100个模型100个Drawcall，GPU的压力很大。&lt;/p&gt;

&lt;p&gt;那么有没种方法合并这些drawcall？利用GPU Instancing。&lt;/p&gt;

&lt;p&gt;什么是GPU Instancing？这是GPU渲染API提供的一种技术，如果绘制1000个物体，它将一个模型的vbo提交给一次给显卡，至于1000个物体不同的位置，状态，颜色等等将他们整合成一个per instance attribute的Buffer给GPU，在显卡上区别绘制，它大大减少提交次数，这种技术对于绘制大量的相同模型的物体由于有硬件实现，所以效率高，更灵活，也避免了合批而造成内存浪费，并且原则上可以做GPU Skinning来实现骨骼动画的instancing。&lt;/p&gt;

&lt;p&gt;GPU Instancing最重要的一个特点是只要提交一次，就可以绘制1000个物体，把原本要提交1000次的流程，简化成了只需要提交1次，1000个Drawcall瞬间降为了1次。&lt;/p&gt;

&lt;p&gt;当然没那么简单，它是有条件的，首先条件是模型的着色器(Shader)要支持GPU Instancing，其次是这1000个模型他们位置、角度可以不一样，但都使用同一个模型数据，最后他们每帧都使用的是同样的模型数据，这样才能提交一次渲染全部。&lt;/p&gt;

&lt;p&gt;GPU Instancing 的条件有点苛刻，Shader要相同，材质球要相同，模型要相同，还不能有变形(就是不能有动画)。&lt;/p&gt;

&lt;p&gt;对于我们来说，要用GPU Instancing，就不能变模型了，怎么办？&lt;/p&gt;

&lt;p&gt;我们原来的方法是准备150个模型，每帧都渲染一个，现在换成，把这150个模型的顶点数据放入一张贴图里去，这张图总共有150行，每行都写入了所有顶点的坐标，每个像素数据 RGB 都分别代表 xyz 的顶点坐标，比如总共有3000个顶点，那么每行就有3000个像素，总共150行，这张图总共有 3000 * 150 个像素。&lt;/p&gt;

&lt;p&gt;然后把这张图，也相当于是网格的顶点数据传入着色器(Shader)，着色器根据传入的图中的每个像素去设置顶点，让GPU去改变网格而不是CPU，这样每次渲染前，所有模型都使用的是同一个模型，同一个材质球，同一个Shader着色器，符合了开启GPU Instancing的条件，只要提交一次模型数据，就能渲染1000个模型并且有动画，瞬间降低1000个Drawcall到个位数字。&lt;/p&gt;

&lt;p&gt;此时，我们不再需要骨骼了，也不需要SkinnedMeshRenderer了，只需要MeshRenderer来渲染模型就可以了，动画里的顶点变化交给了着色器去做，也可以认为是变相的顶点动画。&lt;/p&gt;

&lt;p&gt;这个着色器并不复杂，只是比普通的顶点着色器在传入参数时，多了个变量‘顶点索引’，根据这个顶点索引，来计算得到传入的贴图中的顶点坐标。&lt;/p&gt;

&lt;p&gt;伪代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    v2f vert(appdata v, uint v_index : SV_VertexID)
    {
            UNITY_SETUP_INSTANCE_ID(v); // gpu instance

            float f = _Time.y / _AnimLength;
            fmod(f, 1.0);

            float animMap_x = (v_index + 0.5) * _AnimWidth;
            float animMap_y = f;

            float4 pos = tex2Dlod(_AnimTexture, float4(animMap_x, animMap_y, 0, 0));

            v2f o;
            o.uv = TRANSFORM_TEX(v.uv, _MainTex);
            o.vertex = UnityObjectToClipPos(pos);
            return o;
    }

    fixed4 frag (v2f i) : SV_Target
    {
            fixed4 col = tex2D(_MainTex, i.uv);
            return col;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;顶点着色器中，用时间和动画长度计算出y的位置，也就是行数，再用顶点索引计算出列数，从而得到动画数据贴图中属于自己位置的像素，也就是顶点的坐标信息。&lt;/p&gt;

&lt;p&gt;取出这个像素后，就是这个顶点的坐标了，与世界坐标轴转换后即可使用。Shader中没有复杂的公式和原理，就是从图片中取出值来作为坐标去传递。&lt;/p&gt;

&lt;h6&gt;我们用这种操作方式，利用GPU Instancing 的功能，达到了合并Drawcall的目的，但同样也有很多缺陷，比如最重大的缺陷是，每个人物的动画都是一样的，不会错开来，也就是同一时间，很多模型，做相同的动作。&lt;/h6&gt;

&lt;h6&gt;又比如精度问题，如果要求模型动画有好的表现，就必须提高图片的精度，因为每个像素RGB的颜色就代表了顶点坐标信息，如果要求GPU支持float类型的贴图，一般需要gles3.0以上级别的机器，虽然现在也已经算比较普遍，但毕竟也有部分底端机器无法实现，是否降低动画精度，或者放弃些低端机也需要根据项目不同而深思熟虑下。&lt;/h6&gt;

&lt;h6&gt;LOD，动画LOD，网格LOD&lt;/h6&gt;

&lt;p&gt;借用GPU Instancing 的优势来合并Drawcall有好有坏，最大的坏处就是单个模型无法播放属于自己专有的动画而与其他相同的模型错开来。&lt;/p&gt;

&lt;p&gt;无法错开来播放动画，这个是最糟糕的。想要错开来播放属于自己的动画，那么事情又回来了我们最初的原点，骨骼蒙皮动画。&lt;/p&gt;

&lt;p&gt;对于1000个骨骼动画，并且每个人都必须有属于自己的动画序列，不能合并模型，不能合并材质球，只能用1000个Drawcall来支撑这巨大的消耗。&lt;/p&gt;

&lt;p&gt;也不是没有办法，不过首先我们要‘认命’，这1000个Drawcall是躲不过了，但可以退而求其次，用方法去降低消耗。&lt;/p&gt;

&lt;p&gt;骨骼蒙皮动画的最大消耗是，计算网格变化。那么这个计算网格的变化，究竟有哪些因素决定的？&lt;/p&gt;

&lt;p&gt;我们再一次回到了基础知识的原点，网格的变化是由，骨骼点与顶点的权重数据计算得到的。&lt;/p&gt;

&lt;p&gt;也就是说，有多少顶点，有多少骨骼，有多少权重数据，就有多少CPU要消耗。CPU的消耗与这三者任何一个都成正比。&lt;/p&gt;

&lt;p&gt;也就是说，顶点越少，骨骼数越少，权重数据越少，CPU的消耗就越少。&lt;/p&gt;

&lt;p&gt;但是顶点数少了，模型就不那么精细了，而骨骼数少了，动画就补那么精细了，而权重数据少了，网格变化就不那么精细了。&lt;/p&gt;

&lt;h6&gt;这是要用画面的质量来换取性能啊，伤筋动骨的事情还是少干干，毕竟游戏最重要画面质量不可动摇，这就相当于拿生命换钱一样，不可为。&lt;/h6&gt;

&lt;p&gt;我们还有LOD(Level of Detail)可以用，用远近的视觉差来优化性能开销，用内存来换取CPU。&lt;/p&gt;

&lt;p&gt;LOD的视觉差是利用，离摄像机太远的东西精细不精细无法分辨，精细和粗糙，在距离远的情况下效果是同样的。&lt;/p&gt;

&lt;p&gt;就这个视觉差效果，我们可以这么做LOD：&lt;/p&gt;

&lt;h6&gt;第一，为每个模型准备3-5套简化的模型，这些模型都一定以及肯定要带有骨骼权重数据，否则无法与骨骼关联播放动画，当摄像机与模型的距离拉远时启用较简单的网格，减少顶点数量。当摄像机拉近时则再次启用复杂的网格，加强表现。&lt;/h6&gt;

&lt;h6&gt;第二，同样的手法，准备多套骨骼，当摄像机拉远时启用较为简单的骨骼，减少骨骼数量。当摄像机拉近时则再次启用复杂的骨骼，加强表现。&lt;/h6&gt;

&lt;h6&gt;第三，SkinnedMeshRenderer的 SkinQuality 是决定顶点受多少根骨骼(最多4根)影响的变量，当摄像机拉远时设置为2根或者1根，当摄像机拉近时再恢复过来。&lt;/h6&gt;

&lt;p&gt;LOD也可以用到极致，LOD不只为了静态模型服务的，也同样可以为动画模型服务，虽然我们并没有用LOD降低任何Drawcall，但我们还是同样降低了很大的CPU开销，和降低Drawcall相比也有着异曲同工之妙。&lt;/p&gt;
</description>
               <pubDate>Sat, 18 May 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/05/18/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB7.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/05/18/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB7.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第五章，3D模型与动画(四) - 3D模型的变与换3</title>
               <description>&lt;p&gt;简单叙述下上篇的内容。&lt;/p&gt;

&lt;p&gt;上篇我们了解到，一个简化模型的算法，以及普通网格和蒙皮网格的区别。其中蒙皮网格是专门用来制作动画的，它除了普通网格所需要的顶点，三角形，uv数据外，还需要骨骼数据，和每个顶点的骨骼权重数据。&lt;/p&gt;

&lt;p&gt;其中骨骼动画是由骨骼点组成的，每个骨骼点之间的关系，要么是父子关系，要么就是平行的兄弟关系，要么就是没有关系，这些骨骼点在Unity3D中对应到模型上的GameObject点。在这种骨骼结构下，当父节的骨骼点位移，旋转时，子节点的骨骼也同时相对于父节点位移和旋转。所以骨骼点之间的结构就是父子关系或平行结构关系。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;那么骨骼点是怎么影响到顶点的呢，又是如何判断影响哪些顶点的呢？&lt;/p&gt;

&lt;p&gt;骨骼动画中，需要顶点的骨骼权重数据，每个顶点都受到骨骼的影响，一个顶点最多被4个骨骼影响，所以在Unity3D中每个顶点都有一个BoneWeight实例，实例中描述了当前这个顶点对分别4个骨骼有多少权重，因为最多4个，每个顶点一个，所以顶点数组有多长，BoneWeight数组就有多长，当骨骼点移动时，将使用这些顶点权重值来计算顶点的旋转和偏移量。&lt;/p&gt;

&lt;p&gt;简单来说就是，用顶点上的骨骼权重数据，来确定该点会被哪些骨骼点所影响。&lt;/p&gt;

&lt;h6&gt;蒙皮动画分两步：第一步是用3DMax，Maya等3D模型软件在几何模型上建立一系列的骨骼点(bones)，并计算好几何模型的每个顶点受这些骨骼点的影响权重(BoneWeight)；&lt;/h6&gt;

&lt;h6&gt;第二步则是在Unity3D中用户或关键帧动画持续改变一系列骨骼点位置，几何模型随着骨骼点发生相应变形。&lt;/h6&gt;

&lt;p&gt;通常我们使用的都是关键帧动画，就是Unity3D里的Animation动画文件，在某个时间点上对需要改变的骨骼做一个关键帧，而并不是在每帧上都做关键帧的操作。&lt;/p&gt;

&lt;p&gt;使用关键帧作为骨骼的旋转位移点的好处是不需要每帧去设置骨骼点的位置变化，在关键帧与关键帧之间的骨骼位置，是由Animation动画组件做了平滑的插值计算得到，这样可以减少大量的人力劳动，相当于关键帧之间做了‘补间动画’，这些‘补间动画’的目的就是对需要改变的骨骼做平滑的位移或者旋转插值计算，得到相应的位置和旋转角度。&lt;/p&gt;

&lt;h6&gt;’补间动画‘在每帧都只对骨骼动画做了位置和旋转的改变，然后蒙皮网格组件(SkinnedMeshRender)在每帧必须重新计算骨骼与网格的关系，所以最终就有了‘补间动画’每帧改变一些列骨骼点，骨骼点被(SkinnedMeshRender)重新计算得到模型网格变化，于是每帧就呈现出不同的网格变化，于是就有了3D模型网格动画。&lt;/h6&gt;

&lt;p&gt;整个骨骼动画的呈现流程清晰了，我们来用Unity3D的API来整理下，让我们理解的更加透彻。&lt;/p&gt;

&lt;p&gt;举例代码和解释如下，重点在注释的解释：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    //新建个动画组件和蒙皮组件
    gameObject.AddComponent&amp;lt;Animation&amp;gt;();
    gameObject.AddComponent&amp;lt;SkinnedMeshRenderer&amp;gt;();
    SkinnedMeshRenderer rend = GetComponent&amp;lt;SkinnedMeshRenderer&amp;gt;();
    Animation anim = GetComponent&amp;lt;Animation&amp;gt;();

    //新建个网格组件，并编入4个顶点形成一个矩形形状的网格
    Mesh mesh = new Mesh();
    mesh.vertices = new Vector3[] {new Vector3(-1, 0, 0), new Vector3(1, 0, 0), new Vector3(-1, 5, 0), new Vector3(1, 5, 0)};
    mesh.uv = new Vector2[] {new Vector2(0, 0), new Vector2(1, 0), new Vector2(0, 1), new Vector2(1, 1)};
    mesh.triangles = new int[] {0, 1, 2, 1, 3, 2};
    mesh.RecalculateNormals();

    //新建个漫反射的材质球
    rend.material = new Material(Shader.Find(&amp;quot;Diffuse&amp;quot;));

    //为每个顶点定制相应的骨骼权重
    BoneWeight[] weights = new BoneWeight[4];
    weights[0].boneIndex0 = 0;
    weights[0].weight0 = 1;
    weights[1].boneIndex0 = 0;
    weights[1].weight0 = 1;
    weights[2].boneIndex0 = 1;
    weights[2].weight0 = 1;
    weights[3].boneIndex0 = 1;
    weights[3].weight0 = 1;

    //把骨骼权重赋值给网格组件
    mesh.boneWeights = weights;

    //创建新的骨骼点，设置骨骼点的位置，父节点，和位移旋转矩阵
    Transform[] bones = new Transform[2];
    Matrix4x4[] bindPoses = new Matrix4x4[2];

    bones[0] = new GameObject(&amp;quot;Lower&amp;quot;).transform;
    bones[0].parent = transform;
    bones[0].localRotation = Quaternion.identity;
    bones[0].localPosition = Vector3.zero;
    bindPoses[0] = bones[0].worldToLocalMatrix * transform.localToWorldMatrix;

    bones[1] = new GameObject(&amp;quot;Upper&amp;quot;).transform;
    bones[1].parent = transform;
    bones[1].localRotation = Quaternion.identity;
    bones[1].localPosition = new Vector3(0, 5, 0);
    bindPoses[1] = bones[1].worldToLocalMatrix * transform.localToWorldMatrix;

    mesh.bindposes = bindPoses;

    //把骨骼点和网格赋值给蒙皮组件
    rend.bones = bones;
    rend.sharedMesh = mesh;

    //定制几个关键帧
    AnimationCurve curve = new AnimationCurve();
    curve.keys = new Keyframe[] {new Keyframe(0, 0, 0, 0), new Keyframe(1, 3, 0, 0), new Keyframe(2, 0.0F, 0, 0)};

    //创建帧动画
    AnimationClip clip = new AnimationClip();
    clip.SetCurve(&amp;quot;Lower&amp;quot;, typeof(Transform), &amp;quot;m_LocalPosition.z&amp;quot;, curve);

    //把帧动画赋值给动画组件，并播放动画
    anim.AddClip(clip, &amp;quot;test&amp;quot;);
    anim.Play(&amp;quot;test&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上的Unity3D代码就呈现了，几何模型数据，蒙皮动画数据，从无到有的过程。&lt;/p&gt;

&lt;p&gt;我们再返回去看在蒙皮动画第一步中权重的计算决定了蒙皮算法的效果，如果想要几何模型发生自然、高质量的形变，必须得有一种高效准确的权重计算方法。&lt;/p&gt;

&lt;p&gt;这里简单讲一下蒙皮的计算方式，以了解下计算原理。&lt;/p&gt;

&lt;p&gt;线性混合蒙皮（Linear Blending Skinning，LBS)是最最常用的蒙皮计算方式，由于它的计算速度优势使得其成为商业应用中最主要的方法之一。&lt;/p&gt;

&lt;p&gt;什么是线性混合蒙皮计算方式呢？简单说就是，当前顶点位置变化 = 初始位置 + 骨骼点变化1 * 骨骼权重1 + 骨骼点变化2 * 骨骼权重2 ....&lt;/p&gt;

&lt;p&gt;那么直接使用这种线性混合计算蒙皮的方式效果有点粗糙，为了更好的效果。[Jacobson et al. 2011]提出了一种有界双调和权重（Bounded Biharmonic Weights，BBW）的计算方法，该权重能使得几何模型发生平滑变形，这个算法后来就成为了我们现在最常使用的骨骼蒙皮动画的计算方式。&lt;/p&gt;

&lt;p&gt;他大概的意思就是说，既然网格数据的变化计算量大，线性混合计算的速度又是最快的，我们可以在线性计算的基础上加以改进。在线性蒙皮混合计算公式中，初始位位置无法改变，骨骼点的变化也无法改变，所以权重计算骨骼点的变化的量决定了最终效果是否好的关键。&lt;/p&gt;

&lt;p&gt;于是他就提出了，有界双调和权重的计算方法，其数学表达式如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/book/5/bone-bbw.jpg&quot; alt=&quot;有界双调和权重的计算方法&quot;&gt;&lt;/p&gt;

&lt;h6&gt;由于蒙皮动画是每帧都通过骨骼点来计算网格的变化的，如果骨骼点很多，网格很复杂(顶点或者面数很多)那么消耗的CPU就很多，因为网格里的顶点都需要通过蒙皮算法来算出顶点的变化，这些都是靠CPU来计算的。因此在制作模型动画的时候，特别要注意，同屏里有多少蒙皮动画在播放，以及每个蒙皮动画中，骨骼的数量有多少，网格的面数有多复杂，如果太多太复杂就会巨量的消耗CPU。&lt;/h6&gt;

&lt;h3&gt;5.人物3D模型动画换皮换装&lt;/h3&gt;

&lt;p&gt;有了上面的这些3D模型和骨骼动画的知识，我们在3D模型动画换装这种常见的游戏功能的编码设计上，就显得简单的多了。&lt;/p&gt;

&lt;h6&gt;首先，为了达到模型动画的动态拼接，我们必须一个人物只使用一套骨骼。&lt;/h6&gt;

&lt;h6&gt;其次，把骨骼和模型部件拆分开来，骨骼文件只有骨骼数据，每个部件的模型文件只包含了它自己的模型数据，同时它也必须包含了顶点上的骨骼权重数据。&lt;/h6&gt;

&lt;p&gt;用Unity3D的术语来说就是，把一个人物模型拆分成有很多个Fbx，其中一个Fbx只有骨骼数据，其他Fbx是每个部件的模型数据，它们都带有已经计算好的骨骼权重数据。&lt;/p&gt;

&lt;h6&gt;然后，把骨骼数据和模型动画都动态拼接起来。&lt;/h6&gt;

&lt;p&gt;具体步骤是，用骨骼Fbx模型数据实例化成一个SkinnedMeshRenderer，这样基础的骨骼数据就包含在这个实例里了。再把需要显示的各个部件Fbx模型数据实例化出来，拥有自己的SkinnedMeshRenderer，然后把骨骼信息从前面骨骼SkinnedMeshRenderer里取出来赋值给自己。&lt;/p&gt;

&lt;p&gt;这样每个部件都进行了SkinnedMeshRenderer实例化，SkinnedMeshRenderer可以渲染出自己的模型效果，并且自己的SkinnedMeshRenderer有了自己的骨骼数据，每个部件模型上也都有骨骼的权重数据，使每个模型部件针对骨骼动画是有效的。&lt;/p&gt;

&lt;h6&gt;再然后，在骨骼的SkinnedMeshRenderer上挂上Animator来播放动画文件，动画改变的是骨骼点，当动画播放时骨骼点会针对动画关键帧进行位移和渲染，由于部件模型的骨骼数据都是从骨骼的SkinnedMeshRenderer上映射过来的，所以当骨骼点动起来时就能带动众多的模型部件一起动起来。&lt;/h6&gt;

&lt;p&gt;当骨骼动画的SkinnedMeshRenderer上的动画文件开始播放时，每个部件也会随着骨骼点的变动而不断的计算出网格模型的变动情况，进而在渲染上体现出部件模型的动画效果。&lt;/p&gt;

&lt;h6&gt;最后，当我们需要更换人物上的某个部件模型时，只需要把原有的部件模型实例删除，再实例化出那个我们需要的部件模型，并把骨骼数据赋值给它就完成了操作，更换的操作看上去很简单，在表现上就是更换了人物的某个部件，脸，或腿，或手，或腰，或脚。&lt;/h6&gt;

&lt;p&gt;这种方式虽然是最简单的，但并不是最好的方式，比如人物拆分成了5个部件，头，手，身体，腿，脚，就需要6个SkinnedMeshRenderer来支撑，其中1个为骨骼动画的SkinnedMeshRenderer，其他5个为部件模型的SkinnedMeshRenderer，看上去很不友好，也就是说一个人物要至少5个Drawcall来支撑。&lt;/p&gt;

&lt;p&gt;骨骼动画已经很消耗性能了，还需要5个材质球去消耗5个drawcall，加重了性能消耗的力度。&lt;/p&gt;

&lt;p&gt;我们有更好的办法，我们希望一个人物动画只使用一个drawcall，那么我们就需要把这5个部件合并成一个模型，他们都使用同一个材质球，模型合并好办，使用Unity3D的Mesh.CombineMeshes就可以实现。&lt;/p&gt;

&lt;p&gt;那么贴图怎么办？也同样合并。在每次初始化拼接一个人物模型时，或者更换人物的部件模型时，将5张贴图动态的合并成一张，并在合并贴图的同时需要改变每个模型部件的uv，将他们的uv偏移到这张合并整图的某个范围内。&lt;/p&gt;

&lt;p&gt;这样一来，每个人物模型只需要消耗1个drawcall，减轻了gpu的负担。从CPU消耗来看，拼接的操作只存在于人物初始化，和更换部件模型时才会有消耗，所以合并贴图和模型的消耗并不频繁。&lt;/p&gt;

&lt;p&gt;伪代码为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    function change_role_part( list of part_fbx )
    {
        root = new SkinnedMesh(&amp;#39;role_bone.fbx&amp;#39;);

        combine_mesh = new Mesh();
        combine_tex = new Texture();

        for( item in part_fbx )
        {
            item.mesh.uv = item.uv + offset;

            combine_mesh.combine(item.mesh);

            combine_tex.combine(item.texture);
        }

        root.mesh = combine_mesh;
        root.texture = combine_tex;

        return root;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
               <pubDate>Sun, 12 May 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/05/12/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB6.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/05/12/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB6.html</guid>
            </item>
        
            <item>
               <title>思路探讨(二十四) 要勇敢的相信自己</title>
               <description>&lt;p&gt;你是很厉害的人物，就像是无所不能的一样，但凡你接触到的都能成功搞定。&lt;/p&gt;

&lt;p&gt;我很确信的知道所有看我文章的读者都是很聪明的人，我认为你们就应该这么认为自己。&lt;/p&gt;

&lt;p&gt;我为什么要这么认为？&lt;/p&gt;

&lt;p&gt;因为我知道人与人之间的区别就是思想上的区别。你在想什么，怎么想的，决定了你的现在和你的未来。&lt;/p&gt;

&lt;p&gt;就比如现在我就是这么认为，你们是很聪明的，很棒的，很有能力的一群人，我认为读我的文章的人，都是这个世界上很厉害的人，无论你们来自哪个地方，都那个地方的佼佼者。&lt;/p&gt;

&lt;p&gt;这也同时映射出我是很棒的，是聪明的，是厉害的人。&lt;/p&gt;

&lt;p&gt;我不是反夸自己，因为我相信自己是个厉害的人物，是个聪明的人，是个很棒的人，不论现在是不是，未来一定是。在变成未来那个很厉害的人之前，所有阻碍和困哪，都不值得去太在意。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h6&gt;我只关注那个未来画面里的我要成为的那个厉害的人，我只关注我是如何变成那个人的这个过程，只关注我要如何可以更快更好的变成未来那个人的方法，只关注我有没有按照变成未来那个人的方向去行动。&lt;/h6&gt;

&lt;h6&gt;除了上面这些，其他的一切都不值得我在意，因为我很坚信我能成为我心中的那个很棒的人。钱没了就没了，再去赚，下次小心点，贵重物丢了就丢了，再买一个，下次小心点，事情失败了就失败了，再来一次，下次小心点，事情变遭了，尽力修复，下次小心点。&lt;/h6&gt;

&lt;p&gt;你看，我并没有把注意力聚焦在那些阻碍我发展的事情上，而是把所有的注意力都集中在了我相信的那个事情上。其他所有的阻碍、困难、失败，都被我轻描淡写的掠过了，而我则在这些苦难后还在继续向前走。&lt;/p&gt;

&lt;p&gt;这就不就是，我们生活中一直幻想着的那个，聪明的，冷静的，有远见的，不斤斤计较的，充满智慧的人么。我们每天都在期盼有一个这样厉害的家伙成为自己的合作伙伴。&lt;/p&gt;

&lt;p&gt;成为这样的人其实很简单，只要你想，就能成。&lt;/p&gt;

&lt;h6&gt;是的，只要你把注意力集中在你想的那个东西上，其他事物都是次要的。如果我们把注意集中在未来的美好事物上，我们就能在当下成为一个聪明智慧的人，并且在未来成为画面里那个很棒的人。&lt;/h6&gt;

&lt;p&gt;不知道你有没有和我有同样的体会：回忆过去的时候，发现，很多很多事情都是因为我们不相信，所以才没有成，也有很多很多事情只是因为我们相信我们能成才成就的。我们能否做成一件事，全靠我们有多少的相信（即我相信的力度），我‘有点’相信，这个事情成功的概率就有是‘有点’，如果我‘非常’相信，那么这个事情的成功率就有‘非常’高。&lt;/p&gt;

&lt;p&gt;我相信我今天存进银行的钱，明天就能取出来，那么明天确实能取出来。&lt;/p&gt;

&lt;p&gt;如果我不相信我今天存进银行的钱能取出来，那么明天真的有可能取不出来。（如果有一天社会动荡到你完全不相信存进银行的钱是安全的时候，明天银行就会因挤兑而倒闭）&lt;/p&gt;

&lt;p&gt;我不是神棍，而是告诉大家，让人相信某件事是很难的，让人不相信某件事业也同样很难。就比如我如何让你不相信，存进银行的钱，明天取不出来，这件事，很难。因为现在的社会环境让你非常相信，存进银行的钱，明天就能取出来，我是很难改变你的想法的。就像我无法让你相信，你以后会竞选总理并且获胜一样，很难让你有这种相信的想法。但我能让你相信，我的想法是对，并且对你很有用，这个相对容易点，但也不是针对每个人都有效。&lt;/p&gt;

&lt;h3&gt;让一个人相信一件事，或者让一个人不相信一件事都非常难，概括可以说，要改变一个人的想法非常难。&lt;/h3&gt;

&lt;p&gt;我想了很久，关于人与人之间的区别到底在哪里的问题。&lt;/p&gt;

&lt;p&gt;是钱么？&lt;/p&gt;

&lt;p&gt;如果是钱，那么为什么有钱的人也同样迷茫，也同样冲动，也同样不知所措，同样犯与没钱的人一样的错误，也同样无知。&lt;/p&gt;

&lt;p&gt;是知识么？&lt;/p&gt;

&lt;p&gt;如果是知识，那么为什么博士以及博士后不是在掌控世界，理论上说他们的知识量是最大的，为什么依旧与普通人一样，迷茫，冲动，不知所措，也同样表现的无知。&lt;/p&gt;

&lt;p&gt;其实都不是。人与人之间的区别就是思维，和，想法。你怎么想的，决定了你怎么做，你想的是什么，决定了你最终会成为什么样人。&lt;/p&gt;

&lt;p&gt;如果你每天想着，我基因不好，我老是身体不好，我总是生病，我比较笨，我不会运动，我很穷，我被穷困所限制，老是有人和我作对，我的人生是苦难的，我有才但始终没有伯乐，我每次都被别人抛弃，我在变老，我怕我会破产，我总是迟到，我总是经不住诱惑，别人老是来占我便宜。等等等等。&lt;/p&gt;

&lt;p&gt;那么你就会成为你所想的，你的基因一定不好，你的身体肯定会坏，你肯定总是生病，你肯定比较笨，你肯定不擅长运动，你肯定富不起来，你的人生肯定是苦难的，你肯定遇不到伯乐，你肯定每次都被抛弃，你肯定老的很快，你肯定破产，你肯定迟到.....&lt;/p&gt;

&lt;p&gt;你想什么，就是你希望得到的，事情就会往这个方向发展，最终就会实现你所想。&lt;/p&gt;

&lt;p&gt;反之，如果我们的想法能更加积极点，乐观点，美好点，光明点，那么事情就会向更加积极，乐观，美好，光明的方向去走。&lt;/p&gt;

&lt;p&gt;如果我每天都认为，我的人生是完美的，我拥有很好的基因，我身体很棒，我免疫力很好，我很会运动，我总是很幸运，我总能遇到伯乐，我总是能和大家搞好关系，我永远都是那么年轻，我会越来越富有，我总是很准时的赴约，我总是很理智，别人都很喜欢跟我合作，我的知识会越来越渊博，我很智慧，我总是很受人照顾，我会很厉害。等等等等。&lt;/p&gt;

&lt;p&gt;那么事情就会真的向我想象的方向发展，我的基因很完美，我很健康，我很理智，我总是很受欢迎，我总是能遇到伯乐，我变得越来越富有，我很幸运，我看上去一直很年轻。&lt;/p&gt;

&lt;h6&gt;难道说真的有什么外在因素在决定这些事情的发生吗？并没有，原因在人的内心：我怎么想，决定了事情怎么走。&lt;/h6&gt;

&lt;h3&gt;人与人之间最大的区别就在这里，可以用很简单的一句话概括：你相信什么？信则有，不信则无。&lt;/h3&gt;

&lt;h3&gt;你所相信的，就是你能得到的。同样的，你所不相信的，就是你得不到的。&lt;/h3&gt;

&lt;h3&gt;无论你遭遇什么境况，都要勇敢的相信自己，我是健康的人，我是幸运的人，我是厉害的人，我是受欢迎的人，我是幸福的人。&lt;/h3&gt;
</description>
               <pubDate>Wed, 01 May 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/05/01/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A824.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/05/01/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A824.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第五章，3D模型与动画(四) - 3D模型的变与换2</title>
               <description>&lt;p&gt;上一篇介绍了一些3D模型的渲染基础知识，并且将这些基础知识运用在了3D模型的切割、拉伸、扭曲当中。&lt;/p&gt;

&lt;h6&gt;技术原理是最重要的核心点，人只要理解了技术原理，就能将技术表象解释清楚，在实际项目中将这种技术运用自如。&lt;/h6&gt;

&lt;h6&gt;实际中并没有这么容易，理解和运用自如之间，还是有一段很大的差距的，在实际项目过程中，理解只是理解，只是能解释这种表象是如何发生的，运用自如，则是熟知了原理的优缺点，不再对这种技术有任何的偏见，能做什么不能做什么，做什么有什么优势，有什么有什么劣势，有了更加深入的理解，当没有了这么多的偏见，运用起来自然得心应手。&lt;/h6&gt;

&lt;h6&gt;理论上说，我们每个人把所有精力先放在理解原理上，然后再去做技术实现不就轻松了吗。理论上是这样的，但人类头脑的进化毕竟还没到那么高级的程度，还不能轻松的把抽象的事物短时间内在脑中有条不紊的整理清楚，这还没把人的情绪影响算进去，人性毕竟是弱点多于优点的，虽然表面上能处理一些看上去相对复杂的事物，但从学习知识的角度看，人类的大脑还是不够高级，说实话应该说是有点低级。&lt;/h6&gt;

&lt;h6&gt;对于这么低级的大脑，我们只能通过反复的学习，然后实践，再学习，再实践，很多遍后才能对原理的理解推进那么一点点，我们也只能依靠长时间的、漫长时间的、很长很长时间的磨练，从有兴趣到放弃，再重新拿起到再放下，再拾取再举起再抛向天空，反反复复但始终不离弃，才能最终到达运用自如的境界。人之间没有聪明与不聪明之分，有的人善于思考，善于举一反三是因为前面很长一段时间他都一直在练习这种多思考和举一反三的方式，当我们看到他时他的思维方式已经成型，这些并不是先天就有，而是通过后天努力得来。天才这东西，不管它是否真的存在，我们都应该忽略它，转而更加专注于自己的努力上。&lt;/h6&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h3&gt;3.简化模型&lt;/h3&gt;

&lt;p&gt;经常在项目中看到有模型有几万个面，甚至几十万个面的情况，模型面数多的好处是能表现的更加精细，画面更细腻，但坏处却是加重了渲染压力，渲染的面数越多压力越重，帧率越低。所以一般都会对场景中的单个3D模型进行限制，或者对整体场景面数进行限制。&lt;/p&gt;

&lt;p&gt;画面质量和性能需要权衡，通常都是要求模型降低面数而画面质量不变，LOD(Level Of Detail)在这里就可以发挥巨大的作用，随着镜头的靠近逐级更换更细腻的模型很好的解决这种需求。&lt;/p&gt;

&lt;p&gt;简化模型在LOD中用到的最多，有手动用3D模型软件简化的，也有用程序工具式的简化模型，手动简化更加平滑但费时间，时间成本大，而用程序工具去简化则快速，但不平滑。我们可以根据项目的需求，规模，画质等要求来权衡是否使用程序工具去简化模型，或者更加灵活点，一部分不太需要细致的模型使用程序工具简化，而另一部分比较需要细节化的模型使用手动简化，这样即照顾到了画质，又照顾到了工期。&lt;/p&gt;

&lt;p&gt;这里我们来具体讲述下简化模型的算法。虽然市面上简化模型的插件和工具很多，但如果我们对原理有了更深入了解，在实际的项目中运用这些工具会更加自如且得心应手。&lt;/p&gt;

&lt;p&gt;3D模型是由点，线，面组成。面由点和线组成，减面相当于减点和线，单纯的减去点和线容易引起模型变化不受控制，收缩线上的两顶点成为一个顶点则更加靠谱些。[Garland et al. 1997]提出了一种基于二次项误差作为度量代价的边收缩算法，其计算速度快并且简化质量较高。&lt;/p&gt;

&lt;p&gt;该方法是去选择一条合适的边进行收缩时，定义一个边的收缩都是有代价的，每个顶点也有自己的代价，对于网格中的每个顶点v，我们预先定义一个4×4的对称误差矩阵Q，那么顶点v=[x y z 1]的代价为其二次项形式Δ(v)=vQ。&lt;/p&gt;

&lt;p&gt;同时也定义了边收缩的代价公式，假设对于一条收缩边(v1,v2)，其收缩后v1，v2顶点收缩为v3，我们定义顶点v3的误差矩阵Q3为Q3=Q1 + Q2，也就说是v1，v2的这条边的收缩为v3后代价为Δ(v3) = v3(Q1 + Q2)，以此类推每条边都有一个代价。&lt;/p&gt;

&lt;p&gt;有了上面的代价公式，下面的网格简化算法就容易理解多了：&lt;/p&gt;

&lt;p&gt;1，对所有的初始顶点都计算它们各自的Q矩阵.&lt;/p&gt;

&lt;p&gt;2，选择所有有效的边（这里取的是两点有连线的边，也可以将两点有连线且距离小于某个阈值的边归为有效边）&lt;/p&gt;

&lt;p&gt;3，对每一条有效边(v1,v2)，计算最优收缩目标v3.误差(Q1+Q2)是收缩这条边的代价（cost）&lt;/p&gt;

&lt;p&gt;4，将所有的边按照cost的权值都放在队列中从小到大进行排序。&lt;/p&gt;

&lt;p&gt;5，每次移除队列顶部的代价（cost）最小的边，也就是收缩最小代价的边，删除v1，v2，并用v3替换。&lt;/p&gt;

&lt;p&gt;6，重复1-5步骤，直到顶点数少于某个设定的值，或者所有cost代价大于某个值，则停止收缩算法。&lt;/p&gt;

&lt;p&gt;整个算法并不复杂，关键这里有两个核心问题需要解决，一个是每个顶点的初始Q矩阵如何计算，另一个是v1，v2收缩为v3时的坐标位置该怎么计算。&lt;/p&gt;

&lt;p&gt;在原始网格模型中，每个顶点可以认为是其周围三角片所在平面的交集，也就是这些平面的交点就是顶点位置，因此我们定义顶点的误差为顶点到这些平面的距离平方和。&lt;/p&gt;

&lt;p&gt;由此定义我们可以计算出每个顶点的初始误差矩阵Q：Δ(v)为顶点误差值 = vQ = 0，因为初始顶点的误差值为0，因为是它与相交平面的距离平方和为0，那么初始顶点的误差矩阵Q也可以由此计算出来。&lt;/p&gt;

&lt;p&gt;至于v1，v2收缩为v3时如何选择最优的坐标，简单的方法就是取v1，v2，和中点(v1+v2)/2的三个中收缩代价最小的一个为最优选择，另一种策略则是数值计算顶点v3位置使得Δ(v3)最小，由于Δ的表达式是一个二次项形式，因此令一阶导数为0。&lt;/p&gt;

&lt;p&gt;按照这个算法步骤，不停的收缩最小代价的边，直到顶点数量小于某个值时停止，最终将得到一个简化的模型。&lt;/p&gt;

&lt;h3&gt;4.蒙皮骨骼动画&lt;/h3&gt;

&lt;p&gt;有了3D模型，又会有3D模型动画，那么3D模型和3D模型动画之间到底有什么区别，我们先做个了解。&lt;/p&gt;

&lt;p&gt;为了能让读者们更直观的了解模型与模型动画的不同，我们从 Unity3D 的 MeshRenderer 和 SkinnedMeshRenderer 上作为切入点。&lt;/p&gt;

&lt;p&gt;在Unity3D中，MeshRenderer 与 SkinnedMeshRenderer 分别用于渲染 3D模型 和 3D模型动画。&lt;/p&gt;

&lt;p&gt;普通网格(MeshRenderer)渲染的是模型，由3D模型数据组成，蒙皮网格(SkinnedMeshRenderer)渲染的也是模型，也是由3D模型数据组成。&lt;/p&gt;

&lt;p&gt;不过蒙皮网格被创造出来主要是为了动作动画服务的，所以蒙皮网格除了3D模型数据外还有骨骼数据以及顶点权重数据。&lt;/p&gt;

&lt;p&gt;假设说蒙皮网格(SkinnedMeshRenderer)上没放置任何骨骼数据，那么它和普通网格的作用没有任何区别，都只能渲染静止不动的3D模型。&lt;/p&gt;

&lt;p&gt;有很多人并没有理解骨骼动画的原理，所以在实际项目中对3D模型骨骼动画的运用有很多误区，这里我们有必要阐述一下骨骼动画的原理，以及在Unity3D的SkinnedMeshRenderer上骨骼动画是如何组装和组成的。通过对骨骼动画的原理解剖和对 SkinnedMeshRenderer 的解剖，我们能彻底的明白骨骼动画的计算和渲染其实并不复杂，揭开这层薄薄的面纱后是一片平坦的开阔地。&lt;/p&gt;

&lt;p&gt;我们知道3D模型要做动作，首先是模型上的点，线，面要动起来，只有点，线，面动起来了，在每帧渲染的时候才能在每帧渲染时有不同的3D模型形状。&lt;/p&gt;

&lt;p&gt;那么怎么让点，线，面动起来呢？有两种方法，一种是用一个算法来改变顶点位置，叫顶点动画，另一种是用骨骼机制去影响顶点，叫骨骼动画。&lt;/p&gt;

&lt;p&gt;这两种都是通过每一帧改变模型上的各个顶点位置，从而让模型变形，进而形成动画的效果，每一帧模型的形状不一样，播放时形成动画，只是方法不同。&lt;/p&gt;

&lt;p&gt;模型上成千上万的顶点，如果每个都要手动来调整，每一帧都要手动调整一次，这种量级的劳动力，人类无法承受，所以在最初，还没有骨骼动画这个概念的时候，只能用程序写一个顶点走向算法去改变每个顶点的位置，或者用着色器(Shader)在顶点函数中去改变顶点位置成为动画效果，这种动画效果现在很多游戏中都还在使用，这种方法已经成为节省骨骼动画开销的必要手段，比如草、树在风中的左右摆动，丝带或国旗在空中自然飘动等。至于如何在着色器(Shader)中编写顶点动画，我们会在OpenGL渲染章节中讲解。&lt;/p&gt;

&lt;p&gt;骨骼动画的出现让3D模型的动画效果就变得越来越丰富多彩。为什么这么说？因为它是由简单的几个骨骼点组成，一般骨骼动画的骨骼数量都不会超过50个，是人类能够承受的操控范围之内。通过这一些简单的骨骼点操作，加上3DMAX，Maya这样的好用的动画工具，让人类能够创造出许许多多丰富多彩的动画效果。&lt;/p&gt;

&lt;p&gt;首先，骨骼动画由骨骼点组成，每个骨骼动画可以由许多个骨骼，现代手机游戏中每个人物的骨骼动画的数量一般都会在30个左右，PC单机游戏中会更多点到达40-50个左右。骨骼数量越多，表现出来的动画越细腻越有质感，但同时也消耗掉更多的CPU计算。&lt;/p&gt;

&lt;p&gt;其次，一个骨骼可以有很多个子骨骼，每个子骨骼都与父节点拥有相同的功能，只是当父节点移动、旋转、缩放时子节点也随着父节点的一起移动、旋转、缩放，他们的相对位置、相对角度、相对比例不变。这一点与Unity3D中的 GameObject 的节点很相似，父子节点有着相对位置的关系，所以骨骼点在Unity3D中的表现是由类似GameObject的形式存在的，我们可以直观的从带有骨骼的模型中看到骨骼点的挂载结构。&lt;/p&gt;

&lt;p&gt;在 SkinnedMeshRenderer 中就有 bones 这个变量来记录所有骨骼点，骨骼点的表现在 SkinnedMeshRenderer 中就是 Transform 数组，因此 bones 这个变量就是 Transform[] 类型。&lt;/p&gt;

&lt;p&gt;另外，一个骨骼点可以影响周围一定范围内的所有顶点，单一一个顶点，也可以受到多个骨骼的影响。在Unity3D中的 Quality setting 图形质量设置中，我们可以看到关于Blend Weights的设置，就是关于一个顶点能被多少骨骼影响的参数设置。选项中，有1 Bone，2 Bones，4 Bones，意思是一个顶点能被1个骨骼影响，或者被2个骨骼影响，或者被4个骨骼影响，能被影响的骨骼数越多，CPU消耗在骨骼计算蒙皮的时间越长，消耗量越大。&lt;/p&gt;

&lt;p&gt;最后，模型中每个顶点都有对它顶点本身影响的最多4个骨骼的权重值，在Unity3D中这4个骨骼权重被记录在了 BoneWeight 这个类中，每个 Mesh类 都有一个 boneWeights 变量来记录所有顶点的骨骼权重值，而无骨骼动画的 Mesh 是不需要这些数据的。&lt;/p&gt;

&lt;p&gt;每个顶点都有一个BoneWeight 类实例，BoneWeight 中boneIndex0，boneIndex1，boneIndex2，boneIndex3分别代表被影响的骨骼索引值，而weight0，weight1，weight2，weight3则是分别代表被影响的权重值，权重最大为1，最小为0，所有权重分量之和为1。&lt;/p&gt;

&lt;h3&gt;未完，篇幅有限，下篇继续&lt;/h3&gt;
</description>
               <pubDate>Sat, 27 Apr 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/04/27/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB5.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/04/27/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB5.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第五章，3D模型与动画(四) - 3D模型的变与换1</title>
               <description>&lt;p&gt;3D模型是3D游戏中的基础单位，除了在游戏中那些静止的一动不动的3D模型外，还有许许多多动来动去的，这些3D模型除了骨骼动画，顶点动画外，很多时候为了画面效果的表现，我们还需要：切割，简化，变形，捏脸，飘动等等。那么它们是怎么实现的呢？我们今天就来讲讲这蕴含其中的技术与原理。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;一个3D模型是如何显示到屏幕中去的，这整个过程详细讲解下来有点长，所以将它们放在了OpenGL渲染管道章节中，这里我们先来做个不太深入的了解。&lt;/p&gt;

&lt;p&gt;众多的顶点构成了一个3D模型，顶点之间的连线组成了三角形或多边形，其实还是以三角形为主。为什么？因为OpenGL，DirectX都以三角形为单位渲染。至于为什么要以三角形为单位进行渲染，会在OpenGL渲染管道章节中详细讲解。&lt;/p&gt;

&lt;p&gt;这么多的顶点是怎么表达三角形的呢，有很多种方式，例如顶点索引，三角带，三角扇，不过这里我们只说说普遍用的比较多方式，也就是顶点索引方式，其他方式留到渲染管道章节去详细剖析。&lt;/p&gt;

&lt;p&gt;顶点索引是主流的三角形表达方式，其他方式都是为了优化索引这个数组而设计出来的，应用的范围相对小一点。&lt;/p&gt;

&lt;p&gt;顶点索引的方式就是把所有顶点放进一个数组里，然后用另一个数组用来表达三角形的组成（就是用顶点数组里的index下标）。在索引数组里，每3个索引组成一个三角形，也就是说，如果有4个顶点的数组表达了一个正方形的形状，这个正方形相当于有两个三角形组成的，索引的数组就是大小就是6，前3个索引数组表达第一个三角形，后3个数组表达了另一个三角形。&lt;/p&gt;

&lt;p&gt;看数据：(0,0,0), (0,1,0), (1,1,0), (1,0,0) 这个4个顶点构成了正方形。&lt;/p&gt;

&lt;p&gt;那么索引数组就是，0,1,2,2,3,0 ，其中前三个0,1,2构成一个三角形，后三个2,3,0构成另一个三角形。&lt;/p&gt;

&lt;p&gt;依次类推，每三个索引单元描述三角形的三个顶点。&lt;/p&gt;

&lt;p&gt;我们把所有顶点和所有顶点索引都传给显卡驱动，显卡驱动就可以根据这些数据来展示3D模型，这中间并没有这么简单，不过也并没有复杂到不可理解，只是多了些陌生的的流程和步骤而已，熟悉下就可以理解和应对了，这些都将在OpenGL渲染管道章节中，由浅入深的剖析。&lt;/p&gt;

&lt;p&gt;那么图片是怎么贴上去的呢？&lt;/p&gt;

&lt;p&gt;如果把3D的三角形当做一个2D的面片来看就会好理解多了，一个2D的三角形面片为了把图片贴上去，就需要在图片上也指定三个点，图片上的三个点形成了与三角形一样比例大小的形状，就可以贴上去了，如果比例不对称也可以贴，只是会拉伸或缩放而已。这三个在图片上的点坐标就叫u和v，都是2个数字的数组（都是Vector）为什么叫uv而不是传统的xy，因为不想和xy概念混合，而且uv是一个0到1的浮点数，0表示起始位置，1表示最大偏移位置，一听uv二字母就知道说的是图片上的坐标。&lt;/p&gt;

&lt;p&gt;以这种三角形贴图的方式贴到3D模型的每个三角形上，就可以如期的绘制出有’皮‘的3D模型了。&lt;/p&gt;

&lt;p&gt;这样一来，在绘制3D模型时，就多了另一个数组，叫uv数组，这个uv数组是由uv坐标组成的，由于已经有了顶点索引来表达三角形，所以uv数组就不再需要索引来表达了，只需要按照顶点的索引形成的三角形来定制uv的顺序就可以了。&lt;/p&gt;

&lt;p&gt;还是用旧数据举例来说明：&lt;/p&gt;

&lt;p&gt;[(0,0,0), (0,1,0), (1,1,0), (1,0,0)] 这个4个顶点构成了正方形。&lt;/p&gt;

&lt;p&gt;[0,1,2,2,3,0] 组成了顶点索引表达了2个三角形的形成。&lt;/p&gt;

&lt;p&gt;[(0,0), (0,1), (1,1), (1,1), (1,0), (0,0)] 组成了uv数组，表达了两个三角形上贴图的绘制范围。&lt;/p&gt;

&lt;p&gt;别小看这些基础知识，这些基础知识在平时的实践中有很大很大的用途。下面就开始介绍我们在具体实践中，是如何将这些基础知识灵活的运用到项目中去的。&lt;/p&gt;

&lt;h3&gt;1.切割模型&lt;/h3&gt;

&lt;p&gt;模型切割，也可以说模型的分裂，在游戏中也比较常见。我们这里不具体深入不同切割的算法，因为项目的每种切割方式都可以是不同的，可以由不同的算法代替。我们只说如何切割模型，就拿最简单的一刀切割的方式，如’切水果游戏‘那样，横向或纵向切割。&lt;/p&gt;

&lt;p&gt;我们知道一个模型是由一个渲染实例构成的，也就是说一个Render组件（MeshRender或者SkinnedMeshRender,这里统一称为Render组件）只能渲染一个模型。&lt;/p&gt;

&lt;p&gt;那么要把一个Render渲染的模型切割成2个，就相当于把这个渲染组件删掉，生成两个新的Render渲染组件，渲染不同的模型。&lt;/p&gt;

&lt;p&gt;有了这个方向就容易多了。我们可以把原来的Render渲染组件中的顶点数组、顶点索引数组，uv数组，都提取出来，并全部都分成两部分，一部分是切割后的左半部分，另一部分是切割后的右半部分。再把这两部分，分别放入新建的两个新的Render渲染组件实例中去，就得到了切割后的模型。&lt;/p&gt;

&lt;p&gt;假如在切割后再对这两个切割后的模型，加入碰撞体和物理运动组件（或者说重力引擎Rigidbody），就可以让画面表现的像是真实的被切割开来后倒地分成了两半一样。&lt;/p&gt;

&lt;p&gt;这其中，核心的难点是如何拆分成两部分，以什么规则拆分，如何知道这个顶点在左半边还是右半边，切割中如何生成新的切割顶点，如何将这切割顶点缝合。&lt;/p&gt;

&lt;p&gt;首先面临的是怎么区分点在左半边还是右半边，我们不用区分是左边还是右边，只要区分是否是在平面的同一侧就可以了，方法有很多，比如点与平面上任意点组成的线段和平面上任意线的点积来判断是否为相同一侧，也可以通过平面与线段的交点之间的连线与点与交点的连线的点积判断是否为同一侧。&lt;/p&gt;

&lt;p&gt;其次我们用平面与线段是否有交点的图形算法，来判定是否有新交点。把所有三角形的线都与平面做交点碰撞测试，如果有碰撞，则交点就是新切割点。得出的新切割点用处很大，而且要复制两份，一份放在左半部分，一份放在有半部分。&lt;/p&gt;

&lt;p&gt;切割后，原本点与点之间相连的映射关系被打破并转移到了新交割点上，于是旧点与新切割点组成了新的三角形，左右两部分都是同理。&lt;/p&gt;

&lt;p&gt;用数组的方式更容易理解点，还是拿上面的数据来举例。&lt;/p&gt;

&lt;p&gt;[(0,0,0), (0,1,0), (1,1,0), (1,0,0)] 这个4个顶点构成了正方形。&lt;/p&gt;

&lt;p&gt;切割后分成了两个数组，假设切割点为中点对半切开，也就是切割点位(0.5,0.5,0)和(0.5,0,0)。&lt;/p&gt;

&lt;p&gt;此时数据就变成了这样&lt;/p&gt;

&lt;p&gt;[(0,0,0), (0,1,0), (0.5,0.5,0), (0.5,0,0)]&lt;/p&gt;

&lt;p&gt;和&lt;/p&gt;

&lt;p&gt;[(0.5,0.5,0), (0,0.5,0), (1,1,0), (1,0,0)]&lt;/p&gt;

&lt;p&gt;这个举例的例子是相对比较简单的实例，不需要缝合切面。&lt;/p&gt;

&lt;p&gt;如果切割的对象是一个立方体或者更复杂的模型，切割后，就需要缝合切割面。因为缝合的面上所有点是在同一平面的，所以缝合时只需要缝合新生成出来的交点部分就可以了，因为其他部分还是保留原来的样子。&lt;/p&gt;

&lt;p&gt;缝合的算法很多，主要的目的是，将多新生成出来的点，有规则的组成新的三角形，进而形成一整个切割面。&lt;/p&gt;

&lt;p&gt;其中一种算法是，先选一个点，再用这个点与其他点形成的线段算出夹角，用夹角的大小进行排序，排序后的结果，就是顺时针或者逆时针的点位，然后按顺序先将靠最前面的前三个点形成一个三角形，后面的点位与它之前的两个点形成新的三角形，也就是第4个点与前两个点也就是第三个点和第二个点形成三角形，第5个点与第4个和第3个点形成新的三角形，依次类推形成切割面。&lt;/p&gt;

&lt;h3&gt;2.扭曲模型&lt;/h3&gt;

&lt;p&gt;扭曲模型，相当于将3D模型变形，凹进去，凸出来，部分放大，或者部分缩小等。&lt;/p&gt;

&lt;p&gt;有了上面介绍过的3D模型的基础知识，这里在编写模型的变形时就显得更加容易。&lt;/p&gt;

&lt;p&gt;3D模型就是由三角形组成的，三角形是由点组成的，要变形就是移动顶点的位置，不只一个顶点的位置，是一片顶点的位置，或者说一个范围上的点的位置。&lt;/p&gt;

&lt;p&gt;扭曲和变形在实际项目中也有很多应用，比如爆炸后的地面凹陷，击打某墙壁后的墙壁有个凹陷的表现，或者拉某个球时球有个先被拉伸再恢复的过程，或者3D模型表现制陶工艺，将模型从一个罐头转转转，拉拉拉，拉成一个自定义的陶瓷品，也些角色扮演类游戏中，操控的摇杆就是用可拉伸的泡泡糖表现的，这些都是对模型内某个范围或者某些顶点的进行位移后表现出来的。&lt;/p&gt;

&lt;p&gt;顶点的点位的移动相对比较简单，就是取出顶点数组，修改坐标，再放进去，三个步骤。&lt;/p&gt;

&lt;p&gt;难点一是如何正确找出需要修改的顶点，二是不同的点修改的值如何不同，找出修改方向的算法，三是持续修改的算法。&lt;/p&gt;

&lt;p&gt;我们拿爆炸凹陷，球体拉伸反弹，制陶工艺这三个例子来剖析如何扭曲模型的技巧。&lt;/p&gt;

&lt;p&gt;当发生在场景中发出爆炸特效时，首先找出爆照范围的这块地面，并取出这块地面的所有顶点数据，对所有顶点求出在爆炸范围球体内的地面顶点，这些顶点就是需要修改的顶点。&lt;/p&gt;

&lt;p&gt;爆炸需要凹陷，凹陷算法的目的是把顶点位置修改到爆炸球体的球表面上，这个算法相当于，如何把一个点对应到一个球体的面上，计算出来后修改点位置，再装入渲染的实例中，凹陷变形就完成了，顶点索引和uv都不需要任何变化。&lt;/p&gt;

&lt;p&gt;再说说球体拉伸与反弹恢复，第一个动作是拉伸球体，计算所有顶点与要拉的那个点位的距离，距离越大，顶点需要的位移的越小，这个比例肯定不能是个正比关系，一定是一个衰减的曲线，例如距离是d，拉伸的距离为f，结果为res，最简单的衰减公式为 res =  f/(d * d)，用这个公式对每个顶点进行计算，得到一个需要移动的数据res，这个数据是根据距离大小而衰减的，与拉伸点离得越近移动量越大，反之越小。修改完成所有顶点的坐标后，再推入渲染实例中去，就得到了球体拉伸的效果。&lt;/p&gt;

&lt;p&gt;球体的第二个动作是放开后恢复，这里我们假定球体的屁股是被固定的。恢复和拉伸有点相似，拉的最远的反弹的快，也就是与原有的位置距离最大的点反弹的速度最大，也就是说，我们需要记录原来没被拉伸时的顶点的坐标位置，他们与原来的位置相减就是反弹速度的基础变量。&lt;/p&gt;

&lt;p&gt;反弹力度肯定也不是正比关系，肯定也是类似衰减公式的增强公式，或者说是弧线比例，最简单的公式就做个平方，res = d * d，或者为了更平滑点，找个更好的曲线公式res = (d / max) * (d - 2) * k。&lt;/p&gt;

&lt;p&gt;反弹恢复的力度，在不断得计算过程中，会由于顶点与原有的点位的距离缩小而减小，后又由于反弹过度而不断放大，有一个来回反弹的过程，最后恢复到平静不再移动的状态，用这个公式能就很好的体现出来，因为它与原顶点距离有关，力度在不断得衰减，最后形成稳定态。&lt;/p&gt;

&lt;p&gt;最后再说说制陶工艺的模拟，一个罐体模型在转盘上不停的转，当用手（鼠标或者触摸屏）去触摸它的时，在触摸的点会形成凹陷，或者拉伸，人们通过在这样不断的凹陷和拉伸过程中制作出了一个完整的陶瓷的模样，这就是制陶工艺的过程。&lt;/p&gt;

&lt;p&gt;在一个叫做《釉彩》的手机App中有具体的表现，里面你可以用一个很丑的泥罐，通过来回、上下、左右的手指滑动制作出一个你喜欢的陶瓷品，制作出来的陶瓷品可以让别人定做，也可以通过里面的超市直接购买。&lt;/p&gt;

&lt;p&gt;它的原理非常简单，就是在当你触碰时，根据你的手指滑动的方向，把范围内的顶点向手指滑动方向偏移，并且有一个衰减范围，离手指最近的点越近拉伸的距离越大，离得越远拉伸的距离越小。顶点选取的范围的判定可以认为是在一个矩形中的范围，比如认定的手指滑动的矩形范围，从而构建出一个相应的立方体范围，进而选出在立方体内的顶点，再进行衰减式的位移，最终构建出，可上下，左右，对陶瓷罐的拉伸变形操作。&lt;/p&gt;

&lt;p&gt;由于篇幅限制，下篇将继续介绍’3D模型的变与换2‘。&lt;/p&gt;
</description>
               <pubDate>Sun, 21 Apr 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/04/21/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB4.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/04/21/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-3D%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8A%A8%E7%94%BB4.html</guid>
            </item>
        
            <item>
               <title>思路探讨(二十三) 997成就世界</title>
               <description>&lt;p&gt;实际上还是有人不知道996是什么的。996，每天早上9点上班，晚上9点下班，周6加班，一周工作6天。&lt;/p&gt;

&lt;p&gt;似乎所有人都很痛恨这种模式，当所有人都在喊996痛苦的时候。你，就不应该喊了，你是普通人吗，你不是的。普通人每天过着凑合的日子，每天上着凑合的班，做着凑合的工作，什么都凑合。加班对他们来说是种恶毒的迫害，是对他们劳动力的剥削，是对他们娱乐生活的不尊重，所以他们痛恨。他们认为资本家是万恶的，是拥有无限权利的，是可以掌控世界的，是可以无所不能的，所以他们拒绝资本家的‘迫害’。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;那么真的是他们想象的那样吗？是真的为了迫害，是真的为了剥削，是真的不尊重，是真的万恶，是真的拥有无限权利和无所不能，才996的吗？不是的。&lt;/p&gt;

&lt;p&gt;资本家也是人，有一天你也会成为资本家，其实你我都有可能是资本家。资本家是人，也会痛苦，也会被迫害，也会遭遇不幸，也同样受到压迫，只是他们穿的西服比我们贵，但这并不舒服，不如我们的睡袍和卫衣，吃的200块钱一餐的美食，同样有可能用的是地沟油，也不如我们的汉堡包、薯条、鸡块来的可口。&lt;/p&gt;

&lt;p&gt;世界真的是公平的，不会因为你钱多而让你的痛苦少一点，也不会因为你钱少而给你少一点的机会。&lt;/p&gt;

&lt;h3&gt;我不赞成996，但我心中不止996，成年人世界里辛苦点又算的了什么，为了生存，为了更好的生存，为了追求极致的生存，皮肉上痛苦在成年人的世界里已经是最轻量级的痛苦了。&lt;/h3&gt;

&lt;p&gt;普通人依赖环境，没有环境他们无法生存。普通人，任人摆布，他们无法自控只有听从于他人。普通人，委曲求全，没有突出的能力到哪都是求稳定，稳定就要牺牲自我牺牲尊严。普通人，听从命运，你愿意听从你那稀烂的命运吗？！&lt;/p&gt;

&lt;p&gt;世界是残酷的，也是公平的。残酷在，人人都要为生存而斗争，不是你死就是我活。公平在，只有勤奋努力好学的人才配的上成功，机会永远都是给那些积累很多年并且时时刻刻保持勤奋努力好学的人的。&lt;/p&gt;

&lt;p&gt;当面临淘汰时，也同样公平，也同样残酷，那些凑合的人最先被淘汰，然后那些普通人大部分被淘汰，留下的普通人只是幸运儿，下次还会这么幸运么，你死我活的斗争一直没有停歇。&lt;/p&gt;

&lt;h6&gt;996不能赢得世界，但997能(相当于全年无休)。为什么？&lt;/h6&gt;

&lt;p&gt;因为996给自己留了余地，说一周来每天这么辛苦最后一天让自己休息一下。实际上，只要停下来，启动就难了。给了一个停下来的理由，启动的理由却又要再次寻找了。难以维系。&lt;/p&gt;

&lt;p&gt;我们之间有聪明与不聪明的区别吗？没有，（不要以为自己比别人聪明，当这么认为的时候我们就已经输了一半了）。从整个人生来看，到死之前，我们比的都是谁能坚持到最后，比的是都是耐力，是毅力，是勇气。谁能勇敢的坚持到最后谁就能赢得世界，聪不聪明只是人的自以为是的幻想而已，持久战才是人生真正的赛点。&lt;/p&gt;

&lt;p&gt;那么‘坚持’真就这么容易吗？不是的。‘坚持‘超难，难到怀疑人生。&lt;/p&gt;

&lt;h6&gt;为什么997就能成就世界？因为全年无休让你不得不转变观念。&lt;/h6&gt;

&lt;h6&gt;当我们明白自己无法逃脱全年无休的状态时，我们已经彻底放弃了所有试图休息的谋划，转而关注如何提高专注力，如何用更少的精力做好当下的事情，如何加强体力，如何加强免疫力，以及如何平衡工作、学习和娱乐三者之间的关系。&lt;/h6&gt;

&lt;p&gt;我们训练了更多提高专注力的方法，从而提高了专注力，训练了更多做好事情的方法、知识和技巧，从而提高了效率，加强了每天的健身锻炼，从而让自己每天元气满满，免疫力爆棚，抵御外来病毒侵扰，让高效状态保持的更久更有力。&lt;/p&gt;

&lt;p&gt;我们开始主动关注了每天工作的时间，学习的时间，娱乐的时间，不断调整着三者的时间平衡，我们没有时间娱乐，但人又不能没有娱乐活动，所以我们只能在工作中学习，在学习中娱乐，在娱乐中工作，边工作边学习边娱乐，三者混为一体，工作即学习，学习即娱乐，娱乐为了更好的工作，保持平衡和高效，不断主动的调整，因为它们并不是一个固定时间比，每个人每个时间段每个环境下都不一样，需要主动及时调整。&lt;/p&gt;

&lt;h6&gt;997让我们做时间的朋友。&lt;/h6&gt;

&lt;p&gt;全年无休的情况下我们不得不做时间的朋友，只有让时间成为我们最重要的朋友，我们才能减轻无休的痛苦。做时间的朋友最大的好处便是复利，时间就是复利的要素，每天积累一点，一年下来你就比别人多跑一点，5年下来，你就比别人多跑好几个整圈，10年下来你就比别人多跑好几个级别的比赛。&lt;/p&gt;

&lt;p&gt;每天都问下自己，今天和时间这个朋友合作的如何，今天有把时间好好分配吗，能对得起这位默默无闻支持你永不抛弃永不放弃你的朋友吗，如果有明天继续，如果没有明天继续努力。&lt;/p&gt;

&lt;h6&gt;997让我们转念，转念之间，997反而成就了我们，让时间成为了我们最好的朋友，让复利的积累引领我们走向了世界的巅峰。&lt;/h6&gt;
</description>
               <pubDate>Sat, 13 Apr 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/04/13/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A823.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/04/13/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A823.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第八章 AI(3) 非典型性AI</title>
               <description>&lt;p&gt;前面讲了状态机和行为树在AI中的运用，在实际开发过程中，特别是一些在游戏行业做过5-10年左右的很多人似乎似乎已经习惯了用这些固定的工具去写AI逻辑，一想到游戏AI就固定思维的认为，就用状态机去写，或者说就用行为树去写。&lt;/p&gt;

&lt;p&gt;思维跳不出这些‘工具’，我们就成不了大师。大师是什么，是能将‘剑’运用到最高境界的人，手里‘无剑’而心中有剑，是他们的至高境界。万事万物都是同一个道理，‘技术’就像剑术，在练习过程中，都会经过几个阶段，到底具体有哪些阶段每个人都不一样，我能确定的是，‘识剑’是第一个阶段，认识剑是怎么样的，或者说认识‘技术’是个怎样的东西用在哪里。而‘用剑’是另一个阶段，如何用剑或者说如何运用这项‘技术’是大多数人停留的阶段，怎么用剑怎么用好剑，是一个非常漫长而枯燥的阶段。‘无剑’就是最后一个阶段，手里没有剑而心中有剑在剑术的造诣上达到了至高的境界，无剑胜有剑在这个阶段体现的淋漓尽致。&lt;/p&gt;

&lt;p&gt;我们接触的面要尽量的广，接受和包容的东西要尽量的多，才能体验到更多的东西。游戏开发也是，世界上不是只有RPG角色扮演类一种游戏类型，还有SLG策略类游戏，还有休闲娱乐类游戏，还有体育竞技类游戏，还有学习教育类游戏等等等。只有状态机，只有行为树，或者只有状态机和行为树是无法为项目开发出最好最适合的AI的。我们应该尽量包容非典型性AI。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;下面我们来了解下游戏项目中非典型性的AI。&lt;/p&gt;

&lt;h3&gt;1，庄家式AI&lt;/h3&gt;

&lt;p&gt;顾名思义，是庄家统治游戏的一种玩法，玩法中AI就是全局的统治者，它决定了整个游戏的高潮和低谷，AI如何操作成为了至关重要的关键点，玩家是否喜欢这款游戏很大程度上取决于AI的策略。&lt;/p&gt;

&lt;p&gt;这种类型游戏大部分以彩票或赌局的形式存在，比如老虎机，百家乐，21点，以及部分以彩票为形式的游戏。&lt;/p&gt;

&lt;p&gt;AI策略的目的是要让玩家玩的好又不能赢太多而且最终是要输给AI的。玩家喜欢继续玩但从总体上来看却又是输的，让庄家就是游戏运行商有的赚，但又不能太狠，让游戏细水长流。&lt;/p&gt;

&lt;p&gt;这种AI常以输赢的概率为基本控制手段，比如现阶段以玩家欢乐为主，那么胜的概率变得大一点，玩家会认为幸运女神眷顾他了，一段时间后为了让玩家遇到点困难，让玩家有挑战性，这时AI慢慢降低了赢的概率，玩家缓慢觉得赢的次数开始减少，有些玩家会以为幸运女神走了，需要靠自己的‘本事’玩下去了，他们不断得发现和寻找输赢的规律，以及出牌和翻牌的概率，直到输得所剩无几，然后AI开始了缓慢提高胜率的操作，让玩家又看到了希望，找到了自信，认为自己终于不费苦心找到了规律和破解的秘密，于是又开始了一轮有输有赢但赢多输少的旅程。&lt;/p&gt;

&lt;p&gt;如此这般不断得循环往复，AI以一种庄家的形式控制着整个游戏过程。&lt;/p&gt;

&lt;h6&gt;从技术上来看，这种控制概率的过程，就是加法和减法的过程，相对比较简单。其核心是给出一个概率后，如何让它真的起到概率的作用，而且这种概率能让人很舒适的接受，比如当有30%概率赢时能否做到真正的随机值在30%的概率上徘徊，比如10局中有2-4局能中玩家可以得到想要的那个点位或者想要的牌什么的，而不是10局中0-5局能赢，输赢实际结果波动到了不好的体验。&lt;/h6&gt;

&lt;h3&gt;2，可演算式AI&lt;/h3&gt;

&lt;p&gt;可演算式的AI在策略类游戏中非常常见，在页游里的大部分的自动对战，以及现在卡牌手游中的大部分自动战斗都是可演算式的AI，是可以根据两边的阵容数据和一个随机种子来演算出整场战斗的每个细节的。例如，两个军队的各5个英雄，互相间攻击并释放技能，服务器需要在一瞬间把所有需要在客户端演示的内容都计算出来，并以数据的形式发送给客户端，客户端根据演算的数据进行展示人物的动作，位移，技能释放等，客户端并不需要计算任何内容，所有内容都在服务器里已经计算好了，以数据形式代表了整个过程。&lt;/p&gt;

&lt;h6&gt;可演算式AI的特点是逻辑一定是确定性的，不能是模糊的，或者会随机改变的，或者随时间变化而变化的结果，同样的数据第一次计算和多次计算的结果必须是相同的，才能最终体现出可演算的这个特征。&lt;/h6&gt;

&lt;p&gt;其次，可演算式AI大都是根据时间轴来演化游戏的进程，在那里‘时间轴’的概念在可演算式AI中是比较常见的。&lt;/p&gt;

&lt;p&gt;什么是时间轴演算路径？我们用卡牌对战算法来举几个例子。&lt;/p&gt;

&lt;p&gt;首先最简单的时间轴演算路径，例如，先由敏捷度最高的英雄进攻，等待英雄进攻完毕后再由其次高敏捷度的英雄进攻，依次进行下去直到所有的英雄进攻完毕再重新一轮进攻。这种相对比较简单，可以把进攻看成一轮一轮的回合，每个回合都相当于是一次for循环，每次for循环前先对敏捷度进行排序，再在for循环中依次计算进攻了谁受到了多少伤害，以及是否死亡。最后把进攻的数据和伤害的数据用队列的形式存储在数据中发送给客户端，客户端受到数据后再进行演示。&lt;/p&gt;

&lt;p&gt;稍微复杂点的时间轴逻辑，例如，不再由敏捷度来决定进攻的先后次序了，而是由每个英雄的进攻间隔冷却时间来决定进攻次序，对战开始时开始计算每个英雄的进攻冷却时间是否结束，谁的冷却时间先结束谁就最先得到进攻权，进攻完毕后再等待下一个英雄的冷却时间，以此类推。从技术上讲，冷却时间不需要等待，把所有英雄加入一个队列，排序一下就可以得到谁的剩余冷却时间最短，就立马可以开始计算进攻细节，完毕后根据冷却时间插入到队列中去，任然还是一个有序的剩余冷却时间队列，一直这样计算下去直到演算结束一方胜利或失败。这种演算方式就有了更多了时间轴的概念。&lt;/p&gt;

&lt;p&gt;再稍微复杂点，前面所说的进攻逻辑都是在其他英雄都停止的状态下进行的，现在进攻时不再需要其他英雄等待了，一旦冷却时间结束就可以立刻进攻。也就是说，每个英雄都可以在其他英雄还在进攻时进行进攻操作，只要他的冷却时间到位，并且他的进攻时需要花费固定时间的，等到进攻完毕后再判断对方和自己是否死亡。这种方式，不只是多了一个进攻消耗时间这么简单，还多了一个死亡判断时间，在还没有死亡判定前，此英雄虽然是死了但任然可以被进攻。从技术上来看，计算的量从单一的剩余时间量排序，增加了进攻消耗时间排序插入，以及死亡判定排序，我们既要在冷却时间结束时计算进攻，还要在选择进攻对象时计算该英雄是否已经判定死亡，最后在进攻完毕后计算当前的时间并插入到排序队列中。&lt;/p&gt;

&lt;p&gt;再复杂点，英雄在进攻一半时可以被别的英雄打死，也可以被其他英雄的技能打断，也包括了随时被回复血量蓝量，增加状态等等，让战斗更加逼真、更具有实时性。加强了实时性的要求，更加考验可演算式AI的复杂度，由于太多的需要计算的时间内容，所以我们必须有一个能有效管理时间轴的方法。从技术上来看，我们必须定义‘时间节点’这个概念了。&lt;/p&gt;

&lt;h6&gt;什么是‘时间节点’？‘时间节点’就是一个事件在整个过程的时间轴上的发生时的位置。&lt;/h6&gt;

&lt;p&gt;有了时间节点这个概念，我们可以用时间节点为计算标准，把所有人物的下一个事件的时间节点计算出来，比如，移动到达敌方位置，又比如，释放技能，又比如，回到原地，又比如，冷却时间结束，每个人只计算最近的一个时间节点，并把计算出来的结果放进队列中，然后就可以找出时间节点里离我们最近的一次事件的发生节点，也就是时间差最少的节点，执行它。&lt;/p&gt;

&lt;p&gt;由于每个时间点都有可能引起其他时间点的变化，比如把对方打死了，对方的时间节点就消失了，又比如打断了别人技能释放，对方就回到了冷却时间，时间节点就需要重新计算了，又比如加速了友军的攻击速度，因此所有友军正在攻击或打算攻击的时间节点都要重新计算了，等等等等。&lt;/p&gt;

&lt;p&gt;所以每次在执行完一个时间节点后，都要对有可能产生变化的人物的时间节点进行重新计算，并加入队列，然后就可以找出离我们最近的一个时间节点了，当然旧的时间节点数据必须清除掉。&lt;/p&gt;

&lt;p&gt;如此往复的重复这个计算过程，直到没有任何时间节点可计算和执行，最终决出这张战斗的胜利或失败。&lt;/p&gt;

&lt;h6&gt;时间轴贯穿了整个AI过程，人物之间的打斗，移动，释放法术，冷却时间等待，AI每次只计算一个时间节点，因为只有最近的那个时间节点是一定不会被其他节点影响的，这样既照顾到了可演算的根本原则，也照顾到了游戏的实时性，让战斗更加精彩。然后把每个计算的结果都记录下来，就可以在客户端进行演示了，整个过程的事件发生的时间都将准确无误呈现出来。&lt;/h6&gt;

&lt;h3&gt;3，博弈式AI&lt;/h3&gt;

&lt;p&gt;游戏项目中大部分AI的目的都是以娱乐玩家为主，并没有要真正打败玩家，最多也是要与玩家达到一种平衡。而博弈式AI则不同，它的目标就是为了打败玩家，它是为了赢得比赛而生的。&lt;/p&gt;

&lt;h6&gt;博弈AI最大的特点是搜索。通过搜索，将所有下一步可能发生的，以及下几步可能发生的事情都记录在内存中，以此来确定电脑该怎么进行下一步动作，进而获得最大的效益。&lt;/h6&gt;

&lt;p&gt;有的人不理解为什么是搜索，这里稍微做下解释。在AI选择下一步的动作前，下一步要发生的情况有很多，我们需要选择最佳的那个，怎么选择呢？把所有下一步的情况都列出来，再把下一步的后几步的情况也列在下一步的下面，由于cpu计算量的限制后面的几十几百步计算量太大以至于无法计算，假设我们只计算和预测十步的结果，我们需要找到第十步的最好结果，再反推到第一步来确定第一步到第十步是怎么走的。&lt;/p&gt;

&lt;p&gt;把这十步的所有结果都计算出来太耗时CPU负重太大，有些甚至无法承受这样大的计算量，那么我们就要在没有结果的情况下得到最佳选择，怎么做呢？既然我们要从第一步走到第十步，假设第一步有10种情况，第十步有10种情况，每一步之间都有一个结果就相当于一点到另一个点的路径一样，从第一步到第十步就可以视为路径的一种，那么从第一个点到第十个点的最短路径，就是第一步到第十步的最佳结果。把视角一转换后发现事情变得的简单了，用最短路径算法就可以解决搜索问题。&lt;/p&gt;

&lt;p&gt;不过事情远没有这么简单，这里只是举了个简单的例子，情况会复杂到每一步有几百种情况，普通的搜索方式计算机可能完全无法承受。为了能让计算机承受这样大的计算量，我们就需要引入更多的枝剪和优化，比如，存储一些固定技巧，以及拒绝计算一些明显比较差的选择。&lt;/p&gt;

&lt;h6&gt;另一个特点是AI对局势的估值该如何认定。估值表示了当前局势的好坏程度，通常用一个0到100的浮点数来表示估值，估值的好坏是AI一个比较关键的点，只有正确的计算出局势的估值，AI才能知道选择的行动方向是正确的还是错误的。&lt;/h6&gt;

&lt;p&gt;拿最简单的五子棋来说。棋盘上的每一个点都是对手下一步的可能性，通常不会在空白处下一个完全不着边的棋，所以搜索范围缩减到了当前棋盘上有棋子的范围周围的空位。AI对所有这些空位录入并计算当AI把棋子放入该位置上后，对方可能做出的反应以及由此引发的后几步的对弈可能。我们假设AI只搜索和计算后5步的预测，也就是说，计算出来的当前落子的估值，就是所有棋盘中可落子的后5步内最优估值。&lt;/p&gt;

&lt;h6&gt;最后一个特点是数据录入。人类的手法太过高明，欺骗性很强，很容易就能躲过AI的盲点，所以录入特别的人类的想法的是博弈AI的一大关键点。没有数据的录入，AI很难知道人类的想法。&lt;/h6&gt;

&lt;p&gt;96年97年的人机国际象棋大战就是录入了大量的棋局来告诉AI人类的一些固定走法，让AI在对弈中识别人类的套路。&lt;/p&gt;

&lt;p&gt;以前的数据是一些人手动录入的，所以局限性还是很大，不能应付现代这么快更新换代的技巧和想法。为了做出更强大的博弈式AI，我们不得开始让AI拥有自学的能力，所以机器学习，深度学习得到了广泛的关注和应用。它们原理就是数据录入，加，估值判定，给AI不断地喂数据的同时，告诉AI这个数据是对的还是错的，或者说估值能达到多少，通过不断的喂数据（也相当于用数据训练AI）的方式，让AI拥有丰富的‘经验’，从而在对弈中赢得比赛。&lt;/p&gt;
</description>
               <pubDate>Sun, 07 Apr 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/04/07/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-AI3.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/04/07/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-AI3.html</guid>
            </item>
        
            <item>
               <title>思路探讨(二十二) 人为什么做不出最正确的选择</title>
               <description>&lt;p&gt;人这一生真的能在每个节点都做出最好的决策吗，肯定不能。这个比较理想化的美梦，大多数人都知道是不可能的。&lt;/p&gt;

&lt;p&gt;但人真的能在模棱两可的分岔路面前做出最正确的决策吗？我认为是不可能的。（需要明确一点是，模棱两可的选择是指两种或者几种选择都是朝着光明的方向去的，而不是一黑一白或者两种都是黑。）&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;为什么做不出最正确的选择？&lt;/p&gt;

&lt;p&gt;因为最好的决策通常都是事后分析才会知道，在当下是无法知道事情到底会如何发展，只有当事情变成了历史，我们再回过头来看这件事时才能真正找到最好的决策方向。&lt;/p&gt;

&lt;p&gt;比如，何时买股票，何时卖股票，何时买房，何时卖房，选择什么专业，该不该和这个人结婚，该不该下海去创业，该不该选择这个人合作，该不该送孩子出国，该报考哪所学校，以及该不该跳槽，应该去哪座城市工作和生活等等等。所有这些都会等你做出决策，并执行多年后，再回过头来梳理时，才能真正明白到底我做对了还是错了。&lt;/p&gt;

&lt;p&gt;为什么是要等事情成为了历史才能知道当时该如何决策，我就不能直接洞悉事情的发展方向做出相应的决策？&lt;/p&gt;

&lt;p&gt;不能。因为世界是变化的。&lt;/p&gt;

&lt;p&gt;我们所处的这个世界里每分每秒都在变化，在这个变化的世界里，我们永远无法知道事情会如何发展，永远无法知道别人到底怎么想（你以为你聪明到能知道所有人的想法时就已经代表你错了），他们到底会怎么做，有多少人会这么想并有多少人会那样做，这所有与之有关的人的行为会给这样事情产生多少影响，又有多少人会因为别人的行为而改变自己的行为方式，你认为就凭你聪明的脑袋能计算的过来么，不可能。&lt;/p&gt;

&lt;p&gt;更何况还有那些与事情有关联的人的关联人，以及与之相关联事情的事情，太多太多，甚至我们都无法知道究竟有多少与之相关联的事情在同时发生，何况在同一时刻这所有关联的人和事都在不断得产生着变化。&lt;/p&gt;

&lt;h6&gt;我们不得不敬畏这个世界，我们永远无法估量，到底有多少事情在影响着我们当下关心的这件事情。&lt;/h6&gt;

&lt;h6&gt;在这个变化的世界里，想做出最正确的选择，是不太可能的，正确的选择只有在回顾历史时才存在。而我们只能就自己的理解做出自己认为最正确的选择。&lt;/h6&gt;

&lt;p&gt;那么做出一个正确的选择真的那么重要吗？不是的。为什么？&lt;/p&gt;

&lt;p&gt;我们退一步说，即使从历史的角度看我们做出了正确的选择，就一定能成功吗？不是。&lt;/p&gt;

&lt;p&gt;首先，即使我们很幸运做出的选择，从历史角度看是最正确的选择，我们也不一定能执行到位。&lt;/p&gt;

&lt;p&gt;实际上，大部分时候连我们自己都不太相信自己做出的决策是对是错，总是在摇摆不定，虽然在表面上坚定的支持这种选择，但在心里还是持有一定的怀疑的态度。这种怀疑的态度，导致我们无法完全百分百的执行我们做出的决策。&lt;/p&gt;

&lt;p&gt;知行合一的难度就在这里，我们到底相信多少我们所知道的。由于人类思维的灵活性以及人性的弱点，我们很难百分百相信我们所知道的一切，永远都在怀疑是否有更好的我们所不知道的存在，所以很难做到相信即行动。&lt;/p&gt;

&lt;p&gt;其次，即使我们很幸运做出了正确的选择，并且很坚决的执行了决策，但成功并不是一个决策而导致的结果，而是由几百几千个决策共同组成的决策群，和，所有为之努力的执行方式的集合组合而成的结果。&lt;/p&gt;

&lt;p&gt;成功的难度就在这里，一个决策并不能决定一个人或一件事的成功与否，成功是由一群决策方向和一群行动方向组合而成，并经过多年累月得到的最终结果。&lt;/p&gt;

&lt;h6&gt;抢到门票就能赢吗？不是的，门票只是一个赛跑的起步优势点并不能决定整场比赛的输赢，别忘了拼命抢到的门票也有可能是一场灾难的开始。&lt;/h6&gt;

&lt;h6&gt;做出‘一个’正确的选择并没有那么重要。重要的是做出选择后的所有其他的选择，以及接下来的所有行动。我们共勉。&lt;/h6&gt;
</description>
               <pubDate>Sun, 31 Mar 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/03/31/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A822.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/03/31/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A822.html</guid>
            </item>
        
    </channel>
</rss>