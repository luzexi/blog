<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title></title>
        <description>漫漫人生,记录点滴技术,始于2013</description>
        <link>http://www.luzexi.com</link>
        <atom:link href="http://www.luzexi.com/assets/feed.xml" rel="self" type="application/rss+xml" />
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第十章，地图与寻路(四) 地图的制作与优化</title>
               <description>&lt;h3&gt;地图的制作与优化&lt;/h3&gt;

&lt;p&gt;场景的制作占到所有项目制作中非常大的一块工作内容，这里我们不说场景制作在美术层面上的制作技巧，我们来说说技术层面的。上节把地图编辑器说了一遍，这节我们就在地图编辑器之外说说，地图场景的制作与优化。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;我们先来说说场景中的地图，准确的说应该说地形，地形是场景中比较关键的一部分，在项目中地形的制作分为几种：&lt;/p&gt;

&lt;h3&gt;一种是手动拼接的地图。&lt;/h3&gt;

&lt;p&gt;手动拼接的地形比较常见，由3D设计师制作出来的3D模型作为地面的地形放置在场景中，相当于是一个模型落在场景上一样，只是这个3D模型很可能是有碰撞体的，碰撞体即 Unity3D的 Mesh Collider 根据项目的需要而增加物理系统的组件，一般都会直接使用 Mesh Collider，除非是完全平面式的，不需要碰撞组件，而是自己开发的一套基于平面的2D地图障碍与寻路，完全脱离了传统的物理系统。&lt;/p&gt;

&lt;p&gt;也有可能会使用Unity3D内置的地形，也一样相当于一个3D模型放置在场景中，Unity3D的地形可以任意的改变起伏，但地形的渲染消耗比较大，因此我们并不建议使用Unity3D内置的地形，而是建议地图设计师和3D模型设计师用 Maya 和 3DMax 等模型软件来构建地形的起伏，这种做法能更加容易的被设计师掌控以及自由发挥，也更加节省资源，对程序来说在处理性能优化时也更加容易一些。&lt;/p&gt;

&lt;p&gt;其他3D物体，比如石头，小石块，草，树，动物等也用同种方式放置在场景中，只是放置的手法可能不同，有的可能通过嵌入到prefab的方式，而有的可能通过地图编辑器加入到地图数据文件中，再在加载的地图时，从文件数据中得到要加载的实体的资源位置，再实例化到场景中。&lt;/p&gt;

&lt;p&gt;手动拼接的好处在于地形和地图是可以完全表达美术风格的，地形设计师和场景制作人员能根据自己的喜好和想象中的画面来自由得定制场景，他们可以任意的移动、旋转、缩放，甚至更换、修整、完善等，这能让他们对场景画面的把控有很大的自由度。&lt;/p&gt;

&lt;p&gt;能自由发挥当然是好事，但也带来了诸多不可控性，由于场景内物件没有统一的标准，因此在场景制作时常常会大量使用，小块的地形，甚至带有动画的地形，特效，以及半透明效果来增强画面的效果，画面效果增强的同时导致性能急剧降低。地图上的小件就更不用说了，在给予场景制作团队自由发挥的同时，我们可以想象同时造成了性能无法承受的问题。&lt;/p&gt;

&lt;p&gt;虽然这本质是没有制定和规范场景制作的要求的问题，但无论怎么规范，毕竟不是每个团队的执行力都是完美的，大部分的执行力都是差强人意的，所以都会或多或少的在优化阶段发现很多糟糕的、令人头疼的性能开销问题。&lt;/p&gt;

&lt;h3&gt;另一种是地图地形的程序拼接方式。&lt;/h3&gt;

&lt;p&gt;用程序拼接地图的主旨意图是希望能更好的为设计人员自由设计更好的地图而选择的方式，不仅仅是美术设计人员，还包括策划设计人员，需要在设计和性能上求得平衡点，这样所有的地图都由程序而生成了一个或者几个模型的结构铺满整个地图。&lt;/p&gt;

&lt;p&gt;这种方式来制作地图最常见的要属2D的RPG游戏了，2D角色扮演类游戏中，几乎整个屏幕的地形都需要用地图编辑器来建立和拼合的，当需要这类地图出现时时，程序会将地图数据加载进来后，对每一块的地图都进行动态的拼合，这样一来，整个地图就只有一个drawcall，因为它只是同一个模型。&lt;/p&gt;

&lt;h6&gt;我们先来看看2D RPG游戏中，是如何动态拼合整个地图的&lt;/h6&gt;

&lt;p&gt;很多2D游戏都通过了Unity3D实现，其实2D也是有Mesh、顶点、UV的概念，和3D比起来只是少了1个维度而已。在2D游戏中的地图拼接的手法也都是通过生成顶点和三角来完成的。&lt;/p&gt;

&lt;p&gt;我们可以设想整个地图就是一个大的矩形，地图中每个方块是这个大矩形中的一个格子，而每个格子都由2个三角形构成，既然我们能计算出每个方块的位置，我们就能计算每个三角的顶点和位置。&lt;/p&gt;

&lt;p&gt;我们知道的是，整个地图有多大，也就是这个大矩形在什么位置、有多大，每个方块矩形有多大，也就是每个格子有多大。我们知道有多少格子，有多大的格子，就能计算出，总共有多少个顶点，每个顶点的位置在什么地方，也就能知道三角形该怎么拼接了。&lt;/p&gt;

&lt;p&gt;简单得说，地图是一个大矩形，横切竖切N刀，成了一个个大小一样的小矩形或者正方形，这种有规则、大小一样、位置可寻的网格，是可以通过程序生成的。&lt;/p&gt;

&lt;p&gt;我们利用三角形的拼接方式拼接完矩形，再把地图方块的UV接上去，因为每块地形的图都不一样，所以我们需要在离线时就把所有的地形图都拼成一张图，即以图集的方式存储地图的方块。当我们将图接到网格上时，我们需要将指定的方块图的UV数值赋值给顶点，对每个方块里的2个三角形做UV设置处理，让图集中的方块图显示在网格中。&lt;/p&gt;

&lt;p&gt;伪代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;//生成地图&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Generate_map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//遍历每块矩形的方块位置&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width_count&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height_count&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;generate_trangle_by_rectangle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texture_info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;CombineAdd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;//生成矩形方块所需要的，4个顶点，4个索引，2个三角形，2个三角形的顶点索引，以及三角形的uv位置。&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;generate_trangle_by_rectangle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texture_info&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//矩形的4个顶点&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;//顶点增加后的索引位置&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point_index1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point_index2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point_index3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point_index4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;//三角形的生成时的顶点&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;trangle1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;trangle2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;//三角形顶点的索引信息&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;trangle_index1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point_index1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point_index2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point_index3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;trangle_index2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point_index3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point_index4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point_index1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;//4个uv点位的信息&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point_uv1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uv_x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uv_y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point_uv2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uv_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uv_y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point_uv3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uv_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uv_y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;point_uv4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uv_x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uv_y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;Mesh&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Mesh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;trangles&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trangle1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tangle2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;trangles_index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trangle_index1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trangle_index2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uvs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;point_uv1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point_uv2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point_uv3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point_uv4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码中，对所有地图中的方块都进行遍历，在遍历中生成了每个方块所需要的顶点，顶点索引，uv点，进而生成三角形，三角形的索引。在生成完毕后，将这些生成的数据，与前面生成的数据进行合并，使得整个地图是一个一体化的网格，只产生一个drawcall。&lt;/p&gt;

&lt;p&gt;用程序拼接地图的好处是可以任意的通过地图编辑器来改变地形地貌，拼接完成的地图在渲染上的代价也相当的小，而且假如想换个地图的地形，只要更换贴图就可以了，什么样的贴图就可以产生什么样的地图。&lt;/p&gt;

&lt;p&gt;不过同时也带来了很多弊端，必须要有成形的地图编辑器支撑，前期工具的工作量比较大，稍微提高了点门槛，并且地图元素仅限于贴图中的元素，当地图元素增加到一定范围，就要扩大地图的贴图时就要重新排列地图信息。这一连套的工具链包括地图编辑器是必要的前提条件。&lt;/p&gt;

&lt;h6&gt;3D RPG角色扮演类游戏中，也时常常使用这种技巧来绘制游戏地图，曾经在日本风靡一时的《白猫计划》就是这样做的。&lt;/h6&gt;

&lt;p&gt;这种程序拼合的地图，策划设计师、关卡设计师可以在地图编辑器上，任意的绘制、拼接、同种类型的不同样式的地图（即在同一张贴图内容中的模型和地图元素），因此大大缩短了大量的场景试错时间。它能大量的生成出不同样式的地图，而不需要制作大量的不同类型的3D模型，大大缩短了项目时间进度，深受游戏制作人的喜爱。&lt;/p&gt;

&lt;p&gt;那么在3D地图中是怎么拼接方块地形的呢？看上去比2D更加复杂的事情，其实更加简单。&lt;/p&gt;

&lt;p&gt;首先，在3D地形模型制作时需要制定一下模型的规范。&lt;/p&gt;

&lt;p&gt;3D模型的长宽必须和地图切割后的方块长宽是一致的。3D地图中，不需要我们自己来拼接三角形了，因为已经有了固定的地形模型，但对每个地形模型就需要有规范。假如规定每块地形都是 1 x 1，那么在制作和拆分地形模型时就要按规定来，每个3D地形模型都必须以 1 x 1 的标准来定制，否则不可用。当然并不一定要 1 x 1，也可以是2 x 2、 3 x 3等等，只是当标准制定完毕后，地形模型的制作必须要按照标准来做，每个元素都相当于一个地图块。&lt;/p&gt;

&lt;p&gt;其次，所有地形模型的纹理贴图都必须并在一张贴图上制作。因为只有这样才能在合并模型才能合并，并且在合并后让这么多 1 x 1 的小方块只需要1个drawcall渲染调用就可以了绘制所有的地图。也只有这样，才能解决太多模型需要渲染导致的爆量drawcall问题。&lt;/p&gt;

&lt;p&gt;然后，在3D地形模型制作时也是需要相当的考量的，因为这个地图都被拆分成了N种类型的地形方块，所以在制作的初期需要对整个地形有哪些类型的需求，需要有一个设计、交流、探讨、决策、改进的过程。&lt;/p&gt;

&lt;p&gt;并且在读取地图编辑器编辑的数据后，实例化场景地图时也需要增加些许逻辑，这些逻辑是为了适应更好的模型拼合，比如当左边是某个模型时，为了能与它完美的拼接，当前这个格子上的模型必须是迎合它的那个，就像我们在制作和拆分城墙时那样，当城墙处于拐角处时，我们需要用拐角模型代替，还要判断它的左右前后有没有城墙，假设左边有城墙则应该选用带有连接左边城墙拐点的3D城墙模型，右边的、前面的、后面的、以及前后都有的，左右都有的，等等，总共9种情况都有不同的9种拐角城墙所代替，就是为了完美契合周围的环境而进行的额外的处理。&lt;/p&gt;

&lt;p&gt;最后的合并模型步骤就简单的多了，切分开来后的模型，按地图数据文件所描述的位置，放在指定的位置上，并向上面所说的选择好适配的模型，最后调用Unity3D的 Mesh.CombineMeshes 合并所有模型。&lt;/p&gt;

&lt;p&gt;在合并后可能发生衔接处的问题，用程序生成面片来补救很难做到完美的展示，我们还是建议调整3D模型在接缝处的面片与网格，只有这样才能调整出一个完美的或者说完全可掌控的地图造型。&lt;/p&gt;

&lt;h3&gt;常规场景的性能优化&lt;/h3&gt;

&lt;p&gt;上面几节阐述了地图的拼接方式，其中用程序拼接合并地图块的方式确实大大降低了 Drawcall 的数量，提升了渲染的性能，但只针对可拆分的地图类型项目，对大多数游戏类型来说地图是不可拆分成小块的。因此我们还是需要更多的针对常规场景讲解优化的方法和技巧。&lt;/p&gt;

&lt;p&gt;首先我们要清楚的是，是什么造成了场景的低渲染效率。我们在这里罗列一下主要的几个问题：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1.渲染面数太多，GPU压力太大。

    2.渲染管线调用次数太多，即drawcall太多，GPU排队渲染的队伍太长

    3.贴图太多太大，导致显存的带宽负荷太重

    4.动画太多，蒙皮的计算消耗的CPU太大

    5.实时光的GPU开销太大
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实还有很多很多问题需要解决，比如实时阴影导致的 Drawcall 太多，增大了渲染调用的排队长度，以及透贴太多，Overdraw 重绘问题比较严重，还有比如单个物体需要的Pass渲染太多，一个物体需要绘制多次才能完成等等。这些问题也是很重要的，但这节我们重点解决这最重要的5个问题。&lt;/p&gt;

&lt;h3&gt;1.渲染面数太多，GPU压力太大。&lt;/h3&gt;

&lt;p&gt;渲染面数太多分两种，一种是整个场景3D物体太多导致的面数多，一种是同屏展示的面数太多。&lt;/p&gt;

&lt;h6&gt;前一种Unity3D引擎会裁切掉在摄像头之外的物体，不让他们进入到渲染管线以减少消耗，虽然裁切也会消耗小部分CPU，但毕竟比起渲染整个物体要小的多。&lt;/h6&gt;

&lt;p&gt;在进入渲染管线前每个3D物体能计算出或者已经计算好了一个包围盒，即Bounds，这个包围盒由8个顶点组成，加上旋转矩阵就能计算出每个顶点是否在摄像头的锥形体范围内。&lt;/p&gt;

&lt;p&gt;裁切的算法简单说是这样的，如果有包围盒8个点中只要有一个点在锥形体内，就认为是需要渲染的不可被裁剪，如果8个顶点都不在摄像头的锥形体范围内，才认为是不需要被渲染的，然后Unity3D引擎会阻止这个模型渲染即在渲染调用前裁切掉。&lt;/p&gt;

&lt;p&gt;这种Unity3D引擎上的裁剪，帮助我们屏蔽掉了很多不需要渲染的物体，虽然裁剪也会花去些许CPU，但比起要绘制一个3D物体来说要少的多的多。&lt;/p&gt;

&lt;p&gt;这种裁剪的好处是，使得我们只要关心摄像头范围内的面片就可以了，但是如果是一个模型很大，或者常常我们项目中有合并的模型范围从南延伸到北贯穿整个场景，一旦这个模型很大，覆盖了整个场景，包围盒总有一段在摄像头内就不会被裁剪，这样就会浪费很多不必要的GPU计算。&lt;/p&gt;

&lt;p&gt;除了Unity3D引擎内的裁剪，OpenGL即渲染管线也会对每个三角形进行裁剪，不过三角形的裁剪要比8个顶点的包围盒裁剪要费的多。所以我们尽量还是能用包围盒裁剪就用包围盒裁剪方式，将更少的三角形面片带入渲染管线。&lt;/p&gt;

&lt;p&gt;传入渲染管线的所有三角形顶点管线对它们做的第一个动作就是裁剪，其次才是计算，网格根据摄像头锥形体进行裁剪，所有不在锥形体范围内的顶点都会被裁掉。但是这种裁切的效率比起8个顶点的包围盒效率要低得多。&lt;/p&gt;

&lt;p&gt;场景面数太多时，如果没有或者很少有这种从南到北的模型时，渲染的压力就取决于摄像头中可展示的物体的数量，但是如果单个模型通常会覆盖很多天南地北的网格，那么GPU对裁切计算的压力就会增大。&lt;/p&gt;

&lt;h6&gt;后一种同屏面数太多的情况，就是因为3D模型都在摄像头范围内，要么就是模型太多，要么就是模型面数太多，要么就是摄像头太远而显示距离太大造成的。&lt;/h6&gt;

&lt;p&gt;最简单直接的方法就是，拉近摄像头，或者拉近摄像头显示距离，让更少的模型进入视野内。当视野范围内的物体少了，需要渲染的模型面数也就少了，自然CPU和GPU的消耗也就少了。虽然这是最拙劣的办法，也是我们需要调整和调节的参数，让视线范围在一个合理的范围内。&lt;/p&gt;

&lt;p&gt;其次是减少模型面数，或者减少模型在场景中的数量，降低不必要的高品质。3D模型面数的降低，不是一两天就能完成的事，一个模型面数的降低也伴随着画面质量的降低，又要面数低又要品质高那是痴人做梦，所以我们找到一个平衡，也要制定一个容忍度，即前面几章提到的，要将模型面数在研发期间控制在一定范围内。模型数量在场景中的数量的降低，或者更直接的方式，去除了许许多多本来需要渲染的三角面，自然就省去了诸多CPU和GPU消耗，但也伴随着场景变得空旷不饱满不生动。&lt;/p&gt;

&lt;h6&gt;那么有没一种方法可以不更重制3D模型面数，不减少模型在场景里的数量，不缩短摄像头显示距离，也能优化性能的。有。&lt;/h6&gt;

&lt;p&gt;世上没有免费的午餐，想降低GPU的消耗，就得用增大内存来换。&lt;/p&gt;

&lt;p&gt;LOD，即Level of detail，就是此道。用内存换GPU。&lt;/p&gt;

&lt;p&gt;我们把每个3D模型，做成多个不同细节级别的模型，当摄像头拉远时，启用形状相似面数更少细节的模型，当摄像头拉近时，则启用形状相似面数更多细节的模型。&lt;/p&gt;

&lt;p&gt;这样即使众多的模型在摄像头范围内需要渲染，也只有几个模型在靠近摄像头的，而大部分都是远离摄像头的。&lt;/p&gt;

&lt;p&gt;远离摄像头的3D模型面数很少，即使数量众多，它们所展示的低等级的面数的总和也是可以接受的。&lt;/p&gt;

&lt;p&gt;我们常提到的 Mipmap 也是这种方式在运作，对于距离远的物体，启用更小的纹理贴图，而与摄像头距离近的物体则使用更大的纹理贴图。这样在渲染时就传送进渲染管线的贴图就更小了，宽带压力小了，GPU消耗自然少了。&lt;/p&gt;

&lt;p&gt;天下没有免费的午餐，提升了CPU和GPU的性能，就会增大内存的消耗，如果内存消耗太多也是得不偿失的，因此在考虑怎么分级、分多少级的细节级别上也需要一番考量，针对不同的项目分级的层数也是不同，拿大型MMORPG来说，那种可以在天上飞的游戏，看到的物体自然就很多，如果LOD分级少了画面则会显得突兀，而中小项目如果LOD分级太多，则加大了内存量和制作时间，得不偿失。&lt;/p&gt;

&lt;h3&gt;2.渲染管线太多，即 Drawcall 太多，渲染管线太多&lt;/h3&gt;

&lt;p&gt;除了面数带来的GPU计算压力，渲染管线太多也是造成GPU压力的一大问题。&lt;/p&gt;

&lt;p&gt;渲染管线太多的问题，大都是因为场景中的模型物体太多，或者使用的Shader中的管线太多，或者这两者同时造成的。&lt;/p&gt;

&lt;p&gt;其实这个问题是最好解决的，‘干掉’在场景中众多的模型物体，以及‘注释掉’Shader中不必要的管线。&lt;/p&gt;

&lt;p&gt;当然这是最粗暴的做法，无疑将美术设计师，场景设计师的辛勤工作的成果给抛弃了。但也不是不可为，适当的‘干掉’一部分不必要模型的其实是有助于场景制作的。&lt;/p&gt;

&lt;p&gt;那么我们能不能在不毁坏场景的前提下做些优化呢。可以的。&lt;/p&gt;

&lt;p&gt;关键点就在于‘合并’二字。&lt;/p&gt;

&lt;p&gt;为什么呢？因为一个屏幕内需要渲染的面片数量是一定的，即我们不减模型在场景中的数量，不减单个模型面数的情况下，一个画面上需要渲染的三角形面数是固定的数量。&lt;/p&gt;

&lt;p&gt;我们每次调用管线渲染（即drawcall）传给渲染管线的三角形数量却比较少，所以调用的次数比较多。&lt;/p&gt;

&lt;p&gt;我们能否合并这些面片数据，然后一次性得传递给管线，将原来需要很多次的管线调用变成一次，只有这样才能大大降低 Drawcall 的数量，降低渲染调用次数。&lt;/p&gt;

&lt;p&gt;那么减少渲染管线即减少 Drawcall 的数量究竟有什么好处？&lt;/p&gt;

&lt;p&gt;减少了渲染管线的数量，即降低了Drawcall的数量后，尽管并没有减少任何需要渲染的面片数量，只是每次传递给渲染管线的顶点和面片数增多了，传递的次数减少了，但是三角形数据进入渲染管线后，就可以开启GPU并行处理了，单行线变成了8车道甚至16车道单行线，速度加快8-16倍。&lt;/p&gt;

&lt;p&gt;原本调用一次渲染，就要在队列中等待管线渲染完毕后才进行下一次渲染，合并后就不同了。不再是像以前那样调用这么多次Drawcall，每次渲染一个画面时Drawcall的队伍都要排的老长老长的，都等在那排着队等待一个个的交给GPU处理，效率低下。&lt;/p&gt;

&lt;p&gt;合并后就不再是这样了，排队的数量少了，队伍短了，虽然每个排队的‘人’都很‘胖’（即数据量很多），但是一旦进入处理阶段，8-16条生产线并行处理这些数据，比前面排着老长得队伍一个个处理要来的高效的多。&lt;/p&gt;

&lt;p&gt;所以我们要想方设法的合并各种模型。怎么合并？&lt;/p&gt;

&lt;p&gt;其实Unity3D引擎自带有多种合批方式，前面几个章节有详细的介绍，这里我们简单提一下，Unity3D引擎中有动态合批、静态合批、GPU Instancing 三种合批方式，其中动态合批，合并的普通的模型，但要求比较高，包括模型面熟、Shader的Pass数等，静态合批也有自己的规则，它通过消耗的内存来换取CPU，而GPU Instancing 的原理是通过一次性传递更多的数据来达到合批Drawcall的目的。&lt;/p&gt;

&lt;p&gt;这里我们并不想通过Unity3D自动的方式来做‘合并’的操作，我们希望能够自己掌控‘合并’效率和效果。部分原因也是因为引擎自带的合批方式通常都是通用的合批方式，规则比较严格，合批率比较低。所以时常放弃它们而选择自己动手丰衣足食。&lt;/p&gt;

&lt;p&gt;‘合并’也分实时合并，与，非实时合并两种方法：&lt;/p&gt;

&lt;p&gt;其中实时合并也会消耗大量的CPU，因为它要读取多个模型，并创建新模型数据，不断的创建新模型数据，就会导致CPU的消耗。这里不再详细介绍，前面章节已经介绍过，这里简单点说一下，把相同材质球，相同贴图的模型，读取它们的模型数据，生成一个新的合并后的模型，然后隐藏原有的模型。如果很多模型材质球效果一样，但贴图不一样，我们可以在线下手动合并它们的贴图后再放到线上合并。&lt;/p&gt;

&lt;p&gt;非实时合并则全是线下的手动合并，即大家常说的静态合并。Unity3D静态批处理的规则比较严格，即要求相同材质球相同贴图还要形同模型，而且内存消耗比较大，因此我们还是建议使用自己手动合并的方式，即手动拼接场景中静态不动的、有相同材质球、相同贴图的模型，手动拼接成一个模型，也可以用插件来操作，比如 MeshBaker，通过 MeshBaker 来制作和合并模型与纹理贴图。&lt;/p&gt;

&lt;p&gt;静态合并Mesh的好处就是，游戏中不需要实时消耗CPU去合并模型，节省了不少CPU，也降低了很多Drawcall的数量。&lt;/p&gt;

&lt;p&gt;当然过犹不及么，如果把所有的在场景内的物体全部合成为一个模型，整个地图，无论摄像头能不能看到的地方都合并了，那么GPU的压力也同样很大，因为这样的话我们前面提到的引擎自身做的第一层包围盒裁剪就不生效了。渲染时会一股脑的将整个模型数据塞进渲染管线中，GPU在裁剪时的压力就会很大，因为它要裁剪整个地图的所有模型面片，计算量也是巨大的。&lt;/p&gt;

&lt;p&gt;因此我们在静态合并时也要适度，即合并周围距离不太远的、可以合并的模型。这样即减少 Drawcall 次数，也同时降低了GPU裁剪的压力。&lt;/p&gt;

&lt;h3&gt;3.贴图太多太大，显存的带宽负荷太重&lt;/h3&gt;

&lt;p&gt;贴图太多，宽带压力太大，导致的问题，主要是因为GPU在渲染时，需要将内存的纹理拷贝到显存中去才能使用在GPU中。所以拷贝的消耗和显存的消耗也是很大的。不过，显存只存在于主机和PC游戏中，在手机中没有显存的概念，只有内存，因此都是内存和内存的拷贝。&lt;/p&gt;

&lt;p&gt;在手机中只有内存与内存的拷贝，那么岂不是内存中的贴图纹理有两份？是的，如果引擎没有做额外处理的话，按照常理GPU的工作流程确实会是拷贝一份纹理到另外一段内存中，导致一份纹理占用了两份内存。但是毕竟引擎还是做了很多优化的，Unity3D就做了这方面的优化，当贴图没有勾选Read/Write 时Unity3D就认为该贴图是不会被改变的，当GPU需要该贴图时只是把原来在内存中的值传进去，而不是拷贝整个纹理，而当我们 勾选了 Read/Write 后Unity3D就认为该贴图是会被改变的，因此当GPU需要该贴图去渲染的时候，则会重新拷贝一份纹理贴图，这份纹理贴图专门给GPU渲染使用，避免GPU的纹理贴图随时被更改。&lt;/p&gt;

&lt;p&gt;因此我们在贴图设置时，首先要注意 Read/Write 选项是否需要被开启，绝大部分贴图是不需要被开启的，这些贴图被开启后造成的2倍内存也是不必要的。&lt;/p&gt;

&lt;p&gt;贴图太大太多，最好的办法是缩小贴图和压缩贴图。&lt;/p&gt;

&lt;p&gt;看起来挺简单的，其实我们在实际项目中，我们不可能随意的去缩小和压缩贴图，这样很容易导致项目因贴图质量太糟糕而影响画面效果。&lt;/p&gt;

&lt;p&gt;我们需要针对每个部分的贴图逐一去了解和设置，其实每个功能部分的贴图都有其用途。比如UI中的贴图分，图集和Icon图片，图集一般都是无损质量，因为要保障画面，也不需要 Mipmap采样，Icon图也是一样。虽然也不是不能压缩，不过压缩后确实UI的质量会遭到比较显著的降低，针对低端机时确实可以这样去做，因为无损的贴图在内存上和压缩的贴图通常有5-10倍的差距。&lt;/p&gt;

&lt;p&gt;又比如3D模型的贴图，这些模型纹理贴图，通常都是2的幂次存在，因为2的幂次的纹理在GPU中处理起来比较顺手，而他们也通常是可以压缩的，并且带有 Mipmap 采样生成标记的。要压缩多少，压缩到什么比例才适合，每个项目都不一样，因人而异，大部分时候我们都是指压缩到中位数即Normal Compress普通压缩。&lt;/p&gt;

&lt;p&gt;贴图的大小确实比较重要，每个项目在开始时都要好好的规范一下，因为只有遵守良好的规范，项目才能将内存限制在可控范围内。&lt;/p&gt;

&lt;p&gt;幸运的是，美术设计师无论将贴图做的多大，我们都可以在Unity3D里重新设置成我们需要的大小，Unity3D会将所有贴图都重新制作导出成用户指定大小的贴图和格式。因此即使前期贴图太大而导致的问题，也可以在Unity3D的项目中将贴图设置回我们想要的大小。&lt;/p&gt;

&lt;h3&gt;4.动画太多，蒙皮的计算量太大&lt;/h3&gt;

&lt;p&gt;动画确实是最令人头疼的，因为它是动态的，而且时时刻刻都是动态的，不像3D物件，虽然它们会出现消失，但大部分情况下还是静止不同的。而动画则不同，它们时时刻刻都在你眼前动来动去，即使不再屏幕上，大部分时候也需要一直保持动的状态。&lt;/p&gt;

&lt;p&gt;对于动画的优化，其实上几个章节中有讲的比较详细，这里只是简单的点一下。&lt;/p&gt;

&lt;p&gt;动画的消耗点最大的地方是CPU的蒙皮计算，如果有100个动画在屏幕中播放，由于每帧对蒙皮的计算都是全局性的，因此CPU会极大的消耗在蒙皮计算上。&lt;/p&gt;

&lt;p&gt;蒙皮计算，其实质就是骨骼与顶点的计算，骨骼动画用骨骼点去影响顶点，每帧都需要计算骨骼点与顶点的偏移、缩放与旋转。&lt;/p&gt;

&lt;p&gt;如果动画模型的顶点数量很多，骨骼数量很多，顶点关联着骨骼点，骨骼点影响着顶点，那么计算量就会很大，消耗的CPU自然就会很多。&lt;/p&gt;

&lt;p&gt;为了能节省计算量，我们可以减少顶点数，又或者减少骨骼点的数量，抑或两者都进行削减，就能使得CPU降低消耗。&lt;/p&gt;

&lt;p&gt;让3D模型设计师和动画师去减面和减动画骨骼，工作量毕竟是比较大的，涉及到所有3D模型和动画。在削减的时候还需要顾及画面，不能太糟糕，所以时间会比较长。这是我们程序无法控制的，我们能做的就是从程序上尽量的降低开销。&lt;/p&gt;

&lt;p&gt;由于每帧都要计算，所以很费CPU，如果能把计算好的每帧顶点偏移量存起来，播放的时候直接偏移过去就好了，于是就有了 Animation Instancing。它就是把所有动画文件中的数据都导出放入贴图中，由可编程的顶点着色器来完成顶点的偏移。这样我们就不需要计算了，在设置顶点的位置就可以了，省去了大量的CPU计算消耗。&lt;/p&gt;

&lt;p&gt;但是毕竟一个会动的模型，是无法合并Mesh，理论上说应该说每帧都合并一次对CPU消耗的代价太大，所以每个动画模型都需要至少一个Drawcall来支撑，如果Shader中有多个Pass管线，就有更多，比如描边，实时阴影等。&lt;/p&gt;

&lt;p&gt;假设有100个这样的动画，就需要至少100个Drawcall来支撑。消耗还是太大，能不能合并Drawcall，就像合并Mesh一样，相同的材质球合并成为一个Drawcall呢？&lt;/p&gt;

&lt;p&gt;Unity3D的 GPU Instancing 为我们提供了合并的可能。它可以合并相同材质球，相同模型的Drawcall。它原理是将多个模型的相同顶点，相同贴图，相同材质球，在不同位置的物体一次性提交给GPU，让它只绘制一次就能将所有物体都绘制在帧缓存中，进而体现在屏幕上。&lt;/p&gt;

&lt;p&gt;这种方式的条件虽然有点苛刻，但恰好能和 Animation Instancing 配合的很好，Animation Instancing 并没有改变3D模型，贴图，材质球，能与 GPU Instancing 能很好的结合，两者使用起来能减掉很多有用相同模型和材质球的动画物体，还能将计算蒙皮的CPU消耗省去，可以说是绝佳的搭档。&lt;/p&gt;

&lt;p&gt;与之相似的还有，另外一些场景中的草和树的摇动，我们可以用顶点动画和 GPU Instancing 结合来省去Drawcall和蒙皮计算的CPU消耗。&lt;/p&gt;

&lt;p&gt;其实和 Animation Instancing 一样的原来，只是草和树是纯顶点算法计算出来的摇动，而3D模型动画的 Animation Instancing 则是在离线下将动画数据导进纹理贴图中在顶点着色器中偏移顶点罢了。&lt;/p&gt;

&lt;p&gt;前者用了算法计算出顶点，而后者用纹理贴图当做数据载体直接偏移顶点。前者消耗了GPU来代替CPU计算，后者消耗了内存和少量GPU代替CPU，前者更加灵活但也受到算法的局限性，后者则死板一些但性能开销更少。各有利弊，在实际项目中也需要根据实际情况做选择和混用，我们在使用时应该衡量他们在项目中的限制和作用，尽量做最适合的选择。&lt;/p&gt;

&lt;h6&gt;5.实时光的GPU开销太大&lt;/h6&gt;

&lt;p&gt;烘培是解决实时灯光太多，GPU开销太大时比较好的解决手段。对于场景制作与优化，烘培是永远绕不过去的技巧，它能帮助我们省去很多灯光的实时开销，以及实时阴影的巨大开销。&lt;/p&gt;

&lt;p&gt;下一节我们就来专门来讲讲，烘培及其优化。&lt;/p&gt;
</description>
               <pubDate>Sat, 17 Aug 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/08/17/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E5%9C%B0%E5%9B%BE%E4%B8%8E%E5%AF%BB%E8%B7%AF4.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/08/17/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E5%9C%B0%E5%9B%BE%E4%B8%8E%E5%AF%BB%E8%B7%AF4.html</guid>
            </item>
        
            <item>
               <title>思路探讨(二十七) 如何应对30岁的躁动</title>
               <description>&lt;p&gt;&lt;img src=&quot;/assets/%E9%87%91%E8%9E%8D/idea-talk-27.jpeg&quot; alt=&quot;idea-talk 27&quot;&gt;&lt;/p&gt;

&lt;p&gt;最近对自己影响比较深的一段话。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;台风日没带电脑，只能在手机上打字。&lt;/p&gt;

&lt;p&gt;一整天只在小小房子里原地看看书，原地跑步。&lt;/p&gt;

&lt;p&gt;我依然坚持着自己独有一套理论，即，&lt;/p&gt;

&lt;p&gt;首先要想方设法每天都保持充沛的体力和旺盛的精力，即保持健身、正常的饮食、规律的作息。&lt;/p&gt;

&lt;p&gt;然后，每天必须看几页书以丰富自己的知识、看法、见解和视野，&lt;/p&gt;

&lt;p&gt;其他时间专注于工作，在工作中历练，在工作中积累经验和财富。&lt;/p&gt;

&lt;p&gt;无论处在什么样的状态下，开始努力都为时不晚。&lt;/p&gt;

&lt;p&gt;人只要一直努力下去，肯定比他不努力的强百倍。&lt;/p&gt;

&lt;h6&gt;“努力”应该被称为一种特质，是自驱力的体现，如果你拥有这种特质，总有一天你会发现，所有你所拥有的都因“努力”而得，不管你最终有没有成功，“努力”这两个字将成了你的优势。&lt;/h6&gt;

&lt;p&gt;最近难得平静下来能安安静静的度过一天。也可以梳理下最近的生活和工作。&lt;/p&gt;

&lt;p&gt;30几岁依然是躁动的年纪，只是相比于20几岁，更加让我们躁动的是事业和家庭，比起40几岁，30几岁的我们还不够沉稳，心力还不够强大，经受的狂风暴雨还不够多，这种局面是无法改变，只有我们熬过30岁来到了40岁时，回头看才会知道这一切就是个“轮回”，只是40几岁又有了新的烦恼和痛苦。60后下去了70后起来了，70后下去了80后起来了，80后下去了90后起来了，世界从没因任何人停止过潮汐潮落。我们所感受到的只是我们以自我为中心的视角所看到的和感受到的情景罢了，其实并非我们所想象的那样美好或者那样糟糕，世界就这样悄无声息又平静的路过你，我，他身边，继续向前。&lt;/p&gt;

&lt;h6&gt;如果说世界上有什么办法能够掌控未来，也只有“努力”，并且是持续的长时间的努力，也只有这样才能在下一个阶段来临前打好结实的基础。&lt;/h6&gt;

&lt;p&gt;当下一个阶段来临时，才有足够强的实力，足够多的经验，足够大的视野，足够强壮的身体应对更加复杂的局面。&lt;/p&gt;

&lt;p&gt;也只有我们在当前阶段持续不断的努力，才能在下一个阶段来临时拥有足够多的优势，到那时才能更加从容一点。&lt;/p&gt;

&lt;p&gt;但也同样的，我们会不断面临再下一个阶段的挑战，努力永远都不可能停下来，我们一生都是艰苦而又美好的。&lt;/p&gt;

&lt;h3&gt;我们在“努力”中寻找苦涩的快乐，在“汗水”中绽放疲惫的笑容。&lt;/h3&gt;

&lt;h3&gt;我们一起：苦中作乐&lt;/h3&gt;
</description>
               <pubDate>Sat, 10 Aug 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/08/10/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A827.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/08/10/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A827.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第十章，地图与寻路(三) 地图编辑器</title>
               <description>&lt;p&gt;对于任何游戏来说，地图与场景的是比较重要的，特别是对于中大型游戏来说，在地图和场景上花费的时间和精力占去了大部分。而对于大部分游戏类型来说，布置场景，优化场景，甚至为场景写个编辑器是必不可少的，我们通常称他们为‘地图编辑器’。&lt;/p&gt;

&lt;p&gt;地图编辑器有哪几种实现方式，该如何实现，顺便讲一讲从哪些方面下手优化场景，我们这节就来讲讲关于地图的事。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h3&gt;地图编辑器的基本功能&lt;/h3&gt;

&lt;p&gt;什么是地图编辑器？Unity3D本身的编辑器就是属于场景编辑器，但它没有达地图编辑器的功能，只是能添加场景，添加场景里的物件，移动，旋转，缩放模型物件而已，并不能帮助我们将这些物件变成自定义的具体数据然后存储下来成为文件。&lt;/p&gt;

&lt;p&gt;对于一张完整的地图来说，我们需要的是能生成一个包含地图中所有元素数据的文件，并且我们可以通过这个文件还原整个地图。&lt;/p&gt;

&lt;p&gt;这个文件不只是可以在视觉上还原地图，还要还原我们已经设定好的地图中的逻辑，包括碰撞的逻辑，触发逻辑，关卡逻辑，事件逻辑，以及游戏逻辑。&lt;/p&gt;

&lt;p&gt;说白了，为了能让地图还原成我们编辑的那个模式，并且可以继续持续的编辑，我们需要创造一个地图编辑器来完成这个功能。&lt;/p&gt;

&lt;p&gt;下面就让我们来说说地图编辑器是怎么实现的。&lt;/p&gt;

&lt;p&gt;地图的元素都是以坐标，旋转角度，缩放大小为基准形成的数据，大部分元素都是节点，模型，特效，因此大部分地图编辑器都需要有，元素的坐标，角度，缩放大小，至少有这三样的数据记录。其他的数据，也会有包括配置表ID，物件类型，范围大小，脚本名字等，是为了配合不同游戏系统的需要而构建的。&lt;/p&gt;

&lt;p&gt;即通常每个元素的数据为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    class map_unit
    {
        position, //坐标
        rotation, //旋转角度
        scale, //缩放
        type, //类型
        table_id, //配置表ID
        size, //大小
        function_name, //功能名
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中position, rotation, scale 是基础的数据类型，它记录了需要被展示在场景中的位置，角度，缩放大小。而其他的数据，例如 type 可以用来表示这个物件的类型，是人，是怪，是门，是机关，还是不会动的静态场景物件。&lt;/p&gt;

&lt;p&gt;而 talbe&lt;em&gt;id 可以用来表达这个前面这个 type 类型所对应的配置表ID，用这个 table&lt;/em&gt;id 可以映射到具体数据表里或者说Excel表里的某一行数据，因此各种type下的展示效果可以根据这个 talbe&lt;em&gt;id 的不同而不同，例如 怪物有很多种，每个talbe&lt;/em&gt;id 都代表了怪物表里的一种怪物，因此怪物的形状和怪物AI都可以用这个 table_id 映射。&lt;/p&gt;

&lt;p&gt;size 大小则可以认为是该物体所触发事件的一个范围，比如当角色进入5 * 5 这个size大小范围时将触发机关，或者触发剧情，或者触发任务，或者触发生成一堆怪物。&lt;/p&gt;

&lt;p&gt;function&lt;em&gt;name 一般都会指向某个功能性逻辑。当某个物件size范围内被触发时，功能性逻辑就执行操作，使用它的意图是通过它指向的是某个具体的功能，因为每个物件都有可能具有不同类型的操作指令，因此指令可能是纷繁复杂的。 例如，function&lt;/em&gt;name里填上make&lt;em&gt;new&lt;/em&gt;task 可以定义为，触发时制造新的任务，或者 play&lt;em&gt;animation 触发时播放某个动画，或者 generate&lt;/em&gt;master 生成一堆怪物等等诸如此类。 &lt;/p&gt;

&lt;p&gt;有了数据就需要对数据保存和读取，包括地图数据文件的保存和读取，这两个是最基本的功能。&lt;/p&gt;

&lt;h3&gt;数据协议格式在编辑器中应用的选择&lt;/h3&gt;

&lt;p&gt;关于数据的存储与解析，我们在前面的数据协议章节中专门做了详细讲解，这里我们做一些应用，该怎么选择地图数据的数据格式和存储协议。各类协议在这里也能体现其不同的优势。&lt;/p&gt;

&lt;p&gt;我们把数据都存储到文件中，存储数据就需要格式，我们选定一种协议格式来存储后，就得用相同的协议读取，假设我们用最方便的Json协议格式存储所有数据，并放入文件中，那么我们在读取数据的时候也需要从Json数据中解析出每个元素存储到内存中。&lt;/p&gt;

&lt;p&gt;假设说我们在众多协议中选择了使用Json协议，我们选择Json协议的意义是什么呢，乍一眼看来Json占用的空间又大，解析又慢，导致很多人都摒弃它，这样的情况下我们为什么还用它。肯定是因为简单，快速，易上手，只要有一点点编程知识的人都知道Json的格式，即使不知道也只需要花几分钟就能明白其原理，这对于众多新手来说是适合的门槛线，他们能快速上手快速融入团队。这种团队执行效率，对于一些技术力量参差不齐的团队（资深只有1，2个，其他都是新人）来说是好的选择，大家能很容易达成一个比较高的共识，协作起来也没有太多障碍。&lt;/p&gt;

&lt;p&gt;我们可不要小看达成共识的好处，我们必须认识到我们独自一个人是完不成任务的，这一点很多人虽然清楚明白，但实际中总是犯个人主义的毛病，忍不住靠自己，而不是靠团队，最后事情太多弄得自己手忙脚乱。产品要靠大家一起完成每个人都出尽所有的本事而非一个英雄搞定一切，团队在协作时没有共识或者共识比较差，将发生许许多多怪异的问题，最终都会导致团队执行效率下降，产品的质量降低。假设有一种解决方案能让团队所有成员都能达成共识，即使这种解决方案的效率并不高，在团队执行效率面前我们都需要重点考虑一下。&lt;/p&gt;

&lt;p&gt;有很多协议比Json空间占用小，解析快，效率高，自定义格式的数据协议就是其中一种，那么我们为什么又非要抛弃Json来使用自定义格式的数据协议呢？&lt;/p&gt;

&lt;p&gt;假设说我们使用自定义格式的协议，把每个变量都转换成byte流形式存储，这种形式的存储是最能掌控的，也是最能够节省空间的。因此用自定义协议做存储格式的人，可能非常想要掌控这个存储过程，而不想让其他第三方的插件干扰。不过，自定义协议在使用时也有很大的缺陷，当数据格式变化时，对变化协议格式的适应能力比较弱，虽然也不是没办法，但确实有点代价。&lt;/p&gt;

&lt;p&gt;代价是什么呢？代价就是要为每个版本的数据格式各自写一个完整的数据读取和存储的程序。每增加一个版本，为了维护旧的数据，都要在原有的数据解析的程序外，增加一个新的数据解析程序。就如下面的伪代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    void ReadData(io_stream)
    {
        version = io_stream.read_int();
        if( version == 1 )
        {
            Read_version1(io_stream);
        }
        else if(version == 2)
        {
            Read_version2(io_stream);
        }
    }

    voi Read_version(io_stream)
    {
        id = io_stream.read_int();
        level = io_stream.read_int();
    }

    voi Read_version(io_stream)
    {
        id = io_stream.read_int();
        name = io_stream.read_str();
        gold = io_stream.read_int();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码中读取数据时考虑了多种版本的兼容，使用了不同函数应对不同版本的办法，为每个版本写一个特有的读取顺序，在读取开头，用一个int元素来代表是应该使用哪个版本来读取数据，得到数据版本号后就能对应到不同版本的读取方法。&lt;/p&gt;

&lt;p&gt;自定义方式确实压缩了数据，提高了效率，但也同时增加了维护的复杂度，而Proto Buffer就没有这样的缺点。&lt;/p&gt;

&lt;p&gt;再假设说，我们使用Proto Buffer协议来作为存储格式，原本自定义协议的弊端被大大的削减，即使是数据格式升级和改变，都能轻松的应对，确实是一个比较好的选择，协议数据小，解析速度快，协议升级方便。&lt;/p&gt;

&lt;p&gt;但不要忘了，在看似优秀的协议下的同时我们也被被束缚在了Proto Buffer里，即不得不依赖于Proto Buffer。在未来假设的某一天，我们需要使用其他工具或语言来读取数据文件时，必须被要求使用Proto Buffer来得到数据格式的转换。其实，Proto Buffer在学习门槛上也提高了不少，对于新手来说理解Proto Buffer并使用，虽然我们自己并不觉得有多大的难度，但对于新人来说可是个大门槛，在他们的角度上看，Json是比Proto Buffer更适合。&lt;/p&gt;

&lt;p&gt;上面是我们在编写和创作地图编辑器中对数据部分的了解，接下来我们来看看地图数据对整个游戏的作用。&lt;/p&gt;

&lt;h3&gt;地图编辑器所带来的加载方式的改变&lt;/h3&gt;

&lt;p&gt;我们说地图编辑器主要的作用是将场景地图的编辑功能和地图数据再利用功能结合起来，让可视化的地图编辑器更多的帮助策划设计者或者场景美术人员编辑他们觉得更好看，更舒适，更绚丽的场景地图，并且这些编辑完的场景能随时保存成游戏中需要的数据格式。&lt;/p&gt;

&lt;p&gt;也正因为有了地图数据，我们才能在游戏中正确的还原原本编辑好的地图场景，而且在加载地图时有更明确的目标。&lt;/p&gt;

&lt;p&gt;其中数据到场景的还原是通过加载的方式进行的，这里我们不得不说一下地图的加载形式。地图加载的形式有三种，我们可以选择一次性加载全部地图（即阻塞式的加载所有地图元素），也可以选择流式的动态加载，也可以选择按需分批加载地图中的元素模型。&lt;/p&gt;

&lt;p&gt;一次性加载显然是最容易和方便的，只要把所有数据读取进来，针对每个元素的数据，加载它所指定的模型或效果到指定的位置，并设置旋转和缩放，再对挂上对应的脚本如果需要的话。&lt;/p&gt;

&lt;p&gt;一次性加载这么容易和方便，我们有时可以完全不需要地图编辑器，一个prefab搞定整个场景。这样说来话为什么还需要地图编辑器？&lt;/p&gt;

&lt;p&gt;随着功能和需要的扩大，当游戏开始时，很多物件并不需要加载到场景中，而是根据个人玩家的游戏进度来判断是否需要加载。这时如果还是按一个prefab搞定一个场景，一下子把所有物件都加载进来，内存势必浪费很多，这是我们不希望看到的。在一次性加载地图的方式中，地图编辑器就能帮助我们根据需要加载物件，帮助我们节省不必要的开销。&lt;/p&gt;

&lt;p&gt;然后，游戏越做越大，场景不断扩大，场景中物体的种类和数量越来越多，一次性加载需要消耗的CPU和时间也越来越大。原本只要加载几个面片当做地形的prefab，发展成了带有众多山，路，草，石头，路，桥，人，房子等的一整个大场景。这时，即使是按需加载也可能会在加载整个场景的阻塞中卡住很长时间，体验越来越差。流式加载就在这时体现了更加好的体验。&lt;/p&gt;

&lt;p&gt;根据地图编辑器的数据，进行流式的动态加载，让人能有逐步出现的视觉体验，而不是画面卡住的糟糕体验。这里不深入扩展开去说明如何使用Unity3D的API做流式加载，而是将这些内容放“资源加载的多种方式”的章节中进行讲解。&lt;/p&gt;

&lt;p&gt;流式加载缓解了瞬间的CPU消耗，把CPU消耗按时间平摊开来了，所以画面看起来不那么硬板。但是还不够，RPG的大世界中少有切换场景的时候，大都是整个地图无缝连接，这样才能体会到真实世界无缝的行走和旅行的体验。随着地图的继续扩大，整个世界都被容纳进了地图，我们不可能把整个世界都加载进内存里，因此分块分批加载成了最迫切的需求。&lt;/p&gt;

&lt;p&gt;分批和分块的方法其实很多，比如可以用距离来判断加载和卸载的内容，这里我们介绍一个比较常用的方法，即九宫格分块加载方式。&lt;/p&gt;

&lt;p&gt;我们可以把一整个世界横竖切N和M刀，这样就有了分成 (N+1) * (M+1) 个块，每个块之间的地形也是被拆分开来的，因此可以说每块都是独立的，完全可以被独立加载或独立卸载。&lt;/p&gt;

&lt;p&gt;在游戏场景中，其实我们只能看到一部分的画面，即周围的800-1200米范围内的画面，越远的地形和风景意义越来越少，因此当前在所的分割块，加上周围的八个分割块足以能展示我们需要的画面，即九块的地图内容足以成为我们展示的画面内容。即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [-][-][-][-][-][-][-]
    [-][-][-][-][-][-][-]
    [-][-][2][2][2][-][-]
    [-][-][2][1][2][-][-]
    [-][-][2][2][2][-][-]
    [-][-][-][-][-][-][-]
    [-][-][-][-][-][-][-]
    [-][-][-][-][-][-][-]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中1为角色所在的地图块，2位周围8块已经被加载进来的地图内容。&lt;/p&gt;

&lt;p&gt;我们的角色不断向前行进，穿越了我们当前的地图块的边界，进入了另一个地图块，这时九块内容发生了变化，以我们角色为中心点的地图块周围的八块与原先我们所在的八块内容发生了变化。我们需要加载周围八块内容中，没有被加载进来的那三块内容，即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [-][-][-][-][-][-][-]
    [-][-][-][-][-][-][-]
    [-][3][2][2][2][-][-]
    [-][3][1][1][2][-][-]
    [-][3][2][2][2][-][-]
    [-][-][-][-][-][-][-]
    [-][-][-][-][-][-][-]
    [-][-][-][-][-][-][-]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中1为角色所在块，向前进了1块，原来所在的地块不再是角色的中心块了，转移到了新的地图块，那么周围的8块地图的也发生了变化。&lt;/p&gt;

&lt;p&gt;我们必须加载新的地图块，来确保我们展示的内容是完整的，即标记为3的内容块，并且我们还需要卸载被废弃的三块内容，即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [-][-][-][-][-][-][-]
    [-][-][-][-][-][-][-]
    [-][3][3][3][2][-][-]
    [-][3][1][3][2][-][-]
    [-][3][3][3][2][-][-]
    [-][-][-][-][-][-][-]
    [-][-][-][-][-][-][-]
    [-][-][-][-][-][-][-]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中标记为2的内容块是被废弃的内容块，是需要我们卸载的内容块，卸载不必要的内存贴图，模型等数据。&lt;/p&gt;

&lt;p&gt;根据九宫格的加载和卸载规则，角色不断前进或后退，不同方向上的前进或者后退，不断的跨越不同区块的内容，地图模块不断的加载需要的地图内容块并卸载不需要的内容块，角色能始终看到完整的地图内容，而不需要大量的内存支持，因为我们在不断的卸载那些不需要的地图块。&lt;/p&gt;

&lt;p&gt;当然，我们可以把它划分的更细致一些，将地图分的更细，然后再采用25宫格，49宫格等等，在玩家不断行走的同时，加载那些进入范围内的地图模型，而舍弃那些离开我们的地图方块。&lt;/p&gt;

&lt;p&gt;我们也可以将一次性加载和流式加载结合使用，在加载地图块时，把最关键部分一次性阻塞式的加载，比如地形和碰撞体，而其他的物件则用流式加载方式，使得加载不会瞬间消耗大量CPU，平滑的过度到加载完整个场景，所带来的游戏体验将是绝佳的。&lt;/p&gt;
</description>
               <pubDate>Mon, 05 Aug 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/08/05/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E5%9C%B0%E5%9B%BE%E4%B8%8E%E5%AF%BB%E8%B7%AF3.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/08/05/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E5%9C%B0%E5%9B%BE%E4%B8%8E%E5%AF%BB%E8%B7%AF3.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第十章，地图与寻路(二) 寻路网格的构建</title>
               <description>&lt;h3&gt;寻路网格构建&lt;/h3&gt;

&lt;p&gt;上一节我们了解了A星寻路的算法及其优化，A星寻路只是算法，需要配套的模块和工具链支撑，单独的一个A星无法运作因为它只是一个算法。&lt;/p&gt;

&lt;p&gt;需要什么样的模块和工具链呢，我们这节就来讲一讲，最重要的配套模块‘寻路网格构建’。除了网格构建外，还有动态障碍物，以及地图和地形的构建，最后再配上A星寻路，才形成最终的地图和寻路。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h6&gt;1.用二维数组构建虚拟的方形网格&lt;/h6&gt;

&lt;p&gt;最最简单的也是最最易于理解的网格构建方式要属二维数组网格，它是一个二维数组，每个元素就代表一个方格，方格中数字0代表无障碍，1代表有障碍，或者也可以是数字1代表障碍难度为1，比1大的数字代表更高的障碍难度，数字越大障碍难度越大，到达某个数字比如999，则认为该障碍难度完全无法跨越。&lt;/p&gt;

&lt;p&gt;举个二维网格的例子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    [0][0][0][0][0][0]
    [1][1][0][0][1][1]
    [1][1][0][1][1][1]
    [0][1][0][0][1][1]
    [0][0][0][1][1][1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一个 5 * 6 的二维数组，0代表无障碍，1代表有障碍。我们很清晰的看到这张地图中有哪些是障碍点，在这张地图中，我们从任意一个无障碍点出发都能到达任意一个无障碍点，因为所有的0都是联通的。&lt;/p&gt;

&lt;p&gt;用二维数组代表地图是比较抽象的，那么怎么和地图匹配，怎么与地图真正的关联起来呢？&lt;/p&gt;

&lt;p&gt;我们在脑海中需要把地图也切成 5 * 6 这样30块地，比如这个张地图总共大小为 50米 * 60米 的大小，假如左下角为[0,0]位置，我们从0，0点开始，10，10点到0，0点为一个方块与[0,0]这个点关联，坐标10，10到坐标20，20为一个方块与[1,1]这个点关联，0，10点开始，10，20点到0，10点的方块与[0,1]这个点关联，依次类推。&lt;/p&gt;

&lt;p&gt;每个在地图上的10 * 10大小的一个块正方形的区域，都与数组关联。这样我们在用A星寻路在数组中寻路后的结果都可以一一对应到地图上。&lt;/p&gt;

&lt;p&gt;比如，我们寻路到从[0,0]点开始，到[1,4]点的路径为，[0,0]-&amp;gt;[1,0]-&amp;gt;[2,0]-&amp;gt;[2,1]-&amp;gt;[2,2]-&amp;gt;[2,3]-&amp;gt;[2,4]-&amp;gt;[1,4]，反应到地图上时，是0，0点开始移动，先移动到第一个方块也就是(0,0)到(10,10)这个方块的中点，也就是坐标(5,5)的点位上，再移动到(10,0)与(20，10)这个方块区域的中点上，即(15,5)坐标点位上，再移动到(20,0)与(30,10)这个方块区域的中点上，即(25,5)坐标点位上，依次类推，直到移动到最后一个点位，即(10,40)与(20,50)这个方块区域的中点上，即(15,45)这个坐标上，到达终点。&lt;/p&gt;

&lt;p&gt;因此A星寻路结束后，给出了[0,0]-&amp;gt;[1,0]-&amp;gt;[2,0]-&amp;gt;[2,1]-&amp;gt;[2,2]-&amp;gt;[2,3]-&amp;gt;[2,4]-&amp;gt;[1,4]，即数组上的坐标路径，在实际地图中则移动的路径为(5,5)-&amp;gt;(15,5)-&amp;gt;(25,5)-&amp;gt;(25,15)-&amp;gt;(25,25)-&amp;gt;(25,35)-&amp;gt;(25,45)-&amp;gt;(15,45)的坐标点位顺序。&lt;/p&gt;

&lt;p&gt;相当于把整个地图想象成一个矩形，把矩形横切N刀，竖切N刀，成了一个与二维数组匹配的方块地图，每个方块与数组中的一个元素相关联，当我们使用A星算法从数组中算出一个具体的路径时，可以根据这个数组中的路径，来匹配地图上的点位，即方块的中点。&lt;/p&gt;

&lt;p&gt;如果这个地图很大，但数组的大小很小，就无法实现细腻的碰撞体，所以我们需要在内存占用量与地图寻路细节之间权衡，即多大的数组与当前的地图才能匹配的更好，数组不能过大，因为过大的数组会造成内存的浪费，又不能过小，因为过小的数组使得地图的障碍细节无法得到完美的体现。所以我们在决定数组多少的时候，需要考虑的是整个地图的大小，以及最小障碍物为多大，来决策究竟需要用多大的数组。&lt;/p&gt;

&lt;p&gt;这些切割与关联都是由我们的脑袋想象出来的，过于抽象，毕竟我们在做游戏项目的时候，抽象的东西如果无法可视化的话，就会变得难以运用，至少是难以灵活的编辑和扩展。&lt;/p&gt;

&lt;p&gt;那么如何将这个抽象的方块可视化呢，最简单的方法就是用Excel方式，建立一个Excel，在Excel表中填入一个与数组相等大小的矩形方格块，在方格内填入颜色与数字，绿色代表可行区域，并填入0，红色代表不可行区域，并填入1。这样在Excel内就可以设置地图的障碍物，以及障碍物的大小，一眼就能知道，因为那些标记为红色的方格是障碍物，那里是不可通行的，那些标记绿色的地方为空地，那地方是可通行的，整个地图下来哪些地方不可通行，哪些地方可通行，一目了然。最后我们把这个Excel里的数据导出到文件，再在游戏开始时读取文件中的数据，得到地图的二维数组的障碍数据。&lt;/p&gt;

&lt;p&gt;除了Excel，我们还可以使用UnityEditor UI编写的地图编辑窗口，把地图大小，方格大小，障碍物等以可视化的形式放在 UnityEditor UI编辑窗口中，并编写保存数据到文件，和从文件读取地图数据的功能和按钮，这样一个地图编辑窗口就能更形象的体现地图的元素。&lt;/p&gt;

&lt;p&gt;如果这种可视化还不够，就得在具体的3D场景中的地图上做文章，把具体的整个地图加载并渲染在画面上，然后在地图上用颜色方块的方式画出不同颜色的块状，以具体地图为背景，来编辑地图障碍还是可通行块。当然这也带来更加多的编写和维护工作，但也同时是非常值得的可视化网格编辑器。&lt;/p&gt;

&lt;p&gt;如果嫌做一个地图编辑器作为可视化太麻烦，也可以用类似地形贴图的形式来做为可行走点的依据。用一整张1024 * 1024图代表一整个地形的大小，或者也可以为 2048 * 256等不同需求规格的大小，每个像素点代表二维数组的一个元素，比如白色为可行走区域，黑色为不可行走区域，那么这张图就可以压缩成只有R通道的8比特的图，图片像素中0就是黑色，1就是白色，或者加入更多元素2就是泥潭，3就是沼泽等等，这样就可以用图片代替了Excel的数据。当需要加载二维数组作为可行走数据时，则加载该图片读取像素中的每个元素录入到内存中，然后就可以依据内存中的二维数组来判定是否是可行走区域，以及相邻的格子是否是障碍物的判断。&lt;/p&gt;

&lt;p&gt;由于一维数组在分配内存块时的紧凑度往往比二维数组要来的好，用一维数组来读取索引中的数值会更加的快，因此我们常常使用一维数组来代替二维数组，在调用索引时也只是多了一个简单的乘法和加法的操作，即 二维数组 [a, b] 等于 一维数组 [a * width + b]，这样一来只是消耗很小的CPU就能在一维数组中索引到数值，而不再需要内存地址的跳转。&lt;/p&gt;

&lt;h3&gt;2.用路点系统构建寻路路线图&lt;/h3&gt;

&lt;p&gt;用二维数组的方式来构建寻路的基础数据有一定的局限性。当场景特别大，我们就要存储特别大的一个数组，编辑场景的工作量也有所提高，如果一个2048 * 2048 的数组的场景，我们要把所有的障碍点都设置一遍工作量比较大。&lt;/p&gt;

&lt;p&gt;除了数组太大和需要编辑的工作量扩大外，二维数组下的寻路路径最多是8方向的，上，下，左，右，左上，左下，右上，右下，寻路后的行走时会比较不真实，感觉是直来直去行走方向，要么90度方向行走，要么180度方向行走，要么45度方向行走，没有其他角度的行走姿势，让人感觉不真实，在像素游戏上还感觉不出什么来，但在3D地形中则会感觉明显的怪异。&lt;/p&gt;

&lt;p&gt;路点系统弥补了一些二维数组形式的缺点。路点系统也是一个易于理解的系统，它由很多个点构成，这些点我们称它们为路点，即路上的点，这些路点需要我们手动在地图上放进去，每个路点中都存储了坐标，ID，以及与哪些路点相连的数据。&lt;/p&gt;

&lt;p&gt;我们在地图中，放入了很多个路点，并且为这些路点配置了连线，于是就有了这幅画面：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    图片暂时脑补
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;地图中每个路点都会有与其他某些路点相连接的线，我们可以称它们为路线，由路点与路点之间连线而成。&lt;/p&gt;

&lt;p&gt;如果把地图里的路点和路线铺设的更加复杂一点时，所有的点和线都拼成了一张网：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    图片暂时脑补
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这张网中，只要我们得到某个点，就能根据这些路点和路线，用A星的算法来寻路到目的地。即，起点为，与起点最近的路点，寻路到，与终点最近的路点，的一条路径。如图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    图片暂时脑补
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;路点系统很容易理解，但也需要一些可视化的编辑器的支撑，因为所有的路点都需要在既有的地图上编辑，所以编写一个专门的地图编辑器是必不可少的，没有地图编辑器至少也需要路点编辑器，可保存路点数据到文件，和从文件加载路点数据，以及增加路点，减少路点，添加和减少路点连接信息。&lt;/p&gt;

&lt;p&gt;路点系统的缺点也是比较严重的，它任然需要大量的工作量来编辑可寻路的路点信息与连线。另外，它的寻路方式无法识别碰撞而只能用路点的形式来绕过障碍。&lt;/p&gt;

&lt;p&gt;当在大块空地上做寻路时，需要在这个大块空地上手动添加很多的路点，才能平滑的适应各种寻路，虽然没什么难度，但对人来说重复的工作量比较大。&lt;/p&gt;

&lt;h3&gt;3.平面三角形网格的构建 -- Navigation Mesh&lt;/h3&gt;

&lt;p&gt;路点系统虽然直观，门槛低，上手简单，而且一般情况下路点的数量相对比其他方式的网格少很多，因此内存消耗和CPU消耗都比较少。但是人工手动的重复工作量比较大，更糟糕的是它无法识别障碍区域，行走的路线也依赖路点之间的连线。&lt;/p&gt;

&lt;p&gt;三角形网格就很好的解决了路点系统的缺陷，三角形网格是用生成算法自动生成的网格，无需手动编辑，而且还能识别障碍区域。&lt;/p&gt;

&lt;p&gt;Navmesh(即 Navigation mesh)是最耳熟能详的寻路解决方案，其实质是三角形网格生成算法 + 多边形之间的合并与裁切算法 + 寻路算法（A星算法 或 射线算法），这个解决方案在2D和3D游戏上的都得到了普遍使用。&lt;/p&gt;

&lt;p&gt;尽管Unity3D提供了内置的Navmesh寻路插件，以及Unity3D的Asset Store里也提供了众多的类似的不同种类的插件，但如果我们只是停留在插件使用的表层上，无法更深入理解到原理与底层的算法，那么我们在决策和定制寻路解决方案时仍然将始终无法得心应手，当遇到难题或瓶颈时也无法得到彻底有效的解决。&lt;/p&gt;

&lt;p&gt;三角形网格是怎么生成的呢，这个问题在计算机图形学里叫做 “平面多边形的三角剖分问题”，意思是说“怎么将一个平面多边形分解为由许多三角形组成的多边形”。&lt;/p&gt;

&lt;p&gt;平面多边形的三角形剖分问题是计算几何研究的一个基本问题，它广泛应用于模式识别、图像处理、计算机图形学以及机器人领域。一方面，三角形作为最简单的平面图形，较其他平面图形在计算机表示、分析及处理时方便得多；另一方面，三角剖分是研究其他许多问题的前提。&lt;/p&gt;

&lt;p&gt;其中Delaunay三角剖分算法是一种三角剖分的标准，实现它有多种算法。这些算法都是基于已经拥有多个点位的数据之上来建立一个三角形网格的。&lt;/p&gt;

&lt;p&gt;Delaunay三角剖分有其特点，剖分后的多边形里的三角形必须满足：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1.除了端点，三角形的边不包含其他任何点。

    2.除了在点上的连接，没有任何一条边是相交的。

    3.所有的面都是三角形，且所有三角形的合集是所有点集合的凸包。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一、二点很好理解，要求三角形的边上没有任何其他点，以及没有任何一条边有中间斩断式的相交情况，但最后一点说的是凸包，说明Delaunay三角剖分算法只适用于凸包形式的三角剖分。但实际情况时，凹形区域占到了大量的面积和数量。&lt;/p&gt;

&lt;p&gt;实际中我们需要的不只是凸多边形和凹多边形的三角形剖分，也需要考虑凹凸多边形中含有‘洞’(即不规则多边形阻挡物)的情况，甚至还有更复杂的‘洞’中有孤岛的情况，因此单单是凸多边形的三角形剖分不能满足我们实际的需求。&lt;/p&gt;

&lt;p&gt;2002年 David Eberly 在《Triangulation by Ear Clipping》论文中提出了用切耳法构建简单多边形的三角化。&lt;/p&gt;

&lt;h6&gt;什么是简单多边形呢，简单多边形是，所有顶点都是顺时针或者逆时针排列的顶点，每个顶点只连接两条边，边与边之间没有交叉的多边形，就叫做简单多边形。&lt;/h6&gt;

&lt;h3&gt;切耳算法&lt;/h3&gt;

&lt;p&gt;Ear Clipping 切耳算法是一个简单实用的三角形分割算法，其步骤可以简单的分为三步：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    在解释三步骤之前，我们先解释下几个名词的意思。

    1.耳点，耳点的意思是，多边形中相邻的三个顶点V0,V1,V2形成的三角形里，不包含任何的其他顶点，并且如果V1点是凸点，即V0-V1的连线与V1-V2的连线之间形成的夹角小于180度，则认为V1是耳点。所以一个由4个顶点组成的多边形中，至少有2个耳点。

    2.耳朵三角形，三角形顶点中有耳点的就叫耳朵三角形。

    第一，找到一个耳点。

    第二，记录这个耳朵三角形，然后去掉这个耳朵点，在剩余的顶点中，继续回到第一步

    第三，直到剩下最后3个点形成一个三角形并记录下来，把所有记录的三角形拼接起来就形成了三角化网格。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经过这三个步骤的计算，所有的耳点都被切掉后，再把所有记录的三角形拼装成三角形网格，就完成了整个三角形剖分步骤。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    图片暂时脑补
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;多边形含‘洞’的情况&lt;/h6&gt;

&lt;p&gt;除了普通的简单多边形(包括凹凸多边形)的三角剖分外，如果简单多边形中有‘洞’的情况怎么办。论文中也给出了解决方案，即，依旧使用上述三步骤来做三角形剖分，只是剖分之前定把‘洞’并入外围的简单多边形，即：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1，用外围的简单多边形上的点，连接‘洞’的简单多边形，因此为了保持所有点的一致性，‘洞’必须是与外围的多边形的点的顺序是相反的。即外围如果是逆时针的顺序，‘洞’则需要顺时针的顺序。

    2，在连接处，产生两个一模一样的点，即连接点。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用这种方式来将‘洞’并入成为一个单独的简单多边形，如果有多个洞，则先并入的洞为，拥有x轴方向最大的点的‘洞’，依次并入。&lt;/p&gt;

&lt;p&gt;也就是说，最终计算的还是一个单独的简单多边形，只是在计算之前，将‘洞’以凹形形态并入最外围的简单多边形。&lt;/p&gt;

&lt;p&gt;我们以图为例，可以看的更加清楚一点：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    图片暂时脑补
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中展示了，如何将一个‘洞’以凹形形态的方式并入外围简单多边形的，就如同从外围简单多边形上，修了一条小小的通路到‘洞’中那样，其实我们完全可以理解为，下图那样：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    图片暂时脑补
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图中从外围简单多边形的点上延伸出一条路径来连接‘洞’，使得‘洞’的空白与外围的空白联通，就像贴膜里的气泡开了个口把空气放出去了那样。&lt;/p&gt;

&lt;p&gt;如果’洞‘并不是完全包含在外围简单多边形下，有可能是一半在外面，一半在里面，这时只要做多边形裁剪就可以了，将原来外围的简单多边形根据这个’洞‘裁剪成一个凹形，就与’洞‘彻底分离开来了，形成了新的简单多边形。&lt;/p&gt;

&lt;h6&gt;‘洞’中的’岛‘&lt;/h6&gt;

&lt;p&gt;除了有’洞‘，以及’洞‘包含在里面和’洞‘一半在里面一半在外面的情况，还有种情况是‘洞’中有’岛‘。这个‘岛’就像是湖中的‘孤岛’，虽然它也是需要三角剖分，但与外界是无法取得连接的，也就没有与最外围的简单多边形连接的需求。&lt;/p&gt;

&lt;p&gt;因此’洞‘中有’岛‘，这个’岛‘就相当于另一个独立的简单多边形范围，可以另外单独拎出来，自己计算自己的三角化部分。&lt;/p&gt;

&lt;h6&gt;到此，这样就形成了一整个算法，即，如果有‘洞’则先合并‘洞’，如果有岛，则拎出来作为与外围的简单多边形同级别的简单多边形自行计算。所有三角化的计算过程可简单描述为，找耳朵，去耳朵，记录耳朵三角形，最后得到了所有三角形，这四个步骤。&lt;/h6&gt;

&lt;p&gt;应用到实际项目中，最外层的简单多边形，就是我们在地图中定义的可行走的多边形范围。而‘洞’则是地图上的那些静态的障碍区域，而‘洞’中的‘岛’，则是不可行走范围内的可行走的‘孤岛’。&lt;/p&gt;

&lt;p&gt;实际项目中，构建三角寻路网格，我们首先需要找出这个最外围的简单多边形，以及孤岛，再根据切耳算法来构建三角形网格。因此我们需要根据地形来生成相应的可行走三角形网格，通过读取地图中的可行走区域的Mesh，以及读取障碍物Mesh，将它们的竖直方向y轴的值忽略后，再通过多边形合并算法来合并成为最外层的多边形，操作还包括裁切‘洞’一半在里面的情况，最后可以得到需要三角化的简单多边形，以及‘洞’的数据。最后将这些数据用切耳算法得到一个具体的三角网格。&lt;/p&gt;

&lt;h3&gt;4.拥有高度的3D三角形网格构建&lt;/h3&gt;

&lt;p&gt;前面讲了2D平面上的寻路网格构建，在实际项目中大部分时候，2D平面上的寻路就已经够用了，即使是有起伏的地面寻路，也可以用 2D寻路 + y轴射线碰撞的形式 获得位置坐标，在服务器端保存和运算的数据为2D平面数据，在客户端上展示时则加入了y轴碰撞后的数据，这样即满足了寻路的需求，也满足了高低起伏的地形。&lt;/p&gt;

&lt;p&gt;现实项目中有一种解决方案可以用多层级的2D网格做3D寻路的，这是种古老的做法，曾在PC端的RPG网络游戏中非常流行，但在现代的网络游戏中，相对比较少见，因为现代高度网格构建算法有比较成熟和方便的解决方案，但这种多层级2D网格代替3D网格的做法任然有比较好的借鉴的意义。&lt;/p&gt;

&lt;p&gt;我们暂且称它为‘分层平面寻路网格’，‘分层平面寻路网格’需要把所有可行走的区域分成多个层级，第一层与第二层之间有一个连接层，第二层与第三层之间也有一个连接层，这就像我们在一个多层的有楼梯的古堡中，古堡很高有4层楼这么高，每一层都用楼梯连接着，这个楼梯就是连接层与层之间的中间层。&lt;/p&gt;

&lt;p&gt;我们任然使用2D三角形网格构建法构建每一层的可行走区域，这样构建出7层网格数据，第一层是地面三角形网格数据，Layout层级我们可以标记为1，第二层是1楼与2楼连接的楼梯层可行走区域的平面三角形网格数据，标记为2，第三层为古堡2楼的可行走三角形网格数据，标记为3，第4层为2楼与3楼连接处的楼梯的平面三角形网格数据，标记为4，依次类推，每一层包括楼梯层都有自己的可行走的平面三角形网格数据。&lt;/p&gt;

&lt;p&gt;这7层网格数据都是独立的，每一层自己走自己的路时都不需要依靠其他层的数据来寻路。但是，如果只是独立计算各自层级中的网格数据，是无法跨越层级去其他层级的，就比如我们从大厅一楼要去楼梯上看看，或者上到二楼去看看，或者去三楼四楼。&lt;/p&gt;

&lt;p&gt;在‘分层平面寻路网格’中，当要跨越层级寻路时，首先必须确定的是‘我’在哪一层，目的地是哪个层级，出发点是哪个层级，按次序一层层往上走或者往下走。&lt;/p&gt;

&lt;p&gt;比如我们去的目的地是二楼，所在的起点是大厅的一楼，那么我们就必须由标记为1的地面层级，先到标记为2的楼梯层级，最后到达标记为3的二层楼，到达标记为3的层级也就是所谓的二楼后，再根据二楼的三角形网格数据进行寻路到达目的地。&lt;/p&gt;

&lt;p&gt;每一层都有自己独立的数据网格，跨越层级的寻路就需要层与层之间的连接点或连接信息，比如第一层的某几个三角形与第二层是连接的，或者也可以是某个点的范围内，只要进入这个三角形或者圆圈的范围，就认为我们上升了一层，或者下降了一层，我们身上标记的自己所处的层级也变化了，用到的寻路网格数据也变成了当前层的数据。&lt;/p&gt;

&lt;p&gt;因此只要我们移动到该区域内，就认为我们进入了第二层级，于是就可以开始了第二层级的网格寻路，再从第二层级移动到与第三层级相交的区域，就等于我们进入到了第三层级，最后在第三层级的网格数据上寻路，直达目的地。&lt;/p&gt;

&lt;p&gt;下楼也是同样的道理，在每一层中都有那么一个范围是可以通往下一个层级的，只要到达这个范围以内就认为是进入了下一个层级，于是就可以在下一个层级的网格数据中寻路。所以每次跨层级寻路时，都要先寻找上楼，或下楼的那个点，先从当前层级到达那个点上下楼的点，再从该点到达其他地方，有点像瞬移，到了某个点上时，瞬移到了另外一层网格上，只是坐标不变，层级的信息和网格数据变了。&lt;/p&gt;

&lt;p&gt;这种伪3D高度寻路解决方案其实也挺好用的，只是现在知道的人不多，用的人也少了，大家都是要么2D寻路网格够用了，要么就直接 RecastNavigation Navmesh 这种第三方解决方案，很少有人使用这种中间态的技术了，但是这种中间态的技术不是没用，它也有很多值得思考和借鉴的意义。&lt;/p&gt;

&lt;p&gt;RecastNavigation Navmesh 解决方案在各大引擎上非常流行，虽然各自都对其本身做了相应的修改，但核心算法是不变的。&lt;/p&gt;

&lt;p&gt;在Unreal，Unity3D上也同样应用了 RecastNavigation Navmesh，下一节我们会专门讲一讲这个 RecastNavigation Navmesh 中的核心算法，因为它的内容比较多，所以我打算专门用了一节的内容来剖析它，让大家能深刻理解它的原理。&lt;/p&gt;

&lt;h3&gt;5.三角形网格中的A星寻路&lt;/h3&gt;

&lt;p&gt;网格构建完毕了，那么就要派A星上场了。怎样才能让A星与网格数据结合呢。前面一节讲了A星的具体方法，这节就不再具体讲方法了，而是从应用的角度来看待A星的特点。&lt;/p&gt;

&lt;p&gt;A星的特点是必须有邻近的节点可获取，并且邻近的节点与目的地是可以有距离比较的。&lt;/p&gt;

&lt;p&gt;在这种特点的情况下，二维数组下的A星寻路很好理解，邻近节点就是周围的4个点或者8个点，并且与目的地的距离可以直接用方块之间的距离来计算。&lt;/p&gt;

&lt;p&gt;在路点系统中，也有邻近节点，它的邻近节点就是与该节点有线条连接的点，并且与目的地的距离可以直接用点与点之间的距离计算。&lt;/p&gt;

&lt;p&gt;在平面三角形网格中，要从一个点到另一个点，则可以使用三角形的邻近三角形来计算路径，与目的地之间的距离也可以用点与点之间的距离来计算。&lt;/p&gt;

&lt;p&gt;在‘分层平面寻路网格’中，从一个点到另一个点的寻路，和平面三角形网格差不多的方式，也是用邻近三角形来计算路径，只是在计算过程中还需要根据关注网格的层级，每一层都有自己独立的网格。&lt;/p&gt;

&lt;p&gt;二维数组下，计算出来的路径是这样的，[0,0]-&amp;gt;[1,0]-&amp;gt;[2,0]-&amp;gt;[2,1]-&amp;gt;[2,2]-&amp;gt;[2,3]-&amp;gt;[2,4]-&amp;gt;[1,4]。&lt;/p&gt;

&lt;p&gt;路点系统中，计算出来的路径是这样的，(id=1)-&amp;gt;(id=3)-&amp;gt;(id=6)-&amp;gt;(id=12)-&amp;gt;(id=21)。&lt;/p&gt;

&lt;p&gt;平面三角形网格中，计算出来的路径是这样的，(trangle&lt;em&gt;id=1)-&amp;gt;(trangle&lt;/em&gt;id=4)-&amp;gt;(trangle&lt;em&gt;id=8)-&amp;gt;(trangle&lt;/em&gt;id=13)。&lt;/p&gt;

&lt;p&gt;‘分层平面寻路网格’中，计算出来的路径是这样的，(trangle&lt;em&gt;id=1, layout=1)-&amp;gt;(trangle&lt;/em&gt;id=3, layout=1)-&amp;gt;(trangle&lt;em&gt;id=5, layout=2)-&amp;gt;(trangle&lt;/em&gt;id=8, layout=2)-&amp;gt;(trangle&lt;em&gt;id=1, layout=3)，其中trangle&lt;/em&gt;id为layout层级上的三角形ID。&lt;/p&gt;

&lt;p&gt;在三角形网格寻路后，知道了路径上需要经过哪些三角形，那么问题来了。我们行走的路径是根据点来判断的，三角形怎么定点，三角形的大小不一，有可能是宽形三角形，也有可能是扁长的三角形，如果点位定在中心点，那么行走的时候就会很怪异，每次都要先到达三角形的中点才能去下一个三角形，所以中点与中点的连线可能会很怪异。怎么办？&lt;/p&gt;

&lt;p&gt;折中的办法我们可以考虑用边的中点来记录路径，因为相邻三角形之间的穿越都是靠邻边来穿越的，所以邻边的中点更符合三角形穿越，从ID为1的三角形穿越到ID位2的三角形上时，穿越的是ID 1与ID 2三角形的共同边，这种邻边中点计算出来的路径，有更好更平滑的路径效果。&lt;/p&gt;

&lt;p&gt;不过这种三角形进出领边的中点还是不够靠谱，因为三角大小不一，致使三角形边的进出边也会随着三角形而改变，路径同样看起来曲折怪异。那么有没有一种方法能够更好更平滑的计算出三角形网格的路径呢。&lt;/p&gt;

&lt;p&gt;这里就需要引入一个拐点路径算法来优化寻路后的路径。拐点算法有点像射线，所以也常常被称作为射线优化路径算法。&lt;/p&gt;

&lt;p&gt;拐点算法其实并不复杂：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    1.从起始坐标点出发，往与下一个三角形的入口边的两个顶点v1,v2产生两个向量line1、line2，然后再往下一个三角形的入口边的两个顶点v3,v4产生两个向量line3、line4。

    2.通过计算这四个向量的叉乘，可以判定一个向量是在另一个向量的左边或者右边。我们可以计算出v3，v4是否在line1，line2形成的夹角。

    这里会出现几种情况：

    1.下一组边与上一个路径点的向量全部在前一组边的范围内，直接把下一组边的两点替换前一组边的两点。

    2.下一组边的右边点与上一个路径点向量在上一组边的范围内，但左边的点不在范围内，把下一组边的右边点替换前一组边的右边点

    3.下一组边的左边点与上一个路径点向量在上一组边的范围内，但右边的点不在范围内，把下一组边的左边点替换前一组边的左边点

    4.下一组边两个点组成的向量都在上一组边的左边，那么上一组边的左边点成为拐点

    5.下一组边两个点组成的向量都在上一组边的右边，那么上一组边的右边点成为拐点

    6.假如下一组边左边的点和上一组边的左边点重合，则把上一组边的左边点成为拐点

    7.假如下一组边右边的点和上一组边的右边点重合，则把上一组边的右边点成为拐点

    8.当寻路达到最后一个多边形，直接判断终点和上一个路径点的向量是否在上一个边两点的中间，假如不是，再增加一个拐点
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举例说明：从右边的开始点往左边的结束点寻路&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    脑补图片1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;line3，line4在line1，line2夹角内，左右都缩进。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    脑补图片2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;v4在外面，左边缩进。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    脑补图片3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;v3,v4都在line1 左边，v1成为拐点&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    脑补图片4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从v1出发继续按上面步骤计算拐点&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    脑补图片5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后到达终点，收集所有拐点，加上起点和终点后就是正条经过优化后的路径节点。这种射线算法或者说拐点算法能将原本在三角形网格寻路后诡异的路径转化为更加平滑的直线路径。&lt;/p&gt;

&lt;h6&gt;下一节将重点来剖析一下Unity3D中嵌入的 RecastNavigation Navmesh 网格构建算法和寻路算法。&lt;/h6&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;p&gt;《Triangulation by Ear Clipping》David Eberly&lt;/p&gt;

&lt;p&gt;《Delaunay三角剖分的几种算法综述》吴莉莉&lt;/p&gt;

&lt;p&gt;《多边形寻路算法简单介绍》 liweizhaolili&lt;/p&gt;
</description>
               <pubDate>Fri, 26 Jul 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/07/26/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E5%9C%B0%E5%9B%BE%E4%B8%8E%E5%AF%BB%E8%B7%AF2.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/07/26/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E5%9C%B0%E5%9B%BE%E4%B8%8E%E5%AF%BB%E8%B7%AF2.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第六章，网络层(六) - 网络同步解决方案</title>
               <description>&lt;p&gt;当前网络游戏中网络同步方案有三种，即状态同步，预测信息同步，帧同步。三种方式并不是完全互相排斥的，很多时候我们在开发的时候，为了能都让游戏显得更加逼真，会让多种的同步方案一起使用。例如魔兽世界这种开放世界的多人在线RPG游戏，就使用了状态同步和预测信息同步两种方案，绝地求生、和平精英等战地竞技类游戏，也同时使用了状态同步与预测信息同步方案，而传奇世界、热血传奇等传奇类游戏因为不需要预测信息就只使用状态同步，王者荣耀等一批5v5地图类竞技游戏则使用了帧同步方案。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;同步方案的目标是在针对多人游戏中如何用更少的信息同步量来逼真的’模拟‘其他玩家的一举一动，让我们在玩游戏的时候能知道其他人的位置、动作、以及状态。这里有个关键词’模拟‘，我们获取的信息由于网络因素的关系通常都是延后的，如何通过这些延迟的信息来模拟是关键的关键。&lt;/p&gt;

&lt;p&gt;在同步的解决方案中不仅涉及到信息同步还涉及到同步的范围，比如魔兽世界、绝地求生、和平精英、传奇世界、热血传奇，如果他们每次都同步地图上所有玩家的信息，那么同步的数据量太大，不仅客户端承载不了渲染压力和信息通信压力，服务器也同样承受巨大的数据传输压力。因此同步方案对游戏来说只是一个方面的解决方案，除了有同步方案，还需要其他解决方案来支撑和优化同步数据压力才得以实现良好的游戏体验。&lt;/p&gt;

&lt;h3&gt;状态同步&lt;/h3&gt;

&lt;p&gt;为什么要状态同步？如果每帧(每秒30帧)都同步信息，传输的信息量就太大了，而且信息到位也不及时，为了能更逼真的模拟其他玩家的行为，我们把每个人的行为动作都切分成若干个状态。比如站立状态，所有人都一样，站在某个位置不断循环播放某个动画，只要告诉玩家说我在某个位置进入了站立状态，只要状态不变，我们就知道这个玩家就是一直在原地播放站立动画。&lt;/p&gt;

&lt;p&gt;在状态同步里，人身上每个状态就相当于一个固定的行为模式，这个固定行为模式就像个黑盒，只要给到需要的数据，就能表现出固定的行为，比如攻击，就是播放一个攻击动画，并在某个时间点判定攻击效果，攻击完毕后就进入站立状态，比如打坐休息，就是循环播放一个动画，并每隔一个是时间段加一次血量，又比如行走，就是从某点到某点做A星的寻路操作，并边播放行走动画边跟随路线移动到各个路线节点，最终移动到目的地。&lt;/p&gt;

&lt;p&gt;这些状态只要给予需要的固定数据就能展现出相同画面的个体效果。如果我们要让这些状态连贯起来拼凑成一个可操控的人，我们可以向这个人发送各种各样的指令，告诉它你应该触发这状态，应该触发那状态，指令中包含了状态需要的数据。&lt;/p&gt;

&lt;p&gt;在状态同步中，服务器端扮演了幕后操纵木偶人的那个大老板，而客户端里渲染的对象就是那个木偶人，服务器端发出指令说ID为5的木偶人开始攻击，客户端里那个ID为5的木偶人就开始进入攻击状态并且播放攻击动画。&lt;/p&gt;

&lt;p&gt;当动画播放到一半服务器端又发来指令说，被攻击的那个ID的怪兽受伤了并受到500点伤害，这时客户端就会在指定的怪物头上冒出500点的伤害值并且让怪物进入受伤状态播放受伤动画。&lt;/p&gt;

&lt;p&gt;当攻击动画播放完毕时，服务器又发来指令说继续攻击，ID为5的木偶人就又从站立状态切换到了攻击状态，这次攻击到一半服务器发来指令说，这个怪物受到600点伤害并且死了，于是客户端在怪物头上冒出600点伤害的数字并且让怪物进入死亡状态播放死亡动画。木偶人也在播放完攻击动画后，进入了空闲状态播放站立动画。&lt;/p&gt;

&lt;p&gt;服务器扮演着发送指令操控木偶人的角色，这个木偶人也包括玩家自己的角色，即玩家操控着’我‘自己的在游戏中的人物，也同样需要经过服务器的同意，并发送指令给玩家当前的角色进行状态的切换和模拟。&lt;/p&gt;

&lt;p&gt;有时候也未必要一定要经过服务器同意，为了让玩家能够在网络环境糟糕的时候也能够看起来比较顺畅，玩家可以随意操控自己的角色，并不受限于服务器的延迟指令，但是在稍后的服务器校验时再对玩家进行矫正，比如我们玩传奇世界是状态同步，在网络很卡时我们任然能不停的移动，但是过一段时间，服务器把正确的数据发送到客户端后，客户端进行了位置和状态的矫正。&lt;/p&gt;

&lt;p&gt;状态同步的特点是状态是固定的，除非状态改变，否则相同的状态数据得到的是相同的个体状态结果，人物角色实体的行为都是通过状态切换来表现画面。&lt;/p&gt;

&lt;h3&gt;预测信息同步&lt;/h3&gt;

&lt;p&gt;在一些竞技游戏中，人物的行动速度和旋转速度需要不断的变化，要实时更新这些信息，状态同步不能满足这样需求，因为我们速度和旋转的变化太快，我们无法每帧都同步状态信息来模拟。&lt;/p&gt;

&lt;p&gt;但是状态同步依然可以用于除了移动和旋转意外的同步，因为除了移动和旋转，其他信息都没有这样快速、多样的变化，并且它们仍旧遵守原有的规则，完全可以继续用状态来划分，所以状态同步常常与预测信息同步同时存在。&lt;/p&gt;

&lt;p&gt;预测信息同步方案的主要特点是，位置、旋转信息都是由客户端决定的，客户端将自身的位置、旋转信息发给服务器端，再由服务器端分发给其他玩家，当其他玩家收到位置、旋转信息后根据收到的位置和旋转信息预测其当前的位置，速度，加速度，以及旋转角度，旋转速度，旋转加速度并进行模拟和展示。&lt;/p&gt;

&lt;p&gt;在这种竞技性比较强，移动速度比较快的游戏中，通常都需要玩家不停的改变移动速度和旋转角度来体现其控制角色的灵活性。比较常见为枪战类游戏CS，玩家不停在变化自己的移动和旋转的速度以适应战术的需要。或者跑跑卡丁车中，玩家要在高速移动下，不停的调整自己的方向和速度，让自己能够躲过众多障碍，同时在急弯处要旋转自己的车进行漂移等。还有在类似魔兽世界这种开放世界下的RPG游戏，需要不停的改变自己的速度与旋转角度来让战斗显得更加丰富和灵活。&lt;/p&gt;

&lt;p&gt;为了能更加逼真的同步模拟这种变化频率很高的人物移动和旋转，我们不得不让客户端来决定其位置和旋转角度，牺牲一些数据的安全性来让画面模拟的更加流畅。&lt;/p&gt;

&lt;p&gt;每个玩家的客户端会在1秒内发送15-30次左右自身的移动和旋转数据给服务器端，为的就是能更加顺畅的模拟玩家在游戏中的移动旋转的表现，也只有这样，才能让其他客户端不停的更新玩家的位置和旋转信息。&lt;/p&gt;

&lt;p&gt;不过只是单纯的更新位置和旋转数据，会导致玩家在屏幕中不停的闪跳，而用速度的方式表示则更加流畅，所以计算速度和预测速度，以及加速度，让模拟的对象按速度和加速度的形式在屏幕中运动，而不是只更新位置信息，会让角色在画面中模拟行走的位置和方向会更加流畅。&lt;/p&gt;

&lt;p&gt;预测信息同步的算法和公式并不复杂，首先要取已经收到的该玩家的位置信息前5个除以间隔时间，就能得到一个平均的速度，再取这样5个一组的3-5组，就能得到一个平均的加速度，根据这个速度和加速，就能让角色在屏幕中模拟跑动了。&lt;/p&gt;

&lt;p&gt;但方向还不对，没有方向怎么跑都是错的，在角度的同步上也依然可以按照这种速度和加速度的方式去预测，取最近5个角度的值得到平均旋转速度，再取5个一组的3-5组这样的数据计算得到旋转加速度。&lt;/p&gt;

&lt;p&gt;但是还是有偏差，即使预测和模拟了速度和方向，由于数据的量不够多，网络延迟大且不稳定，所以很容易造成位移的偏差，所以定时的矫正比较是必须的。&lt;/p&gt;

&lt;p&gt;矫正可以在生硬的基础上加入一些当前数据的预测，比如每秒矫正一次，每隔1秒重新计算一次从最近收到一个位置上到现在这个时间点的预测位置，如果网络延迟比较小的时候，由于原本预测的位置和矫正的位置是差不多的，所以角色矫正时的抖动现象完全无法用肉眼看出来，但如果网络延迟比较大的时候，矫正的位置和预测的位置就会偏离的比较远，角色看起来总是一闪一闪的不停抖动甚至飞来飞去。&lt;/p&gt;

&lt;p&gt;这也正是为什么我们在玩CF穿越火线，跑跑卡丁车这类游戏时，假如对方的网络比较卡，就会看到对方角色不停的一闪而过，因为预测数据和矫正数据偏离的太多了，客户端在不断的矫正角色的位置和速度。&lt;/p&gt;

&lt;h3&gt;帧同步&lt;/h3&gt;

&lt;p&gt;状态同步既能控制数据计算的安全性，也能保证所有客户端的同步性，不过在位置和角度变化很快的竞技游戏中，状态同步无法承受这样又多又快的位置和旋转变化，所以就加入了预测信息同步的解决方案，这种解决方案放弃了玩家的位置和旋转角度的强校验，使得各个客户端能更加顺利和准确的模拟其他玩家的位置和旋转角度。&lt;/p&gt;

&lt;p&gt;但是更加严格的同步要求下预测信息同步也无能为力，因为每个玩家的手机和电脑端的设备好坏不一样，网络环境也不同，一台好的机子和手机，同一时间段能位移的距离可能也不一样，预测信息同步解决方案无法在差异性巨大的设备和网络通信之间做到精准的同步，也无法保证数据校验的安全性，帧同步解决方案就很好的解决了预测信息同步解决不了的问题。&lt;/p&gt;

&lt;p&gt;在同步性和安全性要求很高的游戏中，例如王者荣耀，拳皇类格斗游戏，游戏中的每一帧都是非常关键的，一两帧都有可能决定胜负，对于这种类型的游戏，同步的要求性高，安全性也有很高的要求，所以帧同步的解决方案正好契合这种类型游戏。&lt;/p&gt;

&lt;p&gt;与状态同步和预测信息同步不同的是，帧同步的逻辑不再由客户端本身的逻辑帧Update来决定，而是转由从网络收到帧数据包来驱动执行逻辑更新，所有逻辑更新都放在了收到帧数据包时的操作中，包括人物角色的移动，攻击，释放技能等，每收到一个服务器发过来的帧数据包，就更新一帧，如果服务器端发过来的帧数据到达的比较慢，就有可能像放慢动作一样，一帧一帧的播放走路，攻击的慢动作动画。&lt;/p&gt;

&lt;p&gt;帧同步的服务器需要向每个客户端每秒发送20-30个帧数据包，每隔0.033-0.05秒发送一个，即使没有任何信息也会发送空的帧数据，因为客户端要根据这些帧数据包来‘演算’游戏逻辑。&lt;/p&gt;

&lt;p&gt;为什么要说‘演算’呢，一个比较容易理解的比喻是原来在客户端的Update里角色每帧移动xx米的逻辑，转移到放在了从网络收到的帧数据包里，每收到一个帧数据包，角色就移动一步，这样使得每台游戏设备在拥有不同的帧率的情况下，执行了相同数量的逻辑帧，也执行了相同时间点的逻辑指令，因为指令时存在帧数据里的，帧数据的执行顺序一致，则指令执行的时间点也是一致的。&lt;/p&gt;

&lt;p&gt;当玩家有操作指令时，把指令发给服务器，服务器在随后下发的帧数据中，某一帧中带有我们上传的指令数据。因此在帧数据里除了有指令数据外，其他时候都是空的。&lt;/p&gt;

&lt;p&gt;随着客户端不断收到网络数据帧，执行到某一帧带有指令数据时，就执行该指令，比如指令数据表示某角色以每帧1米速度向前移动，那么客户端就开始启动移动状态执行该指令，不过不是在客户端自己的Update中执行，而是从网络中每收到一个帧数据就执行一次，比如后面总共收到20帧的网络空数据帧，那么就执行了20次每帧1米的行走状态，直到玩家再次操作，停止移动指令，并把该停止指令发送给服务器，服务器在再以帧数据的形式发送给所有玩家，当玩家收到这个带有停止指令的帧数据时，才停止移动。&lt;/p&gt;

&lt;p&gt;逻辑在网络数据帧中执行，就相当于服务器控制了所有玩家的播放的帧数，让所有玩家收到的帧数据的数量是相同的，那些需要执行的指令在第几个逻辑帧的位置也是相同的，由于执行帧的时间点，和执行的逻辑的次数是相同的，从而使得所有收到帧数据的客户端做出的表现也是相同的，这就是帧同步的基本原理，由服务器发送的帧数据来完成所有客户端的同步执行操作，在每个客户端设备中所使用来‘演算’的算法是一致的，执行的次数一致，执行的指令数据和时间点一致，执行的算法一致，使得执行的结果一致，那么在画面上所表现的出来的也就是一致的。&lt;/p&gt;

&lt;h3&gt;同步快进&lt;/h3&gt;

&lt;p&gt;不过现实是并不是所有客户端的网络都是流畅的，通常的网络环境都是时好时坏的，客户端在收帧数据时，经常都是不平稳的，偶尔一堆帧数据涌过来，或者又忽然完全没有了帧数据。&lt;/p&gt;

&lt;p&gt;所以如何及时同步落后的客户端画面成了客户端解决同步问题的一个关键。&lt;/p&gt;

&lt;p&gt;最简单的方式是我们可以一下子执行全部堆积在队列里的网络帧，这样我们一下子就能到达画面的最后一帧，然后继续等待网路发送过来的数据帧。&lt;/p&gt;

&lt;p&gt;但是这样一次性执行所有的帧的方式，如果堆积的数据帧太多，会导致游戏卡住很久，画面会停止不动而很久，游戏体验比较差。所以我们可以在渲染帧中每次执行N帧(N大于10)来让画面快速推进，这样一来玩家又能看到动态的画面，又能快速的跟上最后的同步帧数据，同步完所有的帧数据后，再把执行速度降下来，继续按每收到一个网络帧来同步画面。&lt;/p&gt;

&lt;p&gt;不过如果落后太多太多，比如落后了几千几万帧的时候，快进的方法也不管用了，因为执行的帧数落后太多，按普通快进的节奏得要快进很久，如果快进得太快则画面卡住的时间太久，体验太差用户无法接受。&lt;/p&gt;

&lt;p&gt;这时就只能用快照方式做同步操作，快照的意思是把某一帧下面的所有数据，包括玩家，怪物，可破坏的障碍等动态物体的数据像照片一样记录下来存储在服务器，当客户端需要时，打包发给客户端，客户端直接使用该快照数据来渲染画面，因为这一帧的快照离最后需要同步的帧数最近，中间可能跨越了几千几万的帧数，所以如果从快照那一帧数据出发，从该帧数据开始快进到最近的数据帧，相对于从头开始快进来说要快的多，也节省了许多网络流量。&lt;/p&gt;

&lt;p&gt;在同步数据帧时会用以上的快进处理方式，但是如果发送的指令过于频繁也会造成网络数据的灾难，比如玩家控制角色不断释放技能或者不停的旋转奔跑，就会导致客户端以渲染帧的速度每帧大量的向服务器发送指令数据像机关枪一样扫射式的发射，这种数据发送量无法承受。&lt;/p&gt;

&lt;p&gt;在不与帧同步冲突的规则下，我们可以选择把需要发送的指令存起来，等到收到一个网络帧时再发送，如果有很多指令则不断替换未发送的指令直到收到网络帧并发送。这也符合多端帧同步的规则，其实是我们限制了每帧只能有一个操作，就像定制了一个两个规则为‘不能在同一帧有多个操作’的规则。这个规则使得，不能在同一帧中既前进又后退，也不能在同一帧中既释放技能又取消技能。这样的话操作指令的数据包也跟随着同步的数据帧规则一起发送。&lt;/p&gt;

&lt;p&gt;但这里又出现问题了，如果等到有网路数据帧时再发送，那么位移类和旋转的指令就不那么灵活了，因为在实际操作中，旋转和位移的变化是非常快的。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，我们可以加大每秒发送网络数据帧的数量，比如每秒到30帧甚至50帧，但这样网络宽带的消耗量又变的很大了，有时候会得不偿失，因此我们需要优化和权衡一下。由于需要向所有客户端每秒广播数据30-50次的数据，所以发送数据的频率非常高，如果每次广播的数据要足够的小，能在一个MTU以下，这样就能有效的降低底层网络的延迟，既加大了逻辑帧的数量，提高了画面渲染的流畅度，增加了操作的灵活性，网络宽带的占用率也没有这么高。&lt;/p&gt;

&lt;h3&gt;精度问题&lt;/h3&gt;

&lt;p&gt;帧同步的核心战斗的演算算法都是在各自设备的客户端中进行的，前面说了所有设备执行的帧数一致，执行的指令和时间点一致，执行的算法一致，就能得出相同的结果。但是这里又出现一个由于不同设备之间的采用不同的算法来计算浮点数的问题，‘精度’。&lt;/p&gt;

&lt;p&gt;浮点数在各不同设备上的计算结果有细微的差异，导致随着计算的增多，差异变得越来越大，虽然执行次数、时间、算法都一致，最终计算出来的结果还是会由于浮点数计算结果不同而导致不同步的问题。&lt;/p&gt;

&lt;p&gt;所以浮点数的精确计算也是帧同步在同步问题上的一大困难，归根结底，是因为把帧同步方案把计算结果交给不同设备而导致的问题。&lt;/p&gt;

&lt;p&gt;其实也并不是什么难题，市面上有很多用浮点数精度问题的解决方案，比如定点数就是其中之一，所谓定点数，就是把小数部分当整数来计算，这样计算起来就不会有误差了。&lt;/p&gt;

&lt;p&gt;通常的浮点数(即有整数部分和小数部分)在计算机中的表示法是 V = (-1)^s x (1.x) x 2^(E-f) 也就是说浮点数的表达其实是模糊的，它用了另一个数的指数来表示当前的数。而定点数则不同，它把整数部分和小数部分拆分开来，都用整数的形式表示，这样计算和表达都使用整数的方式，整数的计算是确定的，这样就不会存在误差，缺点是占用的字节数多了，计算的范围也缩小了。&lt;/p&gt;

&lt;p&gt;用定点数来替换浮点数计算就能保证在各设备上的计算结果一致性，不过直接使用c#自带的decimal定点数在使用时也存在很多问题，比如无法和浮点数随意的互相转换，所以在计算上也会需要进行一定的封装，又比如无法控制末尾小数点，使得精度还是无法根据项目需求来控制，无法控制内存大小，大量使用使得堆栈内存增加。&lt;/p&gt;

&lt;p&gt;因此大部分项目都是自己实现定点数的，把整数和小数拆开来都用整数表示封装在某个类中，再写一些额外的数学库的编写。其实也没那么恐怖的，就是把定点数与其他类型数字的加减乘除重写一下，如果涉及到更多的数学运算，则再建立一个定点数的数学库，存放一些数学运算的函数。&lt;/p&gt;

&lt;p&gt;最最最快速简单，性价比最高的的方式，其实是将所有数字乘以1000，或者10000，再以整数的方式来计算结果，所有需要计算的数字都以这种方式存储，只有显示的时候才除回来回到浮点数，这样即控制了精度的一致性，也不用这么麻烦去实现定点数的封装，而且浮点数还能继续用，因为在大部分帧同步游戏中，200万的数字，甚至20万都已经是足够大了，所以他们无需劳心费神的去封装一个定点数以及定点数数学库，而且这个定点数还无法与表现层有很好的连接。直接乘一下就能达到一样的效果，大大降低了研发成本。不过两者各有优势利弊，不一定说哪种方式一定好或者坏，按照项目的需求做不同的决策是应该的，也是必须的。​&lt;/p&gt;

&lt;p&gt;这里也了解下同步锁的机制。在更加严格的同步类游戏中，比如星际争霸1中，如果有玩家网络环境不好，希望能够等待该玩家的进度，就会使用同步锁的机制。&lt;/p&gt;

&lt;p&gt;同步锁的机制，要求每个客户端每隔一段时间都发送一个锁帧数据，类似‘心跳’数据包，服务器端在帧数据中嵌入心跳包，告诉其他玩家该玩家仍然在线并正常游戏中，如果客户端在接受帧数据时超过50帧没有收到某个玩家的锁帧数据的话则停止播放网络帧数据，等待该玩家跟上大部队后，再所有客户端同时从最近的一次锁帧数据点开始，以该点为最后一数据帧，一起继续各自演算。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;p&gt;《漫谈游戏帧同步》作者：布尔君de二次方&lt;/p&gt;

&lt;!-- 

网络流量大小，状态同步大，帧同步小。

回放文件大小，状态同步大，帧同步小。

安全性，状态同步好，帧同步弱。

服务器压力大小，状态同步大，帧同步小。

战斗校验，状态同步校验容易，帧同步校验难

网络卡顿表现，瞬移掉血，回撤。

实现，状态验证与插值预测，所有碰撞位移都要程序自己控制；还要写状态的回撤。

六．  长连接和短连接的优缺点
（https://www.zhihu.com/question/39849641/answer/83774680）
tcp:
tcp的好处就是“可靠”，会将体积大的数据包进行分片，保证不会让ip协议进行分片。
会检测数据包是否丢包，丢包重传，有序地发送数据包等等，
坏处就是数据包头比较臃肿，至少有20+的字节（不要小看这20+字节),
在丢包重传时，会阻塞后面的数据包，而且tcp需要保持连接状态才能进行通讯，
在连接数较多时，服务器光在handle这些连接状态上就要消耗不少的性能。
题主所说的“长连接”应该指的是tcp socket，tcp socket是操作系统为tcp协议的实现（说白了就是操作系统为tcp提供的api) 

http: http处于应用层，是基于tcp的实现。它继承了tcp的所有优点。
跟tcp有些不同,http不会一直的保持连接状态，
在早期的http 1.0时期，http请求在得到响应后会立即断开连接，
这样就导致了每次的http请求都必须去进行tcp握手（在数据报文很小时，握手时间甚至会超过数据传送时间），
在1.1版本后使用同一个连接进行多次的http请求，在一段时间内没有再次进行http请求时，会自动断开，
这样就减轻了服务器维护大量链接所产生的开销问题，但是http是应用层，它会产生新的数据报头，在数据包的容量上会更大。

udp: udp 是“不可靠”的：不会丢包重传，会导致ip分片从而丢包，数据包不会按序送达，
只保证到达的包数据是完整的，它的好处就是,不会产生tcp丢包时的队列阻塞，
数据报头较小，只有8个字节，是一个无连接协议。

手游用什么协议？有啥优缺点
tcp：
优点就是tcp的功能太强大了，基本上没有tcp做不了的事，而且基于tcp的第三方库也非常多而且稳定，
开发起来比较顺心。但tcp的缺点也很多，数据报头有20+字节，在一些动作类游戏中，需要非常频繁地与服务器进行交互，
而且通常一个操作指令会很小（基本上都小于20个字节 :P),这就代表一半的带宽开销被用在了数据报头上。
其次就是tcp需要保持连接状态，这个在pc上可能不是问题，在手机上问题就大了。
手机信号不稳定，ios操作系统会将后台非特殊进程挂起，导致游戏断线需要断线重连，也就是重新登陆一次，
做过网游的同学都知道，游戏登陆操作对服务器的开销往往是最大的。
再一个就是tcp丢包重传的特性引起的，每次发送数据包需要check是否包已到达，
队列后的数据包需要等待前一个数据包成功发送后才能进行发送，这样会导致严重的lag，
在手机信号不好时尤为明显。由于大量的tcp连接会带来开销，基于tcp的游戏通常在线人数会有limit,
当然，使用分布式架构或者游戏滚服会解决掉这个问题（tcp分布式架构人人都会做，做的好不好，这个得看功力）。

http：
因为http不需要持续地保持连接，是一个无状态的连接，不会产生tcp所产生的断线重连的问题，
服务器也不需要维护过多的连接。缺点就是需要经常的进行tcp握手操作（不会影响玩家体验），
而且由于http的无状态性，通常游戏数据需要实时保存，不过现在的内存数据库 nosql的兴起和计算机性能的提升，这块劣势已经不存在，
而且越来越多的游戏都采用实时数据保存，防止游戏服务器宕机数据回档的风险。
再一个就是服务器无法主动向客户端推送数据，导致在某些功能上会无法实现。
由于http的无状态性，需要做心跳处理，基于http的游戏服务器可以横向扩展（每一个游戏服务器进程就是一个单纯的逻辑计算器），
数据库架构设计的好的话，一个游戏服很容易实现1亿+的玩家同服的情况。

udp：
优点就是“快”和“小”，udp不会产生tcp的数据包队列阻塞的问题，而且报头数据量很小，
在某些对速度和网络io量有较大要求的玩法时，这2个优点显得尤为重要，而且udp是无连接的，不会产生断线问题，也可以横向扩展。
缺点就是udp的不可靠性，一些实现可靠的udp协议的第三方库很少，而且往往满足不了自己项目的需求，所以要实现可靠的udp要自己动手造一遍轮子，
需要一定的网络基础知识和敢于踩坑的精神 。

推荐方案
方案1 ：完全使用udp，几个项目下来，觉得使用udp做手游服务端真的是perfect match。
没有断线问题，流量小，响应速度快。无奈手游环境开发商们心态比较浮躁，都以稳定来追求利益最大化，市面上完全使用udp的游戏非常少。 

方案2 ：http+udp，这种相对保守一些，逻辑相关的使用http协议，保证游戏逻辑不会出通讯上的问题，推送类的使用udp，
比如聊天，世界公告等等，这些就算你的udp协议写的烂，也不会产生严重问题。
如果实时性要求非常高的战斗功能，请使用udp。

方案 3：tcp+udp，这种方式为了加强连接的可靠性，tcp断了可以用udp继续游戏，两种连接来加强连接的可靠性。在手游MMORPG类型的长连接的游戏中更为合适。




八．  网络加密与压缩
短连接可以用md5前面的所有参数作为校验依据，防止篡改。
加密方式
支持IP6以符合苹果审核，用域名
九．  优化
*短连接用www，做队列，单任务作业，合并请求和回调(每个请求有编号，对应回调)
*长连接自己写，协议可以用protobuff，缩小协议长度
*短连接用md5，token验证参数正确性
*两边加密可以把公钥写在so文件里
*长连接自己写，做队列，锁，多任务作业 --&gt;
</description>
               <pubDate>Sun, 14 Jul 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/07/14/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%826.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/07/14/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%826.html</guid>
            </item>
        
            <item>
               <title>思路探讨(二十五) 困境中的中产</title>
               <description>&lt;p&gt;还是聊聊关于钱的事吧，人生哲学聊多了也没什么立竿见影的效果，能理解的瞬间就能懂，理解不了也只能等那灵光一现的时候。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;最近股市很动荡，中国经济很动荡，L型的经济走势一直没有走完，还不断得被破坏和骚扰。我猜大部分人都在痛苦得挣扎，社会经济似乎走上了萧条的环境，周遭的环境和人们的积极性越来查差，埋怨的越来越多，人们开始怀疑中国的是否能崛起，其实我也一样，不过我知道未来总是不确定的，无论崛起与否我们自身都需要保持积极和乐观，即使有余钱的少部分人，手里拿着钱也是不知所措的，投哪都是亏惨的结局，所以现在这个环境，没有赢家。&lt;/p&gt;

&lt;p&gt;想尽快突围，只有一条路，打铁还需自身硬，乘着大环境不好，我们有理由不去追逐名利，那就沉下心来多多自我修行，多多学习，多多看书，多多磨炼。&lt;/p&gt;

&lt;p&gt;我为什么要弄明白经济运作规律，就是想在未来的人生道路上走的更有方向性，并不一定说要变富有，但至少能少走点邪魔歪道。&lt;/p&gt;

&lt;p&gt;其实最惨的就是中产阶级了，中产阶级即想往上冲，又背负着最沉重的债务，真的难。&lt;/p&gt;

&lt;p&gt;在经济不景气的时候大部分人都要面临债务危机。由于在经济繁盛的时候人们的心里装的都是怎么赚到更多的钱，而对大量的债务风险视而不见，当萧条和不景气来临时，就发现当前的债务过大，利息过多，原来在经济繁盛时很容易偿还和导手的资金，变得很艰难，因此债务压力变得越来越沉重。一不小心，几代人的血与泪以及奋斗积攒的财富，在一瞬间里全部消散了。&lt;/p&gt;

&lt;p&gt;这也是为什么中产阶级最难的原因，背负的债务与收入严重不匹配。在萧条期，最先倒下的就是中产，最容易倒下的也是中产，最快倒下的是中产。&lt;/p&gt;

&lt;p&gt;什么原因导致中产总是最先倒下，难道是中产的人笨吗？又为什么偏偏是中产阶级呢，就不能是其他层阶级或者富人阶级吗？&lt;/p&gt;

&lt;h6&gt;中产有许多自己的阶级特征，大部分的这些特征都说明了，这个阶级没有自主权，不够灵活。&lt;/h6&gt;

&lt;p&gt;不够灵活体现在这几个方面：&lt;/p&gt;

&lt;h3&gt;1，资产量不大，却大部分集中在单一投资方向上。&lt;/h3&gt;

&lt;p&gt;中产阶级的资产大部分比较集中房产上，与房地产行业捆绑紧密。并且是某一个市的一处房子上。&lt;/p&gt;

&lt;p&gt;或者有的中产买些股票，基本都是把大量资金集中在某只股票上。&lt;/p&gt;

&lt;p&gt;资产的升降直接与某个标的绑定的很牢固。只要这个标的一旦崩溃，就可能直接破产。&lt;/p&gt;

&lt;h3&gt;2，债务量与自身收入不成比例。&lt;/h3&gt;

&lt;p&gt;中产阶级创业的最多，超负荷负债买房的也最多。&lt;/p&gt;

&lt;p&gt;职场并不是所有中产阶级都能呆到退休的地方，这一点大部分人都没有意识到问题的严重性，年级大了想找份工作都是难事，年轻人的竞争力更强更有活力。只有职场上的赢家才能继续呆到退休，赢家很多种，技能上的，情商智商上的，还有运气上的。&lt;/p&gt;

&lt;p&gt;所以大部分中产阶级都需要通过自主创业的形式来获得更加稳固持久的收入来源，但创业哪有这么容易，基本都是赔钱，很多中产选择借钱维持，利滚利，加上，继续入不敷出，就会陷入一个更加大的泥潭，不止财务上出现大的问题，精神上也会出现大的问题。&lt;/p&gt;

&lt;p&gt;所以债务导致的破产，在中产阶级数不胜数。&lt;/p&gt;

&lt;h3&gt;3，财富迁移难度大。&lt;/h3&gt;

&lt;p&gt;中产阶级虽然有财富，但毕竟是不是富有人家，无法轻易的迈过一些高门槛的迁移动作。&lt;/p&gt;

&lt;p&gt;比如从二三线城市，甚至从三四线城市，向一线城市迁移就很难，这些其他线城市的房价卖掉后，在一线城市也很难买到几平米，更不用说由于迁移引发的一系列的家庭和生活的问题，挡住了大部分家庭的决心。&lt;/p&gt;

&lt;p&gt;其实不管从心里和现实的角度看，迁到一线城市这种动作，都是需要付出沉重代价的。沉重的代价背后，是否值得，对于每个不同家庭情况来说，都是不一样的。&lt;/p&gt;

&lt;p&gt;又比如移民到拥有更好的经济环境的国家去，这种大级别的迁向更好环境的动作非常难,门槛也非常高。迁移到比中国环境更加弱的国家去是毫无意义的，因为经常听到有人迁移到东欧，以及西欧部分不发达国家，甚至东南亚地区，根本就是自找苦吃。&lt;/p&gt;

&lt;p&gt;唯有迁到世界第一的美国，才是所有迁移选择中最值得的，迁移到美国的门槛比较高，要么技术很牛逼，要么钱很多，500w以上是正常的迁移及投资费用，对于囊中羞涩的中产来说希望渺茫。&lt;/p&gt;

&lt;h3&gt;4，急功近利的思想居多。&lt;/h3&gt;

&lt;p&gt;严重缺钱的中产，其实比其他各层阶级都缺钱，这种缺钱的氛围时常影响着中产家庭的整个人生，这很容易滋生暴富思想。&lt;/p&gt;

&lt;p&gt;很多中产的人总是希望通过借用杠杆来达到一夜暴富。坚信，深信，只要机会一来，自己就能暴富。&lt;/p&gt;

&lt;p&gt;所以中产也是最好骗的，错的，假的，危险的机会，中产们很容易受其诱惑，一旦试图抓住这些机会，他们总想着暴富，不顾一切的投入，全部资产还不够，甚至还借用杠杆，试图一夜暴富。最终，醒过来时，一切已晚，财富早已化为乌有，消散而去。&lt;/p&gt;

&lt;p&gt;其实不能说中产素质不够，辨识不了真假和风险的高低，因为即使博士毕业在这样一个氛围的圈子里也同样会被蒙蔽了双眼，学历越高的人对自己做出的选择坚信不疑的程度越高。&lt;/p&gt;

&lt;h6&gt;那么中产就没有办法了吗？&lt;/h6&gt;

&lt;h6&gt;这个世界能突出重围的人毕竟是少数，无论在哪个圈子，哪个层级，都是一样一样的，因为人性不变，金字塔就不会变，中产更是普遍持有其特点的人群。&lt;/h6&gt;

&lt;h6&gt;因为能看清经济发展规律并降低财富抬升期望的人毕竟是少数。&lt;/h6&gt;

&lt;h6&gt;能持续不断分散投资，多维度考察和思考投资思路和角度的人毕竟是少数。&lt;/h6&gt;

&lt;h6&gt;能沉下心来，排除杂音，专心做好事情，以及专心做自己的人毕竟是少数。&lt;/h6&gt;

&lt;h6&gt;能推开暴富机会诱惑的，不嫉妒那几十万分之一概率中赢得财富的人毕竟是少数。&lt;/h6&gt;

&lt;h6&gt;能持之以恒，不为外界纷扰所动的人毕竟是少数。&lt;/h6&gt;

&lt;h6&gt;如果我们能做到这些少数人才能做到的，我相信量变造成质变会在多年后发生在我们身上。&lt;/h6&gt;
</description>
               <pubDate>Sat, 06 Jul 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/07/06/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A825.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/07/06/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A825.html</guid>
            </item>
        
            <item>
               <title>思路探讨(二十六) 我们真的聪明吗</title>
               <description>&lt;h3&gt;更多时候，我们不是败给了外界，而是败给了自己。&lt;/h3&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h6&gt;我们都是认为自己是聪明的人，没有人会认为自己是那个笨蛋。但聪明真的用在了刀口上吗，不是的，更多时候，聪明被用在刀背上，而愚蠢却常常用在刀口上。&lt;/h6&gt;

&lt;p&gt;“骄傲使人落后”这句话一点都没说错，人很容易没有警惕心理，在没有了谨小慎微的态度后，人总是不自觉的陷入当前环境的假想中，认为当前状况是永远可持续的。&lt;/p&gt;

&lt;p&gt;举个例子，在繁荣时期，人人都有工作的时间，社会上到处都是工作，赚钱也很容易，投个股票，买个基金，放贷给个人，投个P2P，坐等收钱就行了。&lt;/p&gt;

&lt;p&gt;人会不自觉的陷入我不缺工作，我很聪明，我很能赚钱，我很厉害的心理状态和自我认识。&lt;/p&gt;

&lt;p&gt;所以在繁荣时期，人们都会觉得自己很聪明，很能赚钱，我们会认为是因为我们的聪明所以工作很容易找到，赚钱很容易，却从来不认为是繁荣的环境造就了我们。&lt;/p&gt;

&lt;h6&gt;但在萧条时期就不同了，我们会很难找到工作，赚钱也很难，亏钱很容易，原来在繁荣时期浪费的时间，浪费的钱，在萧条时期就开始了对我们的大规模的惩罚。这对人自身的打击不是一点点，能彻底醒悟的人还是不多，能冷静下来一步步脚踏实地积累和沉淀的更少，骄傲没有这么容易败下阵来。&lt;/h6&gt;

&lt;p&gt;那么有人说，我在繁荣时期不去凑这个热闹，自己一步步脚踏实地的积累和沉淀，走自己的路，让别人去赚它自己的钱，不就可以了么。&lt;/p&gt;

&lt;p&gt;其实并没有这么容易，还是同样的话，人很难不受当前环境所影响，在大家都大把大把地赚钱，大把大把的挥霍的时候，我们是很难不受他们影响而不去追随他们的，嫉妒心和贪念的放大致使我们无法控制自己，在贪婪的时刻疯狂的去追求一些虚无缥缈的价值。&lt;/p&gt;

&lt;p&gt;其实退一步说，即使我们能忍住不去嫉妒、不去贪婪，我们周围的亲朋好友肯定没有我们这么好的定力，他们可能会不断得劝我们，骚扰我们，甚至指责我们的无能，指责我们在别人都疯狂的享受盛宴的时候我们却让这么大好的机会错过。&lt;/p&gt;

&lt;p&gt;像这样的假象在生活当中其实有很多。我们年轻的时候，会有股很强烈的意识，认为我们的时间和精力会一直像现在这么多，所以我们在年轻时，时常会大把大把的浪费我们的时间和精力在一些根本毫无意义的事情上，而对于那些需要我们沉下心来学习和积累的事情却认为时间很多以后也能去做。&lt;/p&gt;

&lt;p&gt;随着时间的流逝，精力的下降，年龄的增大，量变成了质变，突然会意识到，我们已经不再年轻，已经不再拥有这么多精力，而原本应该学习和积累的才干却一点都没有做到，原来大把大把的消磨时光和浪费的精力，已经一去不复返了。&lt;/p&gt;

&lt;p&gt;对于青春貌美的年轻人也是同样，几乎所有的年轻人都在这个年轻的姿态下，总是会不自觉的认为我会永远这样年轻貌美，进而无节制的用当下的年轻貌美的优势来享受当下的快乐，等过几年发现年轻貌美一去不复返时，却什么都没有留下。&lt;/p&gt;

&lt;h6&gt;就因为我们并没有意识到当下的我们其实是暂时的，我们的聪明和貌美只是环境造就的，而非我们自己本身的努力，所以总是表现出一副傲人的姿态。&lt;/h6&gt;

&lt;p&gt;我们真的聪明吗，确实不笨，但总是聪明反被聪明误。&lt;/p&gt;

&lt;h6&gt;除了在好环境中无法感知自身的不足外，在辛苦的环境也，也会无法感知自身的进步。&lt;/h6&gt;

&lt;p&gt;人总是无法在当前情景中察觉到自己的位置和状态，就像古诗说的，不识庐山真面目，只缘身在此山中。&lt;/p&gt;

&lt;p&gt;我们在辛苦和充实的日子里，经常会感到乏味、枯燥、苦楚，因为辛苦的日子里天天做着重复的事情，天天面对的自己无法克服的障碍，天天面对从来没有面对过的困难，天天跟自己较劲，天天突破自己的极限，以及天天突破自己的三观和认知。而我们却很难察觉这种辛苦和枯燥对我们的帮助有多大。就因为无法察觉导致我们时常想要摆脱辛苦的状态，总想着早早放弃。&lt;/p&gt;

&lt;p&gt;有时候也要冷静下来，细心想想，这些辛苦的日子里，我到底学到了什么，及时的让自己感受到进步。如果能在辛苦的时候察觉到自己的进步，这种及时的良好的反馈，能让自己不受精神的阻扰，勇往直前。&lt;/p&gt;

&lt;h6&gt;苦中作乐，其实是最好的状态，但关键还是我们要能感受到’乐‘的存在，如果感受不到’乐‘而只感受到’苦‘，那么即使是在一个很好的、很难得的环境下，可能我们也很难坚持下去。&lt;/h6&gt;
</description>
               <pubDate>Mon, 24 Jun 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/06/24/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A826.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/06/24/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A826.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第十章，地图与寻路(一) A星算法及优化</title>
               <description>&lt;p&gt;寻路一直是游戏项目中的热门功能，寻路算法用的最多的就是A星算法，其他也有，比如 Dijkstra算法 与 Floyd 算法，但是他们的在时间和空间上的复杂度都太高，Dijkstra算法时间复杂度为O(N^2)，空间复杂度也是O(N^2)，Floyd的时间复杂度更高有O(N^3)，空间复杂度也在O(N^2)，这种复杂度的算法寻路算法如果应用在游戏中稍微大一点的范围、大面积、稍微高一点的频率的寻路需求是CPU是无法承受的。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;A星算法其实并不是最短路径算法，它找到的路径并不是最短的，它的目标首先是能以最快的速度找到通往目的地的路，它的时间复杂度为O(NLogN)，最差的情况是从起点出发把所有的格子都走了一遍，最后才找到目的地。&lt;/p&gt;

&lt;h6&gt;用一句话概括A星：用最贪婪的方法寻找目的地的路径。&lt;/h6&gt;

&lt;p&gt;怎么个贪婪法呢，我们要拿方格来描述A星算法，因为用方格描述A星寻路的方式很容易理解。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;[][][][][]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[][][][][]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][][][]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[][][][][]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[][][][][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上图中s为start起点(3,2)，e为end终点(5,5)。&lt;/p&gt;

&lt;h6&gt;用最贪婪的方法去找目的地：在所有得到的点中，找到与目的地e距离最短的那个，就是离目的地e最接近的，继续用这个点向前探索，直到找到目的地。&lt;/h6&gt;

&lt;h6&gt;简单来说从s点开始取出它周围的4个点，上，下，左，右，计算下它们与终点e的距离，哪个离e的距离最短，就取那个点的周围4个元素继续进行同样的操作，直到找到目的地e。&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;[-][-][-][-][-]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[-][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][-]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[-][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[-][-][-][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上图中，s开始取到周围的4个点标记为1，计算距离，并推入到一个队列，把这个队列按到e点距离值从小到大排序一下，取出离e点距离最短的点，再从该元素周围取出4个元素标记为2，推入到队列，并对它们计算与e的最短距离，再排序一下，取出离e点距离最近的那个标记为3，依次重复这种操作，直到找到e目的地。所有被标记过的都不能再被重复标记。&lt;/p&gt;

&lt;p&gt;我们来看看复杂点的A星寻路例子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;[-][-][-][-][-]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][+][+][-][-]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[-][+][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][-][-]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[-][+][-][-][-]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[-][-][-][-][-]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从s出发到e，图中‘+’为障碍物，用贪婪的A星寻路会怎么找到e呢，如下图：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][-][-][-][-]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][+][+][-][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][+][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][+][+][+][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;1.先取s周围的点标记1&lt;/h6&gt;

&lt;h6&gt;2.取标记里最近的且没被取过的点，即下面这个1点，取它周围点标记为2&lt;/h6&gt;

&lt;h6&gt;3.取标记里最近的且没被取过的点，即点3也可以是上面的1，但我们定个规则一样的距离以下面为标准，取它周围的点标记为点4&lt;/h6&gt;

&lt;h6&gt;4.离e点最近的还是4，继续取它周围的标记为5&lt;/h6&gt;

&lt;h6&gt;5.离e点最近的还是5，继续取周围点标记为6&lt;/h6&gt;

&lt;h6&gt;6.离e点最近的还是6，取它周围的点标记为7&lt;/h6&gt;

&lt;h6&gt;7.离e点最近的还是7，取它最近的点标记为8&lt;/h6&gt;

&lt;h6&gt;8.离e点最近的是8，取它周围的点标记为9&lt;/h6&gt;

&lt;h6&gt;9.离e点最近的是9，取它周围的点标记为10&lt;/h6&gt;

&lt;h6&gt;10.离e点最近的为左边的10，取它周围的点时发现到达目的地e，结束。&lt;/h6&gt;

&lt;p&gt;上述过程明晰的阐述了A星算法贪婪的全过程，即只选择当前的最优选择，因为只关注当前的最优解，就忽视了对全局的最优解，走‘弯路’是常有的事。&lt;/p&gt;

&lt;p&gt;体现在代码上为如下伪代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;        function find_path(s,e)
        {
            open = new list(); //没有被取到过的点
            close = new list(); //已经被取过的点

            open.add(s); //从s点开始

            for(!open.IsEmpty()) //重复遍历直到没有点可以取
            {
                open.sort(); //排序一下

                p = open.pop(); //把最近的点推出来

                if(p == e)
                {
                    //找到终点
                    break;
                }

                p1 = p.left(); //取左边的点
                p2 = p.right(); //取右边的点
                p3 = p.top(); //取上边的点
                p4 = p.down(); //取下边的点

                //是否已经被取过
                if(p1 != null &amp;amp;&amp;amp; p1.IsNotInClose())
                {
                    //加入到没被取过的列表里
                    open.add(p1);
                }

                //是否已经被取过
                if(p2 != null &amp;amp;&amp;amp; p2.IsNotInClose())
                {
                    //加入到没被取过的列表里
                    open.add(p2);
                }

                //是否已经被取过
                if(p3 != null &amp;amp;&amp;amp; p3.IsNotInClose())
                {
                    //加入到没被取过的列表里
                    open.add(p3);
                }

                //是否已经被取过
                if(p4 != null &amp;amp;&amp;amp; p4.IsNotInClose())
                {
                    //加入到没被取过的列表里
                    open.add(p4);
                }

                //p点已经被取过了
                p.setClose(false);
                close.add(p);
            }
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述伪代码完整的诠释了A星寻路的全过程。&lt;/p&gt;

&lt;p&gt;当地图很大的时候，或者使用A星算法的寻路频率很高的时候，普通的A星算法就会消耗大量的CPU性能急剧下降，普通的A星性能还是不过关。接下来我们讲讲A星寻路在遇到性能瓶颈时的优化方案。&lt;/p&gt;

&lt;h3&gt;一、长距离导航&lt;/h3&gt;

&lt;p&gt;当距离很大，中间有很多障碍物时，A星的算法就会遇到瓶颈，不断加入的可行走点使得排序速度越来越慢，最后可能造成CPU阻塞无法动弹。&lt;/p&gt;

&lt;p&gt;当寻路距离太大时怎么办？&lt;/p&gt;

&lt;p&gt;其实路径不是非得实时计算出来才好，我们可以把一些常用的路径，在离线下算好放在数据文件中，游戏开启时放在内存里，当需要寻路到那个节点或者那个节点附近时，就可以取出来直接使用，而不再需要计算。&lt;/p&gt;

&lt;p&gt;比如 A到B 我们已经算法路径并存放在了内存里，当我们在A附近，要寻路到B附近时，就可以先寻路到A，再调出A到B的路径，再计算B到目的的路径。&lt;/p&gt;

&lt;p&gt;以这种方式来规避一些计算量特别大，或者计算频率特别高的寻路算法调用，在大型世界的RPG游戏里特别常用。&lt;/p&gt;

&lt;p&gt;另一种方法为制作导航点的方式。什么是导航点呢？就是去目的地的必经的点位。&lt;/p&gt;

&lt;p&gt;比如在一座城市里，有4个出口点，这个4个出口点就可以称为导航点，去目的地的路上肯定会经过这4个点的其中一个，我们在寻路时可以先寻找到最近的一个出口的导航点，当到达导航点后，再次寻找到目的地去的路径，有可能在这条路径上，还有一些导航点，继续寻找最近的导航点，依次类推，直到没有导航点可寻时，则直接寻路到目的地。&lt;/p&gt;

&lt;h3&gt;二、A星的排序算法优化&lt;/h3&gt;

&lt;p&gt;每次插入open列表的点后，open就不再是有序的队列了，所以每次去拿最小值时都需要重新排序。排序的时间消耗随着队列长度的增大而增大，其实有很大一部分A星的性能消耗都在排序上。&lt;/p&gt;

&lt;p&gt;那么是不是可以不排序，其实可以不排序，而使用找到插入位置并插入的方法，让队列永远保持有序状态。&lt;/p&gt;

&lt;p&gt;因为open队列在插入前是有序的，所以我们可以选用二分查找算法来找到插入的位置。&lt;/p&gt;

&lt;p&gt;每次插入时都使用二分查找算法查找插入点，那么每次的插入复杂度为O(logN)，比快排一次的O(NlogN)要快很多。&lt;/p&gt;

&lt;h3&gt;三、优化排序判断依据的预测值计算方法&lt;/h3&gt;

&lt;p&gt;前面用图所举的例子中，都是以当前点p与终点e之间的距离来作为预测值，这种方法简单但也不科学，导致A星寻找更好的点位时总是要绕很大的弯路。&lt;/p&gt;

&lt;p&gt;我们可以改变一下这个策略，选用一个更科学的方法， F 预测值= G 当前最近步数 + H 预测当前点到终点的步数 的方法。&lt;/p&gt;

&lt;p&gt;F 为预测值，G为起点s到当前点p的最近步数，H为当前点p到终点e的预测值，它们相加为F预测值。&lt;/p&gt;

&lt;p&gt;其中G应该是已经计算好并放入节点中的值，该值就是计算过程中起点s到当前点的步数。我们可以把每步计算好的步数都放入节点中，以待需要计算时使用。&lt;/p&gt;

&lt;p&gt;这个方法相当于，原来只关注当前点到终点的距离，变为关注起点s经过当前点p路径到终点e的距离，虽然还是贪婪的简单预测算法，但比起原来只关注当前点p与终点e的距离，更加科学化，能更快的找到更好更近的点位。&lt;/p&gt;

&lt;p&gt;为什么要改善这个预测值，改善预测值有什么意义呢？&lt;/p&gt;

&lt;p&gt;其实预测值的计算方法代表了在寻路过程中的走法，如果预测值只关注在于终点距离最近的点上，那么在寻路过程中的选择点位的顺序就会偏向于与终点更近的点。而如果预测值计算公式，关注的是整个距离较近的点位上，那么在寻路过程中在选择点位上也就会偏向整条路径短的方向上去靠。&lt;/p&gt;

&lt;h3&gt;四、多次频繁A星寻路的优化&lt;/h3&gt;

&lt;p&gt;多次频繁寻路中，对A星算法中每个运算，每行代码的运算细节都会有比较重大的考验。&lt;/p&gt;

&lt;p&gt;比如我们在查看一个节点是否为被取过的节点，即是否为Close，很多人都会在Close里取寻找该节点是否存在，这个操作明显就没有考虑到性能的消耗，要在Close列表中找节点，就相当于遍历一遍所有已经找过的节点，Close里的节点越多，越浪费CPU，而且是不只一次浪费，每个循环都会浪费一次，性能消耗巨大。&lt;/p&gt;

&lt;p&gt;因此我们通常的做法是把节点作为一个实例，在实例中添加IsClose的变量，来判断是否被取过，或者说是否Close。&lt;/p&gt;

&lt;p&gt;但这种方法还是不够，因为IsClose变量是要初始化的，每次寻路都要将前面寻路过的痕迹抹去才能开始全新的寻路过程。&lt;/p&gt;

&lt;p&gt;这就是又一个被很多人忽视的初始化的性能消耗，每次在A星寻路开始前，需要将IsClose的变量初始化为false，就需要遍历整个数据来初始化。&lt;/p&gt;

&lt;p&gt;每次都要遍历整个数据的话，A星算法无论优化的多快都无济于事了，因为初始化的性能消耗就已经将A星的性能消耗完全盖掉了。如果初始化的性能消耗需要遍历整个数据，那么优化A星算法的意义何在。&lt;/p&gt;

&lt;p&gt;其实可以用一个变量就能判断IsClose的方法，无需初始化。&lt;/p&gt;

&lt;p&gt;我们可以在寻路类中设置一个属性变量FindIndex，或者专门为寻路服务的静态变量也可以，而每个寻路节点中也存有一个变量FindIndex，每次寻路前都对FindIndex++，在判断IsClose时，当节点中的FindIndex与寻路类中FindIndex一致时说明已经被当次寻路算法取出过，否则两者不一样，说明这个节点没有被取出过，当节点被取出时，节点里的FindIndex则设置为当前寻路类中的FindIndex值，以表明该节点已经被这次寻路算法取出过。&lt;/p&gt;

&lt;p&gt;用一个变量和整数的比较就能知道IsClose的结果，省去了巨量的初始化操作。&lt;/p&gt;

&lt;h6&gt;在A星算法这种经常用频繁用的算法中，一个小小的性能消耗就能放大很多倍，特别注意调用的函数的复杂度，公式的复杂度，以及运算的优化，尽量做到能不调用函数的不调用函数，能简化公式的尽量简化公式，能用&amp;amp;|&amp;lt;&amp;gt;位运算符号代替加减乘除的尽量用位运算代替，节省A星算法的性能开销。&lt;/h6&gt;

&lt;h6&gt;我也看过所谓的B星算法过程，其实世上没有B星，所谓的B星其实就是我们A星的优化版本，而且互联网中所阐述的B星算法存在一定几率无法寻到路径的问题，即它只关注所谓的‘前方‘，而忽略了其实’后方‘也有路，如果只有后方有路时，B星就无法找到路径。&lt;/h6&gt;
</description>
               <pubDate>Sat, 22 Jun 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/06/22/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E5%9C%B0%E5%9B%BE%E4%B8%8E%E5%AF%BB%E8%B7%AF1.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/06/22/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E5%9C%B0%E5%9B%BE%E4%B8%8E%E5%AF%BB%E8%B7%AF1.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第六章，网络层(五) - 剖析数据协议原理</title>
               <description>&lt;h6&gt;协议包的格式，json, msgpack, protobuf 以及自定义格式&lt;/h6&gt;

&lt;p&gt;项目的网路层在建设中，除了选择长短连接TCP，UDP，HTTP方式外，还需要选择在传输过程中使用什么样的协议格式。&lt;/p&gt;

&lt;p&gt;前面分析了TCP，UDP，HTTP的原理与应用，现在我们来了解下在传输层和应用层之上的逻辑层中，信息传递格式的选择与利弊。&lt;/p&gt;

&lt;p&gt;我们将深入剖析JSON，MessagePack，Protobuf的原理，包括它们都是由什么组成的，怎么序列化的，怎么反序列化的，数据格式究竟是由哪些元素构成的，使我们对网络数据协议的理解更加透彻清晰。&lt;/p&gt;

&lt;p&gt;我们以最常见的JSON格式作为切入点，一步步深入了解更加有效却复杂的传递格式。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h6&gt;JSON&lt;/h6&gt;

&lt;p&gt;JSON：JavaScript 对象表示法（JavaScript Object Notation）。它是存储和交换文本信息的语法。类似 XML，但比 XML 更小、更快，更易解析。&lt;/p&gt;

&lt;p&gt;JSON 是轻量级的文本数据交换格式，它独立于语言，具有自我描述性，更易理解。&lt;/p&gt;

&lt;p&gt;JSON 是属于纯文本，具有“自我描述性”（人类可读），具有层级结构（值中存在值）&lt;/p&gt;

&lt;p&gt;JSON与同时纯文本类型格式的XML相比较，JSON不需要结束标签，JSON更短，JSON解析和读写的速度更快，在JavaScript中能够使用内建的 JavaScript eval() 方法进行解析，JSON还可以使用数组，切不使用保留字（&amp;amp;，&amp;lt;，&amp;gt;，&amp;#39;，&amp;quot;）。&lt;/p&gt;

&lt;p&gt;JSON 语法规则：&lt;/p&gt;

&lt;p&gt;JSON 数据的书写格式是：名称/值对。&lt;/p&gt;

&lt;p&gt;名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值：&lt;/p&gt;

&lt;p&gt;&amp;quot;firstName&amp;quot; : &amp;quot;John&amp;quot;&lt;/p&gt;

&lt;p&gt;JSON数据由逗号分隔，它的值可以是：&lt;/p&gt;

&lt;p&gt;数字（整数或浮点数）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;{
  &amp;quot;number&amp;quot; : 1,
  &amp;quot;number2&amp;quot; : 11.5
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;字符串（在双引号中）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;{
  &amp;quot;str1&amp;quot; : &amp;quot;1&amp;quot;,
  &amp;quot;str2&amp;quot; : &amp;quot;11&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;逻辑值（true 或 false）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;{
  &amp;quot;logic1&amp;quot; : true,
  &amp;quot;logic2&amp;quot; : false
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;数组（在方括号中）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;{
   &amp;quot;array1&amp;quot; : [1,2,3],
   &amp;quot;array2&amp;quot; : [{&amp;quot;str1&amp;quot;,1},{&amp;quot;str2&amp;quot;,2},{33,44}]
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对象（在花括号中）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;{
  &amp;quot;obj1&amp;quot; : {1, &amp;quot;str1&amp;quot;, true},
  &amp;quot;obj2&amp;quot; : {&amp;quot;str2&amp;quot;, 2, false},
  &amp;quot;obj3&amp;quot; : null
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JSON 对象在花括号中书写：&lt;/p&gt;

&lt;p&gt;对象可以包含多个名称/值对：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;{ &amp;quot;firstName&amp;quot;:&amp;quot;John&amp;quot; , &amp;quot;lastName&amp;quot;:&amp;quot;Doe&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JSON 数组在方括号中书写：&lt;/p&gt;

&lt;p&gt;数组可包含多个对象：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;{
    &amp;quot;employees&amp;quot;: [
        { &amp;quot;firstName&amp;quot;:&amp;quot;John&amp;quot; , &amp;quot;lastName&amp;quot;:&amp;quot;Doe&amp;quot; },
        { &amp;quot;firstName&amp;quot;:&amp;quot;Anna&amp;quot; , &amp;quot;lastName&amp;quot;:&amp;quot;Smith&amp;quot; },
        { &amp;quot;firstName&amp;quot;:&amp;quot;Peter&amp;quot; , &amp;quot;lastName&amp;quot;:&amp;quot;Jones&amp;quot; }
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JSON 文件的文件类型通常是 &amp;quot;xxx.json&amp;quot; 用来扩展名用来说明是json格式的文本文件&lt;/p&gt;

&lt;p&gt;JSON 文本的 MIME 类型是 &amp;quot;application/json&amp;quot; (MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准。MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。)&lt;/p&gt;

&lt;p&gt;JSON 解析器可以用些比较常用的，比如simpleJson，MiniJson，DataContractJsonSerializer，JArray，JObject等等，都是非常通用高效的插件。&lt;/p&gt;

&lt;h6&gt;自定义二进制流协议格式&lt;/h6&gt;

&lt;p&gt;大部分的网络协议都具有一定的通用性，JSON是最典型的案例，XML，MessagePack，Protobuf都具有一定的通用性，但自定义二进制流协议格式则不是，它完全不通用，因为它不需要顾及通用性。&lt;/p&gt;

&lt;p&gt;我们在存储一串数据的时候，无论这串数据里包含了哪些数据以及哪些数据类型，当我们拿到这串数据在解析的时候能够知道该怎么解析，这是定义协议格式的目标。&lt;/p&gt;

&lt;p&gt;简单的来说就是，当你传给我一串数据的时候，我是用什么样的规则知道这串数据里的内容的。JSON就制定了这么一个规则，这个规则以字符串KEY-VALUE，以及一些辅助的符号‘{’,&amp;#39;}&amp;#39;,&amp;#39;[&amp;#39;,&amp;#39;]&amp;#39;组合而成，这个规则非常通用，以至于任何人拿到任何JSON数据都能知道里面有什么数据。&lt;/p&gt;

&lt;p&gt;自定义二进制流协议格式则不具有通用性，不是任何人拿到数据都能知道里面装的是什么的，有且只有两端在私下协定的双方才知道该如何解析收到的数据，对于破解自定义二进制流的内容也只有靠猜，虽然猜的难度也不是非常大。&lt;/p&gt;

&lt;p&gt;一个自定义二进制流协议格式，分成三部分：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;数据大小|协议编号|具体数据
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;数据大小、协议编号、具体数据，这三者构成了一个完整的协议内容，这一整个协议内容少了谁都不成，不过有时数据大小和协议编号的前后顺序可以交换。&lt;/p&gt;

&lt;p&gt;我们举例来描述这个协议格式，假设我们客户端有这样一个数据结构需要传输到服务端去：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;struct test
{
  int test1;
  float test2;
  bool test3;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;服务端拿到数据时，其实完全不知道当前拿到的数据是什么，也不知道数据是否完整，有可能只拿到一半的数据，或者一部分的数据。&lt;/p&gt;

&lt;p&gt;首先我们要确定的是，我们收到的数据包它的完整的大小有多大，只有知道完整的包体大小才能确定我当前收到的数据在大小上是否完整，我们是要等待继续接受后面的数据，还是现在就可以进行解析操作了。&lt;/p&gt;

&lt;p&gt;为了确定包的完整性，我们必须先向二进制流中读取4个比特，组合成一个无符号整数，这个整数总共32位，也就是说我们的数据包的大小最大为2的32次减1个byte，然后再用来确定接下来的完整包体大小。&lt;/p&gt;

&lt;p&gt;例如我现在接受到了20个byte，读取前4个，组成一个整数后为24，说明我接受到的后面16个byte是一个不完整的包体，我应该继续等待后续的数据到来。&lt;/p&gt;

&lt;p&gt;其次我们要确定的是收到的数据包是属于哪个格式的协议。&lt;/p&gt;

&lt;p&gt;于是再读取4个byte大小的数据，组成一个无符号整数，用来确定协议号。比如这个无符号整数位为1002，就代表是编号为1002的协议。&lt;/p&gt;

&lt;p&gt;假设我们上面这个test结构的协议号是1002，那么接下来连着这个协议号的所有数据直到包体大小的末尾，都是这个test结构的数据。&lt;/p&gt;

&lt;p&gt;在解析这个具体数据的时候，要根据生成这个数据的顺序来解析。&lt;/p&gt;

&lt;p&gt;假设在生成这个二进制流数据时，我们的顺序是，先推入test1，再推入test2，再推入test3。test1是4个byte的整数，test2是4个byte的浮点数，test3是1个byte的布尔值，于是就有了&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;xxxx|xxxx|x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样一个形状的二进制流，每个‘x’为一个byte，这里4个byte组成一个int或float数据，1个byte组成布尔数据，‘|’只是为了解释说明用的分隔符不存在于数据内，这个数据其实就是由9个byte组成，其中前4个为test1，中间4个为test2，后面1个为test3。&lt;/p&gt;

&lt;p&gt;那么在网络传输过程中整个test结构的数据包格式为如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;13|1002|test1|test2|test3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;13为接下来的数据大小，1002位协议编号，test1|test2|test3为具体数据。&lt;/p&gt;

&lt;p&gt;我们在解析的时候也需要按照生成时的顺序来解析，先读取前4个byte组成一个整数赋值给test1，接着再读取4个byte组成一个浮点数赋值给test2，接着再读取1个byte赋值给test3，完成数据解析。&lt;/p&gt;

&lt;p&gt;对于数组形式的数据则要在原来的基础上多增加一个长度标志，比如 int[]类型数据，在生成时先推入一个长度，再连续推入所有内容，在解析的时候做同样的反向操作，先读取4个byte的长度标志，再对连续读取N个具体数据，这个N为长度标志。&lt;/p&gt;

&lt;p&gt;举例int[]为3个整数数组则二进制为如下效果：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;xxxx|xxxx|xxxx|xxxx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前4个byte为长度，接着3次4个byte为数组内的整数数据。&lt;/p&gt;

&lt;p&gt;自定义二进制流协议格式为最不通用的格式，但也是最节省流量的协议，因为每个数据都可以用最小的方式进行定义，比如协议号不需要4个byte，2个byte大小2的16次-1就够用了，长度有可能也不需要4个byte，只要2个甚至1个byte就够用了，有些数据不需要4个byte组成int整数，只需要2个byte数组short就够用了，甚至有些可以组合起来使用，比如协议结构中有4个bool，可以拼成一个byte来传递，这些都可以完全由我们来控制包体的大小不受到任何规则的限制，这也是自定义二进制协议格式最吸引人的地方。&lt;/p&gt;

&lt;p&gt;自定义二进制流协议格式最大的缺点是不通用，当我们需要更换一个协议格式的时候，旧的协议格式就无法解析了，特别是当新的协议解析旧的协议时就会报错。我们也可以做些补救这种问题的措施，为了能让旧的协议格式还能继续使用，我们在每个数据头部都加入一个2个byte的整数代表版本号，由版本号来决定该读取哪个版本的协议，这样旧的协议也照样可以兼容新的协议，只是处理起来的时候需要注意些初始化问题，那些旧协议没有的而新协议有的数据则要尽可能的初始化成默认值以免造成逻辑报错。&lt;/p&gt;

&lt;h6&gt;MessagePack&lt;/h6&gt;

&lt;p&gt;MessagePack 是一个介乎于JSON和自定义二进制流之间的协议格式，他的理念是 ‘It’s like JSON. but fast and small.’ 。&lt;/p&gt;

&lt;p&gt;与JSON相同的是MessagePack也有采用Key-Value形式的Map映射类型，不同的是MessagePack用byte形式存储整数、浮点数、布尔值，并且在Map映射类型外加入了更多单独类型（非KEY-VALUE形式）的数据类型，其中也包括了自定义二进制流的数据类型。&lt;/p&gt;

&lt;p&gt;其中map映射类型是比较常用，也是比较通用的存储形式类型，也因为它的通用性被很多程序员所喜爱。&lt;/p&gt;

&lt;p&gt;使用起来能和JSON用起来一样，并且数据大小比JSON小，解析速度又比JSON快，是MessagePack最大的特点。&lt;/p&gt;

&lt;p&gt;非map类型的数据，其实和自定义二进制流的存储方式差不多，只是把原来的‘数据大小|数据’的形式改为了‘类型|数据’，比如存储一个4个byte也就是32位的整数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;+--------+--------+--------+--------+--------+
|  0xd2  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|
+--------+--------+--------+--------+--------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个byte的值0xd2代表32位整数类型，它表示后面4个byte组合起来是整数类型的数据。&lt;/p&gt;

&lt;p&gt;再举个列子，32位的浮点数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;+--------+--------+--------+--------+--------+
|  0xca  |XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|
+--------+--------+--------+--------+--------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个byte的值0xca代表32位浮点数类型，它表示后面4个byte组合起来是浮点数类型的数据。&lt;/p&gt;

&lt;p&gt;以此类推，nil，bool，8位无符号整数，16位无符号整数，32位无符号整数，64位无符号整数，8位有符号整数，16位有符号整数，32位有符号整数，64位有符号整数等，以及32位浮点数，64位浮点数，都用这种类似的方式表示。&lt;/p&gt;

&lt;p&gt;其实用MessagePack并不是冲着这些单独的数据类型去的，因为这些单独的数据类型完全可以用自定义二进制流代替，我们最关心的其实是它的map类型数据。&lt;/p&gt;

&lt;p&gt;我们专门来看看，MessagePack的map类型的存储机制，为什么就比JSON快，为什么就比JSON小，它是如何存储和解析的。&lt;/p&gt;

&lt;p&gt;在map之前我们看看数组类型的格式：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;+--------+--------+--------+~~~~~~~~~~~~~~~~~+
|  0xdc  |YYYYYYYY|YYYYYYYY|    N objects    |
+--------+--------+--------+~~~~~~~~~~~~~~~~~+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个byte的值0xdc代表是个总共可以存储16位长度的数组，也就是最大为2的16次-1个元素的数组，后面2个byte组合起来成为一个无符号的整数代表后面有多少个元素，接着后面N个为相同类型的元素的数据。&lt;/p&gt;

&lt;p&gt;假设说这N个为32位整数类型，那么就是如下格式&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;+--------+--------+--------+~~~~~~~~~~~~~~~~~+
|  0xdc  |00000000|00000011|  0xd2|00001001|0xd2|00001101|...(3 objects)
+--------+--------+--------+~~~~~~~~~~~~~~~~~+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个数组中指定了数组类型，以及数组元素的个数，接下来的数据就是单个元素的数据了，每个数据都包含了‘类型|数据’格式。&lt;/p&gt;

&lt;p&gt;其实map类型就是Array数组类型的变种，在数组类型上每个元素，多加了个KEY字符串，我们来看下map的格式：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;+--------+--------+--------+~~~~~~~~~~~~~~~~~+
|  0xde  |YYYYYYYY|YYYYYYYY|   N*2 objects   |
+--------+--------+--------+~~~~~~~~~~~~~~~~~+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个byte的值0xde代表是最大个数为16位的map类型数据，接着2个byte组合起来表示有多少个元素，再接着N乘2个元素为数据元素，其中以2个元素为一个组合，第一元素一定是字符串KEY，第二个元素为单独的任意的数据类型。&lt;/p&gt;

&lt;p&gt;我们用官方的例子来分析下：&lt;/p&gt;

&lt;p&gt;一个JSON类型的数据：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;{&amp;quot;compact&amp;quot;:true, &amp;quot;schema&amp;quot;:0}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在MessagePack中的map格式为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;82|A7|&amp;#39;c&amp;#39;|&amp;#39;o&amp;#39;|&amp;#39;m&amp;#39;|&amp;#39;p&amp;#39;|&amp;#39;a&amp;#39;|&amp;#39;c&amp;#39;|&amp;#39;t&amp;#39;|C3|A6|&amp;#39;s&amp;#39;|&amp;#39;c&amp;#39;|&amp;#39;h&amp;#39;|&amp;#39;e&amp;#39;|&amp;#39;m&amp;#39;|&amp;#39;a&amp;#39;|00|
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中8位前半个byte的值代表是个15个以内的map类型数据，8后面的2是后半个byte的值，代表总共有2个元素。&lt;/p&gt;

&lt;p&gt;接着A为前半个byte的值，代表是是个31个以内的字符串，A后面的7代表这个字符串拥有7个字符。&lt;/p&gt;

&lt;p&gt;接着7个元素都是字符。&lt;/p&gt;

&lt;p&gt;接着C3是KEY-VALUE的VALUE，这个VALUE是一个bool型的ture值。&lt;/p&gt;

&lt;p&gt;接着A6，A为前半个byte代表是31个以内的字符串，A后面的6代表这个字符串有6个字符。&lt;/p&gt;

&lt;p&gt;接着6个元素都是字符。&lt;/p&gt;

&lt;p&gt;最后00，前面0为前半个byte，表示类型为7位以内的整数，接着的0位后半个byte，代表数据为0。&lt;/p&gt;

&lt;p&gt;MessagePack整个map就是以这种“类型|数据”或者&amp;quot;类型|大小|数据&amp;quot;的方式存储。由于存储的方式是顺序，所以在解析的时候不需要排序，不需要解析符号和类型，数据的类型直接可以用byte来表示，能用byte存储绝不用字符串形式存储，能减少byte使用个数的尽量减少byte的使用个数，能合并的尽量合并为一个byte。&lt;/p&gt;

&lt;p&gt;因此MessagePack对于JSON来说，比JSON减少了大量的解析，比JSON减少了更多的数据空间，使得MessagePack能比起JSON来更快并且更小，就像它自己所说的那样 ‘It’s like JSON. but fast and small.’。&lt;/p&gt;

&lt;h3&gt;Protocol Buffer&lt;/h3&gt;

&lt;p&gt;虽然Proto3在Proto2之上又做了更多的改进，但我们这里以Proto2为基准来讲解Protocal buffer的内在机制。&lt;/p&gt;

&lt;p&gt;MessagePack在JSON之上做了优化，其实可以看做是，把JSON和自定义二进制的合并做法，既汲取了JSON这种KEY-VALUE(键值对)通用性的优点，又汲取了自定义二进制流格式无需解析和存储空间小的特点。&lt;/p&gt;

&lt;p&gt;不过MessagePack的Map毕竟是kEY-VALUE形式的KEY值还是使用了字符串类型，它的KEY还是逃脱不了字符串string占用太多存储空间的弊端。&lt;/p&gt;

&lt;p&gt;Google Protocol Buffer 的出现就弥补了MessagePack的这个缺点，但是Google Protocol Buffer也有自身不可忽视的缺点，我们来看究竟Google Protocol Buffer是怎么的一种数据协议。&lt;/p&gt;

&lt;p&gt;Google Protocol Buffer( 简称 Protobuf) 是 Google 公司内部的混合语言数据标准，它们用于 RPC 系统和持续数据存储系统。&lt;/p&gt;

&lt;p&gt;Protobuf 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。&lt;/p&gt;

&lt;p&gt;常有人推崇说 Protocol Buffer 比JSON、MessagePack要好，那么它究竟好在哪里呢？我们就来分析下，为什么有这么多人推崇它。&lt;/p&gt;

&lt;p&gt;我们选择数据协议的目的主要关注的点是，它是否能更简单上手，解析数据是否能更快，存储空间是否能更小，通用性是否能更强。对于这些特点，Protocol Buffer 是否能都做到，还是说它只是在部分几个方面做到了，下面我们来透彻的对它剖析。&lt;/p&gt;

&lt;h6&gt;Protocol Buffer消息定义&lt;/h6&gt;

&lt;p&gt;创建扩展名为.proto的文件，如：MyMessage.proto，并将以下内容存入该文件中。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;message LoginReqMessage {
  required int64 acct_id = 1;
  required string passwd = 2;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;message是消息定义的关键字，等同于C#中的struct/class。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LoginReqMessage为消息的名字，等同于结构体名或类名。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;required前缀表示该字段为必要字段。即在序列化和反序列化之前该字段必须已经被赋值。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;与required相似的功能还存在另外两个类似的关键字，optional和repeated。&lt;/p&gt;

&lt;p&gt;optional表示该字段为可选字段，即在序列化和反序列化前可以不进行赋值。&lt;/p&gt;

&lt;p&gt;相比于optional，repeated主要用于表示数组字段。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;int64和string分别表示64位长整型和字符串型的消息字段。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在Protocol Buffer中存在一张类型对照表，既Protocol Buffer中的数据类型与其他编程语言(C#/Java/C++)中所用类型的对照。&lt;/p&gt;

&lt;p&gt;该对照表中还将给出在不同的数据场景下，哪种类型更为高效。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;acct_id 和 passwd 分别表示消息字段名，等同于C#中的域变量名。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;标签数字 1 和 2 表示不同的字段在序列化后的二进制数据中的布局位置。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在该例中，passwd 字段编码后的数据一定位于 acct_id 之后。需要注意的是该值在同一message中不能重复。&lt;/p&gt;

&lt;p&gt;对于Protocol Buffer而言，标签值为 1 到 15 的字段在编码时可以得到优化，即标签值和类型信息仅占有一个byte，标签范围是 16 到 2047 的将占有两个bytes，而Protocol Buffer可以支持的字段数量则为2的29次方减1。有鉴于此，我们在设计消息结构时，可以尽可能考虑让repeated类型的字段标签位于1到15之间，这样便可以有效的节省编码后的字节数量。&lt;/p&gt;

&lt;h6&gt;嵌套Protocol Buffer&lt;/h6&gt;

&lt;p&gt;我们可以在同一个.proto文件中定义多个message，这样便可以很容易的实现嵌套消息的定义。如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;required&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;required&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;optional&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;email&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

      &lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PhoneType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;MOBILE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;HOME&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;WORK&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

      &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PhoneNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;required&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;optional&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PhoneType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

      &lt;span class=&quot;n&quot;&gt;repeated&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PhoneNumber&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phones&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;repeated&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weight_recent_months&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;packed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AddressBook&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;repeated&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;people&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;AddressBook消息的定义中包含另外一个消息类型作为其字段Person，Person又包含了另一个消息类型作为字段PhoneNumber。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其中的 AddressBook 和 Person 被定义在同一个.proto文件中，也可以被分开来定义在各自的.proto文件中。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Protocol Buffer提供了另外一个关键字import，相当于 C++ 的Include，这样我们便可以将很多通用的message定义在同一个.proto文件中，而其他各模块功能的消息体定义在其他文件中，再通过import的方式将需要的结构体文件中定义的消息包含进来，如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;import &amp;quot;myproject/CommonMessages.proto&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;限定符 required、optional、repeated 的规则&lt;/h6&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在每个消息中必须至少有一个required类型的字段，保证数据中一定有至少一个数据。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;required限定符表示该字段为必要字段。即在序列化和反序列化之前该字段必须已经被赋值。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个消息中可以包含0个或多个optional类型的字段。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;optional表示该字段为可选字段，即在序列化和反序列化前可以不进行赋值，如果没有赋值则表示该数据为空。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;repeated表示的字段可以包含0个或多个重复的数据。注意，是重复的数据，可以等价于我们常使用的数组和列表，并且可以不赋值，则表示0个数据。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5&gt;Protocol Buffer 原理-序列化和反序列化&lt;/h5&gt;

&lt;p&gt;Protocol Buffer 是怎么识别和存储数据的，是序列化和反序列的关键。&lt;/p&gt;

&lt;p&gt;JSON 和 MessagePack 都使用了字符串的KEY作为映射到程序变量的关键字，变量和字符串用比较字符串的是否相等来判断是否为该变量，避免不了字符串太多而浪费空间。&lt;/p&gt;

&lt;p&gt;Protocol Buffer 则用数字编号来作为KEY的关键字，每个变量都必须有个不能重复的标签号(即数字编号)，用变量后面跟着的数字编号来映射到数据中的数字编号，进而读取数据。&lt;/p&gt;

&lt;p&gt;Protocol Buffer为每个变量都定义了一个标签号(即数字编号)，这个数字编号就代表了程序变量与指定编号数据的映射关系。&lt;/p&gt;

&lt;p&gt;有了这个规则还不够，因为程序在读取的时候，是不知道某个变量到底对应哪个标签号的，比如上面的Person的 name 变量，在程序里的 name 变量是不知道到底该读取哪个编号的数据的，除非在程序里写死。&lt;/p&gt;

&lt;p&gt;Protocol Buffer 就是使用了这种简单粗暴的方法，‘在程序里写死’的这种方式让事情变得更简单。&lt;/p&gt;

&lt;p&gt;‘在程序里写死’这种粗暴的方式最讲究周边工具了，Protocol Buffer就为很多种语言定制了生成序列化和反序列化程序代码的工具。只需要通过提供.proto文件就能生成相应语音的程序代码，在代码中把编号‘写死’，这一切代码都是自动生成的，我们只需要关心.proto文件中的结构。&lt;/p&gt;

&lt;p&gt;以就是说，当Protocol Buffer生成的解析代码在读数据的时候，一旦读取到编号为1的数据时，就把数据解析给 name 这个程序变量，这些都写死在代码中，而代码由Protocol Buffer工具生成。&lt;/p&gt;

&lt;h6&gt;我们使用上面提到的 AddressBook 数据结构来序列化一个 Protocol Buffer 数据。&lt;/h6&gt;

&lt;p&gt;加入数据的伪代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AddressBook&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address_book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address_book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add_people&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set_id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Jack&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set_email&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Jack@qq.com&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;PhoneNumber&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phone_number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_phones&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;phone_number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set_number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;123456&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;phone_number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;phone_number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add_phones&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;phone_number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set_number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;234567&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;phone_number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MOBILE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_weight_recent_months&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_weight_recent_months&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;52&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_weight_recent_months&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;54&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成出来的二进制数据流如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// (1 &amp;lt;&amp;lt; 3) + 2 = 0a，1为people的标签号,2为嵌入结构对应的类型号&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 0x3c = 60，表示接下来60个字节为Person的数据&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 下面进入到 repeated Person 数组的数据结构&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// (1 &amp;lt;&amp;lt; 3) + 2 = 0a，Person的第一个字段name的标签号为1，2为string(字符串)对应的类型号&lt;/span&gt;
&lt;span class=&quot;mo&quot;&gt;04&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// name字段的字符串长度为4&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;61&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;63&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// &amp;quot;Jack&amp;quot; 的ascii编码&lt;/span&gt;

&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// (2 &amp;lt;&amp;lt; 3) + 0 = 10，字段id的标签号为2，0为int32对应的类型号&lt;/span&gt;
&lt;span class=&quot;mo&quot;&gt;01&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// id的整型数据为1&lt;/span&gt;

&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// (3 &amp;lt;&amp;lt; 3) + 2 = 1a，字段email的标签号为3，2为string对应的类型号&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 0x0b = 11 email字段的字符串长度为11&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;61&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;63&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;71&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;71&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;63&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;6f&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;6d&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// &amp;quot;Jack@qq.com&amp;quot;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//第1个PhoneNumber，嵌套message&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// (4 &amp;lt;&amp;lt; 3) + 2 = 22，phones字段，标签号为4，2为嵌套结构对应的类型号&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 0a = 10，接下来10个字节为PhoneNumber的数据&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// (1 &amp;lt;&amp;lt; 3) + 2 =  0a, PhoneNumber的number，标签号为1，2为string对应的类型号&lt;/span&gt;
    &lt;span class=&quot;mo&quot;&gt;06&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// number字段的字符串长度为6&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;33&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;34&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;35&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;36&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// &amp;quot;123456&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// (2 &amp;lt;&amp;lt; 3) + 0 = 10，PhoneType type字段，0为enum对应的类型号&lt;/span&gt;
    &lt;span class=&quot;mo&quot;&gt;01&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// HOME，enum被视为整数&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 第2个PhoneNumber，嵌套message&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;06&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;33&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;34&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;35&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;36&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;37&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;00&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//信息解读同上，最后的00为MOBILE&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;06&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 1010 0010 0000 0110 varint方式，weight_recent_months的key&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//  010 0010  000 0110 → 000 0110 0100 010 little-endian存储&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// (100 &amp;lt;&amp;lt; 3) + 2 = a2 06，100为weight_recent_months的标签号&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//  2为 packed repeated field的类型号&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 0c = 12，后面12个字节为float的数据，每4个字节一个数据&lt;/span&gt;
&lt;span class=&quot;mo&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;48&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// float 50&lt;/span&gt;
&lt;span class=&quot;mo&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// float 52&lt;/span&gt;
&lt;span class=&quot;mo&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;58&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// float 54&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整个数据看下来都是遵循了简单的规则，即，标签号 + 类型号，最为头部标识，数据大小标识，作为可选标识，最后放入具体数据：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;标签号 + 类型号|数据大小|具体数据
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体数据中再嵌套不同种类的数据，也同样遵循 ‘标签号 + 类型号|数据大小|具体数据’ 这样的规则。&lt;/p&gt;

&lt;h6&gt;二进制数据流中反序列化为程序对象数据，我们重点看看其中 Person 结构的反序列过程：&lt;/h6&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MergeFrom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CodedInputStream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ReadTag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_unknownFields&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UnknownFieldSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MergeFieldFrom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_unknownFields&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ReadString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ReadInt32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;email&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ReadString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;phones_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;AddEntriesFrom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_repeated_phones_codec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;weight_recent_months_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;AddEntriesFrom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_repeated_weight_recent_months_codec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上述Protocol Buffer生成的代码我们了解到，所有的对象变量都通过.proto文件中的标签号来识别数据是否与该变量有映射关系的，当拿到具体数据时，先判定属于哪个变量，再针对该变量的类型读取数据。&lt;/p&gt;

&lt;h6&gt;Protocol Buffer 不同版本消息的兼容问题&lt;/h6&gt;

&lt;p&gt;在实际的开发中会存在这样一种应用场景，即消息格式因为某些需求的变化而不得不进行必要的修改或者说升级，但是有些使用原有消息格式的应用程序暂时又不能被立刻升级，这便要求我们在升级消息格式时要遵守一定的规则，从而可以保证基于新老消息格式的新老程序能够同时运行。规则如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不要修改已经存在字段的标签号，即变量后面的数字，保证旧数据协议能够继续从数据中读取指定标签号的正确数据。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;任何新添加的字段必须是optional和repeated限定符，保证在旧数据无法加入新数据的情况下，新的协议还能够在旧数据协议之下继续顺利解析，否则无法保证新老程序在互相传递消息时的消息兼容性。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在原有的消息中，不能移除已经存在的required字段，虽然optional和repeated类型的字段可以被移除，但是他们之前使用的标签号必须被保留，不能被新的字段重用。因为旧协议在执行时还是会在旧的标签号中加入自己的数据，新协议如果使用了旧的标签号，就会导致新旧协议数据解析错误的问题。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;int32、uint32、int64、uint64和bool等类型之间是兼容的，sint32和sint64是兼容的，string和bytes是兼容的，fixed32和sfixed32，以及fixed64和sfixed64之间是兼容的，这意味着如果想修改原有字段的类型时，为了保证兼容性，只能将其修改为与其原有类型兼容的类型，否则就将打破新老消息格式的兼容性。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h6&gt;Protocol Buffer 的优点&lt;/h6&gt;

&lt;p&gt;Protobuf 全程使用二进制流形式，用整数代替了KEY来映射变量，比 XML、Json、MessagePack它们更小、更快、也更简单。&lt;/p&gt;

&lt;p&gt;我们可以定义自己的数据结构，然后使用Protobuf代码生成器生成的代码来读写这个数据结构。甚至可以在无需重新部署程序的情况下更新数据结构。只需使用 Protobuf 对数据结构进行一次描述，即可利用各种不同语言或从各种不同数据流中对你的结构化数据轻松读写。&lt;/p&gt;

&lt;p&gt;使用 Protobuf 无需学习复杂的文档对象模型，Protobuf 的编程模式比较友好，简单易学，同时它拥有良好的文档和示例，对于喜欢简单事物的人们而言，Protobuf 比其他的技术更加有吸引力。&lt;/p&gt;

&lt;p&gt;Protobuf 语义更清晰，无需类似 XML，JSON 解析器的东西，简化了解析的操作，减少了解析的消耗。&lt;/p&gt;

&lt;p&gt;Protobuf 数据使用二进制形式，把原来在JSON,XML里用字符串存储的数字换成用byte存储，大量减少了浪费的存储空间。与MessagePack相比，Protobuf减少了Key的存储空间，让原本用字符串来表达Key的方式换成了用整数表达，不但减少了存储空间也加快了反序列化的速度。&lt;/p&gt;

&lt;h6&gt;Protocol Buffer 的不足&lt;/h6&gt;

&lt;p&gt;Protbuf 与 XML 相比也有不足之处。它功能简单无法用来表示复杂的概念。&lt;/p&gt;

&lt;p&gt;XML 已经成为多种行业标准的编写工具，Protobuf 只是运用在数据传输与存储上，在通用性上还差很多。&lt;/p&gt;

&lt;p&gt;由于 XML 具有某种程度上的自解释性，它可以被人直接读取编辑，在这一点上 Protobuf 不行，它以二进制的方式存储，除非你有 .proto 定义，否则你没法直接读出 Protobuf 的任何内容。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;p&gt;《Protocol Buffers：阅读一个二进制文件》&lt;/p&gt;
</description>
               <pubDate>Sun, 16 Jun 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/06/16/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%825.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/06/16/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%825.html</guid>
            </item>
        
            <item>
               <title>《Unity3D高级编程之进阶主程》第六章，网络层(四) - 封装HTTP</title>
               <description>&lt;h3&gt;HTTP协议原理&lt;/h3&gt;

&lt;p&gt;HTTP俗称短连接，由于其连接的时间较短，不受前端所控制，所以在互联网开发圈内，通常被以‘短’字开头。&lt;/p&gt;

&lt;p&gt;在Unity3D短连接可以用.NET库来编写，也可以用U3D的内置API的WWW来写。差别不是很大，WWW对.Net做了封装，其功能已经完全够用在游戏开发上了，即使有情况不够用再用.NET补充也是很容易的事。(WWW在2018及以后的版本中都被废弃了，取代它的是UnityWebRequest，应该说封装的更好，但自定义部分则被削弱了。)&lt;/p&gt;

&lt;p&gt;其两者的区别主要还是WWW把.NET库封装后再加了层用协程使得我们开发者在使用时更加的便捷，.NET库则直接用了线程，导致开发者还需要关注主线程与子线程的资源锁。另外WWW里面已经实现了IP6转换，而使用.Net库则还需要自己解析IP6地址，虽然对程序员来说自己用.NET实现更加接近底层实现，但同时也带来了更多需要花精力关注的地方，夺走了程序员些许宝贵的精力。&lt;/p&gt;

&lt;p&gt;不管协程还是线程，其实两边都需要缓存和队列，如果没有缓存和队列，当网络请求量放大时就会出现数据丢失的情况。所以缓存机制在网络层是不可或缺的。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;我们所说的HTTP，最形象的描述就是网页(Web)形式的请求与回调。它被运用在最多的就是网页(Web)请求上，它是网页(Web) 上进行数据交换的基础。&lt;/p&gt;

&lt;p&gt;HTTP是一种 请求/响应式 的协议。也就是说，请求通常是由像浏览器这样的User-
Agent发起的，当像浏览器接收方收到数据后，再通过数据来处理相应的逻辑，每个请求都是一一对应的，一个请求有且最多只能得到一个响应。&lt;/p&gt;

&lt;p&gt;当我们要要展现一个网页时，浏览器首先发送一个请求，目的是从服务器获取页面的HTML文档，再解析文档中的资源信息然后才发送其他请求，例如获取可执行脚本或CSS样式来进行页面布局渲染，以及一些其它页面资源（如图片和视频等）。&lt;/p&gt;

&lt;p&gt;浏览器将这些资源整合到一起，展现出一个完整的网页。浏览器执行的脚本可以在之后的阶段发起更多的请求来获取更多信息和资源，从而可以不断的叠加、更新到当前的网页内容上来。&lt;/p&gt;

&lt;p&gt;我们常常会在游戏项目中把这套 请求/响应式 协议搬到了游戏中运用，那么为什么要用HTTP呢，用HTTP有什么好处呢？&lt;/p&gt;

&lt;p&gt;其最重要的原因是HTTP简单易用，上手成本低，功能扩展难度低，因此被广大互联网程序员所喜爱。&lt;/p&gt;

&lt;p&gt;HTTP是应用层上的协议，它并不需要其底层的传输层协议是面向连接的，只需要它是可靠的，或不丢失消息的（至少返回错误）。因此，HTTP依赖于面向连接的TCP进行消息传递，但HTTP本身对连接的需求并不是必须的，也就是说它本身是无状态的。&lt;/p&gt;

&lt;p&gt;HTTP本身并没有检测是否连接，数据是否传输准确，是否有数据到达等的机制，而是依赖于TCP协议，由TCP协议来做这些传输层的事情。HTTP在TCP之上，制定了自己的规则。&lt;/p&gt;

&lt;p&gt;HTTP在TCP之上制定了自己的规则：&lt;/p&gt;

&lt;p&gt;1.HTTP有自己的协议，HEADS和BODY&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    GET /root1/module?name1=value1&amp;amp;name2=value2 HTTP/1.1
    Host: localhost:8080
    Accept-Language: fr
    //这里HEADS 和 BODY一定是用空行隔开的
    body content
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 GET为方式，HTTP有很多种方式，其中GET和POST最为常用。GET方式是把参数值放在地址中，而POST则是把参数值放在协议数据包中，并且POST可以使用二进制作为参数值，而GET则不能。其两者的实质是一样的，都是以Key1=Value1&amp;amp;Key2=Value2的形式作为请求内容，他们两请求的参数都会被写入请求包体中。&lt;/p&gt;

&lt;p&gt;其协议中 HTTP/1.1为HTTP协议的版本号，我们现在常用的协议为1.1，也有少部分还在使用1.0。HTTP1.1兼容了1.0，并且在1.0之上改进了诸多内容，比如同一个地址不同host，增加了cache特性，增加Chunked transfer-coding标志切割数据块等。而2.0由于和1.1差别太大，不能兼容1.0和1.1，因此世界被分成了两块，HTTP2.0主要运用在HTTPS上，而HTTP1.1和1.0则运行在原有的HTTP上。&lt;/p&gt;

&lt;p&gt;body content是主要存储请求内容的，POST内容都放在这里。&lt;/p&gt;

&lt;p&gt;服务器收到请求处理相应逻辑后发送响应数据，其数据格式为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    HTTP/1.1 200
    Date:Mon,31Dec200104:25:57GMT
    Server:Apache/1.3.14(Unix)
    Content-type:text/html
    Last-modified:Tue,17Apr200106:46:28GMT
    Content-length:xxx

    //这里HEADS 和 BODY一定是用空行隔开的
    body content
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中200为响应后代表请求成功的错误码，其他常用的错误码可以简单理解为 404 找不到请求页，500 服务器程序报错，400 访问请求参数错误，403 被拒绝访问。&lt;/p&gt;

&lt;p&gt;2.HTTP是无状态但有会话的，两个执行成功的请求之间是没有关系的。&lt;/p&gt;

&lt;p&gt;无状态，是指对于事务处理没有记忆能力，前后两次的请求并没有任何相关性，可以是不同的连接，也可以是不同的客户端，服务器在处理无状态请求时，只关注当下这个连接请求时的可获取到的数据，不会去关心也没有记忆去关联上一次请求的状态。&lt;/p&gt;

&lt;p&gt;HTTP的访问请求一般都由软硬件做负载均衡来决定访问哪台物理服务器，进而两次同样地址的访问请求，有可能选择的服务器是不同的。&lt;/p&gt;

&lt;p&gt;无状态很好的匹配了这种近乎随机的访问方式，也就是说HTTP客户端可以任意选择一个部署在不同区域的服务器进行访问，得到的结果是相同的。&lt;/p&gt;

&lt;p&gt;3.HTTP每次请求访问结束会断开连接。&lt;/p&gt;

&lt;p&gt;HTTP是依据什么来断开连接的呢？content-length。&lt;/p&gt;

&lt;p&gt;content-length为 heads 上的标记，表示 body 内容长度。&lt;/p&gt;

&lt;p&gt;带content-length，body长度是可知的，客户端在接收body内容时，就可以依据这个长度来接受数据。接受完毕后，就表示这个请求完毕了。客户端主动调用close进入四次挥手断开连接。&lt;/p&gt;

&lt;p&gt;假如没有content-length 标记，那么body内容长度是不可知的，客户端会一直接受数据，直到服务端主动断开。&lt;/p&gt;

&lt;p&gt;HTTP1.1在这个断开规则之上又扩展了一种新规则，即增加了Transfer-encoding标记。如果Transfer-encoding为chunked，则表示body是流式输出，body会被分成多个块，每块的开始会标识出当前块的长度，此时body不需要通过content-length长度来指定了。&lt;/p&gt;

&lt;p&gt;HEADS上带有Transfer-encoding:chunked 就表示body被分成很多块，每块的长度也是可知的，当客户端根据长度接受完毕数据后，就会主动断开连接。&lt;/p&gt;

&lt;p&gt;假如说Transfer-encoding 和 content-length 这两个标记都没有，那么就只能一直接受数据直到服务器主动断开连接。&lt;/p&gt;

&lt;p&gt;那么有没有一种可能，既想使用HTTP协议又不想断开连接的？&lt;/p&gt;

&lt;p&gt;使用keep-alive标识，keep-alive标识会让客户端与服务器的连接保持状态，直到服务器发现空闲时间结束而断开连接，在结束时间内我们仍然能发送数据。也在就是说，可以减少多次的与服务器3次握手建立连接，以及多次与服务器4次握手断开连接，提高了传输效率。&lt;/p&gt;

&lt;p&gt;而在服务器端上，Nginx的 keepalive&lt;em&gt;timeout，和Apache的 KeepAliveTimeout 都能设置 Keep-alive 的空闲时间大小，当httpd守护进程发送完一个响应后，理应马上主动关闭相应的TCP连接，但设置 keepalive&lt;/em&gt;timeout后，httpd守护进程会说：”再等等吧，看看客户端还有没有请求过来”，这一等，便是 keepalive_timeout时间。如果守护进程在这个等待的时间里，一直没有收到客户端发过来HTTP请求，则关闭这个HTTP连接。&lt;/p&gt;

&lt;p&gt;但也不一定说使用keep-alive标识能提高效率，有时也会反而降低了效率。比如经常会没有数据需要发送，导致长时间的Tcp连接保持导致系统资源无效占用，浪费系统资源，巨量的保持连接会浪费巨量的资源。&lt;/p&gt;

&lt;p&gt;如果客户端使用keep-alive，则需要在连续发送数据时，使用同一个HTTP连接实例。并且在发送完毕后要记录空闲时间，以便再次发送时，可以判断是否继续使用该连接，因为通常服务器端主动断开连接后并没有被客户端及时的得知，所以自行判断是否有可能已经被服务器端断开连接为好。还有一个问题是，如果网络环境不好导致发送请求无法到达时，则要尽可能的自己记录和判断，哪些数据是需要重发的。这几个问题增加了HTTP作为keep-alive来保持连接的操作难度，将本来简单便捷的HTTP，推向了有点长连接的味道。&lt;/p&gt;

&lt;h6&gt;在Unity3D中的HTTP封装&lt;/h6&gt;

&lt;p&gt;Unity3D的2018版本中原本经常用的WWW类已经被废弃，取而代之的是UnityWebRequest。&lt;/p&gt;

&lt;p&gt;API改了但功能都是一样的，我们主要还是围绕HTTP的原理来写程序，也只有这样才能真正写出程序的精髓。&lt;/p&gt;

&lt;p&gt;UnityWebRequest里有几个接口对我们来说比较重要，一个是Post(string uri, WWWForm postData)接口用来创建一个带有地址和Post数据的UnityWebRequest实例，一个是SendWebRequest()用来开始发送请求和迭代请求的接口，另一个是SetRequestHeader(string name, string value)用来设置HTTP头的，其中它说下面这些HEAD标记不支持设置：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    These headers cannot be set with custom values on any platform: accept-charset, access-control-request-headers, access-control-request-method, connection, date, dnt, expect, host, keep-alive, origin, referer, te, trailer, transfer-encoding, upgrade, via.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些标记都是什么意思呢，&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    accept-charset: 用于告诉服务器，客户机采用的编码格式

    access-control-request-headers: 在预检请求中，用于通知服务器在真正的请求中会采用哪些请求首部

    access-control-request-method: 在预检请求中，用于通知服务器在真正的请求中会采用哪种 HTTP 方法

    connection: 处理完这次请求后是否断开连接还是继续保持连接

    date: 当前时间值

    dnt:  (Do Not Track) 表明了用户对于网站追踪的偏好。

    expect: 是一个请求消息头，包含一个期望条件，表示服务器只有在满足此期望条件的情况下才能妥善地处理请求。服务器开始检查请求消息头，可能会返回一个状态码为 100 (Continue) 的回复来告知客户端继续发送消息体，也可能会返回一个状态码为417 (Expectation Failed) 的回复来告知对方要求不能得到满足。

    host: 请求头指明了服务器的域名(对于虚拟主机来说)，以及服务器监听的TCP端口号。

    keep-alive: 允许消息发送者暗示连接的状态，还可以用来设置超时时长和最大请求数。

    origin: 指示了此次请求发起者来自于哪个站点。

    referer: 表示当前页面是通过此来源页面里的链接进入的，与origin相似。

    te: 指定用户代理希望使用的传输编码类型

    trailer: 允许发送方在分块发送的消息后面添加额外的元信息，这些元信息可能是随着消息主体的发送动态生成的，比如消息的完整性校验，消息的数字签名，或者消息经过处理之后的最终状态等。

    transfer-encoding: 指明了将 entity 安全传递给用户所采用的编码形式。transfer-encoding是一个逐跳传输消息首部，即仅应用于两个节点之间的消息传递，而不是所请求的资源本身。一个多节点连接中的每一段都可以应用不同的Transfer-Encoding 值。

    upgrade: 升级为其他协议

    via: 代理服务器相关的信息
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上这些由HEAD扩展的HTTP功能都不能进行自主的选择，其中包括了我们比较关心的标识 connection 和 keep-alive 保持连接的功能，代表了我们无法用UnityWebRequest来实现一次连接发送多次数据的需求。&lt;/p&gt;

&lt;p&gt;另外我们最关心的content-length也不能被自定义设置，而是由API本身来自动设置。&lt;/p&gt;

&lt;p&gt;与原来WWWW的API不同的是，UnityWebRequest更加简洁方便，但也失去了一些自定义的功能。接下来我们来使用UnityWebRequest封装HTTP网络层。&lt;/p&gt;

&lt;p&gt;我们必须设计一个类，比如建个名称为HTTPRequest的类，每次请求服务器都调用这个类的方法来处理一个请求的操作。把地址，参数，回调传进去，等待服务器相应和回调。&lt;/p&gt;

&lt;p&gt;短连接接口相对较少，其中POST,GET,HEAD,Start，这几个接口最为关键。在UnityWebRequest中对应的是&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    POST: UnityWebRequest UnityWebRequest.Post(string uri, WWWForm postData) (静态函数)

    GET: UnityWebRequest UnityWebRequest.Get(string uri) (静态函数)

    HEAD: UnityWebRequest.SetRequestHeader(string name, string value) (非静态函数)

    Start: UnityWebRequest.SendWebRequest() (非静态函数)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用这四个API就能实现HTTP基本的发送与接收。&lt;/p&gt;

&lt;p&gt;在调用UnityWebRequest发送请求时可以用协程也可以在逻辑更新中进行判断收发过程。&lt;/p&gt;

&lt;p&gt;不过在协程中不太可控，并且每次都起一个携程来发送数据也浪费资源，并且协程结束时随着函数调用结束而结束的，而我们时常会有需要暂停，继续等操作。所以一般都会把HTTP的收发判断移到逻辑更新中的Update里去，这样做更容易理解，也更容易掌控。&lt;/p&gt;

&lt;p&gt;下面我们建立一个类来封装UnityWebRequest的收发过程：&lt;/p&gt;

&lt;p&gt;1.建立实例开始连接和发送请求，设置好这次请求回应的回调句柄。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    void StartRequest(string url, Callback _callback)
    {
        this.web_request = UnityWebRequest.Get(url);
        this.Callback =  _callback;
        this.web_request.SendWebRequest();
    }

    or POST

    void StartRequest(string url, WWWForm wwwform, Callback _callback)
    {
        this.web_request = UnityWebRequest.POST(url, wwwform);
        this.Callback =  _callback;
        this.web_request.SendWebRequest();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.判断是否完成或者说发送请求是否完毕,并且调用回调函数&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    void Update()
    {
        if(web_request != null)
        {
            if(web_request.isDone)
            {
                ProcessResponse(web_request);
                web_request.Dispose();
                web_request = null;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.处理数据，先判断有错误存在，如果没有错误则对数据进行处理，HTTP回应的数据格式比较多，比如Json格式的，Xml格式等等。对数据进行解析后变为具体的类实例，再传给相应的函数句柄进行调用。所以这里数据格式协议也是关键。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    void ProcessResponse(UnityWebRequest _WebRequest)
    {
        if(_WebRequest.error != null)
        {
            NetworkErrorReport(_www.error);
            return;
        }
        CallbackResponse(_WebRequest.downloadHandler.text);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上是用UnityWebRequest做HTTP请求的基本步骤。在具体项目中看似简单的连接，发送，接收过程中也有不少事情需要我们做。特别是游戏逻辑中，大量多次，频繁发送HTTP请求的问题的延伸和提出的解决方案。&lt;/p&gt;

&lt;p&gt;多次或者连续发送HTTP请求引起的问题&lt;/p&gt;

&lt;p&gt;多次或者连续请求HTTP在具体项目中比价常见，比如客户端向服务器请求角色信息，并且请求军团信息，并且请求每日任务信息，然后再显示主界面。&lt;/p&gt;

&lt;p&gt;这种连续的多次的请求HTTP，会同时触发多个线程向服务器做请求操作，建立连接，发送请求，关闭连接，而得到服务器返回时，却不知道哪个在先哪个在后，例如军团信息有可能先得到响应，然后再是每日任务信息得到了响应，再是角色信息得到了响应，因为是多个线程发起的多个连接，服务端接受到的数据也是没有顺序的，即使服务器端接受的顺序刚好没有打乱顺序，在处理和回调的时机也是不可知的，导致回调的顺序不可知，所以并不能确定响应的顺序与请求的顺序是一样的。&lt;/p&gt;

&lt;p&gt;当接受数据的顺序无法确定时，如果还用顺序接受数据的方式处理出具则有风险，比如我们在发送，军团，任务，角色数据请求后，希望能够在三者都到齐的情况下执行某个程序逻辑，如果得到的数据是顺序的，则我们可以确定在收到角色数据后表明所有的数据都到齐了，于是我们再执行逻辑程序。&lt;/p&gt;

&lt;h6&gt;解决方案1：多开线程发送请求数据，等待所有数据到齐再调用执行逻辑。&lt;/h6&gt;

&lt;p&gt;每个HTTP(也可以认为是UnityWebRequest)请求都会开一个线程来向服务器请求数据，多个HTTP请求同时开启，相当于多个线程同时工作提高了网络效率。&lt;/p&gt;

&lt;p&gt;我们可以用HTTP这种开线程的方式做，当需要多个请求的回应数据时，开启多个HTTP请求，等到数据全部得到相应后再处理逻辑。&lt;/p&gt;

&lt;p&gt;这里有一个限制，我们需要假设多次请求之间没有且不需要逻辑顺序，则可以使用同时发起多次HTTP请求，并且等待所有请求结束后再做逻辑处理。&lt;/p&gt;

&lt;p&gt;多次请求的响应数据的需求问题，其本质是‘如何判断我们需要的多条数据是否已经都到达’。&lt;/p&gt;

&lt;p&gt;为了能更快的，更高效的得到HTTP请求数据，在同一时间同时向服务器发起多个HTTP请求，并且等待所有请求都得到响应后才执行逻辑程序，即等待并辨认多次请求是否全数收到。&lt;/p&gt;

&lt;p&gt;在Unity3D上伪代码及注释如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    class multiple_request
    {
        void StartRequest( request_list, call_back )
        {
            lst_req = new List&amp;lt;UnityWebRequest&amp;gt;();
            for( url,wwwform in request_list )
            {
                //开启多个HTTP请求
                UnityWebRequest req = UnityWebRequest.Post(url, wwwform);
                req.SendWebRequest();

                //记录请求实例
                lst_req.Add(req);
            }

            //记录回调函数
            Callback = call_back;
        }

        void Update()
        {
            if(lst_req == null || lst_req.Count &amp;lt;= 0) return;

            for( UnityWebRequest req in lst_req)
            {
                //判断是否完成该请求，只要有一个没完成就继续等待
                if(!req.isDone)
                {
                    return;
                }
            }

            //当全部请求都完成时，执行回调
            Callback(lst_req);

            //请求结束并清空
            lst_req.Clear();
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方式同时开启多个HTTP连接来向服务器请求数据，极大程度地加速了数据的响应速度，最大限度的提高了服务器端的CPU利用率，但请求彼此之间必须没有顺序关系，只有这样服务器端的执行顺序才无序担心。&lt;/p&gt;

&lt;p&gt;如果请求之间是有顺序要求的，服务器端执行顺序无法保障则容易出现逻辑顺序问题，比如会有多个这样的请求，购买物品，出售物品，使用物品，三个请求一起被发起，服务器接受到的请求顺序有可能是，使用物品，出售物品，再购买物品，当顺序不同时就有可能存在逻辑问题，与我们原本设想的逻辑存在偏差，物品可能先被使用或出售，而不是被先购买，导致没有物品可被使用或出售，跟我们的所预期不一致。&lt;/p&gt;

&lt;p&gt;提高了网络效率，服务器的CPU利用率，却无法保证预期的逻辑顺序，在需要顺序的功能上必出现诸多错误。&lt;/p&gt;

&lt;p&gt;因此这种解决方案在需要逻辑顺序的连接请求上无法运作，但在不需要逻辑顺的连接请求上可以极大的提高网络连接利用率。&lt;/p&gt;

&lt;h6&gt;解决方案2：逐个发起请求，保证顺序。&lt;/h6&gt;

&lt;p&gt;逐个发送请求的方式最常见也比较普遍的做法，在网页端，安卓原生端，苹果原生端都使用这种方式来做请求，即每次只处理一个请求，当这个请求结束后再发起下一个请求，即一个请求对应一个功能模块，结束当前功能模块后再发起下一个请求。&lt;/p&gt;

&lt;p&gt;例如前面所描述的例子，请求角色信息，并且请求军团信息，并且请求每日任务信息，每次只做一件事，收到角色信息数据后，再发起请求军团信息，收到军团信息后，再发起请求任务信息，收到任务信息后再显示在界面，每个请求都会被动态的分配一个回调函数，当某个请求的数据需要做别的事情的时候，就分配一个不同回调函数。&lt;/p&gt;

&lt;p&gt;也就是说，当请求角色信息前，我们可以分配一个自定义句柄，当接受到数据后，回调执行这个自定义句柄。在自定义句柄里，可以继续发送我们需要请求的数据或功能，或者执行其他逻辑。&lt;/p&gt;

&lt;p&gt;伪代码为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    void on_button_click()
    {
        //请求角色数据
        function_request_roleinfo( callback_function1 ) 
    }

    void callback_function1( data )
    {
        //记录角色信息
        role_info.Add(data);

        //请求军团信息
        function_request_groupinfo( callback_function2 )
    }

    void callback_function2( data )
    {
        //记录军团信息
        group_info.Add( data );

        //请求任务信息
        function_request_task( callback_funciton3 );
    }

    void callback_function3( data )
    {
        //记录任务信息
        task_info.Add( data);

        //展示UI
        show_ui();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;伪代码展示了发送请求的逻辑顺序，这种逐个发送请求的方式，保证了逻辑顺序，同时也满足了对多样化功能的扩展，同一个请求可以在不同逻辑处拥有自己的自定义回调。&lt;/p&gt;

&lt;p&gt;单个连接的自定义方式确实保证了顺序，但也降低了网络连接效率，多个请求需要发起多个TPC连接，每个连接都需要等待上一个连接请求完毕后才能开始下一个请求，每次收到消息后都需要发起4次握手的断开连接‘仪式’，每次发起请求时又必须进行3次握手的建立连接‘仪式’，消耗网络连接资源降低了收发效率。&lt;/p&gt;

&lt;p&gt;另一种逐个发送请求的方式，为了保证请求的顺序进行，可以使用发送队列和接收队列来做逐个发送的模式。&lt;/p&gt;

&lt;p&gt;队列在请求和响应中起到了缓冲的作用，当连续使用HTTP请求，连续收到HTTP响应的时候，能够依次处理相应的逻辑。&lt;/p&gt;

&lt;p&gt;因为全程是只有1个线程在做请求处理，所以并不需要线程锁之类的操作。发送时，向队列推送请求实例。在逻辑更新上，判断是否有请求在队列里，有的话推出来，做HTTP请求操作，并将请求的相关信息存起来，当得到服务器响应时，调用请求信息中的回调函数，处理回调句柄。&lt;/p&gt;

&lt;p&gt;发送和接收队列的伪代码:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    //将请求推入队列
    void RequestHttp(Request req)
    {
        ListRequest.Push(req);
    }

    //逻辑更新
    void Update()
    {
        //是否完成HTTP
        If( IsHttpFinished() )
        {
            //开始新的请求
            Request  req = ListRequest.Pop();
            mCurrentRequest = req;
            StartHttpRequest(req);
        }
        else
        {
            //是否收到响应
            If(HttpIsDone())
            {
                //根据响应数据处理逻辑
                ProcessResponse(data);

                //完成HTTP
                FinishHttp();
            }
        }
    }

    //根据数据处理逻辑
    void ProcessResponse(Response data)
    {
        If(mCurrentRequest != null
            &amp;amp;&amp;amp; mCurrentRequest.Callback != null)
        {
            //回调句柄
            mCurrentRequest.Callback(data);
            mCurrentRequest = null;
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上阐述了，在发送HTTP请求时的推入队列操作和在收到请求后的句柄响应操作，队列使我们做到了逐个请求以及逐个响应。&lt;/p&gt;

&lt;h6&gt;解决方案3：多连接与逐个发送，并行使用。&lt;/h6&gt;

&lt;p&gt;多连接提高网络请求效率但没有一致的响应顺序，逐个发送有一致的响应顺序网络请求效率则不够好。&lt;/p&gt;

&lt;p&gt;两者之间没有排斥关系，可以并行使用，既提高了网络请求效率，又保证了顺序。&lt;/p&gt;

&lt;p&gt;仍然使用前面解决方案1中的类 multiple&lt;em&gt;request ，原本 multiple&lt;/em&gt;request 类可以传入多个请求数据，并等待全部相应结束后再执行回调。然后再在 multiple_request 中回调中执行下一个请求。&lt;/p&gt;

&lt;p&gt;伪代码如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    //界面按钮
    void on_click()
    {
        //新建一个请求对象
        request1 = new request();
        request1.url = url1;
        request1.wwwform = new wwwform();
        request1.wwwform.AddField(&amp;quot;name1&amp;quot;,&amp;quot;value1&amp;quot;);

        //加入请求列表
        lst_request.Add(request1);

        //兴建一个请求对象
        request2 = new request();
        request2.url = url2;
        request2.wwwform = new wwwform();
        request2.wwwform.AddField(&amp;quot;name21&amp;quot;,&amp;quot;value21&amp;quot;);

        //加入请求列表
        lst_request.Add(request2);

        //新建一个请求对象
        request2 = new request();
        request2.url = url3;
        request2.wwwform = new wwwform();
        request2.wwwform.AddField(&amp;quot;name22&amp;quot;,&amp;quot;value22&amp;quot;);

        //加入请求列表
        lst_request.Add(request3);

        //新建多请求实例
        multiple_request req = new multiple_request();

        //开始多个请求对象开启HTTP请求
        req.StartRequest(lst_request, callback_function1);
    }

    void callback_fucntion1(lst_request)
    {
        //做些逻辑
        do_some_function(lst_request);

        //新建一个请求对象
        request1 = new request();
        request1.url = url1;
        request1.wwwform = new wwwform();
        request1.wwwform.AddField(&amp;quot;name1&amp;quot;,&amp;quot;value1&amp;quot;);

        //加入请求列表
        lst_request.Add(request1);

        //兴建一个请求对象
        request2 = new request();
        request2.url = url2;
        request2.wwwform = new wwwform();
        request2.wwwform.AddField(&amp;quot;name21&amp;quot;,&amp;quot;value21&amp;quot;);

        //新建多请求实例
        multiple_request req = new multiple_request();

        //开始多个请求对象开启HTTP请求
        req.StartRequest(lst_request, callback_function2);
    }

    void callback_function2(lst_request)
    {
        //将信息展示到UI
        show_ui(lst_request);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;伪代码中展示了如何多请求与逐个请求的并行使用，将多个请求看成一个请求的变体，将多个请求看成一个完整的功能块，就有了多请求与逐个请求的并行使用过程。&lt;/p&gt;

&lt;p&gt;伪代码中展示的编码过程太过繁琐，展示出每一步的编码是为了让读者能更容易理解，多请求连接与逐个请求并行使用的理念。&lt;/p&gt;

&lt;p&gt;在现实项目中，完全可以为每个网络功能新建一个类，继承 multiple_request 类，并且将所有参数写进子类中，一并发送，并且可以多次使用在多个地方。&lt;/p&gt;

&lt;p&gt;伪代码:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    //新建个父类继承 multiple_request 专门用来做某个功能，这个功能里需要请求多条数据
    class do_something : multiple_request
    {
        void StartRequest( int val1 , int val2, int val3, call_back )
        {
            //新建一个请求对象
            request1 = new request();
            request1.url = url1;
            request1.wwwform = new wwwform();
            request1.wwwform.AddField(&amp;quot;name1&amp;quot;,&amp;quot;value1&amp;quot;);

            //加入请求列表
            request_list.Add(request1);

            //兴建一个请求对象
            request2 = new request();
            request2.url = url2;
            request2.wwwform = new wwwform();
            request2.wwwform.AddField(&amp;quot;name21&amp;quot;,&amp;quot;value21&amp;quot;);

            //加入请求列表
            request_list.Add(request2);

            //新建一个请求对象
            request2 = new request();
            request2.url = url3;
            request2.wwwform = new wwwform();
            request2.wwwform.AddField(&amp;quot;name22&amp;quot;,&amp;quot;value22&amp;quot;);

            base.StartRequest(request_list, call_back);
        }
    }

    //ui上的按钮
    void on_click()
    {
        //实例化功能对象
        do_something = new do_something();

        //开始请求
        do_something.StartRequest(1,2,3, call_back_function1);
    }

    //回调1
    void call_back_function1(lst_request)
    {
        //做点事
        do_something(lst_requset);

        //实例化功能2的对象
        do_something2 = do_something2();

        //开始请求
        do_something2.StartRequest(3,2, call_back_function2);
    }

    //回调2
    void call_back_function2(lst_request)
    {
        //展示UI
        show_ui(lst_request);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上所描述的，在实际项目中可以用子类继承父类功能的方法，复用了请求的步骤，使得需要某个功能时使用起来更加便捷。&lt;/p&gt;

&lt;h6&gt;解决方案4：合并请求，并逐个发送合并后的请求包。&lt;/h6&gt;

&lt;p&gt;多个请求与逐一发送合并的解决方案，确实既提高了发送效率，又保证了顺序，但还是有几个缺点。&lt;/p&gt;

&lt;p&gt;缺点1，多开连接，连接数增多，服务器建立和断开连接的压力增大。&lt;/p&gt;

&lt;p&gt;缺点2，使用操作不方便，必须手动建立新功能类。&lt;/p&gt;

&lt;p&gt;缺点3，多功能间的顺序，必须手动排列顺序。&lt;/p&gt;

&lt;p&gt;客户端更希望的是多次请求能够被同时发出，收到的响应顺序也要按原来请求的顺序响应，并且要可以自定义回调句柄满足多样化的功能扩展。&lt;/p&gt;

&lt;p&gt;合并请求就成了更好的解决方案。合并多个请求的数据进一个请求中，再发起请求，一次打包多个请求，只发一次能全部响应回来，发送这个合并包则可以做到与发起多个连接同样的效果，并且响应也可以做到顺序一致性。&lt;/p&gt;

&lt;p&gt;合并请求，减少了连接数量，提高了网络效率，同时也可以保证顺序的一致性。&lt;/p&gt;

&lt;p&gt;如何实现呢？&lt;/p&gt;

&lt;p&gt;这需要服务端程序员一些配合，服务端需要将原本多个地址，每个地址对应的功能块的模式，改为同一个地址，并且改为用commoand id 字段来对应不同的功能块。&lt;/p&gt;

&lt;p&gt;我们以json为例，HTTP数据使用json格式，服务器响应也是json格式。每次请求，客户端都会发送格式给服务器，服务器收到后解析json格式数据，然后提取变量。&lt;/p&gt;

&lt;p&gt;我们在对多个请求进行合并时，可以将多个json请求格式，推入一个大的json数据中，为每个json数据添加一个序列号，以代表请求顺序，如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    //请求1
    {
        &amp;quot;request-order&amp;quot; : 1,
        &amp;quot;command&amp;quot; : 1001,
        &amp;quot;data1&amp;quot; : &amp;quot;i am text&amp;quot;,
        &amp;quot;data2&amp;quot; : &amp;quot;i am num&amp;quot;,
    }

    //请求2
    {
        &amp;quot;request-order&amp;quot; : 2,
        &amp;quot;command&amp;quot; : 2011,
        &amp;quot;book&amp;quot; : &amp;quot;i am text&amp;quot;,
        &amp;quot;chat&amp;quot; : &amp;quot;i am num&amp;quot;,
        &amp;quot;level&amp;quot; : 1，
    }

    //请求3
    {
        &amp;quot;request-order&amp;quot; : 3,
        &amp;quot;command&amp;quot; : 3105,
        &amp;quot;image&amp;quot; : &amp;quot;i am text&amp;quot;,
        &amp;quot;doc&amp;quot; : &amp;quot;i am num&amp;quot;,
    }

    //将1，2，3合并后的请求数据为
    {
        &amp;quot;data&amp;quot;:
        [
            {
                &amp;quot;request-order&amp;quot; : 1,
                &amp;quot;command&amp;quot; : 1001,
                &amp;quot;data1&amp;quot; : &amp;quot;i am text&amp;quot;,
                &amp;quot;data2&amp;quot; : &amp;quot;i am num&amp;quot;,
            }
            ,
            {
                &amp;quot;request-order&amp;quot; : 2,
                &amp;quot;command&amp;quot; : 2011,
                &amp;quot;book&amp;quot; : &amp;quot;i am text&amp;quot;,
                &amp;quot;chat&amp;quot; : &amp;quot;i am num&amp;quot;,
                &amp;quot;level&amp;quot; : 1;
            }
            ,
            {
                &amp;quot;request-order&amp;quot; : 3,
                &amp;quot;command&amp;quot; : 3105,
                &amp;quot;image&amp;quot; : &amp;quot;i am text&amp;quot;,
                &amp;quot;doc&amp;quot; : &amp;quot;i am num&amp;quot;,
            }
        ],
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;合并后多个json被推入数组中发送给服务器，服务器拿到数据后对data中的数据进行提取和处理，处理顺序按照request-order来做，每个数据块都有一个command字段，用这个字段来判断使用哪个功能模块，将数据传给该功能模块处理。&lt;/p&gt;

&lt;p&gt;每个功能模块处理完毕后，将所有响应数据都推入同一个json实例中，并且附上与请求数据中相同的request-order，再把整个响应数据发送给客户端，当客户端收到数据时，就可以通过request-order知道响应数据的顺序了，按照request-order排序后，再进行解析和回调，得到了与请求顺序一致的响应顺序。&lt;/p&gt;

&lt;p&gt;合并响应后的例子如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    //响应数据1
    {
        &amp;quot;response-order&amp;quot; : 1,
        &amp;quot;command&amp;quot; : 1001,
        &amp;quot;data1&amp;quot; : &amp;quot;response text&amp;quot;,
        &amp;quot;data2&amp;quot; : &amp;quot;response num&amp;quot;,
        &amp;quot;error_code&amp;quot; : &amp;quot;0&amp;quot;, 
    }

    //响应数据2
    {
        &amp;quot;response-order&amp;quot; : 2,
        &amp;quot;command&amp;quot; : 2011,
        &amp;quot;data1&amp;quot; : &amp;quot;response text&amp;quot;,
        &amp;quot;data2&amp;quot; : &amp;quot;response num&amp;quot;,
        &amp;quot;error_code&amp;quot; : &amp;quot;1&amp;quot;,
    }

    //响应数据3
    {
        &amp;quot;response-order&amp;quot; : 3
        &amp;quot;command&amp;quot; : 3105,
        &amp;quot;data1&amp;quot; : &amp;quot;response text&amp;quot;,
        &amp;quot;data2&amp;quot; : &amp;quot;response num&amp;quot;,
        &amp;quot;error_code&amp;quot; : &amp;quot;2&amp;quot;,
    }

    //合并后的响应数据
    {
        &amp;quot;error_code&amp;quot; : 0,
        &amp;quot;data&amp;quot;:
        [
            {
                &amp;quot;response-order&amp;quot; : 1,
                &amp;quot;command&amp;quot; : 1001,
                &amp;quot;data1&amp;quot; : &amp;quot;response text&amp;quot;,
                &amp;quot;data2&amp;quot; : &amp;quot;response num&amp;quot;,
                &amp;quot;error_code&amp;quot; : &amp;quot;0&amp;quot;, 
            }
            ,
            {
                &amp;quot;response-order&amp;quot; : 2,
                &amp;quot;command&amp;quot; : 2011,
                &amp;quot;data1&amp;quot; : &amp;quot;response text&amp;quot;,
                &amp;quot;data2&amp;quot; : &amp;quot;response num&amp;quot;,
                &amp;quot;error_code&amp;quot; : &amp;quot;1&amp;quot;,
            }
            ,
            {
                &amp;quot;response-order&amp;quot; : 3
                &amp;quot;command&amp;quot; : 3105,
                &amp;quot;data1&amp;quot; : &amp;quot;response text&amp;quot;,
                &amp;quot;data2&amp;quot; : &amp;quot;response num&amp;quot;,
                &amp;quot;error_code&amp;quot; : &amp;quot;2&amp;quot;,
            }
        ]
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得到合并后的响应数据后，客户端要先提取data数据中的所有数据，以respose-order为基准进行排序，头部最小序号的先处理，解析，回调。&lt;/p&gt;

&lt;p&gt;不仅仅是合并，我们还要保证发送的顺序，多个合并请求一同发送则会遇到大麻烦，也就是顺序问题，所以需要用队列来规避。&lt;/p&gt;

&lt;p&gt;用了队列的方式保证请求的有序性，并且在队列之上进行操作请求合并，能更有效更便捷的进行合并。&lt;/p&gt;

&lt;p&gt;队列与合并结合的伪代码如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    //将请求推入队列
    void RequestHttp(Request req)
    {
        ListRequest.Push(req);
    }

    //逻辑更新
    void Update()
    {
        //是否完成HTTP
        If( IsHttpFinished() )
        {
            //推出多个请求进行合并
            lst_combine_req.Clear();
            for(int i = 0 ; i&amp;lt;10 ; i++)
            {
                Request  req = ListRequest.Pop();
                lst_combine_req.Add(req);
            }

            combine_request = CombineRequest(lst_combine_req);
            StartHttpRequest(req);
        }
        else
        {
            //是否收到响应
            If(HttpIsDone())
            {
                //排序
                sort(combine_request.lst_response);

                //循环处理每个响应逻辑
                for(int i = 0 ; i&amp;lt;combine_request.lst_response.count ; i++)
                {
                    //根据响应数据处理逻辑
                    data = combine_request.lst_response[i];
                    ProcessResponse(data);
                }

                //完成HTTP
                FinishHttp();
            }
        }
    }

    //根据数据处理逻辑
    void ProcessResponse(Response data)
    {
        If(mCurrentRequest != null
            &amp;amp;&amp;amp; mCurrentRequest.Callback != null)
        {
            //回调句柄
            mCurrentRequest.Callback(data);
            mCurrentRequest = null;
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体逻辑中的操作伪代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    //按钮事件
    void on_click()
    {
        //请求玩家数据
        request_roleinfo( call_back_function1 );

        //请求军团数据
        request_groupinfo( call_back_function2 );

        //请求任务数据
        request_taskinfo( call_back_function3 );
    }

    //先回调的是这个句柄
    void call_back_function1( data )
    {
        //保存玩家数据
        save_roleinfo(data);
    }

    //再回调的是这个句柄
    void call_back_function2( data )
    {
        //保存军团数据
        save_groupinfo(data);
    }

    //最后收到任务数据时，表明前面的数据都已经收到了，就可以做一些逻辑处理
    void call_back_function3( data )
    {
        //保存任务数据
        save_taskinfo(data);

        do_something();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述伪代码中表现了，客户端可以随意的发送请求而不需要去关心顺序的问题，大大提高了程序员的网络逻辑编程效率。&lt;/p&gt;

&lt;p&gt;对多个请求进行合并后减少HTTP请求的次数，对速度的提升很有效果，但这里还有一些细节问题，比如多少个开始进行合并，或者多少时间内合并一次。&lt;/p&gt;

&lt;p&gt;为了让HTTP最大效率的得到提升，必须每次请求得到响应后就应该立即进行下一次HTTP请求，如果有等待合并间隔，反而减低了网络效率。不过每次合并数量可以做一些限制，比如有1000个请求，我们不能统统合并了，为了保证发送数据大小和回调数据大小合适，也保证服务器不会为了一下子需要处理1000个数据请求而当机，我们必须限制一次性合并的个数，比如每次最多合并10个请求数据包，来保证减少连接次数减少的情况下，服务器不会在瞬间压力过大。&lt;/p&gt;
</description>
               <pubDate>Sun, 02 Jun 2019 00:00:00 +0800</pubDate>
               <link>http://www.luzexi.com//2019/06/02/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%824.html</link>
               <guid isPermaLink="true">http://www.luzexi.com//2019/06/02/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%B1%824.html</guid>
            </item>
        
    </channel>
</rss>