<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      技术人生 &middot; luzexi.com
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          技术人生
        </a>
      </h1>
      <p class="lead">漫漫人生,记录点滴,始于2013</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>

      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about/">About Me</a>
          
        
      
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      

      <a class="sidebar-nav-item" href="/lua/index.html">Lua</a>
      <a class="sidebar-nav-item" href="/unity3d/index.html">Unity3D</a>
      <a class="sidebar-nav-item" href="/其他技术/index.html">其他技术</a>
      <a class="sidebar-nav-item" href="/游戏服务端/index.html">游戏服务端</a>
      <a class="sidebar-nav-item" href="/游戏架构/index.html">游戏架构</a>
      <a class="sidebar-nav-item" href="/游戏通用模块/index.html">游戏通用模块</a>
      <a class="sidebar-nav-item" href="/android/index.html">Android</a>
      <a class="sidebar-nav-item" href="/cocos2dx/index.html">Cocos2dx</a>
      <a class="sidebar-nav-item" href="/html5/index.html">Html5</a>
      <a class="sidebar-nav-item" href="/linux/index.html">Linux</a>
      <a class="sidebar-nav-item" href="/生活/index.html">生活</a>
      <a class="sidebar-nav-item" href="https://github.com/luzexi">GitHub project</a>
      <!-- <span class="sidebar-nav-item">Currently v2.1.0</span> -->
    </nav>

    <p>&copy; 2015. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84/2013/10/22/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%98%E5%8C%96/">
        游戏服务端优化
      </a>
    </h1>

    <span class="post-date">22 Oct 2013</span>

    <p>完成《王途霸业》后，慢慢地开始整理客户端，服务端的架构思路和优化思路。虽然1年来项目工作非常累，但我还是不想放弃这个整理资料，梳理知识的绝佳机会。</p>

<p>废话不多说，直接开始游戏服务端优化思路。</p>

<p>1.整体架构决定承载量。想要完全突破游戏用户承载量，你必须尽快即使调整自己服务器的架构，这个非常不容易，特别是在项目开发后期，在过多的代码积累的情况下，你很难对当前的架构进行调整。基本上，当时的情况都是，不动则已，一动一发不可收拾。架构调整主要是为了分担服务器的 游戏逻辑处理，数据存储，第三方接口处理。</p>

<p>2.用户集中短时间使用的优化。比如帐号登录，帐号修改，角色获取，角色选择，角色创建等，在一个相对比较短的时间里完成的东西，又有可能会借助第三放接口的，需要进行统一管理和拆分，在用户量扩大时可以使用扩充服务器来对承载量扩充。一句话来表明：对于这种时间较短，用户会集中冲击承载量的，把它做成能扩充服务器就可以达到效果的架构，这种架构只要花钱就能解决。但凡能走上只要花钱就能解决承载量的架构，一定没有问题。</p>

<p>3.大量用户集中使用同一功能的优化。《王途霸业》的挂机系统就遇到这样的情况，大部分玩家都会使用这个功能，而且这是机器与机器的交互，大部分玩家都会在长时间里使用这个功能。当大量用户时，这个挂机战斗功能，对数据存储服务器的SQL语句执行冲击很大，类似的情况还有很多。像这样的功能呢，就需要我们进一步优化，不但是优化逻辑处理，还要优化数据存储方式，不可以加大了逻辑服务器的承载，却忽视了数据服务器的承载。优化方法很多，比如当前功能不存储数据，只在玩家下线时操作数据存储更新，还有数据差异化存储，当数据有变化才进行储存更新，去除了很多不必要的存储SQL执行时间。</p>

<p>4.HTTP与TCP结合的优化。《王途霸业》一开始尝试过只使用TCP长连接的架构方式，但最终以不方便，不好用的试用结果落败。TCP与WEB的HTTP结合的方式优化架构是个非常好的方式。首先WEB的HTTP本身就是个大众化稳定的架构体系，它在帐号管理，数据记录，需求变化的适应力等方面都有非常好的表现。其实就是人们口中所有的短连接和长连接的结合。《王途霸业》使用HTTP方式做了帐号认证系统是为了所有服务器的帐号获取方式，又用HTTP方式做了服务器列表，全服公告，网关轮询等做为中心服务器，这个中心服务器还配备了后台管理界面，让运营人员非常舒服，最后还用HTTP方式为《王途霸业》的数据统计做了一个统计管理的WEB后台管理，让市场人员能清晰得看到整个游戏数据的起伏变化情况。</p>

<p>5.循环驱动更改为事件驱动。很多时候我们服务器里会有一些需要用逻辑帧循环来做的事情，《王途霸业》中就有很多，比如建筑时间完成判断，常胜峰战斗奖励判断，玩家当前资源量计算，盘丝洞挂机计算，这些程序逻辑倘若都用服务器的主逻辑帧来做，那将是个非常损耗CPU的事情，并且它还会影响到DB存储服务器的效率。这时候我们就要好好利用事件驱动，在玩家下线时，上线时，玩家获取信息时，更或者在玩家退出某个场景时，进行操作。这样不仅省去了主逻辑帧的循环CPU损耗，更让DB服务器有了更多的力量去处理更重要的事，大大提高了整个游戏服务器的承载量。</p>

<p>PS:一点点小分享，大神切莫嘲笑。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/unity3d/2013/10/06/Unity3D%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1NavMesh%E5%AF%BB%E8%B7%AF/">
        Unity3D架构设计NavMesh寻路
      </a>
    </h1>

    <span class="post-date">06 Oct 2013</span>

    <p>国庆闲来没事把NavMesh巩固一下。以Unity3D引擎为例写一个底层c# NavMesh寻路。因为Unity3D中本身自带的NavMesh寻路不能很好的融入到游戏项目当中，所以重写一个NavMesh寻路是个必经之路。NavMesh在很多游戏中应用广泛，不同种类的框架下NavMesh寻路发挥的淋漓尽致。与传统的A星寻路相比，NavMesh不仅减少了内存空间占有量，加快了寻路速度，还可以加入寻路角色的宽高限制，以及动态物体寻路等功能，基本上适应了大部分项目变化多端的需求。</p>

<p>我把写NavMesh的过程分成好几个部分，一一进行描述：</p>

<p>一.首先要理解NavMesh核心算法。NavMesh的核心算法就是用三角形代替传统寻路的方格，用计算拐点优化寻路路径来代替合并路径直线。
如下图1NavMesh寻路:
<img class="alignnone wp-image-91 size-full" src="/assets/uploads/2013/10/2303121.jpg" alt="" width="479" height="312" /></p>

<p>以及如下图2传统的方格寻路:
<img class="alignnone wp-image-94 size-full" src="/assets/uploads/2013/10/20131006173445.jpg" alt="" width="621" height="568" /></p>

<p>看到两者的差别了吧，NavMesh已三角形为寻路块，而传统以方格为寻路块。其实两者都使用A*寻路，但就是其网格生成不一样，导致当有大范围寻路时，其效率和要求也不一样。</p>

<p>二.NavMesh寻路中的路径优化之拐点计算。其实NavMesh中比较常用的是<strong>光照射线法，</strong>但这里不做详细介绍，光照射浅法详细内容地址:<a href="http://www.cnblogs.com/neoragex2002/archive/2007/09/09/887556.html">http://www.cnblogs.com/neoragex2002/archive/2007/09/09/887556.html</a>
拐点计算优化路径就是到达目的地需要经过的一堆三角形中计算出最简洁的移动方式。其核心算法就是从当前点到另一个三角形中的点之间的线段，与这条线段相交的线段全部是路径所穿越的线段，就是拐点，把所有的拐点找出来，并得到一条最长的拐点，那个拐点就是最佳的拐点位置。</p>

<p>三.NavMesh类设计详解(这里只设计2D的寻路，对于3D方向的寻路，其实是可以2D寻路代替的)：</p>

<p>1.所有类都在同一的命名空间NavMesh内 namespace NavMesh
Triangle 三角形基础类
NavTriangle 寻路三角形类 (继承Triangle)
Line2D 线段类
Polygon 多边形类
Seeker 寻路主算法类</p>

<p>----------------------------------------- 让大家久等了 ------------------------------------</p>

<p>在寻路前，我们需要建立MESH三角形网格，这是NAV_MESH的重点之一。</p>

<p>1.首先我们先要画出一个范围来确定我们的可行走范围。</p>

<p>2.再在可行走范围中去添加不可行走的范围。</p>

<p>3.我们用多个多边形Polygon代替以上的范围，也就是说，一个大的可行走Polygon内包含了若干个小的不可行走的Polygon。</p>

<p>这是生成MESH前我们需要知道的生成范围，然后再由这些多边形的各个顶点来生成三角形网格,三角形网格的生成算法如下：</p>

<p>Step 1 :  用可行走Polygon的任意一条边作为起点，将其推入堆栈列表。到Step2.</p>

<p>Step 2:  从堆栈中推出一条边，在所有三角形中计算出边的DT点，构成约束Delaunay三角形，到Step3。如果没有DT点就重复做Step2，直到堆栈为空就结束整个程序。</p>

<p>Step 3:  将所构成的三角形，另两边做如下处理：检查堆栈中是否已存在，如果存在就删除该边，如果不存在就加入到堆栈中。</p>

<p>生成mesh后如图：（绿色的为多边形边框，蓝色的为寻路路径，红色的为编辑器选中的多边形）
<img class="alignnone size-full wp-image-376" src="/assets/uploads/2013/10/OD04RIKAWEMUTM_3MSBQ.jpg" alt="OD04[RIKAWEMUTM_3MS}B$Q" width="475" height="312" /></p>

<p>核心源码为：</p>
<div class="highlight"><pre><code class="language-c#" data-lang="c#">        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// 创建导航网格</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="c1">/// 所有阻挡区域&lt;/param&gt;</span>
        <span class="c1">/// 输出的导航网格&lt;/param&gt;</span>
        <span class="c1">/// &lt;returns&gt;&lt;/returns&gt;</span>
        <span class="k">public</span> <span class="n">NavResCode</span> <span class="nf">CreateNavMesh</span><span class="p">(</span><span class="n">List</span><span class="p">&lt;</span><span class="n">Polygon</span><span class="p">&gt;</span> <span class="n">polyAll</span> <span class="p">,</span> <span class="k">ref</span> <span class="kt">int</span> <span class="n">id</span> <span class="p">,</span> <span class="kt">int</span> <span class="n">groupid</span> <span class="p">,</span> <span class="k">ref</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Triangle</span><span class="p">&gt;</span> <span class="n">triAll</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">triAll</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span>
            <span class="n">List</span><span class="p">&lt;</span><span class="n">Line2D</span><span class="p">&gt;</span> <span class="n">allLines</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Line2D</span><span class="p">&gt;();</span> <span class="c1">//线段堆栈</span>

            <span class="c1">//Step1 保存顶点和边</span>
            <span class="n">NavResCode</span> <span class="n">initRes</span> <span class="p">=</span> <span class="n">InitData</span><span class="p">(</span><span class="n">polyAll</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">initRes</span> <span class="p">!=</span> <span class="n">NavResCode</span><span class="p">.</span><span class="n">Success</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">initRes</span><span class="p">;</span>

            <span class="kt">int</span> <span class="n">lastNeighborId</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
            <span class="n">Triangle</span> <span class="n">lastTri</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>

            <span class="c1">//Step2.遍历边界边作为起点</span>
            <span class="p">{</span>
                <span class="n">Line2D</span> <span class="n">sEdge</span> <span class="p">=</span> <span class="n">startEdge</span><span class="p">;</span>
                <span class="n">allLines</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">sEdge</span><span class="p">);</span>
                <span class="n">Line2D</span> <span class="n">edge</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>

                <span class="k">do</span>
                <span class="p">{</span>
                    <span class="c1">//Step3.选出计算出边的DT点，构成约束Delaunay三角形</span>
                    <span class="n">edge</span> <span class="p">=</span> <span class="n">allLines</span><span class="p">[</span><span class="n">allLines</span><span class="p">.</span><span class="n">Count</span> <span class="p">-</span> <span class="m">1</span><span class="p">];</span>
                    <span class="n">allLines</span><span class="p">.</span><span class="n">Remove</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>

                    <span class="n">Vector2</span> <span class="n">dtPoint</span><span class="p">;</span>
                    <span class="kt">bool</span> <span class="n">isFindDt</span> <span class="p">=</span> <span class="n">FindDT</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="k">out</span> <span class="n">dtPoint</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(!</span><span class="n">isFindDt</span><span class="p">)</span>
                        <span class="k">continue</span><span class="p">;</span>
                    <span class="n">Line2D</span> <span class="n">lAD</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Line2D</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">GetStartPoint</span><span class="p">(),</span> <span class="n">dtPoint</span><span class="p">);</span>
                    <span class="n">Line2D</span> <span class="n">lDB</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Line2D</span><span class="p">(</span><span class="n">dtPoint</span><span class="p">,</span> <span class="n">edge</span><span class="p">.</span><span class="n">GetEndPoint</span><span class="p">());</span>

                    <span class="c1">//创建三角形</span>
                    <span class="n">Triangle</span> <span class="n">delaunayTri</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Triangle</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">GetStartPoint</span><span class="p">(),</span> <span class="n">edge</span><span class="p">.</span><span class="n">GetEndPoint</span><span class="p">(),</span> <span class="n">dtPoint</span><span class="p">,</span> <span class="n">id</span><span class="p">++</span> <span class="p">,</span> <span class="n">groupid</span><span class="p">);</span>
                    <span class="c1">// 保存邻居节点</span>
                    <span class="c1">// if (lastNeighborId != -1)</span>
                    <span class="c1">// {</span>
                    <span class="c1">// delaunayTri.SetNeighbor(lastNeighborId);</span>
                    <span class="c1">// if(lastTri != null)</span>
                    <span class="c1">// lastTri.SetNeighbor(delaunayTri.ID);</span>
                    <span class="c1">// }</span>
                    <span class="c1">//save result triangle</span>
                    <span class="n">triAll</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">delaunayTri</span><span class="p">);</span>

                    <span class="c1">// 保存上一次的id和三角形</span>
                    <span class="n">lastNeighborId</span> <span class="p">=</span> <span class="n">delaunayTri</span><span class="p">.</span><span class="n">GetID</span><span class="p">();</span>
                    <span class="n">lastTri</span> <span class="p">=</span> <span class="n">delaunayTri</span><span class="p">;</span>

                    <span class="kt">int</span> <span class="n">lineIndex</span><span class="p">;</span>
                    <span class="c1">//Step4.检测刚创建的的线段ad,db；如果如果它们不是约束边</span>
                    <span class="c1">//并且在线段堆栈中，则将其删除，如果不在其中，那么将其放入</span>
                    <span class="k">if</span> <span class="p">(!</span><span class="n">Line2D</span><span class="p">.</span><span class="n">CheckLineIn</span><span class="p">(</span><span class="n">allEdges</span><span class="p">,</span> <span class="n">lAD</span><span class="p">,</span> <span class="k">out</span> <span class="n">lineIndex</span><span class="p">))</span>
                    <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(!</span><span class="n">Line2D</span><span class="p">.</span><span class="n">CheckLineIn</span><span class="p">(</span><span class="n">allLines</span><span class="p">,</span> <span class="n">lAD</span><span class="p">,</span> <span class="k">out</span> <span class="n">lineIndex</span><span class="p">))</span>
                            <span class="n">allLines</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">lAD</span><span class="p">);</span>
                        <span class="k">else</span>
                            <span class="n">allLines</span><span class="p">.</span><span class="n">RemoveAt</span><span class="p">(</span><span class="n">lineIndex</span><span class="p">);</span>
                    <span class="p">}</span>

                    <span class="k">if</span> <span class="p">(!</span><span class="n">Line2D</span><span class="p">.</span><span class="n">CheckLineIn</span><span class="p">(</span><span class="n">allEdges</span><span class="p">,</span> <span class="n">lDB</span><span class="p">,</span> <span class="k">out</span> <span class="n">lineIndex</span><span class="p">))</span>
                    <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(!</span><span class="n">Line2D</span><span class="p">.</span><span class="n">CheckLineIn</span><span class="p">(</span><span class="n">allLines</span><span class="p">,</span> <span class="n">lDB</span><span class="p">,</span> <span class="k">out</span> <span class="n">lineIndex</span><span class="p">))</span>
                            <span class="n">allLines</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">lDB</span><span class="p">);</span>
                        <span class="k">else</span>
                            <span class="n">allLines</span><span class="p">.</span><span class="n">RemoveAt</span><span class="p">(</span><span class="n">lineIndex</span><span class="p">);</span>
                    <span class="p">}</span>

                    <span class="c1">//Step5.如果堆栈不为空，则转到第Step3.否则结束循环</span>
                <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">allLines</span><span class="p">.</span><span class="n">Count</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="c1">// 计算邻接边和每边中点距离</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">triAll</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="n">Triangle</span> <span class="n">tri</span> <span class="p">=</span> <span class="n">triAll</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="c1">//// 计算每个三角形每边中点距离</span>
                <span class="c1">//tri.calcWallDistance();</span>

                <span class="c1">// 计算邻居边</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">j</span> <span class="p">&lt;</span> <span class="n">triAll</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span> <span class="n">j</span><span class="p">++)</span>
                <span class="p">{</span>
                    <span class="n">Triangle</span> <span class="n">triNext</span> <span class="p">=</span> <span class="n">triAll</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">tri</span><span class="p">.</span><span class="n">GetID</span><span class="p">()</span> <span class="p">==</span> <span class="n">triNext</span><span class="p">.</span><span class="n">GetID</span><span class="p">())</span>
                        <span class="k">continue</span><span class="p">;</span>

                    <span class="kt">int</span> <span class="n">result</span> <span class="p">=</span> <span class="n">tri</span><span class="p">.</span><span class="n">isNeighbor</span><span class="p">(</span><span class="n">triNext</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="p">!=</span> <span class="p">-</span><span class="m">1</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="n">tri</span><span class="p">.</span><span class="n">SetNeighbor</span><span class="p">(</span><span class="n">result</span> <span class="p">,</span> <span class="n">triNext</span><span class="p">.</span><span class="n">GetID</span><span class="p">()</span> <span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="n">NavResCode</span><span class="p">.</span><span class="n">Success</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div>
<p>这里对如何计算DT点进行一个说明：</p>

<p>Step1. 构造三角形的外接圆，以及外接圆的包围盒</p>

<p>Step2. 依次访问网格包围盒内的每个网格单元：</p>

<p>若某个网格单元中存在可见点 p, 并且 &ang;p1pp2 &gt; &ang;p1p3p2，则令 p3=p，转Step1；</p>

<p>否则，转Step3.</p>

<p>Step3. 若当前网格包围盒内所有网格单元都已被处理完,也即C（p1，p2，p3）内无可见点，则 p3 为的 p1p2 的 DT 点.</p>

<p>核心源码为：</p>
<div class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="c1">/// &lt;summary&gt;</span>
<span class="c1">/// 找到指定边的约束边DT</span>
<span class="c1">/// &lt;/summary&gt;</span>
<span class="c1">/// &lt;param name=&quot;line&quot;&gt;&lt;/param&gt;</span>
<span class="c1">/// &lt;returns&gt;&lt;/returns&gt;</span>
<span class="k">private</span> <span class="kt">bool</span> <span class="nf">FindDT</span><span class="p">(</span><span class="n">Line2D</span> <span class="n">line</span><span class="p">,</span> <span class="k">out</span> <span class="n">Vector2</span> <span class="n">dtPoint</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">dtPoint</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector2</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">line</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">false</span><span class="p">;</span>

    <span class="n">Vector2</span> <span class="n">ptA</span> <span class="p">=</span> <span class="n">line</span><span class="p">.</span><span class="n">GetStartPoint</span><span class="p">();</span>
    <span class="n">Vector2</span> <span class="n">ptB</span> <span class="p">=</span> <span class="n">line</span><span class="p">.</span><span class="n">GetEndPoint</span><span class="p">();</span>

    <span class="n">List</span><span class="p">&lt;</span><span class="n">Vector2</span><span class="p">&gt;</span> <span class="n">visiblePnts</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Vector2</span><span class="p">&gt;();</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="n">Vector2</span> <span class="n">point</span> <span class="k">in</span> <span class="n">allPoints</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">IsPointVisibleOfLine</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">point</span><span class="p">))</span>
            <span class="n">visiblePnts</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">point</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">visiblePnts</span><span class="p">.</span><span class="n">Count</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">false</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">bContinue</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="n">dtPoint</span> <span class="p">=</span> <span class="n">visiblePnts</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>

    <span class="k">do</span>
    <span class="p">{</span>
        <span class="n">bContinue</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="c1">//Step1.构造三角形的外接圆，以及外接圆的包围盒</span>
        <span class="n">Circle</span> <span class="n">circle</span> <span class="p">=</span> <span class="n">NMath</span><span class="p">.</span><span class="n">CreateCircle</span><span class="p">(</span><span class="n">ptA</span><span class="p">,</span> <span class="n">ptB</span><span class="p">,</span> <span class="n">dtPoint</span><span class="p">);</span>
        <span class="n">Rect</span> <span class="n">boundBox</span> <span class="p">=</span> <span class="n">NMath</span><span class="p">.</span><span class="n">GetCircleBoundBox</span><span class="p">(</span><span class="n">circle</span><span class="p">);</span>

        <span class="c1">//Step2. 依次访问网格包围盒内的每个网格单元：</span>
        <span class="c1">//若某个网格单元中存在可见点 p, 并且 &amp;ang;p1pp2 &gt; &amp;ang;p1p3p2，则令 p3=p，转Step1；</span>
        <span class="c1">//否则，转Step3.</span>
        <span class="kt">float</span> <span class="n">angOld</span> <span class="p">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">Math</span><span class="p">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">NMath</span><span class="p">.</span><span class="n">LineRadian</span><span class="p">(</span><span class="n">ptA</span><span class="p">,</span> <span class="n">dtPoint</span><span class="p">,</span> <span class="n">ptB</span><span class="p">));</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="n">Vector2</span> <span class="n">pnt</span> <span class="k">in</span> <span class="n">visiblePnts</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pnt</span> <span class="p">==</span> <span class="n">ptA</span> <span class="p">||</span> <span class="n">pnt</span> <span class="p">==</span> <span class="n">ptB</span> <span class="p">||</span> <span class="n">pnt</span> <span class="p">==</span> <span class="n">dtPoint</span><span class="p">)</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(!</span><span class="n">boundBox</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="n">pnt</span><span class="p">))</span>
                <span class="k">continue</span><span class="p">;</span>

            <span class="kt">float</span> <span class="n">angNew</span> <span class="p">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">Math</span><span class="p">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">NMath</span><span class="p">.</span><span class="n">LineRadian</span><span class="p">(</span><span class="n">ptA</span><span class="p">,</span> <span class="n">pnt</span><span class="p">,</span> <span class="n">ptB</span><span class="p">));</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">angNew</span> <span class="p">&gt;</span> <span class="n">angOld</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">dtPoint</span> <span class="p">=</span> <span class="n">pnt</span><span class="p">;</span>
                <span class="n">bContinue</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">//false 转Step3</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bContinue</span><span class="p">);</span>

    <span class="c1">//Step3. 若当前网格包围盒内所有网格单元都已被处理完，</span>
    <span class="c1">// 也即C（p1，p2，p3）内无可见点，则 p3 为的 p1p2 的 DT 点</span>
    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>为了让各位能更容易读懂此文，此文仍会继续补充。</p>

<p>现在我将所有源码都存放在了Github上，请各位跟随我到Github去取源码：<a href="https://github.com/luzexi/Unity3DNavMesh">https://github.com/luzexi/Unity3DNavMesh</a></p>

<p>转载请注明出处：http://www.luzexi.com</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/%E6%B8%B8%E6%88%8F%E9%80%9A%E7%94%A8%E6%A8%A1%E5%9D%97/2013/09/04/%E8%B5%8C%E5%8D%9A%E6%B8%B8%E6%88%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E6%95%B0%E5%AD%A6%E6%A6%82%E7%8E%87%E8%AE%BA/">
        赌博游戏程序设计中如何运用数学概率论
      </a>
    </h1>

    <span class="post-date">04 Sep 2013</span>

    <p>我们在《王途霸业》中加入了一个非常有特色的系统，叫做&quot;通吃谷&quot;，它是一个类似于街机中的水果机那样的游戏系统。每盘玩家可以押注8个元素中任意个数，按开始后，轮盘开始转动，一旦停下来，停在某个元素上，该元素就算中奖，奖励的倍数由所在的元素显示的倍数决定。</p>

<p>这种类似的押宝游戏我一直想做，但一直没有机会，所以这个押宝系统一直对我笼罩着一层神秘感。随着研究的深入，这层神秘感渐渐消除。</p>

<p>首先说说，如何将概率的准确性达到最高。内容在最下面的转载内容部分。请细细品尝。</p>

<p>再着，先把大部分人认定的那些误区给去除，水果机并不是由算法支撑核心的，那是数学概率论的一部分。每个元素都有一个概率，准确定义这个概率，再加上一定的算法技巧，就会有一个可玩性，体验好，庄家必赢的赌博系统。</p>

<p>首先给8个元素定义一个赔率，5倍，10倍，15倍，20倍，30倍，40倍，50倍，100倍。漫无目的的调整中奖概率是件很痛苦的事情，那我就用一个方法去定义，提取这些倍率的公倍数，在将他们各自的倍率去除以这个公倍数，得到一个基础的中奖概率。这样就得到一个总和加起来并不是百分之一百的概率体系。为什么要是总和不是100%的概率体系呢？我把剩余的未中奖的概率设定为吞吃比率，也就是在这些中奖概率后，有一个一定吞吃所有的概率，当这个吞吃概率被命中时，我们就需要用一定的算法来获得一个不一定不让玩家赢的中奖位置，这个中奖位置也可能是玩家选择的位置，也可以是玩家没有选择的赔率，为了让游戏体验更加的有趣，这个算法非常重要。</p>

<p>其实整个游戏所用到的知识非常简单，而如何让玩家能有一个非常良好的体验，是从吞吃算法和概率调整上下手。我并没有去细致的调整概率，而是做了一个整体概率调整的方案，也就是一个浮点数调整所有概率，当浮点数为1时，是基础的概率，浮点数越大，各元素的中奖概率越大，玩家中奖机会也越大，再加上吞吃算法，整个游戏体验将会是非常切合人的本性。这样，既实现了游戏了娱乐性，也实现了庄家必赢的局面，最重要的是，整个游戏调整起来非常便捷，无需了解很多知识，这也是对项目灵活性的一个很大帮助。</p>

<p>以下内容转载网络，由于页面不复存在，所以只能贴出来：
计算机随机模拟方法，是一种基于&quot;随机数&quot;的计算方法。这一方法源于美国在第二次世界大战中研制原子弹的&quot;曼哈顿计划&quot;。该计划的主持人之一、数学家冯诺伊曼用驰名世界的赌城-摩纳哥的Monte Carlo-来命名这种方法，为它蒙上了一层神秘色彩。Monte Carlo方法的基本思想很早以前就被人们所发现和利用。早在17世纪，人们就知道用事件发生的&quot;频率&quot;来决定事件的&quot;概率&quot;。19世纪人们用投针试验的方法来决定圆周率pi。本世纪40年代电子计算机的出现，特别是近年来高速电子计算机的出现，使得用数学方法在计算机上大量、快速地模拟这样的试验成为可能。考虑平面上的一个边长为1的正方形及其内部的一个形状不规则的&quot;图形&quot;，如何求出这个&quot;图形&quot;的面积呢？Monte Carlo方法是这样一种&quot;随机化&quot;的方法：向该正方形&quot;随机地&quot;投掷N个点,其中有M个点落于&quot;图形&quot;内，则该&quot;图形&quot;的面积近似为M/N。可用民意测验来作一个不严格的比喻。民意测验的人不是征询每一个登记选民的意见，而是通过对选民进行小规模的抽样调查来确定可能的优胜者。其基本思想是一样的。科技计算中的问题比这要复杂得多。比如金融衍生产品（期权、期货、掉期等）的定价及交易风险估算，问题的维数（即变量的个数）可能高达数百甚至数千。对这类问题，难度随维数的增加呈指数增长，这就是所谓的&quot;维数的灾难&quot;(Course Dimensionality)，传统的数值方法难以对付（即使使用速度最快的计算机）。Monte Carlo方法能很好地用来对付维数的灾难，因为该方法的计算复杂性不再依赖于维数。以前那些本来是无法计算的问题现在也能够计算量。为提高方法的效率，科学家们提出了许多所谓的&quot;方差缩减&quot;技巧。另一类形式与Monte Carlo方法相似，但理论基础不同的方法-&quot;拟蒙特卡罗方法&quot;(Quasi-Monte Carlo方法)-近年来也获得迅速发展。我国数学家华罗庚、王元提出的&quot;华-王&quot;方法即是其中的一例。这种方法的基本思想是&quot;用确定性的超均匀分布序列(数学上称为Low Discrepancy Sequences)
代替Monte Carlo方法中的随机数序列。对某些问题该方法的实际速度一般可比Monte Carlo方法提出高数百倍，并可计算精确度。</p>

<p>高精度概率事件，程序实现如下：</p>

<p>设P(i)，其中i=1..n，为n个个体被选择的概率，在轮盘上表示为所占扇区的面积百分比，这里显然sum(P)=1。select用来保存n次选择的结果。</p>

<p>1） 第一种实现办法：可以想象一个转动的轮盘，注意这里轮盘最多只转一圈。每次转轮盘前，把色子随机放到轮盘外缘的某处，即色子不随轮盘转动，以一个随机数sel代表它所处的位置。轮盘转动后，色子所指示的轮盘扇区号不断变化，轮盘停止时色子所指示的轮盘上扇区号，即为本次轮盘赌所选中的个体号。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span>   <span class="o">%</span><span class="n">第i次掷色子</span>
    <span class="n">sel</span> <span class="o">=</span> <span class="n">rand</span><span class="o">;</span> <span class="o">%</span><span class="n">产生一个0</span><span class="err">、</span><span class="mi">1</span><span class="n">之间的随机数</span><span class="err">，</span><span class="n">代表色子在轮盘外缘所指示的位置</span>
    <span class="n">sumPs</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>   <span class="o">%</span><span class="n">轮盘初始转动的位置</span><span class="err">，</span><span class="n">从0变化到1</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>   <span class="o">%</span><span class="n">轮盘初始指示的位置</span>
    <span class="k">while</span> <span class="n">sumPs</span><span class="o">&lt;</span><span class="n">sel</span>   <span class="o">%</span><span class="n">终止条件为轮盘转动的位置超过色子位置</span>
        <span class="n">sumPs</span> <span class="o">=</span> <span class="n">sumPs</span> <span class="o">+</span> <span class="n">P</span><span class="o">(</span><span class="n">j</span><span class="o">)</span>   <span class="o">%</span><span class="n">轮盘转动</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="err">；</span>   <span class="o">%</span><span class="n">轮盘指示位置</span>
    <span class="n">end</span>
    <span class="nf">select</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">=</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>   <span class="o">%</span><span class="n">轮盘停止时色子停留位置所指示的个体</span>
<span class="n">end</span>   <span class="o">%</span><span class="n">循环终了</span><span class="err">，</span><span class="n">会对轮盘上由P所划分出来的n个区间产生n次随机选择</span><span class="err">，</span><span class="n">扇区越大</span><span class="err">，</span><span class="n">该扇区被选中的几率也越大</span>
</code></pre></div>
<p>还需要注意的是：上面的程序中，我们当然可以把n改成2<em>n或者10</em>n，产生的结果都是&#39;个体概率所表示扇区越大，该个体被选中的几率也越大&#39;，并且随着实验次数的增大，这一结果越精确。</p>

<p>2）这种方法可以想象成往划分好扇区的轮盘里扔色子，事先生成一组满足均匀分布的随机数，代表n次掷色子或者n个色子一起扔，轮盘不动，色子所在区域为选择结果。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">r</span> <span class="o">=</span> <span class="n">rand</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="n">n</span><span class="o">)</span>   <span class="o">%</span><span class="n">预先产生n个色子的位置</span><span class="err">，</span><span class="n">注意这里r服从0</span><span class="err">、</span><span class="mi">1</span><span class="n">之间均匀分布</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span>   <span class="o">%</span><span class="n">第i次轮盘赌</span>
    <span class="nf">select</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>   <span class="o">%</span><span class="n">本次轮盘赌的结果初始化为n</span>
    <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span>   <span class="o">%</span><span class="n">轮盘开始转动</span>
        <span class="k">if</span> <span class="nf">r</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">&lt;=</span><span class="n">P</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>   <span class="o">%</span><span class="n">若色子停在轮盘第j扇区</span>
        <span class="nf">select</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span> <span class="o">%</span><span class="n">则第i次轮盘赌的结果为j</span>
        <span class="k">break</span><span class="o">;</span>   <span class="o">%</span><span class="n">第i次轮盘赌结束</span>
    <span class="n">end</span> <span class="o">%~</span><span class="n">第i次轮盘赌结束</span>
<span class="n">end</span> <span class="o">%~</span><span class="n">第i次轮盘赌结束</span>
<span class="n">end</span> <span class="o">%</span><span class="n">n次轮盘赌结束</span>
</code></pre></div><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="o">%%%%%%%%%%%%%</span><span class="n">下面为完整的matlab程序实现</span><span class="o">%%%%%%%%%%%%%%%</span>
<span class="n">function</span> <span class="n">Select</span><span class="o">=</span><span class="n">Roulette</span><span class="o">(</span><span class="n">P</span><span class="o">,</span><span class="n">num</span><span class="o">)</span>
<span class="n">按轮盘赌策略选择下一点</span><span class="o">,</span><span class="n">返回num次轮盘赌结果</span>
<span class="n">第一种轮盘赌方法</span><span class="o">,</span><span class="n">精度很低</span><span class="o">,</span>
 <span class="n">m</span> <span class="o">=</span> <span class="n">length</span><span class="o">(</span><span class="n">P</span><span class="o">);</span>
 <span class="n">Select</span> <span class="o">=</span> <span class="n">zeros</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="n">num</span><span class="o">);</span>
 <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">:</span><span class="n">num</span>
     <span class="nf">Select</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">=</span> <span class="n">m</span><span class="o">;%</span> <span class="n">初始化为最后一个</span>
     <span class="k">for</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">:</span><span class="n">m</span> <span class="o">%:</span><span class="n">按概率选择</span>
       <span class="k">if</span> <span class="nf">P</span><span class="o">(</span><span class="n">j</span><span class="o">)&gt;</span><span class="n">rand</span><span class="o">()</span>
          <span class="n">Select</span><span class="o">(</span><span class="n">i</span><span class="o">)=</span><span class="n">j</span><span class="o">;</span>
          <span class="k">break</span><span class="o">;</span>
       <span class="n">end</span>
     <span class="n">end</span>
 <span class="n">end</span>
<span class="n">第二种轮盘赌方法</span><span class="o">,</span><span class="n">精度较高</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">length</span><span class="o">(</span><span class="n">P</span><span class="o">);</span>
<span class="n">Select</span> <span class="o">=</span> <span class="n">zeros</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="n">num</span><span class="o">);</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">rand</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="n">num</span><span class="o">);</span>
<span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">:</span><span class="n">num</span>
    <span class="n">sumP</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">ceil</span><span class="o">(</span><span class="n">m</span><span class="o">*</span><span class="n">rand</span><span class="o">);</span> <span class="o">%</span><span class="n">产生1</span><span class="o">~</span><span class="n">m之间的随机整数</span>
    <span class="k">while</span> <span class="n">sumP</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
        <span class="n">sumP</span> <span class="o">=</span> <span class="n">sumP</span> <span class="o">+</span> <span class="n">P</span><span class="o">(</span><span class="n">mod</span><span class="o">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span><span class="n">m</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
    <span class="n">end</span>
<span class="nf">Select</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">=</span> <span class="n">mod</span><span class="o">(</span><span class="n">j</span><span class="o">-</span><span class="mi">2</span><span class="o">,</span><span class="n">m</span><span class="o">)+</span><span class="mi">1</span><span class="o">;</span>
<span class="n">end</span>
 <span class="n">本程序中轮盘赌方法的准确程度可由如下程序验证</span>
 <span class="n">P</span><span class="o">=</span><span class="n">rand</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span>
 <span class="n">P</span><span class="o">=</span><span class="n">P</span><span class="o">./</span><span class="n">sum</span><span class="o">(</span><span class="n">P</span><span class="o">);</span>
 <span class="n">Select</span><span class="o">=</span><span class="n">Roulette</span><span class="o">(</span><span class="n">P</span><span class="o">,</span><span class="mi">1</span><span class="n">e6</span><span class="o">);</span>
 <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">:</span><span class="mi">10</span>
     <span class="n">Ps</span><span class="o">(</span><span class="n">i</span><span class="o">)=(</span><span class="n">sum</span><span class="o">(</span><span class="n">Select</span><span class="o">==</span><span class="n">i</span><span class="o">)/</span><span class="mi">1</span><span class="n">e6</span><span class="o">);</span>
 <span class="n">end</span>
<span class="n">最后验证该轮盘赌方法准确程度</span>
<span class="n">比较P和Ps差异大小</span><span class="err">，</span><span class="n">例</span>
</code></pre></div>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84/2013/08/24/%E3%80%8A%E7%8E%8B%E9%80%94%E9%9C%B8%E4%B8%9A%E3%80%8B%E6%88%98%E4%BA%89%E7%AD%96%E7%95%A5%E6%B8%B8%E6%88%8F%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">
        《王途霸业》战争策略游戏的服务器架构设计
      </a>
    </h1>

    <span class="post-date">24 Aug 2013</span>

    <p>王途霸业的服务器架构设计从2012年11月份开始历时10个月从6月份的V1.0.0第一次于玩家见面，到现在V1.1.5版本，这10个月里《王途霸业》经历了很多次架构的调整，客户端和服务端都已经有成型的架构体系，特别是服务器的架构，似乎从一个无知的少年经过1年的时间成长为了一个成熟的白领，可以正式抗起整个家庭的重担。</p>

<p>服务端：</p>

<p>服务端整个架构由4个部分组成,分别是：数据缓冲服务器，逻辑服务器，认证服务器，中心服务器</p>

<p>数据缓冲服务器：对MYSQL数据库从内存上的数据存储优化，将更大程度上优化数据读取和存储效率。</p>

<p>逻辑服务器：不言而明，这是《王途霸业》的核心服务器，对《王途霸业》的游戏正常运行起到了关键性的作用</p>

<p>认证服务器：《王途霸业》是一款面向多平台，多渠道的游戏。她的帐号系统面向《王途霸业》中的所有服务器。也就是说，你只要注册一个帐号，就可以登录任何一个服务器进行游戏。</p>

<p>中心服务器：主要负责对《王途霸业》的服务器地址管理，版本更新和公告内容。她是整个游戏的入口点，就像个看门人，对所有进入游戏的手机终端，检查他们的版本是否最新，并给予当前的全服公告和现有服务器的状态。</p>

<p>《王途霸业》中缓冲服务器有，DB缓冲服务器，日志缓冲服务器</p>

<p>这两个服务器分别分则对游戏数据存储和游戏日志数据存储。</p>

<p>《王途霸业》中逻辑服务器有，GAME游戏服务器，LOGIN登录服务器</p>

<p>游戏服务器对负责游戏的逻辑，而LOGIN服务器负责对帐号验证分流一部分HTTP访问造成的延迟。</p>

<p>《王途霸业》中认证服务器主要负责对所有平台的帐号进行验证，并提供帐号所对应的ID，这里启用HTTP连接，短连接的好处就是不必担心个服务器之间的长连接中断问题，并且能够承载更多的用户，统一所有服务器的帐号。</p>

<p>《王途霸业》中的中心服务器是HTTP方式，也是因为这样能更好的承载客户端入口点，快速让客户端获得最新的更新内容和最新的服务器列表状态。将入口功能集成于一身。</p>

<p><img alt="ddd" class="alignnone size-full wp-image-56" height="761" src="/assets/uploads/2013/08/ddd.png" width="1035" /></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/%E6%B8%B8%E6%88%8F%E9%80%9A%E7%94%A8%E6%A8%A1%E5%9D%97/2013/01/26/%E4%BD%BF%E7%94%A8%E8%A1%8C%E4%B8%BA%E6%A0%91(Behavior%20Tree)%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8FAI/">
        使用行为树(Behavior Tree)实现游戏AI
      </a>
    </h1>

    <span class="post-date">26 Jan 2013</span>

    <p>使用行为树(Behavior Tree)实现游戏AI</p>

<h1>by AKara 2010-12-09 @ http://blog.csdn.net/akara @ akaras@163.com</h1>

<p>谈到游戏AI，很明显智能体拥有的知识条目越多，便显得更智能，但维护庞大数量的知识条目是个噩梦：使用有限状态机(FSM)，分层有限状态机(HFSM)，
决策树(Decision Tree)来实现游戏AI总有那么些不顺意。试试Next-Gen AI的行为树(Behavior Tree)吧。虽说Next-Gen AI，但距其原型提出已有约10年时间，而微软Halo系列估计已用了超过8年了，Spore和一些著名游戏也早已使用行为树作为它们的AI结构。如从未接触，那wikipedia(http://en.wikipedia.org/wiki/Behavior_Trees) 绝对是入门好资料。</p>

<p>先贴本文最具价值图(配色可花了不少时间)</p>

<p><img class="alignnone size-full wp-image-20" src="/assets/uploads/2013/01/213345_1292157838h3CY.jpg" alt="213345_1292157838h3CY" width="444" height="768" /></p>

<p>为显美观：BT被横放，Node层次被刻意减少，Dec被刻意安插，Cond被刻意捏造。</p>

<p>PS：其实真正的高效的Node Group剔除应多加一层Sequence Node。</p>

<p>行为树(Behavior Tree)具有如下的特性：
* 它只有4大类型的Node：
* Composite Node
* Decorator Node
* Condition Node
* Action Node</p>

<p>任何Node被执行后，必须向其Parent Node报告执行结果：成功 / 失败.</p>

<p>这简单的成功 / 失败汇报原则被很巧妙地用于控制整棵树的决策方向。</p>

<p>先看Composite Node，其实它按复合性质还可以细分为3种：</p>

<ul>
<li>Selector Node</li>
</ul>

<p>当执行本类型Node时，它将从begin到end迭代执行自己的Child Node：</p>

<p>如遇到一个Child Node执行后返回True，那停止迭代，</p>

<p>本Node向自己的Parent Node也返回True；否则所有Child Node都返回False，</p>

<p>那本Node向自己的Parent Node返回False。</p>

<ul>
<li>Sequence Node</li>
</ul>

<p>当执行本类型Node时，它将从begin到end迭代执行自己的Child Node：</p>

<p>如遇到一个Child Node执行后返回False，那停止迭代，</p>

<p>本Node向自己的Parent Node也返回False；否则所有Child Node都返回True，</p>

<p>那本Node向自己的Parent Node返回True。</p>

<ul>
<li>Parallel Node</li>
</ul>

<p>并发执行它的所有Child Node。</p>

<p>而向Parent Node返回的值和Parallel Node所采取的具体策略相关：</p>

<p>Parallel Selector Node: 一False则返回False，全True才返回True。</p>

<p>Parallel Sequence Node: 一True则返回True，全False才返回False。</p>

<p>Parallel Hybird Node: 指定数量的Child Node返回True或False后才决定结果。</p>

<p>Parallel Node提供了并发，提高性能。</p>

<p>不需要像Selector/Sequence那样预判哪个Child Node应摆前，哪个应摆后，</p>

<p>常见情况是：</p>

<p>(1)用于并行多棵Action子树。</p>

<p>(2)在Parallel Node下挂一棵子树，并挂上多个Condition Node，</p>

<p>以提供实时性和性能。</p>

<p>Parallel Node增加性能和方便性的同时，也增加实现和维护复杂度。</p>

<p>PS：上面的Selector/Sequence准确来说是Liner Selector/Liner Sequence。</p>

<p>AI术语中称为strictly-order：按既定先后顺序迭代。</p>

<p>Selector和Sequence可以进一步提供非线性迭代的加权随机变种。</p>

<p>Weight Random Selector提供每次执行不同的First True Child Node的可能。</p>

<p>Weight Random Sequence则提供每次不同的迭代顺序。</p>

<p>AI术语中称为partial-order，能使AI避免总出现可预期的结果。</p>

<p>=============================================================</p>

<p>再看Decorator Node，它的功能正如它的字面意思：它将它的Child Node执行</p>

<p>后返回的结果值做额外处理后，再返回给它的Parent Node。很有些AOP的味道。</p>

<p>比如Decorator Not/Decorator FailUtil/Decorator Counter/Decorator Time...</p>

<p>更geek的有Decorator Log/Decorator Ani/Decorator Nothing...</p>

<p>====================================================================</p>

<p>然后是很直白的Condition Node，它仅当满足Condition时返回True。</p>

<p>====================================================================</p>

<p>最后看Action Node，它完成具体的一次(或一个step)的行为，视需求返回值。</p>

<p>而当行为需要分step/Node间进行时，可引入Blackboard进行简单数据交互。</p>

<p>====================================================================</p>

<p>整棵行为树中，只有Condition Node和Action Node才能成为Leaf Node，而也</p>

<p>只有Leaf Node才是需要特别定制的Node；Composite Node和Decorator Node均</p>

<p>用于控制行为树中的决策走向。(所以有些资料中也统称Condition Node和Action</p>

<p>Node为Behavior Node，而Composite Node和Decorator Node为Decider Node。)</p>

<p>更强大的是可以加入Stimulus和Impulse，通过Precondition来判断masks开关。</p>

<p>通过上述的各种Nodes几乎可以实现所有的决策控制：if, while, and, or,</p>

<p>not, counter, time, random, weight random, util...</p>

<p>====================================================================</p>

<p>总的来说，行为树具有如下几种优点，确实是实现AI框架的利器，甚至是一种</p>

<p>通用的可维护的复杂流程管理利器：</p>

<blockquote>
<p>静态性</p>
</blockquote>

<p>越复杂的功能越需要简单的基础，否则最后连自己都玩不过来。</p>

<p>静态是使用行为树需要非常着重的一个要点：即使系统需要某些&quot;动态&quot;性。</p>

<p>其实诸如Stimulus这类动态安插的Node看似强大，</p>

<p>但却破坏了本来易于理解的静态性，弊大于利。</p>

<p>Halo3相对于Halo2对BT AI的一个改进就是去除Stimulus的动态性。</p>

<p>取而代之的做法是使用Behavior Masks，Encounter Attitude，Inhibitions。</p>

<p>原则就是保持全部Node静态，只是根据事件和环境来检查是否启用Node。</p>

<p>静态性直接带来的好处就是整棵树的规划无需再运行时动态调整，为很多优化</p>

<p>和预编辑都带来方便。</p>

<blockquote>
<p>直观性</p>
</blockquote>

<p>行为树可以方便地把复杂的AI知识条目组织得非常直观。</p>

<p>默认的Composite Node的从begin往end的Child Node迭代方式就像是处理一个</p>

<p>预设优先策略队列，也非常符合人类的正常思考模式：先最优再次优。</p>

<p>行为树编辑器对优秀的程序员来说也是唾手可得。</p>

<blockquote>
<p>复用性</p>
</blockquote>

<p>各种Node，包括Leaf Node，可复用性都极高。</p>

<p>实现NPC AI的个性区别甚至可以通过在一棵共用的行为树上不同的位置来</p>

<p>安插Impulse来达到目的。</p>

<p>当然，当NPC需要一个完全不同的大脑，比如70级大BOSS，</p>

<p>与其绞尽脑汁在一棵公用BT安插Impulse，不如重头设计一棵专属BT。</p>

<blockquote>
<p>扩展性</p>
</blockquote>

<p>虽然上述Node之间的组合和搭配使用几乎覆盖所有AI需求。</p>

<p>但也可以容易地为项目量身定做新的Composite Node或Decorator Node。</p>

<p>还可以积累一个项目相关的Node Lib，长远来说非常有价值。</p>

  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page7">Older</a>
  
  
    
      <a class="pagination-item newer" href="/page5">Newer</a>
    
  
</div>
    </div>

    
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?f3d58556a7396e715b3602ef6754cd91";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


  </body>
</html>
