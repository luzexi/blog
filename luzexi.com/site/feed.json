{
    "version": "https://jsonfeed.org/version/1",
    "title": "技术人生",
    "home_page_url": "http://www.luzexi.com/",
    "feed_url": "http://www.luzexi.com/feed.json",
    "description": "技术，哲学，金融",
    "icon": "http://www.luzexi.com/apple-touch-icon.png",
    "favicon": "http://www.luzexi.com/favicon.ico",
    "expired": false,
    
    "author":  {
        "name": "Jesse Lu",
        "url": "http://www.luzexi.com",
        "avatar": null
    },
    
"items": [
    
        {
            "id": "http://www.luzexi.com/2021/07/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B037",
            "title": "读书笔记(三十七) 《心流》#1 - 寻找生命的意义",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：在2020年初就买了《心流》，直到2021年1月才读完第一遍，刹那间开阔了我的眼界。读完本书让我的专注力提高了一个级别，这让我非常兴奋。而这只是我读了第一遍吸收到的10%都不到结果，我想它的魔力远不止于此，于是决定好好复习总结一下书本中的内容，开启了第二遍、第三遍的读书旅程。平时我在工作、生活、交流、学习时，常常很难集中注意力，因此我带着好奇心阅读了这本书。我猜大家应该也和我一样希望自己在专注做一件事情的时候能够拥有更高的效率。本书的核心是心流的最优体验，当你的心流体验最佳时是学习效率最高的时候同时也是最幸福的时刻，里面讲到了关于学习、工作、运动、交际等方面的心流原理和技巧，下面开始详细讲解一下。正文：本书的序是我所读过的书中最长的序，也是有最多名人写感悟的序，整整写了63页的序。序中写了几位高知在细品本书后的体会与感悟，这些体会与感悟给了我很多启发，同时让我对本书整体思想和逻辑有了一个大致的了解。于是本不想对序的内容进行总结的我，由于这本书的序实在太精彩，不由自主的将序也纳入了书本的内容范围，同时也侧面反映了这本书的精彩程度。作者米哈里是一位心理学家，同时他对生物学和社会学也非常关注，他认为这三大学科都是对幸福研究的重要领域。他说，动物的技巧总是能配合实际的需要，因为它们的心灵只容纳当下环境中与它们切身相关、能靠直觉判断的资讯。例如：饥饿的狮子只注意能帮助它猎到羚羊的资讯，吃饱的狮子注意力则完全集中在温暖的阳光上。人类与动物最大的差别就在于神经系统过于发达。虽然我们感知和摄取比其他动物更多的信息，这样有利于人类生存，但烦恼也更多，多知也多忧。例如金钱就困扰了我们大部分人，那么金钱到底是否能让人幸福呢？米哈里认为不是。虽然很多学者也有相同的看法，但这其中一部分人走向了另一个极端，即将幸福替代金钱，将它放在最重要的位置上（以前金钱的位置上），他们认为幸福才是人生理当直奔的主题。米哈里也否认这种判断。事实上，幸福感通常根本不是作为目标存在于人们的追求中，它只不过是表现为目标中附带的现象。米哈里认为，幸福是你全身心投入一桩事物，达到忘我的程度，并由此获得的内心秩序和安宁的状态。例如一位攀岩的选手，不断逼身体发挥所有的极限，直到全身隐隐作痛，然后满怀敬畏的回顾自我，回顾所做的一切，那种佩服的感觉简直无法形容。攀岩最终目的是攀岩，正如写作的目的是写作一样，你唯一征服的是自己的内心，而不是为了到达山顶或乌托邦。当你全力争取胜利时，其他就不那么重要了，甚至连胜利本身都不重要。专注的过程达到忘我的状态，虽说不是幸福的全部，但也是它很重要的一部分。练习专注的过程并不容易，我们往往要花三、五年甚至十年二十年的时间来学习剔除外部干扰、克服紧张，使自己的学习或表演能够放松、自然、快乐。可见学习快乐，并不是一件容易的事。有人认为专注某项活动精神消耗会更大，米哈里则不这么认为。他认为专注让大脑减轻了负担，心流较强的人在专注时会关闭其他资讯通道，只把注意力集中在接收闪光的刺激上。对于这种懂得如何控制意识的人而言，专注反而更轻松。专注通常伴随着挑战，如果挑战不是自愿的，通常无法达到心流。如果目标太难或者太简单，也同样会造成心流的消失，降低幸福感和体验。因此首先我们要自己去寻找目标，其次要去调整目标高度，让目标有一个适合我们的难度。例如历史上贵族阶层脱离生产后，缺少了生活上的挑战，从而面临生命不能承受之轻，一部分贵族陷入物欲不能自拔，另一部分选择体育、音乐、诗歌词赋的艺术化生活方式。这种工作而非无所事事的挑战，例如攀岩、舞蹈、下棋、运动、游戏也可以造就心流。其中体育具备造就心流的最佳条件：明确的目标、即时的回馈、易学难精带来的上不封顶的挑战。它最大的功能是帮助人们控制自己：学习控制自己的身体，学习控制自己的精神，学习控制自己的注意力。这种技巧不持续练习是不会提高的，持续下去主要考的也不是耐心，而是不断发现技巧上的微妙差异，靠的是持续存在的关注点。此外，书中提到了熵，熵是指系统的混乱程度，越混乱，熵值越高。反之，系统内部越有规律，结构越清晰，熵值就越低。例如水变成冰时熵值就很低，变成水蒸气后熵值就很大。熵延伸到我们的人身上也适用，人如果没有节制，没有经过训练，大脑常常会处于混乱状态，虽然你能意识到的可能只有少数几个念头，但在潜意识里却有很多念头在互相冲突，它们在争夺你的注意力，抢夺你的大脑的控制权，并且试图引导、影响你往南辕北辙的方向走。但是如果你进入了心流状态，那就不一样了，虽然你的大脑仍然在高速运转，但是所有这些念头都是非常有规律、有秩序的，就像一支有纪律的军队，被井井有条地组织了起来，高效地去完成一个任务。心流就是这样一个降熵的过程，把原来混乱的心序重新组合成有规律的集体。当心熵比较高时一片混乱，大脑的做功能力很低，很多心理能量都浪费在内耗上了。一旦进入心流状态，心理能量就围绕着同一个主题组织起来，向同一个方向高效输出，此时人的表现也最好。如果一个人经常经历心流，他的心理就会被训练得越来越有秩序，以后进入心流就越来越容易，即使平时不在心流状态下，也不会像一般人那样心猿意马了。降低心熵最典型的例子就是冥想，在冥想中，你摒除杂念，心灵澄净，如一道清澈的心流。经过长期练习之后，哪怕不在冥想之中，你的心灵也会比常人更平静，遇到意外变故时能更快地集中注意力，也就是你的心熵整体降低了。例如高僧冥想多年后才能达到波澜不惊，而我们也同样需要反复练习才能更容易进入心流，但这一切都是值得的。一些虔诚的基督徒也有同样的修为，当他们遇到生活的苦难时，也会难过，但在祷告和与亲友交流后会坦然接受这个苦难，“上帝爱我，他的安排一定自有他的深意”。这样一次次苦难中经历信念的动摇和重固的挑战，最终形成更加坚定的信仰，从而更好地指导自己生活的方方面面，这样全神贯注而又平安喜乐，就等于把整个人生过成了一场大心流。至于普通人怎么把一生过成心流体验，米哈里的建议是，首先要找一个终生的目标，其次不要害怕其复杂性，这就是对你人生意义的挑战。你可以用“行动式生活”和“反省式生活”相结合来逐步应对挑战实现你的目标，只要个人目标与宇宙心流汇合，意义的问题也就迎刃而解了。生命的意义会随着你的心流而升级，从简单舒适，到社会价值，从个人发展，到个人与社会的重新整合，不断升级，挑战也滚滚而来，生命就在这些不断挑战和升级中找到意义。其实降熵的过程有高下，心流也有高下，原本的混沌越多，整合进去的元素越复杂，这个心流就越伟大。也就是说，那些能够整合无比复杂的人生、找到人生意义，整合无比复杂的世界、形成自己的价值观的人，就会有最大的心流。当然，过犹不及，米哈里有时也过分强调了集中注意力的好处。新的研究表明“注意力不集中”也是一种对健康至关重要的状态。在注意力不集中的情况下，我们的大脑大部分时间处于默认模式，这种状态是发散思维和创新的必要条件。如果能在专注一段时候后放松一下准备下一段专注，这样的持续效率会更高。说到底心流只是一个方法，其背后的逻辑是，“通过锻炼控制自己的意识，去获得真正的幸福”。如果你直接追求的并不是幸福，而是把自己变得更复杂，在这个变复杂的过程中，你就能找到乐趣，此时这个状态就是幸福。人生要的不是最后终点的结果，而是每时每刻点点滴滴成长的过程，其实成长本身就是我们的目的。据我所知，90%的家长在孩子学习的时候设定了过重的目标，且常常过于重视技巧和速成，使得学习成为了孩子的负担，这样孩子们自然无法从中得到快乐。如果能把精神集中在过程上，比如优美的画面、欢快的节奏，更多的及时反馈，小目标达成的快乐，这样孩子们的体验就会更好，学习的劲头也更足。说了这么多，其实只有学会控制心灵的人才能决定自己的生活品质，而如果具备了这种能力，也就相当于接近幸福的境界了。快乐与否，取决于内心是否和谐，就得从掌握意识着手，学习从生活中创造乐趣，多加练习就能掌握，化无聊为有趣，也就兴趣盎然了。心流的这个态度是真正的以人为本，当我们做事的时候如果不在乎结果能不能给自己带来多大的利益，而是专注于做这件事本身，就能从中获巨大的乐趣。最后祝大家通过能心流找到人生的意义，我们下篇继续《心流》已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484840&amp;idx=1&amp;sn=a56725615b9e43cdb1f8848b1ef54183&amp;chksm=fc2260afcb55e9b9f3ee8b37a78872623bd55ec5e8151779fa477c30fb9be9c601ad3d78b43d&amp;token=1126834365&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h2 id=\"背景\">背景：</h2><p>在2020年初就买了《心流》，直到2021年1月才读完第一遍，刹那间开阔了我的眼界。</p><p>读完本书让我的专注力提高了一个级别，这让我非常兴奋。而这只是我读了第一遍吸收到的10%都不到结果，我想它的魔力远不止于此，于是决定好好复习总结一下书本中的内容，开启了第二遍、第三遍的读书旅程。</p><p>平时我在工作、生活、交流、学习时，常常很难集中注意力，因此我带着好奇心阅读了这本书。我猜大家应该也和我一样希望自己在专注做一件事情的时候能够拥有更高的效率。</p><p>本书的核心是心流的最优体验，当你的心流体验最佳时是学习效率最高的时候同时也是最幸福的时刻，里面讲到了关于学习、工作、运动、交际等方面的心流原理和技巧，下面开始详细讲解一下。</p><h2 id=\"正文\">正文：</h2><p>本书的序是我所读过的书中最长的序，也是有最多名人写感悟的序，整整写了63页的序。</p><p>序中写了几位高知在细品本书后的体会与感悟，这些体会与感悟给了我很多启发，同时让我对本书整体思想和逻辑有了一个大致的了解。于是本不想对序的内容进行总结的我，由于这本书的序实在太精彩，不由自主的将序也纳入了书本的内容范围，同时也侧面反映了这本书的精彩程度。</p><p>作者米哈里是一位心理学家，同时他对生物学和社会学也非常关注，他认为这三大学科都是对幸福研究的重要领域。</p><p>他说，动物的技巧总是能配合实际的需要，因为它们的心灵只容纳当下环境中与它们切身相关、能靠直觉判断的资讯。例如：饥饿的狮子只注意能帮助它猎到羚羊的资讯，吃饱的狮子注意力则完全集中在温暖的阳光上。</p><p>人类与动物最大的差别就在于神经系统过于发达。虽然我们感知和摄取比其他动物更多的信息，这样有利于人类生存，但烦恼也更多，多知也多忧。</p><h3 id=\"例如金钱就困扰了我们大部分人那么金钱到底是否能让人幸福呢米哈里认为不是\">例如金钱就困扰了我们大部分人，那么金钱到底是否能让人幸福呢？米哈里认为不是。</h3><h3 id=\"虽然很多学者也有相同的看法但这其中一部分人走向了另一个极端即将幸福替代金钱将它放在最重要的位置上以前金钱的位置上他们认为幸福才是人生理当直奔的主题米哈里也否认这种判断\">虽然很多学者也有相同的看法，但这其中一部分人走向了另一个极端，即将幸福替代金钱，将它放在最重要的位置上（以前金钱的位置上），他们认为幸福才是人生理当直奔的主题。米哈里也否认这种判断。</h3><p>事实上，幸福感通常根本不是作为目标存在于人们的追求中，它只不过是表现为目标中附带的现象。米哈里认为，幸福是你全身心投入一桩事物，达到忘我的程度，并由此获得的内心秩序和安宁的状态。</p><p>例如一位攀岩的选手，不断逼身体发挥所有的极限，直到全身隐隐作痛，然后满怀敬畏的回顾自我，回顾所做的一切，那种佩服的感觉简直无法形容。</p><h3 id=\"攀岩最终目的是攀岩正如写作的目的是写作一样你唯一征服的是自己的内心而不是为了到达山顶或乌托邦\">攀岩最终目的是攀岩，正如写作的目的是写作一样，你唯一征服的是自己的内心，而不是为了到达山顶或乌托邦。</h3><h3 id=\"当你全力争取胜利时其他就不那么重要了甚至连胜利本身都不重要\">当你全力争取胜利时，其他就不那么重要了，甚至连胜利本身都不重要。</h3><p>专注的过程达到忘我的状态，虽说不是幸福的全部，但也是它很重要的一部分。</p><p>练习专注的过程并不容易，我们往往要花三、五年甚至十年二十年的时间来学习剔除外部干扰、克服紧张，使自己的学习或表演能够放松、自然、快乐。可见学习快乐，并不是一件容易的事。</p><p>有人认为专注某项活动精神消耗会更大，米哈里则不这么认为。</p><p>他认为专注让大脑减轻了负担，心流较强的人在专注时会关闭其他资讯通道，只把注意力集中在接收闪光的刺激上。对于这种懂得如何控制意识的人而言，专注反而更轻松。</p><h3 id=\"专注通常伴随着挑战如果挑战不是自愿的通常无法达到心流\">专注通常伴随着挑战，如果挑战不是自愿的，通常无法达到心流。</h3><h3 id=\"如果目标太难或者太简单也同样会造成心流的消失降低幸福感和体验\">如果目标太难或者太简单，也同样会造成心流的消失，降低幸福感和体验。</h3><p>因此首先我们要自己去寻找目标，其次要去调整目标高度，让目标有一个适合我们的难度。</p><p>例如历史上贵族阶层脱离生产后，缺少了生活上的挑战，从而面临生命不能承受之轻，一部分贵族陷入物欲不能自拔，另一部分选择体育、音乐、诗歌词赋的艺术化生活方式。这种工作而非无所事事的挑战，例如攀岩、舞蹈、下棋、运动、游戏也可以造就心流。</p><p>其中体育具备造就心流的最佳条件：明确的目标、即时的回馈、易学难精带来的上不封顶的挑战。</p><p>它最大的功能是帮助人们控制自己：学习控制自己的身体，学习控制自己的精神，学习控制自己的注意力。</p><p>这种技巧不持续练习是不会提高的，持续下去主要考的也不是耐心，而是不断发现技巧上的微妙差异，靠的是持续存在的关注点。</p><h3 id=\"此外书中提到了熵熵是指系统的混乱程度越混乱熵值越高反之系统内部越有规律结构越清晰熵值就越低\">此外，书中提到了熵，熵是指系统的混乱程度，越混乱，熵值越高。反之，系统内部越有规律，结构越清晰，熵值就越低。</h3><p>例如水变成冰时熵值就很低，变成水蒸气后熵值就很大。</p><p>熵延伸到我们的人身上也适用，人如果没有节制，没有经过训练，大脑常常会处于混乱状态，虽然你能意识到的可能只有少数几个念头，但在潜意识里却有很多念头在互相冲突，它们在争夺你的注意力，抢夺你的大脑的控制权，并且试图引导、影响你往南辕北辙的方向走。但是如果你进入了心流状态，那就不一样了，虽然你的大脑仍然在高速运转，但是所有这些念头都是非常有规律、有秩序的，就像一支有纪律的军队，被井井有条地组织了起来，高效地去完成一个任务。</p><h3 id=\"心流就是这样一个降熵的过程把原来混乱的心序重新组合成有规律的集体\">心流就是这样一个降熵的过程，把原来混乱的心序重新组合成有规律的集体。</h3><p>当心熵比较高时一片混乱，大脑的做功能力很低，很多心理能量都浪费在内耗上了。一旦进入心流状态，心理能量就围绕着同一个主题组织起来，向同一个方向高效输出，此时人的表现也最好。</p><h3 id=\"如果一个人经常经历心流他的心理就会被训练得越来越有秩序以后进入心流就越来越容易即使平时不在心流状态下也不会像一般人那样心猿意马了\">如果一个人经常经历心流，他的心理就会被训练得越来越有秩序，以后进入心流就越来越容易，即使平时不在心流状态下，也不会像一般人那样心猿意马了。</h3><p>降低心熵最典型的例子就是冥想，在冥想中，你摒除杂念，心灵澄净，如一道清澈的心流。</p><p>经过长期练习之后，哪怕不在冥想之中，你的心灵也会比常人更平静，遇到意外变故时能更快地集中注意力，也就是你的心熵整体降低了。</p><p>例如高僧冥想多年后才能达到波澜不惊，而我们也同样需要反复练习才能更容易进入心流，但这一切都是值得的。</p><p>一些虔诚的基督徒也有同样的修为，当他们遇到生活的苦难时，也会难过，但在祷告和与亲友交流后会坦然接受这个苦难，“上帝爱我，他的安排一定自有他的深意”。</p><p>这样一次次苦难中经历信念的动摇和重固的挑战，最终形成更加坚定的信仰，从而更好地指导自己生活的方方面面，这样全神贯注而又平安喜乐，就等于把整个人生过成了一场大心流。</p><p>至于普通人怎么把一生过成心流体验，米哈里的建议是，首先要找一个终生的目标，其次不要害怕其复杂性，这就是对你人生意义的挑战。</p><p>你可以用“行动式生活”和“反省式生活”相结合来逐步应对挑战实现你的目标，只要个人目标与宇宙心流汇合，意义的问题也就迎刃而解了。</p><p>生命的意义会随着你的心流而升级，从简单舒适，到社会价值，从个人发展，到个人与社会的重新整合，不断升级，挑战也滚滚而来，生命就在这些不断挑战和升级中找到意义。</p><h3 id=\"其实降熵的过程有高下心流也有高下原本的混沌越多整合进去的元素越复杂这个心流就越伟大\">其实降熵的过程有高下，心流也有高下，原本的混沌越多，整合进去的元素越复杂，这个心流就越伟大。</h3><h3 id=\"也就是说那些能够整合无比复杂的人生找到人生意义整合无比复杂的世界形成自己的价值观的人就会有最大的心流\">也就是说，那些能够整合无比复杂的人生、找到人生意义，整合无比复杂的世界、形成自己的价值观的人，就会有最大的心流。</h3><p>当然，过犹不及，米哈里有时也过分强调了集中注意力的好处。新的研究表明“注意力不集中”也是一种对健康至关重要的状态。在注意力不集中的情况下，我们的大脑大部分时间处于默认模式，这种状态是发散思维和创新的必要条件。如果能在专注一段时候后放松一下准备下一段专注，这样的持续效率会更高。</p><p>说到底心流只是一个方法，其背后的逻辑是，“通过锻炼控制自己的意识，去获得真正的幸福”。</p><h3 id=\"如果你直接追求的并不是幸福而是把自己变得更复杂在这个变复杂的过程中你就能找到乐趣此时这个状态就是幸福\">如果你直接追求的并不是幸福，而是把自己变得更复杂，在这个变复杂的过程中，你就能找到乐趣，此时这个状态就是幸福。</h3><h3 id=\"人生要的不是最后终点的结果而是每时每刻点点滴滴成长的过程其实成长本身就是我们的目的\">人生要的不是最后终点的结果，而是每时每刻点点滴滴成长的过程，其实成长本身就是我们的目的。</h3><p>据我所知，90%的家长在孩子学习的时候设定了过重的目标，且常常过于重视技巧和速成，使得学习成为了孩子的负担，这样孩子们自然无法从中得到快乐。如果能把精神集中在过程上，比如优美的画面、欢快的节奏，更多的及时反馈，小目标达成的快乐，这样孩子们的体验就会更好，学习的劲头也更足。</p><p>说了这么多，其实只有学会控制心灵的人才能决定自己的生活品质，而如果具备了这种能力，也就相当于接近幸福的境界了。快乐与否，取决于内心是否和谐，就得从掌握意识着手，学习从生活中创造乐趣，多加练习就能掌握，化无聊为有趣，也就兴趣盎然了。</p><h3 id=\"心流的这个态度是真正的以人为本当我们做事的时候如果不在乎结果能不能给自己带来多大的利益而是专注于做这件事本身就能从中获巨大的乐趣\">心流的这个态度是真正的以人为本，当我们做事的时候如果不在乎结果能不能给自己带来多大的利益，而是专注于做这件事本身，就能从中获巨大的乐趣。</h3><p>最后祝大家通过能心流找到人生的意义，我们下篇继续《心流》</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484840&amp;idx=1&amp;sn=a56725615b9e43cdb1f8848b1ef54183&amp;chksm=fc2260afcb55e9b9f3ee8b37a78872623bd55ec5e8151779fa477c30fb9be9c601ad3d78b43d&amp;token=1126834365&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/07/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B037",
            
            
            
            
            
            "date_published": "2021-07-25T00:00:00+08:00",
            "date_modified": "2021-07-25T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/07/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B036",
            "title": "读书笔记(三十六) 《张爱玲传记》成就富家才女的落魄家族",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：这是一本张爱玲的他传《张爱玲-民国临水照花人》，读书前我问过自己，为什么要读这本书。大概是因为我有两个女儿的关系，使得我迫切想去了解女性的世界，包括她们的成长、她们的心理、她们的困惑、她们的烦恼等。因此我陆陆续续读完了国民四大才女的传记，《林徽因》，《陆小曼》、《张爱玲》、《三毛》传记，我希望通过这四个民国才女来了解女性在成长和发展过程中需要经历的困惑与煎熬。直到有了女儿我才体会到女性与男性有着完全不同的路径和体验，也因此在这些年读了很多关于女性书籍后更深有体会。《张爱玲-民国临水照花人》这本书着实也给了我很多震撼，为此我不得不给自己留下一篇回顾性的文章， 以记录下读完此书后给我带来的感受。正文：张爱玲这一生有很多成就，同时也伴随着很多人对她的负面评价，但无论怎样她都没有被这个世界改变，她一直在活出自己，一直都是那个有才但又羞涩的少女。张爱玲祖上有许多积累，她的祖父、外祖父、曾外祖父都是当时有名的人物，比如曾外祖父就是李鸿章，外祖父是张佩纶科举中榜并后来受军机处重用位于重要职务。整个家族从父亲张延重开始没落，和当时许多高官的子孙一样，由于祖辈只留下遗产而没有留下好的教养和精神力量，因此寻花问柳和赌博是这些富家子弟的常态。父亲张延重与长江水师提督孙女黄逸梵结婚后很快就生下女儿张爱玲，后来他们又生了一个弟弟张子静。母亲和父亲从小的家庭氛围完全不同，父亲更多的是老派作风，性格刻板拘谨，母亲则接受过开明的新式教育，风情漂亮，思想新潮，因此两人格格不入。其实张爱玲从小就在学习氛围浓重的家庭长大，父母很小开始就亲自教她读书写字，而且张爱玲也很喜欢读书，三岁就会背唐诗成了父亲的掌上明珠。好景不长，在那个动荡的时代每个家庭都处于风雨摇摆之中，虽然张家家底比较殷实没有那么辛苦，但父亲与母亲的矛盾愈演愈烈。父亲希望母亲能对自己言听计从，以弥补自己多年来所承受的束缚；母亲则为刚逃脱父权压制又落入夫权专横的家庭感到绝望。失落和失望中父亲开始堕落，出入风月场所，吸鸦片，还带姨太太回家。母亲则喜欢洋派的派对并到处旅游，东南亚、日本、欧洲，对父亲的行为很少在意。其实最初他们两彼此也曾试图为了靠近对方改变过自己的价值观，守旧的父亲为了能追随妻子的思想看起了洋书，一心向往新思想的黄逸梵读起了唐诗，但最终还是以失败告终。母亲对张爱玲的教育一直放在心上，她希望女儿得到新思想的熏陶，所以她精心为女儿安排了钢琴、英文和绘画等课程，这为张爱玲营造出了良好的艺术氛围。最终父亲与母亲还是劳燕分飞了，离婚前母亲告诉父亲自己心已如木头一般，父亲听了心潮涌动，想到对方屡次退步已退无可退不如海阔天空，放各自一条生路。离婚后母亲过的风生水起，旅游、派对、崇尚欧美风格的时尚着装，奢华洋派的生活再一次影响了张爱玲的人生观。这些所有的经历都会使人成长，无论最后定型为哪一种性格，都是自然而然的事情，习惯了分离，就会觉得一个人往前走是种常态。在这个乱世里体会过不同的感受，张爱玲小小年纪就学会了将喜怒哀乐都转换为坚强。因此她一生对任何事情和情感的漠然令人疑惑，殊不知，张爱玲在幼时就已经修炼成风轻云淡的心态，既然要来的早晚要来，不如看淡，走好眼前的路，才是当下最好的生活。父亲对女儿的新思想教育不太支持，所以每次张爱玲向父亲要上课的学费时，父亲都是冷漠以待，因为他无法容忍妻子的影子影射到女儿的身上。父亲后来娶了新妻子，继母对张爱玲很讨厌，也很讨厌前任妻子，这让原本曾一度父女相依为命的温情在继母的影响下落到不堪的地步。最后张爱玲离家出走去了亲身母亲家里，但其实亲生母亲家中并不富有，只能维持现状，无法给张爱玲更好的环境。所以张爱玲很小就知道，唯有知识才能改变命运，当别人还在懵懂迷茫的时候，她早已开始谋划未来。当然张爱玲与母亲也有很大的隔阂，由于张爱玲从习惯了小富家小姐的环境，懒散又不太会家务，出门连路都不认得，因此让母亲很不满意，时常斥责张爱玲。饱尝巨大落差的张爱玲，心里却是介意的，觉得母亲是个自私的女人，为了享乐还要挥霍有限的金钱，对待自己的女儿却要百般计较。张爱玲所经历的畸形家庭裂变，和身边亲人的冷漠自私，尤其是在金钱上遭受过的窘迫和难堪，都深深地影响了她的人生观。后来张爱玲在母亲的帮助下苦读，考上了香港大学。当时香港刚好在战火中，一边读书一边听炮火的经历让张爱玲刻骨铭心。张爱玲的姑姑是张爱玲生命中重要的亲人，母亲崇尚自由很早就去了国外，留下姑姑与她相伴。姑姑的品位与学识也深深影响着张爱玲，在张爱玲离开上海时，姑姑正在英商洋行做事，后来听了别人建议投资股票失败又遇时局动荡，辞职到电台工作了一段时间后，又去了大光明戏院做翻译，后来供职于外资企业，生活还算过的悠闲。在大学里张爱玲仍然需要一边读书一边赚取生活费，写稿的紧张节奏令张爱玲逐渐吃不消，于是她决定退学而正是走上写作的道路。在专注创作后不久，张爱玲体会到了中文小说的谋篇布局，畅意抒怀的创作更让她淋漓尽致发挥自己的才华，曾向往的林语堂方式的英文写作，远不如她书写生活中的市井生活，和身边人的人生百态。从小读《红楼梦》长大的张爱玲，又在港大将西方作家的作品统统学过，将文学精粹炼进自己的文字里，形成独树一帜的风格。张爱玲感情生活中，最著名也是最有争议的一段感情就是与“国民汉奸”胡兰成。胡兰成从桂系军阀到汪精卫伪政府一直走的是邪魔歪道的路线，但对于涉世不深的张爱玲来说她并没有意识到胡兰成的问题所在。汪精卫以重金拉拢胡兰成于羽翼之下，胡兰成成为他们的御用文人，汪精卫伪政府成立后胡兰成上任宣传部部长。当时的张爱玲在感情上相当于一张白纸，而胡兰成则早已经历了风风雨雨无论情场还是职场都是老手了，加之胡兰成在文学上有一些造诣让张爱玲很快就沦陷了。胡兰成一介寒士爬到如今的位置，那些上流社会的美好始终在他心中梦一般的存在着，不曾想到这一切在张爱玲心里竟不值一提。高傲的张爱玲自有她的万丈光芒，无须以自己的家世来衬托，她的不屑与他的渴望形成了鲜明的讽刺。但是胡兰成的细腻还是将张爱玲的骄傲清冷融化，令她产生出多年来从而有过的归属感。他与她之间共生出的默契是张爱玲从未感受过的强烈洪流。坊间的俗语，流氓不可怕，就怕流氓有文化，来形容胡兰成很是贴切。而常年孤僻生活和写作的幻想空间，使得张爱玲脱离了现实，她常常拿小说里的经验来判断胡兰成对待她的真伪。胡兰成在张爱玲结束前就有三位妻子，结婚后又与女同事出轨，在日本战败后逃离中又与好友家中的寡妇联结，最后张爱玲忍无可忍分手道别。可惜已经太晚，张爱玲已经背负了汉奸之妻的身份，出门也要伪装自己以免被人认出。母亲回国后看到张爱玲的样子，认为她沉浸在小城市里裹足不前，应该去往更远的地方看看世界，提高眼界。此时母亲自身的能力非常出色，在国外做尼赫鲁两姐妹的社交秘书，因此对于沉浸在小情小调文字中的张爱玲不屑一顾，甚至有几分怒其不争的愤慨。那个年轻风情文雅的母亲早已消失不见，站在眼前的是一个强势又自我的老太婆。张爱玲太过了解母亲黄逸梵，从小与父母有隔阂的张爱玲羞于喊出“妈妈”这般亲昵的字眼，母亲当年给她心理造成的阴影，让她一直以“婶婶”相称。同时在母亲回来看女儿的时刻，张爱玲提出了要用二两金子还清母女之情，母亲得知女儿的意思后潸然泪下后婉拒了女儿，又踏上了出国的旅程。张爱玲一生未育，当然也无法体会母亲年轻时候所承受的一切，而只是执拗地刺激着给了她生命的母亲。其实母女两人都是极端自我的女子，不同的是，黄逸梵不仅学历高，交际手腕也高明，还有非常远大的追求；张爱玲则大学没有上完因此没有大学毕业证，更不擅长为人处世。与胡兰成离婚后，张爱玲用剧本拍了几部电影非常火热，还与导演桑弧热恋，桑弧是个非常擅长人情世故的人，这是因为在电影行业里必定要学会处世才能混得风生水起。但谈到结婚生子时，张爱玲是抗拒的，她往前看似乎能看到未来的路上有一个身影，重叠着自己年少时的孤独和恐惧，她不想重蹈母亲的覆辙，她恨母亲的自私，但同时她也是与母亲一样的女人，没有能力去爱护幼小的生命。与导演桑弧分手后张爱玲回到了香港大学，继续漂泊继续流浪，漂泊对她与母亲来说似乎已经成为了一种信仰。在香港她认识了邝文美，邝文美相貌不仅秀丽端庄，又是个学识、有见地的才女，她的温柔像一条薄厚相宜的毯子，柔软的话语覆盖过来，让张爱玲四肢百骸都放松下来，像遇见多年未见的幼年伙伴怎么说话也说不完。在那个人人都想出人头地的时代，邝文美始终以家庭为重，将家庭和事业经营得有声有色。她放弃了荣华富贵的机遇，不攀附权贵，却愿意和远在异乡的张爱玲结为知己。邝文美在生活里应付自如的涵养，恰到好处地弥补了张爱玲不理俗事的弱点。邝文美本就对张爱玲非常欣赏，又加之她深谙人性特点，在这样的友谊中，她不但能理解张爱玲天真的幼稚，亦能包容她不明世故的观点。1953年美国放开移民政策，张爱玲在麦卡锡的担保下离开了香港去往美国。在那里她邂逅了共度半生的美国作家普德南.赖雅。赖雅是位德国移民后裔，在哈弗大学读到文艺硕士毕业后，从事英文教室工作。在艺术方面天赋极高，不仅文学作品优秀，摄影也非常出色。先后担任欧洲战地记者，自由撰稿人，欧洲采访知名作家等，经历非常丰富。但此时赖雅已经65岁了，而张爱玲才36岁，她曾坦言：一向对于年纪大一点的人感到亲切，对于和自己年纪差不多的人则有点看不起。在美国几年后，收到了母亲病重的来信，而张爱玲只写了封信，寄上100美元的支票安慰母亲，让她好好治病。母亲在她心里一直都是个强大的女人，她在追求自由的道路上，是个快乐的女神，怎么会被疾病轻易击垮？多年来在两人之间的隔膜已经深成了跨不过去的沟壑。张爱玲同时也流掉了与丈夫赖雅的孩子，这与张爱玲从小缺乏家庭关爱不无关系。母亲黄逸梵手术后不久，就离开了人世，张爱玲默然承受着这个结果，没能满足母亲最后的愿望，张爱玲为此大病一场。母亲走了为女儿留下一箱古董，黄逸梵在病体难抗的绝境里，完全可以卖掉古董来治病，一向有见地的她并没有这么做，而是留给了女人张爱玲，这是母亲对张爱玲最后的眷恋。黄逸梵从张爱玲四岁起就离开了上海前往国外，从此爱上了独自旅行。她跑到欧洲的学校学绘画，又去了马来西亚的华侨学校教书，在瑞士的阿尔卑斯山上，这个三寸金莲的美丽女子勇敢从山顶往下飞滑。在游历过程中所邂逅的情人，无不是浪漫多情又绅士的外国男子，这让她品尝到了爱情的真谛。从家庭角度讲，黄逸梵并不是个称职的母亲，但却对张爱玲的成长有着很深的影响，面对封建旧式家庭的规矩，她毅然站出来拒绝女儿缠足，还自作主张教导女儿英语、钢琴，从而也使得张爱玲熏陶到良好的西方文化。虽然母女俩不常见面，张爱玲在心里将母亲当作偶像，张爱玲对事业的追求和我行我素的风格，以及爱情上的观念，甚至是后来漂泊海外的流浪旅途都与母亲有着惊人的吻合，她们是相爱相杀的母女，黄逸梵的洒脱是留给张爱玲的华丽背影，也是投射在她心灵深处的阴影。1967年赖雅去世，张爱玲心情降到冰点。但天亮了，张爱玲还要将写作进行下去，生命的真相有时候没必要去追根究底，因为宿命的安排或是性格上的原因，也许是一个人最简单的寄托。张爱玲的弟弟张子静在新中国成立后在上海浦东一所小学任教，先后又更换了几所学校，于1986年正式退休搬到江苏路的一个14平方米小屋居住，这是父亲败光家产后遗留给他的最后遗产。1953年父亲张延重肺病去世，继母所依赖房屋被政府回收后的定息也在文革爆发后停止发放。1970年继母双目失明，弟弟给她请了个保姆，1986年离世。1983年弟弟联系到张爱玲并劝姐姐回国，但张爱玲拒绝了弟弟的请求，并告诉他能保持书信就好。到了晚年，张爱玲再读《红楼梦》时在书中读出了整个张氏大家族与贾府相似的命运，从而让她对世事产生出悲凉之感。她年轻时争名夺利的性情，如风过，已是了无痕。往事已过去多年，她对人生有了新的认识，不再是浮于表面的浅薄。虽是个老太太，举止言谈间却完全是一个自闭的少女状态，但神清里有说不出的柔和恬静，遇事的时候也已经能够泰然自若。晚年整理回忆录《对照记》时，选了100多幅她与家人、朋友的照片，母亲、姑姑、闺蜜和她的风华正茂，都定格在光影里。其中最为经典的是那张，最具张爱玲风范，她的脸庞轻轻上扬，眼睛望向侧上方，穿着缎子做的高领短袖，如生在世间的一枝兰，高傲贵气又出尘。1995年9月8日，张爱玲去世在自己的公寓里，旁边的书桌上是一叠铺开的稿纸和一支未合上的笔。张爱玲在遗嘱中把所有的遗产都留给了邝文美。已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484831&amp;idx=1&amp;sn=844da82b7868b494c0d71c1713a813f5&amp;chksm=fc226098cb55e98e222bcbeff2646b4fed2bbc6eb2416090a75aece54d9064258674990ccfc0&amp;token=1401123908&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h1 id=\"背景\">背景：</h1><p>这是一本张爱玲的他传《张爱玲-民国临水照花人》，读书前我问过自己，为什么要读这本书。</p><p>大概是因为我有两个女儿的关系，使得我迫切想去了解女性的世界，包括她们的成长、她们的心理、她们的困惑、她们的烦恼等。因此我陆陆续续读完了国民四大才女的传记，《林徽因》，《陆小曼》、《张爱玲》、《三毛》传记，我希望通过这四个民国才女来了解女性在成长和发展过程中需要经历的困惑与煎熬。</p><h3 id=\"直到有了女儿我才体会到女性与男性有着完全不同的路径和体验也因此在这些年读了很多关于女性书籍后更深有体会\">直到有了女儿我才体会到女性与男性有着完全不同的路径和体验，也因此在这些年读了很多关于女性书籍后更深有体会。</h3><p>《张爱玲-民国临水照花人》这本书着实也给了我很多震撼，为此我不得不给自己留下一篇回顾性的文章， 以记录下读完此书后给我带来的感受。</p><h1 id=\"正文\">正文：</h1><p>张爱玲这一生有很多成就，同时也伴随着很多人对她的负面评价，但无论怎样她都没有被这个世界改变，她一直在活出自己，一直都是那个有才但又羞涩的少女。</p><h3 id=\"张爱玲祖上有许多积累她的祖父外祖父曾外祖父都是当时有名的人物比如曾外祖父就是李鸿章外祖父是张佩纶科举中榜并后来受军机处重用位于重要职务\">张爱玲祖上有许多积累，她的祖父、外祖父、曾外祖父都是当时有名的人物，比如曾外祖父就是李鸿章，外祖父是张佩纶科举中榜并后来受军机处重用位于重要职务。</h3><h3 id=\"整个家族从父亲张延重开始没落和当时许多高官的子孙一样由于祖辈只留下遗产而没有留下好的教养和精神力量因此寻花问柳和赌博是这些富家子弟的常态\">整个家族从父亲张延重开始没落，和当时许多高官的子孙一样，由于祖辈只留下遗产而没有留下好的教养和精神力量，因此寻花问柳和赌博是这些富家子弟的常态。</h3><h3 id=\"父亲张延重与长江水师提督孙女黄逸梵结婚后很快就生下女儿张爱玲后来他们又生了一个弟弟张子静\">父亲张延重与长江水师提督孙女黄逸梵结婚后很快就生下女儿张爱玲，后来他们又生了一个弟弟张子静。</h3><p>母亲和父亲从小的家庭氛围完全不同，父亲更多的是老派作风，性格刻板拘谨，母亲则接受过开明的新式教育，风情漂亮，思想新潮，因此两人格格不入。</p><p>其实张爱玲从小就在学习氛围浓重的家庭长大，父母很小开始就亲自教她读书写字，而且张爱玲也很喜欢读书，三岁就会背唐诗成了父亲的掌上明珠。</p><p>好景不长，在那个动荡的时代每个家庭都处于风雨摇摆之中，虽然张家家底比较殷实没有那么辛苦，但父亲与母亲的矛盾愈演愈烈。</p><h3 id=\"父亲希望母亲能对自己言听计从以弥补自己多年来所承受的束缚母亲则为刚逃脱父权压制又落入夫权专横的家庭感到绝望\">父亲希望母亲能对自己言听计从，以弥补自己多年来所承受的束缚；母亲则为刚逃脱父权压制又落入夫权专横的家庭感到绝望。</h3><p>失落和失望中父亲开始堕落，出入风月场所，吸鸦片，还带姨太太回家。母亲则喜欢洋派的派对并到处旅游，东南亚、日本、欧洲，对父亲的行为很少在意。</p><h3 id=\"其实最初他们两彼此也曾试图为了靠近对方改变过自己的价值观守旧的父亲为了能追随妻子的思想看起了洋书一心向往新思想的黄逸梵读起了唐诗但最终还是以失败告终\">其实最初他们两彼此也曾试图为了靠近对方改变过自己的价值观，守旧的父亲为了能追随妻子的思想看起了洋书，一心向往新思想的黄逸梵读起了唐诗，但最终还是以失败告终。</h3><p>母亲对张爱玲的教育一直放在心上，她希望女儿得到新思想的熏陶，所以她精心为女儿安排了钢琴、英文和绘画等课程，这为张爱玲营造出了良好的艺术氛围。</p><h3 id=\"最终父亲与母亲还是劳燕分飞了离婚前母亲告诉父亲自己心已如木头一般父亲听了心潮涌动想到对方屡次退步已退无可退不如海阔天空放各自一条生路\">最终父亲与母亲还是劳燕分飞了，离婚前母亲告诉父亲自己心已如木头一般，父亲听了心潮涌动，想到对方屡次退步已退无可退不如海阔天空，放各自一条生路。</h3><p>离婚后母亲过的风生水起，旅游、派对、崇尚欧美风格的时尚着装，奢华洋派的生活再一次影响了张爱玲的人生观。</p><p>这些所有的经历都会使人成长，无论最后定型为哪一种性格，都是自然而然的事情，习惯了分离，就会觉得一个人往前走是种常态。</p><p>在这个乱世里体会过不同的感受，张爱玲小小年纪就学会了将喜怒哀乐都转换为坚强。</p><p>因此她一生对任何事情和情感的漠然令人疑惑，殊不知，张爱玲在幼时就已经修炼成风轻云淡的心态，既然要来的早晚要来，不如看淡，走好眼前的路，才是当下最好的生活。</p><p>父亲对女儿的新思想教育不太支持，所以每次张爱玲向父亲要上课的学费时，父亲都是冷漠以待，因为他无法容忍妻子的影子影射到女儿的身上。</p><p>父亲后来娶了新妻子，继母对张爱玲很讨厌，也很讨厌前任妻子，这让原本曾一度父女相依为命的温情在继母的影响下落到不堪的地步。</p><p>最后张爱玲离家出走去了亲身母亲家里，但其实亲生母亲家中并不富有，只能维持现状，无法给张爱玲更好的环境。</p><p>所以张爱玲很小就知道，唯有知识才能改变命运，当别人还在懵懂迷茫的时候，她早已开始谋划未来。</p><p>当然张爱玲与母亲也有很大的隔阂，由于张爱玲从习惯了小富家小姐的环境，懒散又不太会家务，出门连路都不认得，因此让母亲很不满意，时常斥责张爱玲。</p><h3 id=\"饱尝巨大落差的张爱玲心里却是介意的觉得母亲是个自私的女人为了享乐还要挥霍有限的金钱对待自己的女儿却要百般计较\">饱尝巨大落差的张爱玲，心里却是介意的，觉得母亲是个自私的女人，为了享乐还要挥霍有限的金钱，对待自己的女儿却要百般计较。</h3><h3 id=\"张爱玲所经历的畸形家庭裂变和身边亲人的冷漠自私尤其是在金钱上遭受过的窘迫和难堪都深深地影响了她的人生观\">张爱玲所经历的畸形家庭裂变，和身边亲人的冷漠自私，尤其是在金钱上遭受过的窘迫和难堪，都深深地影响了她的人生观。</h3><p>后来张爱玲在母亲的帮助下苦读，考上了香港大学。当时香港刚好在战火中，一边读书一边听炮火的经历让张爱玲刻骨铭心。</p><p>张爱玲的姑姑是张爱玲生命中重要的亲人，母亲崇尚自由很早就去了国外，留下姑姑与她相伴。</p><h3 id=\"姑姑的品位与学识也深深影响着张爱玲在张爱玲离开上海时姑姑正在英商洋行做事后来听了别人建议投资股票失败又遇时局动荡辞职到电台工作了一段时间后又去了大光明戏院做翻译后来供职于外资企业生活还算过的悠闲\">姑姑的品位与学识也深深影响着张爱玲，在张爱玲离开上海时，姑姑正在英商洋行做事，后来听了别人建议投资股票失败又遇时局动荡，辞职到电台工作了一段时间后，又去了大光明戏院做翻译，后来供职于外资企业，生活还算过的悠闲。</h3><p>在大学里张爱玲仍然需要一边读书一边赚取生活费，写稿的紧张节奏令张爱玲逐渐吃不消，于是她决定退学而正是走上写作的道路。</p><h3 id=\"在专注创作后不久张爱玲体会到了中文小说的谋篇布局畅意抒怀的创作更让她淋漓尽致发挥自己的才华曾向往的林语堂方式的英文写作远不如她书写生活中的市井生活和身边人的人生百态\">在专注创作后不久，张爱玲体会到了中文小说的谋篇布局，畅意抒怀的创作更让她淋漓尽致发挥自己的才华，曾向往的林语堂方式的英文写作，远不如她书写生活中的市井生活，和身边人的人生百态。</h3><h3 id=\"从小读红楼梦长大的张爱玲又在港大将西方作家的作品统统学过将文学精粹炼进自己的文字里形成独树一帜的风格\">从小读《红楼梦》长大的张爱玲，又在港大将西方作家的作品统统学过，将文学精粹炼进自己的文字里，形成独树一帜的风格。</h3><p>张爱玲感情生活中，最著名也是最有争议的一段感情就是与“国民汉奸”胡兰成。</p><p>胡兰成从桂系军阀到汪精卫伪政府一直走的是邪魔歪道的路线，但对于涉世不深的张爱玲来说她并没有意识到胡兰成的问题所在。</p><p>汪精卫以重金拉拢胡兰成于羽翼之下，胡兰成成为他们的御用文人，汪精卫伪政府成立后胡兰成上任宣传部部长。</p><p>当时的张爱玲在感情上相当于一张白纸，而胡兰成则早已经历了风风雨雨无论情场还是职场都是老手了，加之胡兰成在文学上有一些造诣让张爱玲很快就沦陷了。</p><p>胡兰成一介寒士爬到如今的位置，那些上流社会的美好始终在他心中梦一般的存在着，不曾想到这一切在张爱玲心里竟不值一提。</p><p>高傲的张爱玲自有她的万丈光芒，无须以自己的家世来衬托，她的不屑与他的渴望形成了鲜明的讽刺。</p><p>但是胡兰成的细腻还是将张爱玲的骄傲清冷融化，令她产生出多年来从而有过的归属感。他与她之间共生出的默契是张爱玲从未感受过的强烈洪流。</p><p>坊间的俗语，流氓不可怕，就怕流氓有文化，来形容胡兰成很是贴切。而常年孤僻生活和写作的幻想空间，使得张爱玲脱离了现实，她常常拿小说里的经验来判断胡兰成对待她的真伪。</p><p>胡兰成在张爱玲结束前就有三位妻子，结婚后又与女同事出轨，在日本战败后逃离中又与好友家中的寡妇联结，最后张爱玲忍无可忍分手道别。</p><p>可惜已经太晚，张爱玲已经背负了汉奸之妻的身份，出门也要伪装自己以免被人认出。</p><h3 id=\"母亲回国后看到张爱玲的样子认为她沉浸在小城市里裹足不前应该去往更远的地方看看世界提高眼界\">母亲回国后看到张爱玲的样子，认为她沉浸在小城市里裹足不前，应该去往更远的地方看看世界，提高眼界。</h3><h3 id=\"此时母亲自身的能力非常出色在国外做尼赫鲁两姐妹的社交秘书因此对于沉浸在小情小调文字中的张爱玲不屑一顾甚至有几分怒其不争的愤慨\">此时母亲自身的能力非常出色，在国外做尼赫鲁两姐妹的社交秘书，因此对于沉浸在小情小调文字中的张爱玲不屑一顾，甚至有几分怒其不争的愤慨。</h3><p>那个年轻风情文雅的母亲早已消失不见，站在眼前的是一个强势又自我的老太婆。</p><p>张爱玲太过了解母亲黄逸梵，从小与父母有隔阂的张爱玲羞于喊出“妈妈”这般亲昵的字眼，母亲当年给她心理造成的阴影，让她一直以“婶婶”相称。</p><h3 id=\"同时在母亲回来看女儿的时刻张爱玲提出了要用二两金子还清母女之情母亲得知女儿的意思后潸然泪下后婉拒了女儿又踏上了出国的旅程\">同时在母亲回来看女儿的时刻，张爱玲提出了要用二两金子还清母女之情，母亲得知女儿的意思后潸然泪下后婉拒了女儿，又踏上了出国的旅程。</h3><h3 id=\"张爱玲一生未育当然也无法体会母亲年轻时候所承受的一切而只是执拗地刺激着给了她生命的母亲\">张爱玲一生未育，当然也无法体会母亲年轻时候所承受的一切，而只是执拗地刺激着给了她生命的母亲。</h3><h3 id=\"其实母女两人都是极端自我的女子不同的是黄逸梵不仅学历高交际手腕也高明还有非常远大的追求张爱玲则大学没有上完因此没有大学毕业证更不擅长为人处世\">其实母女两人都是极端自我的女子，不同的是，黄逸梵不仅学历高，交际手腕也高明，还有非常远大的追求；张爱玲则大学没有上完因此没有大学毕业证，更不擅长为人处世。</h3><p>与胡兰成离婚后，张爱玲用剧本拍了几部电影非常火热，还与导演桑弧热恋，桑弧是个非常擅长人情世故的人，这是因为在电影行业里必定要学会处世才能混得风生水起。</p><h3 id=\"但谈到结婚生子时张爱玲是抗拒的她往前看似乎能看到未来的路上有一个身影重叠着自己年少时的孤独和恐惧她不想重蹈母亲的覆辙她恨母亲的自私但同时她也是与母亲一样的女人没有能力去爱护幼小的生命\">但谈到结婚生子时，张爱玲是抗拒的，她往前看似乎能看到未来的路上有一个身影，重叠着自己年少时的孤独和恐惧，她不想重蹈母亲的覆辙，她恨母亲的自私，但同时她也是与母亲一样的女人，没有能力去爱护幼小的生命。</h3><p>与导演桑弧分手后张爱玲回到了香港大学，继续漂泊继续流浪，漂泊对她与母亲来说似乎已经成为了一种信仰。</p><h3 id=\"在香港她认识了邝文美邝文美相貌不仅秀丽端庄又是个学识有见地的才女她的温柔像一条薄厚相宜的毯子柔软的话语覆盖过来让张爱玲四肢百骸都放松下来像遇见多年未见的幼年伙伴怎么说话也说不完\">在香港她认识了邝文美，邝文美相貌不仅秀丽端庄，又是个学识、有见地的才女，她的温柔像一条薄厚相宜的毯子，柔软的话语覆盖过来，让张爱玲四肢百骸都放松下来，像遇见多年未见的幼年伙伴怎么说话也说不完。</h3><h3 id=\"在那个人人都想出人头地的时代邝文美始终以家庭为重将家庭和事业经营得有声有色她放弃了荣华富贵的机遇不攀附权贵却愿意和远在异乡的张爱玲结为知己\">在那个人人都想出人头地的时代，邝文美始终以家庭为重，将家庭和事业经营得有声有色。她放弃了荣华富贵的机遇，不攀附权贵，却愿意和远在异乡的张爱玲结为知己。</h3><h3 id=\"邝文美在生活里应付自如的涵养恰到好处地弥补了张爱玲不理俗事的弱点邝文美本就对张爱玲非常欣赏又加之她深谙人性特点在这样的友谊中她不但能理解张爱玲天真的幼稚亦能包容她不明世故的观点\">邝文美在生活里应付自如的涵养，恰到好处地弥补了张爱玲不理俗事的弱点。邝文美本就对张爱玲非常欣赏，又加之她深谙人性特点，在这样的友谊中，她不但能理解张爱玲天真的幼稚，亦能包容她不明世故的观点。</h3><p>1953年美国放开移民政策，张爱玲在麦卡锡的担保下离开了香港去往美国。在那里她邂逅了共度半生的美国作家普德南.赖雅。</p><p>赖雅是位德国移民后裔，在哈弗大学读到文艺硕士毕业后，从事英文教室工作。在艺术方面天赋极高，不仅文学作品优秀，摄影也非常出色。先后担任欧洲战地记者，自由撰稿人，欧洲采访知名作家等，经历非常丰富。</p><p>但此时赖雅已经65岁了，而张爱玲才36岁，她曾坦言：一向对于年纪大一点的人感到亲切，对于和自己年纪差不多的人则有点看不起。</p><p>在美国几年后，收到了母亲病重的来信，而张爱玲只写了封信，寄上100美元的支票安慰母亲，让她好好治病。</p><p>母亲在她心里一直都是个强大的女人，她在追求自由的道路上，是个快乐的女神，怎么会被疾病轻易击垮？多年来在两人之间的隔膜已经深成了跨不过去的沟壑。</p><h3 id=\"张爱玲同时也流掉了与丈夫赖雅的孩子这与张爱玲从小缺乏家庭关爱不无关系\">张爱玲同时也流掉了与丈夫赖雅的孩子，这与张爱玲从小缺乏家庭关爱不无关系。</h3><h3 id=\"母亲黄逸梵手术后不久就离开了人世张爱玲默然承受着这个结果没能满足母亲最后的愿望张爱玲为此大病一场\">母亲黄逸梵手术后不久，就离开了人世，张爱玲默然承受着这个结果，没能满足母亲最后的愿望，张爱玲为此大病一场。</h3><h3 id=\"母亲走了为女儿留下一箱古董黄逸梵在病体难抗的绝境里完全可以卖掉古董来治病一向有见地的她并没有这么做而是留给了女人张爱玲这是母亲对张爱玲最后的眷恋\">母亲走了为女儿留下一箱古董，黄逸梵在病体难抗的绝境里，完全可以卖掉古董来治病，一向有见地的她并没有这么做，而是留给了女人张爱玲，这是母亲对张爱玲最后的眷恋。</h3><p>黄逸梵从张爱玲四岁起就离开了上海前往国外，从此爱上了独自旅行。</p><h3 id=\"她跑到欧洲的学校学绘画又去了马来西亚的华侨学校教书在瑞士的阿尔卑斯山上这个三寸金莲的美丽女子勇敢从山顶往下飞滑在游历过程中所邂逅的情人无不是浪漫多情又绅士的外国男子这让她品尝到了爱情的真谛从家庭角度讲黄逸梵并不是个称职的母亲但却对张爱玲的成长有着很深的影响面对封建旧式家庭的规矩她毅然站出来拒绝女儿缠足还自作主张教导女儿英语钢琴从而也使得张爱玲熏陶到良好的西方文化\">她跑到欧洲的学校学绘画，又去了马来西亚的华侨学校教书，在瑞士的阿尔卑斯山上，这个三寸金莲的美丽女子勇敢从山顶往下飞滑。在游历过程中所邂逅的情人，无不是浪漫多情又绅士的外国男子，这让她品尝到了爱情的真谛。从家庭角度讲，黄逸梵并不是个称职的母亲，但却对张爱玲的成长有着很深的影响，面对封建旧式家庭的规矩，她毅然站出来拒绝女儿缠足，还自作主张教导女儿英语、钢琴，从而也使得张爱玲熏陶到良好的西方文化。</h3><h3 id=\"虽然母女俩不常见面张爱玲在心里将母亲当作偶像张爱玲对事业的追求和我行我素的风格以及爱情上的观念甚至是后来漂泊海外的流浪旅途都与母亲有着惊人的吻合她们是相爱相杀的母女黄逸梵的洒脱是留给张爱玲的华丽背影也是投射在她心灵深处的阴影\">虽然母女俩不常见面，张爱玲在心里将母亲当作偶像，张爱玲对事业的追求和我行我素的风格，以及爱情上的观念，甚至是后来漂泊海外的流浪旅途都与母亲有着惊人的吻合，她们是相爱相杀的母女，黄逸梵的洒脱是留给张爱玲的华丽背影，也是投射在她心灵深处的阴影。</h3><p>1967年赖雅去世，张爱玲心情降到冰点。但天亮了，张爱玲还要将写作进行下去，生命的真相有时候没必要去追根究底，因为宿命的安排或是性格上的原因，也许是一个人最简单的寄托。</p><h3 id=\"张爱玲的弟弟张子静在新中国成立后在上海浦东一所小学任教先后又更换了几所学校于1986年正式退休搬到江苏路的一个14平方米小屋居住这是父亲败光家产后遗留给他的最后遗产\">张爱玲的弟弟张子静在新中国成立后在上海浦东一所小学任教，先后又更换了几所学校，于1986年正式退休搬到江苏路的一个14平方米小屋居住，这是父亲败光家产后遗留给他的最后遗产。</h3><p>1953年父亲张延重肺病去世，继母所依赖房屋被政府回收后的定息也在文革爆发后停止发放。1970年继母双目失明，弟弟给她请了个保姆，1986年离世。</p><p>1983年弟弟联系到张爱玲并劝姐姐回国，但张爱玲拒绝了弟弟的请求，并告诉他能保持书信就好。</p><h3 id=\"到了晚年张爱玲再读红楼梦时在书中读出了整个张氏大家族与贾府相似的命运从而让她对世事产生出悲凉之感\">到了晚年，张爱玲再读《红楼梦》时在书中读出了整个张氏大家族与贾府相似的命运，从而让她对世事产生出悲凉之感。</h3><h3 id=\"她年轻时争名夺利的性情如风过已是了无痕往事已过去多年她对人生有了新的认识不再是浮于表面的浅薄\">她年轻时争名夺利的性情，如风过，已是了无痕。往事已过去多年，她对人生有了新的认识，不再是浮于表面的浅薄。</h3><h3 id=\"虽是个老太太举止言谈间却完全是一个自闭的少女状态但神清里有说不出的柔和恬静遇事的时候也已经能够泰然自若\">虽是个老太太，举止言谈间却完全是一个自闭的少女状态，但神清里有说不出的柔和恬静，遇事的时候也已经能够泰然自若。</h3><p>晚年整理回忆录《对照记》时，选了100多幅她与家人、朋友的照片，母亲、姑姑、闺蜜和她的风华正茂，都定格在光影里。</p><p>其中最为经典的是那张，最具张爱玲风范，她的脸庞轻轻上扬，眼睛望向侧上方，穿着缎子做的高领短袖，如生在世间的一枝兰，高傲贵气又出尘。</p><p>1995年9月8日，张爱玲去世在自己的公寓里，旁边的书桌上是一叠铺开的稿纸和一支未合上的笔。</p><h3 id=\"张爱玲在遗嘱中把所有的遗产都留给了邝文美\">张爱玲在遗嘱中把所有的遗产都留给了邝文美。</h3><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484831&amp;idx=1&amp;sn=844da82b7868b494c0d71c1713a813f5&amp;chksm=fc226098cb55e98e222bcbeff2646b4fed2bbc6eb2416090a75aece54d9064258674990ccfc0&amp;token=1401123908&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/07/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B036",
            
            
            
            
            
            "date_published": "2021-07-17T00:00:00+08:00",
            "date_modified": "2021-07-17T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/07/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B035",
            "title": "读书笔记(三十五) 《如何高效阅读 - 下》",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：与前两本《如何阅读》、《如何阅读一本书》相比《如何有效阅读一本书》这本书更加注重阅读实用技巧，从选书、读书、笔记、重读四个方面详细讲解了作者自己在实践过程中的经验。正文：全书11万字分为五个部分，选书、读书、笔记、重读、实用技巧。如何选书？书有很多种，好坏也是天差地别，坏书不仅会浪费我们很多时间，还会灌输我们错误的观念。因此如何选书，如何选好书就成提高读书效率的关键。作者提到选书最重要的是主动选择而不是被动选择，主动去做筛选会比被动的选择遇到好书的概率要大的多。有这四个途径可以提高选到好书的概率：  生活中大众认可的经典书籍  自己看过的好书中提到的书  告知人书评中提到的好书  知识品位高的朋友提到的好书选书的过程中，我们依然要保持警惕，时时刻刻主动选择而不是被动被推荐无脑接受。有时候看到好书不一定要买，其实各领域的好书有很多，如果不是你当下需要的书，即使是好书买来也没有用，堆积在那里会成为你的心里负担。我们应该尽量做到，当真正需要的时候才购买，买回来尽量立即看起来，而不是认为是好书就买了堆积在那里给自己造成心里负担，其实买了没看也会给自己造成挫败感。作者说除了选好书，我们也需要一些能与自己长期共处的书，当失落时、走投无路时，那本书会成为我们的心灵支柱。如何读书？提高读书效率的一个重要指标就是养成好习惯，这个习惯包括：坚持每日读书的习惯，坚持做读书笔记的习惯，坚持重读巩固复习的习惯。其中做笔记的方法和技巧，以及重读的技巧特别重要，这两个话题在下面的内容中会详细介绍。前面说要读好书，但其实现实中坚持“只选好书，只读好书”可能不太现实，我们可以张弛有度地贯彻“好书要细细研读，其他书则粗读略读”原则，这样会让读书效率更高。其次在读书过程中，积极的“跳读”和“略读”，并在比较难理解的部分换上低速齿轮认真品读，保持读书张弛有度的节奏，可以把更多精力集中在好书的精华内容上，这样读书效率会更高。最后读书的目的是用自己的方式去学习，而不是模仿别人的方法。因此在读书学习过程中，用自己的方法吸收学到的知识才是最重要的，再根据书中提到的技巧加以改进，这样的学习效率会更高。我们可以看到整个读书流程为：  主动选择好书  只购买真正要看的书  读书并记录  读后总结与评价  复习与巩固为什么要做笔记？我们要学的东西实在太多，而我们的人脑记忆力又非常有限，无法在同一时间记住太多的知识和信息。学了忘，忘了学，如此往复效率太差。笔记就给予了我们快速恢复记忆的途径，它不但可以帮助我们快速恢复记忆，还可以帮助我们加深记忆，让知识记忆的保存时间更长一些。我们在做笔记时就相当于在做归纳和重读，特别是当我们要把笔记写成文章发表出去时，我们会不自觉的更加仔细、小心并且反复琢磨知识要点。即使不发表读书文章，你也会发现，在读完一本书后其实记不住多少内容，只有对书中内容做出反应，进行主动思考，才能真正掌握这本书的内容。读书笔记就是这种帮助我们升华的工具，可以让读书活动完成从生搬硬套到独创思维的飞跃。其实日常生活中说的所谓“理解精髓”就够了只是个美好的愿望，你不把整个知识理顺了并记录下来，即使长期读书的人也会在很长时间后把看过的书忘得一干二净。如果只是这样读过，就等于没有读过。如果只是用眼睛看过，而没有记在脑子里，读再多的书也都会忘记。读完每本书如果都能有扎实的收获，那么每个月读多少本书，一本书花几小时读完的能力，在这个目标面前都是苍白无力的。认真选择每一本满足自己需求的书，然后真挚地与每一本书对话，努力从书中学到知识，这才是明智的做法。当达到这样读书后扎实收获的目标后，再去训练更快的读书速度其实也为时不晚。当你以思想输出为前提去读书时，思想输入的质量也会提升，亲手写文章的好处比你想象的大很多。当你一遍遍思考如何写文章时，不由自主的就多读了几遍书，尤其是对没有读懂的部分，在不断思考和不断重读过程中，你对书本知识的理解也进入到了更深层次的境界。如果你以输出为目的去读书，那么读书的质量和效率会很高。如果读书的目标是写读书笔记，那么读书效率会比随便读一读要高出很多，如果你以发表自己的理解和总结性文章为目标，那么你的读书效率会更高，如果你以输出讲座为目标，那么你的读书效率会特别高。道理很简单因为当我们知道自己要在别人面前表达自己的想法后，我们才会去调查那些我们从未在意过的出处、资料，重新审视自己的观点，建立起系统的知识体系。这时你会发现，这个补充学习的过程就像从零学起一样，需要费不少功夫。而能够正视这些辛苦工作的人，最后都不再对知识一知半解了。因此掌握再多信息，如果不去积极输出，也无法形成知识体系。如何做笔记？有时你可能感觉到没什么可写的，但只要你拿起笔来随便写两句，说不定就有惊喜等着你。读书笔记三步骤：  读书  划重点  写读后总结读书阶段，要在书上做一些简单的记号，为写读书笔记做准备。这里作者介绍了自己的读书方法：第一遍通读时，把有价值的页折起来，第二遍重读时只读折起来的部分，并且认为重要的划线或标记，第三遍再重读时只读划线和标记部分，认为精华的部分摘抄到笔记里。最后把摘抄的精华加上自己的理解把它们写成文章。作者自己发明了葱郁火锅笔记法，它有两部分组成：  摘抄下重要语句  下方写上自己的感受即重要的内容摘抄下来，下面写下自己的感想和评论。（摘抄和评论交替进行，趁着自己印象还鲜明写下自己的感想）作者认为，自己当下的想法才是最重要的，摘抄这一段文章的原因和自己当时的想法才是日后值得参考的贵重资料。如何重读与巩固？读完一本书后的时间越长，在读书时产生的环境变化就会越模糊，你就越能冷静地看待书中的观点。因此不要在意一本书读完已经搁置了多久，再次重读时会有别样的风味。重读笔记的时间点：睡觉前、洗完澡后、晚饭后、思绪进入死胡同时，可以是碎片时间也最好是安静的环境。重读习惯养成：  量化重读频率，每周一次或者三天一次。  多种重读方式交替进行  重读后写复习总结并发布到博客上多种重读方式：  想要简单回顾时，重读读书笔记  想回忆起更多时，参考书中的重点段落  想从头开始看起时，重读原书每一次的复习总结都是对自己知识的再回顾和再理解，把这些复习总结放到博客上同样可以作为思想输出的一部分，而且每次复习总结后都会让自己对这部分知识理解的更加透彻，记忆也更加久远。吸收知识的重要手段主题阅读同一个主题的选出三本以上的书同时阅读或者依次阅读，读完记录要点，做笔记，再把三本笔记合起来写一篇文章，这篇文章就相当于是让三个专家围绕某个问题给自己提意见，让他们进行讨论而我则思考并听取意见。经过整理和总结后，渐渐的得出一些自己的结论，这些结论是由三个专家共同讨论得出的，这样的结论比较客观且符合当下的情况。让读书百遍更轻松的方法就是阅读读书笔记，通过读书笔记缩短复习时间、提高记忆恢复速度，以笔记内容为线索回忆整个读书过程，达到快速恢复记忆的目的。读书实用技巧作者列举了20条读书实用技巧，这里我筛选了一部分因为有些确实没什么用处，也是结合我实际阅读学习过程中的经验：  读书过程中多用参考书，地图、图鉴、统计数据、百科全书、年表、词典等帮助自己加深理解书中内容。  随机阅读，偶尔阅读一些自己从来没有接触过领域的书籍，打破你的常规思维，有时候这种方式会给你一种豁然开朗的感觉。  由浅入深的吃透难懂的书，太难的书会让我们有强烈的挫败感，不如先从入门版、图解版、漫画版、精编版开始阅读，逐步熟悉、理解、渗透，最后再去阅读原著能收获更多的成就感和自信。  把书份分类堆放，未阅读的、阅读过的、已经做过笔记的、已经写好总结文章，并且分类摆放，这样会给自己一个方向，随着时间推移读完的和做完笔记的书堆放的会越来越多，会有更多的成就感，也激励自己阅读更多的书。  把经典名著放在枕头边，这些书比较难度，我们可以睡觉前看两页慢慢读，反复读几年也非常好，因为这些书是经得起考验的，读的次数阅读读的时间越久，我们从中吸取的知识就越多。  同时阅读几本书，为了减少自己在读书时的枯燥感，三本书的领域应该是不一样的，当我们觉得一本书读的很痛苦时就可以换另外一本读，从而增加愉悦感保持心灵舒畅。  在办公桌和家里的每个角落都放满书，给自己一个身边满是书的氛围，同时当我们想看书的时候就可以随时抓到一本，不给自己找更多没有书看的理由。  去掉外封面让读书变得轻松，有多书的外封面有自己的宣传设计，这些外封面在读书的时候很不舒服，不如去掉它们给自己一个轻松的书。  用边撕边读的方式阅读杂志，并不一定要从头到尾顺序读，读完的就撕下来扔进垃圾桶。  偶尔的音频、视频读书也是一种读书的一种方式，当读书累的时候可以换一下轻松的方式阅读，特别读不熟悉的领域时这种轻松的方式可能会让我们更加容易的跨过这道门槛。  买一支你喜欢的钢笔，读书笔记时一直用它，这会带动我们写文章的热情，会有总想用这支笔写点什么感觉，同时调节钢笔出水、吸墨、擦拭等也能激发我们的写作热情。  把自己信奉的名言贴在显眼的位置，让自己更有长远的目标和行动指南。  从摘抄开始写作，写文章时时常会遇到瓶颈，我们可以尝试先把喜欢的文章抄写下来，抄写的同时自己想写的东西会从脑中涌现出来。  写好的文章打印出来，这样更方便我们随手翻阅，也更容易帮助我们重组知识创建出新的点子。  记录读书的时间过程，在书的首页上，记下自己的名字、购买日期、阅读结束日期、标记结束日期、完成读书标记日期，不但让自己的读书过程更清晰，也让这本书完完全全归属了我们。  经常整理书籍摆放归类，经常整理自己的读书笔记，会让自己在读书习惯，以及复习巩固时有更好的提升。已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484825&amp;idx=1&amp;sn=72548c4cb8aaf9961b3ea77cc0905ba6&amp;chksm=fc22609ecb55e988c328a3a7b71c9614dd6e5d4b0df369ffd8d5275603ab7afd3ec9e01b036a&amp;token=1401123908&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h1 id=\"背景\">背景：</h1><p>与前两本《如何阅读》、《如何阅读一本书》相比《如何有效阅读一本书》这本书更加注重阅读实用技巧，从选书、读书、笔记、重读四个方面详细讲解了作者自己在实践过程中的经验。</p><h1 id=\"正文\">正文：</h1><p>全书11万字分为五个部分，选书、读书、笔记、重读、实用技巧。</p><h1 id=\"如何选书\">如何选书？</h1><h3 id=\"书有很多种好坏也是天差地别坏书不仅会浪费我们很多时间还会灌输我们错误的观念因此如何选书如何选好书就成提高读书效率的关键\">书有很多种，好坏也是天差地别，坏书不仅会浪费我们很多时间，还会灌输我们错误的观念。因此如何选书，如何选好书就成提高读书效率的关键。</h3><p>作者提到选书最重要的是主动选择而不是被动选择，主动去做筛选会比被动的选择遇到好书的概率要大的多。</p><p>有这四个途径可以提高选到好书的概率：</p><ol>  <li>生活中大众认可的经典书籍</li>  <li>自己看过的好书中提到的书</li>  <li>告知人书评中提到的好书</li>  <li>知识品位高的朋友提到的好书</li></ol><p>选书的过程中，我们依然要保持警惕，时时刻刻主动选择而不是被动被推荐无脑接受。</p><p>有时候看到好书不一定要买，其实各领域的好书有很多，如果不是你当下需要的书，即使是好书买来也没有用，堆积在那里会成为你的心里负担。</p><h3 id=\"我们应该尽量做到当真正需要的时候才购买买回来尽量立即看起来而不是认为是好书就买了堆积在那里给自己造成心里负担其实买了没看也会给自己造成挫败感\">我们应该尽量做到，当真正需要的时候才购买，买回来尽量立即看起来，而不是认为是好书就买了堆积在那里给自己造成心里负担，其实买了没看也会给自己造成挫败感。</h3><p>作者说除了选好书，我们也需要一些能与自己长期共处的书，当失落时、走投无路时，那本书会成为我们的心灵支柱。</p><h1 id=\"如何读书\">如何读书？</h1><p>提高读书效率的一个重要指标就是养成好习惯，这个习惯包括：坚持每日读书的习惯，坚持做读书笔记的习惯，坚持重读巩固复习的习惯。</p><p>其中做笔记的方法和技巧，以及重读的技巧特别重要，这两个话题在下面的内容中会详细介绍。</p><h3 id=\"前面说要读好书但其实现实中坚持只选好书只读好书可能不太现实我们可以张弛有度地贯彻好书要细细研读其他书则粗读略读原则这样会让读书效率更高\">前面说要读好书，但其实现实中坚持“只选好书，只读好书”可能不太现实，我们可以张弛有度地贯彻“好书要细细研读，其他书则粗读略读”原则，这样会让读书效率更高。</h3><h3 id=\"其次在读书过程中积极的跳读和略读并在比较难理解的部分换上低速齿轮认真品读保持读书张弛有度的节奏可以把更多精力集中在好书的精华内容上这样读书效率会更高\">其次在读书过程中，积极的“跳读”和“略读”，并在比较难理解的部分换上低速齿轮认真品读，保持读书张弛有度的节奏，可以把更多精力集中在好书的精华内容上，这样读书效率会更高。</h3><h3 id=\"最后读书的目的是用自己的方式去学习而不是模仿别人的方法因此在读书学习过程中用自己的方法吸收学到的知识才是最重要的再根据书中提到的技巧加以改进这样的学习效率会更高\">最后读书的目的是用自己的方式去学习，而不是模仿别人的方法。因此在读书学习过程中，用自己的方法吸收学到的知识才是最重要的，再根据书中提到的技巧加以改进，这样的学习效率会更高。</h3><p>我们可以看到整个读书流程为：</p><ol>  <li>主动选择好书</li>  <li>只购买真正要看的书</li>  <li>读书并记录</li>  <li>读后总结与评价</li>  <li>复习与巩固</li></ol><h1 id=\"为什么要做笔记\">为什么要做笔记？</h1><p>我们要学的东西实在太多，而我们的人脑记忆力又非常有限，无法在同一时间记住太多的知识和信息。</p><h3 id=\"学了忘忘了学如此往复效率太差笔记就给予了我们快速恢复记忆的途径它不但可以帮助我们快速恢复记忆还可以帮助我们加深记忆让知识记忆的保存时间更长一些\">学了忘，忘了学，如此往复效率太差。笔记就给予了我们快速恢复记忆的途径，它不但可以帮助我们快速恢复记忆，还可以帮助我们加深记忆，让知识记忆的保存时间更长一些。</h3><p>我们在做笔记时就相当于在做归纳和重读，特别是当我们要把笔记写成文章发表出去时，我们会不自觉的更加仔细、小心并且反复琢磨知识要点。</p><p>即使不发表读书文章，你也会发现，在读完一本书后其实记不住多少内容，只有对书中内容做出反应，进行主动思考，才能真正掌握这本书的内容。</p><p>读书笔记就是这种帮助我们升华的工具，可以让读书活动完成从生搬硬套到独创思维的飞跃。</p><p>其实日常生活中说的所谓“理解精髓”就够了只是个美好的愿望，你不把整个知识理顺了并记录下来，即使长期读书的人也会在很长时间后把看过的书忘得一干二净。</p><h3 id=\"如果只是这样读过就等于没有读过如果只是用眼睛看过而没有记在脑子里读再多的书也都会忘记\">如果只是这样读过，就等于没有读过。如果只是用眼睛看过，而没有记在脑子里，读再多的书也都会忘记。</h3><h3 id=\"读完每本书如果都能有扎实的收获那么每个月读多少本书一本书花几小时读完的能力在这个目标面前都是苍白无力的\">读完每本书如果都能有扎实的收获，那么每个月读多少本书，一本书花几小时读完的能力，在这个目标面前都是苍白无力的。</h3><h3 id=\"认真选择每一本满足自己需求的书然后真挚地与每一本书对话努力从书中学到知识这才是明智的做法\">认真选择每一本满足自己需求的书，然后真挚地与每一本书对话，努力从书中学到知识，这才是明智的做法。</h3><p>当达到这样读书后扎实收获的目标后，再去训练更快的读书速度其实也为时不晚。</p><p>当你以思想输出为前提去读书时，思想输入的质量也会提升，亲手写文章的好处比你想象的大很多。</p><p>当你一遍遍思考如何写文章时，不由自主的就多读了几遍书，尤其是对没有读懂的部分，在不断思考和不断重读过程中，你对书本知识的理解也进入到了更深层次的境界。</p><p>如果你以输出为目的去读书，那么读书的质量和效率会很高。</p><h3 id=\"如果读书的目标是写读书笔记那么读书效率会比随便读一读要高出很多如果你以发表自己的理解和总结性文章为目标那么你的读书效率会更高如果你以输出讲座为目标那么你的读书效率会特别高\">如果读书的目标是写读书笔记，那么读书效率会比随便读一读要高出很多，如果你以发表自己的理解和总结性文章为目标，那么你的读书效率会更高，如果你以输出讲座为目标，那么你的读书效率会特别高。</h3><h3 id=\"道理很简单因为当我们知道自己要在别人面前表达自己的想法后我们才会去调查那些我们从未在意过的出处资料重新审视自己的观点建立起系统的知识体系这时你会发现这个补充学习的过程就像从零学起一样需要费不少功夫而能够正视这些辛苦工作的人最后都不再对知识一知半解了\">道理很简单因为当我们知道自己要在别人面前表达自己的想法后，我们才会去调查那些我们从未在意过的出处、资料，重新审视自己的观点，建立起系统的知识体系。这时你会发现，这个补充学习的过程就像从零学起一样，需要费不少功夫。而能够正视这些辛苦工作的人，最后都不再对知识一知半解了。</h3><h3 id=\"因此掌握再多信息如果不去积极输出也无法形成知识体系\">因此掌握再多信息，如果不去积极输出，也无法形成知识体系。</h3><h1 id=\"如何做笔记\">如何做笔记？</h1><p>有时你可能感觉到没什么可写的，但只要你拿起笔来随便写两句，说不定就有惊喜等着你。</p><p>读书笔记三步骤：</p><ol>  <li>读书</li>  <li>划重点</li>  <li>写读后总结</li></ol><p>读书阶段，要在书上做一些简单的记号，为写读书笔记做准备。</p><p>这里作者介绍了自己的读书方法：</p><p>第一遍通读时，把有价值的页折起来，</p><p>第二遍重读时只读折起来的部分，并且认为重要的划线或标记，</p><p>第三遍再重读时只读划线和标记部分，认为精华的部分摘抄到笔记里。</p><p>最后把摘抄的精华加上自己的理解把它们写成文章。</p><p>作者自己发明了葱郁火锅笔记法，它有两部分组成：</p><ol>  <li>摘抄下重要语句</li>  <li>下方写上自己的感受</li></ol><p>即重要的内容摘抄下来，下面写下自己的感想和评论。（摘抄和评论交替进行，趁着自己印象还鲜明写下自己的感想）</p><p>作者认为，自己当下的想法才是最重要的，摘抄这一段文章的原因和自己当时的想法才是日后值得参考的贵重资料。</p><h1 id=\"如何重读与巩固\">如何重读与巩固？</h1><p>读完一本书后的时间越长，在读书时产生的环境变化就会越模糊，你就越能冷静地看待书中的观点。</p><p>因此不要在意一本书读完已经搁置了多久，再次重读时会有别样的风味。</p><p>重读笔记的时间点：睡觉前、洗完澡后、晚饭后、思绪进入死胡同时，可以是碎片时间也最好是安静的环境。</p><p>重读习惯养成：</p><ol>  <li>量化重读频率，每周一次或者三天一次。</li>  <li>多种重读方式交替进行</li>  <li>重读后写复习总结并发布到博客上</li></ol><p>多种重读方式：</p><ol>  <li>想要简单回顾时，重读读书笔记</li>  <li>想回忆起更多时，参考书中的重点段落</li>  <li>想从头开始看起时，重读原书</li></ol><h3 id=\"每一次的复习总结都是对自己知识的再回顾和再理解把这些复习总结放到博客上同样可以作为思想输出的一部分而且每次复习总结后都会让自己对这部分知识理解的更加透彻记忆也更加久远\">每一次的复习总结都是对自己知识的再回顾和再理解，把这些复习总结放到博客上同样可以作为思想输出的一部分，而且每次复习总结后都会让自己对这部分知识理解的更加透彻，记忆也更加久远。</h3><h1 id=\"吸收知识的重要手段主题阅读\">吸收知识的重要手段主题阅读</h1><h3 id=\"同一个主题的选出三本以上的书同时阅读或者依次阅读读完记录要点做笔记再把三本笔记合起来写一篇文章这篇文章就相当于是让三个专家围绕某个问题给自己提意见让他们进行讨论而我则思考并听取意见\">同一个主题的选出三本以上的书同时阅读或者依次阅读，读完记录要点，做笔记，再把三本笔记合起来写一篇文章，这篇文章就相当于是让三个专家围绕某个问题给自己提意见，让他们进行讨论而我则思考并听取意见。</h3><p>经过整理和总结后，渐渐的得出一些自己的结论，这些结论是由三个专家共同讨论得出的，这样的结论比较客观且符合当下的情况。</p><h3 id=\"让读书百遍更轻松的方法就是阅读读书笔记通过读书笔记缩短复习时间提高记忆恢复速度以笔记内容为线索回忆整个读书过程达到快速恢复记忆的目的\">让读书百遍更轻松的方法就是阅读读书笔记，通过读书笔记缩短复习时间、提高记忆恢复速度，以笔记内容为线索回忆整个读书过程，达到快速恢复记忆的目的。</h3><h1 id=\"读书实用技巧\">读书实用技巧</h1><p>作者列举了20条读书实用技巧，这里我筛选了一部分因为有些确实没什么用处，也是结合我实际阅读学习过程中的经验：</p><ol>  <li>读书过程中多用参考书，地图、图鉴、统计数据、百科全书、年表、词典等帮助自己加深理解书中内容。</li>  <li>随机阅读，偶尔阅读一些自己从来没有接触过领域的书籍，打破你的常规思维，有时候这种方式会给你一种豁然开朗的感觉。</li>  <li>由浅入深的吃透难懂的书，太难的书会让我们有强烈的挫败感，不如先从入门版、图解版、漫画版、精编版开始阅读，逐步熟悉、理解、渗透，最后再去阅读原著能收获更多的成就感和自信。</li>  <li>把书份分类堆放，未阅读的、阅读过的、已经做过笔记的、已经写好总结文章，并且分类摆放，这样会给自己一个方向，随着时间推移读完的和做完笔记的书堆放的会越来越多，会有更多的成就感，也激励自己阅读更多的书。</li>  <li>把经典名著放在枕头边，这些书比较难度，我们可以睡觉前看两页慢慢读，反复读几年也非常好，因为这些书是经得起考验的，读的次数阅读读的时间越久，我们从中吸取的知识就越多。</li>  <li>同时阅读几本书，为了减少自己在读书时的枯燥感，三本书的领域应该是不一样的，当我们觉得一本书读的很痛苦时就可以换另外一本读，从而增加愉悦感保持心灵舒畅。</li>  <li>在办公桌和家里的每个角落都放满书，给自己一个身边满是书的氛围，同时当我们想看书的时候就可以随时抓到一本，不给自己找更多没有书看的理由。</li>  <li>去掉外封面让读书变得轻松，有多书的外封面有自己的宣传设计，这些外封面在读书的时候很不舒服，不如去掉它们给自己一个轻松的书。</li>  <li>用边撕边读的方式阅读杂志，并不一定要从头到尾顺序读，读完的就撕下来扔进垃圾桶。</li>  <li>偶尔的音频、视频读书也是一种读书的一种方式，当读书累的时候可以换一下轻松的方式阅读，特别读不熟悉的领域时这种轻松的方式可能会让我们更加容易的跨过这道门槛。</li>  <li>买一支你喜欢的钢笔，读书笔记时一直用它，这会带动我们写文章的热情，会有总想用这支笔写点什么感觉，同时调节钢笔出水、吸墨、擦拭等也能激发我们的写作热情。</li>  <li>把自己信奉的名言贴在显眼的位置，让自己更有长远的目标和行动指南。</li>  <li>从摘抄开始写作，写文章时时常会遇到瓶颈，我们可以尝试先把喜欢的文章抄写下来，抄写的同时自己想写的东西会从脑中涌现出来。</li>  <li>写好的文章打印出来，这样更方便我们随手翻阅，也更容易帮助我们重组知识创建出新的点子。</li>  <li>记录读书的时间过程，在书的首页上，记下自己的名字、购买日期、阅读结束日期、标记结束日期、完成读书标记日期，不但让自己的读书过程更清晰，也让这本书完完全全归属了我们。</li>  <li>经常整理书籍摆放归类，经常整理自己的读书笔记，会让自己在读书习惯，以及复习巩固时有更好的提升。</li></ol><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484825&amp;idx=1&amp;sn=72548c4cb8aaf9961b3ea77cc0905ba6&amp;chksm=fc22609ecb55e988c328a3a7b71c9614dd6e5d4b0df369ffd8d5275603ab7afd3ec9e01b036a&amp;token=1401123908&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/07/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B035",
            
            
            
            
            
            "date_published": "2021-07-12T00:00:00+08:00",
            "date_modified": "2021-07-12T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/07/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B034",
            "title": "读书笔记(三十四) 《C++ Primer》#6",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意。第三是当我们在巩固时创造出了新的知识，那么这些新的知识和旧的知识将同时变成智慧融合到身体中。本系列基于《C++ Primer》学习，由于重点放在“重学”，我略过了滚瓜烂熟的部分，挑出以前常忽略的部分，以及记忆没有那么深刻的部分，特别是那些重要的但没有上心的部分。正文：本文是全书总结的最后部分，在总结的同时我又重读了一遍整本书，对各个知识点的理解又加深了许多，希望这些回顾对各位都有所帮助。模版编程模版有两种，一种是类型模版参数，另一种是非类型模版参数。两种类型模版都是由编译器生成的代码，当两个不同的数据类型使用同一个模版时，会在模版实例化时生成的两份不同的代码。例如：template&lt;typename T&gt;T compare(const T v1, const T v2){    return v1 - v2;}count &lt;&lt; compare(1, 0) &lt;&lt; endl; // 编译器会生成 int compare(const int , const int)count &lt;&lt; compare(1.3F, 2.3F) &lt;&lt;endl; // 编译器会生成 int compare(const float, const float)编译器发现有两种数据类型分别调用了模版函数compare，此时编译器会生成两个版本的compare，应用在Class模版也是同样的道理。另一种是非类型模版，意思是参数为指定常量，例如：template&lt;unsigned N, unsigned M&gt;int compare(const char (&amp;p1)[N], const char (&amp;p2)[M]){    return strcmp(p1, p2);}compare(\"hi\",\"mon\"); // 编译器会生成 int compare(const char (&amp;p1)[3], const char (&amp;p2)[4]);compare(\"hello\", \"world\"); // 编译器会生成 int compare(const char(&amp;p1)[6], const char (&amp;p2)[6]);非类型参数是一个常量，而且必须是常量或者常量表达式，编译器会根据不同的常量生成不同类型的代码，应用在Class模版上也是同样的道理。编译器生成模版代码，当且仅当编译器检测到模版被使用时才发生，即如果一个成员函数没有被使用，则它不会被编译器实例化。另外编译器生成模版代码会分三个阶段，第一个阶段是检查语法，第二个阶段是检查模版调用的参数匹配，第三个阶段才是模版实例化，因此链接时发生错误在模版编程时是常有的事。在新标准中C++可以通过显示实例化来明确指定某个类或函数实例化。例如：extern template declaration; // 显式实例化申明template declaration; // 显式实例化定义当编译器遇到extern模版显式实例化声明时，表明程序会在其他地方有该程序的实例化。和普通模版实例化不同的是，如果一个类定义了模版显式实例化，则该模版的所有成员包括内联成员函数都会被实例化。此外在调用中如果有需要，我们也可以显式指定模版参数类型。例如：template&lt;tyepname T1, typename T2, typename T3&gt;T1 sum(T2, T3);long long var1 = sum(11,22L); // 编译错误long long var2 = sum&lt;long long&gt;(22, 33L); // 显式指定返回值为long longlong long var3 = sum&lt;long long, int, float&gt;(23, 34F); // 显式指定返回值和参数分别为 long long, int, float上述示例告诉我们，如果返回值使用了模版类型，则最好通过显式指定的方式来指定形参类型。理解右值引用、std::move和std::forward可以简单理解为，一个&amp;为左值引用，两个&amp;为右值引用，右值引用有些特殊，它转为转移数据而存在，即当右值引用赋值后，原值的内存数据将失效。通过右值引用可以做到数据转移的功能，例如：void f(int v1, int &amp;v2){    count &lt;&lt; v1 &lt;&lt; \" \" &lt;&lt; ++v2 &lt;&lt; endl;}template&lt;typename F, typename T1, typename T2&gt;void flip1(F f, T1 t1, T2 t2){    f(t2, t1);}template&lt;typename F, typename T1, typename T2&gt;void flip2(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2){    f(t2, t1);}int i = 0;f(42, i); // i变量被改变flip1(f, i, 42); // i变量没有被改变flip2(f, i, 42); // i变量被改变上述中filp1与flip2的差别是，filp2使用了右值引用，将实参转移到了形参上，进而在f中可以改变i本身的变量。模版可以接受右值引用参数，std::move的定义就是模版右值引用定义：template&lt;typename T&gt;typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; t){    return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);}move函数参数T&amp;&amp;是一个指向模版类型的右值引用。通过引用折叠，参数可以与任何类型的实参匹配。string s1(\"hi\"), s2;s2 = std::move(string(\"bye\")); // 实例化为 string&amp;&amp; move(string &amp;&amp;t)s2 = std::move(s1); // 实例化为 string&amp;&amp; move(string &amp;t)其实这两个模版实例化成了不同的函数，根本原因是右值引用可折叠，导致的结果是：  如果一个函数参数是一个指向模版类型参数的右值引用（如，T&amp;&amp;）则它可以被绑定到一个左值。  如果实参是一个左值，则推断出的模版实参类型将是一个左值引用，且函数参数将被实例化为一个（普通）左值引用参数（T&amp;）。标准库中std::forward可以帮助我们返回实参类型的右值引用，即std::forward的返回类型是T&amp;&amp;。例如：template&lt;type F, typename T1, typename T2&gt;void flip(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2){    f(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));}模版重载函数与可变参数模版模版重载函数在匹配规则上有些小规则，当有多个重载模版对一个调用提供同样好的匹配时，应选择最特例化的版本。对于一个调用，如果一个非函数模版与一个函数模版提供同样好的匹配，则选择非模版版本。可变参数模版中，编译器会根据识别到的函数参数类型生成多个不同类型形参的函数。可变参数模版可以与sizeof…运算符一起使用，sizeof…运算符也是通过预编译生成的模版函数，返回的是类型数目或者参数数目。例如：template&lt;typename T, typename... Args&gt;ostream &amp;print(ostream &amp;os, const T &amp;t, const Args&amp;... rest){    os &lt;&lt; t &lt;&lt; \",\";    return print(os, rest...); // 预编译会将函数展开成类似print(os, i, s, 42)}string debug_rep(char *p){    return string(p);}template&lt;typename... Args&gt;ostream &amp;errorMsg(ostream &amp;os, const Args&amp;... rest){    return print(os, debug_rep(rest)...); // 预编译会将函数展开成类似print(os, debug_rep(i), debug_rep(s), debug_rep(42));}编译器会在预编译时对可变参数展开，因此上述函数在调用展开后类似于 print(os, i, s, 42) 和 print(os, debug_rep(i), debug_rep(s), debug_rep(42))。模版特例化有时候我们不希望使用模版但又想跟模版的使用方式一样，此时就可以用一个特例化模版来独立定义模版中的一个或者多个参数指定为特定类型。template&lt;typename T, typename U&gt; int compare(const T&amp;, const U&amp;);  // 原模版template&lt;&gt; int compare(const char* const &amp;p1, const char* const &amp;p2); // 全特例化template&lt;typename T&gt; int compare(const T&amp;, const char* const &amp;p2); // 部分特例化int compare(const int const &amp;var1, const int const &amp;var2);   //  普通函数compare(3F,5F); // 调用源模版compare(\"HI\", \"HELLO\"); // 调用全特例化compare(3F,\"HELLO\"); // 调用部分特例化compare(3,5); // 调用普通函数当定义函数模版的特例化版本时，我们本质上接管了编译器的工作。即我们为原模版的一个特殊实例提供了定义。重要的是要弄清楚：一个特例化版本本质上是一个实例，而非函数名的一个重载版本，因此特例化不影响函数匹配。注意，当一个非模版函数提供与函数模版同样好的匹配时，编译器会选择非模版版本。另外特例化也可以应用到类定义上，类上的特例化也同样支持全特例化和部分特例化，例如：template&lt;class T, class U&gt; class testClass { // 原类    public：    T var1;    U var2;    void Func();}template&lt;&gt; class testClass&lt;int, double&gt; { // 全特例化    public：    int var1;    double var2;    void Func();}template&lt;T&gt; class testClass&lt;T, double&gt; { // 部分特例化    public：    T var1;    double var2;    void Func();}template&lt;class T, class U&gt; struct testClass { // 对函数成员特例化    public：    T var1;    U var2;    template&lt;&gt;    void Func&lt;int, double&gt;(); // 成员函数特例化}类也可以全特例化和部分特例化，其中成员函数特例化时必须全特例化，不支持部分特例化。标准库中的特殊类型tuple类似pair的模版，不过tuple可以有任意数量的成员，例如：tuple&lt;T1, T2, T3...Tn&gt; t; // 一个tuple变量可以有n个成员T2 item = get&lt;i&gt;(t); // 用索引值获取成员tuple的一个常见用途是从函数返回多值，当使用tuple作为多值返回值时，它相当于是一个可以方便临时构造的数据结构。bitset能使得二进制运算的使用更为容易，能处理超过整数大小的位集合。bitset&lt;n&gt; b; // b有n位，每一位均为0。bool item = b[i]; // 访问b中pos处位置的值b.set(27); // 第27个位置设置为1正则表达式regex类，这里不多说了，正则表达式网上说明太多。标准库中的rand随机数主要解决两类问题，第一是范围内随机，第二是非均匀分布。因此标准库提供了随机数引擎Engine，通过种子来锚定伪随机数。常用程序工具异常处理流程通常是从一处抛出异常，不断沿着函数调用链寻找异常匹配，如果没有找到则调用标准库函数terminate终止程序执行。其中一条catch语句可以通过重新抛出操作将异常传递给另外一个catch语句，函数也可以通过声明noexcept或throw来承诺不会抛出异常。新标准中引入了内联命名空间，内联命名空间中的名字可以被外层命名空间直接使用。多重继承，指从多个直接基类中派生类的能力。多重继承的派生类继承了所有父类的属性。多重继承的派生类的内存模型其实就是类属性的叠加，不同父类之间通过内存叠加来实现多重继承。在构造时按继承顺序调用构造函数，析构时的调用顺序则刚好相反。运行时类型识别（RTTI，run-time type identification）RTTI功能由两个运算符实现：  typeid 运算符，用于返回表达式的类型  dynamic_cast 运算符，用于将指针或引用安全地转换为派生类指针或引用我们知道不包含任何虚函数的类在内存模型中是没有虚表的，而虚表是运行时识别的重要关键。其实两个运算符都是针对虚函数实现的，其原理就是派生类中有虚表，虚表中有指向type_info的指针和虚函数指针。typeid通过虚表取得type_info返回给程序，dynamic_cast则通过比较目标类中的type_info和执行对象虚表中的type_info确定是否可以安全转换。有趣的一点是，typeid也可以用于静态类（即没有任何虚函数的类），此时获取的type_info则是通过编译器生成的，因为在编译阶段就能识别该对象类型。类成员指针与普通指针不同的是类成员指针指向的是成员而非对象。类成员指针分为数据成员指针和成员函数指针。数据成员指针指向的是数据成员，成员函数指针则指向成员函数，例如：class testClass{    public:    string content;    char * getChar();}const string testClass::*pdata = &amp;testClass::content; // pdata为成员指针const string testClass::*pfunc = &amp;testClass::getChar; //pfunc为成员函数指针testClass myObj; // 实例对象testClass *pObj = &amp;myObj; // 指针string s = myObj.*pdata; // 用成员指针获取实例成员数据string ss = myObj-&gt;*pdata; //  用成员指针获取指针成员数据char *c = (myObj.*pfunc)();char *cc = (myObj-&gt;*pfunc)();上述例子中我们可以清楚的看到pdata，pfunc是testClass成员指针，通过声明testClass + 类型来指定成员指针，用成员指针可以调用或者取得成员数据。通过这种成员指针的方式，我们可以将类成员的函数放入一个函数表中以方便逻辑使用，例如：class testClass{    public:    using Action = char* (testClass::*)();    char* getChar1();    char* getChar2();    char* getChar3();}testClass::Action funcMenu[] = { &amp;testClass::getChar1, &amp;testClass::getChar2, &amp;testClass::getChar3 };testClass obj;for(int i = 0; i&lt;3 ; i++){    char * c = (obj.*(funcMenu[i]))();}类成员指针与普通函数指针不同之处在于成员指针并不是一个可调用对象，因此它不支持函数调用运算符。这时我们可以用funciton和bind将类成员函数指针封装成可调用对象，这样可以让成员函数指针运用的更加灵活。例如：function&lt;bool (const string&amp;)&gt; fcn = &amp;string::empty;find_if(svec.begin(), svec.end(), fcn);auto it = find_if(svec.begin(), svec.end(), bind(&amp;string::empty, _1));联合union一个union可以有多数据成员，其空间大小为最大的那个数据成员，因为在任意时刻只有一个数据成员有效，当我们给某个成员赋值后，其他成员就变成了未定义状态。union可以有自己的构造函数和析构函数，但不能有虚函数不能作为基类更不能派生。有时我们需要最终union中存储了什么类型的值，因此通常会自己定义个独立的类对象，通过这个对象来判别union当前类型。其他特性位域，明确了变量的二进制位数，它必须是整数，当一个程序需要向其他程序或者硬件设备传递二进制数据时通常会使用位域，因为设备之间的编译环境不同。取地址运算符（&amp;）不能作用于位域，因此任何指针都无法指向类的位域。它声明的方式为成名名字之后紧跟冒号和常量，例如：class testClass{    public:    int mode: 2; // mode 占2位    int var1: 4: // var1 占4位}volatile，会告诉编译器阻止这个对象优化。由于不同设备之间存在差异，因此在移植或不同环境时会有所改变，因此我们需要使用volatile阻止编译器在当前环境下做编译优化，例如：volatile int var; // 阻止优化变量volatile用在如下的几个地方：  中断服务程序中修改的供其它程序检测的变量需要加volatile；  多任务环境下各任务间共享的标志应该加volatile；  存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；链接指示extern “C”，意味着我们声明了另一个语言的编译器，从而使得我们在编译时让编译器遵守另一个语言的规则（其他兼容例如extern “Ada”，extern “FORTRAN”等）所有在链接指示里的内容都被指向该语言编写的链接，例如：extern \"C\"{    #include &lt;string.h&gt; // 操作c风格字符串的c函数}extern \"C\" void (*pf)(int); // 当pf被调用时，编译器认定pf为C函数(*pf)(2);extern \"C\" typedef void FC(int); // 定义一个C函数void f2(FC *); // 将C函数指针作为C++函数的形参我们可以通过宏来判断当前编译器是C++编译器还是C编译器，即__cplusplus，例如：#ifdef __cplusplusextern \"C\"#endifint strcmp(const char*, const char*);上述代码通过预处理定义在代码中兼容C和C++。已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484819&amp;idx=1&amp;sn=229a9bb2eb6ca5fd7322c8b85bae6d8f&amp;chksm=fc226094cb55e98229f537079c784bcf16f42579928fd034b46a69a953f6ddab28f1b4cf3c1c&amp;token=1401123908&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h1 id=\"背景\">背景：</h1><p>我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意。第三是当我们在巩固时创造出了新的知识，那么这些新的知识和旧的知识将同时变成智慧融合到身体中。</p><p>本系列基于《C++ Primer》学习，由于重点放在“重学”，我略过了滚瓜烂熟的部分，挑出以前常忽略的部分，以及记忆没有那么深刻的部分，特别是那些重要的但没有上心的部分。</p><h1 id=\"正文\">正文：</h1><p>本文是全书总结的最后部分，在总结的同时我又重读了一遍整本书，对各个知识点的理解又加深了许多，希望这些回顾对各位都有所帮助。</p><h3 id=\"模版编程\">模版编程</h3><p>模版有两种，一种是类型模版参数，另一种是非类型模版参数。</p><p>两种类型模版都是由编译器生成的代码，当两个不同的数据类型使用同一个模版时，会在模版实例化时生成的两份不同的代码。例如：</p><pre><code class=\"language-c\">template&lt;typename T&gt;T compare(const T v1, const T v2){    return v1 - v2;}count &lt;&lt; compare(1, 0) &lt;&lt; endl; // 编译器会生成 int compare(const int , const int)count &lt;&lt; compare(1.3F, 2.3F) &lt;&lt;endl; // 编译器会生成 int compare(const float, const float)</code></pre><p>编译器发现有两种数据类型分别调用了模版函数compare，此时编译器会生成两个版本的compare，应用在Class模版也是同样的道理。</p><p>另一种是非类型模版，意思是参数为指定常量，例如：</p><pre><code class=\"language-c\">template&lt;unsigned N, unsigned M&gt;int compare(const char (&amp;p1)[N], const char (&amp;p2)[M]){    return strcmp(p1, p2);}compare(\"hi\",\"mon\"); // 编译器会生成 int compare(const char (&amp;p1)[3], const char (&amp;p2)[4]);compare(\"hello\", \"world\"); // 编译器会生成 int compare(const char(&amp;p1)[6], const char (&amp;p2)[6]);</code></pre><p>非类型参数是一个常量，而且必须是常量或者常量表达式，编译器会根据不同的常量生成不同类型的代码，应用在Class模版上也是同样的道理。</p><p>编译器生成模版代码，当且仅当编译器检测到模版被使用时才发生，即如果一个成员函数没有被使用，则它不会被编译器实例化。</p><p>另外编译器生成模版代码会分三个阶段，第一个阶段是检查语法，第二个阶段是检查模版调用的参数匹配，第三个阶段才是模版实例化，因此链接时发生错误在模版编程时是常有的事。</p><p>在新标准中C++可以通过显示实例化来明确指定某个类或函数实例化。例如：</p><pre><code class=\"language-c\">extern template declaration; // 显式实例化申明template declaration; // 显式实例化定义</code></pre><p>当编译器遇到extern模版显式实例化声明时，表明程序会在其他地方有该程序的实例化。和普通模版实例化不同的是，如果一个类定义了模版显式实例化，则该模版的所有成员包括内联成员函数都会被实例化。</p><p>此外在调用中如果有需要，我们也可以显式指定模版参数类型。例如：</p><pre><code class=\"language-c\">template&lt;tyepname T1, typename T2, typename T3&gt;T1 sum(T2, T3);long long var1 = sum(11,22L); // 编译错误long long var2 = sum&lt;long long&gt;(22, 33L); // 显式指定返回值为long longlong long var3 = sum&lt;long long, int, float&gt;(23, 34F); // 显式指定返回值和参数分别为 long long, int, float</code></pre><p>上述示例告诉我们，如果返回值使用了模版类型，则最好通过显式指定的方式来指定形参类型。</p><h3 id=\"理解右值引用stdmove和stdforward\">理解右值引用、std::move和std::forward</h3><p>可以简单理解为，一个&amp;为左值引用，两个&amp;为右值引用，右值引用有些特殊，它转为转移数据而存在，即当右值引用赋值后，原值的内存数据将失效。</p><p>通过右值引用可以做到数据转移的功能，例如：</p><pre><code class=\"language-c\">void f(int v1, int &amp;v2){    count &lt;&lt; v1 &lt;&lt; \" \" &lt;&lt; ++v2 &lt;&lt; endl;}template&lt;typename F, typename T1, typename T2&gt;void flip1(F f, T1 t1, T2 t2){    f(t2, t1);}template&lt;typename F, typename T1, typename T2&gt;void flip2(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2){    f(t2, t1);}int i = 0;f(42, i); // i变量被改变flip1(f, i, 42); // i变量没有被改变flip2(f, i, 42); // i变量被改变</code></pre><p>上述中filp1与flip2的差别是，filp2使用了右值引用，将实参转移到了形参上，进而在f中可以改变i本身的变量。</p><p>模版可以接受右值引用参数，std::move的定义就是模版右值引用定义：</p><pre><code class=\"language-c\">template&lt;typename T&gt;typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; t){    return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);}move函数参数T&amp;&amp;是一个指向模版类型的右值引用。通过引用折叠，参数可以与任何类型的实参匹配。string s1(\"hi\"), s2;s2 = std::move(string(\"bye\")); // 实例化为 string&amp;&amp; move(string &amp;&amp;t)s2 = std::move(s1); // 实例化为 string&amp;&amp; move(string &amp;t)</code></pre><p>其实这两个模版实例化成了不同的函数，根本原因是右值引用可折叠，导致的结果是：</p><ol>  <li>如果一个函数参数是一个指向模版类型参数的右值引用（如，T&amp;&amp;）则它可以被绑定到一个左值。</li>  <li>如果实参是一个左值，则推断出的模版实参类型将是一个左值引用，且函数参数将被实例化为一个（普通）左值引用参数（T&amp;）。</li></ol><p>标准库中std::forward可以帮助我们返回实参类型的右值引用，即std::forward<T>的返回类型是T&amp;&amp;。例如：</T></p><pre><code class=\"language-c\">template&lt;type F, typename T1, typename T2&gt;void flip(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2){    f(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));}</code></pre><h3 id=\"模版重载函数与可变参数模版\">模版重载函数与可变参数模版</h3><p>模版重载函数在匹配规则上有些小规则，当有多个重载模版对一个调用提供同样好的匹配时，应选择最特例化的版本。</p><p>对于一个调用，如果一个非函数模版与一个函数模版提供同样好的匹配，则选择非模版版本。</p><p>可变参数模版中，编译器会根据识别到的函数参数类型生成多个不同类型形参的函数。</p><p>可变参数模版可以与sizeof…运算符一起使用，sizeof…运算符也是通过预编译生成的模版函数，返回的是类型数目或者参数数目。</p><p>例如：</p><pre><code class=\"language-c\">template&lt;typename T, typename... Args&gt;ostream &amp;print(ostream &amp;os, const T &amp;t, const Args&amp;... rest){    os &lt;&lt; t &lt;&lt; \",\";    return print(os, rest...); // 预编译会将函数展开成类似print(os, i, s, 42)}string debug_rep(char *p){    return string(p);}template&lt;typename... Args&gt;ostream &amp;errorMsg(ostream &amp;os, const Args&amp;... rest){    return print(os, debug_rep(rest)...); // 预编译会将函数展开成类似print(os, debug_rep(i), debug_rep(s), debug_rep(42));}</code></pre><p>编译器会在预编译时对可变参数展开，因此上述函数在调用展开后类似于 print(os, i, s, 42) 和 print(os, debug_rep(i), debug_rep(s), debug_rep(42))。</p><h3 id=\"模版特例化\">模版特例化</h3><p>有时候我们不希望使用模版但又想跟模版的使用方式一样，此时就可以用一个特例化模版来独立定义模版中的一个或者多个参数指定为特定类型。</p><pre><code class=\"language-c\">template&lt;typename T, typename U&gt; int compare(const T&amp;, const U&amp;);  // 原模版template&lt;&gt; int compare(const char* const &amp;p1, const char* const &amp;p2); // 全特例化template&lt;typename T&gt; int compare(const T&amp;, const char* const &amp;p2); // 部分特例化int compare(const int const &amp;var1, const int const &amp;var2);   //  普通函数compare(3F,5F); // 调用源模版compare(\"HI\", \"HELLO\"); // 调用全特例化compare(3F,\"HELLO\"); // 调用部分特例化compare(3,5); // 调用普通函数</code></pre><p>当定义函数模版的特例化版本时，我们本质上接管了编译器的工作。即我们为原模版的一个特殊实例提供了定义。</p><p>重要的是要弄清楚：一个特例化版本本质上是一个实例，而非函数名的一个重载版本，因此特例化不影响函数匹配。</p><p>注意，当一个非模版函数提供与函数模版同样好的匹配时，编译器会选择非模版版本。</p><p>另外特例化也可以应用到类定义上，类上的特例化也同样支持全特例化和部分特例化，例如：</p><pre><code class=\"language-c\">template&lt;class T, class U&gt; class testClass { // 原类    public：    T var1;    U var2;    void Func();}template&lt;&gt; class testClass&lt;int, double&gt; { // 全特例化    public：    int var1;    double var2;    void Func();}template&lt;T&gt; class testClass&lt;T, double&gt; { // 部分特例化    public：    T var1;    double var2;    void Func();}template&lt;class T, class U&gt; struct testClass { // 对函数成员特例化    public：    T var1;    U var2;    template&lt;&gt;    void Func&lt;int, double&gt;(); // 成员函数特例化}</code></pre><p>类也可以全特例化和部分特例化，其中成员函数特例化时必须全特例化，不支持部分特例化。</p><h3 id=\"标准库中的特殊类型\">标准库中的特殊类型</h3><p>tuple类似pair的模版，不过tuple可以有任意数量的成员，例如：</p><pre><code class=\"language-c\">tuple&lt;T1, T2, T3...Tn&gt; t; // 一个tuple变量可以有n个成员T2 item = get&lt;i&gt;(t); // 用索引值获取成员</code></pre><p>tuple的一个常见用途是从函数返回多值，当使用tuple作为多值返回值时，它相当于是一个可以方便临时构造的数据结构。</p><p>bitset能使得二进制运算的使用更为容易，能处理超过整数大小的位集合。</p><pre><code class=\"language-c\">bitset&lt;n&gt; b; // b有n位，每一位均为0。bool item = b[i]; // 访问b中pos处位置的值b.set(27); // 第27个位置设置为1</code></pre><p>正则表达式regex类，这里不多说了，正则表达式网上说明太多。</p><p>标准库中的rand随机数主要解决两类问题，第一是范围内随机，第二是非均匀分布。因此标准库提供了随机数引擎Engine，通过种子来锚定伪随机数。</p><h3 id=\"常用程序工具\">常用程序工具</h3><p>异常处理流程通常是从一处抛出异常，不断沿着函数调用链寻找异常匹配，如果没有找到则调用标准库函数terminate终止程序执行。</p><p>其中一条catch语句可以通过重新抛出操作将异常传递给另外一个catch语句，函数也可以通过声明noexcept或throw来承诺不会抛出异常。</p><p>新标准中引入了内联命名空间，内联命名空间中的名字可以被外层命名空间直接使用。</p><p>多重继承，指从多个直接基类中派生类的能力。多重继承的派生类继承了所有父类的属性。</p><p>多重继承的派生类的内存模型其实就是类属性的叠加，不同父类之间通过内存叠加来实现多重继承。</p><p>在构造时按继承顺序调用构造函数，析构时的调用顺序则刚好相反。</p><h3 id=\"运行时类型识别rttirun-time-type-identification\">运行时类型识别（RTTI，run-time type identification）</h3><p>RTTI功能由两个运算符实现：</p><ol>  <li>typeid 运算符，用于返回表达式的类型</li>  <li>dynamic_cast 运算符，用于将指针或引用安全地转换为派生类指针或引用</li></ol><p>我们知道不包含任何虚函数的类在内存模型中是没有虚表的，而虚表是运行时识别的重要关键。</p><p>其实两个运算符都是针对虚函数实现的，其原理就是派生类中有虚表，虚表中有指向type_info的指针和虚函数指针。</p><p>typeid通过虚表取得type_info返回给程序，dynamic_cast则通过比较目标类中的type_info和执行对象虚表中的type_info确定是否可以安全转换。</p><p>有趣的一点是，typeid也可以用于静态类（即没有任何虚函数的类），此时获取的type_info则是通过编译器生成的，因为在编译阶段就能识别该对象类型。</p><h3 id=\"类成员指针\">类成员指针</h3><p>与普通指针不同的是类成员指针指向的是成员而非对象。</p><p>类成员指针分为数据成员指针和成员函数指针。</p><p>数据成员指针指向的是数据成员，成员函数指针则指向成员函数，例如：</p><pre><code class=\"language-c\">class testClass{    public:    string content;    char * getChar();}const string testClass::*pdata = &amp;testClass::content; // pdata为成员指针const string testClass::*pfunc = &amp;testClass::getChar; //pfunc为成员函数指针testClass myObj; // 实例对象testClass *pObj = &amp;myObj; // 指针string s = myObj.*pdata; // 用成员指针获取实例成员数据string ss = myObj-&gt;*pdata; //  用成员指针获取指针成员数据char *c = (myObj.*pfunc)();char *cc = (myObj-&gt;*pfunc)();</code></pre><p>上述例子中我们可以清楚的看到pdata，pfunc是testClass成员指针，通过声明testClass + 类型来指定成员指针，用成员指针可以调用或者取得成员数据。</p><p>通过这种成员指针的方式，我们可以将类成员的函数放入一个函数表中以方便逻辑使用，例如：</p><pre><code class=\"language-c\">class testClass{    public:    using Action = char* (testClass::*)();    char* getChar1();    char* getChar2();    char* getChar3();}testClass::Action funcMenu[] = { &amp;testClass::getChar1, &amp;testClass::getChar2, &amp;testClass::getChar3 };testClass obj;for(int i = 0; i&lt;3 ; i++){    char * c = (obj.*(funcMenu[i]))();}</code></pre><p>类成员指针与普通函数指针不同之处在于成员指针并不是一个可调用对象，因此它不支持函数调用运算符。</p><p>这时我们可以用funciton和bind将类成员函数指针封装成可调用对象，这样可以让成员函数指针运用的更加灵活。例如：</p><pre><code class=\"language-c\">function&lt;bool (const string&amp;)&gt; fcn = &amp;string::empty;find_if(svec.begin(), svec.end(), fcn);auto it = find_if(svec.begin(), svec.end(), bind(&amp;string::empty, _1));</code></pre><h3 id=\"联合union\">联合union</h3><p>一个union可以有多数据成员，其空间大小为最大的那个数据成员，因为在任意时刻只有一个数据成员有效，当我们给某个成员赋值后，其他成员就变成了未定义状态。</p><p>union可以有自己的构造函数和析构函数，但不能有虚函数不能作为基类更不能派生。</p><p>有时我们需要最终union中存储了什么类型的值，因此通常会自己定义个独立的类对象，通过这个对象来判别union当前类型。</p><h3 id=\"其他特性\">其他特性</h3><p>位域，明确了变量的二进制位数，它必须是整数，当一个程序需要向其他程序或者硬件设备传递二进制数据时通常会使用位域，因为设备之间的编译环境不同。</p><p>取地址运算符（&amp;）不能作用于位域，因此任何指针都无法指向类的位域。</p><p>它声明的方式为成名名字之后紧跟冒号和常量，例如：</p><pre><code class=\"language-c\">class testClass{    public:    int mode: 2; // mode 占2位    int var1: 4: // var1 占4位}</code></pre><p>volatile，会告诉编译器阻止这个对象优化。</p><p>由于不同设备之间存在差异，因此在移植或不同环境时会有所改变，因此我们需要使用volatile阻止编译器在当前环境下做编译优化，例如：</p><pre><code class=\"language-c\">volatile int var; // 阻止优化变量</code></pre><p>volatile用在如下的几个地方：</p><ol>  <li>中断服务程序中修改的供其它程序检测的变量需要加volatile；</li>  <li>多任务环境下各任务间共享的标志应该加volatile；</li>  <li>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；</li></ol><p>链接指示extern “C”，意味着我们声明了另一个语言的编译器，从而使得我们在编译时让编译器遵守另一个语言的规则（其他兼容例如extern “Ada”，extern “FORTRAN”等）</p><p>所有在链接指示里的内容都被指向该语言编写的链接，例如：</p><pre><code class=\"language-c\">extern \"C\"{    #include &lt;string.h&gt; // 操作c风格字符串的c函数}extern \"C\" void (*pf)(int); // 当pf被调用时，编译器认定pf为C函数(*pf)(2);extern \"C\" typedef void FC(int); // 定义一个C函数void f2(FC *); // 将C函数指针作为C++函数的形参</code></pre><p>我们可以通过宏来判断当前编译器是C++编译器还是C编译器，即__cplusplus，例如：</p><pre><code class=\"language-c\">#ifdef __cplusplusextern \"C\"#endifint strcmp(const char*, const char*);</code></pre><p>上述代码通过预处理定义在代码中兼容C和C++。</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484819&amp;idx=1&amp;sn=229a9bb2eb6ca5fd7322c8b85bae6d8f&amp;chksm=fc226094cb55e98229f537079c784bcf16f42579928fd034b46a69a953f6ddab28f1b4cf3c1c&amp;token=1401123908&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/07/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B034",
            
            
            
            "tags": ["读书笔记","前端技术"],
            
            "date_published": "2021-07-11T00:00:00+08:00",
            "date_modified": "2021-07-11T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/07/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B033",
            "title": "读书笔记(三十一) 《装载、链接与库》#4 内核运行库",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：看此书的起源是我在了解Linux注入技术的时候翻阅到的，由于注入技术需要用到很多ELF格式的内容，很多网络上的技术文章都指向了同一本书。也刚好周围的同事有此书，便翻阅了一下，这一番翻阅打开了我对程序世界的又一扇大门。很快我就自己买了此书并阅读完成，整本书给我很大的震撼，让我对程序从编译到链接到装载有了更深刻的认识。我把我的整个学习过程以及对书本的理解，用自己的语言和自己画的图表达出来，让读者能够更容易接受到我所学的知识。目标：了解编译过程了解动态库和静态库的装载细节了解可执行程序装载和执行过程了解可执行文件和动态库的数据格式疑问：c/c++编译器是如何将cpp编译为可执行文件的？多个c/c++文件是如何编译成一个可执行文件的？操作系统内存是如何初始化和管理的？动态库和静态库的链接和装载过程是怎样的？操作系统的用户态和内核态是如何运作的？正文：前面我们介绍了Linux的动态库在装载时的动态链接过程，以及可执行文件的装载过程。这里简单介绍下Windows的动态库的装载过程。Windows下的动态链接与Linux下的相比有很多相似之处，但也有很多不同的地方。Windows下的动态库称为DLL（Dynamic-Link Library），它和EXE文件实际上是一个概念，即都是PE格式的文件，区别在于PE文件头的符号位标识位不同，而且DLL文件的扩展名不一定是.dll，也可能是.ocx或.CPL。与Linux不同的是Windows有符号导入表和导出表概念，即必须使用“__declspec(dllimport)”和“__declspec(dllexport)”来显式的声明符号的导入与导出。Window编译器通过收集这些显式声明的导入符号，将它们放在一个导出表（Exprot Table）的符号集中，类似于Linux下的.dynsym段。动态链接器根据需要导入的符号从导出表上查找到真实的函数地址，这期间导入表则起到了存储符号和记录地址的作用，类似于Linux下的GOT。其实DLL中的代码段并不是地址无关的，Windows加载DLL时采用了重定基地址（Rebasing）的方法重定位每个绝对地址引用。由于DLL内部的地址都是基于基地址或相对于基地址的RVA，因此在重定位时只需要加上一个固定差值就能完成重定位工作。由于是绝对地址重定位，所以重定基地址比ELF的延迟定位机制要快很多，因为它不需要通过类似的GOT机制，对外部数据和函数的访问不需要每次都计算GOT位置。内存堆与栈前面我们说了很多关于系统内存的，包括虚拟内存、页表、缺页、置换等，而这节主要对堆内存和栈内存进行讲解。当我们调用函数时，需要将当前函数的信息保存到栈上以便调用结束回到原来位置时所有数据都能恢复到原样。我们把这些保存到栈上的数据称为栈帧（Stack Frame），这些数据主要包含：  调用需要的参数，以及调用结束时函数的返回地址  临时变量：包括函数的非静态局部变量以及编译器自动生成的临时变量  上下文：当前函数调用的寄存器数据注意，每种编译器都有自己的调用惯例，比如参数的传递顺序和方式、栈维护的方式、函数的签名规则、返回的寄存器等，在各个编译器之间可能有细微的差别。其中几乎所有的编译器调用惯例都将返回值存储在eax寄存器中，对于大于4字节的数据则存储在eax和edx中联合返回。堆内存我们在写内存分配时通常使用内存分配接口malloc或new，这两个接口分配的内存通常都放在.heap堆内存区域中，而动态库文件在加载的时候，则通过mmap将动态库映射到.libraries文件映射区域中。注意，malloc分配的内存到.heap段，mmap分配内存到.libraries段，而当malloc请求的内存大于MMAP_THRESHOLD时，则会转而调用mmap，申请的内存则在.libraries区域，这个阈值可以通过mallopt调整。这里作者介绍了下堆内存管理的几种方式不是非常详细，简单介绍下（后面会写一个操作系统内存专题）：  空闲链表法，把空闲的内存块加入到一个链表上，这个链表里全是空闲的内存块地址，当需要使用时就从这里找合适的。  分页分块法，把整个内存分成128K大小的XX页，然后再把每页分成32字节大小的内存块，用数组记录每个内存页和内存块的占用情况，这样在分配和释放时查找速度会比较快。  固定大小内存池，把整个分为固定大小的内存块，然后用空闲链表记录所有空闲的内存地址，每次分配都从空闲链表里推出一个内存使用。运行库作者专研的比较细，把进程启动到结束的整个过程都扒了出来，我们也跟着扒一下。程序从开始运行到结束的步骤如下：  操作系统fork（创建）进程，把控制权交到程序入口，这个入口通常都是公共库的某个函数（libc或MSVC）  入口函数对运行库和程序运行环境进行初始化，包括堆、I/O、线程、全局变量的构造等等  入口函数在完成初始化之后，调用main函数，正式开始执行程序主体部分  main函数执行完毕，返回入口函数，入口函数进行清理工作，包括全局变量析构、堆栈销毁、关闭I/O等，然后进程调用系统调用结束进程。下面我们来说说在整个系统调用里各部分是如何运作的。文件句柄原理这里不得不提一下文件句柄的原理，因为我们常常使用文件句柄，却不知道文件句柄究竟是什么，以及是什么产生了文件句柄。文件句柄总是和内核的文件对象相关联，内核可以通过句柄来计算出内核里文件对象的地址。在内核中，每个进程都有一个私有的“打开文件表”，这个表是一个指针数组，每一个元素都指向一个内核的打开文件对象，文件句柄就是数组的下标。当用户打开一个文件时，内核就会在内部生成一个文件对象，并在这个表里找到一个空项，让这一项指向生成的打开文件对象，并返回这一项的下标作为句柄值。由于这个“打开文件表”处于内核，并且用户无法访问到，因此用户即使拥有句柄值，也无法直接打开文件对象的地址，只能通过系统提供的函数来操作。Windows的句柄稍有不同，虽然类似于文件表的下标但它并不是下标而是经过某种线性变换的结果。注意，文件表数组前三个元素填充的是stdin、stdout、stderr这三个内核对象。读取文件实现原理我们知道标准库中，文件在写入时会有缓冲区，因此在写入完毕后可以手动调用刷新接口来将缓冲取的内容清空到文件。其实读取文件也是同样的道理，如果读取文件时总是对文件操作，那么每次都需要进入内核模式，完成后再回到用户模式。很明显这样的读取方式消耗的比较大，因此读取文件也需要自己的缓冲，以提高文件读取效率。那么标准库是如何实现文件读取的呢？标准库中文件读取时的执行步骤：  每个文件读取时都会有一个缓冲区，缓冲区存储了已经读取的文件数据和还未读取的文件数据，  当读取文件时，先判断缓冲区中是否有此数据，  如果缓冲区中有我们需要的数据，则直接取得后返回即可，  如果没有我们需要的数据或者数据不够，则读取文件并将其后的数据一并读取放入到缓冲区中后再返回变长参数的实现方式这里作者说明了printf这种函数可变参数的实现方式：  编译时将多个实参打包成byte数组传入函数  在函数中根据下标和大小从byte数组指针中提取形参数据glibc的组成glibc中的内容由两部分组成，一部分是头文件，比如stdio.h、stdlib.h等，它们位于/usr/include，另一部分则是库的二进制文件，/lib/libc.so，或者/usr/lib/libc.a。事实上glibc还有3个重要的运行库，  /usr/lib/crt1.o，包含了入口程序，负责调用__libc_start_main初始化libc，并调用main函数进入真正的程序主体。  /usr/lib/crti.o，包含了_init()部分的程序初始化指令， 所有的.init都会被收集起来在这里调用  /usr/lib/crtn.o，包含了_finit()部分的程序销毁指令，所有的.finit都会被收集起来在这里调用注意，收集全局构造函数和析构函数的过程是，在链接时，将各个目标文件中.ctors段中的构造函数和析构函数合并为一个数组，在初始化和销毁时依次调用由于crti.o必须保证在用户目标文件和系统库之前，crtn.o必须在用户目标文件和系统库之后，因此链接器输入文件顺序必须是：ld crt1.o crti.o [user_objects] [system_libraries] crtn.o注意，前面说的都是C语言，在C++中则提供了crtbeginT.o和crtend.o来配合glibc实现C++的全局构造和析构。线程局部存储(TLS，Thread Local Storage)线程也可以拥有私有数据，这就是线程局部存储机制(TLS，Thread Local Storage)。TLS的用法很简单，只需要在它定义的时候加上关键字__thread就可以，在MSVC里为__declspec(thread)。// Linux__thread in number;// MSVC__declspec(thread) int number;一旦一个全局变量被定义为TLS类型，那么每个线程都会拥有这个变量的副本，任何线程对该变量的修改都不会影响其他线程中该变量的副本。在Windows中TLS的实现方式为：  编译器把__declspec(thread)定义的线程私有变量放到.tls段中  当进程启动一个线程时，在进程堆中分配一块足够大小的空间  把.tls段中的内容复制到这块空间中  于是每个线程都有自己独立的一个.tls数据副本注意，在.rdata表中有一个TLS表，它保存了所有的TLS变量的构造和析构函数地址，在线程启动和退出时都会对TLS变量进行构造和析构。除了使用添加关键字定义TLS变量外，还可以通过系统接口的方式，实时申请TLS类型变量。系统内核调用原理为了安全操作系统将操作分为两种模式，一种用户模式，一种是内核模式，用户模式操作范围被限制在用户空间上，而内核模式的程序涉及的范围会更广一些，但也主要集中内核空间中。由于内核模式操作的权限更大，因此内核程序编写时需要更加谨慎并严格测试，通常我们都接触不到内核程序，除非自己编写或修改操作系统。当用户模式要调用内核模式中的程序，要先通过EAX寄存器设置调用号，再调用中断指令，内核通过中断向量表找到系统调用程序，系统调用程序根据系统调用表查找到系统函数，最后执行系统调用。x86下中断指令为0x80，通过寄存器EAX指定系统调用的调用号，内核程序根据EAX中的值找到系统函数最后执行。举例创建进程时的系统调用过程：  用户调用创建进程函数，  创建进程函数设置eax寄存器并调用中断指令进入内核态，  中断指令根据0x80和中断向量表找到系统调用程序，  系统调用程序根据eax寄存器和系统调用表找到需要调用的函数，  系统调用完毕返回用户态函数返回地址。当用户态和内核态切换时，首先SS要指向内核栈，ESP指向内核栈顶，这样才能让程序当前的栈从用户栈切换到内核栈。其实每个进程都有两个栈，用户栈和内核栈，在切换到内核栈时要保存当前上下文，因此要向内核栈中推入ESP、SS、EFLASHS、CS、EIP的值，以便切回用户态时再弹出恢复。除了这几个特殊的寄存器，向内核栈中推入的还有EBX、ECX、EDX、ESI、EDI和EBP这6个寄存器，而这6个寄存器刚好可以被系统调用函数用于实参。实现自定义CRT（C Runtime）作者根据前面的理论知识，实现了一个自己的CRT（C Runtime），在不使用标准库的情况下，支持自定义自己的函数入口、进程初始化与销毁、堆内存分配与释放、文件读取与写入、格式化输出。我们这里讲解下实现CRT的几个关键点。关键点一：入口函数可以使用编译命令来指定，例如：gcc -nostartfiles -e myentry source.c -o source-e：设置程序的入口函数关键点二：进入main函数前要初始化堆内存，堆内存的管理分配与释放要自己来实现，比如实现一个FreeList空闲链表来存储销毁的堆内存以便下次使用。例如：//自定义堆内存块结构typedef struct _heap_header{    unsigned size;    struct _heap_header * next;    struct _heap_header * prev;} heap_header;//空闲内存链表static heap_header * freelist_head = NULL;//自定义内存释放函数void free(void * ptr){    ....}//自定义堆内存申请函数void * malloc(unsigned size){    ....}关键点三：堆内存的扩容可以通过brk系统调用设置进程的数据段边界，而sbrk可以移动进程的数据段边界，其实将数据段边界后移就相当于分配了一个定量的内存。由brk/sbrk分配的内存仅仅分配了虚拟空间，这些空间是不会提交的（即不分配物理内存页），当进程访问某个地址时才会与物理页关联。关键点四：由于不使用标准库，因此文件系统也必须自己重写，重写文件读写底层时，我们可以用汇编写系统调用来实现。其中系统调用中，打开文件的系统调用号是5、读取文件的系统调用号是3、写入文件的系统调用号是4、关闭文件的系统调用号是6。因此在调用int 0x80前，设置eax为各调用号就可以，同时用ebx、ecx、edx将参数传入系统调用。举例打开文件的系统调用：asm(\"movl $5, %%eax \\n\\t\" // 设置eax的调用号    \"movl %1, %%ebx \\n\\t\" // 设置参数1    \"movl %2, %%ecx \\n\\t\" // 设置参数2    \"movl %3, %%edx \\n\\t\" // 设置参数3    \"int $0x80 \\n\\t\" // 调用0x80系统中断)前面我们说标准输入输出是文件表的前3个句柄，因此句柄0，1，2为标准输入、标准输出、标准错误的句柄。关键点五：实现全局构造和析构时，从.ctors段中读取构造和析构函数数据，将构造和析构函数都合并到指针数组中，依次调用函数指针数组中的方法。typedef void (*ctor_func)(void);ctor_func ctors_begin[1] __attribute__ ((section(\".ctors\"))) = {    (ctor_func) -1;};void run_ctors(){    const ctor_func * list = ctors_begin;    while( (int)*++list != -1 )    {        (**list)();    }}",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484809&amp;idx=1&amp;sn=89091ecce47229ebf10e4855c0ccceca&amp;chksm=fc22608ecb55e998cdff3952057e6d1c6f099463797d57458ec1f4d37a432d46dc3c5bfcfbb5&amp;token=557108361&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h2 id=\"背景\">背景：</h2><p>看此书的起源是我在了解Linux注入技术的时候翻阅到的，由于注入技术需要用到很多ELF格式的内容，很多网络上的技术文章都指向了同一本书。也刚好周围的同事有此书，便翻阅了一下，这一番翻阅打开了我对程序世界的又一扇大门。</p><p>很快我就自己买了此书并阅读完成，整本书给我很大的震撼，让我对程序从编译到链接到装载有了更深刻的认识。</p><p>我把我的整个学习过程以及对书本的理解，用自己的语言和自己画的图表达出来，让读者能够更容易接受到我所学的知识。</p><h2 id=\"目标\">目标：</h2><p>了解编译过程</p><p>了解动态库和静态库的装载细节</p><p>了解可执行程序装载和执行过程</p><p>了解可执行文件和动态库的数据格式</p><h2 id=\"疑问\">疑问：</h2><p>c/c++编译器是如何将cpp编译为可执行文件的？</p><p>多个c/c++文件是如何编译成一个可执行文件的？</p><p>操作系统内存是如何初始化和管理的？</p><p>动态库和静态库的链接和装载过程是怎样的？</p><p>操作系统的用户态和内核态是如何运作的？</p><h2 id=\"正文\">正文：</h2><p>前面我们介绍了Linux的动态库在装载时的动态链接过程，以及可执行文件的装载过程。这里简单介绍下Windows的动态库的装载过程。</p><p>Windows下的动态链接与Linux下的相比有很多相似之处，但也有很多不同的地方。Windows下的动态库称为DLL（Dynamic-Link Library），它和EXE文件实际上是一个概念，即都是PE格式的文件，区别在于PE文件头的符号位标识位不同，而且DLL文件的扩展名不一定是.dll，也可能是.ocx或.CPL。</p><p>与Linux不同的是Windows有符号导入表和导出表概念，即必须使用“__declspec(dllimport)”和“__declspec(dllexport)”来显式的声明符号的导入与导出。Window编译器通过收集这些显式声明的导入符号，将它们放在一个导出表（Exprot Table）的符号集中，类似于Linux下的.dynsym段。动态链接器根据需要导入的符号从导出表上查找到真实的函数地址，这期间导入表则起到了存储符号和记录地址的作用，类似于Linux下的GOT。</p><p>其实DLL中的代码段并不是地址无关的，Windows加载DLL时采用了重定基地址（Rebasing）的方法重定位每个绝对地址引用。由于DLL内部的地址都是基于基地址或相对于基地址的RVA，因此在重定位时只需要加上一个固定差值就能完成重定位工作。由于是绝对地址重定位，所以重定基地址比ELF的延迟定位机制要快很多，因为它不需要通过类似的GOT机制，对外部数据和函数的访问不需要每次都计算GOT位置。</p><h3 id=\"内存堆与栈\">内存堆与栈</h3><p>前面我们说了很多关于系统内存的，包括虚拟内存、页表、缺页、置换等，而这节主要对堆内存和栈内存进行讲解。</p><p>当我们调用函数时，需要将当前函数的信息保存到栈上以便调用结束回到原来位置时所有数据都能恢复到原样。我们把这些保存到栈上的数据称为栈帧（Stack Frame），这些数据主要包含：</p><ol>  <li>调用需要的参数，以及调用结束时函数的返回地址</li>  <li>临时变量：包括函数的非静态局部变量以及编译器自动生成的临时变量</li>  <li>上下文：当前函数调用的寄存器数据</li></ol><p>注意，每种编译器都有自己的调用惯例，比如参数的传递顺序和方式、栈维护的方式、函数的签名规则、返回的寄存器等，在各个编译器之间可能有细微的差别。</p><p>其中几乎所有的编译器调用惯例都将返回值存储在eax寄存器中，对于大于4字节的数据则存储在eax和edx中联合返回。</p><h3 id=\"堆内存\">堆内存</h3><p>我们在写内存分配时通常使用内存分配接口malloc或new，这两个接口分配的内存通常都放在.heap堆内存区域中，而动态库文件在加载的时候，则通过mmap将动态库映射到.libraries文件映射区域中。</p><p>注意，malloc分配的内存到.heap段，mmap分配内存到.libraries段，而当malloc请求的内存大于MMAP_THRESHOLD时，则会转而调用mmap，申请的内存则在.libraries区域，这个阈值可以通过mallopt调整。</p><p>这里作者介绍了下堆内存管理的几种方式不是非常详细，简单介绍下（后面会写一个操作系统内存专题）：</p><ol>  <li>空闲链表法，把空闲的内存块加入到一个链表上，这个链表里全是空闲的内存块地址，当需要使用时就从这里找合适的。</li>  <li>分页分块法，把整个内存分成128K大小的XX页，然后再把每页分成32字节大小的内存块，用数组记录每个内存页和内存块的占用情况，这样在分配和释放时查找速度会比较快。</li>  <li>固定大小内存池，把整个分为固定大小的内存块，然后用空闲链表记录所有空闲的内存地址，每次分配都从空闲链表里推出一个内存使用。</li></ol><h3 id=\"运行库\">运行库</h3><p>作者专研的比较细，把进程启动到结束的整个过程都扒了出来，我们也跟着扒一下。</p><p>程序从开始运行到结束的步骤如下：</p><ol>  <li>操作系统fork（创建）进程，把控制权交到程序入口，这个入口通常都是公共库的某个函数（libc或MSVC）</li>  <li>入口函数对运行库和程序运行环境进行初始化，包括堆、I/O、线程、全局变量的构造等等</li>  <li>入口函数在完成初始化之后，调用main函数，正式开始执行程序主体部分</li>  <li>main函数执行完毕，返回入口函数，入口函数进行清理工作，包括全局变量析构、堆栈销毁、关闭I/O等，然后进程调用系统调用结束进程。</li></ol><p>下面我们来说说在整个系统调用里各部分是如何运作的。</p><h3 id=\"文件句柄原理\">文件句柄原理</h3><p>这里不得不提一下文件句柄的原理，因为我们常常使用文件句柄，却不知道文件句柄究竟是什么，以及是什么产生了文件句柄。</p><p>文件句柄总是和内核的文件对象相关联，内核可以通过句柄来计算出内核里文件对象的地址。在内核中，每个进程都有一个私有的“打开文件表”，这个表是一个指针数组，每一个元素都指向一个内核的打开文件对象，文件句柄就是数组的下标。当用户打开一个文件时，内核就会在内部生成一个文件对象，并在这个表里找到一个空项，让这一项指向生成的打开文件对象，并返回这一项的下标作为句柄值。由于这个“打开文件表”处于内核，并且用户无法访问到，因此用户即使拥有句柄值，也无法直接打开文件对象的地址，只能通过系统提供的函数来操作。Windows的句柄稍有不同，虽然类似于文件表的下标但它并不是下标而是经过某种线性变换的结果。</p><p>注意，文件表数组前三个元素填充的是stdin、stdout、stderr这三个内核对象。</p><h3 id=\"读取文件实现原理\">读取文件实现原理</h3><p>我们知道标准库中，文件在写入时会有缓冲区，因此在写入完毕后可以手动调用刷新接口来将缓冲取的内容清空到文件。</p><p>其实读取文件也是同样的道理，如果读取文件时总是对文件操作，那么每次都需要进入内核模式，完成后再回到用户模式。很明显这样的读取方式消耗的比较大，因此读取文件也需要自己的缓冲，以提高文件读取效率。</p><p>那么标准库是如何实现文件读取的呢？</p><p>标准库中文件读取时的执行步骤：</p><ol>  <li>每个文件读取时都会有一个缓冲区，缓冲区存储了已经读取的文件数据和还未读取的文件数据，</li>  <li>当读取文件时，先判断缓冲区中是否有此数据，</li>  <li>如果缓冲区中有我们需要的数据，则直接取得后返回即可，</li>  <li>如果没有我们需要的数据或者数据不够，则读取文件并将其后的数据一并读取放入到缓冲区中后再返回</li></ol><h3 id=\"变长参数的实现方式\">变长参数的实现方式</h3><p>这里作者说明了printf这种函数可变参数的实现方式：</p><ol>  <li>编译时将多个实参打包成byte数组传入函数</li>  <li>在函数中根据下标和大小从byte数组指针中提取形参数据</li></ol><h3 id=\"glibc的组成\">glibc的组成</h3><p>glibc中的内容由两部分组成，一部分是头文件，比如stdio.h、stdlib.h等，它们位于/usr/include，另一部分则是库的二进制文件，/lib/libc.so，或者/usr/lib/libc.a。</p><p>事实上glibc还有3个重要的运行库，</p><ul>  <li>/usr/lib/crt1.o，包含了入口程序，负责调用__libc_start_main初始化libc，并调用main函数进入真正的程序主体。</li>  <li>/usr/lib/crti.o，包含了_init()部分的程序初始化指令， 所有的.init都会被收集起来在这里调用</li>  <li>/usr/lib/crtn.o，包含了_finit()部分的程序销毁指令，所有的.finit都会被收集起来在这里调用</li></ul><p>注意，收集全局构造函数和析构函数的过程是，在链接时，将各个目标文件中.ctors段中的构造函数和析构函数合并为一个数组，在初始化和销毁时依次调用</p><p>由于crti.o必须保证在用户目标文件和系统库之前，crtn.o必须在用户目标文件和系统库之后，因此链接器输入文件顺序必须是：</p><pre><code class=\"language-c++\">ld crt1.o crti.o [user_objects] [system_libraries] crtn.o</code></pre><p>注意，前面说的都是C语言，在C++中则提供了crtbeginT.o和crtend.o来配合glibc实现C++的全局构造和析构。</p><h3 id=\"线程局部存储tlsthread-local-storage\">线程局部存储(TLS，Thread Local Storage)</h3><p>线程也可以拥有私有数据，这就是线程局部存储机制(TLS，Thread Local Storage)。TLS的用法很简单，只需要在它定义的时候加上关键字__thread就可以，在MSVC里为__declspec(thread)。</p><pre><code class=\"language-c++\">// Linux__thread in number;// MSVC__declspec(thread) int number;</code></pre><p>一旦一个全局变量被定义为TLS类型，那么每个线程都会拥有这个变量的副本，任何线程对该变量的修改都不会影响其他线程中该变量的副本。</p><p>在Windows中TLS的实现方式为：</p><ol>  <li>编译器把__declspec(thread)定义的线程私有变量放到.tls段中</li>  <li>当进程启动一个线程时，在进程堆中分配一块足够大小的空间</li>  <li>把.tls段中的内容复制到这块空间中</li>  <li>于是每个线程都有自己独立的一个.tls数据副本</li></ol><p>注意，在.rdata表中有一个TLS表，它保存了所有的TLS变量的构造和析构函数地址，在线程启动和退出时都会对TLS变量进行构造和析构。除了使用添加关键字定义TLS变量外，还可以通过系统接口的方式，实时申请TLS类型变量。</p><h3 id=\"系统内核调用原理\">系统内核调用原理</h3><p>为了安全操作系统将操作分为两种模式，一种用户模式，一种是内核模式，用户模式操作范围被限制在用户空间上，而内核模式的程序涉及的范围会更广一些，但也主要集中内核空间中。由于内核模式操作的权限更大，因此内核程序编写时需要更加谨慎并严格测试，通常我们都接触不到内核程序，除非自己编写或修改操作系统。</p><p>当用户模式要调用内核模式中的程序，要先通过EAX寄存器设置调用号，再调用中断指令，内核通过中断向量表找到系统调用程序，系统调用程序根据系统调用表查找到系统函数，最后执行系统调用。x86下中断指令为0x80，通过寄存器EAX指定系统调用的调用号，内核程序根据EAX中的值找到系统函数最后执行。</p><p>举例创建进程时的系统调用过程：</p><ol>  <li>用户调用创建进程函数，</li>  <li>创建进程函数设置eax寄存器并调用中断指令进入内核态，</li>  <li>中断指令根据0x80和中断向量表找到系统调用程序，</li>  <li>系统调用程序根据eax寄存器和系统调用表找到需要调用的函数，</li>  <li>系统调用完毕返回用户态函数返回地址。</li></ol><p>当用户态和内核态切换时，首先SS要指向内核栈，ESP指向内核栈顶，这样才能让程序当前的栈从用户栈切换到内核栈。</p><p>其实每个进程都有两个栈，用户栈和内核栈，在切换到内核栈时要保存当前上下文，因此要向内核栈中推入ESP、SS、EFLASHS、CS、EIP的值，以便切回用户态时再弹出恢复。除了这几个特殊的寄存器，向内核栈中推入的还有EBX、ECX、EDX、ESI、EDI和EBP这6个寄存器，而这6个寄存器刚好可以被系统调用函数用于实参。</p><h3 id=\"实现自定义crtc-runtime\">实现自定义CRT（C Runtime）</h3><p>作者根据前面的理论知识，实现了一个自己的CRT（C Runtime），在不使用标准库的情况下，支持自定义自己的函数入口、进程初始化与销毁、堆内存分配与释放、文件读取与写入、格式化输出。</p><p>我们这里讲解下实现CRT的几个关键点。</p><h3 id=\"关键点一\">关键点一：</h3><p>入口函数可以使用编译命令来指定，例如：</p><pre><code class=\"language-c\">gcc -nostartfiles -e myentry source.c -o source</code></pre><p>-e：设置程序的入口函数</p><h3 id=\"关键点二\">关键点二：</h3><p>进入main函数前要初始化堆内存，堆内存的管理分配与释放要自己来实现，比如实现一个FreeList空闲链表来存储销毁的堆内存以便下次使用。</p><p>例如：</p><pre><code class=\"language-c++\">//自定义堆内存块结构typedef struct _heap_header{    unsigned size;    struct _heap_header * next;    struct _heap_header * prev;} heap_header;//空闲内存链表static heap_header * freelist_head = NULL;//自定义内存释放函数void free(void * ptr){    ....}//自定义堆内存申请函数void * malloc(unsigned size){    ....}</code></pre><h3 id=\"关键点三\">关键点三：</h3><p>堆内存的扩容可以通过brk系统调用设置进程的数据段边界，而sbrk可以移动进程的数据段边界，其实将数据段边界后移就相当于分配了一个定量的内存。</p><p>由brk/sbrk分配的内存仅仅分配了虚拟空间，这些空间是不会提交的（即不分配物理内存页），当进程访问某个地址时才会与物理页关联。</p><h3 id=\"关键点四\">关键点四：</h3><p>由于不使用标准库，因此文件系统也必须自己重写，重写文件读写底层时，我们可以用汇编写系统调用来实现。</p><p>其中系统调用中，打开文件的系统调用号是5、读取文件的系统调用号是3、写入文件的系统调用号是4、关闭文件的系统调用号是6。因此在调用int 0x80前，设置eax为各调用号就可以，同时用ebx、ecx、edx将参数传入系统调用。</p><p>举例打开文件的系统调用：</p><pre><code class=\"language-c++\">asm(\"movl $5, %%eax \\n\\t\" // 设置eax的调用号    \"movl %1, %%ebx \\n\\t\" // 设置参数1    \"movl %2, %%ecx \\n\\t\" // 设置参数2    \"movl %3, %%edx \\n\\t\" // 设置参数3    \"int $0x80 \\n\\t\" // 调用0x80系统中断)</code></pre><p>前面我们说标准输入输出是文件表的前3个句柄，因此句柄0，1，2为标准输入、标准输出、标准错误的句柄。</p><h3 id=\"关键点五\">关键点五：</h3><p>实现全局构造和析构时，从.ctors段中读取构造和析构函数数据，将构造和析构函数都合并到指针数组中，依次调用函数指针数组中的方法。</p><pre><code class=\"language-c++\">typedef void (*ctor_func)(void);ctor_func ctors_begin[1] __attribute__ ((section(\".ctors\"))) = {    (ctor_func) -1;};void run_ctors(){    const ctor_func * list = ctors_begin;    while( (int)*++list != -1 )    {        (**list)();    }}</code></pre>",
            "url": "http://www.luzexi.com/2021/07/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B033",
            
            
            
            "tags": ["读书笔记","前端技术"],
            
            "date_published": "2021-07-04T00:00:00+08:00",
            "date_modified": "2021-07-04T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/07/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B032",
            "title": "读书笔记(三十二) 《C++ Primer》#5",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意。第三是当我们在巩固时创造出了新的知识，那么这些新的知识和旧的知识将同时变成智慧融合到身体中。本系列基于《C++ Primer》学习，由于重点放在“重学”，我略过了滚瓜烂熟的部分，挑出以前常忽略的部分，以及记忆没有那么深刻的部分，特别是那些重要的但没有上心的部分。正文：关联容器关联容器包括map、set以及相应的扩展容器，包括可容纳重复关键字的multimap和multiset容器，以及用unordered为前缀的无序容器。注意，对map使用下标操作时，如果关键字在容器中不存在，则会添加一个关键字在容器中。无序容器大都使用哈希方式来做查找工作，它在存储上组织为一个数组，我们可以比喻为桶管理，每个数组中的元素为桶，它保存0个或多个元素，用哈希函数将元素映射到桶中，当一个桶保存多个元素时，需要顺序搜索这些元素来查找正确的那个。因此无序容器的性能通常依赖于哈希函数的质量和数组的大小。智能指针新的标准库中有两种智能指针，一种允许多个指针指向同一个对象shared_ptr，另一种则“独占”所指向的对象unique_ptr，标准库还提供了一个名为weak_ptr的弱引用方式，来指向shared_ptr所管理的对象。其实智能指针也是模版，它通过模版并重载=、+/-、==运算符来实现智能指针的逻辑。智能指针的逻辑很简单，通过计数器来记录现在有多少个shared_ptr指向相同的对象，当计数为0时它就会自动释放对象。智能指针可以帮助我们管理内存对象的销毁时机，但智能指针不是万能的，如果你忘记销毁了智能指针，则同样会造成内存泄漏。因此我们应该明白内存管理方式有很多种，用来防止内存泄漏的方法也不只智能指针这一种。动态内存管理我们常常自己来管理内存，内存泄漏也是常用的事，分配了内存但没有释放，或者没有及时释放堆积的太多等问题都是比较普遍的。常用的new和delete运算符，在分配内存的同时，也负责调用构造函数和析构函数。如果我们想更好的管理内存，提高内存使用效率，让内存泄漏更容易分析，那么我们就得设计内存分配器来管理内存，例如固定大小内存分配器、环形内存分配器、双端内存分配器等等，这里不详细介绍。阻止对象拷贝用“=delete”定义删除函数来阻止拷贝和赋值：struct NoCopy{  NoCopy() = default; // 默认构造函数  NoCopy(const NoCopy&amp;) = delete; // 阻止拷贝  NoCopy &amp;operator = (const NoCopy&amp;) = delete; // 阻止赋值}关键字“= delete”通知了编译器，告知它我们不希望定义这些成员。注意，析构函数不能被删除，因此不能被定义删除函数。另外父类和子类对删除函数具有一致性，即父类定义了删除函数时子类也同样具备。我们也常通过private来控制拷贝，即将构造函数和赋值运算符声明为private来阻止拷贝。对象移动在内置对象中常发生对象拷贝的情况，如果想避免拷贝又想移动对象，则可以考虑右值引用。所谓右值引用，就是必须绑定到右值的引用，我们可以通过&amp;&amp;（而不是&amp;）来获得右值引用。右值引用有一个重要性质，即只能绑定到一个将要销毁的对象。使用新标准库中move函数移动对象：int &amp;&amp;rr1 = 42; int &amp;&amp;rr3 = std::move(rr1);std::move函数除了获取rr1右值引用外，还负责销毁，因此std::move后我们将不能再使用它了。由于一个移后源对象具有不确定的状态，对其调用std::move是危险的，所以当我们使用move时，必须绝对确认移动后源对象没有其他用户。为了让自定义类支持移动操作，我们可以为其定义移动构造函数和移动赋值运算符。例如：// 移动构造函数testClass::testClass(testClass &amp;&amp;s) noexcept{  var1 = s.var1; // 移动var1  var2 = s.var2; // 移动var2  s.var1 = s.var2 = nullptr; // 移动后置空}// 移动赋值运算符testClass &amp; testClass::operator = (testClass &amp;&amp;s) noexcept{  var1 = s.var1; // 移动var1  var2 = s.var2; // 移动var2  s.var1 = s.var2 = nullptr; // 移动后置空}与构造函数不同的是，移动构造函数不分配任何新内存，它会接管给定对象中的内存。在接管内存后，它将给定对象中的指针都置为 nullptr 以便在后续在销毁源对象时不会销毁这部分内存。编译器也会帮助我们合成默认的移动构造函数和移动赋值运算符，当然必须是编译器发现移动操作被用到的时候，而且只有当一个类没有定义任何自己版本的拷贝控制成员且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成默认的移动构造函数或移动赋值运算符。可调用对象可调用对象包括，函数、函数指针、lambda表达式、bind创建的对象、以及重载了的运算符。从机器指令角度上来理解，函数实质是没有类型之分的，但实际调用时，仍然会需要对齐参数和返回值，因此区别在于参数数量、参数类型、返回值类型。编译器在识别两个可调用对象是否一致时，其实并不关注它是函数指针或者其他，而关心它们的形参和返回值是否相同。这样说来，任意两个可调用对象可以共享同一种调用形式，这使得建立函数表成为了可能，前提是它们的参数和返回类型相同。标准库提供了这样一个模版封装，function，让相同的可调用对象能够转换成同一类型指针，其中T为函数类型可以用lambda表达式。function&lt;int(int, int)&gt; f1 = add; // 加法函数指针function&lt;int(int, int)&gt; f2 = divide(); // 除法函数function&lt;int(int, int)&gt; f3 = [](int i, int j){ return i*j;}; // lambda表达式count &lt;&lt; f1(4,2) &lt;&lt; endl; // 打印6count &lt;&lt; f2(4,2) &lt;&lt; endl; // 打印2count &lt;&lt; f3(4,2) &lt;&lt; endl; // 打印8虚函数OOP的核心是多态，多态的核心就是虚函数，我们知道通过虚函数可以在运行时动态确定要调用的函数，派生类的虚函数会直接覆盖基类。class testClass1{   public:       int var1;       virtual int testFunc();}class testClass2{    public:        virtual int testFunc();}testClass1 * point = new testClass2();point-&gt;testFunc(); // 调用派生类函数point-&gt;testClass1::testFunc(); // 调用父类函数虚函数原理是在虚函数调用时根据虚表来的确定，虚表中存放了当前类的虚函数，每次调用虚函数都会按固定偏移在虚表中提取函数，所以派生类覆盖了父类后，在虚表中固定偏移的函数就成了派生类的函数了。既然派生类覆盖了父类的虚函数，派生类又怎么去调用父类的虚函数呢？其实是由于代码显式的指明了调用方向，所以在编译时编译器就已经知道要调用的哪个函数，也就不需要动态借助虚表来定位了，编译时直接静态绑定父类中函数便可。小知识，我们还可以通过final关键字，阻止虚函数派生类覆盖。虚函数在构造函数和析构函数中调用要特别小心，因为此时部分成员没有被初始化，例如在父类中调用虚函数，由于此时调用的是子类虚函数，而子类成员还未被初始化，调用虚函数有可能导致不可预测的错误，因此通常在构造和析构函数内执行虚函数时用显式的方式调用当前类的虚函数。改变类成员的访问规则用using声明可以改变基类的成员访问级别class Base{  private:    void testFunc();  public:    void testFunc2();}class Derived : private Base{  public:    using Base::testFunc;  protected:    using Base::testFunc2;}上述例子中，基类中的testFunc和testFunc2在派生类中的访问级别都被改变了，testFunc从private改为了public，而testFunc2从public改为了protected。其实成员变量的访问规则只是编译器的规则，在进程的内存和指令中没有做任何限制，在汇编里你完全可以随意访问所谓的私有变量，限制你的只是编译器。",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484794&amp;idx=1&amp;sn=03be5eab5f7014e7d612ffee2a193cb9&amp;chksm=fc22607dcb55e96bd6f1dd010815d3e382cbcacca18bb1a4c69ff96ca3c4644c3d2f6240f7ef&amp;token=557108361&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h2 id=\"背景\">背景：</h2><p>我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意。第三是当我们在巩固时创造出了新的知识，那么这些新的知识和旧的知识将同时变成智慧融合到身体中。</p><p>本系列基于《C++ Primer》学习，由于重点放在“重学”，我略过了滚瓜烂熟的部分，挑出以前常忽略的部分，以及记忆没有那么深刻的部分，特别是那些重要的但没有上心的部分。</p><h2 id=\"正文\">正文：</h2><h3 id=\"关联容器\">关联容器</h3><p>关联容器包括map、set以及相应的扩展容器，包括可容纳重复关键字的multimap和multiset容器，以及用unordered为前缀的无序容器。</p><p>注意，对map使用下标操作时，如果关键字在容器中不存在，则会添加一个关键字在容器中。</p><p>无序容器大都使用哈希方式来做查找工作，它在存储上组织为一个数组，我们可以比喻为桶管理，每个数组中的元素为桶，它保存0个或多个元素，用哈希函数将元素映射到桶中，当一个桶保存多个元素时，需要顺序搜索这些元素来查找正确的那个。因此无序容器的性能通常依赖于哈希函数的质量和数组的大小。</p><h3 id=\"智能指针\">智能指针</h3><p>新的标准库中有两种智能指针，一种允许多个指针指向同一个对象shared_ptr，另一种则“独占”所指向的对象unique_ptr，标准库还提供了一个名为weak_ptr的弱引用方式，来指向shared_ptr所管理的对象。</p><p>其实智能指针也是模版，它通过模版并重载=、+/-、==运算符来实现智能指针的逻辑。智能指针的逻辑很简单，通过计数器来记录现在有多少个shared_ptr指向相同的对象，当计数为0时它就会自动释放对象。</p><p>智能指针可以帮助我们管理内存对象的销毁时机，但智能指针不是万能的，如果你忘记销毁了智能指针，则同样会造成内存泄漏。因此我们应该明白内存管理方式有很多种，用来防止内存泄漏的方法也不只智能指针这一种。</p><h3 id=\"动态内存管理\">动态内存管理</h3><p>我们常常自己来管理内存，内存泄漏也是常用的事，分配了内存但没有释放，或者没有及时释放堆积的太多等问题都是比较普遍的。</p><p>常用的new和delete运算符，在分配内存的同时，也负责调用构造函数和析构函数。</p><p>如果我们想更好的管理内存，提高内存使用效率，让内存泄漏更容易分析，那么我们就得设计内存分配器来管理内存，例如固定大小内存分配器、环形内存分配器、双端内存分配器等等，这里不详细介绍。</p><p>阻止对象拷贝</p><p>用“=delete”定义删除函数来阻止拷贝和赋值：</p><pre><code class=\"language-c++\">struct NoCopy{  NoCopy() = default; // 默认构造函数  NoCopy(const NoCopy&amp;) = delete; // 阻止拷贝  NoCopy &amp;operator = (const NoCopy&amp;) = delete; // 阻止赋值}</code></pre><p>关键字“= delete”通知了编译器，告知它我们不希望定义这些成员。注意，析构函数不能被删除，因此不能被定义删除函数。另外父类和子类对删除函数具有一致性，即父类定义了删除函数时子类也同样具备。</p><p>我们也常通过private来控制拷贝，即将构造函数和赋值运算符声明为private来阻止拷贝。</p><h3 id=\"对象移动\">对象移动</h3><p>在内置对象中常发生对象拷贝的情况，如果想避免拷贝又想移动对象，则可以考虑右值引用。所谓右值引用，就是必须绑定到右值的引用，我们可以通过&amp;&amp;（而不是&amp;）来获得右值引用。右值引用有一个重要性质，即只能绑定到一个将要销毁的对象。</p><p>使用新标准库中move函数移动对象：</p><pre><code class=\"language-c++\">int &amp;&amp;rr1 = 42; int &amp;&amp;rr3 = std::move(rr1);</code></pre><p>std::move函数除了获取rr1右值引用外，还负责销毁，因此std::move后我们将不能再使用它了。由于一个移后源对象具有不确定的状态，对其调用std::move是危险的，所以当我们使用move时，必须绝对确认移动后源对象没有其他用户。</p><p>为了让自定义类支持移动操作，我们可以为其定义移动构造函数和移动赋值运算符。例如：</p><pre><code class=\"language-c++\">// 移动构造函数testClass::testClass(testClass &amp;&amp;s) noexcept{  var1 = s.var1; // 移动var1  var2 = s.var2; // 移动var2  s.var1 = s.var2 = nullptr; // 移动后置空}// 移动赋值运算符testClass &amp; testClass::operator = (testClass &amp;&amp;s) noexcept{  var1 = s.var1; // 移动var1  var2 = s.var2; // 移动var2  s.var1 = s.var2 = nullptr; // 移动后置空}</code></pre><p>与构造函数不同的是，移动构造函数不分配任何新内存，它会接管给定对象中的内存。在接管内存后，它将给定对象中的指针都置为 nullptr 以便在后续在销毁源对象时不会销毁这部分内存。编译器也会帮助我们合成默认的移动构造函数和移动赋值运算符，当然必须是编译器发现移动操作被用到的时候，而且只有当一个类没有定义任何自己版本的拷贝控制成员且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成默认的移动构造函数或移动赋值运算符。</p><h3 id=\"可调用对象\">可调用对象</h3><p>可调用对象包括，函数、函数指针、lambda表达式、bind创建的对象、以及重载了的运算符。从机器指令角度上来理解，函数实质是没有类型之分的，但实际调用时，仍然会需要对齐参数和返回值，因此区别在于参数数量、参数类型、返回值类型。编译器在识别两个可调用对象是否一致时，其实并不关注它是函数指针或者其他，而关心它们的形参和返回值是否相同。</p><p>这样说来，任意两个可调用对象可以共享同一种调用形式，这使得建立函数表成为了可能，前提是它们的参数和返回类型相同。</p><p>标准库提供了这样一个模版封装，function<T>，让相同的可调用对象能够转换成同一类型指针，其中T为函数类型可以用lambda表达式。</T></p><pre><code class=\"language-c++\">function&lt;int(int, int)&gt; f1 = add; // 加法函数指针function&lt;int(int, int)&gt; f2 = divide(); // 除法函数function&lt;int(int, int)&gt; f3 = [](int i, int j){ return i*j;}; // lambda表达式count &lt;&lt; f1(4,2) &lt;&lt; endl; // 打印6count &lt;&lt; f2(4,2) &lt;&lt; endl; // 打印2count &lt;&lt; f3(4,2) &lt;&lt; endl; // 打印8</code></pre><h3 id=\"虚函数\">虚函数</h3><p>OOP的核心是多态，多态的核心就是虚函数，我们知道通过虚函数可以在运行时动态确定要调用的函数，派生类的虚函数会直接覆盖基类。</p><pre><code class=\"language-c++\">class testClass1{   public:       int var1;       virtual int testFunc();}class testClass2{    public:        virtual int testFunc();}testClass1 * point = new testClass2();point-&gt;testFunc(); // 调用派生类函数point-&gt;testClass1::testFunc(); // 调用父类函数</code></pre><p>虚函数原理是在虚函数调用时根据虚表来的确定，虚表中存放了当前类的虚函数，每次调用虚函数都会按固定偏移在虚表中提取函数，所以派生类覆盖了父类后，在虚表中固定偏移的函数就成了派生类的函数了。</p><p>既然派生类覆盖了父类的虚函数，派生类又怎么去调用父类的虚函数呢？其实是由于代码显式的指明了调用方向，所以在编译时编译器就已经知道要调用的哪个函数，也就不需要动态借助虚表来定位了，编译时直接静态绑定父类中函数便可。</p><p>小知识，我们还可以通过final关键字，阻止虚函数派生类覆盖。</p><p>虚函数在构造函数和析构函数中调用要特别小心，因为此时部分成员没有被初始化，例如在父类中调用虚函数，由于此时调用的是子类虚函数，而子类成员还未被初始化，调用虚函数有可能导致不可预测的错误，因此通常在构造和析构函数内执行虚函数时用显式的方式调用当前类的虚函数。</p><h3 id=\"改变类成员的访问规则\">改变类成员的访问规则</h3><p>用using声明可以改变基类的成员访问级别</p><pre><code class=\"language-c++\">class Base{  private:    void testFunc();  public:    void testFunc2();}class Derived : private Base{  public:    using Base::testFunc;  protected:    using Base::testFunc2;}</code></pre><p>上述例子中，基类中的testFunc和testFunc2在派生类中的访问级别都被改变了，testFunc从private改为了public，而testFunc2从public改为了protected。</p><p>其实成员变量的访问规则只是编译器的规则，在进程的内存和指令中没有做任何限制，在汇编里你完全可以随意访问所谓的私有变量，限制你的只是编译器。</p>",
            "url": "http://www.luzexi.com/2021/07/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B032",
            
            
            
            "tags": ["读书笔记","前端技术"],
            
            "date_published": "2021-07-03T00:00:00+08:00",
            "date_modified": "2021-07-03T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/06/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B031",
            "title": "读书笔记(三十一) 《装载、链接与库》#3 动态链接与装载",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：看此书的起源是我在了解Linux注入技术的时候翻阅到的，由于注入技术需要用到很多ELF格式的内容，很多网络上的技术文章都指向了同一本书。也刚好周围的同事有此书，便翻阅了一下，这一番翻阅打开了我对程序世界的又一扇大门。很快我就自己买了此书并阅读完成，整本书给我很大的震撼，让我对程序从编译到链接到装载有了更深刻的认识。我把我的整个学习过程以及对书本的理解，用自己的语言和自己画的图表达出来，让读者能够更容易接受到我所学的知识。目标：了解编译过程了解动态库和静态库的装载细节了解可执行程序装载和执行过程了解可执行文件和动态库的数据格式疑问：c/c++编译器是如何将cpp编译为可执行文件的？多个c/c++文件是如何编译成一个可执行文件的？操作系统内存是如何初始化和管理的？动态库和静态库的链接和装载过程是怎样的？操作系统的用户态和内核态是如何运作的？正文：前面我们说了ELF格式，以及ELF格式的静态链接过程，Windows也有自己的二进制文件格式，这里简单说一下Windows部分的格式。Windows的二进制文件格式称为PE（Protable executable），PE文件格式与ELF同根同源，都是COFF格式发展而来。Windows平台使用Visual C++编译器产生的目标文件使用COFF文件，它们的结构很大程度上都是相同的。“cl”是Visual C++的编译器，即“Compiler”的缩写，Visual C++还提供了用于查看目标文件和可执行文件的工具“dumpbin”。可执行文件装载在讲解执行文件装载前先简单介绍下虚拟空间，因为可执行文件装载需要虚拟空间支持，那么什么是虚拟空间呢？虚拟空间虚拟空间很多人都认为是一个真实的空间，其实不然，它是我们想象出来的空间，其实并不存在。而我们在理解的时候却需要承认这个空间的存在，即每个进程都拥有一个自己想象的虚拟空间，地址从0到0xFFFFFFFFF（32位设备）操作系统上的使用的内存空间都是虚拟地址空间，而非实际物理空间，它是由操作系统虚构出来的一个地址空间。这就像是操作系统给了每个进程一个世界那样，在这个世界里，进程可以自由的申请和释放内存，而不需要理会物理内存如何分配和释放。每个进程中的内存从虚拟地址都从0开始，到0xFFFFFFFF结束，其中有1G的空间专门为内核空间所用，用户空间也做了不同的分段。因此整个虚拟空间地址可以分为：.kernel 内核空间段.stack 栈内存段.libraries  动态库映射段（文件映射段）.heap 堆内存段.bass 未初始化的全局/静态变量段.data 已初始化全局/静态变量段.text 程序指令字节段其中栈内存大小是固定的，只有1MB内存，栈会不断向下分配内存，回收时只需要调整栈顶指针，因此它的分配和回收效率很高，而堆内存则不断向上分配内存，效率相对较低，回收时也容易产生内存碎片。对于Windows操作系统来说，它的进程虚拟地址空间划分是操作系统占用2GB，用户空间剩下2GB。从硬件层面上来说原先的总线32位地址只能访问最多4GB物理内存。但自从扩展至36位地址线之后，Intel修改了页映射的方式，使得新的映射方式可以访问到更多的物理内存，这个扩展方式叫做PAE（Physical Address Extension）。原理就是多块物理内存随时交换映射为同一个虚拟内存地址，这样应用程序就不需要管超出部分的内存空间了。不过这只是在32位机时代的补救办法，现在逐渐淘汰了，但这个方法在其他领域里仍然在被使用。Linux和Windows操作系统都使用页映射方式管理虚拟内存和物理内存之间的关系虚拟内存与物理内存之间由一个页表作为映射连接它们之间的关系当我们访问一块虚拟空间时，操作系统发现没有这块地址没有被连接到真实的物理地址，此时才真正从真实物理内存中找到一块内存块用页表连接起来，这才真正分配成功并且可以使用。每次分配实际物理内存，也并不是分配一整块申请的虚拟内存空间，而是按页大小来分配。即，实际物理空间在使用到时才真正分配，而虚拟空间则已经先行分配。因此我们在虚拟内存上申请的连续内存，有可能在物理内存上是不连续的。当然，申请连续内存获得实际连续内存的概率要大很多。对虚拟空间来说，一块内存只是一个数据结构，没有实际的占用，也没有真正的空间之说，只是我们说起来容易理解一些。程序启动时虚拟内存中很多内存地址都没有被用到，因此也没有对应的物理页，只有当使用到该虚拟内存页时，发现有物理内存缺页的情况，才会发起物理内存申请和映射。除了虚拟内存，不一定有实际的物理内存外，实际的物理地址上的内存，也不一定在实际物理内存中。操作系统又在实际物理内存上加了一个系统用于更好的利用实际物理内存空间，即Swap。当检测到某些物理内存上一次使用时间过长时，则会被Swap置换到硬盘空间，为实际物理内存腾出更多空间给其他进程使用。我们前文提到，在虚拟存储中，现代的硬件MMU提供了地址转换功能，帮助我们在虚拟地址和物理地址之间的转换。那么执行文件是怎么被装载进进程的呢？大致过程为，先创建一个进程，然后将可执行文件装载进进程，再开始运行程序。其中装载可执行文件时需要分三步：  创建一个独立的虚拟地址空间  读取可执行文件头，并建立虚拟空间与可执行文件的映射关系  将CPU的指令寄存器设置成可执行文件的入口地址，开始运行注意，创建一个虚拟空间实际上并不是创建空间，而是创建映射函数所需要的相应的数据结构。在i386的Linux下，创建虚拟地址空间实际上只是分配一个页目录就可以了。另外，可执行文件与虚拟空间建立映射关系时，不会有磁盘和内存的装载，当我们读取可执行文件内容时才发生“缺页”并从磁盘中读取文件内容，装载到虚拟内存再通过页表分配实际物理内存。因此，由于可执行文件在装载时实际上是被映射的虚拟空间地址，所以可执行文件很多时候被称为映像文件（Image）。ELF可执行文件引入了Segment的概念，Segment段合并了多个Section，这样的好处是装载时能更高效且方便。所有相同属性的Section都会归类到一个Segment并映射到同一个匿名虚拟内存区域中（VMA，Anonymous Virtual Memory Area）。Linux内核装载ELF过程内核装载ELF的过程可以描述为如下步骤：  调用fork()创建一个新的进程  新的进程调用execve()执行指定的ELF文件  进入execve()后，Linux内核就开始进行真正的装载工作  先调用sys_execve()进行一些参数检查与复制  再调用do_execve()，它会先查找被执行的文件，去读文件的前128个字节做文件检查，比如魔数的检查。  调用search_binary_handle()搜索和匹配合适的可执行文件装载处理过程，比如ELF可执行文件的装载处理过程为load_elf_binary()，以及装载可执行脚本程序的处理过程叫做load_script()。  load_elf_binary()执行完毕后由于把系统调用的返回地址改为了装载ELF程序的入口地址，  所以当sys_execve()从内核态返回到用户态时，EIP寄存器直接跳转到ELF程序的入口地址，  于是新的程序开始执行，ELF可执行文件装载完成。其中load_elf_binary()执行过程为：  检查ELF可执行文件的有效性，比如魔数、ELF头数据中与Segment的数量  获取动态链接的“.interp”段，并设置动态链接器路径。  根据ELF可执行文件的头描述，对ELF文件进行映射，比如代码、数据、只读数据。  初始化ELF进程环境，比如进程启动时EDX寄存器的地址应该是DT_FINI的地址。  将系统调用的返回地址修改成ELF可执行文件的入口点，入口点对于静态链接来说就是ELF头中的e_entry所指的地址，对于动态链接的ELF可执行文件入口点就是动态链接器。Windows PE的装载过程比ELF简单一些：  读取文件第一页，里面包含了DOS头、PE文件头和段表  检查进程地址空间中目标地址是否可用。如果不可用则另外选一个装载地址，这里可执行文件装载不存在问题，主要针对DLL装载。  获取段表中提供的信息，将PE文件中所有的段一一映射到地址空间中相应的位置。  如果装载地址不是目标地址，则进行Rebasing重定位。  装载所有PE文件所需要的DLL文件。  对PE文件中的所有导入符号进行解析。  根据PE头中指定的参数，建立初始化栈和堆空间。  建立主线程并启动进程。动态链接注意，静态链接和动态链接，与静态库和动态库是两个概念，前者说的是程序链接，后者说的是库的不同组装方式。静态链接由于必须在编译时就确定好库文件而且每个进程都需要载入一份内存，所以它的缺点是更多内存、更多磁盘空间、模块更新困难。我们可以想象一下，每个程序内部都增加一份1MB库程序的内存，那么100个进程就要浪费近100MB的内存，如果磁盘中有2000个这样的程序，就要浪费近2GB磁盘空间，而且在编译后还不能及时更新某个模块，弊端确实挺大的。动态链接就很好的解决了这个问题，它不仅可以使得不同进程之间共享一个库内存，还可以减少物理页的换入换出，也可以增加CPU缓存的命中率。当我们升级程序库时，只要简单的覆盖原文件而无须将所有程序再重新链接一遍，当程序下次运行时新版本库文件就会自动装载到内存完成升级目标。注意，动态链接与静态链接在内存分布上也不同。静态链接后的库程序是可执行文件内不可分割的整体，动态链接后的库程序则有自己的独立内存模块。动态库的动态链接过程其实在需要进行动态装载动态库的可执行文件中，已经装载好了一个ld-2.6.so动态库，它实际上就是Linux下的动态链接器。我们在开启一个进程时，在装载完执行文件后，进程首先会把控制权交给动态链接器，由它完成所有的动态链接工作，再把控制权交给进程开始执行。当我们在代码中写下动态库的函数时，在程序模块动态装载时，应该不需要因为装载地址的改变而改变。所以实现动态链接的基本想法就是把指令中那些需要被修改的部分分离出来，放到数据那里去，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。这种方案称为，地址无关代码（PIC，Position-independent Code）技术方案，通常我们在编译时会加上PIC这个标记，就是告诉编译器，我们这个库是地址无关的。如果一个库不是以地址无关（PIC）模式编译的，那么毫无疑问，它需要在装载时被重定位，即在启动执行时就需要装载库文件并且重定位所有与库文件有关的函数调用地址。如果一个库是以地址无关（PIC）模式编译的，那么就不会在装载时对整个库函数相关调用进行重定位，而是会用延迟绑定（PLT）的方式实时定位函数。static int a;extern int b;extern void ext();void bar(){  a = 1; // 模块内数据访问  b = 2; // 外部模块数据访问}void foo(){  bar(); // 模块内函数调用  ext(); // 外部模块函数调用}以上图为例模块内和模块间的数据访问和函数调用方法，  模块内的函数调用使用相对地址调用  模块内的数据访问使用相对寻址方式  模块外的数据访问，由于无法知道外部数据的具体地址，所以需要借助全局偏移表（GOT）获取外部数据  模块外的函数调用，由于无法知道外部函数的具体地址，所以需要借助全局偏移表（GOT）获取外部函数地址后再调用这样说来GOT就是关键中的关键，那么GOT是怎么工作的呢？大致的方案得从编译说起，我们知道在使用printf，scanf()，strlen()这样的公用库函数时都需要加载公共库libc.so，但公共库并没有被合并到可执行文件中，也就没有可依赖的地址规则。所以编译器在编译这些外部函数的时候，其实并不知道它们的调用地址是多少，无法填充真实地址。但编译器会填充一个地址指向一段动态程序，当这个函数真正被调用时，先调用到动态程序，再由动态程序去寻找真正的调用地址，最后再调用真实地址的函数。这种方法就是延迟绑定（PLT），即进程启动加载外部so后并不立刻对任何调用到so函数的指令做重定位，而是当这些外部函数被调用到时才去寻找并且绑定函数与真实地址的关系。动态链接对全局和静态数据的访问要进行复杂的GOT定位，然后再间接寻址，对外部模块中的函数调用先定位GOT，然后再进行间接跳转。GOT延迟绑定（PLT）运行原理从上图中我们可以知道PLT有3个关键点：  跳转到动态绑定程序  查找外部函数地址的程序  GOT表中数据的存储与读取我们就从这三个关键点入手说明PLT的运行原理当我们在代码里编写外部模块函数，在编译时编译器为我们留下的其实是PLT程序的地址，这个地址就是专门为这个外部函数服务的动态绑定程序，在.plt段里，符号以@plt结尾。动态绑定程序中有3条指令：  第一条就是跳转到GOT中去获取真实地址，如果有就直接跳转，没有就再跳转回来到第二条。  第二条和第三条指令是去查找函数真实地址，找到函数真实地址后把数据写入GOT中并跳转到真实地址。.plt段里动态绑定程序才是真实的查找函数地址的过程，其查找函数真实地址步骤为：  将重定位表（.rel.plt）下标传入动态链接器_dl_runtime_resove()，  由它来完成符号解析和重定位工作，  再将函数的真实地址写入到GOT表中，最后跳转到真实地址。ELF将GOT拆分成两个表，“.got”和“.got.plt”，其中“.got”用来保存全局变量引用地址，“.got.plt”用来保存函数引用地址。其中“.got.plt”的前三项有着特殊意义：  第一项保存的是“.dynamic”段地址，该段描述了本模块动态链接相关的信息。  第二项保存的是本模块的ID。  第三项保存的是_dl_runtime_resolve()地址。三项中的第二项和第三项由动态链接器在装载模块时将它们填充。第四项也稍有些特殊，通常会将跳转指令的通用程序放在第四项中以减少代码重复，因此“.got.plt”基本上前4项都是确定的内容。动态链接相关的数据结构在整个PLT绑定、查找和定位过程中用到了好几个数据段，这里介绍一下。.interp段里保存了一个字符串，这个字符串就是可执行文件件所需要的动态链接器的路径，Linux下动态链接器通常都在“/lib/ld-linux.so.2”，它通常是个软连接指向真正的库。.dynamic段是ELF动态链接最重要的结构，里面保存了动态链接器所需要的基本信息，比如依赖于哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。它有点像ELF文件头，只是ELF文件头中保存的是静态链接时需要的信息，比如符号表、重定位表等，.dynamic可以看成是动态链接下所需要的信息。.dynsym段是动态符号表，与.symtab符号表不同的是，.dynsym动态符号表只保存了与链接相关的符号，也就是外部接口符号表，对于那些模块内部的符号则不保存。为了在.dynsym中查找到对应的符号，会有一个动态符号字符串表.dynstr和符号哈希表.hash来辅助定位和查找符号字符串，加快了符号查找过程。.rel.dyn和.rel.plt段位动态链接时的重定位表，与我们之前在静态链接里介绍的.rel.text和.rel.data的用途类似，存储的是需要重定位的符号和全局数据。与.rel.text和.rel.data的区别在于，.rel.dyn实际上只是修正地址的引用，并不是实际数据地址，他修正的位置其实位于.got以及数据段中；同样的，.rel.plt修正的也只是函数地址的引用，而不是实际地址，其真正地址位于.got.plt中。了解了这几个段的用途，我们可以把调用动态库的延迟重定位的整个过程串连起来了：  程序调用动态库中函数  跳转到PLT程序集中  从GOT中获取真实函数地址，有则直接跳转  没有则从.rela.plt中获取相关信息并调用_dl_runtime_resolve()查找真实函数地址  _dl_runtime_resolve()根据查找到的so中的.dynsym动态符号表找到真实函数地址  将真实地址填充到GOT中并跳转  库函数调用结束动态链接器自己重定位我们说动态链接器本身就是一个库文件（ld-linux.so），所以在进程把控制权交给动态链接器前必须先要将这个库装载到进程中，由于此时又没有程序能去重定位这个动态链接器的库，因此动态链接库必须自己来给自己做重定位，这个重定位过程称为“自举”。自举的过程可以简单描述为：  通过自己的.dynamic段，找到它自己的重定位表和符号表  再根据重定位表和符号表，重定位所有符号表自举期间不能调用函数，因为模块内函数调用必须采用GOT/PLT方式，但GOT/PLT没有被重定位，因此自举代码不可以使用任何全局变量或调用函数。动态链接器自举完成后，就可以通过.dynamic段获取所有需要装载的动态库依次装载、解析、重定位。每个需要被装载的动态库，在装载完成后它的符号表都会被合并到全局符号表（Global Symbol Table）中，全局符号表包含了进程中所有动态链接需要的符号。运行时链接前面说的静态链接和动态链接都是在程序还未完全启动前做的事情，运行时链接则是在程序进行中加载动态库的一种方式。运行时链接的接口有4个，分别是：  dlopen，装载指定动态库  dlsym，获取动态库中的某个符号的地址  dlerror，获取上次调用的错误信息  dlclose，关闭并卸载动态库运行时链接与动态链接的一模一样（除了自举部分），区别一个在启动时装载，另一个则在程序运行时装载。注意，由于所有加载的动态库中的符号都会合并到全局符号表，因此在加载多个库时如果有重复的符号，则后加载的符号可以根据参数选择是否覆盖前面的符号表，默认是不覆盖的。这里作者做了一个试验，因为在Windows中有个rundll的小程序可以直接调用DLL中的函数并返回结果，所以作者想在Linux上也实现一个。于是自己写代码读取动态库so中的函数并调用后打印返回结果，其原理就是利用这4个函数，先dlopen加载指定so，再根据函数名调用dlsym找到函数地址并且调用，最后调用dlerror卸载动态库。已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484788&amp;idx=1&amp;sn=8e4f7f36e4ddf6dd2f7c086463c089de&amp;chksm=fc226073cb55e965e5ab259f04293c48f718a2fd72858b11397852d8ba8c7fab656b0f46e248&amp;token=283688006&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h3 id=\"背景\">背景：</h3><p>看此书的起源是我在了解Linux注入技术的时候翻阅到的，由于注入技术需要用到很多ELF格式的内容，很多网络上的技术文章都指向了同一本书。也刚好周围的同事有此书，便翻阅了一下，这一番翻阅打开了我对程序世界的又一扇大门。</p><p>很快我就自己买了此书并阅读完成，整本书给我很大的震撼，让我对程序从编译到链接到装载有了更深刻的认识。</p><p>我把我的整个学习过程以及对书本的理解，用自己的语言和自己画的图表达出来，让读者能够更容易接受到我所学的知识。</p><h3 id=\"目标\">目标：</h3><p>了解编译过程了解动态库和静态库的装载细节了解可执行程序装载和执行过程了解可执行文件和动态库的数据格式</p><h3 id=\"疑问\">疑问：</h3><p>c/c++编译器是如何将cpp编译为可执行文件的？</p><p>多个c/c++文件是如何编译成一个可执行文件的？</p><p>操作系统内存是如何初始化和管理的？</p><p>动态库和静态库的链接和装载过程是怎样的？</p><p>操作系统的用户态和内核态是如何运作的？</p><h3 id=\"正文\">正文：</h3><p>前面我们说了ELF格式，以及ELF格式的静态链接过程，Windows也有自己的二进制文件格式，这里简单说一下Windows部分的格式。</p><p>Windows的二进制文件格式称为PE（Protable executable），PE文件格式与ELF同根同源，都是COFF格式发展而来。Windows平台使用Visual C++编译器产生的目标文件使用COFF文件，它们的结构很大程度上都是相同的。“cl”是Visual C++的编译器，即“Compiler”的缩写，Visual C++还提供了用于查看目标文件和可执行文件的工具“dumpbin”。</p><h3 id=\"可执行文件装载\">可执行文件装载</h3><p>在讲解执行文件装载前先简单介绍下虚拟空间，因为可执行文件装载需要虚拟空间支持，那么什么是虚拟空间呢？</p><h3 id=\"虚拟空间\">虚拟空间</h3><p>虚拟空间很多人都认为是一个真实的空间，其实不然，它是我们想象出来的空间，其实并不存在。而我们在理解的时候却需要承认这个空间的存在，即每个进程都拥有一个自己想象的虚拟空间，地址从0到0xFFFFFFFFF（32位设备）</p><p>操作系统上的使用的内存空间都是虚拟地址空间，而非实际物理空间，它是由操作系统虚构出来的一个地址空间。</p><p>这就像是操作系统给了每个进程一个世界那样，在这个世界里，进程可以自由的申请和释放内存，而不需要理会物理内存如何分配和释放。</p><p>每个进程中的内存从虚拟地址都从0开始，到0xFFFFFFFF结束，其中有1G的空间专门为内核空间所用，用户空间也做了不同的分段。因此整个虚拟空间地址可以分为：</p><pre><code class=\"language-c\">.kernel 内核空间段.stack 栈内存段.libraries  动态库映射段（文件映射段）.heap 堆内存段.bass 未初始化的全局/静态变量段.data 已初始化全局/静态变量段.text 程序指令字节段</code></pre><p>其中栈内存大小是固定的，只有1MB内存，栈会不断向下分配内存，回收时只需要调整栈顶指针，因此它的分配和回收效率很高，而堆内存则不断向上分配内存，效率相对较低，回收时也容易产生内存碎片。</p><p>对于Windows操作系统来说，它的进程虚拟地址空间划分是操作系统占用2GB，用户空间剩下2GB。</p><p>从硬件层面上来说原先的总线32位地址只能访问最多4GB物理内存。但自从扩展至36位地址线之后，Intel修改了页映射的方式，使得新的映射方式可以访问到更多的物理内存，这个扩展方式叫做PAE（Physical Address Extension）。原理就是多块物理内存随时交换映射为同一个虚拟内存地址，这样应用程序就不需要管超出部分的内存空间了。不过这只是在32位机时代的补救办法，现在逐渐淘汰了，但这个方法在其他领域里仍然在被使用。</p><p>Linux和Windows操作系统都使用页映射方式管理虚拟内存和物理内存之间的关系</p><h3 id=\"虚拟内存与物理内存之间由一个页表作为映射连接它们之间的关系\">虚拟内存与物理内存之间由一个页表作为映射连接它们之间的关系</h3><p>当我们访问一块虚拟空间时，操作系统发现没有这块地址没有被连接到真实的物理地址，此时才真正从真实物理内存中找到一块内存块用页表连接起来，这才真正分配成功并且可以使用。</p><p>每次分配实际物理内存，也并不是分配一整块申请的虚拟内存空间，而是按页大小来分配。即，实际物理空间在使用到时才真正分配，而虚拟空间则已经先行分配。</p><p>因此我们在虚拟内存上申请的连续内存，有可能在物理内存上是不连续的。当然，申请连续内存获得实际连续内存的概率要大很多。</p><p>对虚拟空间来说，一块内存只是一个数据结构，没有实际的占用，也没有真正的空间之说，只是我们说起来容易理解一些。</p><p>程序启动时虚拟内存中很多内存地址都没有被用到，因此也没有对应的物理页，只有当使用到该虚拟内存页时，发现有物理内存缺页的情况，才会发起物理内存申请和映射。</p><p>除了虚拟内存，不一定有实际的物理内存外，实际的物理地址上的内存，也不一定在实际物理内存中。操作系统又在实际物理内存上加了一个系统用于更好的利用实际物理内存空间，即Swap。</p><p>当检测到某些物理内存上一次使用时间过长时，则会被Swap置换到硬盘空间，为实际物理内存腾出更多空间给其他进程使用。</p><p>我们前文提到，在虚拟存储中，现代的硬件MMU提供了地址转换功能，帮助我们在虚拟地址和物理地址之间的转换。</p><h3 id=\"那么执行文件是怎么被装载进进程的呢\">那么执行文件是怎么被装载进进程的呢？</h3><p>大致过程为，先创建一个进程，然后将可执行文件装载进进程，再开始运行程序。</p><p>其中装载可执行文件时需要分三步：</p><ol>  <li>创建一个独立的虚拟地址空间</li>  <li>读取可执行文件头，并建立虚拟空间与可执行文件的映射关系</li>  <li>将CPU的指令寄存器设置成可执行文件的入口地址，开始运行</li></ol><p>注意，创建一个虚拟空间实际上并不是创建空间，而是创建映射函数所需要的相应的数据结构。在i386的Linux下，创建虚拟地址空间实际上只是分配一个页目录就可以了。</p><p>另外，可执行文件与虚拟空间建立映射关系时，不会有磁盘和内存的装载，当我们读取可执行文件内容时才发生“缺页”并从磁盘中读取文件内容，装载到虚拟内存再通过页表分配实际物理内存。因此，由于可执行文件在装载时实际上是被映射的虚拟空间地址，所以可执行文件很多时候被称为映像文件（Image）。</p><p>ELF可执行文件引入了Segment的概念，Segment段合并了多个Section，这样的好处是装载时能更高效且方便。所有相同属性的Section都会归类到一个Segment并映射到同一个匿名虚拟内存区域中（VMA，Anonymous Virtual Memory Area）。</p><h3 id=\"linux内核装载elf过程\">Linux内核装载ELF过程</h3><p>内核装载ELF的过程可以描述为如下步骤：</p><ol>  <li>调用fork()创建一个新的进程</li>  <li>新的进程调用execve()执行指定的ELF文件</li>  <li>进入execve()后，Linux内核就开始进行真正的装载工作</li>  <li>先调用sys_execve()进行一些参数检查与复制</li>  <li>再调用do_execve()，它会先查找被执行的文件，去读文件的前128个字节做文件检查，比如魔数的检查。</li>  <li>调用search_binary_handle()搜索和匹配合适的可执行文件装载处理过程，比如ELF可执行文件的装载处理过程为load_elf_binary()，以及装载可执行脚本程序的处理过程叫做load_script()。</li>  <li>load_elf_binary()执行完毕后由于把系统调用的返回地址改为了装载ELF程序的入口地址，</li>  <li>所以当sys_execve()从内核态返回到用户态时，EIP寄存器直接跳转到ELF程序的入口地址，</li>  <li>于是新的程序开始执行，ELF可执行文件装载完成。</li></ol><p>其中load_elf_binary()执行过程为：</p><ol>  <li>检查ELF可执行文件的有效性，比如魔数、ELF头数据中与Segment的数量</li>  <li>获取动态链接的“.interp”段，并设置动态链接器路径。</li>  <li>根据ELF可执行文件的头描述，对ELF文件进行映射，比如代码、数据、只读数据。</li>  <li>初始化ELF进程环境，比如进程启动时EDX寄存器的地址应该是DT_FINI的地址。</li>  <li>将系统调用的返回地址修改成ELF可执行文件的入口点，入口点对于静态链接来说就是ELF头中的e_entry所指的地址，对于动态链接的ELF可执行文件入口点就是动态链接器。</li></ol><p>Windows PE的装载过程比ELF简单一些：</p><ol>  <li>读取文件第一页，里面包含了DOS头、PE文件头和段表</li>  <li>检查进程地址空间中目标地址是否可用。如果不可用则另外选一个装载地址，这里可执行文件装载不存在问题，主要针对DLL装载。</li>  <li>获取段表中提供的信息，将PE文件中所有的段一一映射到地址空间中相应的位置。</li>  <li>如果装载地址不是目标地址，则进行Rebasing重定位。</li>  <li>装载所有PE文件所需要的DLL文件。</li>  <li>对PE文件中的所有导入符号进行解析。</li>  <li>根据PE头中指定的参数，建立初始化栈和堆空间。</li>  <li>建立主线程并启动进程。</li></ol><h3 id=\"动态链接\">动态链接</h3><p>注意，静态链接和动态链接，与静态库和动态库是两个概念，前者说的是程序链接，后者说的是库的不同组装方式。</p><p>静态链接由于必须在编译时就确定好库文件而且每个进程都需要载入一份内存，所以它的缺点是更多内存、更多磁盘空间、模块更新困难。</p><p>我们可以想象一下，每个程序内部都增加一份1MB库程序的内存，那么100个进程就要浪费近100MB的内存，如果磁盘中有2000个这样的程序，就要浪费近2GB磁盘空间，而且在编译后还不能及时更新某个模块，弊端确实挺大的。</p><p>动态链接就很好的解决了这个问题，它不仅可以使得不同进程之间共享一个库内存，还可以减少物理页的换入换出，也可以增加CPU缓存的命中率。当我们升级程序库时，只要简单的覆盖原文件而无须将所有程序再重新链接一遍，当程序下次运行时新版本库文件就会自动装载到内存完成升级目标。</p><p>注意，动态链接与静态链接在内存分布上也不同。静态链接后的库程序是可执行文件内不可分割的整体，动态链接后的库程序则有自己的独立内存模块。</p><h3 id=\"动态库的动态链接过程\">动态库的动态链接过程</h3><p>其实在需要进行动态装载动态库的可执行文件中，已经装载好了一个ld-2.6.so动态库，它实际上就是Linux下的动态链接器。</p><p>我们在开启一个进程时，在装载完执行文件后，进程首先会把控制权交给动态链接器，由它完成所有的动态链接工作，再把控制权交给进程开始执行。</p><p>当我们在代码中写下动态库的函数时，在程序模块动态装载时，应该不需要因为装载地址的改变而改变。所以实现动态链接的基本想法就是把指令中那些需要被修改的部分分离出来，放到数据那里去，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。</p><p>这种方案称为，地址无关代码（PIC，Position-independent Code）技术方案，通常我们在编译时会加上PIC这个标记，就是告诉编译器，我们这个库是地址无关的。</p><p>如果一个库不是以地址无关（PIC）模式编译的，那么毫无疑问，它需要在装载时被重定位，即在启动执行时就需要装载库文件并且重定位所有与库文件有关的函数调用地址。</p><p>如果一个库是以地址无关（PIC）模式编译的，那么就不会在装载时对整个库函数相关调用进行重定位，而是会用延迟绑定（PLT）的方式实时定位函数。</p><pre><code class=\"language-c\">static int a;extern int b;extern void ext();void bar(){  a = 1; // 模块内数据访问  b = 2; // 外部模块数据访问}void foo(){  bar(); // 模块内函数调用  ext(); // 外部模块函数调用}</code></pre><p>以上图为例模块内和模块间的数据访问和函数调用方法，</p><ol>  <li>模块内的函数调用使用相对地址调用</li>  <li>模块内的数据访问使用相对寻址方式</li>  <li>模块外的数据访问，由于无法知道外部数据的具体地址，所以需要借助全局偏移表（GOT）获取外部数据</li>  <li>模块外的函数调用，由于无法知道外部函数的具体地址，所以需要借助全局偏移表（GOT）获取外部函数地址后再调用</li></ol><h3 id=\"这样说来got就是关键中的关键那么got是怎么工作的呢\">这样说来GOT就是关键中的关键，那么GOT是怎么工作的呢？</h3><p>大致的方案得从编译说起，我们知道在使用printf，scanf()，strlen()这样的公用库函数时都需要加载公共库libc.so，但公共库并没有被合并到可执行文件中，也就没有可依赖的地址规则。</p><p>所以编译器在编译这些外部函数的时候，其实并不知道它们的调用地址是多少，无法填充真实地址。但编译器会填充一个地址指向一段动态程序，当这个函数真正被调用时，先调用到动态程序，再由动态程序去寻找真正的调用地址，最后再调用真实地址的函数。</p><p>这种方法就是延迟绑定（PLT），即进程启动加载外部so后并不立刻对任何调用到so函数的指令做重定位，而是当这些外部函数被调用到时才去寻找并且绑定函数与真实地址的关系。</p><p>动态链接对全局和静态数据的访问要进行复杂的GOT定位，然后再间接寻址，对外部模块中的函数调用先定位GOT，然后再进行间接跳转。</p><h3 id=\"got延迟绑定plt运行原理\">GOT延迟绑定（PLT）运行原理</h3><p>从上图中我们可以知道PLT有3个关键点：</p><ol>  <li>跳转到动态绑定程序</li>  <li>查找外部函数地址的程序</li>  <li>GOT表中数据的存储与读取</li></ol><p>我们就从这三个关键点入手说明PLT的运行原理</p><p>当我们在代码里编写外部模块函数，在编译时编译器为我们留下的其实是PLT程序的地址，这个地址就是专门为这个外部函数服务的动态绑定程序，在.plt段里，符号以@plt结尾。</p><p>动态绑定程序中有3条指令：</p><ul>  <li>第一条就是跳转到GOT中去获取真实地址，如果有就直接跳转，没有就再跳转回来到第二条。</li>  <li>第二条和第三条指令是去查找函数真实地址，找到函数真实地址后把数据写入GOT中并跳转到真实地址。</li></ul><p>.plt段里动态绑定程序才是真实的查找函数地址的过程，其查找函数真实地址步骤为：</p><ul>  <li>将重定位表（.rel.plt）下标传入动态链接器_dl_runtime_resove()，</li>  <li>由它来完成符号解析和重定位工作，</li>  <li>再将函数的真实地址写入到GOT表中，最后跳转到真实地址。</li></ul><p>ELF将GOT拆分成两个表，“.got”和“.got.plt”，其中“.got”用来保存全局变量引用地址，“.got.plt”用来保存函数引用地址。</p><p>其中“.got.plt”的前三项有着特殊意义：</p><ul>  <li>第一项保存的是“.dynamic”段地址，该段描述了本模块动态链接相关的信息。</li>  <li>第二项保存的是本模块的ID。</li>  <li>第三项保存的是_dl_runtime_resolve()地址。</li></ul><p>三项中的第二项和第三项由动态链接器在装载模块时将它们填充。第四项也稍有些特殊，通常会将跳转指令的通用程序放在第四项中以减少代码重复，因此“.got.plt”基本上前4项都是确定的内容。</p><h3 id=\"动态链接相关的数据结构\">动态链接相关的数据结构</h3><p>在整个PLT绑定、查找和定位过程中用到了好几个数据段，这里介绍一下。</p><p>.interp段里保存了一个字符串，这个字符串就是可执行文件件所需要的动态链接器的路径，Linux下动态链接器通常都在“/lib/ld-linux.so.2”，它通常是个软连接指向真正的库。</p><p>.dynamic段是ELF动态链接最重要的结构，里面保存了动态链接器所需要的基本信息，比如依赖于哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。</p><p>它有点像ELF文件头，只是ELF文件头中保存的是静态链接时需要的信息，比如符号表、重定位表等，.dynamic可以看成是动态链接下所需要的信息。</p><p>.dynsym段是动态符号表，与.symtab符号表不同的是，.dynsym动态符号表只保存了与链接相关的符号，也就是外部接口符号表，对于那些模块内部的符号则不保存。</p><p>为了在.dynsym中查找到对应的符号，会有一个动态符号字符串表.dynstr和符号哈希表.hash来辅助定位和查找符号字符串，加快了符号查找过程。</p><p>.rel.dyn和.rel.plt段位动态链接时的重定位表，与我们之前在静态链接里介绍的.rel.text和.rel.data的用途类似，存储的是需要重定位的符号和全局数据。</p><p>与.rel.text和.rel.data的区别在于，.rel.dyn实际上只是修正地址的引用，并不是实际数据地址，他修正的位置其实位于.got以及数据段中；同样的，.rel.plt修正的也只是函数地址的引用，而不是实际地址，其真正地址位于.got.plt中。</p><p>了解了这几个段的用途，我们可以把调用动态库的延迟重定位的整个过程串连起来了：</p><ol>  <li>程序调用动态库中函数</li>  <li>跳转到PLT程序集中</li>  <li>从GOT中获取真实函数地址，有则直接跳转</li>  <li>没有则从.rela.plt中获取相关信息并调用_dl_runtime_resolve()查找真实函数地址</li>  <li>_dl_runtime_resolve()根据查找到的so中的.dynsym动态符号表找到真实函数地址</li>  <li>将真实地址填充到GOT中并跳转</li>  <li>库函数调用结束</li></ol><h3 id=\"动态链接器自己重定位\">动态链接器自己重定位</h3><p>我们说动态链接器本身就是一个库文件（ld-linux.so），所以在进程把控制权交给动态链接器前必须先要将这个库装载到进程中，由于此时又没有程序能去重定位这个动态链接器的库，因此动态链接库必须自己来给自己做重定位，这个重定位过程称为“自举”。</p><p>自举的过程可以简单描述为：</p><ol>  <li>通过自己的.dynamic段，找到它自己的重定位表和符号表</li>  <li>再根据重定位表和符号表，重定位所有符号表</li></ol><p>自举期间不能调用函数，因为模块内函数调用必须采用GOT/PLT方式，但GOT/PLT没有被重定位，因此自举代码不可以使用任何全局变量或调用函数。</p><p>动态链接器自举完成后，就可以通过.dynamic段获取所有需要装载的动态库依次装载、解析、重定位。每个需要被装载的动态库，在装载完成后它的符号表都会被合并到全局符号表（Global Symbol Table）中，全局符号表包含了进程中所有动态链接需要的符号。</p><h3 id=\"运行时链接\">运行时链接</h3><p>前面说的静态链接和动态链接都是在程序还未完全启动前做的事情，运行时链接则是在程序进行中加载动态库的一种方式。</p><p>运行时链接的接口有4个，分别是：</p><ol>  <li>dlopen，装载指定动态库</li>  <li>dlsym，获取动态库中的某个符号的地址</li>  <li>dlerror，获取上次调用的错误信息</li>  <li>dlclose，关闭并卸载动态库</li></ol><p>运行时链接与动态链接的一模一样（除了自举部分），区别一个在启动时装载，另一个则在程序运行时装载。</p><p>注意，由于所有加载的动态库中的符号都会合并到全局符号表，因此在加载多个库时如果有重复的符号，则后加载的符号可以根据参数选择是否覆盖前面的符号表，默认是不覆盖的。</p><p>这里作者做了一个试验，因为在Windows中有个rundll的小程序可以直接调用DLL中的函数并返回结果，所以作者想在Linux上也实现一个。于是自己写代码读取动态库so中的函数并调用后打印返回结果，其原理就是利用这4个函数，先dlopen加载指定so，再根据函数名调用dlsym找到函数地址并且调用，最后调用dlerror卸载动态库。</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484788&amp;idx=1&amp;sn=8e4f7f36e4ddf6dd2f7c086463c089de&amp;chksm=fc226073cb55e965e5ab259f04293c48f718a2fd72858b11397852d8ba8c7fab656b0f46e248&amp;token=283688006&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/06/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B031",
            
            
            
            "tags": ["读书笔记","前端技术"],
            
            "date_published": "2021-06-27T00:00:00+08:00",
            "date_modified": "2021-06-27T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/06/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B030",
            "title": "读书笔记(三十) 《C++ Primer》#4",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意。第三是当我们在巩固时创造出了新的知识，那么这些新的知识和旧的知识将同时变成智慧融合到身体中。本系列基于《C++ Primer》学习，由于重点放在“重学”，我略过了滚瓜烂熟的部分，挑出以前常忽略的部分，以及记忆没有那么深刻的部分，特别是那些重要的但没有上心的部分。正文类相关定义注意，this指针是常量指针，因为我们不允许改变this指针中保存的地址。当我们定义类相关的非成员函数时，即如果函数在概念上属于类但不定义在类中，则它一般应与类声明在同一个头文件中。这种方式下，当用户使用接口的任何部分都只需要引用一个文件，举例：//testClass.h//类声明class testClass {  //test class  public:    int testVar;}//类相关的非成员函数int readFrom_testClass(const testClass &amp; item);默认合成的构造函数编译器创建的默认构造函数称为，合成的默认构造函数（synthesized default constructor），它的规则如下：  如果存在类内的初始值，用它来初始化成员。  否则，默认初始化该成员。合成的默认构造函数只适合非常简单的类，其他某些类不能依赖于合成默认构造函数，原因有三：  编译器只有在发现类不包含任何构造函数的情况下才替我们生成一个默认的构造函数。  类中含有内置类型或者复合类型成员的类应该在类的内部初始化这些成员，否则使用默认构造函数可能得到未定义值。  类中含有其他类型成员且成员类型没有默认构造函数，则默认构造函数无法初始化这个成员。当然最好是我们自己定义每个类的构造函数而不是让编译器使用默认构造函数，如果你不能使用类内初始化值，则所有构造函数都应该显式地初始化每个内置类型的成员。Class和Struct的区别与C#、Java不同，C++中Class和Struct几乎一样，只是关键字不同和使用习惯不同而已。唯一的微小区别就是，使用Class的默认访问模式为private，而struct的默认访问模式是public。友元友元允许其他类或函数访问自己的非公有成员，这个大家都知道就不多说了。需要注意的是友元关系不存在传递性，也就是说子类的友元并不能理所当然的访问父类。而且想要所有重载函数成为友元关系，必须为每个重载函数做一次友元声明。不过在编译时，友元的声明仅仅指定了访问的权限，它只是标记编译的语法规则好让编译器在语法检查时能知道友元标记的存在，实际上编译器并没有做任何内存上和寄存器上的修改。构造函数初始值列表class testClass{  public:      testClass(int ii);  private:      int i;      const int ci;      int &amp;ri;}testClass::testClass(intii):    i(ii),ci(ii),ri(i){  //do something}我们在类中常使用以上这种构造函数来初始化成员，其实这就相当于成员的初始化顺序，即先初始化i，然后ci，然后ri。隐式的类构造转换在对象构造时，也会出现隐式的构造情况，例如：class Test_data{   Test_data(const string str);}string test_str = \"test\";Vector&lt;Test_data&gt; item;item.push(test_str);如果构造函数只接受一个实参，则实际上它同时也定义了转换为此类类型的隐式转换机制，我们把这种构造函数称为，转换构造函数（converting constructor）。上面例子中传入的string对象从而引发了Test_data的转换构造函数，构造出对象后再传入，其实这些隐式转换和构造都是在编译时离线计算的，根本不会放到运行时去发生。如果你不想让隐式构造发生，可以通过在构造函数前加 explicit 声明来阻止隐式转换，如下：class Test_data{   explicit Test_data(const string str);}string test_str = \"test\";Vector&lt;Test_data&gt; item;item.push_back(test_str); // 编译错误item.push_back(Test_data(test_str)); // 编译正确声明了explicit的构造函数，只能以直接初始化的形式使用，编译器将不会再进行隐式的自动转换这些构造函数。IO库这里有些零散的知识需要注意下。IO库定义了很多标记，这些标记可以帮助我们访问和操作流，例如由于流可能处于错误状态，我们在操作之前先去检查它是否处于良好状态。其中badbit标记相对用的比较多，它表示系统级错误，例如不可恢复的读写错误。通常情况下，一旦badbit被置位，流就无法再使用了。IO流有缓冲机制，这可以提升IO的性能，当刷新时才将数据写入到文件中。导致缓冲刷新的几种情况为：  程序正常结束，main函数return操作。  缓冲区满时，需要刷新缓冲。  使用操作符endl来显式刷新缓冲区。  使用操作符unitbuf设置流的内部状态，清空缓冲区。  一个输出流被关联到另一个流时，输出流会被刷新。注意，如果程序崩溃了，输出流的缓冲区是不会被刷新的，这也是为什么崩溃时部分数据没有被写入文件的原因。顺序容器顺序容器指，vector，deque，list，array，string，它们都可以用迭代器访问元素。如果我们不需要写访问元素，则应该使用cbegin和cend来获取常量迭代指针。顺序容器中有一个方法比较有趣assign（array除外），它可以用参数所指定的元素（拷贝形式）替换容器中的所有元素。seq.assign(b,e); // 将seq替换为迭代器b到e范围内的元素seq.assign(il); // 将seq替换为容器列表il中的元素seq.assign(il); // 将seq替换为n个t值的元素注意，当我们用一个对象来初始化容器，或者将一个对象插入到容器中时，实际上放入到容器中的是对象的拷贝，而不是对象本身。就像我们将一个对象传递给非引用参数一样，容器中的元素与提供值的对象之间没有任何关联。另外我们也要注意向容器中添加元素或删除元素的操作，可能会使得指向容器的指针、引用、迭代器失效，进而导致运行时错误。泛型算法标准库并没有给每个容器添加大量功能，而是提供了一组算法，这些算法大多是通用算法，可以独立于任何特定的容器。归纳总结下来，泛型算法有4个特点：  大多是通用算法，可以独立于任何特定的容器  虽然独立于任何容器，但有些算法依赖于元素类型（例如累加算法依赖于带有加法运算的对象类型）。  不会直接操作容器，而是运行于迭代器之上，执行的是迭代器的操作。  算法可能改变容器中保存的值，或移动容器中的元素，但永远不会直接添加或者删除元素。lambda函数当定义一个lambda函数时，编译器生成一个与lambda对应的新（未命名的）类类型。也就是说当向一个函数传递一个lambda函数时，编译器同时定义了一个新类型和该类型的一个对象，传递的参数就是此编译器生成的类类型的未命名对象，而不是传入的对象。void func1(){  int v1 = 41;  auto f = [v1] {return v1;}; // 值捕获  v1 = 0;  auto j = f(); // j 为 41  auto f2 = [&amp;v1] {return v1;} // 引用捕获  v1 = 2;  auto j = f2(); // j 为 2}transform(v1.begin(), vi.end(), vi.begin(), [](int i) -&gt; int { if (i &lt; 0) return -i; else return i; }); // lambda函数指定了int返回值和int形参注意，如上代码中，如果lambda形参为引用则需要我们注意实参的生命周期，因为在lambda执行时，如果该对象已经被销毁则可能引起运行时错误。除了使用lambda创建快速创建函数外，也可以使用标准库里bind函数来生成函数，例如：// 格式： auto newCallable = bind(callable, arg_list);void func1(int a, int b){  return a + b;}int aa = 1;int bb = 2;auto newFunc1 = bind(func1, aa, bb); // 生成一个新的可调用对象来适配算法auto wc = find_if(words.begin(), words.end(), newFunc1); // bind生成了一个适配泛型算法的函数bind可以看做是一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484770&amp;idx=1&amp;sn=417618b18d6a0bf34b5fa720031f6312&amp;chksm=fc226065cb55e973587b7a3e372b71acf1def7cb7b04ce3ba2d43a5e4871582f72459bcb962d&amp;token=283688006&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h3 id=\"背景\">背景：</h3><p>我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意。第三是当我们在巩固时创造出了新的知识，那么这些新的知识和旧的知识将同时变成智慧融合到身体中。</p><p>本系列基于《C++ Primer》学习，由于重点放在“重学”，我略过了滚瓜烂熟的部分，挑出以前常忽略的部分，以及记忆没有那么深刻的部分，特别是那些重要的但没有上心的部分。</p><h3 id=\"正文\">正文</h3><h3 id=\"类相关定义\">类相关定义</h3><p>注意，this指针是常量指针，因为我们不允许改变this指针中保存的地址。</p><p>当我们定义类相关的非成员函数时，即如果函数在概念上属于类但不定义在类中，则它一般应与类声明在同一个头文件中。这种方式下，当用户使用接口的任何部分都只需要引用一个文件，举例：</p><pre><code class=\"language-c\">//testClass.h//类声明class testClass {  //test class  public:    int testVar;}//类相关的非成员函数int readFrom_testClass(const testClass &amp; item);</code></pre><p>默认合成的构造函数</p><p>编译器创建的默认构造函数称为，合成的默认构造函数（synthesized default constructor），它的规则如下：</p><ol>  <li>如果存在类内的初始值，用它来初始化成员。</li>  <li>否则，默认初始化该成员。</li></ol><p>合成的默认构造函数只适合非常简单的类，其他某些类不能依赖于合成默认构造函数，原因有三：</p><ol>  <li>编译器只有在发现类不包含任何构造函数的情况下才替我们生成一个默认的构造函数。</li>  <li>类中含有内置类型或者复合类型成员的类应该在类的内部初始化这些成员，否则使用默认构造函数可能得到未定义值。</li>  <li>类中含有其他类型成员且成员类型没有默认构造函数，则默认构造函数无法初始化这个成员。</li></ol><p>当然最好是我们自己定义每个类的构造函数而不是让编译器使用默认构造函数，如果你不能使用类内初始化值，则所有构造函数都应该显式地初始化每个内置类型的成员。</p><h3 id=\"class和struct的区别\">Class和Struct的区别</h3><p>与C#、Java不同，C++中Class和Struct几乎一样，只是关键字不同和使用习惯不同而已。唯一的微小区别就是，使用Class的默认访问模式为private，而struct的默认访问模式是public。</p><h3 id=\"友元\">友元</h3><p>友元允许其他类或函数访问自己的非公有成员，这个大家都知道就不多说了。需要注意的是友元关系不存在传递性，也就是说子类的友元并不能理所当然的访问父类。而且想要所有重载函数成为友元关系，必须为每个重载函数做一次友元声明。</p><p>不过在编译时，友元的声明仅仅指定了访问的权限，它只是标记编译的语法规则好让编译器在语法检查时能知道友元标记的存在，实际上编译器并没有做任何内存上和寄存器上的修改。</p><h3 id=\"构造函数初始值列表\">构造函数初始值列表</h3><pre><code class=\"language-c\">class testClass{  public:      testClass(int ii);  private:      int i;      const int ci;      int &amp;ri;}testClass::testClass(intii):    i(ii),ci(ii),ri(i){  //do something}</code></pre><p>我们在类中常使用以上这种构造函数来初始化成员，其实这就相当于成员的初始化顺序，即先初始化i，然后ci，然后ri。</p><h3 id=\"隐式的类构造转换\">隐式的类构造转换</h3><p>在对象构造时，也会出现隐式的构造情况，例如：</p><pre><code class=\"language-c\">class Test_data{   Test_data(const string str);}string test_str = \"test\";Vector&lt;Test_data&gt; item;item.push(test_str);</code></pre><p>如果构造函数只接受一个实参，则实际上它同时也定义了转换为此类类型的隐式转换机制，我们把这种构造函数称为，转换构造函数（converting constructor）。</p><p>上面例子中传入的string对象从而引发了Test_data的转换构造函数，构造出对象后再传入，其实这些隐式转换和构造都是在编译时离线计算的，根本不会放到运行时去发生。</p><p>如果你不想让隐式构造发生，可以通过在构造函数前加 explicit 声明来阻止隐式转换，如下：</p><pre><code class=\"language-c\">class Test_data{   explicit Test_data(const string str);}string test_str = \"test\";Vector&lt;Test_data&gt; item;item.push_back(test_str); // 编译错误item.push_back(Test_data(test_str)); // 编译正确</code></pre><p>声明了explicit的构造函数，只能以直接初始化的形式使用，编译器将不会再进行隐式的自动转换这些构造函数。</p><h3 id=\"io库\">IO库</h3><p>这里有些零散的知识需要注意下。</p><p>IO库定义了很多标记，这些标记可以帮助我们访问和操作流，例如由于流可能处于错误状态，我们在操作之前先去检查它是否处于良好状态。其中badbit标记相对用的比较多，它表示系统级错误，例如不可恢复的读写错误。通常情况下，一旦badbit被置位，流就无法再使用了。</p><p>IO流有缓冲机制，这可以提升IO的性能，当刷新时才将数据写入到文件中。</p><p>导致缓冲刷新的几种情况为：</p><ol>  <li>程序正常结束，main函数return操作。</li>  <li>缓冲区满时，需要刷新缓冲。</li>  <li>使用操作符endl来显式刷新缓冲区。</li>  <li>使用操作符unitbuf设置流的内部状态，清空缓冲区。</li>  <li>一个输出流被关联到另一个流时，输出流会被刷新。</li></ol><p>注意，如果程序崩溃了，输出流的缓冲区是不会被刷新的，这也是为什么崩溃时部分数据没有被写入文件的原因。</p><h3 id=\"顺序容器\">顺序容器</h3><p>顺序容器指，vector，deque，list，array，string，它们都可以用迭代器访问元素。如果我们不需要写访问元素，则应该使用cbegin和cend来获取常量迭代指针。</p><p>顺序容器中有一个方法比较有趣assign（array除外），它可以用参数所指定的元素（拷贝形式）替换容器中的所有元素。seq.assign(b,e); // 将seq替换为迭代器b到e范围内的元素seq.assign(il); // 将seq替换为容器列表il中的元素seq.assign(il); // 将seq替换为n个t值的元素</p><p>注意，当我们用一个对象来初始化容器，或者将一个对象插入到容器中时，实际上放入到容器中的是对象的拷贝，而不是对象本身。就像我们将一个对象传递给非引用参数一样，容器中的元素与提供值的对象之间没有任何关联。</p><p>另外我们也要注意向容器中添加元素或删除元素的操作，可能会使得指向容器的指针、引用、迭代器失效，进而导致运行时错误。</p><h3 id=\"泛型算法\">泛型算法</h3><p>标准库并没有给每个容器添加大量功能，而是提供了一组算法，这些算法大多是通用算法，可以独立于任何特定的容器。</p><p>归纳总结下来，泛型算法有4个特点：</p><ol>  <li>大多是通用算法，可以独立于任何特定的容器</li>  <li>虽然独立于任何容器，但有些算法依赖于元素类型（例如累加算法依赖于带有加法运算的对象类型）。</li>  <li>不会直接操作容器，而是运行于迭代器之上，执行的是迭代器的操作。</li>  <li>算法可能改变容器中保存的值，或移动容器中的元素，但永远不会直接添加或者删除元素。</li></ol><h3 id=\"lambda函数\">lambda函数</h3><p>当定义一个lambda函数时，编译器生成一个与lambda对应的新（未命名的）类类型。</p><p>也就是说当向一个函数传递一个lambda函数时，编译器同时定义了一个新类型和该类型的一个对象，传递的参数就是此编译器生成的类类型的未命名对象，而不是传入的对象。</p><pre><code class=\"language-c\">void func1(){  int v1 = 41;  auto f = [v1] {return v1;}; // 值捕获  v1 = 0;  auto j = f(); // j 为 41  auto f2 = [&amp;v1] {return v1;} // 引用捕获  v1 = 2;  auto j = f2(); // j 为 2}transform(v1.begin(), vi.end(), vi.begin(), [](int i) -&gt; int { if (i &lt; 0) return -i; else return i; }); // lambda函数指定了int返回值和int形参</code></pre><p>注意，如上代码中，如果lambda形参为引用则需要我们注意实参的生命周期，因为在lambda执行时，如果该对象已经被销毁则可能引起运行时错误。</p><p>除了使用lambda创建快速创建函数外，也可以使用标准库里bind函数来生成函数，例如：</p><pre><code class=\"language-c\">// 格式： auto newCallable = bind(callable, arg_list);void func1(int a, int b){  return a + b;}int aa = 1;int bb = 2;auto newFunc1 = bind(func1, aa, bb); // 生成一个新的可调用对象来适配算法auto wc = find_if(words.begin(), words.end(), newFunc1); // bind生成了一个适配泛型算法的函数</code></pre><p>bind可以看做是一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484770&amp;idx=1&amp;sn=417618b18d6a0bf34b5fa720031f6312&amp;chksm=fc226065cb55e973587b7a3e372b71acf1def7cb7b04ce3ba2d43a5e4871582f72459bcb962d&amp;token=283688006&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/06/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B030",
            
            
            
            "tags": ["读书笔记","前端技术"],
            
            "date_published": "2021-06-26T00:00:00+08:00",
            "date_modified": "2021-06-26T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/06/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B029",
            "title": "读书笔记(二十九) 《装载、链接与库》#2 静态链接过程",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：看此书的起源是我在了解Linux注入技术的时候翻阅到的，由于注入技术需要用到很多ELF格式的内容，很多网络上的技术文章都指向了同一本书。也刚好周围的同事有此书，便翻阅了一下，这一番翻阅打开了我对程序世界的又一扇大门。很快我就自己买了此书并阅读完成，整本书给我很大的震撼，让我对程序从编译到链接到装载有了更深刻的认识。我把我的整个学习过程以及对书本的理解，用自己的语言和自己画的图表达出来，让读者能够更容易接受到我所学的知识。目标：了解编译过程了解动态库和静态库的装载细节了解可执行程序装载和执行过程了解可执行文件和动态库的数据格式疑问：c/c++编译器是如何将cpp编译为可执行文件的？多个c/c++文件是如何编译成一个可执行文件的？操作系统内存是如何初始化和管理的？动态库和静态库的链接和装载过程是怎样的？操作系统的用户态和内核态是如何运作的？正文：前文《链接、装载与库-回顾基础》说了计算机设备的架构，硬盘的存储方式，内存虚拟空间的意义，多线程调度和安全的本质，以及代码编译的整体流程。我们平常用C++代码编译出来的可执行文件、静态库、动态库，看上去它们的不一样的东西，其实它们的数据格式是相同的。现代流行的操作系统分Windows和Linux两种，因此我们主要介绍这两种平台下的文件格式。在Windows下的可执行文件格式称为PE（Portable Executable），在Linux下则称为ELF（Executable Linkable Format），其实它们都是COFF（Common file format）格式的变种。不光是可执行文件，动态链接库（DLL，Dynamic Linking Library）和静态链接库（Static Linking Library）都是按照可执行文件格式存储的。静态链接库稍有不同，它把很多目标文件捆绑在一起形成一个文件，可以简单把它理解为一个包含很多目标文件的文件包。单个目标文件简单的结构介绍int global_init_var = 84; // 已初始化全局变量int global_uninit_var; // 未初始化全局变量//全局函数void func1( int i){    printf(\"%d\\n\",i);}//入口函数int main(void){    static int static_var = 85; // 已初始化静态变量    static int static_var2; // 未初始化静态变量    int a = 1; // 已初始化局部变量    int b; // 未初始化局部变量    func1(static_var + static_var2 + a + b); // 调用全局函数    return 0;}我们先以目标文件为例，来举一个简单的文件ELF结构。目标文件是最常见的编译单位，它将指令代码、数据以Section的形式存储在文件中。上图中我们简单说明了程序、已初始化全局数据、未初始化全局数据在目标文件中的存放位置。其中.data段保存的是已初始化了的全局静态变量和局部静态变量，这些数据是可写可读的，而只读数据则存放在.rodata中，例如const修饰的变量和字符串常量。用.rodata单独保存只读数据能够更加好的保护数据，任何修改.rodata中的数据都会作为非法操作处理。类似的Section段有很多，我们列举一些重要的来说：.bss：包含程序运行时未初始化的数据（全局变量和静态变量）。当程序运行时，这些数据初始化为0。.data和.data1，包含初始化的全局变量和静态变量。.dynamic，包含了动态链接的信息，包括链接器地址、需要的动态库、段地址信息，类型为SHT_DYNAMIC。.dynstr，包含了动态链接用的字符串，通常是和符号表中的符号关联的字符串，类型为SHT_STRTAB。.dynsym，包含动态链接函数符号表和地址，没有地址的则为0，标志SHF_ALLOC，类型为SHT_DYNSYM。.fini，正常结束时要执行的析构程序，类型为SHT_PROGBITS。.got，全局偏移表(global offset table)，类型为SHT_PROGBITS。.hash，包含符号hash表，用于快速查找函数名的。标志SHF_ALLOC，类型为SHT_HASH。.init，程序运行或加载时初始化程序。类型为SHT_PROGBITS。.interp，该节内容是一个字符串，指定了程序链接器的路径名。如果文件中有一个可加载的segment包含该节，属性就包含SHF_ALLOC，否则不包含。类型为SHT_PROGBITS。.plt 过程链接表（Procedure Linkage Table），类型为SHT_PROGBITS。.rodata和.rodata1， 包含只读数据，组成不可写的段。标志SHF_ALLOC，类型为SHT_PROGBITS。.shstrtab，包含section的名字，真正的字符串存储在.shstrtab中，其他都是索引。类型为SHT_STRTAB。.strtab，包含字符串，通常是符号表中符号对应的变量名字和函数名。类型为SHT_STRTAB。.symtab，Symbol Table，符号表。包含了所有符号信息，包括变量、函数、定位、重定位符号定义和引用时需要的信息。符号表是一个数组，Index 0 第一个入口，它的含义是undefined symbol index， STN_UNDEF。.rela.dyn，包含了除PLT以外的 RELA 类型的动态库重定向信息。.rela.plt，包含了PLT中的 RELA 类型的动态库重定向信息.rela.text 代码重定位表.rela.data 数据重定位表.line，调试时的行号表，即源代码行号与编译后指令的对应表如果我们想自定义些Section，可以用__attribute__((section(“name”)))把相应的变量或函数放到“name”作为段名的段中，例如：__attribute__((section(\"GlobalTest\"))) int global = 42;__attribute__((section(\"FuncTest\"))) void foo(){}那么ELF结构在文件中是以怎样的形式存在的呢？下面是ELF文件的大致布局（来源ELF描述文档 http://www.skyfree.org/linux/references/ELF_Format.pdf）左边是ELF的链接视图，可以理解为是目标代码文件的内容布局。右边是ELF的执行视图，可以理解为可执行文件的内容布局。目标代码文件（编译过程中的.o文件）的内容是由Section组成的，而可执行文件（二进制可执行文件或库文件）的内容是由Segment段组成的。ELF header的定义可以在 /usr/include/elf.h 中找到。Elf32_Ehdr是32位 ELF header的结构体。Elf64_Ehdr是64位ELF header的结构体。    （Linker and Libraries Guide：https://docs.oracle.com/cd/E19120-01/open.solaris/819-0690/chapter6-43405/index.html）其中e_ident的前4个字节是魔数，魔数是固定的，它用来确认文件的类型，操作系统在加载可执行文件时会确认魔数是否正确，如果不正确则说明文件不是ELF格式，则拒绝加载。ELF的整体结构现在我们知道了，ELF Header描述了Program header table 和 Section header table，Program header table 又描述了Segment摘要，Section header table 又描述了Section摘要。那么 Program header table 和 Section header table 究竟是怎么去描述Segment和Section摘要的呢？前面我们说ELF Header里已经有了Program header table 和 Section header table的位置的偏移量，有了它们每个table的大小，以及有多少个table，我们就能知道Program header table 和 Section header table的起始地址、每个结构体的位置、以及它们的范围。也就是说，每个Program header table 和 Section header table是一个由固定大小结构体组成的数组，于是可以根据ELF Header来确定它们的数据内容和范围。我们来看下它们的结构体，Program header结构：Section header结构：这里特别从重要的几个Section中挑出几个特别重要的字段来重点说明下。重定位表任何需要重定位的Section都需要一个重定位表，例如.text需要.rel.text来辅助重定位.data需要.rel.data来辅助重定位.rela.dyn，用于动态重定位变量的表.rela.plt，则用于动态重定位函数的表重定位分为两种  一种是静态编译时重定位，在编译时重定位  另一种是动态加载时重定位，在执行时重定位重定位我们放后面详细介绍字符串表字符串主要用于匹配函数和变量名，但不同用途的字符串也会分开存放。.shstrtab，包含section名字的字符串存储在.shstrtab中.strtab，包含符号表中符号对应的变量名字和函数名的字符串.symtab，Symbol Table符号表，包含了所有符号信息，包括变量、函数、定位、重定位符号定义和引用时需要的信息，这里所有的字符串都只有索引指向.strtab中的内容。.dynstr，包含了动态链接用的字符串，通常是和符号表中的符号关联的字符串.hash，包含符号hash表，用于快速查找函数名和变量名字符串表中包含了存储字符串的表、存储索引的表、以及hash表，它们的用途分别是：  存储字符串的表目的是存储真实字符串数据  其他表有需要字符串的都用索引表示以节省内存  hash表则主要用于快速查找和比较字符串符号表符号表主要用于记录函数名、变量名和地址，例如：.symtab，Symbol Table符号表，包含了所有符号信息，包括变量、函数、定位、重定位符号定义和引用时需要的信息.dynsym，包含动态链接函数符号表和地址，没有地址的则为0这两者的区别是，symtab记录了所有符号，包括内部的和外部的函数和变量，而.dynsym则只包含了对外动态加载时需要提供的函数和变量，可以.dynsym是.symtab的阉割版。symtab的数据结构为typedef struct{  Elf32_Word st_name; // 符号名在符号表中的索引  Elf32_Addr st_value; // 符号相对应的值，是地址或者其他值  Elf32_Word st_size; // 符号大小，包含数据的符号，该值为占用大小  unsigned char st_info; // 符号类型和绑定信息  unsigned char st_other; // 无用，值为0  Elf32_Half st_shndx; // 符号所在段的索引} Elf32_Sym;函数签名规则前面说函数名就是符号名，会存储在符号表中，但C++中函数名常常会有相同的时候，因此编译器在编译时会对函数名进行处理，以区别不同范围内的函数。我们称这种改变符号名的机制为函数签名（Function Signature）。签名后的函数名，包含了函数名、它的参数类型、它所在的类和命名空间以及其他信息。签名规则每种编译器都不一样，GCC编译器的规则为，所有符号以“_Z”开头，对于嵌套的名字后面紧跟“N”，然后是各个名称空间和类的名字，每个名字前是名字字符串长度，再以“E”结尾，“E”后面是参数列表，对于int类型来说就是字母“i”，float类型来说就是字母“f”，以此类推。来举几个例子：* int func(int)  签名后--&gt; _Z4funci --&gt; _Z开头，4个字符的函数名func，参数是i整型* float func(float) 签名后--&gt; _Z4funcf --&gt; _Z开头，4个字符的函数名func，参数是f浮点型* int C::func(int) 签名后--&gt; _ZN1C4funcEi --&gt; _Z开头，嵌套1个字符C，接4个字符的函数名func，E结尾，参数是i整型* int C::C2::func(int) 签名后--&gt; _ZN1C2C24funcEi --&gt; _Z开头，嵌套1个字符C，再嵌套2个字符C2，接4个字符的函数名func，E结尾，参数是i整型* int N::func(int) 签名后--&gt; _ZN1N4funcEi --&gt; _Z开头，嵌套1个字符N，接4个字符函数名func，E结尾，参数是i整型* int N::C::func(int) 签名后--&gt; _ZN1N1C4funcEi --&gt; _Z开图，嵌套1个字符N，再嵌套1个字符C，接4个字符func，E结尾，参数是i整型由于不同编译器的签名规则不同，所以当我们要使用C语言写的外部函数时，就需要告诉编译器使用C语言的命名规则extern \"C\"{  int func(int);  int var;}如果我们在C++中没有使用extern “C”申明会如何？如果我们没有正确告知编译器外部引用函数的编译器规则，则在链接器链接时就会因为符号不匹配而无法链接，因此对于C++引用C函数来说，必须使用extern “C”来声明编译器规则。强符号弱符号，强引用弱引用通常我们定义的变量和函数都是强符号和强引用，意思是当符号冲突时会直接覆盖原来的符号，而弱符号和弱引用则是当符号冲突时不覆盖原来的。在编写通用库、共享库程序时，弱符号和弱引用，可以起到替换和被替换的作用。例如库中定义的弱符号被用户定义的强符号覆盖，从而使得程序可以使用自定义版本的库函数；或者扩展某个功能模块时，弱引用被新模块接口覆盖，从而使得程序可以在正常使用的情况下扩展功能。attribute((week)) week_var = 2;attribute((weekref)) void func();Linux提供了几个工具来帮助我们了解ELF格式内容  readelf，可以帮助我们读取ELF文件中Section的内容  objdump，可以帮助我们翻译二进制指令和数据  c++filt，可以帮助我们解析被修饰过的名称  编译时通过加 -g 参数，可以让编译器在产生目标文件时加上调试信息  strip，可以通过这个命令把ELF中的调试信息都去除静态链接静态链接的过程其实就是把目标文件中的数据归档到一个文件中，其归档步骤有两步。第一步，空间与地址分配扫描所有输入的目标文件，获取它们的各Section的数据，合并各段数据并建立映射关系。同时把所有目标文件中的符号和符号定义都收集起来放到全局符号表中。第二步，符号解析与重定位根据第一步收集到的信息，包括Section和符号表信息，进行符号解析与重定位，调整代码中的地址。在重定位时，由于各个符号的在Section内的位置是相对固定的，所以只要计算出Section的偏移量就可以知道合并后的符号实际位置。在第一步完成空间分配后，就可以确定所有符号的虚拟地址了，但这时目标文件内含有其他目标文件函数，则需要另外通过符号表来重定位。由于在完成空间分配后，全局符号表内的符号都确定了地址，因此在重定位时可以使用全局符号表中的地址替换未定位地址。每个目标文件都可能定义一些符号，也可能引用到定义在其他目标文件的符号。链接器在重定位的过程中，每个重定位的入口都是一个符号的引用，当需要对某个符号的引用进行重定位时，就要确定这个符号的目标地址。这时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位。注意：在未确定外部符号地址时，编译器把这部分地址暂时用“0x00000000”和“0xFFFFFFFC”来代替，在链接时再由链接器将计算好的地址填充进来。重定位表我们前面说过每个需要重定位的Section都有一个重定位表，例如“.text”有“.rel.text”，“.data”有“.rel.data”。每个重定位表里的数据为：typedef struct{  Elf32_Addr r_offset; // 相对于当前Section的相对位置  Elf32_Word r_info; // 低8位表示重定位入口类型，高24位表示重定位入口符号的索引}简单来说就是，重定位表数据中有一个需要重定位的位置和一个重定位的符号名字符串索引，有了这两个数据，链接器就能在链接时从全局符号表中找到合并后的真实虚拟地址。在符号地址修正时，也分绝对寻址修正和相对寻址修正，它们的区别是绝对寻址修正后的地址为该符号的实际虚拟地址，相对寻址修正后的地址为符号距离被修正位置的地址差，因此它们分别服务的是不同类型的指令。全局构造和析构表.init段中保存的初始化代码。当一个程序开始运行时在main函数调用之前Glibc的初始化程序会执行这个段中的代码。.fini段中保存的析构代码。当一个进程的main函数正常退出时Glibc会安排执行这个段中的代码。这两个段有特别的目的，.init在main函数前执行，.fini则在main函数后执行，利用这两个特性C++的全局构造和析构函数就由此实现。将不同编译器的编译结果链接那么有没有可能将不同编译器的编译结果链接成一个可执行文件呢？其实可以的，但非常困难。目标文件必须满足以下条件：  目标文件的数据格式兼容  符号签名规则兼容  变量的内存分布方式兼容  函数调用方式兼容  堆栈分布方式兼容  寄存器使用阅读兼容我们把这种链接时的兼容性相关内容称为ABI（Application Binary Interface）。与API不同的是，ABI是指二进制层面的接口兼容性更加严格，而API则只是源代码级别上的的接口。其实不同编译器链接成可执行文件的最大问题就是，各种硬件平台、编程语言、编译器、链接器和操作系统之间的ABI互不兼容。由于ABI的不兼容，导致各个目标文件之间无法互相链接。静态库与链接其实静态库可以简单看成一组目标文件的集合，在制作静态库时只是将所有目标文件打包压缩后归档为一个文件而已。Linux下可以使用“ar”这个工具命令来归档目标文件，“ar”压缩程序将所有目标文件压缩到一起并对其进行编号和索引，以便于查找和检索，就形成了xxx.a静态库文件。Visual C++也提供了类似ar的工具，叫lib.exe，这个程序可以用来创建、提取、查看.lib文件中的内容。在静态库链接时，Linux下的链接器ld会自动寻找需要的静态库，并从中解压出来目标文件，再最终将这些目标文件链接在一起成为可执行文件。从这个规则上看来，我们在编写静态库的时候，最好是每个函数独立存放在一个目标文件中，因此这样可以尽量减少空间浪费，因为没有被用到的目标文件就不会链接到最终的输出文件中。中间件BFD库我们说各种操作系统平台都遵循类似ELF格式的文件格式，虽然是相似的ELF格式但在不同软硬件平台都有着不同的变种。种种差异导致编译器和链接器很难处理不同平台之间的目标文件，因此最好有一种统一的接口来处理不同格式的文件。BFD库（Binary File Dexcriptor library）就是为了这个目的存在的，它的目标就是用一种统一接口来处理不同的目标文件格式。现在GCC编译器、链接器ld、调试器gdb、binutils等工具都是通过BFD库来处理文件，而不直接操作目标文件。这样做的好处是将编译器和链接器与具体的目标文件格式隔离开来，一旦我们需要支持一种新的目标文件格式，只需要在BFD库里添加一种格式就可以了，而不需要再去修改编译器和链接器。已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484763&amp;idx=1&amp;sn=f1b3d678c1309a66d44b64b7ff22a002&amp;chksm=fc22605ccb55e94a53558e85fdbe196fc58612fe20c88f35f8c0f4098e240ef48bcd2da099b0&amp;token=535520395&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h3 id=\"背景\">背景：</h3><p>看此书的起源是我在了解Linux注入技术的时候翻阅到的，由于注入技术需要用到很多ELF格式的内容，很多网络上的技术文章都指向了同一本书。也刚好周围的同事有此书，便翻阅了一下，这一番翻阅打开了我对程序世界的又一扇大门。</p><p>很快我就自己买了此书并阅读完成，整本书给我很大的震撼，让我对程序从编译到链接到装载有了更深刻的认识。</p><p>我把我的整个学习过程以及对书本的理解，用自己的语言和自己画的图表达出来，让读者能够更容易接受到我所学的知识。</p><h3 id=\"目标\">目标：</h3><p>了解编译过程</p><p>了解动态库和静态库的装载细节</p><p>了解可执行程序装载和执行过程</p><p>了解可执行文件和动态库的数据格式</p><h3 id=\"疑问\">疑问：</h3><p>c/c++编译器是如何将cpp编译为可执行文件的？</p><p>多个c/c++文件是如何编译成一个可执行文件的？</p><p>操作系统内存是如何初始化和管理的？</p><p>动态库和静态库的链接和装载过程是怎样的？</p><p>操作系统的用户态和内核态是如何运作的？</p><h3 id=\"正文\">正文：</h3><p>前文《链接、装载与库-回顾基础》说了计算机设备的架构，硬盘的存储方式，内存虚拟空间的意义，多线程调度和安全的本质，以及代码编译的整体流程。</p><p>我们平常用C++代码编译出来的可执行文件、静态库、动态库，看上去它们的不一样的东西，其实它们的数据格式是相同的。</p><p>现代流行的操作系统分Windows和Linux两种，因此我们主要介绍这两种平台下的文件格式。在Windows下的可执行文件格式称为PE（Portable Executable），在Linux下则称为ELF（Executable Linkable Format），其实它们都是COFF（Common file format）格式的变种。</p><p>不光是可执行文件，动态链接库（DLL，Dynamic Linking Library）和静态链接库（Static Linking Library）都是按照可执行文件格式存储的。</p><p>静态链接库稍有不同，它把很多目标文件捆绑在一起形成一个文件，可以简单把它理解为一个包含很多目标文件的文件包。</p><p>单个目标文件简单的结构介绍</p><pre><code class=\"language-c\">int global_init_var = 84; // 已初始化全局变量int global_uninit_var; // 未初始化全局变量//全局函数void func1( int i){    printf(\"%d\\n\",i);}//入口函数int main(void){    static int static_var = 85; // 已初始化静态变量    static int static_var2; // 未初始化静态变量    int a = 1; // 已初始化局部变量    int b; // 未初始化局部变量    func1(static_var + static_var2 + a + b); // 调用全局函数    return 0;}</code></pre><p>我们先以目标文件为例，来举一个简单的文件ELF结构。目标文件是最常见的编译单位，它将指令代码、数据以Section的形式存储在文件中。</p><p>上图中我们简单说明了程序、已初始化全局数据、未初始化全局数据在目标文件中的存放位置。其中.data段保存的是已初始化了的全局静态变量和局部静态变量，这些数据是可写可读的，而只读数据则存放在.rodata中，例如const修饰的变量和字符串常量。用.rodata单独保存只读数据能够更加好的保护数据，任何修改.rodata中的数据都会作为非法操作处理。</p><p>类似的Section段有很多，我们列举一些重要的来说：</p><pre><code class=\"language-c\">.bss：包含程序运行时未初始化的数据（全局变量和静态变量）。当程序运行时，这些数据初始化为0。.data和.data1，包含初始化的全局变量和静态变量。.dynamic，包含了动态链接的信息，包括链接器地址、需要的动态库、段地址信息，类型为SHT_DYNAMIC。.dynstr，包含了动态链接用的字符串，通常是和符号表中的符号关联的字符串，类型为SHT_STRTAB。.dynsym，包含动态链接函数符号表和地址，没有地址的则为0，标志SHF_ALLOC，类型为SHT_DYNSYM。.fini，正常结束时要执行的析构程序，类型为SHT_PROGBITS。.got，全局偏移表(global offset table)，类型为SHT_PROGBITS。.hash，包含符号hash表，用于快速查找函数名的。标志SHF_ALLOC，类型为SHT_HASH。.init，程序运行或加载时初始化程序。类型为SHT_PROGBITS。.interp，该节内容是一个字符串，指定了程序链接器的路径名。如果文件中有一个可加载的segment包含该节，属性就包含SHF_ALLOC，否则不包含。类型为SHT_PROGBITS。.plt 过程链接表（Procedure Linkage Table），类型为SHT_PROGBITS。.rodata和.rodata1， 包含只读数据，组成不可写的段。标志SHF_ALLOC，类型为SHT_PROGBITS。.shstrtab，包含section的名字，真正的字符串存储在.shstrtab中，其他都是索引。类型为SHT_STRTAB。.strtab，包含字符串，通常是符号表中符号对应的变量名字和函数名。类型为SHT_STRTAB。.symtab，Symbol Table，符号表。包含了所有符号信息，包括变量、函数、定位、重定位符号定义和引用时需要的信息。符号表是一个数组，Index 0 第一个入口，它的含义是undefined symbol index， STN_UNDEF。.rela.dyn，包含了除PLT以外的 RELA 类型的动态库重定向信息。.rela.plt，包含了PLT中的 RELA 类型的动态库重定向信息.rela.text 代码重定位表.rela.data 数据重定位表.line，调试时的行号表，即源代码行号与编译后指令的对应表</code></pre><p>如果我们想自定义些Section，可以用__attribute__((section(“name”)))把相应的变量或函数放到“name”作为段名的段中，例如：</p><pre><code class=\"language-c\">__attribute__((section(\"GlobalTest\"))) int global = 42;__attribute__((section(\"FuncTest\"))) void foo(){}</code></pre><p>那么ELF结构在文件中是以怎样的形式存在的呢？</p><h3 id=\"下面是elf文件的大致布局\">下面是ELF文件的大致布局</h3><p>（来源ELF描述文档 http://www.skyfree.org/linux/references/ELF_Format.pdf）</p><p>左边是ELF的链接视图，可以理解为是目标代码文件的内容布局。右边是ELF的执行视图，可以理解为可执行文件的内容布局。目标代码文件（编译过程中的.o文件）的内容是由Section组成的，而可执行文件（二进制可执行文件或库文件）的内容是由Segment段组成的。</p><p>ELF header的定义可以在 /usr/include/elf.h 中找到。Elf32_Ehdr是32位 ELF header的结构体。Elf64_Ehdr是64位ELF header的结构体。    （Linker and Libraries Guide：https://docs.oracle.com/cd/E19120-01/open.solaris/819-0690/chapter6-43405/index.html）</p><p>其中e_ident的前4个字节是魔数，魔数是固定的，它用来确认文件的类型，操作系统在加载可执行文件时会确认魔数是否正确，如果不正确则说明文件不是ELF格式，则拒绝加载。</p><h3 id=\"elf的整体结构\">ELF的整体结构</h3><p>现在我们知道了，ELF Header描述了Program header table 和 Section header table，Program header table 又描述了Segment摘要，Section header table 又描述了Section摘要。</p><h3 id=\"那么-program-header-table-和-section-header-table-究竟是怎么去描述segment和section摘要的呢\">那么 Program header table 和 Section header table 究竟是怎么去描述Segment和Section摘要的呢？</h3><p>前面我们说ELF Header里已经有了Program header table 和 Section header table的位置的偏移量，有了它们每个table的大小，以及有多少个table，我们就能知道Program header table 和 Section header table的起始地址、每个结构体的位置、以及它们的范围。</p><p>也就是说，每个Program header table 和 Section header table是一个由固定大小结构体组成的数组，于是可以根据ELF Header来确定它们的数据内容和范围。</p><p>我们来看下它们的结构体，Program header结构：</p><p>Section header结构：</p><p>这里特别从重要的几个Section中挑出几个特别重要的字段来重点说明下。</p><h3 id=\"重定位表\">重定位表</h3><p>任何需要重定位的Section都需要一个重定位表，例如</p><p>.text需要.rel.text来辅助重定位.data需要.rel.data来辅助重定位.rela.dyn，用于动态重定位变量的表.rela.plt，则用于动态重定位函数的表</p><p>重定位分为两种</p><ol>  <li>一种是静态编译时重定位，在编译时重定位</li>  <li>另一种是动态加载时重定位，在执行时重定位</li></ol><h3 id=\"重定位我们放后面详细介绍\">重定位我们放后面详细介绍</h3><h3 id=\"字符串表\">字符串表</h3><p>字符串主要用于匹配函数和变量名，但不同用途的字符串也会分开存放。</p><p>.shstrtab，包含section名字的字符串存储在.shstrtab中.strtab，包含符号表中符号对应的变量名字和函数名的字符串.symtab，Symbol Table符号表，包含了所有符号信息，包括变量、函数、定位、重定位符号定义和引用时需要的信息，这里所有的字符串都只有索引指向.strtab中的内容。.dynstr，包含了动态链接用的字符串，通常是和符号表中的符号关联的字符串.hash，包含符号hash表，用于快速查找函数名和变量名</p><p>字符串表中包含了存储字符串的表、存储索引的表、以及hash表，它们的用途分别是：</p><ol>  <li>存储字符串的表目的是存储真实字符串数据</li>  <li>其他表有需要字符串的都用索引表示以节省内存</li>  <li>hash表则主要用于快速查找和比较字符串</li></ol><h3 id=\"符号表\">符号表</h3><p>符号表主要用于记录函数名、变量名和地址，例如：</p><p>.symtab，Symbol Table符号表，包含了所有符号信息，包括变量、函数、定位、重定位符号定义和引用时需要的信息.dynsym，包含动态链接函数符号表和地址，没有地址的则为0</p><p>这两者的区别是，symtab记录了所有符号，包括内部的和外部的函数和变量，而.dynsym则只包含了对外动态加载时需要提供的函数和变量，可以.dynsym是.symtab的阉割版。</p><p>symtab的数据结构为</p><pre><code class=\"language-c\">typedef struct{  Elf32_Word st_name; // 符号名在符号表中的索引  Elf32_Addr st_value; // 符号相对应的值，是地址或者其他值  Elf32_Word st_size; // 符号大小，包含数据的符号，该值为占用大小  unsigned char st_info; // 符号类型和绑定信息  unsigned char st_other; // 无用，值为0  Elf32_Half st_shndx; // 符号所在段的索引} Elf32_Sym;</code></pre><h3 id=\"函数签名规则\">函数签名规则</h3><p>前面说函数名就是符号名，会存储在符号表中，但C++中函数名常常会有相同的时候，因此编译器在编译时会对函数名进行处理，以区别不同范围内的函数。</p><p>我们称这种改变符号名的机制为函数签名（Function Signature）。签名后的函数名，包含了函数名、它的参数类型、它所在的类和命名空间以及其他信息。</p><p>签名规则每种编译器都不一样，GCC编译器的规则为，所有符号以“_Z”开头，对于嵌套的名字后面紧跟“N”，然后是各个名称空间和类的名字，每个名字前是名字字符串长度，再以“E”结尾，“E”后面是参数列表，对于int类型来说就是字母“i”，float类型来说就是字母“f”，以此类推。</p><p>来举几个例子：</p><pre><code class=\"language-c\">* int func(int)  签名后--&gt; _Z4funci --&gt; _Z开头，4个字符的函数名func，参数是i整型* float func(float) 签名后--&gt; _Z4funcf --&gt; _Z开头，4个字符的函数名func，参数是f浮点型* int C::func(int) 签名后--&gt; _ZN1C4funcEi --&gt; _Z开头，嵌套1个字符C，接4个字符的函数名func，E结尾，参数是i整型* int C::C2::func(int) 签名后--&gt; _ZN1C2C24funcEi --&gt; _Z开头，嵌套1个字符C，再嵌套2个字符C2，接4个字符的函数名func，E结尾，参数是i整型* int N::func(int) 签名后--&gt; _ZN1N4funcEi --&gt; _Z开头，嵌套1个字符N，接4个字符函数名func，E结尾，参数是i整型* int N::C::func(int) 签名后--&gt; _ZN1N1C4funcEi --&gt; _Z开图，嵌套1个字符N，再嵌套1个字符C，接4个字符func，E结尾，参数是i整型</code></pre><p>由于不同编译器的签名规则不同，所以当我们要使用C语言写的外部函数时，就需要告诉编译器使用C语言的命名规则</p><pre><code>extern \"C\"{  int func(int);  int var;}</code></pre><p>如果我们在C++中没有使用extern “C”申明会如何？如果我们没有正确告知编译器外部引用函数的编译器规则，则在链接器链接时就会因为符号不匹配而无法链接，因此对于C++引用C函数来说，必须使用extern “C”来声明编译器规则。</p><h3 id=\"强符号弱符号强引用弱引用\">强符号弱符号，强引用弱引用</h3><p>通常我们定义的变量和函数都是强符号和强引用，意思是当符号冲突时会直接覆盖原来的符号，而弱符号和弱引用则是当符号冲突时不覆盖原来的。在编写通用库、共享库程序时，弱符号和弱引用，可以起到替换和被替换的作用。例如库中定义的弱符号被用户定义的强符号覆盖，从而使得程序可以使用自定义版本的库函数；或者扩展某个功能模块时，弱引用被新模块接口覆盖，从而使得程序可以在正常使用的情况下扩展功能。<strong>attribute</strong>((week)) week_var = 2;<strong>attribute</strong>((weekref)) void func();</p><p>Linux提供了几个工具来帮助我们了解ELF格式内容</p><ol>  <li>readelf，可以帮助我们读取ELF文件中Section的内容</li>  <li>objdump，可以帮助我们翻译二进制指令和数据</li>  <li>c++filt，可以帮助我们解析被修饰过的名称</li>  <li>编译时通过加 -g 参数，可以让编译器在产生目标文件时加上调试信息</li>  <li>strip，可以通过这个命令把ELF中的调试信息都去除</li></ol><h3 id=\"静态链接\">静态链接</h3><p>静态链接的过程其实就是把目标文件中的数据归档到一个文件中，其归档步骤有两步。</p><h3 id=\"第一步空间与地址分配\">第一步，空间与地址分配</h3><p>扫描所有输入的目标文件，获取它们的各Section的数据，合并各段数据并建立映射关系。同时把所有目标文件中的符号和符号定义都收集起来放到全局符号表中。</p><h3 id=\"第二步符号解析与重定位\">第二步，符号解析与重定位</h3><p>根据第一步收集到的信息，包括Section和符号表信息，进行符号解析与重定位，调整代码中的地址。</p><h3 id=\"在重定位时由于各个符号的在section内的位置是相对固定的所以只要计算出section的偏移量就可以知道合并后的符号实际位置\">在重定位时，由于各个符号的在Section内的位置是相对固定的，所以只要计算出Section的偏移量就可以知道合并后的符号实际位置。</h3><h3 id=\"在第一步完成空间分配后就可以确定所有符号的虚拟地址了但这时目标文件内含有其他目标文件函数则需要另外通过符号表来重定位\">在第一步完成空间分配后，就可以确定所有符号的虚拟地址了，但这时目标文件内含有其他目标文件函数，则需要另外通过符号表来重定位。</h3><h3 id=\"由于在完成空间分配后全局符号表内的符号都确定了地址因此在重定位时可以使用全局符号表中的地址替换未定位地址\">由于在完成空间分配后，全局符号表内的符号都确定了地址，因此在重定位时可以使用全局符号表中的地址替换未定位地址。</h3><p>每个目标文件都可能定义一些符号，也可能引用到定义在其他目标文件的符号。链接器在重定位的过程中，每个重定位的入口都是一个符号的引用，当需要对某个符号的引用进行重定位时，就要确定这个符号的目标地址。这时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位。</p><h3 id=\"注意在未确定外部符号地址时编译器把这部分地址暂时用0x00000000和0xfffffffc来代替在链接时再由链接器将计算好的地址填充进来\">注意：在未确定外部符号地址时，编译器把这部分地址暂时用“0x00000000”和“0xFFFFFFFC”来代替，在链接时再由链接器将计算好的地址填充进来。</h3><h3 id=\"重定位表-1\">重定位表</h3><p>我们前面说过每个需要重定位的Section都有一个重定位表，例如“.text”有“.rel.text”，“.data”有“.rel.data”。</p><p>每个重定位表里的数据为：</p><pre><code class=\"language-c\">typedef struct{  Elf32_Addr r_offset; // 相对于当前Section的相对位置  Elf32_Word r_info; // 低8位表示重定位入口类型，高24位表示重定位入口符号的索引}</code></pre><p>简单来说就是，重定位表数据中有一个需要重定位的位置和一个重定位的符号名字符串索引，有了这两个数据，链接器就能在链接时从全局符号表中找到合并后的真实虚拟地址。</p><p>在符号地址修正时，也分绝对寻址修正和相对寻址修正，它们的区别是绝对寻址修正后的地址为该符号的实际虚拟地址，相对寻址修正后的地址为符号距离被修正位置的地址差，因此它们分别服务的是不同类型的指令。</p><h3 id=\"全局构造和析构表\">全局构造和析构表</h3><p>.init段中保存的初始化代码。当一个程序开始运行时在main函数调用之前Glibc的初始化程序会执行这个段中的代码。.fini段中保存的析构代码。当一个进程的main函数正常退出时Glibc会安排执行这个段中的代码。这两个段有特别的目的，.init在main函数前执行，.fini则在main函数后执行，利用这两个特性C++的全局构造和析构函数就由此实现。</p><h3 id=\"将不同编译器的编译结果链接\">将不同编译器的编译结果链接</h3><p>那么有没有可能将不同编译器的编译结果链接成一个可执行文件呢？其实可以的，但非常困难。</p><p>目标文件必须满足以下条件：</p><ol>  <li>目标文件的数据格式兼容</li>  <li>符号签名规则兼容</li>  <li>变量的内存分布方式兼容</li>  <li>函数调用方式兼容</li>  <li>堆栈分布方式兼容</li>  <li>寄存器使用阅读兼容</li></ol><p>我们把这种链接时的兼容性相关内容称为ABI（Application Binary Interface）。与API不同的是，ABI是指二进制层面的接口兼容性更加严格，而API则只是源代码级别上的的接口。其实不同编译器链接成可执行文件的最大问题就是，各种硬件平台、编程语言、编译器、链接器和操作系统之间的ABI互不兼容。由于ABI的不兼容，导致各个目标文件之间无法互相链接。</p><h3 id=\"静态库与链接\">静态库与链接</h3><p>其实静态库可以简单看成一组目标文件的集合，在制作静态库时只是将所有目标文件打包压缩后归档为一个文件而已。</p><p>Linux下可以使用“ar”这个工具命令来归档目标文件，“ar”压缩程序将所有目标文件压缩到一起并对其进行编号和索引，以便于查找和检索，就形成了xxx.a静态库文件。Visual C++也提供了类似ar的工具，叫lib.exe，这个程序可以用来创建、提取、查看.lib文件中的内容。</p><p>在静态库链接时，Linux下的链接器ld会自动寻找需要的静态库，并从中解压出来目标文件，再最终将这些目标文件链接在一起成为可执行文件。</p><p>从这个规则上看来，我们在编写静态库的时候，最好是每个函数独立存放在一个目标文件中，因此这样可以尽量减少空间浪费，因为没有被用到的目标文件就不会链接到最终的输出文件中。</p><h3 id=\"中间件bfd库\">中间件BFD库</h3><p>我们说各种操作系统平台都遵循类似ELF格式的文件格式，虽然是相似的ELF格式但在不同软硬件平台都有着不同的变种。种种差异导致编译器和链接器很难处理不同平台之间的目标文件，因此最好有一种统一的接口来处理不同格式的文件。BFD库（Binary File Dexcriptor library）就是为了这个目的存在的，它的目标就是用一种统一接口来处理不同的目标文件格式。</p><p>现在GCC编译器、链接器ld、调试器gdb、binutils等工具都是通过BFD库来处理文件，而不直接操作目标文件。这样做的好处是将编译器和链接器与具体的目标文件格式隔离开来，一旦我们需要支持一种新的目标文件格式，只需要在BFD库里添加一种格式就可以了，而不需要再去修改编译器和链接器。</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484763&amp;idx=1&amp;sn=f1b3d678c1309a66d44b64b7ff22a002&amp;chksm=fc22605ccb55e94a53558e85fdbe196fc58612fe20c88f35f8c0f4098e240ef48bcd2da099b0&amp;token=535520395&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/06/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B029",
            
            
            
            "tags": ["读书笔记","前端技术"],
            
            "date_published": "2021-06-20T00:00:00+08:00",
            "date_modified": "2021-06-20T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/06/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B028",
            "title": "读书笔记(二十八) 《C++ Primer》#3",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意。第三是当我们在巩固时创造出了新的知识，那么这些新的知识和旧的知识将同时变成智慧融合到身体中。本系列基于《C++ Primer》学习，由于重点放在“重学”，我略过了滚瓜烂熟的部分，挑出以前常忽略的部分，以及记忆没有那么深刻的部分，特别是那些重要的但没有上心的部分。开始左值和右值这两个名词是从C语言继承过来的，原本是为了帮助记忆即：左值可以位于赋值语句的左侧，右值则不能。在C++语言中则没那么简单了，可以简单归纳为：当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。不同运算符对运算对象的要求不同，有的需要左值运算对象、有的则需要右值运算对象。因此有个重要原则：在需要右值的地方可以用左值来代替，但不能把右值当左值（也就是位置）使用。当一个左值被当成右值使用时，实际使用的是它的内容（就是值）。举几个例子：\t赋值运算符，是左值运算，因为结果是值（内容）\t取地址符，是右值运算，因为结果的是指针或地址\t解引用运算符、下标运算符，是左值运算，因为运算结果是值（内容）\t递增运算，是左值运算，因为运算结果是值（内容）关于后置++这里有个小提示，后置++版本会多浪费一个寄存器，但是编译器会帮我们优化掉，不过对于迭代器来说则不同，编译器通常不会优化迭代器的后置++，因此我们在使用迭代器后置++时要注意一下代码的优化。cout&lt;&lt; *iter++ &lt;&lt; endl;==&gt; 优化count&lt;&lt; *iter &lt;&lt; endl;++iter;sizeof运算符sizeof有离线计算和实时运算之分，通常情况下有些值在离线时就能知道的类型的大小，这时编译器都会在编译时就将其替换成固定值。举例说明sizeof运算符的结果取决于其作用类型：  对char类型表达式执行sizeof运算，结果为1。编译器离线计算  对引用类型执行sizeof，结果为被引用对象所占空间大小。编译器离线计算  对指针执行sizeof运算，结果为指针本身空间大小。编译器离线计算  对解引用指针执行sizeof，结果为指针指向的对象的空间大小。编译器离线计算  对数组执行sizeof运算，结果是整个数组所占空间大小。编译器离线计算  对string对象或vector对象执行sizeof运算，结果为该类型固定部分的大小。实时计算空间大小强制类型转换强制类型转换的根本目的就是告诉编译器，该变量的类型改变了，符合后面的逻辑运算，好让在编译器在编译时能够不误解逻辑运算，所以编译器并没有对内存内容做任何的改变，它只是为了迎合编译器。//旧式的强制类型转换type (expr); // 函数形式的强制类型转换(type) expr; // c语言风格的强制类型转换//新式的强制类型转换static_cast&lt;type&gt;(expression); // 静态转换dynamic_cast&lt;type&gt;(expression); // 运行时转换const_cast&lt;type&gt;(expression); // 常量转换reinterpret_cast&lt;type&gt;(expression); // 低阶类型转换强制转换分为，static_cast（静态转换），dynamic_cast（运行时转换），const_cast（常量转换），reinterpret_cast（低阶类型转换）4种  static_cast静态转换，直接将对象转换成指定类型对象。  dynamic_cast运行时转换，通常用于继承对象，运行时转换会先通过RTTI的方式判断是否能进行父子转换，如果可以再进行执行转换。  const_cast常量转换，只能改变运算对象的底层const无法改变具体类型，可以将const变量转换为非const变量，这样编译器就不再阻止我们对该对象进行写操作了。  reinterpret_cast低阶类型转换，通常为运算对象的位模式提供低层次上的解释。例如将int转换为char*等低阶模式。注意：使用reinterpret_cast比较危险的是，使用reinterpret_cast强制转换后编译器不会怀疑所转换的类型，如果类型错误则会因调用混乱而崩溃，而编译器在编译时不会发出任何警告或错误，因此reinterpret_cast通常适合比较底层转换工作。异常处理当异常被抛出时，首先在该函数中寻找匹配的catch子句，如果没有找到则终止该函数并在调用该函数的函数中继续寻找，以此类推沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。如果最终还是没能找到任何匹配的catch子句，程序会转到名为terminate的标准库函数中。该函数的行为与系统有关，一般情况下，执行该函数会导致程序非正常退出。如果当程序没有使用try catch语句且发生了异常，系统会直接调用terminate函数并终止当前程序的执行。分离式编译分离式编译的意思就是，多个源文件在编译中可以只顾自己编译，最后再统一链接到执行文件或库文件中。在分离式编译中，如果我们修改了其中一个源文件，那么只需要重新编译那个改动了的文件，再重新链接就可以。现代大多数编译器提供了分离式编译每个文件的机制，这一过程通常会产生一个后缀名是.obj（windows）或.o(UNIX)的目标文件，再用链接器将所有目标文件链接成可执行文件或库文件。参数传递解释下，实参就是要传递的数据变量，形参就是传递后函数中的参数变量。参数传递分引用传递和值传递  引用传递，通过传递引用的方式避免了对象拷贝。  值传递，则都是通过拷贝对象传递数据的。其中指针形参也是值传递，只不过传递时拷贝的是指针数据而非具体对象。函数设置参数时，我们要注意尽量使用const常量引用或指针作为形参，因为这样既避免了对象拷贝，又可以限制对象的修改。可变形参使用initializer_list类型的形参可以做到传递可变数量的实参。和Vector不一样的是，initializer_list中的元素永远都是常量值。举个例子：void test_func(initializer_list&lt;string&gt; li){  for(auto beg = li.begin(); beg != li.end() ; ++beg)      cout&lt;&lt; *beg &lt;&lt; \" \";}test_func(\"1\",\"3\",\"4\");test_func(\"2\",\"3\");test_func(\"2\",\"4\",\"6\",\"8\",\"10\");值返回和引用返回与值传递和引用传一样，在函数返回时，我们也需要注意拷贝操作。例如字符串拼接后的返回值就会造成对象拷贝的消耗：string test_func(string &amp;a, string &amp;b){   return a + b;}为了避免拷贝我们会使用引用返回或指针，但要注意，使用引用返回或指针时如果返回的是局部对象则会引起内存使用错误。string &amp;test_func(){   string test = \"test\";   return test; // 错误的返回了局部变量，导致内存使用错误}函数重载函数重载的特点是函数名字相同参数列表不同且在同一个作用域。在重载函数调用时，可能与我们想象的不同，其实编译器在离线时就区分了不同重载函数的调用地址。当调用重载函数时，编译器会根据传递的实参类型去比较每个重载函数的参数直到匹配成功或失败。我们知道虽然重载函数名字相同，但参数列表不同，这导致函数签名时的实际名字是不同，也就相当于调用的是不同名字的函数。举例说明重载函数的函数签名后命名不同：int func(int); //  函数签名后--&gt; _Z4funci int func(float); // 函数签名后--&gt; _Z4funcffunc(3); // -&gt; 匹配 _Z4funcifunc(3.5F); // -&gt; 匹配 _Z4funcf重载函数的匹配过程为：  收集所有重载函数  比较实参与所有重载函数的形参，寻找最佳匹配函数  匹配规则为精准匹配和转换匹配两种，精准匹配要求实参与形参高度一致，转换则可以通过const转换、类型提升、算术类型转换来实现匹配。  匹配成功后替换为匹配函数的函数签名至于函数签名的规则，其实每种编译器都不同，不过也是大同小异的。例如上述我们举例代码中的GCC编译器的规则为：  所有符号以“_Z”开头，  对于嵌套的名字后面紧跟“N”，  然后紧跟各个名称空间和类的名字，每个名字前是名字字符串长度，  再以“E”结尾，“E”后面是所有参数，  参数以简写代替，例如对于int类型来说就是字母“i”，float类型来说就是字母“f”，以此类推。内联函数我们知道函数在调用时会先保存当前寄存器、拷贝实参值、并在返回时拷贝恢复，这些都是函数调用的消耗。内联函数则可以避免函数调用的消耗，其原理是就地展开函数，这样能省去了函数调用前和后的一系列操作。我们可以通过内联关键字inline告诉编译器该函数需要在编译器时展开，但这也只是向编译器发出请求而已，如果编译器认为该内敛展开后性价比不高可以选择忽略这个请求。常量表达函数constexpr，我们可以通过constrexpr定义常量表达式的函数，与普通内联函数不同的是，编译器会把constexpr函数的调用替换成实际结果，简单来说就是离线计算好结果并替换调用函数。对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致，基于这个原因，内联函数和constexpr函数通常定义在头文件中。调试辅助指令assert是常见的调试工具，它其实是一个预处理宏，通过判断表达式来终止程序执行。assert的行为依赖于一个名为NDEBUG的预处理变量。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，我们可以使用#define来定义NDEBUG从而关闭调试状态，或者使用编译器的预处理指令cc -D NDEBUG main.c除了assert，C++编译器还定义了多个帮助我们调试的变量，例如：  func，存放的是当前函数名字  FILE，存放的是当前文件名  LINE，存放的是当前代码行号  TIME，存放的是当前文件编译时间  DATA，存放的是当前文件编译日期函数指针函数指针指向的是函数地址，它的类型由它的返回值类型、形参类型共同决定，编译器会检查函数类型与函数指针类型之间的一致性。bool (*point_func)(const string &amp;, const string &amp;);// point_func前面有个*，因此point_func是指针，这里括号不能少。// point_func右侧是形参列表，表示point_func指向的是，两个const string引用为参数、并且返回值是bool的函数类型。bool lenCompare(const string &amp;, const string &amp;);point_func = lenCompare; //指向lenComparepoint_func = &amp;lenCompare; //等价于赋值在指向不同函数类型的指针间不存在转换规则，也就是说，不同类型函数之间无法转换，即我们无法将一个类型函数转换到另一个类型函数指针。在将函数指针用于形参、返回值、重载函数时，都必须遵循函数类型与函数指针一致性的原则，编译器不会自动将函数类型转换成我们想要的类型，因为转换是不允许的。已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484764&amp;idx=1&amp;sn=edc0beab7722d092571c8f88a9a38bd6&amp;chksm=fc22605bcb55e94d95e3445b7449c42f87450a2fcc8dd16d63f44a242b17e63b6f5051e91dcd&amp;token=535520395&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h3 id=\"背景\">背景：</h3><p>我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意。第三是当我们在巩固时创造出了新的知识，那么这些新的知识和旧的知识将同时变成智慧融合到身体中。</p><p>本系列基于《C++ Primer》学习，由于重点放在“重学”，我略过了滚瓜烂熟的部分，挑出以前常忽略的部分，以及记忆没有那么深刻的部分，特别是那些重要的但没有上心的部分。</p><h3 id=\"开始\">开始</h3><h3 id=\"左值和右值\">左值和右值</h3><p>这两个名词是从C语言继承过来的，原本是为了帮助记忆即：左值可以位于赋值语句的左侧，右值则不能。在C++语言中则没那么简单了，可以简单归纳为：当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。</p><p>不同运算符对运算对象的要求不同，有的需要左值运算对象、有的则需要右值运算对象。因此有个重要原则：在需要右值的地方可以用左值来代替，但不能把右值当左值（也就是位置）使用。当一个左值被当成右值使用时，实际使用的是它的内容（就是值）。</p><p>举几个例子：\t赋值运算符，是左值运算，因为结果是值（内容）\t取地址符，是右值运算，因为结果的是指针或地址\t解引用运算符、下标运算符，是左值运算，因为运算结果是值（内容）\t递增运算，是左值运算，因为运算结果是值（内容）</p><h3 id=\"关于后置\">关于后置++</h3><p>这里有个小提示，后置++版本会多浪费一个寄存器，但是编译器会帮我们优化掉，不过对于迭代器来说则不同，编译器通常不会优化迭代器的后置++，因此我们在使用迭代器后置++时要注意一下代码的优化。</p><pre><code class=\"language-C\">cout&lt;&lt; *iter++ &lt;&lt; endl;==&gt; 优化count&lt;&lt; *iter &lt;&lt; endl;++iter;</code></pre><h3 id=\"sizeof运算符\">sizeof运算符</h3><p>sizeof有离线计算和实时运算之分，通常情况下有些值在离线时就能知道的类型的大小，这时编译器都会在编译时就将其替换成固定值。</p><p>举例说明sizeof运算符的结果取决于其作用类型：</p><ul>  <li>对char类型表达式执行sizeof运算，结果为1。编译器离线计算</li>  <li>对引用类型执行sizeof，结果为被引用对象所占空间大小。编译器离线计算</li>  <li>对指针执行sizeof运算，结果为指针本身空间大小。编译器离线计算</li>  <li>对解引用指针执行sizeof，结果为指针指向的对象的空间大小。编译器离线计算</li>  <li>对数组执行sizeof运算，结果是整个数组所占空间大小。编译器离线计算</li>  <li>对string对象或vector对象执行sizeof运算，结果为该类型固定部分的大小。实时计算空间大小</li></ul><h3 id=\"强制类型转换\">强制类型转换</h3><p>强制类型转换的根本目的就是告诉编译器，该变量的类型改变了，符合后面的逻辑运算，好让在编译器在编译时能够不误解逻辑运算，所以编译器并没有对内存内容做任何的改变，它只是为了迎合编译器。</p><pre><code class=\"language-C\">//旧式的强制类型转换type (expr); // 函数形式的强制类型转换(type) expr; // c语言风格的强制类型转换//新式的强制类型转换static_cast&lt;type&gt;(expression); // 静态转换dynamic_cast&lt;type&gt;(expression); // 运行时转换const_cast&lt;type&gt;(expression); // 常量转换reinterpret_cast&lt;type&gt;(expression); // 低阶类型转换</code></pre><h3 id=\"强制转换分为static_cast静态转换dynamic_cast运行时转换const_cast常量转换reinterpret_cast低阶类型转换4种\">强制转换分为，static_cast（静态转换），dynamic_cast（运行时转换），const_cast（常量转换），reinterpret_cast（低阶类型转换）4种</h3><ul>  <li>static_cast静态转换，直接将对象转换成指定类型对象。</li>  <li>dynamic_cast运行时转换，通常用于继承对象，运行时转换会先通过RTTI的方式判断是否能进行父子转换，如果可以再进行执行转换。</li>  <li>const_cast常量转换，只能改变运算对象的底层const无法改变具体类型，可以将const变量转换为非const变量，这样编译器就不再阻止我们对该对象进行写操作了。</li>  <li>reinterpret_cast低阶类型转换，通常为运算对象的位模式提供低层次上的解释。例如将int转换为char*等低阶模式。</li></ul><h3 id=\"注意使用reinterpret_cast比较危险的是使用reinterpret_cast强制转换后编译器不会怀疑所转换的类型如果类型错误则会因调用混乱而崩溃而编译器在编译时不会发出任何警告或错误因此reinterpret_cast通常适合比较底层转换工作\">注意：使用reinterpret_cast比较危险的是，使用reinterpret_cast强制转换后编译器不会怀疑所转换的类型，如果类型错误则会因调用混乱而崩溃，而编译器在编译时不会发出任何警告或错误，因此reinterpret_cast通常适合比较底层转换工作。</h3><h3 id=\"异常处理\">异常处理</h3><p>当异常被抛出时，首先在该函数中寻找匹配的catch子句，如果没有找到则终止该函数并在调用该函数的函数中继续寻找，以此类推沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。如果最终还是没能找到任何匹配的catch子句，程序会转到名为terminate的标准库函数中。该函数的行为与系统有关，一般情况下，执行该函数会导致程序非正常退出。如果当程序没有使用try catch语句且发生了异常，系统会直接调用terminate函数并终止当前程序的执行。</p><h3 id=\"分离式编译\">分离式编译</h3><p>分离式编译的意思就是，多个源文件在编译中可以只顾自己编译，最后再统一链接到执行文件或库文件中。</p><p>在分离式编译中，如果我们修改了其中一个源文件，那么只需要重新编译那个改动了的文件，再重新链接就可以。现代大多数编译器提供了分离式编译每个文件的机制，这一过程通常会产生一个后缀名是.obj（windows）或.o(UNIX)的目标文件，再用链接器将所有目标文件链接成可执行文件或库文件。</p><h3 id=\"参数传递\">参数传递</h3><p>解释下，实参就是要传递的数据变量，形参就是传递后函数中的参数变量。</p><p>参数传递分引用传递和值传递</p><ul>  <li>引用传递，通过传递引用的方式避免了对象拷贝。</li>  <li>值传递，则都是通过拷贝对象传递数据的。其中指针形参也是值传递，只不过传递时拷贝的是指针数据而非具体对象。</li></ul><p>函数设置参数时，我们要注意尽量使用const常量引用或指针作为形参，因为这样既避免了对象拷贝，又可以限制对象的修改。</p><h3 id=\"可变形参\">可变形参</h3><p>使用initializer_list类型的形参可以做到传递可变数量的实参。和Vector不一样的是，initializer_list中的元素永远都是常量值。</p><p>举个例子：</p><pre><code class=\"language-C\">void test_func(initializer_list&lt;string&gt; li){  for(auto beg = li.begin(); beg != li.end() ; ++beg)      cout&lt;&lt; *beg &lt;&lt; \" \";}test_func(\"1\",\"3\",\"4\");test_func(\"2\",\"3\");test_func(\"2\",\"4\",\"6\",\"8\",\"10\");</code></pre><h3 id=\"值返回和引用返回\">值返回和引用返回</h3><p>与值传递和引用传一样，在函数返回时，我们也需要注意拷贝操作。</p><p>例如字符串拼接后的返回值就会造成对象拷贝的消耗：</p><pre><code class=\"language-C\">string test_func(string &amp;a, string &amp;b){   return a + b;}</code></pre><p>为了避免拷贝我们会使用引用返回或指针，但要注意，使用引用返回或指针时如果返回的是局部对象则会引起内存使用错误。</p><pre><code class=\"language-C\">string &amp;test_func(){   string test = \"test\";   return test; // 错误的返回了局部变量，导致内存使用错误}</code></pre><h3 id=\"函数重载\">函数重载</h3><p>函数重载的特点是函数名字相同参数列表不同且在同一个作用域。</p><p>在重载函数调用时，可能与我们想象的不同，其实编译器在离线时就区分了不同重载函数的调用地址。当调用重载函数时，编译器会根据传递的实参类型去比较每个重载函数的参数直到匹配成功或失败。我们知道虽然重载函数名字相同，但参数列表不同，这导致函数签名时的实际名字是不同，也就相当于调用的是不同名字的函数。</p><p>举例说明重载函数的函数签名后命名不同：</p><pre><code class=\"language-C\">int func(int); //  函数签名后--&gt; _Z4funci int func(float); // 函数签名后--&gt; _Z4funcffunc(3); // -&gt; 匹配 _Z4funcifunc(3.5F); // -&gt; 匹配 _Z4funcf</code></pre><p>重载函数的匹配过程为：</p><ol>  <li>收集所有重载函数</li>  <li>比较实参与所有重载函数的形参，寻找最佳匹配函数</li>  <li>匹配规则为精准匹配和转换匹配两种，精准匹配要求实参与形参高度一致，转换则可以通过const转换、类型提升、算术类型转换来实现匹配。</li>  <li>匹配成功后替换为匹配函数的函数签名</li></ol><p>至于函数签名的规则，其实每种编译器都不同，不过也是大同小异的。例如上述我们举例代码中的GCC编译器的规则为：</p><ul>  <li>所有符号以“_Z”开头，</li>  <li>对于嵌套的名字后面紧跟“N”，</li>  <li>然后紧跟各个名称空间和类的名字，每个名字前是名字字符串长度，</li>  <li>再以“E”结尾，“E”后面是所有参数，</li>  <li>参数以简写代替，例如对于int类型来说就是字母“i”，float类型来说就是字母“f”，以此类推。</li></ul><h3 id=\"内联函数\">内联函数</h3><p>我们知道函数在调用时会先保存当前寄存器、拷贝实参值、并在返回时拷贝恢复，这些都是函数调用的消耗。</p><p>内联函数则可以避免函数调用的消耗，其原理是就地展开函数，这样能省去了函数调用前和后的一系列操作。我们可以通过内联关键字inline告诉编译器该函数需要在编译器时展开，但这也只是向编译器发出请求而已，如果编译器认为该内敛展开后性价比不高可以选择忽略这个请求。</p><p>常量表达函数constexpr，我们可以通过constrexpr定义常量表达式的函数，与普通内联函数不同的是，编译器会把constexpr函数的调用替换成实际结果，简单来说就是离线计算好结果并替换调用函数。</p><p>对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致，基于这个原因，内联函数和constexpr函数通常定义在头文件中。</p><h3 id=\"调试辅助指令\">调试辅助指令</h3><p>assert是常见的调试工具，它其实是一个预处理宏，通过判断表达式来终止程序执行。</p><p>assert的行为依赖于一个名为NDEBUG的预处理变量。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，我们可以使用#define来定义NDEBUG从而关闭调试状态，或者使用编译器的预处理指令cc -D NDEBUG main.c</p><p>除了assert，C++编译器还定义了多个帮助我们调试的变量，例如：</p><ul>  <li><strong>func</strong>，存放的是当前函数名字</li>  <li><strong>FILE</strong>，存放的是当前文件名</li>  <li><strong>LINE</strong>，存放的是当前代码行号</li>  <li><strong>TIME</strong>，存放的是当前文件编译时间</li>  <li><strong>DATA</strong>，存放的是当前文件编译日期</li></ul><h3 id=\"函数指针\">函数指针</h3><p>函数指针指向的是函数地址，它的类型由它的返回值类型、形参类型共同决定，编译器会检查函数类型与函数指针类型之间的一致性。</p><pre><code class=\"language-C\">bool (*point_func)(const string &amp;, const string &amp;);// point_func前面有个*，因此point_func是指针，这里括号不能少。// point_func右侧是形参列表，表示point_func指向的是，两个const string引用为参数、并且返回值是bool的函数类型。bool lenCompare(const string &amp;, const string &amp;);point_func = lenCompare; //指向lenComparepoint_func = &amp;lenCompare; //等价于赋值</code></pre><p>在指向不同函数类型的指针间不存在转换规则，也就是说，不同类型函数之间无法转换，即我们无法将一个类型函数转换到另一个类型函数指针。</p><p>在将函数指针用于形参、返回值、重载函数时，都必须遵循函数类型与函数指针一致性的原则，编译器不会自动将函数类型转换成我们想要的类型，因为转换是不允许的。</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484764&amp;idx=1&amp;sn=edc0beab7722d092571c8f88a9a38bd6&amp;chksm=fc22605bcb55e94d95e3445b7449c42f87450a2fcc8dd16d63f44a242b17e63b6f5051e91dcd&amp;token=535520395&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/06/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B028",
            
            
            
            "tags": ["读书笔记","前端技术"],
            
            "date_published": "2021-06-19T00:00:00+08:00",
            "date_modified": "2021-06-19T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/06/16/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A113",
            "title": "给女儿的信(十三) 要赢的是自己",
            "summary": "女儿 教育 亲情",
            "content_text": "Sharon，Anne，爸爸回到深圳了，很想你们哟。这里的天气和杭州一样暖，只是这里没有太多的雨。爸爸又回到了公司开始工作了。想起在家里和你们一起的这几天，爸爸很开心哟，爸爸喜欢和你们一起玩、一起学习。还记得Sharon跟爸爸一起玩拼图游戏的时候吗，Sharon老想着要和爸爸比谁快。爸爸跟你说，不要总想着和别人比，要和自己比。Sharon疑惑的问爸爸，什么是跟自己比。爸爸跟你说，爸爸以前也总是和别人比，但是和别人比总会让爸爸很紧张发挥不出真正的实力，因为爸爸总想赢，太着急了太在意了赢得也不轻松，输了就会很失落。所以当爸爸想着和别人比的时候，情绪波动很大，特别遇到比自己厉害很多的人时心情就更低落了。爸爸后来不和别人比了，因为这样太不好了，转而和自己比。怎么比呢，例如，去年我能看多少本书，今年我就比去年多看几本书。去年我能认识多少字，今年我就比去年的我多认识一些。每天坚持积累一些些，今天的我比昨天的我进步一些些，每天都在跟昨天的自己比，跟过去的自己比，我每次都能战胜过去的自己，我就像是不断战胜自己的勇士那样，充满了斗志。即使这样爸爸有时候也还是会陷入到和别人比较的陷进中去，但爸爸慢慢习惯和自己比赛后，挣脱出这种困境就越来越容易了。由于每天积累看书，帮助爸爸建立起了丰富的知识，让爸爸在工作和生活当中更加轻松自如哟。Sharon、Anne要和爸爸一起加油哟。爱你们。",
            "content_html": "<p>Sharon，Anne，爸爸回到深圳了，很想你们哟。</p><p>这里的天气和杭州一样暖，只是这里没有太多的雨。爸爸又回到了公司开始工作了。</p><p>想起在家里和你们一起的这几天，爸爸很开心哟，爸爸喜欢和你们一起玩、一起学习。</p><p>还记得Sharon跟爸爸一起玩拼图游戏的时候吗，Sharon老想着要和爸爸比谁快。</p><p>爸爸跟你说，不要总想着和别人比，要和自己比。</p><p>Sharon疑惑的问爸爸，什么是跟自己比。</p><p>爸爸跟你说，爸爸以前也总是和别人比，但是和别人比总会让爸爸很紧张发挥不出真正的实力，因为爸爸总想赢，太着急了太在意了赢得也不轻松，输了就会很失落。</p><p>所以当爸爸想着和别人比的时候，情绪波动很大，特别遇到比自己厉害很多的人时心情就更低落了。</p><p>爸爸后来不和别人比了，因为这样太不好了，转而和自己比。</p><p>怎么比呢，例如，去年我能看多少本书，今年我就比去年多看几本书。</p><p>去年我能认识多少字，今年我就比去年的我多认识一些。</p><p>每天坚持积累一些些，今天的我比昨天的我进步一些些，每天都在跟昨天的自己比，跟过去的自己比，我每次都能战胜过去的自己，我就像是不断战胜自己的勇士那样，充满了斗志。</p><p>即使这样爸爸有时候也还是会陷入到和别人比较的陷进中去，但爸爸慢慢习惯和自己比赛后，挣脱出这种困境就越来越容易了。</p><p>由于每天积累看书，帮助爸爸建立起了丰富的知识，让爸爸在工作和生活当中更加轻松自如哟。</p><p>Sharon、Anne要和爸爸一起加油哟。爱你们。</p>",
            "url": "http://www.luzexi.com/2021/06/16/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A113",
            
            
            
            
            
            "date_published": "2021-06-16T00:00:00+08:00",
            "date_modified": "2021-06-16T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/06/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B027",
            "title": "读书笔记(二十七) 《装载、链接与库》#1 回顾基础",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：看此书的起源是我在了解Linux注入技术的时候翻阅到的，由于注入技术需要用到很多ELF格式的内容，很多网络上的技术文章都指向了同一本书。也刚好周围的同事有此书，便翻阅了一下，这一番翻阅打开了我对程序世界的又一扇大门。很快我就自己买了此书并阅读完成，整本书给我很大的震撼，让我对程序从编译到链接到装载有了更深刻的认识。为了能更好的巩固知识，我把我的整个学习过程以及对书本的理解，用自己的语言和自己画的图表达出来，让读者能够很好的接受到我所学的知识。目标：了解编译过程了解动态库和静态库的装载细节了解可执行程序装载和执行过程了解可执行文件和动态库的数据格式疑问：c/c++编译器是如何将cpp编译为可执行文件的？多个c/c++文件是如何编译成一个可执行文件的？操作系统内存是如何初始化和管理的？动态库和静态库的链接和装载过程是怎样的？操作系统的用户态和内核态是如何运作的？正文：已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484732&amp;idx=1&amp;sn=e53f438b8815df3840208d7caa36f4f7&amp;chksm=fc22603bcb55e92debcabe242e42139c805b56addbc5993c1f521e967806f5bb76d62b0bb612&amp;token=890029854&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h2 id=\"背景\">背景：</h2><p>看此书的起源是我在了解Linux注入技术的时候翻阅到的，由于注入技术需要用到很多ELF格式的内容，很多网络上的技术文章都指向了同一本书。也刚好周围的同事有此书，便翻阅了一下，这一番翻阅打开了我对程序世界的又一扇大门。</p><p>很快我就自己买了此书并阅读完成，整本书给我很大的震撼，让我对程序从编译到链接到装载有了更深刻的认识。</p><p>为了能更好的巩固知识，我把我的整个学习过程以及对书本的理解，用自己的语言和自己画的图表达出来，让读者能够很好的接受到我所学的知识。</p><h2 id=\"目标\">目标：</h2><p>了解编译过程</p><p>了解动态库和静态库的装载细节</p><p>了解可执行程序装载和执行过程</p><p>了解可执行文件和动态库的数据格式</p><h2 id=\"疑问\">疑问：</h2><p>c/c++编译器是如何将cpp编译为可执行文件的？</p><p>多个c/c++文件是如何编译成一个可执行文件的？</p><p>操作系统内存是如何初始化和管理的？</p><p>动态库和静态库的链接和装载过程是怎样的？</p><p>操作系统的用户态和内核态是如何运作的？</p><h2 id=\"正文\">正文：</h2><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484732&amp;idx=1&amp;sn=e53f438b8815df3840208d7caa36f4f7&amp;chksm=fc22603bcb55e92debcabe242e42139c805b56addbc5993c1f521e967806f5bb76d62b0bb612&amp;token=890029854&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/06/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B027",
            
            
            
            "tags": ["读书笔记","前端技术"],
            
            "date_published": "2021-06-14T00:00:00+08:00",
            "date_modified": "2021-06-14T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/06/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B026",
            "title": "读书笔记(二十六) 《C++ Primer》#2",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意。第三是当我们在巩固时创造出了新的知识，那么这些新的知识和旧的知识将同时变成智慧融合到身体中。本系列基于《C++ Primer》学习，由于重点放在“重学”，我略过了滚瓜烂熟的部分挑出以前常忽略的部分，以及记忆没有那么深刻的部分，特别是那些重要的但没有上心的部分。开始1.const限定关键字const对变量的类型加以限定，因此它的值在初始化后不能被改变。const默认情况下只在文件内生效，当需要支持多个文件共享时，则使用extern关键字，不管定义和声明都添加extern关键字，并且只需要定义一次。//a.cppextern const int test_constVar = fcn();//b.cppextern const int test_constVar;通过添加extern共享const变量。const引用（常量引用）与普通引用不同的是，常量引用不能被用作它修改它所绑定的对象。const int ci = 10;const int &amp;r1 = ci;r1 = 40; //错误，常量引用不能修改绑定对象int &amp;r2 = ci; //错误，普通引用无法赋值常量严格来说，并不存在常量引用。因为引用不是一个对象，所以我们没法让引用本身恒定不变。事实上，由于c++语言并不允许随意改变引用所绑定的对象，所以从这层意义上理解所有的引用又都算是常量。引用的对象是常量还是非常量可以决定其所能参与的操作，却无论如何都不会影响到引用和对象的绑定关系。简单来说，由于绑定对象无法改变，所以要求引用对象也不能改变。但const引用可以绑定一个非const对象，其意义为，绑定后const引用无法改变，只能由所绑定的对象来决定内容。const指针（常量指针）const指针与const引用有同样的规则。const指针在初始化后无法改变，const指针不能改变所指对象的值，但可以指向非常量变量。当指向非常量时，const指针所指向的对象的值，只能由对象本身来决定。C++11中，用constexpr来表示常量表达式，声明为constexpr的变量是一个常量，编译器会验证变量的值是否为常量表达式并离线计算该值。constexpr int mf = 20 + 1; //离线计算constexpr int limit = mf + 1; //离线计算constexpr int sz = size(); // size()必须是constexpr函数2.类型别名类型别名是某种类型的同义词。使用类型别名是为了让复杂的类型名字变得简单明了、易于理解和使用。C++11新标准中，使用using来定义类型的别名typedef double wages; //wages是double的同义词typedef wages base, *p; //base是double的同义词，并且p是double*的同义词typedef char *pstring; //pstring 是char*的同义词using It = Item_test; // It 是Item_test的同义词//定义wages test1; //定义double 变量It item; //定义Item_test 变量pstring cstr = 0; //定义一个char *3.其他auto和decltype都是用来让编译器在离线下自动识别类型的关键字。其中decltype着重识别结果类型与表达式的关系。预处理器能确保头文件多次包含仍能安全工作，它在编译之前被执行。 #include、#define、#ifdef、#ifndef都是预处理关键字。第3章1.string字符串类前面说using可以用于类型别名，using也可以用于声明命名空间。using namespace::name不过头文件中不应包含using声明，因为这会导致头文件在被拷贝时多次重复声明using。string是标准库中的类对象。string在使用中最容易发生的问题就是拷贝。特别是等号(=、+)引起的合并和拷贝需要注意。string在比较时(==、!=、&lt;、&lt;=、&gt;、&gt;=)有比较算法但每个字符都会比较。严格来说string对象不属于容器类型，但string支持很多与容器类似的操作，比如下标、迭代器等。2.vector动态数组vector是标准中的动态数组模版库。模版本身不是类或函数，可以把模版看成编译器生成的类或函数。编译器根据模版创建类或函数的过程称为实例化。因此使用模版时，我们要指出编译器应把类或函数实例化成何种类型。因此vector是模版而非类型，由vector生成的类才叫类型。vector容器本身就是对象，因此也能通过拷贝初始化。vector&lt;int&gt; v1 = {1,2,3}; // 初始化3个元素，1、2、3vector&lt;int&gt; v2(10,-1); // 初始化10个元素，都是-1vector&lt;int&gt; v3 = v1; // 用拷贝来初始化，将v1中的数据拷贝到v3，完成后v3拥有独立的数据vector&lt;int&gt; v4(20); // 提前预备20个值，每个值都是0由于vector是动态数组，因此如果能在初始化时提前告知vector的话，vector就不用扩容了，运行时性能会更好。3.迭代器迭代器有三种不同含意，一是迭代器概念本身，二是容器定义的迭代器类型，三是指某个迭代器对象。有时她跟指针很像，但又完全不一样。其实迭代器是个由模版封装过的类，根据不同的类型的容器，编译器生成功能相似但命名不同的类。迭代器又重写了==、&gt;、&lt;、!=、&lt;=、&gt;=、+=、-=运算符，使得我们在编写代码时更加方便。共识：当使用迭代器时如果对容器做了增删操作，则会使得迭代器失效，甚至报错和崩溃。迭代器对象是实时生成的，当我们获取迭代器对象时，容器会实时生成一个迭代器对象，我们再通过操作这个迭代器对象达成我们的目的。4.数组一些复杂的数组声明难以理解，因此如果能从数组的名字开始按照由内向外的顺序阅读会更加容易些。int arr[10]; // 普通数组含有10个整数int *ptrs[10]; // ptrs是含有10个整数指针的数组int (*Parray)[10] = &amp;arr; // Parray指向一个含有10个整数的数组int (&amp;arrRef)[10] = arr; // arrRef引用一个含有10个整数的数组int *(&amp;arry)[10] = ptrs; //arry是数组的引用，该数组含有10个整数指针数组真正使用的时候编译器会把它转成指针。因此指向数组的指针可以使用+、-、==、!=运算符号来操作数组。int arr[] = {0,1,2,3};int *p = arr;++p;int *e = &amp;arr[4]; // e指向arr元素的下一位置for(int *b = arr; b!=e ; ++b)    cout &lt;&lt; *b &lt;&lt; endl;至于多维数组，严格来说C++中没有多维数组，通常所说的多维数组其实是数组的数组，也就是用数组类型组成的数组。其中要注意的是在多维数组遍历时，其遍历顺序应该按照数组的整块内存来遍历，否则命中效率比较低。已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484732&amp;idx=3&amp;sn=13204e3fd9171849653497a8c788c649&amp;chksm=fc22603bcb55e92dfe641a5066c21000b70a3a03a61d2c691324b23a20ae3fffeef40a70facd&amp;token=890029854&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h2 id=\"背景\">背景：</h2><p>我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意。第三是当我们在巩固时创造出了新的知识，那么这些新的知识和旧的知识将同时变成智慧融合到身体中。</p><p>本系列基于《C++ Primer》学习，由于重点放在“重学”，我略过了滚瓜烂熟的部分挑出以前常忽略的部分，以及记忆没有那么深刻的部分，特别是那些重要的但没有上心的部分。</p><h2 id=\"开始\">开始</h2><h2 id=\"1const限定\">1.const限定</h2><p>关键字const对变量的类型加以限定，因此它的值在初始化后不能被改变。</p><p>const默认情况下只在文件内生效，当需要支持多个文件共享时，则使用extern关键字，不管定义和声明都添加extern关键字，并且只需要定义一次。</p><figure class=\"highlight\"><pre><code class=\"language-c--\" data-lang=\"c++\"><span class=\"c1\">//a.cpp</span><span class=\"k\">extern</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">test_constVar</span> <span class=\"o\">=</span> <span class=\"n\">fcn</span><span class=\"p\">();</span><span class=\"c1\">//b.cpp</span><span class=\"k\">extern</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">test_constVar</span><span class=\"p\">;</span></code></pre></figure><p>通过添加extern共享const变量。</p><h2 id=\"const引用常量引用\">const引用（常量引用）</h2><p>与普通引用不同的是，常量引用不能被用作它修改它所绑定的对象。</p><figure class=\"highlight\"><pre><code class=\"language-c--\" data-lang=\"c++\"><span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">ci</span> <span class=\"o\">=</span> <span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"o\">&amp;</span><span class=\"n\">r1</span> <span class=\"o\">=</span> <span class=\"n\">ci</span><span class=\"p\">;</span><span class=\"n\">r1</span> <span class=\"o\">=</span> <span class=\"mi\">40</span><span class=\"p\">;</span> <span class=\"c1\">//错误，常量引用不能修改绑定对象</span><span class=\"kt\">int</span> <span class=\"o\">&amp;</span><span class=\"n\">r2</span> <span class=\"o\">=</span> <span class=\"n\">ci</span><span class=\"p\">;</span> <span class=\"c1\">//错误，普通引用无法赋值常量</span></code></pre></figure><p>严格来说，并不存在常量引用。因为引用不是一个对象，所以我们没法让引用本身恒定不变。事实上，由于c++语言并不允许随意改变引用所绑定的对象，所以从这层意义上理解所有的引用又都算是常量。引用的对象是常量还是非常量可以决定其所能参与的操作，却无论如何都不会影响到引用和对象的绑定关系。简单来说，由于绑定对象无法改变，所以要求引用对象也不能改变。</p><p>但const引用可以绑定一个非const对象，其意义为，绑定后const引用无法改变，只能由所绑定的对象来决定内容。</p><h2 id=\"const指针常量指针\">const指针（常量指针）</h2><p>const指针与const引用有同样的规则。const指针在初始化后无法改变，const指针不能改变所指对象的值，但可以指向非常量变量。当指向非常量时，const指针所指向的对象的值，只能由对象本身来决定。</p><p>C++11中，用constexpr来表示常量表达式，声明为constexpr的变量是一个常量，编译器会验证变量的值是否为常量表达式并离线计算该值。</p><figure class=\"highlight\"><pre><code class=\"language-c--\" data-lang=\"c++\"><span class=\"k\">constexpr</span> <span class=\"kt\">int</span> <span class=\"n\">mf</span> <span class=\"o\">=</span> <span class=\"mi\">20</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"c1\">//离线计算</span><span class=\"k\">constexpr</span> <span class=\"kt\">int</span> <span class=\"n\">limit</span> <span class=\"o\">=</span> <span class=\"n\">mf</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"c1\">//离线计算</span><span class=\"k\">constexpr</span> <span class=\"kt\">int</span> <span class=\"n\">sz</span> <span class=\"o\">=</span> <span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"c1\">// size()必须是constexpr函数</span></code></pre></figure><h2 id=\"2类型别名\">2.类型别名</h2><p>类型别名是某种类型的同义词。</p><p>使用类型别名是为了让复杂的类型名字变得简单明了、易于理解和使用。</p><p>C++11新标准中，使用using来定义类型的别名</p><figure class=\"highlight\"><pre><code class=\"language-c--\" data-lang=\"c++\"><span class=\"k\">typedef</span> <span class=\"kt\">double</span> <span class=\"n\">wages</span><span class=\"p\">;</span> <span class=\"c1\">//wages是double的同义词</span><span class=\"k\">typedef</span> <span class=\"n\">wages</span> <span class=\"n\">base</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">p</span><span class=\"p\">;</span> <span class=\"c1\">//base是double的同义词，并且p是double*的同义词</span><span class=\"k\">typedef</span> <span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">pstring</span><span class=\"p\">;</span> <span class=\"c1\">//pstring 是char*的同义词</span><span class=\"k\">using</span> <span class=\"n\">It</span> <span class=\"o\">=</span> <span class=\"n\">Item_test</span><span class=\"p\">;</span> <span class=\"c1\">// It 是Item_test的同义词</span><span class=\"c1\">//定义</span><span class=\"n\">wages</span> <span class=\"n\">test1</span><span class=\"p\">;</span> <span class=\"c1\">//定义double 变量</span><span class=\"n\">It</span> <span class=\"n\">item</span><span class=\"p\">;</span> <span class=\"c1\">//定义Item_test 变量</span><span class=\"n\">pstring</span> <span class=\"n\">cstr</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"c1\">//定义一个char *</span></code></pre></figure><h2 id=\"3其他\">3.其他</h2><p>auto和decltype都是用来让编译器在离线下自动识别类型的关键字。其中decltype着重识别结果类型与表达式的关系。</p><p>预处理器能确保头文件多次包含仍能安全工作，它在编译之前被执行。</p><figure class=\"highlight\"><pre><code class=\"language-c--\" data-lang=\"c++\"> <span class=\"cp\">#include、#define、#ifdef、#ifndef都是预处理关键字。</span></code></pre></figure><h2 id=\"第3章\">第3章</h2><h2 id=\"1string字符串类\">1.string字符串类</h2><p>前面说using可以用于类型别名，using也可以用于声明命名空间。using namespace::name不过头文件中不应包含using声明，因为这会导致头文件在被拷贝时多次重复声明using。</p><p>string是标准库中的类对象。string在使用中最容易发生的问题就是拷贝。特别是等号(=、+)引起的合并和拷贝需要注意。string在比较时(==、!=、&lt;、&lt;=、&gt;、&gt;=)有比较算法但每个字符都会比较。</p><p>严格来说string对象不属于容器类型，但string支持很多与容器类似的操作，比如下标、迭代器等。</p><h2 id=\"2vector动态数组\">2.vector动态数组</h2><p>vector是标准中的动态数组模版库。模版本身不是类或函数，可以把模版看成编译器生成的类或函数。编译器根据模版创建类或函数的过程称为实例化。因此使用模版时，我们要指出编译器应把类或函数实例化成何种类型。因此vector是模版而非类型，由vector生成的类才叫类型。</p><p>vector容器本身就是对象，因此也能通过拷贝初始化。</p><figure class=\"highlight\"><pre><code class=\"language-c--\" data-lang=\"c++\"><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">v1</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">};</span> <span class=\"c1\">// 初始化3个元素，1、2、3</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">v2</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">);</span> <span class=\"c1\">// 初始化10个元素，都是-1</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">v3</span> <span class=\"o\">=</span> <span class=\"n\">v1</span><span class=\"p\">;</span> <span class=\"c1\">// 用拷贝来初始化，将v1中的数据拷贝到v3，完成后v3拥有独立的数据</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">v4</span><span class=\"p\">(</span><span class=\"mi\">20</span><span class=\"p\">);</span> <span class=\"c1\">// 提前预备20个值，每个值都是0</span></code></pre></figure><p>由于vector是动态数组，因此如果能在初始化时提前告知vector的话，vector就不用扩容了，运行时性能会更好。</p><h2 id=\"3迭代器\">3.迭代器</h2><p>迭代器有三种不同含意，一是迭代器概念本身，二是容器定义的迭代器类型，三是指某个迭代器对象。</p><p>有时她跟指针很像，但又完全不一样。</p><p>其实迭代器是个由模版封装过的类，根据不同的类型的容器，编译器生成功能相似但命名不同的类。</p><p>迭代器又重写了==、&gt;、&lt;、!=、&lt;=、&gt;=、+=、-=运算符，使得我们在编写代码时更加方便。</p><p>共识：当使用迭代器时如果对容器做了增删操作，则会使得迭代器失效，甚至报错和崩溃。</p><p>迭代器对象是实时生成的，当我们获取迭代器对象时，容器会实时生成一个迭代器对象，我们再通过操作这个迭代器对象达成我们的目的。</p><h2 id=\"4数组\">4.数组</h2><p>一些复杂的数组声明难以理解，因此如果能从数组的名字开始按照由内向外的顺序阅读会更加容易些。</p><figure class=\"highlight\"><pre><code class=\"language-c--\" data-lang=\"c++\"><span class=\"kt\">int</span> <span class=\"n\">arr</span><span class=\"p\">[</span><span class=\"mi\">10</span><span class=\"p\">];</span> <span class=\"c1\">// 普通数组含有10个整数</span><span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">ptrs</span><span class=\"p\">[</span><span class=\"mi\">10</span><span class=\"p\">];</span> <span class=\"c1\">// ptrs是含有10个整数指针的数组</span><span class=\"kt\">int</span> <span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">Parray</span><span class=\"p\">)[</span><span class=\"mi\">10</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">arr</span><span class=\"p\">;</span> <span class=\"c1\">// Parray指向一个含有10个整数的数组</span><span class=\"kt\">int</span> <span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">arrRef</span><span class=\"p\">)[</span><span class=\"mi\">10</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">arr</span><span class=\"p\">;</span> <span class=\"c1\">// arrRef引用一个含有10个整数的数组</span><span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">arry</span><span class=\"p\">)[</span><span class=\"mi\">10</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">ptrs</span><span class=\"p\">;</span> <span class=\"c1\">//arry是数组的引用，该数组含有10个整数指针</span></code></pre></figure><p>数组真正使用的时候编译器会把它转成指针。因此指向数组的指针可以使用+、-、==、!=运算符号来操作数组。</p><figure class=\"highlight\"><pre><code class=\"language-c--\" data-lang=\"c++\"><span class=\"kt\">int</span> <span class=\"n\">arr</span><span class=\"p\">[]</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">};</span><span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">arr</span><span class=\"p\">;</span><span class=\"o\">++</span><span class=\"n\">p</span><span class=\"p\">;</span><span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">arr</span><span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">];</span> <span class=\"c1\">// e指向arr元素的下一位置</span><span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">arr</span><span class=\"p\">;</span> <span class=\"n\">b</span><span class=\"o\">!=</span><span class=\"n\">e</span> <span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">b</span><span class=\"p\">)</span>    <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"o\">*</span><span class=\"n\">b</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span></code></pre></figure><p>至于多维数组，严格来说C++中没有多维数组，通常所说的多维数组其实是数组的数组，也就是用数组类型组成的数组。</p><p>其中要注意的是在多维数组遍历时，其遍历顺序应该按照数组的整块内存来遍历，否则命中效率比较低。</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484732&amp;idx=3&amp;sn=13204e3fd9171849653497a8c788c649&amp;chksm=fc22603bcb55e92dfe641a5066c21000b70a3a03a61d2c691324b23a20ae3fffeef40a70facd&amp;token=890029854&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/06/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B026",
            
            
            
            "tags": ["读书笔记","前端技术"],
            
            "date_published": "2021-06-12T00:00:00+08:00",
            "date_modified": "2021-06-12T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/06/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B025",
            "title": "读书笔记(二十五) 《C++ Primer》#1",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意，将这些知识变成智慧融合到身体中。本系列基于《C++ Primer》学习，重学的时候，我略过了滚瓜烂熟的部分，挑出以前忽略的，以及记忆没有那么深刻的，特别是那些重要的但以前没有上心的部分。开始使用命令行界面来学习c++会更好一些，这种学习方式可以让你将精力集中在c++语言本身上，一旦掌握了语言，使用和学习IDE编辑器通常也更容易些。.h文件作为头文件只是程序员的习惯，头文件后缀并没有特定的规范，通常为了方便查看都以.h为后缀。编译器一般不关心文件名的形式，但有的IDE对此有特定要求。c++基础c++是一种静态数据类型语言，它的类型检查发生在编译时。因此，编译器必须知道程序中每一个变量对应的数据类型。c++提供了一组内置数据类型、相应的运算符、以及为数不多的程序流控制语句，这些元素共同构成了c++语言的基本形态。仅就c++的基本形态来说，它是一种简单的编程语言。但其强大的能力显示于它对程序员自定义数据结构的支持，程序员可以通过自主定义新的数据结构来使语言满足他们各自的需求。省略掉一些简单变量类型的内容，将一些特别需要注意，以及大家常忽略又比较重要的内容提取出来。类型转换      char在一些机器上是有符号的，另一些机器上则是无符号的。        当我们赋值给一个无符号类型的变量一个超出它范围的值时，结果是总数取模后的余数。        当我们赋值给带符号类型一个超出他范围的值时，结果是未定义（不可预测）。        切勿混用有符号和无符号的类型，如果表达式里既有带符号又有无符号类型，带符号的数会自动转换成无符号，如果是个负数则会出现异常结果。  无法预知的行为源于编译器无须检查的错误。在某些情况或某些编译器下，含有无法预知行为的程序也能正确执行。不可移植通常都是程序依赖了环境，或操作系统环境或编译器环境，程序应该尽量避免依赖于实现环境的行为。例如我们把 int 的尺寸看成一个固定不变的值，这样的程序就称为不可移植。变量何为对象？对象就是指一块能存储数据并具有某种类型的内存空间。初始化是一个复杂的过程，很多程序员对于初始化的认识，停留在=等号赋值的认知上。事实上它完全不是这样的。它有构造、拷贝、赋值三种途径，且有默认构造、未初始化、定义与声明三个容易出错的地方。初始化并不一定被默认执行，这是因为并对象不一定有默认构造函数，且有些编译器构造的默认构造函数并不一定会去初始化变量，这导致一个未被初始化的变量在拷贝和访问时就会引发错误，因此我们最好自己主动的去初始化每个变量。c++支持分离式编译，允许将程序分为若干个文件，每个文件可被独立编译。因此我们可以把变量的定义和声明区分开来，即在某个文件中定义，在另一些文件中声明后再使用。变量能且只能定义一次，但可以被多次声明，在声明时不能重复初始化：// a.cppint global_index = 5; //定义// b.cppextern int global_index; //声明global_index += 5;// c.cppextern int global_index; //声明global_index -= 2;如上代码中，a.cpp中定义了global_index并初始化为5，在b.cpp和c.cpp中使用。复合类型复合类型有两种，即引用和指针。引用特点：\t引用本身不是对象，而它必须绑定一个对象。\t引用在定义时必须被初始化，它不能为空。\t引用在初始化后，与它的值绑定在一起，并且无法再重新绑定到另外的对象上。指针特点：\t指针本身就有自己的对象概念，存放的是对象的地址，可为null也可以为具体的指针值。\t指针无须在定义时初始化（未初始化有风险），可以为空，也可以指向某个对象，也可能是无效的野指针。引用和指针通过，取地址符（&amp;），解引用（*）来操作，我们来举个例子：int dval = 5; // 初始化int &amp;tval = dval; // 绑定dvalint *pd = &amp;dval; // 取地址，赋值给指针*pd = 3; // 此时dval 为3，tval也为3，*pd也为3特殊指针：\t1.c++11中引入了nullptr的空指针类型，以前用的NULL空指针，其实质是一个宏预处理，NULL定义在cstdlib中值为0。\t\t2.void*也是特殊指针，可用于存放任意对象地址。但不能操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，它仅仅是内存空间。已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484732&amp;idx=2&amp;sn=cbf9e354ddf1157c9913d7e4fc3ad41f&amp;chksm=fc22603bcb55e92dd8e5fdd6210f007c072f1208ecf85a081f0273f26e54ff95ad9d219d2094&amp;token=890029854&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h2 id=\"背景\">背景：</h2><p>我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意，将这些知识变成智慧融合到身体中。</p><p>本系列基于《C++ Primer》学习，重学的时候，我略过了滚瓜烂熟的部分，挑出以前忽略的，以及记忆没有那么深刻的，特别是那些重要的但以前没有上心的部分。</p><h2 id=\"开始\">开始</h2><p>使用命令行界面来学习c++会更好一些，这种学习方式可以让你将精力集中在c++语言本身上，一旦掌握了语言，使用和学习IDE编辑器通常也更容易些。</p><p>.h文件作为头文件只是程序员的习惯，头文件后缀并没有特定的规范，通常为了方便查看都以.h为后缀。</p><p>编译器一般不关心文件名的形式，但有的IDE对此有特定要求。</p><h2 id=\"c基础\">c++基础</h2><p>c++是一种静态数据类型语言，它的类型检查发生在编译时。因此，编译器必须知道程序中每一个变量对应的数据类型。</p><p>c++提供了一组内置数据类型、相应的运算符、以及为数不多的程序流控制语句，这些元素共同构成了c++语言的基本形态。</p><p>仅就c++的基本形态来说，它是一种简单的编程语言。</p><p>但其强大的能力显示于它对程序员自定义数据结构的支持，程序员可以通过自主定义新的数据结构来使语言满足他们各自的需求。</p><p>省略掉一些简单变量类型的内容，将一些特别需要注意，以及大家常忽略又比较重要的内容提取出来。</p><p>类型转换</p><ol>  <li>    <p>char在一些机器上是有符号的，另一些机器上则是无符号的。</p>  </li>  <li>    <p>当我们赋值给一个无符号类型的变量一个超出它范围的值时，结果是总数取模后的余数。</p>  </li>  <li>    <p>当我们赋值给带符号类型一个超出他范围的值时，结果是未定义（不可预测）。</p>  </li>  <li>    <p>切勿混用有符号和无符号的类型，如果表达式里既有带符号又有无符号类型，带符号的数会自动转换成无符号，如果是个负数则会出现异常结果。</p>  </li></ol><p>无法预知的行为源于编译器无须检查的错误。在某些情况或某些编译器下，含有无法预知行为的程序也能正确执行。</p><p>不可移植通常都是程序依赖了环境，或操作系统环境或编译器环境，程序应该尽量避免依赖于实现环境的行为。例如我们把 int 的尺寸看成一个固定不变的值，这样的程序就称为不可移植。</p><h2 id=\"变量\">变量</h2><p>何为对象？对象就是指一块能存储数据并具有某种类型的内存空间。</p><p>初始化是一个复杂的过程，很多程序员对于初始化的认识，停留在=等号赋值的认知上。事实上它完全不是这样的。</p><p>它有构造、拷贝、赋值三种途径，且有默认构造、未初始化、定义与声明三个容易出错的地方。</p><p>初始化并不一定被默认执行，这是因为并对象不一定有默认构造函数，且有些编译器构造的默认构造函数并不一定会去初始化变量，这导致一个未被初始化的变量在拷贝和访问时就会引发错误，因此我们最好自己主动的去初始化每个变量。</p><p>c++支持分离式编译，允许将程序分为若干个文件，每个文件可被独立编译。</p><p>因此我们可以把变量的定义和声明区分开来，即在某个文件中定义，在另一些文件中声明后再使用。</p><p>变量能且只能定义一次，但可以被多次声明，在声明时不能重复初始化：</p><figure class=\"highlight\"><pre><code class=\"language-c--\" data-lang=\"c++\"><span class=\"c1\">// a.cpp</span><span class=\"kt\">int</span> <span class=\"n\">global_index</span> <span class=\"o\">=</span> <span class=\"mi\">5</span><span class=\"p\">;</span> <span class=\"c1\">//定义</span><span class=\"c1\">// b.cpp</span><span class=\"k\">extern</span> <span class=\"kt\">int</span> <span class=\"n\">global_index</span><span class=\"p\">;</span> <span class=\"c1\">//声明</span><span class=\"n\">global_index</span> <span class=\"o\">+=</span> <span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"c1\">// c.cpp</span><span class=\"k\">extern</span> <span class=\"kt\">int</span> <span class=\"n\">global_index</span><span class=\"p\">;</span> <span class=\"c1\">//声明</span><span class=\"n\">global_index</span> <span class=\"o\">-=</span> <span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"err\">如上代码中，</span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">cpp</span><span class=\"err\">中定义了</span><span class=\"n\">global_index</span><span class=\"err\">并初始化为</span><span class=\"mi\">5</span><span class=\"err\">，在</span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">cpp</span><span class=\"err\">和</span><span class=\"n\">c</span><span class=\"p\">.</span><span class=\"n\">cpp</span><span class=\"err\">中使用。</span></code></pre></figure><h2 id=\"复合类型\">复合类型</h2><p>复合类型有两种，即引用和指针。</p><p>引用特点：</p><pre><code>\t引用本身不是对象，而它必须绑定一个对象。\t引用在定义时必须被初始化，它不能为空。\t引用在初始化后，与它的值绑定在一起，并且无法再重新绑定到另外的对象上。</code></pre><p>指针特点：</p><pre><code>\t指针本身就有自己的对象概念，存放的是对象的地址，可为null也可以为具体的指针值。\t指针无须在定义时初始化（未初始化有风险），可以为空，也可以指向某个对象，也可能是无效的野指针。</code></pre><p>引用和指针通过，取地址符（&amp;），解引用（*）来操作，我们来举个例子：</p><figure class=\"highlight\"><pre><code class=\"language-c--\" data-lang=\"c++\"><span class=\"kt\">int</span> <span class=\"n\">dval</span> <span class=\"o\">=</span> <span class=\"mi\">5</span><span class=\"p\">;</span> <span class=\"c1\">// 初始化</span><span class=\"kt\">int</span> <span class=\"o\">&amp;</span><span class=\"n\">tval</span> <span class=\"o\">=</span> <span class=\"n\">dval</span><span class=\"p\">;</span> <span class=\"c1\">// 绑定dval</span><span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">pd</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">dval</span><span class=\"p\">;</span> <span class=\"c1\">// 取地址，赋值给指针</span><span class=\"o\">*</span><span class=\"n\">pd</span> <span class=\"o\">=</span> <span class=\"mi\">3</span><span class=\"p\">;</span> <span class=\"c1\">// 此时dval 为3，tval也为3，*pd也为3</span></code></pre></figure><p>特殊指针：</p><pre><code>\t1.c++11中引入了nullptr的空指针类型，以前用的NULL空指针，其实质是一个宏预处理，NULL定义在cstdlib中值为0。\t\t2.void*也是特殊指针，可用于存放任意对象地址。但不能操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，它仅仅是内存空间。</code></pre><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484732&amp;idx=2&amp;sn=cbf9e354ddf1157c9913d7e4fc3ad41f&amp;chksm=fc22603bcb55e92dd8e5fdd6210f007c072f1208ecf85a081f0273f26e54ff95ad9d219d2094&amp;token=890029854&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/06/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B025",
            
            
            
            "tags": ["读书笔记","前端技术"],
            
            "date_published": "2021-06-07T00:00:00+08:00",
            "date_modified": "2021-06-07T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/05/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B024",
            "title": "读书笔记(二十四) 《如何高效阅读 - 中》",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：看了很多书，也总结过很多书，对如何看书以及如何总结书本仍然迷茫。所以自己找了3本书，《如何阅读》、《如何阅读一本书》、《如何高效阅读一本书》，专门针对这三本书做了仔细的总结和分析。我把文章分为上、中、下三篇，本篇为中篇，讲的是《如何阅读一本书》这本书。书中有几个方法和框架，无论你是完全照做，或只是掌握个形式，你都得了解要如何跟着规则走，这是第一步。只有了解规则怎么走，熟悉了规则，才会能逐渐掌握。就像我们在学习新知识的时候那样，可能一开始只是模仿，只是形式上的掌握，没有触及技巧的灵魂。随着我们熟练度的深入，规则越来越熟悉，技巧越来越熟练，也就慢慢地将技巧的灵魂融入到我们的身体中甚至生活习惯中。下面我们就来看看书中是怎么论述阅读规则和技巧的。简要总结：      阅读有四个层次，基础阅读、检视阅读、分析阅读、主题阅读。        主动阅读就是带着目的阅读，在阅读前提出问题，带着问题阅读，并且在多次重复阅读中回答问题。最后阅读完成用自己的语言写大纲和评价。        主题阅读需要阅读很多同一主题的书，然后再做分析和讨论。        针对不同类型的读物，我们需要用不同类型的方法。        珍惜一本好书的方法，就是读很多遍，甚至是一辈子都在读。        主动阅读对我们各方面的帮助都会很大。  正文：已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484709&amp;idx=1&amp;sn=4c609d7afb6e41db78948f7797e31de6&amp;chksm=fc226022cb55e934935d6df6b188978331f28a6854abd70eec313fc71d225a709bdcbd291af0&amp;token=679775473&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h2 id=\"背景\">背景：</h2><p>看了很多书，也总结过很多书，对如何看书以及如何总结书本仍然迷茫。所以自己找了3本书，《如何阅读》、《如何阅读一本书》、《如何高效阅读一本书》，专门针对这三本书做了仔细的总结和分析。我把文章分为上、中、下三篇，本篇为中篇，讲的是《如何阅读一本书》这本书。</p><p>书中有几个方法和框架，无论你是完全照做，或只是掌握个形式，你都得了解要如何跟着规则走，这是第一步。</p><p>只有了解规则怎么走，熟悉了规则，才会能逐渐掌握。就像我们在学习新知识的时候那样，可能一开始只是模仿，只是形式上的掌握，没有触及技巧的灵魂。随着我们熟练度的深入，规则越来越熟悉，技巧越来越熟练，也就慢慢地将技巧的灵魂融入到我们的身体中甚至生活习惯中。</p><p>下面我们就来看看书中是怎么论述阅读规则和技巧的。</p><h2 id=\"简要总结\">简要总结：</h2><ol>  <li>    <p>阅读有四个层次，基础阅读、检视阅读、分析阅读、主题阅读。</p>  </li>  <li>    <p>主动阅读就是带着目的阅读，在阅读前提出问题，带着问题阅读，并且在多次重复阅读中回答问题。最后阅读完成用自己的语言写大纲和评价。</p>  </li>  <li>    <p>主题阅读需要阅读很多同一主题的书，然后再做分析和讨论。</p>  </li>  <li>    <p>针对不同类型的读物，我们需要用不同类型的方法。</p>  </li>  <li>    <p>珍惜一本好书的方法，就是读很多遍，甚至是一辈子都在读。</p>  </li>  <li>    <p>主动阅读对我们各方面的帮助都会很大。</p>  </li></ol><h2 id=\"正文\">正文：</h2><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484709&amp;idx=1&amp;sn=4c609d7afb6e41db78948f7797e31de6&amp;chksm=fc226022cb55e934935d6df6b188978331f28a6854abd70eec313fc71d225a709bdcbd291af0&amp;token=679775473&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/05/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B024",
            
            
            
            
            
            "date_published": "2021-05-29T00:00:00+08:00",
            "date_modified": "2021-05-29T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/05/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B023",
            "title": "读书笔记(二十三) 《如何高效阅读 - 上》",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：看了很多书，也总结了很多书，但对读书这个词语越来越迷茫。迷茫的是，不知道自己的阅读习惯是否真的好，自己的阅读效率是否真的高，我对自己的阅读能力不自信。因此买了三本经典阅读技巧书，一本是《如何阅读一本书》、另一个本是《如何阅读》，再加上去年读过的《如何有效阅读一本书》，三本书加起来，对阅读的技巧和效率做一个巩固和总结。因此我把此系列总结文章分成三部分，上、中、下，本文是上篇。本文总结的是《如何阅读》这本书，它主要讲的主题是，如何提高我们的阅读速度。阅读速度是否是阅读的关键呢，我认为是的，但也认为不是。关键在于你怎么理解和运用。我们来看看作者是怎么认为的。文中并没有详细的提到带着目的去阅读的具体方法，但全文都在提倡带着目的去阅读，我认为这是个重要方法，这个重要的方法我打算在另一本书《如何阅读一本书》的总结里做分析。简要总结：不一定什么书都要细读，针对不同的书要使用不同的阅读方式。提高阅读速度的技巧有很多种，针对不同的内容使用不同阅读速度。阅读的环境和习惯是提高效率的一个重要关键点。理解力是阅读效率的一个重要指标，它要求我们和作者不断对话，彼此交流达到沟通理解的地步。阅读笔记是增加理解力，加强注意力，提高回顾效率的一个有效方式。正文：已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484653&amp;idx=1&amp;sn=f16e52ea17560947ace74b8a7ecfaefb&amp;chksm=fc2261eacb55e8fc2d96d43bcf8dc1978cfa67e678d5003b793d33a7adb7bdf7b4859e28c740&amp;token=2074622695&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h2 id=\"背景\">背景：</h2><p>看了很多书，也总结了很多书，但对读书这个词语越来越迷茫。</p><p>迷茫的是，不知道自己的阅读习惯是否真的好，自己的阅读效率是否真的高，我对自己的阅读能力不自信。</p><p>因此买了三本经典阅读技巧书，一本是《如何阅读一本书》、另一个本是《如何阅读》，再加上去年读过的《如何有效阅读一本书》，</p><p>三本书加起来，对阅读的技巧和效率做一个巩固和总结。因此我把此系列总结文章分成三部分，上、中、下，本文是上篇。</p><p>本文总结的是《如何阅读》这本书，它主要讲的主题是，如何提高我们的阅读速度。</p><p>阅读速度是否是阅读的关键呢，我认为是的，但也认为不是。关键在于你怎么理解和运用。我们来看看作者是怎么认为的。</p><p>文中并没有详细的提到带着目的去阅读的具体方法，但全文都在提倡带着目的去阅读，我认为这是个重要方法，这个重要的方法我打算在另一本书《如何阅读一本书》的总结里做分析。</p><h2 id=\"简要总结\">简要总结：</h2><pre><code>不一定什么书都要细读，针对不同的书要使用不同的阅读方式。提高阅读速度的技巧有很多种，针对不同的内容使用不同阅读速度。阅读的环境和习惯是提高效率的一个重要关键点。理解力是阅读效率的一个重要指标，它要求我们和作者不断对话，彼此交流达到沟通理解的地步。阅读笔记是增加理解力，加强注意力，提高回顾效率的一个有效方式。</code></pre><h2 id=\"正文\">正文：</h2><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484653&amp;idx=1&amp;sn=f16e52ea17560947ace74b8a7ecfaefb&amp;chksm=fc2261eacb55e8fc2d96d43bcf8dc1978cfa67e678d5003b793d33a7adb7bdf7b4859e28c740&amp;token=2074622695&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/05/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B023",
            
            
            
            
            
            "date_published": "2021-05-23T00:00:00+08:00",
            "date_modified": "2021-05-23T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/05/14/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A865",
            "title": "思路探讨(六十五) 人生的框架",
            "summary": "思路 随想 理念 逻辑 人生哲学",
            "content_text": "目标管理从2月份到现在已经实践了有一段时间了，它给我带来了很多震撼的效果，也开阔了我不少视野。我慢慢发现行为习惯和思维习惯的改变就像脱胎换骨一样，是极难的，也是极其痛苦的过程。当然这也意味着，目标管理的这3个月折磨的我很痛苦，不过这些都是值得的，都是改变行为习惯和思维习惯所必须经历。人就是这样的，改变的太多太快，身体就会承受很大的痛苦，心思上和肉体上都会有。最大的体会是，目标给我提供了动力和方向。这给了我很多提示，很多旧思想和旧习惯在我脑海中浮现。以前经常会去寻找安全感，去为获得安全感而努力，比如想着有一天能安心躺着赚钱，或者存够钱去农村养老，或者找到一份安逸稳定的饭碗，还有我们总是想早点完成手头上的工作来获得安全感。这其实就是人性的一面，为获得安全感而活，所以很多新闻标题都以恐吓人的方式来命名，以吸引人来关注。这些年的经历告诉我，不要试图去追求安全感，周遭的环境从来都不会有绝对的安全，如果有，那肯定是陷进，你安全的越久，就会陷的越深越无法自拔。只有不断的挑战，不断努力，不断拼搏，才能让自己有永恒的动力，才会有不灭的优势。也体会到，人越老，年龄越大就越对周围的事物失去兴趣，保持热情变得越来越困难。年轻时对周围的事物都充满了新鲜感，社会生活了10几年后，这层新鲜感就不在了，留下的都是枯燥和乏味。有些人沉沦，有些人走偏，这也都是在预料之中的事。保持热情，就要保持好奇。而保持好奇心最好的方式，就要有目标，这些都是一环扣一环的，有目标，可量化，就能得到反馈，有反馈就有令人兴奋的动力。这些我都写在《目标管理》的一篇文章中，这些年我建立了自己的框架，框架中包含了做人做事的心态，家庭，价值观，目标，行为习惯和思维习惯等方方面面，我希望我的人生是平衡的，这样走下去才会更加的稳。什么是更加稳的人生呢？1.更少的情绪波动（外部波动可能很大，内部波动则更小）2.要事优先，做更重要的事情3.朝着正确的人生方向不偏离4.帮助周围的人一起往更好的方向奔去同时这个框架让我所做的事情变得可积累，甚至是把原本不可积累事情的变成了可积累。这样，在这个框架中，我积累的越多，框架就越强大，我也会活的更好些。当然，框架不是一蹴而就的，可能需要建设10年20年甚至一辈子，所以我一直在完善这个框架，不断去调整它，加入更好的元素，去掉错误的理解，调整偏离的方向。框架也同时成为了我人生中的可以一直感兴趣的事情，因为我在不断研究它完善它，我相信这个框架会给我带来越来越好的人生。也希望各位能共同努力，往更好的人生方向奔去。一点点小总结，希望能给大家带去一些参考价值。",
            "content_html": "<p>目标管理从2月份到现在已经实践了有一段时间了，它给我带来了很多震撼的效果，也开阔了我不少视野。</p><p>我慢慢发现行为习惯和思维习惯的改变就像脱胎换骨一样，是极难的，也是极其痛苦的过程。</p><p>当然这也意味着，目标管理的这3个月折磨的我很痛苦，不过这些都是值得的，都是改变行为习惯和思维习惯所必须经历。人就是这样的，改变的太多太快，身体就会承受很大的痛苦，心思上和肉体上都会有。</p><h3 id=\"最大的体会是目标给我提供了动力和方向\">最大的体会是，目标给我提供了动力和方向。</h3><p>这给了我很多提示，很多旧思想和旧习惯在我脑海中浮现。</p><p>以前经常会去寻找安全感，去为获得安全感而努力，比如想着有一天能安心躺着赚钱，或者存够钱去农村养老，或者找到一份安逸稳定的饭碗，还有我们总是想早点完成手头上的工作来获得安全感。</p><p>这其实就是人性的一面，为获得安全感而活，所以很多新闻标题都以恐吓人的方式来命名，以吸引人来关注。</p><h3 id=\"这些年的经历告诉我不要试图去追求安全感周遭的环境从来都不会有绝对的安全如果有那肯定是陷进你安全的越久就会陷的越深越无法自拔\">这些年的经历告诉我，不要试图去追求安全感，周遭的环境从来都不会有绝对的安全，如果有，那肯定是陷进，你安全的越久，就会陷的越深越无法自拔。</h3><h3 id=\"只有不断的挑战不断努力不断拼搏才能让自己有永恒的动力才会有不灭的优势\">只有不断的挑战，不断努力，不断拼搏，才能让自己有永恒的动力，才会有不灭的优势。</h3><p>也体会到，人越老，年龄越大就越对周围的事物失去兴趣，保持热情变得越来越困难。</p><p>年轻时对周围的事物都充满了新鲜感，社会生活了10几年后，这层新鲜感就不在了，留下的都是枯燥和乏味。有些人沉沦，有些人走偏，这也都是在预料之中的事。</p><p>保持热情，就要保持好奇。而保持好奇心最好的方式，就要有目标，这些都是一环扣一环的，有目标，可量化，就能得到反馈，有反馈就有令人兴奋的动力。</p><p>这些我都写在《目标管理》的一篇文章中，这些年我建立了自己的框架，框架中包含了做人做事的心态，家庭，价值观，目标，行为习惯和思维习惯等方方面面，我希望我的人生是平衡的，这样走下去才会更加的稳。</p><p>什么是更加稳的人生呢？</p><pre><code>1.更少的情绪波动（外部波动可能很大，内部波动则更小）2.要事优先，做更重要的事情3.朝着正确的人生方向不偏离4.帮助周围的人一起往更好的方向奔去</code></pre><p>同时这个框架让我所做的事情变得可积累，甚至是把原本不可积累事情的变成了可积累。这样，在这个框架中，我积累的越多，框架就越强大，我也会活的更好些。</p><h3 id=\"当然框架不是一蹴而就的可能需要建设10年20年甚至一辈子所以我一直在完善这个框架不断去调整它加入更好的元素去掉错误的理解调整偏离的方向\">当然，框架不是一蹴而就的，可能需要建设10年20年甚至一辈子，所以我一直在完善这个框架，不断去调整它，加入更好的元素，去掉错误的理解，调整偏离的方向。</h3><p>框架也同时成为了我人生中的可以一直感兴趣的事情，因为我在不断研究它完善它，我相信这个框架会给我带来越来越好的人生。也希望各位能共同努力，往更好的人生方向奔去。</p><p>一点点小总结，希望能给大家带去一些参考价值。</p>",
            "url": "http://www.luzexi.com/2021/05/14/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A865",
            
            
            
            
            
            "date_published": "2021-05-14T00:00:00+08:00",
            "date_modified": "2021-05-14T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/05/11/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A112",
            "title": "给女儿的信(十二) 关于积分制",
            "summary": "女儿 教育 亲情",
            "content_text": "hi Sharon Anne，爸爸几天不见好想你们。爸爸又回到深圳工作了，爸爸跟你们说过，爸爸不只是来工作的，更是来学习的。爸爸每天都很努力的去学习，去思考，爸爸想多学一点。但是，你知道，每个人都会有累的时候，都会有这么段时间想偷懒的时候。爸爸不想偷懒，但人就是会有是有懒的时候，懒的早起，懒的看书，懒的运动，懒的写文章。这不是爸爸想要的，爸爸想克服它，为了能抵抗人的懒惰，爸爸想了很多办法，也尝试了很多办法。幸运的是，爸爸终于找到一个很好的办法来抵抗懒惰，那就是给自己设定目标，并且奖励小星星。爸爸给自己设置了很多奖励小星星的任务，比如看完一本书，就给自己10颗小星星，写一篇文章就给自己8颗小星星，每天早起锻炼就给自己1颗小星星。爸爸又给自己设定了奖励，比如用30颗小星星换一次回家休息的机会，用50颗小星星换一次去外面野餐的机会，80颗小星星换一个游戏。爸爸把这些小星星积累起来，到了足够多的时候，就把它们用在自己喜欢的事情上。于是为了能够凑足小星星，获得自己想要的奖励，爸爸又充满的动力了，每天都努力读书，写文章，锻炼，攒小星星。哈哈，是不是很好玩，爸爸也跟你们一起攒小星星呢，攒满了小星星，一起去玩哦。加油Sharon，加油Anne，爸爸喜欢你们哦，要照顾好妈妈呦，笔芯。",
            "content_html": "<p>hi Sharon Anne，爸爸几天不见好想你们。爸爸又回到深圳工作了，爸爸跟你们说过，爸爸不只是来工作的，更是来学习的。</p><p>爸爸每天都很努力的去学习，去思考，爸爸想多学一点。</p><p>但是，你知道，每个人都会有累的时候，都会有这么段时间想偷懒的时候。</p><p>爸爸不想偷懒，但人就是会有是有懒的时候，懒的早起，懒的看书，懒的运动，懒的写文章。</p><p>这不是爸爸想要的，爸爸想克服它，为了能抵抗人的懒惰，爸爸想了很多办法，也尝试了很多办法。</p><p>幸运的是，爸爸终于找到一个很好的办法来抵抗懒惰，那就是给自己设定目标，并且奖励小星星。</p><p>爸爸给自己设置了很多奖励小星星的任务，</p><p>比如看完一本书，就给自己10颗小星星，写一篇文章就给自己8颗小星星，每天早起锻炼就给自己1颗小星星。</p><p>爸爸又给自己设定了奖励，比如用30颗小星星换一次回家休息的机会，用50颗小星星换一次去外面野餐的机会，80颗小星星换一个游戏。</p><p>爸爸把这些小星星积累起来，到了足够多的时候，就把它们用在自己喜欢的事情上。</p><p>于是为了能够凑足小星星，获得自己想要的奖励，爸爸又充满的动力了，每天都努力读书，写文章，锻炼，攒小星星。</p><p>哈哈，是不是很好玩，爸爸也跟你们一起攒小星星呢，攒满了小星星，一起去玩哦。</p><p>加油Sharon，加油Anne，爸爸喜欢你们哦，要照顾好妈妈呦，笔芯。</p>",
            "url": "http://www.luzexi.com/2021/05/11/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A112",
            
            
            
            
            
            "date_published": "2021-05-11T00:00:00+08:00",
            "date_modified": "2021-05-11T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/05/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B022",
            "title": "读书笔记(二十二) 《金字塔原理》下",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：上一篇，我们总结了《金字塔原理》上半部分，这一篇继续了解思考、表达的逻辑。本书我们主要学习的是框架，以前都是没有章法的去思考、去表达、去分析，看了这本书后就知道思考、表达、分析、和解决问题的框架。当然理论和实践差距比较大，我们应该把这些理论落地到实践中去。建立起自己在现实中的框架，这样我们在学习和工作中会更稳一些，倘若我们发现自己的框架有问题，我们则需要停下来先修理自己的框架，这样就能逐渐形成自己的体系，从而让你更有章法、更有节奏、更有效率的去解决问题。概述：回顾一下前面的知识，前面我们说了，我们在表达时的逻辑，表达时要以金字塔的形式叙述，这样能让听者和读者更容易接受。序言的故事结构，就很好的契合了这种表达目的，由于序言常以故事结构作为表达形式，而人更容易接受以故事形式叙述的事情，所以它更能让人接受和吸收。序言有4个要素组成，即背景、冲突、疑问、答案，遵照这4个要素，我们在表达时就会更容易些。表达逻辑之后，也讲到思考的逻辑。我们在应用逻辑顺序时，会用到逻辑的时间顺序、结构顺序、程度顺序去分析和归纳问题。当然，采用各种逻辑思考最终目的是要产生新的思想，那么如何提高产生新的思想的概率呢，我们可以通过分析和归纳的方法。即，列出值得思考的思想、找出思想之间的共同点、提出新的思想。简单回顾到这里，现在继续下篇的总结，内容包括：  解决问题的逻辑          界定问题的框架      结构化分析问题        演示的逻辑          书面上的金字塔      PPT上的金字塔      字里行间的金字塔      正文：已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484626&amp;idx=1&amp;sn=cdbe54838b9b0207441663acb49bec6f&amp;chksm=fc2261d5cb55e8c3185818b45f69941cffe1cfe7466b901b907c08d16576a04a3eb11890b6e0&amp;token=1892444225&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h2 id=\"背景\">背景：</h2><p>上一篇，我们总结了《金字塔原理》上半部分，这一篇继续了解思考、表达的逻辑。</p><p>本书我们主要学习的是框架，以前都是没有章法的去思考、去表达、去分析，看了这本书后就知道思考、表达、分析、和解决问题的框架。当然理论和实践差距比较大，我们应该把这些理论落地到实践中去。</p><p>建立起自己在现实中的框架，这样我们在学习和工作中会更稳一些，倘若我们发现自己的框架有问题，我们则需要停下来先修理自己的框架，这样就能逐渐形成自己的体系，从而让你更有章法、更有节奏、更有效率的去解决问题。</p><h2 id=\"概述\">概述：</h2><p>回顾一下前面的知识，前面我们说了，我们在表达时的逻辑，表达时要以金字塔的形式叙述，这样能让听者和读者更容易接受。</p><p>序言的故事结构，就很好的契合了这种表达目的，由于序言常以故事结构作为表达形式，而人更容易接受以故事形式叙述的事情，所以它更能让人接受和吸收。</p><p>序言有4个要素组成，即背景、冲突、疑问、答案，遵照这4个要素，我们在表达时就会更容易些。</p><p>表达逻辑之后，也讲到思考的逻辑。我们在应用逻辑顺序时，会用到逻辑的时间顺序、结构顺序、程度顺序去分析和归纳问题。</p><p>当然，采用各种逻辑思考最终目的是要产生新的思想，那么如何提高产生新的思想的概率呢，我们可以通过分析和归纳的方法。</p><p>即，列出值得思考的思想、找出思想之间的共同点、提出新的思想。</p><p>简单回顾到这里，现在继续下篇的总结，内容包括：</p><ul>  <li>解决问题的逻辑    <ul>      <li>界定问题的框架</li>      <li>结构化分析问题</li>    </ul>  </li>  <li>演示的逻辑    <ul>      <li>书面上的金字塔</li>      <li>PPT上的金字塔</li>      <li>字里行间的金字塔</li>    </ul>  </li></ul><h2 id=\"正文\">正文：</h2><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484626&amp;idx=1&amp;sn=cdbe54838b9b0207441663acb49bec6f&amp;chksm=fc2261d5cb55e8c3185818b45f69941cffe1cfe7466b901b907c08d16576a04a3eb11890b6e0&amp;token=1892444225&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/05/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B022",
            
            
            
            
            
            "date_published": "2021-05-09T00:00:00+08:00",
            "date_modified": "2021-05-09T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/05/03/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A864",
            "title": "思路探讨(六十四) 习惯养成-阅读技巧-要事优先",
            "summary": "思路 随想 理念 逻辑 人生哲学",
            "content_text": "看到了越来越多人的努力和奋进，因此不要以为自己是最努力的那个。当然努力只是开始，为了能有一个好的结果，我们不只是努力就够了，还要有目标和策略。人总是对自己当前的能力高估，对自己的未来低估。这是自然反应，反人性的。为了能做反人性的事做的更好，我们需要形成好习惯，这样才能在反人性的事情上，做起来更容易些。最近开始整理读书技巧，以前看过《如何有效阅读一本书》改进了下自己在阅读时的习惯和技巧，现在正在看《如何阅读一本书》，前一本是日本人写的，后一本是美国人写的，两本书的风格不同，但都挺有用的，我把两本书结合起来，巩固自己的阅读技巧，这对自己巩固学习基础建设很重要，磨刀不误砍柴工。最后聊下事情的重要性，我发现生活中90%的事情都是紧急但不重要的，而10%是重要的事情却常常被我们以各种理由搁置。因此我们常常做的都是无用功，做这些无用功的理由通常是比较荒唐的，但当事人以及周围的人听起来却是理所当然。这些，养成好习惯、做重要的事情、巩固基础技巧、历史和人性，我将继续总结，继续说出我的理解，继续分享。",
            "content_html": "<p>看到了越来越多人的努力和奋进，因此不要以为自己是最努力的那个。</p><p>当然努力只是开始，为了能有一个好的结果，我们不只是努力就够了，还要有目标和策略。</p><p>人总是对自己当前的能力高估，对自己的未来低估。这是自然反应，反人性的。</p><p>为了能做反人性的事做的更好，我们需要形成好习惯，这样才能在反人性的事情上，做起来更容易些。</p><p>最近开始整理读书技巧，以前看过《如何有效阅读一本书》改进了下自己在阅读时的习惯和技巧，现在正在看《如何阅读一本书》，</p><p>前一本是日本人写的，后一本是美国人写的，两本书的风格不同，但都挺有用的，</p><p>我把两本书结合起来，巩固自己的阅读技巧，这对自己巩固学习基础建设很重要，磨刀不误砍柴工。</p><p>最后聊下事情的重要性，我发现生活中90%的事情都是紧急但不重要的，而10%是重要的事情却常常被我们以各种理由搁置。</p><p>因此我们常常做的都是无用功，做这些无用功的理由通常是比较荒唐的，但当事人以及周围的人听起来却是理所当然。</p><p>这些，养成好习惯、做重要的事情、巩固基础技巧、历史和人性，我将继续总结，继续说出我的理解，继续分享。</p>",
            "url": "http://www.luzexi.com/2021/05/03/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A864",
            
            
            
            
            
            "date_published": "2021-05-03T00:00:00+08:00",
            "date_modified": "2021-05-03T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/04/27/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A863",
            "title": "思路探讨(六十三) 投资-工作-生活",
            "summary": "思路 随想 理念 逻辑 人生哲学",
            "content_text": "假如你的股票投资，已经有100万，并且已经盈利了50%，你在这场投资游戏中还会慌吗？如果投资注定是一场漫长的游戏，那么你该如何正确的面对一时的亏损，面对投资标的的选择？投资本身就反应了我们的价值观，这种价值观最后都会反应到，投资回报中，从长期来看就是这样的。当然这中间，波动会很大，你会意外的发现买了后就涨或跌，如果你需要安全感，就不要做投资，投资本身就是打破安全感的事情。投资也好，工作也好，生活也好，其实都是一个道理。最终你会发现，其实事情可以很简单，做好人做好事，多帮助他人，这样我们保持下去，生活就会对我们好。但因为时间过于漫长了，效果也很难在短时间见到，所以很多人都想走捷径，最终走了偏门。其实最艰难的道路就是捷径，那就是做好自己，帮助他人，一步一个脚印脚踏实地向前走。再看看自己的平衡轮，将自己的轮子平衡一下，这样就可以走的更稳一些，同时稳的同时也更快了。",
            "content_html": "<p>假如你的股票投资，已经有100万，并且已经盈利了50%，你在这场投资游戏中还会慌吗？</p><p>如果投资注定是一场漫长的游戏，那么你该如何正确的面对一时的亏损，面对投资标的的选择？</p><p>投资本身就反应了我们的价值观，这种价值观最后都会反应到，投资回报中，从长期来看就是这样的。</p><p>当然这中间，波动会很大，你会意外的发现买了后就涨或跌，如果你需要安全感，就不要做投资，投资本身就是打破安全感的事情。</p><p>投资也好，工作也好，生活也好，其实都是一个道理。</p><p>最终你会发现，其实事情可以很简单，做好人做好事，多帮助他人，这样我们保持下去，生活就会对我们好。</p><p>但因为时间过于漫长了，效果也很难在短时间见到，所以很多人都想走捷径，最终走了偏门。</p><p>其实最艰难的道路就是捷径，那就是做好自己，帮助他人，一步一个脚印脚踏实地向前走。</p><p>再看看自己的平衡轮，将自己的轮子平衡一下，这样就可以走的更稳一些，同时稳的同时也更快了。</p>",
            "url": "http://www.luzexi.com/2021/04/27/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A863",
            
            
            
            
            
            "date_published": "2021-04-27T00:00:00+08:00",
            "date_modified": "2021-04-27T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/04/18/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A111",
            "title": "给女儿的信(十一) 时间很重要",
            "summary": "女儿 教育 亲情",
            "content_text": "Hi Sharon，Anne，爸爸好想你们。没过几天没看到你们就很想你们。Sharon生病了还吐了，爸爸心疼你，要保护好自己的身体哦。Anne也是，在姐姐生病时要照顾好姐姐和妈妈，帮助妈妈一起照顾好姐姐，大家一起对抗病魔哈。最近爸爸在抓紧时间学习，爸爸发现时间对人很重要。假如我们的时间用不完的话，我们就能做很多我们想做但又没时间做的事情，比如锻炼健身、看书、写文章、去旅行看看世界等。如果爸爸有用不完的时间的话，爸爸就能一边跟你们在一起玩，又一边能学习和工作了。可是时间是有限的，爸爸1天就24个小时，除去睡觉吃饭休息，满打满算也就只有12个小时的时间。为了赚钱爸爸又要把12个小时里的8个小时分给公司，帮公司干活，剩下的4个小时，爸爸要学习新的知识，还要和妈妈聊天，要去奶奶家看奶奶，还要和你们玩，时间实在不够用。所以爸爸很珍惜时间，每天精打细算的花时间，好想让每一分钟的时间都用在刀口上。为了能把所有花时间做过的事情都保存下来，爸爸把每件事都记录了下来，这样就可以保存爸爸做过的每一件事。就好像时间停留在了那个点上一样，所有做过的事情都停留在了每个时间点上。以后再翻开这些记录的文章去回忆时，一下子就能记起来当时发生的环境和心情了，是不是很好：）为了精打细算的花时间，爸爸给自己定了计划，爸爸每年都给自己定一个大的计划，然后把大的计划拆分成很多很多份，直到爸爸知道每天应该干什么，当爸爸知道每天都该做什么的时候，做每件事的时候都会觉得非常有意义。爸爸相信只要每天不断学习，不断进步，这些计划和目标都会慢慢变成现实的。给爸爸加油喔~喜欢你们Sharon和Anne，我们一起加油，我们一家人都很优秀，继续加油。",
            "content_html": "<p>Hi Sharon，Anne，爸爸好想你们。没过几天没看到你们就很想你们。</p><p>Sharon生病了还吐了，爸爸心疼你，要保护好自己的身体哦。Anne也是，在姐姐生病时要照顾好姐姐和妈妈，帮助妈妈一起照顾好姐姐，大家一起对抗病魔哈。</p><p>最近爸爸在抓紧时间学习，爸爸发现时间对人很重要。</p><p>假如我们的时间用不完的话，我们就能做很多我们想做但又没时间做的事情，比如锻炼健身、看书、写文章、去旅行看看世界等。</p><p>如果爸爸有用不完的时间的话，爸爸就能一边跟你们在一起玩，又一边能学习和工作了。</p><p>可是时间是有限的，爸爸1天就24个小时，除去睡觉吃饭休息，满打满算也就只有12个小时的时间。</p><p>为了赚钱爸爸又要把12个小时里的8个小时分给公司，帮公司干活，剩下的4个小时，爸爸要学习新的知识，还要和妈妈聊天，要去奶奶家看奶奶，还要和你们玩，时间实在不够用。</p><p>所以爸爸很珍惜时间，每天精打细算的花时间，好想让每一分钟的时间都用在刀口上。</p><p>为了能把所有花时间做过的事情都保存下来，爸爸把每件事都记录了下来，这样就可以保存爸爸做过的每一件事。</p><p>就好像时间停留在了那个点上一样，所有做过的事情都停留在了每个时间点上。以后再翻开这些记录的文章去回忆时，一下子就能记起来当时发生的环境和心情了，是不是很好：）</p><p>为了精打细算的花时间，爸爸给自己定了计划，爸爸每年都给自己定一个大的计划，然后把大的计划拆分成很多很多份，直到爸爸知道每天应该干什么，当爸爸知道每天都该做什么的时候，做每件事的时候都会觉得非常有意义。</p><p>爸爸相信只要每天不断学习，不断进步，这些计划和目标都会慢慢变成现实的。给爸爸加油喔~</p><p>喜欢你们Sharon和Anne，我们一起加油，我们一家人都很优秀，继续加油。</p>",
            "url": "http://www.luzexi.com/2021/04/18/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A111",
            
            
            
            
            
            "date_published": "2021-04-18T00:00:00+08:00",
            "date_modified": "2021-04-18T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/04/18/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A862",
            "title": "思路探讨(六十二) 知识的深度与广度",
            "summary": "思路 随想 理念 逻辑 人生哲学",
            "content_text": "知识的深度和广度都是非常重要的，没有一定说，只做某个方向一定能成，或者说只要涉猎足够广一定能成事。很多有知识深度的人，特别是某个专业领域特别强的人，会去鄙视那些专业程度不深但知道很多个领域知识的人。例如学者就常看不上商人，学者有足够深的专业，而商人则有足够广的领域涉猎。其实这种思维是非常错误的，也是狭隘的，其本身的做法也是不够明智的。实际上深度和广度是兼并的，知识的深度支撑了广度，广度又回馈了深度，这样深度和广度相辅相成的才是比较好的模式，这也是人们口中常说的“一专多精”的意义所在。就像你懂的事情越多，越能对事物提出不同的观点那样。不同领域间的知识常以惊人的方式互相取长补短。毕竟，创造的核心是将从未有过交集的东西融合在一起。如果你接受了人需要博识的观点后，学会了微精通，那么你就能从多种微精通实践中获得了思维流畅性，自然而然就从封闭转换到了开放。这是种普遍的生活观，开放地拥抱生活中的各种奇迹机遇，你就会变得乐于学习了，因为你知道了获取专业知识的微精通的奥秘，不再有被其他领域拒之门外的挫败感。那时你就会变得信心十足、无所畏惧，这是任何境遇下都需要的优秀品质。",
            "content_html": "<p>知识的深度和广度都是非常重要的，没有一定说，只做某个方向一定能成，或者说只要涉猎足够广一定能成事。</p><p>很多有知识深度的人，特别是某个专业领域特别强的人，会去鄙视那些专业程度不深但知道很多个领域知识的人。例如学者就常看不上商人，学者有足够深的专业，而商人则有足够广的领域涉猎。其实这种思维是非常错误的，也是狭隘的，其本身的做法也是不够明智的。</p><p>实际上深度和广度是兼并的，知识的深度支撑了广度，广度又回馈了深度，这样深度和广度相辅相成的才是比较好的模式，这也是人们口中常说的“一专多精”的意义所在。</p><p>就像你懂的事情越多，越能对事物提出不同的观点那样。不同领域间的知识常以惊人的方式互相取长补短。毕竟，创造的核心是将从未有过交集的东西融合在一起。</p><p>如果你接受了人需要博识的观点后，学会了微精通，那么你就能从多种微精通实践中获得了思维流畅性，自然而然就从封闭转换到了开放。</p><p>这是种普遍的生活观，开放地拥抱生活中的各种奇迹机遇，你就会变得乐于学习了，因为你知道了获取专业知识的微精通的奥秘，不再有被其他领域拒之门外的挫败感。那时你就会变得信心十足、无所畏惧，这是任何境遇下都需要的优秀品质。</p>",
            "url": "http://www.luzexi.com/2021/04/18/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A862",
            
            
            
            
            
            "date_published": "2021-04-18T00:00:00+08:00",
            "date_modified": "2021-04-18T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/04/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B021",
            "title": "读书笔记(二十一) 《金字塔原理》上",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：很多同学在大学里就已经学习过《金字塔原理》，这本书主要讲了如何借鉴几个经典的框架来解决和表达问题。看了这本书后，发现书中说的东西非常好，于是我在现实生活和工作中也落地实践了许多，基于这些理论和实践经验，我想对这本书中所描述的知识做一次全面的回顾和总结。疑问：为了能够更好的理解这本书，我同时给自己提了很多疑问，这让我在看书的同时有了目标性。我也想通过疑问-解答的方式来总结这本书的内容，因为这种方式更能让人接受。为什么说是金字塔？（让人感觉很势利）为什么要用框架去解决问题？会不会让做事变的很死板？有哪些比较经典的框架？它们具体是怎么去做表达和解决问题的？概述：金字塔原理是一种突出重点、逻辑清晰、层次分明、简单易懂的思考方式和沟通方式。它的基本结构是：结论先行，以上统下，归类分组，逻辑递进。先重要后次要，先总结后具体，先框架后细节，先结论后原因，先结果后过程，先论点后论据。它能够帮助我们挖掘受众的意图、需求点、利益点、关注点、兴趣点。也能让我们在沟通时达到，观点鲜明、重点突出、思路清晰、层次分明、简单易懂，让对方有兴趣、能理解、记得住。其具体做法是，自上而下的表达，自上而下的思考，纵向总结概括，横向归类分组，序言讲故事，标题提炼思想精华。已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484575&amp;idx=1&amp;sn=2d34a8dbcfb9c1210fa3e0ae5b0c13fb&amp;chksm=fc226198cb55e88e892b31fa217da8e11e8eb6bfbcbd74805e610b706f69c4e776cb7da9b40f&amp;token=673219380&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h3 id=\"背景\">背景：</h3><p>很多同学在大学里就已经学习过《金字塔原理》，这本书主要讲了如何借鉴几个经典的框架来解决和表达问题。</p><p>看了这本书后，发现书中说的东西非常好，于是我在现实生活和工作中也落地实践了许多，基于这些理论和实践经验，我想对这本书中所描述的知识做一次全面的回顾和总结。</p><h3 id=\"疑问\">疑问：</h3><p>为了能够更好的理解这本书，我同时给自己提了很多疑问，这让我在看书的同时有了目标性。我也想通过疑问-解答的方式来总结这本书的内容，因为这种方式更能让人接受。</p><p>为什么说是金字塔？（让人感觉很势利）为什么要用框架去解决问题？会不会让做事变的很死板？有哪些比较经典的框架？它们具体是怎么去做表达和解决问题的？</p><h3 id=\"概述\">概述：</h3><p>金字塔原理是一种突出重点、逻辑清晰、层次分明、简单易懂的思考方式和沟通方式。</p><p>它的基本结构是：结论先行，以上统下，归类分组，逻辑递进。先重要后次要，先总结后具体，先框架后细节，先结论后原因，先结果后过程，先论点后论据。</p><p>它能够帮助我们挖掘受众的意图、需求点、利益点、关注点、兴趣点。也能让我们在沟通时达到，观点鲜明、重点突出、思路清晰、层次分明、简单易懂，让对方有兴趣、能理解、记得住。其具体做法是，自上而下的表达，自上而下的思考，纵向总结概括，横向归类分组，序言讲故事，标题提炼思想精华。</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484575&amp;idx=1&amp;sn=2d34a8dbcfb9c1210fa3e0ae5b0c13fb&amp;chksm=fc226198cb55e88e892b31fa217da8e11e8eb6bfbcbd74805e610b706f69c4e776cb7da9b40f&amp;token=673219380&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/04/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B021",
            
            
            
            
            
            "date_published": "2021-04-11T00:00:00+08:00",
            "date_modified": "2021-04-11T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/04/03/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A861",
            "title": "思路探讨(六十一) 《原则》摘录",
            "summary": "思路 随想 理念 逻辑 人生哲学",
            "content_text": "最近看了《原则》一书的前半部分，讲述的是桥水创始人瑞.达利欧的个人经历。这本书2019年6月份就买了，一直没空看，但我知道它是一本好书，直到2021年过年时才从箱底里翻出来看。（我时常翻箱底，因为我知道很多东西被我遗忘在箱底了，我时常要去翻它们，这会让我有很多惊喜）本来这周想用自己的小脑袋思考弄清楚点事情，可惜在电脑前发呆了1个小时也没写出一个字，个人思考的力量毕竟有限，所以还是看书吧，站在巨人的肩膀上，让巨人带你领略风景。最近现在每次看书都会画线并记录自己的感受，就讲讲我记录的笔记吧。原文：我一直记不住没有内在逻辑的东西（如电话号码），而且我不喜欢听从别人的指示。同时，我的好奇心很强，喜欢自己把事情弄清楚，不过当时我并不像现在这么清楚地知道这一点。笔记：我也一样，记不住没有逻辑的东西，喜欢自主的想法，不喜欢被动。原文：我一直不明白，除了能得到母亲的认可之外，上学上得好还能给给我什么。笔记：这让我更加慎重的考虑我的孩子的成长和教育，如何才能让她们更有自主的学习动力。原文：与失败比起来，我对乏味和平庸的恐惧要严重得多。对我而言，很好的事要比糟糕的事好，糟糕的事要比平庸的事好，因为糟糕的事至少给生活增加了滋味。笔记：我不想要乏味和平庸，即使失败也比平庸和乏味来的好。失败还意味着拼搏过，平庸和乏味基本上都是由于躺在舒适区不想动的缘故。原文：经历这些让我认识到，尽管几乎所有人都会估计未来和当下大同小异，但未来通常和当下大相径庭。笔记：未来和当下总是出乎人们的意料，相差比较大。原文：这个现实传递给我的信息时：你最好弄明白其他时间，其他地点，其他人身上发生的事，因为如果你不这么做，你就不知道这些事情会不会发生在你身上，而且一旦发生在你身上，你将不知道如何应对。笔记：弄明白历史能更清晰的看清当下自己身上正在发生的事情。原文：哈佛教学：没有教师在黑板前告诉我们什么东西要记住，也没有考试测试我们有没有记住。相反，教师给我们的都是真实的案例研究，让我们进行阅读与分析。然后我们分成小组自由讨论，加入我们处在和案例中的人相同的情况下，我们会怎么做。这正是我喜欢的教学方式。笔记：开放式教育，自主阅读，案例分析，讨论，实践。原文：你必须既有防御心又有进攻心。如果没有进攻心，你就赚不到钱，而如果没有防御心，你的钱就保不住。笔记：进攻和防御最好兼备原文：把赚钱作为你的目标是没有意义的，因为金钱并没有固有的价值，金钱的价值来自它能买到的东西，但金钱并不能买到一切。更聪明的做法是，先确定你真正想要什么，你真正的目标是什么，然后想想你为了得到这些目标需要做什么。笔记：真正想要什么，制定目标，目标不是钱，而是自己的想法，用自己的视野去实现，并拓展自己的视野。原文：在考虑有意义的人际关系与金钱相比的重要性时，很明显，人际关系更重要，因为一种有意义的人际关系时无价的，我用再多的金钱也买不到比这更有价值的东西。有意义的工作和有意义人际关系都是我的主要目标，我做的一切事情都是为了实现这两个目标。赚钱只是其附带结果。笔记：有意义的工作和有意义的人际关系，是核心。围绕着这个两个有意义，人生才真正有意义。有意义的工作指自己想做的工作，有意义人人际关系，指与周围同事、家人、朋友建立良好的关系。…还有很多，摘录的只是百分之一，这本书不错，摘录部分内容希望能给大家带来一点启示。",
            "content_html": "<p>最近看了《原则》一书的前半部分，讲述的是桥水创始人瑞.达利欧的个人经历。</p><p>这本书2019年6月份就买了，一直没空看，但我知道它是一本好书，直到2021年过年时才从箱底里翻出来看。（我时常翻箱底，因为我知道很多东西被我遗忘在箱底了，我时常要去翻它们，这会让我有很多惊喜）</p><p>本来这周想用自己的小脑袋思考弄清楚点事情，可惜在电脑前发呆了1个小时也没写出一个字，个人思考的力量毕竟有限，所以还是看书吧，站在巨人的肩膀上，让巨人带你领略风景。</p><p>最近现在每次看书都会画线并记录自己的感受，就讲讲我记录的笔记吧。</p><p>原文：我一直记不住没有内在逻辑的东西（如电话号码），而且我不喜欢听从别人的指示。同时，我的好奇心很强，喜欢自己把事情弄清楚，不过当时我并不像现在这么清楚地知道这一点。</p><h3 id=\"笔记我也一样记不住没有逻辑的东西喜欢自主的想法不喜欢被动\">笔记：我也一样，记不住没有逻辑的东西，喜欢自主的想法，不喜欢被动。</h3><p>原文：我一直不明白，除了能得到母亲的认可之外，上学上得好还能给给我什么。</p><h3 id=\"笔记这让我更加慎重的考虑我的孩子的成长和教育如何才能让她们更有自主的学习动力\">笔记：这让我更加慎重的考虑我的孩子的成长和教育，如何才能让她们更有自主的学习动力。</h3><p>原文：与失败比起来，我对乏味和平庸的恐惧要严重得多。对我而言，很好的事要比糟糕的事好，糟糕的事要比平庸的事好，因为糟糕的事至少给生活增加了滋味。</p><h3 id=\"笔记我不想要乏味和平庸即使失败也比平庸和乏味来的好失败还意味着拼搏过平庸和乏味基本上都是由于躺在舒适区不想动的缘故\">笔记：我不想要乏味和平庸，即使失败也比平庸和乏味来的好。失败还意味着拼搏过，平庸和乏味基本上都是由于躺在舒适区不想动的缘故。</h3><p>原文：经历这些让我认识到，尽管几乎所有人都会估计未来和当下大同小异，但未来通常和当下大相径庭。</p><h3 id=\"笔记未来和当下总是出乎人们的意料相差比较大\">笔记：未来和当下总是出乎人们的意料，相差比较大。</h3><p>原文：这个现实传递给我的信息时：你最好弄明白其他时间，其他地点，其他人身上发生的事，因为如果你不这么做，你就不知道这些事情会不会发生在你身上，而且一旦发生在你身上，你将不知道如何应对。</p><h3 id=\"笔记弄明白历史能更清晰的看清当下自己身上正在发生的事情\">笔记：弄明白历史能更清晰的看清当下自己身上正在发生的事情。</h3><p>原文：哈佛教学：没有教师在黑板前告诉我们什么东西要记住，也没有考试测试我们有没有记住。相反，教师给我们的都是真实的案例研究，让我们进行阅读与分析。然后我们分成小组自由讨论，加入我们处在和案例中的人相同的情况下，我们会怎么做。这正是我喜欢的教学方式。</p><h3 id=\"笔记开放式教育自主阅读案例分析讨论实践\">笔记：开放式教育，自主阅读，案例分析，讨论，实践。</h3><p>原文：你必须既有防御心又有进攻心。如果没有进攻心，你就赚不到钱，而如果没有防御心，你的钱就保不住。</p><h3 id=\"笔记进攻和防御最好兼备\">笔记：进攻和防御最好兼备</h3><p>原文：把赚钱作为你的目标是没有意义的，因为金钱并没有固有的价值，金钱的价值来自它能买到的东西，但金钱并不能买到一切。更聪明的做法是，先确定你真正想要什么，你真正的目标是什么，然后想想你为了得到这些目标需要做什么。</p><h3 id=\"笔记真正想要什么制定目标目标不是钱而是自己的想法用自己的视野去实现并拓展自己的视野\">笔记：真正想要什么，制定目标，目标不是钱，而是自己的想法，用自己的视野去实现，并拓展自己的视野。</h3><p>原文：在考虑有意义的人际关系与金钱相比的重要性时，很明显，人际关系更重要，因为一种有意义的人际关系时无价的，我用再多的金钱也买不到比这更有价值的东西。有意义的工作和有意义人际关系都是我的主要目标，我做的一切事情都是为了实现这两个目标。赚钱只是其附带结果。</p><h3 id=\"笔记有意义的工作和有意义的人际关系是核心围绕着这个两个有意义人生才真正有意义有意义的工作指自己想做的工作有意义人人际关系指与周围同事家人朋友建立良好的关系\">笔记：有意义的工作和有意义的人际关系，是核心。围绕着这个两个有意义，人生才真正有意义。有意义的工作指自己想做的工作，有意义人人际关系，指与周围同事、家人、朋友建立良好的关系。</h3><p>…</p><h3 id=\"还有很多摘录的只是百分之一这本书不错摘录部分内容希望能给大家带来一点启示\">还有很多，摘录的只是百分之一，这本书不错，摘录部分内容希望能给大家带来一点启示。</h3>",
            "url": "http://www.luzexi.com/2021/04/03/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A861",
            
            
            
            
            
            "date_published": "2021-04-03T00:00:00+08:00",
            "date_modified": "2021-04-03T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/03/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B020",
            "title": "读书笔记(二十) 《目标管理》",
            "summary": "读书 书 看书 读后感",
            "content_text": "背景：机缘巧合从印象笔记中看到目标管理这个课程，也正好契合我最近的理念。我发现学习，工作，生活如果没有目标就很难做的好，同样的人生如果没有目标，就很难保持动力和正确的方向。虽然我一直提倡时间管理，精力管理，但这一切都是为了什么呢？在漫无目的的行动中，常常使我迷茫，因为太枯燥太无聊了，我时常问自己，“这样坚持下去真的有效吗？”于是目标管理映入我的眼帘，以前很排斥的东西，现在变成了我的宝贝。当然事情并没有这么顺利，我发现它需要一个很强大的习惯来支撑它的运作，不过我认定这是个好东西我开始将目标管理付诸于实际生活中，它是一个漫长的练习过程，我希望在学习和实践中不断领悟其精髓，并分享给大家。疑问：我在这次好奇般的学习过程中到底学到了什么呢？我给自己提出了几个疑问，并做了总结和自我解答。我们为什么害怕目标？为什么要目标管理？目标管理的精髓是什么？它有哪些策略可以用？分别是什么？内容：我们对目标管理其实有很深的偏见。因为无论是工作还是学校学习，都会有上级和老师给我们的目标，每次这种目标都会给我们很大的压力。甚至很多时候因为目标太大，压力太重，压垮了我们。所以我们大部分人都很害怕‘目标’这两个字，很少有人能真正主动去接受它、拆解它、分析它。我也是一样，只是在学习过程中，我渐渐了解了如何应对，慢慢的熟知了它，并且喜欢上了它。这里我想所讲的目标管理，都是我们自己主动发出的目标，而不是别人给予我们的目标。因为这两者有很大的不同，一个是你自己想要的，另一个则是别人强加给你的。至于怎么把别人强加给你的目标变成自己的目标则是另外一回事了。目标管理有一个成功方程式，即，目标达成 = 目标 * 策略 * （动力 - 阻力）方程式中每个词语都是关键，目标、策略、动力、阻力。下面我们就来 一 一 分解他们。首先，目标制定非常关键，它是所有一切的前提，好的目标让我们动力满满，而差的目标让我们沮丧。定目标的时候，我们要考虑自己的力量，不能超过自己能力范围太多，这样会让我们受到很大的挫败感而不敢前进，也不能在自己的能力范围之内，会让我们觉得很无聊。目标制定的时候要有延展性，就是在原来可达到的目标之上延展30-50%左右，这样目标会更加合理些。如果原来完全没接触过的，则要把目标定的低一些，以免挫败感太强烈。其次，目标要符合我们的价值观。价值观反应了我们的个性，如果不符合我们的价值观，我们在目标的执行过程中也很难进行下去。其根本原因通常是跟我们的价值观相反的东西，我们很难坚持。没有绝对好的价值观，价值观通常不是我们想要的东西，而是反应我们性格的东西，你是什么样的人，就会有什么样的价值观。接着，目标定制要有符合SMART原则，即：要具体的，可衡量的，可达到的，和其他目标有关联的。最后，长远目标要拆分成很多小而简单的目标，比如1年的目标要拆分到月目标，再拆分到周目标，再细分到每天所要做的事情上来。也只有这样才能让自己感到安全，把事情落地到每天的任务上才能让我们有实实在在的安全感，而不会只是远远得望着这个1整年的大目标而感到害怕。当然我们在制定目标的时候，最好不要只制定单方面的目标，因为单一的目标会让自己很枯燥，也无法平衡人生的这辆车。我们的目标应该比较多元化，这些目标加起来应该要平衡我们人生的各个方向，包括，精神上的、思维上的、情绪、身体、婚姻、亲情、人际、专业、娱乐、财务。只有这样才能让我们能感到，是整辆车在不断前进，而不单单是单个轮子在走，整辆车则停滞不前。下面是一些在目标执行过程中的策略，前半部分是我在实践过程中的一些体会，后半部分是目标管理的学习，有助于我们更好的坚持下去，并最终完成目标。这是一个过程，首先我们要享受过程，在过程中学习和进步，其次我们要不断调整自己，努力让自己达成目标获得成就。这不仅能让我们达成目标获得成就，更重要的是在未来的日子中，我们能活的更加自信和洒脱，也许无法让你财务自由，但肯定能让你精神自由。策略1观察自己记录生活中的每一样事情，这样可以方便我们统计自己的行为。由于我们很难看清自己，自己的日常生活中觉醒过来是很难的，所以将自己生活中的每一件事记录下来，再隔1周去看这些数据，会有惊人的发现。发现了自己的问题，并寻求改善，再记录，在分析，再改善，形成一种良性循环。记录的方式有两种第一种是，对某些自己在意的事做数据记录，并统计，最后通过数据分析，看到自己的问题，再寻找解决办法第二种是，把事情的前因后果，和自己的所思所想，记录下来，通过复盘的形式寻找调整方案策略2强化习惯在做了某件事之后，如果得到一个你很喜欢的结果，那么这件事做多了，就会被强化。其结果可以是物品、赞扬、活动等，因此我们这里最应该研究的是如何奖励自己。研究奖励时应该注意，做完某件事后，会很愉快，这个愉快到底是从哪里来才是关键。下面些奖励的例子娱乐：看电影，爬山，游乐场，旅行，玩游戏感情：和家人玩，和朋友玩，和闺蜜玩物品：买电子产品，买家具电器，买衣服鞋子社交：得到赞扬，受人关注食物：美食，巧克力策略3列出阻力，并且列出应对方案列出所有可能阻碍自己计划进行的障碍，并想出应对方案当预料到的阻碍来临时，用自己设计好的应对方案去应对。如果不行，则再更换其他方案，直到能应对为止。当自己实行应对方案时，有没有效果都要记录下来。这能够不断记得自己的目标，也能看到自己的进步。策略4记录反馈数据前面说，我们的目标必须是可衡量的，也就是说，每一步必须都是可用数据表现出来了。在每次小目标完成时都要把数据记录下来，这样可以及时帮助我们调整计划。比如，能看到我们最近的目标进度，情绪变化等等，从而调整新的计划和应对方案。策略5和自己签约这是一个增强动力的方法。把目标想象成一个项目，甲方乙方都是自己，作为甲方，我要监督项目的进展，把控项目的质量，在项目完成后给予报酬。作为乙方，你要遵守合约的约定，调动资源，合理安排进度，排除障碍，保证高质量的完成项目。用这种很正式的书面约定，签字画押，将自己与目标绑定。一个人对目标承诺度越高，他完成目标的可能性就越大。这样就能让自己非常重视目标，也就有了动力。1.合约能让自己明确这个目标对自己有多重要。2.合约会加强你对目标成功的期待。它会让你看到目标实现后的样子，就好像前方的苹果树，你能清晰的看到它。3.合约是一种自我约束，尽一切努力去完成约定，不能随便毁约，这就是契约精神。合约内容1.把SMART目标写在合约里。2.写下这个目标对你的重要性，1-5分。3.把目标拆分成小目标也写在合约里，每个小目标的内容，阶段性的目标，周目标，这样就能减少自己对目标的恐惧。4.把计划写在合约里，受到阻碍时的应对方案。5.在合约里写明奖励机制，对小目标、阶段性目标也要有奖励。6.写下你曾经经历过的依次成功经历，写出自己的哪些特质和能力让自己成功。7.写下自己对合约的承诺，签字画押，并贴在墙上，同时把合约给重要的人看，从而获得他们的支持，亲人和朋友对你的支持是非常重要的。策略 6自我关怀大多数人总是在批评自己，而不是在关怀自己自我批评是我们每个人都很熟悉和擅长的一件事。常常，当我们没有达成预想的目标时，或者经历失败的时候，我们总是会对自己说，“我就是不如别人”，“我真的很失败”，“我怎么就是做不好呢”，然后你可能会对自己说，“你应该再努力点”，“你不能总是这样懒惰”，“你再不努力就没有机会了”，我们以为只有不断鞭策自己、不断找出问题并改正，才能够进步，才能够达成目标。这其实是我们自身启动了防御系统，通过自我批评的防御系统来改变自己，通过改变自己，让自己变得更加安全。这个防御系统有很多负面作用，它会让我们出现三种常见表现，第一，战斗，猛烈的批评自己，第二，僵住，不停反思自己为什么会这样，以后该怎么做，第三，逃跑，逃避所有可能的失败，一个人呆在安全的地方。它对我们实现目标有相反的作用，会导致我们降低自信，增加焦虑感，甚至导致抑郁，这些会让我们放弃目标的概率变的更大。自我关怀则不是，它可以让我们更好的坚持目标。它最重要的作用是，让我们感到放松和安全，我们就像怀抱里获得温暖的孩子那样，当我们获得了力量，就不会轻易放弃我们的目标了。第一个方法，写自我关怀日记日记分为三部分：此时此刻，连接，爱。1.不带任何评价的写出此时此刻的感受，2.要意识到世界上每个人都在经历挫折和痛苦，3.把自己当做好朋友用关怀的语气给自己写些温暖的话语。第二个方法，身体触摸原理是，当母亲轻抚孩子的头，轻拍孩子的肩膀，拥抱孩子的时候，孩子都会感到安全和轻松。同样的，我们对自己做类似的触摸时，也会感到被关爱，这样身体和精神都会放松下来。找一个能让你感到安全、感到被支持的身体姿势，用这个姿势来安慰自己。例如：把一只手放在心上双手交叠在心上一只手放在心上，一只手放在肚子上两只手交叠放在肚子上一只手或两只手放在脸颊上交叉胳膊，给自己一个温柔的拥抱把手放在大腿上，轻轻地拍一只手轻拍另一只收第三个方法，对自己说善意的话语在心里，或者对着镜子里的自己说，让自己感到安全、温暖、被支持的话语。这个方法可以降低我们内在批评的背景声音，从而减少内在冲突，让我们在实现目标的路上更加平静和自信。善意的话语有点像是祝福自己的话语，“愿我平安、愿我平静、愿我勇敢”找善意的话语，聚焦一个问题：我需要什么？然后从内心深处的需要找适合自己的话语。找到内心需要，而不是想要，需要是脖子以下的需要，包括，被认可、被欣赏、被爱、被看见、被听到、被保护、被珍惜、被尊重。去发现和找到适合自己的，当自己情绪低落的时候，希望别人对你说什么？哪些话能够安慰到你，然你平静下来或振作起来？把这些话记录下来，作为自己的“善意话语库”，供自己随时使用。这三个方法要勤加练习，自我关怀让阻碍我们实现目标的最大敌人（我们自己），变成帮助我们实现目标的最好盟友。策略7建立自我奖励机制1.列出自我奖励清单    头脑风暴出所有让你感到高兴、满足、愉快的事物和活动。        想象奖励：达成目标后的美好场景，让自己产生愉悦的感觉        口头奖励：当做了符合目标的行为后，对自己口头的表扬2.行为和奖励配对    即，做了什么，就会获得什么奖励，这样就能强化我们的行为，让自己更加喜欢去做这件事。经常让自己去想象获得奖励时的场景，这不仅会对你现在的行为有好处，而且会提醒和强化你的长期目标是什么，让你更聚焦于自己的目标。口头奖励加强的自我关怀，替代了破坏性强的自我批评，例如达成小目标后对自己说“你能这样做很棒”，替代了破坏性强的自我批评“这没什么大不了的，别人都比你做的好”我们经常赞扬和鼓励自己，就会更愿意去做自己期待的事情。用奖励强化行为，完成什么事后，获得什么奖励，这种强化机制，让自己更有动力去执行这件事。奖励强化行为可以用个方法更有效，即代币机制：1.给期待的行为制定相应的分值，2.积累到一定分值可以获得奖励，3.给每个奖励都标上需要的分值，4.用代币机制去获得这个奖励可以用这种方式为自己建立良好的习惯。执行了什么符合目标的事情，获得多少分值，累积了多少分值，想要获得什么奖励。关键在于记录，记录自己做的事情，并记录分数。自我奖励改善了我和自己的关系，我们犒劳了自己，奖赏了自己，关注自己的需要并满足它们，这些都是滋养自己的事情。让自己（主动让自己，调整自己）进入一个良性的循环中去。专项对策：计划遇阻的对策很多人认为事情的发展是一条直线，其实不是，它是曲折的，不可预测的。大部分人害怕失败，当他们看到失败的可能性时，为了避免彻底失败，干脆主动放弃，逃避失败。大部分人对自己太苛刻，用很多‘必须’和‘应该’来包装自己的计划，一旦计划中断，就会自我攻击，‘你就是不如别人’、‘你就是个三分钟热度的人’、‘你一辈子也就这样了’很多人只关注结果，而不享受过程。当不符合预期的情况出现时，就会因为害怕而夸大可能出现的结果。比如三天不运动就会说，自己的坚持运动的计划破产了。悲观预期削弱了他们前进的动力，无法继续走下去。用ABCDE法，即，A记录客观事实B记录发生后自己的看法C记录行为导致的结果D重新审视自己的看法E计划在新看法下激发新行动因为这事会发生很多次，所以我认为除了这个方法外，我们可以再改进方法，即，记录，统计，总结，制定应对方法。把所有阻碍都记录下来，然后统计原因，总结原因，制定当这些原因发生的时候，我们应该用什么样的方法或技巧去应对。专项对策：计划失败时的对策《终生成长》提到的成长型思维是关键固定型思维，人是天生的，聪明和笨是不无法改变的，人的基因决定了一切，命运是无法改变的，他人的成功对我造成了威胁。成长型思维，人的智力是可以提高的（这会让人产生学习的欲望），人是可以通过努力学习和拼搏改变命运的，遇到困难时迎接挑战面对挫折坚持不懈，努力练习才能熟能生巧，从他人的成功中学到新的知识获得新的灵感。关键是去塑造成长型思维，有哪些方法可以帮助我们塑造成长型思维呢？1.当出现失败时，观察自己的固定型思维在说些什么。把它们写下来，它们可能是“放弃吧，你的能力还做不了这么难的事情”或者“不管你怎么努力，你永远都不可能比别人优秀”2.和自己的固定型思维对话，例如“欢迎你存在，你的存在使得我有对照，可以让我变的更好。让我们来看看能从这次失败中学到什么？我可以做些什么可以让我做得更好些”3.列出具体的调整计划，按照调整计划去行动。这步很重要，是思维到行为落地的过程，只有真正行动起来才算有效调整。也只有真正按调整计划行动起来，成长型思维才算真正建立起来。塑造成长型思维的关键是让自己的关注点，从“我是不是足够好”转变为关注“我还能学到什么东西”，不断从失败中学习成长，让失败成为我们实现目标的加速器。（可以学习下人复盘加速成长）专项对策：意志力意志力包括三种不同级别大小的力量1.我不要2.我要做3.我想要我不要，说的是我为了自身考虑，不要做什么，比如我不要吸烟、我不要玩游戏、我不要吃甜食等。我不要这种力量虽然能够促进自我，但力量太薄弱，人很难用这种力量与自己对抗。我要做，说的是我在事情面前认为自己应该做的，比如我要努力干活，我要努力学习，我要坚持运动。我要做这种力量，虽然比我不要更强大一些，但仍然不受我们控制，不是我们要做就能做到的，时常会遇到我们要做什么但最终还是没有去做或者做不下去的情况。我想要，说的是当自己知道真正的目标的时候，就更有可能拒绝眼前的诱惑，并且会主动去选择那些困难的任务，所以它是前面两种力量的基础，也是根基最深的力量。我想要这种力量，带给你无穷的想象力，无穷的动力，让你能想出各种办法，专心专注的去实现自己的目标。意志力就是去驾驭这三种力量而存在的，如果驾驭的好，它就能帮我们实现目标。意志力也是可以通过练习提高的。提高意志力方案1.运动提高意志力储备运动就是提高意志力储备的最好的方法之一。每天运动一下，可以是10分钟-60分钟之间，不断加强锻炼强度，让自己不断去提高意志力储备。这里提醒大家一句，低强度而持续的锻炼，比高强度但短暂的锻炼有更明显的提高意志力的效果。2.有计划的练习，‘我不要’，‘我要做’，‘我想要’的三种能力1.列出‘我不要’的事情，和，‘我要做’的事情，用任务的方式去做自己给自己规定的事情。    比如，我不要喝咖啡，我不要吸烟，我不要吃甜食。我要每天看书30分钟，我要每天早起，我要每月强制存款3000元，我要每周写篇文章。2.有意识的每天练习‘我不要’和‘我要做’能锻炼自己的意志力，为自己的执行计划打下坚定的基础。    增强这两种力量，对我们实现目标的可能性也就越大。3.练习‘我想要’的力量时，有两个方法，    一是，每天花两分钟在脑海中描绘目标实现后的景象，始终记住自己的目标。    二是，面对诱惑时不马上行动，而是先等10分钟，10分钟里告诉自己真正想要的是什么，让前额皮层开始工作。 通过每天记住自己的目标，诱惑前思考10分钟，来锻炼“我想要”的力量，这样做的同时也会增强“我不要”和“我要做”的力量。给自己未来写信方案我们会把未来的自己想象成完全不同的人，这是一种错误的想象。这会让我们对待未来的自己就像对待陌生人一样。当我们考虑未来的自己的时候，你就好像在想一个陌生人一样。这样的话，你就有很大可能对未来的自己说，“去你的，你会怎么样我一点都不关心”，这会导致我们不关心自己的未来，而被当下的诱惑所屈服。这也是为什么很多人不为未来做准备的原因，因为和陌生人的幸福比起来，我们更关心自己的幸福。比如，不为年老的自己存款，不为了未来更优秀的自己而学习，不为了未来的身体健康而锻炼，不为了更好的节奏而早起等等等。有一种测量方式，叫做‘未来自我的连续性’，这个方法可以帮助我们认识到未来的自己在本质上和现在的自己是一样的。研究表明，那些“未来自我连续性”比较高的人，也就是“现在的我”和“未来的我”圆圈重叠得比较多的人，为未来计划和实施的事情也越多，表象上来看他们的存款更多，储备的知识更丰富，也更加健康，未来也更加美好。当你的两个圈重叠越多时，你就越有可能为未来的目标而努力，你的目标也就越容易实现。我们可以每个月给未来的自己写封信，这有助于我们挡住眼前即时满足的诱惑，而选择更有利于长期目标的行动。信中可以写：想象下自己未来在做什么？他会如何看待现在做出的选择？向未来的自己描述下自己将会怎么做，这是他希望的吗？我对未来有什么希望？我觉得自己会变成什么样？想象未来的自己回头看现在的自己，他会为现在的自己做了什么而表示感激？每个月写一封，这样的信，给未来的自己，让自己和未来的自己越来越亲密，重叠度越来越高，也就越来越喜欢做对自己未来有帮助的事情了。专项对策：时间不够假如你是个‘时间富翁’，有取之不尽的时间，你每天都有很多时间去做你想要做的事情，运动、学习、工作、副业，实现一个个目标，你变得健康、自信、富有。因此关键是时间，和使用时间的效率。时间和效率，两者不同，一个是注重使用情况，另一个注重使用的点。我们知道二八原则，20%的重要的事情，要花费80%的精力是比较高效的，而反过来如果我们把80%的精力花在80%不重要的事情上，效率就会很差。首先把无效时间转变为有效时间。如何转变呢？1.关键在于记录时间2.记录后，分析你的时间，每天无效时间和有效时间分别是多少3.把无效时间转变为以有效时间。其次重注效率。给那些重要但不紧急的目标加上优先级。我们很多时候都是在工作，处理的都是紧急但不重要的事情，导致对我们重要而不紧急的事情被无限期拖延。方法1，每天列个清单，只做5件事，如果出现了更重要的事情，则在5件事中删除一件。这样可以确保我们把时间花在这些重要的事情上。方法2，把紧急但可以缓一缓做的事情放在一个列表里，然后在某段时间批量处理。比如还信用卡，回某人短息，处理邮件，安排会议时间等，放在任务列表里，等到自己手头上的事情结束时，集合起来去完成它们。最后是时间盒子法安排固定一段时间，专门做某事，就叫做时间盒子。比如早上8点到8点半：30分钟写文章，9点到9点半：健身房运动，晚上10点10点半：中午12点到12点半，30分钟看书：梳理一天的生活。把时间固定下来，成为一个时间盒子。这样能确保我们每天都能朝着目标行动。时间盒子要注意两点：1.时间要固定，形成固定节奏后不能随意改动。2.时间盒子内，神圣不可侵犯，关掉手机关掉电视，全心全意做好这件事。",
            "content_html": "<h3 id=\"背景\">背景：</h3><p>机缘巧合从印象笔记中看到目标管理这个课程，也正好契合我最近的理念。我发现学习，工作，生活如果没有目标就很难做的好，同样的人生如果没有目标，就很难保持动力和正确的方向。</p><p>虽然我一直提倡时间管理，精力管理，但这一切都是为了什么呢？在漫无目的的行动中，常常使我迷茫，因为太枯燥太无聊了，我时常问自己，“这样坚持下去真的有效吗？”于是目标管理映入我的眼帘，以前很排斥的东西，现在变成了我的宝贝。</p><p>当然事情并没有这么顺利，我发现它需要一个很强大的习惯来支撑它的运作，不过我认定这是个好东西我开始将目标管理付诸于实际生活中，它是一个漫长的练习过程，我希望在学习和实践中不断领悟其精髓，并分享给大家。</p><h3 id=\"疑问\">疑问：</h3><p>我在这次好奇般的学习过程中到底学到了什么呢？我给自己提出了几个疑问，并做了总结和自我解答。</p><h3 id=\"我们为什么害怕目标\">我们为什么害怕目标？</h3><h3 id=\"为什么要目标管理\">为什么要目标管理？</h3><h3 id=\"目标管理的精髓是什么\">目标管理的精髓是什么？</h3><h3 id=\"它有哪些策略可以用分别是什么\">它有哪些策略可以用？分别是什么？</h3><h3 id=\"内容\">内容：</h3><p>我们对目标管理其实有很深的偏见。因为无论是工作还是学校学习，都会有上级和老师给我们的目标，每次这种目标都会给我们很大的压力。甚至很多时候因为目标太大，压力太重，压垮了我们。所以我们大部分人都很害怕‘目标’这两个字，很少有人能真正主动去接受它、拆解它、分析它。</p><p>我也是一样，只是在学习过程中，我渐渐了解了如何应对，慢慢的熟知了它，并且喜欢上了它。这里我想所讲的目标管理，都是我们自己主动发出的目标，而不是别人给予我们的目标。因为这两者有很大的不同，一个是你自己想要的，另一个则是别人强加给你的。至于怎么把别人强加给你的目标变成自己的目标则是另外一回事了。</p><p>目标管理有一个成功方程式，即，</p><pre><code>目标达成 = 目标 * 策略 * （动力 - 阻力）</code></pre><p>方程式中每个词语都是关键，目标、策略、动力、阻力。下面我们就来 一 一 分解他们。</p><h3 id=\"首先目标制定非常关键它是所有一切的前提好的目标让我们动力满满而差的目标让我们沮丧\">首先，目标制定非常关键，它是所有一切的前提，好的目标让我们动力满满，而差的目标让我们沮丧。</h3><p>定目标的时候，我们要考虑自己的力量，不能超过自己能力范围太多，这样会让我们受到很大的挫败感而不敢前进，也不能在自己的能力范围之内，会让我们觉得很无聊。</p><p>目标制定的时候要有延展性，就是在原来可达到的目标之上延展30-50%左右，这样目标会更加合理些。如果原来完全没接触过的，则要把目标定的低一些，以免挫败感太强烈。</p><h3 id=\"其次目标要符合我们的价值观\">其次，目标要符合我们的价值观。</h3><p>价值观反应了我们的个性，如果不符合我们的价值观，我们在目标的执行过程中也很难进行下去。</p><p>其根本原因通常是跟我们的价值观相反的东西，我们很难坚持。</p><p>没有绝对好的价值观，价值观通常不是我们想要的东西，而是反应我们性格的东西，你是什么样的人，就会有什么样的价值观。</p><h3 id=\"接着目标定制要有符合smart原则即要具体的可衡量的可达到的和其他目标有关联的\">接着，目标定制要有符合SMART原则，即：要具体的，可衡量的，可达到的，和其他目标有关联的。</h3><h3 id=\"最后长远目标要拆分成很多小而简单的目标比如1年的目标要拆分到月目标再拆分到周目标再细分到每天所要做的事情上来\">最后，长远目标要拆分成很多小而简单的目标，比如1年的目标要拆分到月目标，再拆分到周目标，再细分到每天所要做的事情上来。</h3><p>也只有这样才能让自己感到安全，把事情落地到每天的任务上才能让我们有实实在在的安全感，而不会只是远远得望着这个1整年的大目标而感到害怕。</p><p>当然我们在制定目标的时候，最好不要只制定单方面的目标，因为单一的目标会让自己很枯燥，也无法平衡人生的这辆车。我们的目标应该比较多元化，这些目标加起来应该要平衡我们人生的各个方向，包括，精神上的、思维上的、情绪、身体、婚姻、亲情、人际、专业、娱乐、财务。只有这样才能让我们能感到，是整辆车在不断前进，而不单单是单个轮子在走，整辆车则停滞不前。</p><h3 id=\"下面是一些在目标执行过程中的策略前半部分是我在实践过程中的一些体会后半部分是目标管理的学习有助于我们更好的坚持下去并最终完成目标\">下面是一些在目标执行过程中的策略，前半部分是我在实践过程中的一些体会，后半部分是目标管理的学习，有助于我们更好的坚持下去，并最终完成目标。</h3><h3 id=\"这是一个过程首先我们要享受过程在过程中学习和进步其次我们要不断调整自己努力让自己达成目标获得成就\">这是一个过程，首先我们要享受过程，在过程中学习和进步，其次我们要不断调整自己，努力让自己达成目标获得成就。</h3><h3 id=\"这不仅能让我们达成目标获得成就更重要的是在未来的日子中我们能活的更加自信和洒脱也许无法让你财务自由但肯定能让你精神自由\">这不仅能让我们达成目标获得成就，更重要的是在未来的日子中，我们能活的更加自信和洒脱，也许无法让你财务自由，但肯定能让你精神自由。</h3><h3 id=\"策略1\">策略1</h3><p>观察自己</p><p>记录生活中的每一样事情，这样可以方便我们统计自己的行为。由于我们很难看清自己，自己的日常生活中觉醒过来是很难的，所以将自己生活中的每一件事记录下来，再隔1周去看这些数据，会有惊人的发现。</p><p>发现了自己的问题，并寻求改善，再记录，在分析，再改善，形成一种良性循环。</p><p>记录的方式有两种</p><pre><code>第一种是，对某些自己在意的事做数据记录，并统计，最后通过数据分析，看到自己的问题，再寻找解决办法第二种是，把事情的前因后果，和自己的所思所想，记录下来，通过复盘的形式寻找调整方案</code></pre><h3 id=\"策略2\">策略2</h3><h3 id=\"强化习惯\">强化习惯</h3><h3 id=\"在做了某件事之后如果得到一个你很喜欢的结果那么这件事做多了就会被强化\">在做了某件事之后，如果得到一个你很喜欢的结果，那么这件事做多了，就会被强化。</h3><p>其结果可以是物品、赞扬、活动等，因此我们这里最应该研究的是如何奖励自己。</p><p>研究奖励时应该注意，做完某件事后，会很愉快，这个愉快到底是从哪里来才是关键。</p><p>下面些奖励的例子</p><p>娱乐：看电影，爬山，游乐场，旅行，玩游戏感情：和家人玩，和朋友玩，和闺蜜玩物品：买电子产品，买家具电器，买衣服鞋子社交：得到赞扬，受人关注食物：美食，巧克力</p><h3 id=\"策略3\">策略3</h3><p>列出阻力，并且列出应对方案</p><h3 id=\"列出所有可能阻碍自己计划进行的障碍并想出应对方案\">列出所有可能阻碍自己计划进行的障碍，并想出应对方案</h3><h3 id=\"当预料到的阻碍来临时用自己设计好的应对方案去应对\">当预料到的阻碍来临时，用自己设计好的应对方案去应对。</h3><h3 id=\"如果不行则再更换其他方案直到能应对为止\">如果不行，则再更换其他方案，直到能应对为止。</h3><p>当自己实行应对方案时，有没有效果都要记录下来。这能够不断记得自己的目标，也能看到自己的进步。</p><h3 id=\"策略4\">策略4</h3><p>记录反馈数据</p><p>前面说，我们的目标必须是可衡量的，也就是说，每一步必须都是可用数据表现出来了。</p><h3 id=\"在每次小目标完成时都要把数据记录下来这样可以及时帮助我们调整计划\">在每次小目标完成时都要把数据记录下来，这样可以及时帮助我们调整计划。</h3><h3 id=\"比如能看到我们最近的目标进度情绪变化等等从而调整新的计划和应对方案\">比如，能看到我们最近的目标进度，情绪变化等等，从而调整新的计划和应对方案。</h3><h3 id=\"策略5\">策略5</h3><p>和自己签约</p><p>这是一个增强动力的方法。</p><h3 id=\"把目标想象成一个项目甲方乙方都是自己\">把目标想象成一个项目，甲方乙方都是自己，</h3><h3 id=\"作为甲方我要监督项目的进展把控项目的质量在项目完成后给予报酬\">作为甲方，我要监督项目的进展，把控项目的质量，在项目完成后给予报酬。</h3><h3 id=\"作为乙方你要遵守合约的约定调动资源合理安排进度排除障碍保证高质量的完成项目\">作为乙方，你要遵守合约的约定，调动资源，合理安排进度，排除障碍，保证高质量的完成项目。</h3><p>用这种很正式的书面约定，签字画押，将自己与目标绑定。一个人对目标承诺度越高，他完成目标的可能性就越大。</p><p>这样就能让自己非常重视目标，也就有了动力。</p><h3 id=\"1合约能让自己明确这个目标对自己有多重要\">1.合约能让自己明确这个目标对自己有多重要。</h3><h3 id=\"2合约会加强你对目标成功的期待它会让你看到目标实现后的样子就好像前方的苹果树你能清晰的看到它\">2.合约会加强你对目标成功的期待。它会让你看到目标实现后的样子，就好像前方的苹果树，你能清晰的看到它。</h3><h3 id=\"3合约是一种自我约束尽一切努力去完成约定不能随便毁约这就是契约精神\">3.合约是一种自我约束，尽一切努力去完成约定，不能随便毁约，这就是契约精神。</h3><p>合约内容</p><pre><code>1.把SMART目标写在合约里。2.写下这个目标对你的重要性，1-5分。3.把目标拆分成小目标也写在合约里，每个小目标的内容，阶段性的目标，周目标，这样就能减少自己对目标的恐惧。4.把计划写在合约里，受到阻碍时的应对方案。5.在合约里写明奖励机制，对小目标、阶段性目标也要有奖励。6.写下你曾经经历过的依次成功经历，写出自己的哪些特质和能力让自己成功。7.写下自己对合约的承诺，签字画押，并贴在墙上，同时把合约给重要的人看，从而获得他们的支持，亲人和朋友对你的支持是非常重要的。</code></pre><h3 id=\"策略-6\">策略 6</h3><h3 id=\"自我关怀\">自我关怀</h3><p>大多数人总是在批评自己，而不是在关怀自己自我批评是我们每个人都很熟悉和擅长的一件事。</p><p>常常，当我们没有达成预想的目标时，或者经历失败的时候，我们总是会对自己说，“我就是不如别人”，“我真的很失败”，“我怎么就是做不好呢”，然后你可能会对自己说，“你应该再努力点”，“你不能总是这样懒惰”，“你再不努力就没有机会了”，我们以为只有不断鞭策自己、不断找出问题并改正，才能够进步，才能够达成目标。</p><h3 id=\"这其实是我们自身启动了防御系统通过自我批评的防御系统来改变自己通过改变自己让自己变得更加安全\">这其实是我们自身启动了防御系统，通过自我批评的防御系统来改变自己，通过改变自己，让自己变得更加安全。</h3><h3 id=\"这个防御系统有很多负面作用它会让我们出现三种常见表现第一战斗猛烈的批评自己第二僵住不停反思自己为什么会这样以后该怎么做第三逃跑逃避所有可能的失败一个人呆在安全的地方\">这个防御系统有很多负面作用，它会让我们出现三种常见表现，第一，战斗，猛烈的批评自己，第二，僵住，不停反思自己为什么会这样，以后该怎么做，第三，逃跑，逃避所有可能的失败，一个人呆在安全的地方。</h3><h3 id=\"它对我们实现目标有相反的作用会导致我们降低自信增加焦虑感甚至导致抑郁这些会让我们放弃目标的概率变的更大\">它对我们实现目标有相反的作用，会导致我们降低自信，增加焦虑感，甚至导致抑郁，这些会让我们放弃目标的概率变的更大。</h3><p>自我关怀则不是，它可以让我们更好的坚持目标。它最重要的作用是，让我们感到放松和安全，我们就像怀抱里获得温暖的孩子那样，当我们获得了力量，就不会轻易放弃我们的目标了。</p><h3 id=\"第一个方法写自我关怀日记\">第一个方法，写自我关怀日记</h3><p>日记分为三部分：此时此刻，连接，爱。</p><pre><code>1.不带任何评价的写出此时此刻的感受，2.要意识到世界上每个人都在经历挫折和痛苦，3.把自己当做好朋友用关怀的语气给自己写些温暖的话语。</code></pre><h3 id=\"第二个方法身体触摸\">第二个方法，身体触摸</h3><p>原理是，当母亲轻抚孩子的头，轻拍孩子的肩膀，拥抱孩子的时候，孩子都会感到安全和轻松。同样的，我们对自己做类似的触摸时，也会感到被关爱，这样身体和精神都会放松下来。找一个能让你感到安全、感到被支持的身体姿势，用这个姿势来安慰自己。</p><p>例如：</p><pre><code>把一只手放在心上双手交叠在心上一只手放在心上，一只手放在肚子上两只手交叠放在肚子上一只手或两只手放在脸颊上交叉胳膊，给自己一个温柔的拥抱把手放在大腿上，轻轻地拍一只手轻拍另一只收</code></pre><h3 id=\"第三个方法对自己说善意的话语\">第三个方法，对自己说善意的话语</h3><p>在心里，或者对着镜子里的自己说，让自己感到安全、温暖、被支持的话语。这个方法可以降低我们内在批评的背景声音，从而减少内在冲突，让我们在实现目标的路上更加平静和自信。</p><p>善意的话语有点像是祝福自己的话语，“愿我平安、愿我平静、愿我勇敢”找善意的话语，聚焦一个问题：我需要什么？然后从内心深处的需要找适合自己的话语。</p><h3 id=\"找到内心需要而不是想要需要是脖子以下的需要包括被认可被欣赏被爱被看见被听到被保护被珍惜被尊重\">找到内心需要，而不是想要，需要是脖子以下的需要，包括，被认可、被欣赏、被爱、被看见、被听到、被保护、被珍惜、被尊重。</h3><h3 id=\"去发现和找到适合自己的当自己情绪低落的时候希望别人对你说什么哪些话能够安慰到你然你平静下来或振作起来\">去发现和找到适合自己的，当自己情绪低落的时候，希望别人对你说什么？哪些话能够安慰到你，然你平静下来或振作起来？</h3><h3 id=\"把这些话记录下来作为自己的善意话语库供自己随时使用\">把这些话记录下来，作为自己的“善意话语库”，供自己随时使用。</h3><p>这三个方法要勤加练习，自我关怀让阻碍我们实现目标的最大敌人（我们自己），变成帮助我们实现目标的最好盟友。</p><h3 id=\"策略7\">策略7</h3><h3 id=\"建立自我奖励机制\">建立自我奖励机制</h3><p>1.列出自我奖励清单    头脑风暴出所有让你感到高兴、满足、愉快的事物和活动。        想象奖励：达成目标后的美好场景，让自己产生愉悦的感觉        口头奖励：当做了符合目标的行为后，对自己口头的表扬2.行为和奖励配对    即，做了什么，就会获得什么奖励，这样就能强化我们的行为，让自己更加喜欢去做这件事。</p><h3 id=\"经常让自己去想象获得奖励时的场景这不仅会对你现在的行为有好处而且会提醒和强化你的长期目标是什么让你更聚焦于自己的目标\">经常让自己去想象获得奖励时的场景，这不仅会对你现在的行为有好处，而且会提醒和强化你的长期目标是什么，让你更聚焦于自己的目标。</h3><p>口头奖励加强的自我关怀，替代了破坏性强的自我批评，例如达成小目标后对自己说“你能这样做很棒”，替代了破坏性强的自我批评“这没什么大不了的，别人都比你做的好”</p><p>我们经常赞扬和鼓励自己，就会更愿意去做自己期待的事情。</p><p>用奖励强化行为，完成什么事后，获得什么奖励，这种强化机制，让自己更有动力去执行这件事。</p><p>奖励强化行为可以用个方法更有效，即代币机制：</p><pre><code>1.给期待的行为制定相应的分值，2.积累到一定分值可以获得奖励，3.给每个奖励都标上需要的分值，4.用代币机制去获得这个奖励</code></pre><p>可以用这种方式为自己建立良好的习惯。执行了什么符合目标的事情，获得多少分值，累积了多少分值，想要获得什么奖励。关键在于记录，记录自己做的事情，并记录分数。</p><h3 id=\"自我奖励改善了我和自己的关系我们犒劳了自己奖赏了自己关注自己的需要并满足它们这些都是滋养自己的事情\">自我奖励改善了我和自己的关系，我们犒劳了自己，奖赏了自己，关注自己的需要并满足它们，这些都是滋养自己的事情。</h3><p>让自己（主动让自己，调整自己）进入一个良性的循环中去。</p><hr /><h3 id=\"专项对策计划遇阻的对策\">专项对策：计划遇阻的对策</h3><p>很多人认为事情的发展是一条直线，其实不是，它是曲折的，不可预测的。</p><h3 id=\"大部分人害怕失败当他们看到失败的可能性时为了避免彻底失败干脆主动放弃逃避失败\">大部分人害怕失败，当他们看到失败的可能性时，为了避免彻底失败，干脆主动放弃，逃避失败。</h3><h3 id=\"大部分人对自己太苛刻用很多必须和应该来包装自己的计划一旦计划中断就会自我攻击你就是不如别人你就是个三分钟热度的人你一辈子也就这样了\">大部分人对自己太苛刻，用很多‘必须’和‘应该’来包装自己的计划，一旦计划中断，就会自我攻击，‘你就是不如别人’、‘你就是个三分钟热度的人’、‘你一辈子也就这样了’</h3><p>很多人只关注结果，而不享受过程。当不符合预期的情况出现时，就会因为害怕而夸大可能出现的结果。比如三天不运动就会说，自己的坚持运动的计划破产了。悲观预期削弱了他们前进的动力，无法继续走下去。</p><p>用ABCDE法，即，</p><pre><code>A记录客观事实B记录发生后自己的看法C记录行为导致的结果D重新审视自己的看法E计划在新看法下激发新行动</code></pre><p>因为这事会发生很多次，所以我认为除了这个方法外，我们可以再改进方法，即，记录，统计，总结，制定应对方法。把所有阻碍都记录下来，然后统计原因，总结原因，制定当这些原因发生的时候，我们应该用什么样的方法或技巧去应对。</p><hr /><h3 id=\"专项对策计划失败时的对策\">专项对策：计划失败时的对策</h3><p>《终生成长》提到的成长型思维是关键</p><p>固定型思维，人是天生的，聪明和笨是不无法改变的，人的基因决定了一切，命运是无法改变的，他人的成功对我造成了威胁。</p><h3 id=\"成长型思维人的智力是可以提高的这会让人产生学习的欲望人是可以通过努力学习和拼搏改变命运的遇到困难时迎接挑战面对挫折坚持不懈努力练习才能熟能生巧从他人的成功中学到新的知识获得新的灵感\">成长型思维，人的智力是可以提高的（这会让人产生学习的欲望），人是可以通过努力学习和拼搏改变命运的，遇到困难时迎接挑战面对挫折坚持不懈，努力练习才能熟能生巧，从他人的成功中学到新的知识获得新的灵感。</h3><p>关键是去塑造成长型思维，有哪些方法可以帮助我们塑造成长型思维呢？</p><h3 id=\"1当出现失败时观察自己的固定型思维在说些什么把它们写下来它们可能是放弃吧你的能力还做不了这么难的事情或者不管你怎么努力你永远都不可能比别人优秀\">1.当出现失败时，观察自己的固定型思维在说些什么。把它们写下来，它们可能是“放弃吧，你的能力还做不了这么难的事情”或者“不管你怎么努力，你永远都不可能比别人优秀”</h3><h3 id=\"2和自己的固定型思维对话例如欢迎你存在你的存在使得我有对照可以让我变的更好让我们来看看能从这次失败中学到什么我可以做些什么可以让我做得更好些\">2.和自己的固定型思维对话，例如“欢迎你存在，你的存在使得我有对照，可以让我变的更好。让我们来看看能从这次失败中学到什么？我可以做些什么可以让我做得更好些”</h3><h3 id=\"3列出具体的调整计划按照调整计划去行动这步很重要是思维到行为落地的过程只有真正行动起来才算有效调整也只有真正按调整计划行动起来成长型思维才算真正建立起来\">3.列出具体的调整计划，按照调整计划去行动。这步很重要，是思维到行为落地的过程，只有真正行动起来才算有效调整。也只有真正按调整计划行动起来，成长型思维才算真正建立起来。</h3><h3 id=\"塑造成长型思维的关键是让自己的关注点从我是不是足够好转变为关注我还能学到什么东西不断从失败中学习成长让失败成为我们实现目标的加速器\">塑造成长型思维的关键是让自己的关注点，从“我是不是足够好”转变为关注“我还能学到什么东西”，不断从失败中学习成长，让失败成为我们实现目标的加速器。</h3><p>（可以学习下人复盘加速成长）</p><hr /><h3 id=\"专项对策意志力\">专项对策：意志力</h3><p>意志力包括三种不同级别大小的力量</p><pre><code>1.我不要2.我要做3.我想要</code></pre><p>我不要，说的是我为了自身考虑，不要做什么，比如我不要吸烟、我不要玩游戏、我不要吃甜食等。我不要这种力量虽然能够促进自我，但力量太薄弱，人很难用这种力量与自己对抗。</p><p>我要做，说的是我在事情面前认为自己应该做的，比如我要努力干活，我要努力学习，我要坚持运动。我要做这种力量，虽然比我不要更强大一些，但仍然不受我们控制，不是我们要做就能做到的，时常会遇到我们要做什么但最终还是没有去做或者做不下去的情况。</p><p>我想要，说的是当自己知道真正的目标的时候，就更有可能拒绝眼前的诱惑，并且会主动去选择那些困难的任务，所以它是前面两种力量的基础，也是根基最深的力量。我想要这种力量，带给你无穷的想象力，无穷的动力，让你能想出各种办法，专心专注的去实现自己的目标。</p><p>意志力就是去驾驭这三种力量而存在的，如果驾驭的好，它就能帮我们实现目标。意志力也是可以通过练习提高的。</p><h3 id=\"提高意志力方案\">提高意志力方案</h3><p>1.运动提高意志力储备</p><pre><code>运动就是提高意志力储备的最好的方法之一。每天运动一下，可以是10分钟-60分钟之间，不断加强锻炼强度，让自己不断去提高意志力储备。这里提醒大家一句，低强度而持续的锻炼，比高强度但短暂的锻炼有更明显的提高意志力的效果。</code></pre><p>2.有计划的练习，‘我不要’，‘我要做’，‘我想要’的三种能力</p><pre><code>1.列出‘我不要’的事情，和，‘我要做’的事情，用任务的方式去做自己给自己规定的事情。    比如，我不要喝咖啡，我不要吸烟，我不要吃甜食。我要每天看书30分钟，我要每天早起，我要每月强制存款3000元，我要每周写篇文章。2.有意识的每天练习‘我不要’和‘我要做’能锻炼自己的意志力，为自己的执行计划打下坚定的基础。    增强这两种力量，对我们实现目标的可能性也就越大。3.练习‘我想要’的力量时，有两个方法，    一是，每天花两分钟在脑海中描绘目标实现后的景象，始终记住自己的目标。    二是，面对诱惑时不马上行动，而是先等10分钟，10分钟里告诉自己真正想要的是什么，让前额皮层开始工作。 通过每天记住自己的目标，诱惑前思考10分钟，来锻炼“我想要”的力量，这样做的同时也会增强“我不要”和“我要做”的力量。</code></pre><h3 id=\"给自己未来写信方案\">给自己未来写信方案</h3><p>我们会把未来的自己想象成完全不同的人，这是一种错误的想象。</p><h3 id=\"这会让我们对待未来的自己就像对待陌生人一样当我们考虑未来的自己的时候你就好像在想一个陌生人一样\">这会让我们对待未来的自己就像对待陌生人一样。当我们考虑未来的自己的时候，你就好像在想一个陌生人一样。</h3><p>这样的话，你就有很大可能对未来的自己说，“去你的，你会怎么样我一点都不关心”，这会导致我们不关心自己的未来，而被当下的诱惑所屈服。</p><h3 id=\"这也是为什么很多人不为未来做准备的原因因为和陌生人的幸福比起来我们更关心自己的幸福\">这也是为什么很多人不为未来做准备的原因，因为和陌生人的幸福比起来，我们更关心自己的幸福。</h3><h3 id=\"比如不为年老的自己存款不为了未来更优秀的自己而学习不为了未来的身体健康而锻炼不为了更好的节奏而早起等等等\">比如，不为年老的自己存款，不为了未来更优秀的自己而学习，不为了未来的身体健康而锻炼，不为了更好的节奏而早起等等等。</h3><p>有一种测量方式，叫做‘未来自我的连续性’，这个方法可以帮助我们认识到未来的自己在本质上和现在的自己是一样的。</p><h3 id=\"研究表明那些未来自我连续性比较高的人也就是现在的我和未来的我圆圈重叠得比较多的人为未来计划和实施的事情也越多表象上来看他们的存款更多储备的知识更丰富也更加健康未来也更加美好\">研究表明，那些“未来自我连续性”比较高的人，也就是“现在的我”和“未来的我”圆圈重叠得比较多的人，为未来计划和实施的事情也越多，表象上来看他们的存款更多，储备的知识更丰富，也更加健康，未来也更加美好。</h3><p>当你的两个圈重叠越多时，你就越有可能为未来的目标而努力，你的目标也就越容易实现。</p><p>我们可以每个月给未来的自己写封信，这有助于我们挡住眼前即时满足的诱惑，而选择更有利于长期目标的行动。</p><p>信中可以写：</p><pre><code>想象下自己未来在做什么？他会如何看待现在做出的选择？向未来的自己描述下自己将会怎么做，这是他希望的吗？我对未来有什么希望？我觉得自己会变成什么样？想象未来的自己回头看现在的自己，他会为现在的自己做了什么而表示感激？</code></pre><p>每个月写一封，这样的信，给未来的自己，让自己和未来的自己越来越亲密，重叠度越来越高，也就越来越喜欢做对自己未来有帮助的事情了。</p><hr /><h3 id=\"专项对策时间不够\">专项对策：时间不够</h3><p>假如你是个‘时间富翁’，有取之不尽的时间，你每天都有很多时间去做你想要做的事情，运动、学习、工作、副业，实现一个个目标，你变得健康、自信、富有。</p><p>因此关键是时间，和使用时间的效率。时间和效率，两者不同，一个是注重使用情况，另一个注重使用的点。</p><h3 id=\"我们知道二八原则20的重要的事情要花费80的精力是比较高效的而反过来如果我们把80的精力花在80不重要的事情上效率就会很差\">我们知道二八原则，20%的重要的事情，要花费80%的精力是比较高效的，而反过来如果我们把80%的精力花在80%不重要的事情上，效率就会很差。</h3><p>首先把无效时间转变为有效时间。如何转变呢？</p><pre><code>1.关键在于记录时间2.记录后，分析你的时间，每天无效时间和有效时间分别是多少3.把无效时间转变为以有效时间。</code></pre><h3 id=\"其次重注效率\">其次重注效率。</h3><p>给那些重要但不紧急的目标加上优先级。我们很多时候都是在工作，处理的都是紧急但不重要的事情，导致对我们重要而不紧急的事情被无限期拖延。</p><h3 id=\"方法1每天列个清单只做5件事如果出现了更重要的事情则在5件事中删除一件\">方法1，每天列个清单，只做5件事，如果出现了更重要的事情，则在5件事中删除一件。</h3><p>这样可以确保我们把时间花在这些重要的事情上。</p><h3 id=\"方法2把紧急但可以缓一缓做的事情放在一个列表里然后在某段时间批量处理\">方法2，把紧急但可以缓一缓做的事情放在一个列表里，然后在某段时间批量处理。</h3><p>比如还信用卡，回某人短息，处理邮件，安排会议时间等，放在任务列表里，等到自己手头上的事情结束时，集合起来去完成它们。</p><h3 id=\"最后是时间盒子法\">最后是时间盒子法</h3><p>安排固定一段时间，专门做某事，就叫做时间盒子。</p><h3 id=\"比如早上8点到8点半30分钟写文章9点到9点半健身房运动晚上10点10点半中午12点到12点半30分钟看书梳理一天的生活\">比如早上8点到8点半：30分钟写文章，9点到9点半：健身房运动，晚上10点10点半：中午12点到12点半，30分钟看书：梳理一天的生活。</h3><h3 id=\"把时间固定下来成为一个时间盒子这样能确保我们每天都能朝着目标行动\">把时间固定下来，成为一个时间盒子。这样能确保我们每天都能朝着目标行动。</h3><p>时间盒子要注意两点：</p><pre><code>1.时间要固定，形成固定节奏后不能随意改动。2.时间盒子内，神圣不可侵犯，关掉手机关掉电视，全心全意做好这件事。</code></pre>",
            "url": "http://www.luzexi.com/2021/03/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B020",
            
            
            
            
            
            "date_published": "2021-03-28T00:00:00+08:00",
            "date_modified": "2021-03-28T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/03/22/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A860",
            "title": "思路探讨(六十) 杂谈",
            "summary": "思路 随想 理念 逻辑 人生哲学",
            "content_text": "最近看了《基业长青》，这本书着实不错，它讲了组织发展的核心，分析了曾经那些高瞻远瞩的公司是如何屹立不倒并越走越旺的根本原因。作者为了不让自己陷入自己设计好的偏见陷阱中，拿了各种与自己观念相反的案例来分析，包括那些曾经高瞻远瞩公司后来倒下去的案例，以及并没有与自己观点相符但活的很好的公司。全书给我很多启发，其精神世界的力量贯穿始终，后面打算专门写一篇关于此书的文章来全面介绍此书的精髓之处。看完后让我沉思许久，发现我的技术经验是我唯一的财富，它不能转变成为可以传承的东西，或者说可以几代人不断经营的东西，这让我重新审视了我的职业和我正在做的事情。从更大的视角来说，我现在做的事情是短视的。我正在做一件，只考虑了我自己的事情。我喜欢编程技术，用它来赚钱养家糊口，这其实就是短视的一种，因为我并没有建立几代人可以共同努力的东西，只顾自己喜欢和擅长的东西。我的经验和技术会随着我的死亡而消失，期间也无法与任何人共同经营，而我只能自己拼搏，然后独自乐呵或悲伤。经验的好处是让我在处理事情的时候有了依据，但同时也限制了我的想象力。想到这里，我确实短视了很多年了，只想到自己没有太多的顾及别人。不过庆幸的是这么多年下来，我比较注重精神世界，没有被世俗吞没。来深圳后，让我想明白一件事，大多数事情跟我想象的完全不一样，我只要做好我认为对的事情就可以了，直到自己认识到有问题及时改进，这样不断完善自己。人与人的区别是精神世界，俗话说，广厦千间，夜眠仅需六尺，家财万贯，日食不过三餐。房再多，睡觉时也只需要4平方面的床，钱再多，一天只不过吃三餐。说到这里，让我想起，以前看过的《亮剑》中的军魂，它就是精神世界的代表，它应该代表了军队中精神世界的比较高的境界。狭路相逢勇者胜，逢敌先亮剑而不是想着先退缩，这是真实战斗中比较好的精神状态。精神世界是人类最高层级的东西，就因为人有精神世界，才与机器人完全区别开来。所以我在自律的同时，一直告诫自己，要多观察自己，要多问自己为什么，要多看看别人和自己的区别是什么，避免死板。如果我想要更多的确定性，就得付出更多的努力，去经营的世界，经营的理念，步步完善，日日积累。有才却耐不住性子，忍受不了枯燥，和平庸者没两样，甚至会更差。更何况我自认为，我是个《笨小孩》，这首歌也在最近的歌单里放了很多遍，勉励自己要稳扎稳打。所以不要放纵，它会成为习惯，要时常忍耐，才能守住自己的成果，因为它很容易就灰飞烟灭。回头看去年最大的成就是，其实是成功戒烟。最后再提醒自己两句：1.你是什么样的人，你就会有什么样的朋友和家人。2.你怎么对待别人，别人就会怎么对待你。",
            "content_html": "<p>最近看了《基业长青》，这本书着实不错，它讲了组织发展的核心，分析了曾经那些高瞻远瞩的公司是如何屹立不倒并越走越旺的根本原因。</p><p>作者为了不让自己陷入自己设计好的偏见陷阱中，拿了各种与自己观念相反的案例来分析，包括那些曾经高瞻远瞩公司后来倒下去的案例，以及并没有与自己观点相符但活的很好的公司。</p><p>全书给我很多启发，其精神世界的力量贯穿始终，后面打算专门写一篇关于此书的文章来全面介绍此书的精髓之处。</p><p>看完后让我沉思许久，发现我的技术经验是我唯一的财富，它不能转变成为可以传承的东西，或者说可以几代人不断经营的东西，这让我重新审视了我的职业和我正在做的事情。</p><p>从更大的视角来说，我现在做的事情是短视的。</p><p>我正在做一件，只考虑了我自己的事情。</p><p>我喜欢编程技术，用它来赚钱养家糊口，这其实就是短视的一种，因为我并没有建立几代人可以共同努力的东西，只顾自己喜欢和擅长的东西。</p><p>我的经验和技术会随着我的死亡而消失，期间也无法与任何人共同经营，而我只能自己拼搏，然后独自乐呵或悲伤。</p><p>经验的好处是让我在处理事情的时候有了依据，但同时也限制了我的想象力。</p><p>想到这里，我确实短视了很多年了，只想到自己没有太多的顾及别人。</p><p>不过庆幸的是这么多年下来，我比较注重精神世界，没有被世俗吞没。来深圳后，让我想明白一件事，大多数事情跟我想象的完全不一样，我只要做好我认为对的事情就可以了，直到自己认识到有问题及时改进，这样不断完善自己。</p><p>人与人的区别是精神世界，俗话说，广厦千间，夜眠仅需六尺，家财万贯，日食不过三餐。</p><p>房再多，睡觉时也只需要4平方面的床，钱再多，一天只不过吃三餐。</p><p>说到这里，让我想起，以前看过的《亮剑》中的军魂，它就是精神世界的代表，它应该代表了军队中精神世界的比较高的境界。</p><p>狭路相逢勇者胜，逢敌先亮剑而不是想着先退缩，这是真实战斗中比较好的精神状态。</p><p>精神世界是人类最高层级的东西，就因为人有精神世界，才与机器人完全区别开来。所以我在自律的同时，一直告诫自己，要多观察自己，要多问自己为什么，要多看看别人和自己的区别是什么，避免死板。</p><p>如果我想要更多的确定性，就得付出更多的努力，去经营的世界，经营的理念，步步完善，日日积累。</p><p>有才却耐不住性子，忍受不了枯燥，和平庸者没两样，甚至会更差。更何况我自认为，我是个《笨小孩》，这首歌也在最近的歌单里放了很多遍，勉励自己要稳扎稳打。</p><p>所以不要放纵，它会成为习惯，要时常忍耐，才能守住自己的成果，因为它很容易就灰飞烟灭。回头看去年最大的成就是，其实是成功戒烟。</p><p>最后再提醒自己两句：</p><h3 id=\"1你是什么样的人你就会有什么样的朋友和家人\">1.你是什么样的人，你就会有什么样的朋友和家人。</h3><h3 id=\"2你怎么对待别人别人就会怎么对待你\">2.你怎么对待别人，别人就会怎么对待你。</h3>",
            "url": "http://www.luzexi.com/2021/03/22/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A860",
            
            
            
            
            
            "date_published": "2021-03-22T00:00:00+08:00",
            "date_modified": "2021-03-22T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/03/18/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A110",
            "title": "给女儿的信(十) 关于自我驱动",
            "summary": "女儿 教育 亲情",
            "content_text": "Hi Sharon Anne，爸爸又想你们了。爸爸再给你们讲讲最近爸爸给自己定目标的事情。爸爸为什么要给自己定目标呢？因为人总是会有懒的时候，总是会有不用脑子去做事情的时候，爸爸想更好的鞭策自己。于是自己给自己定目标，有了目标，爸爸就要想各种办法去慢慢的实现目标，爸爸在慢慢实现目标的过程中，就会不断得动脑筋。这样爸爸不断的动脑筋，既实现了目标，自己获得了成就感，开心了，脑袋也越来越聪明了，你说这是不是一举三得。爸爸知道无论大人小孩，都会有懒的动的时候。我们家每个人都很自律，每天都会坚持打卡，每天都会学习、看书，我们家每个人都很棒喔。但打卡、学习、看书，并不一定代表着动脑子哦，有时会进入一种浑浑噩噩的状态，手在写、嘴巴在动，但脑子却不在动。这很常见，爸爸时常会这样不动脑子的时候。这样很浪费时间，看似自己在学习，其实是在浪费时间。于是爸爸问自己，那该怎么办呢，爸爸想到了，用定目标的方式来驱动自己，驱动自己去做的更好。有了目标，爸爸就会想各种办法去实现目标，这样既动了脑子，又完成了目标，自己就会很开心。你们也可以试试喔，很有趣很好玩的，多练习几次，一旦上手了就会感觉很棒喔。Sharon和Anne也要加油喔，妈妈和小姨妈也是呢，我们全家都一起加油好不好！加油~",
            "content_html": "<p>Hi Sharon Anne，爸爸又想你们了。</p><p>爸爸再给你们讲讲最近爸爸给自己定目标的事情。</p><p>爸爸为什么要给自己定目标呢？</p><p>因为人总是会有懒的时候，总是会有不用脑子去做事情的时候，爸爸想更好的鞭策自己。</p><p>于是自己给自己定目标，有了目标，爸爸就要想各种办法去慢慢的实现目标，爸爸在慢慢实现目标的过程中，就会不断得动脑筋。</p><p>这样爸爸不断的动脑筋，既实现了目标，自己获得了成就感，开心了，脑袋也越来越聪明了，你说这是不是一举三得。</p><p>爸爸知道无论大人小孩，都会有懒的动的时候。</p><p>我们家每个人都很自律，每天都会坚持打卡，每天都会学习、看书，我们家每个人都很棒喔。</p><p>但打卡、学习、看书，并不一定代表着动脑子哦，有时会进入一种浑浑噩噩的状态，手在写、嘴巴在动，但脑子却不在动。</p><p>这很常见，爸爸时常会这样不动脑子的时候。这样很浪费时间，看似自己在学习，其实是在浪费时间。</p><p>于是爸爸问自己，那该怎么办呢，爸爸想到了，用定目标的方式来驱动自己，驱动自己去做的更好。</p><p>有了目标，爸爸就会想各种办法去实现目标，这样既动了脑子，又完成了目标，自己就会很开心。</p><p>你们也可以试试喔，很有趣很好玩的，多练习几次，一旦上手了就会感觉很棒喔。</p><p>Sharon和Anne也要加油喔，妈妈和小姨妈也是呢，我们全家都一起加油好不好！加油~</p>",
            "url": "http://www.luzexi.com/2021/03/18/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A110",
            
            
            
            
            
            "date_published": "2021-03-18T00:00:00+08:00",
            "date_modified": "2021-03-18T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/03/15/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A859",
            "title": "思路探讨(五十九) 避免自动驾驶",
            "summary": "思路 随想 理念 逻辑 人生哲学",
            "content_text": "这周继续目标管理，执行过程中细节比较多，每个脚步每个转折我都记录下来了，待积累一段时间再来为大家呈现我的总结和分享。我对目标管理的赞不绝口：目标管理是我见过的，最强的，自我驱动方式，也是我见过的最好的自我潜力挖掘方式。一直以来我都在为自己找自我驱动的方式，也一直认为自我驱动是人这一生很重要的东西。活了这么久，我受够了日复一日枯燥乏味的生活，希望能给自己一些改变，寻找自我驱动就是我寻求突破和改变的途径。其实我们在日常工作生活中，非常容易行尸走肉，无论做的是什么高级的’活‘，都是如此。无论什么事情，做多了，我们就会发现很无聊，如果我们没有从中发现新的亮点，新的兴趣点的话，就会陷入疲惫，陷入枯燥乏味，陷入苦闷的状态。我写公众号本身就是为了避免行尸走肉，所以我很喜欢写公众号，它能让我思考，反思。通过写公众号我找出了自身很多问题，这样就能更好的观察自己、了解自己。我知道，无论做什么都是会陷入一种自动驾驶的状态，当进入自动驾驶状态时，我们会很自然的忽视周围发生的问题。看书、健身、写作、学习、做题、工作、甚至社交也同样不例外。特别是 ，我一直提倡的自律，时间管理，精力管理，目标管理，其实自律这东西最容易行尸走肉，每天日复一日的做同样的事情，如果你没有找到做这些事情的动力、看到自律的未来、没有期望其达到的目标，那么做的再多，坚持得再久，可能效果也会是微乎其微的。所以关键不是你做了多少，而是你是否主动去思考、分析、调查，思考后有没去尝试、去实践。主动思考驱动了自我完善，觉醒了自我意识。但其实实际中并没那么容易，主动思考很难，人都有惰性，不是随时都能做到的，那么怎么让自己保持主动思考呢，目标管理就可以。当然它是有前提条件的，前提条件是：自律、进取。这也是我核心价值观中的前两个。",
            "content_html": "<p>这周继续目标管理，执行过程中细节比较多，每个脚步每个转折我都记录下来了，待积累一段时间再来为大家呈现我的总结和分享。</p><h3 id=\"我对目标管理的赞不绝口目标管理是我见过的最强的自我驱动方式也是我见过的最好的自我潜力挖掘方式\">我对目标管理的赞不绝口：目标管理是我见过的，最强的，自我驱动方式，也是我见过的最好的自我潜力挖掘方式。</h3><p>一直以来我都在为自己找自我驱动的方式，也一直认为自我驱动是人这一生很重要的东西。</p><p>活了这么久，我受够了日复一日枯燥乏味的生活，希望能给自己一些改变，寻找自我驱动就是我寻求突破和改变的途径。</p><p>其实我们在日常工作生活中，非常容易行尸走肉，无论做的是什么高级的’活‘，都是如此。</p><p>无论什么事情，做多了，我们就会发现很无聊，如果我们没有从中发现新的亮点，新的兴趣点的话，就会陷入疲惫，陷入枯燥乏味，陷入苦闷的状态。</p><h3 id=\"我写公众号本身就是为了避免行尸走肉所以我很喜欢写公众号它能让我思考反思通过写公众号我找出了自身很多问题这样就能更好的观察自己了解自己\">我写公众号本身就是为了避免行尸走肉，所以我很喜欢写公众号，它能让我思考，反思。通过写公众号我找出了自身很多问题，这样就能更好的观察自己、了解自己。</h3><p>我知道，无论做什么都是会陷入一种自动驾驶的状态，当进入自动驾驶状态时，我们会很自然的忽视周围发生的问题。</p><p>看书、健身、写作、学习、做题、工作、甚至社交也同样不例外。</p><p>特别是 ，我一直提倡的自律，时间管理，精力管理，目标管理，其实自律这东西最容易行尸走肉，每天日复一日的做同样的事情，如果你没有找到做这些事情的动力、看到自律的未来、没有期望其达到的目标，那么做的再多，坚持得再久，可能效果也会是微乎其微的。</p><h3 id=\"所以关键不是你做了多少而是你是否主动去思考分析调查思考后有没去尝试去实践\">所以关键不是你做了多少，而是你是否主动去思考、分析、调查，思考后有没去尝试、去实践。</h3><h3 id=\"主动思考驱动了自我完善觉醒了自我意识\">主动思考驱动了自我完善，觉醒了自我意识。</h3><p>但其实实际中并没那么容易，主动思考很难，人都有惰性，不是随时都能做到的，那么怎么让自己保持主动思考呢，目标管理就可以。</p><p>当然它是有前提条件的，前提条件是：自律、进取。这也是我核心价值观中的前两个。</p>",
            "url": "http://www.luzexi.com/2021/03/15/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A859",
            
            
            
            
            
            "date_published": "2021-03-15T00:00:00+08:00",
            "date_modified": "2021-03-15T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/03/08/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A858",
            "title": "思路探讨(五十八) 学习目标管理的第二周",
            "summary": "思路 随想 理念 逻辑 人生哲学",
            "content_text": "说到上周，给自己定的目标比较满，自己比较焦虑，当时写下思路探讨57后，发现最后竟然在自己的奋力拼搏之下在周日的最后一刻完成了。虽然完成了，喜悦感和成就感，仍然很少，因为太满太重，让自己很焦虑，做事很急躁，即使完成了也觉得太辛苦了，不想再来第二次。这周又继续犯了同样的毛病，，给自己定的目标仍然太高，但心态稳了，由于这周紧急事情比较多，大部分时间都花费在了工作上，留给自己的时间很少。但我仍然挤出了不少时间来完成目标，可惜最后仍然还有一项完全没时间去做。我原谅了我自己，我跟我自己说，事情一直在变，没有按计划走很正常，以后我要考虑的更周到一些，于是默默的将这项目标移到了下周。没有按计划走很正常，生活和工作中失败也很正常，我一生都充斥着失败，我曾一度认为自己会成为那个游走在社会边缘的人成为一个寄生虫，最后还不是挺过来了。失败是人生旅途中的很关键的要素，它激发我的反思，敲醒了我的斗志，让我从迷糊和沉睡中醒来，进而让我从困惑中走出来。所以没有必要太在意，反而要感谢它，它抹去了那层虚伪的窗户纸，让我们知道我们自己现在的真实状况。当你遇到失败时，你应该这么想，所有杀不死你的终将使你强大。只要秉持这个理念，你就能从失败走向成功，从黑暗走向光明。其实这周我完成了很多事情，目标清单上的内容，我很有把握努力一下能完成它们，虽然最后还是有一项没完成，但我没有沮丧，也没有焦虑，从这个现象上看，我进步了，我对目标的本身，以及对制定目标的意义有了更深层次的理解，同时我认为我对制定目标的尺度在越来越靠谱了。前面一直都在说我给自己制定周目标，但其实周目标的大方向要用月目标来配合，月目标要用年目标来配合，这样才能真正发现自己每周做的事情都是有意义的，而1年目标要用5年目标来指引方向，5年目标要用10年目标来指引方向，10年目标要用生命的目标来指引方向。只有这样一环扣一环，拆分到每周的目标才会更加清晰，信心也能得到更加多的支撑，知道自己要什么，该怎么做。当你知道自己要什么，该怎么做时，具体执行时如果能多坚持几周，每周都能完成自己拆分后的目标，我猜你很快就能体会到什么叫信心爆棚、动力十足、思路广阔。很多人害怕目标，一看到目标就吓坏了。其实目标没有这么可怕，就像我今天跟媳妇提出要买别墅这个目标时那样，媳妇连想都没想过，分析都没分析过就吓坏了，直接反击到“不可能”。其实这个目标有很多条道路通向它，比如选择3、4、5线城市的别墅，别墅本身就没有那么多聚集属性，本身就是要远离城市的喧嚣，是一个要让自己更加独立和自律的地方，假如我们没有那么多现金可以抵押现有的房子拿现金付首付，也可以向亲戚朋友借点钱，或者把房子卖了去3、4线，或者把现有的房子拆分成两半，一半付别墅首付，一半付更小套的首付，装修自己来，自己一天天蚂蚁搬砖自己DIY。如果仅仅是为了住别墅，其实方法有很多种，条条道路通罗马，把所有选项整理一下，找出适合自己的，目标就变的没那么可怕了。哈哈哈哈我脑洞挺大的，说实话，这个脑洞还真的可行。以前我时常问自己，我究竟要的是什么，后来改成了，我想成为什么样的人，现在又改成了，我想让后人如何评价我，每一层思想的蜕变都有不一样的风景。每每遇到问题，都要以这个为前提去思考。希望我的学习分享，能给大家一些启示。",
            "content_html": "<p>说到上周，给自己定的目标比较满，自己比较焦虑，当时写下思路探讨57后，发现最后竟然在自己的奋力拼搏之下在周日的最后一刻完成了。</p><p>虽然完成了，喜悦感和成就感，仍然很少，因为太满太重，让自己很焦虑，做事很急躁，即使完成了也觉得太辛苦了，不想再来第二次。</p><p>这周又继续犯了同样的毛病，，给自己定的目标仍然太高，但心态稳了，由于这周紧急事情比较多，大部分时间都花费在了工作上，留给自己的时间很少。但我仍然挤出了不少时间来完成目标，可惜最后仍然还有一项完全没时间去做。</p><p>我原谅了我自己，我跟我自己说，事情一直在变，没有按计划走很正常，以后我要考虑的更周到一些，于是默默的将这项目标移到了下周。</p><h3 id=\"没有按计划走很正常生活和工作中失败也很正常我一生都充斥着失败我曾一度认为自己会成为那个游走在社会边缘的人成为一个寄生虫最后还不是挺过来了\">没有按计划走很正常，生活和工作中失败也很正常，我一生都充斥着失败，我曾一度认为自己会成为那个游走在社会边缘的人成为一个寄生虫，最后还不是挺过来了。</h3><h3 id=\"失败是人生旅途中的很关键的要素它激发我的反思敲醒了我的斗志让我从迷糊和沉睡中醒来进而让我从困惑中走出来所以没有必要太在意反而要感谢它它抹去了那层虚伪的窗户纸让我们知道我们自己现在的真实状况\">失败是人生旅途中的很关键的要素，它激发我的反思，敲醒了我的斗志，让我从迷糊和沉睡中醒来，进而让我从困惑中走出来。所以没有必要太在意，反而要感谢它，它抹去了那层虚伪的窗户纸，让我们知道我们自己现在的真实状况。</h3><h3 id=\"当你遇到失败时你应该这么想所有杀不死你的终将使你强大只要秉持这个理念你就能从失败走向成功从黑暗走向光明\">当你遇到失败时，你应该这么想，所有杀不死你的终将使你强大。只要秉持这个理念，你就能从失败走向成功，从黑暗走向光明。</h3><p>其实这周我完成了很多事情，目标清单上的内容，我很有把握努力一下能完成它们，虽然最后还是有一项没完成，但我没有沮丧，也没有焦虑，从这个现象上看，我进步了，我对目标的本身，以及对制定目标的意义有了更深层次的理解，同时我认为我对制定目标的尺度在越来越靠谱了。</p><h3 id=\"前面一直都在说我给自己制定周目标但其实周目标的大方向要用月目标来配合月目标要用年目标来配合这样才能真正发现自己每周做的事情都是有意义的而1年目标要用5年目标来指引方向5年目标要用10年目标来指引方向10年目标要用生命的目标来指引方向\">前面一直都在说我给自己制定周目标，但其实周目标的大方向要用月目标来配合，月目标要用年目标来配合，这样才能真正发现自己每周做的事情都是有意义的，而1年目标要用5年目标来指引方向，5年目标要用10年目标来指引方向，10年目标要用生命的目标来指引方向。</h3><h3 id=\"只有这样一环扣一环拆分到每周的目标才会更加清晰信心也能得到更加多的支撑知道自己要什么该怎么做\">只有这样一环扣一环，拆分到每周的目标才会更加清晰，信心也能得到更加多的支撑，知道自己要什么，该怎么做。</h3><h3 id=\"当你知道自己要什么该怎么做时具体执行时如果能多坚持几周每周都能完成自己拆分后的目标我猜你很快就能体会到什么叫信心爆棚动力十足思路广阔\">当你知道自己要什么，该怎么做时，具体执行时如果能多坚持几周，每周都能完成自己拆分后的目标，我猜你很快就能体会到什么叫信心爆棚、动力十足、思路广阔。</h3><p>很多人害怕目标，一看到目标就吓坏了。其实目标没有这么可怕，就像我今天跟媳妇提出要买别墅这个目标时那样，媳妇连想都没想过，分析都没分析过就吓坏了，直接反击到“不可能”。</p><p>其实这个目标有很多条道路通向它，比如选择3、4、5线城市的别墅，别墅本身就没有那么多聚集属性，本身就是要远离城市的喧嚣，是一个要让自己更加独立和自律的地方，假如我们没有那么多现金可以抵押现有的房子拿现金付首付，也可以向亲戚朋友借点钱，或者把房子卖了去3、4线，或者把现有的房子拆分成两半，一半付别墅首付，一半付更小套的首付，装修自己来，自己一天天蚂蚁搬砖自己DIY。如果仅仅是为了住别墅，其实方法有很多种，条条道路通罗马，把所有选项整理一下，找出适合自己的，目标就变的没那么可怕了。</p><p>哈哈哈哈我脑洞挺大的，说实话，这个脑洞还真的可行。</p><p>以前我时常问自己，我究竟要的是什么，后来改成了，我想成为什么样的人，现在又改成了，我想让后人如何评价我，每一层思想的蜕变都有不一样的风景。每每遇到问题，都要以这个为前提去思考。</p><p>希望我的学习分享，能给大家一些启示。</p>",
            "url": "http://www.luzexi.com/2021/03/08/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A858",
            
            
            
            
            
            "date_published": "2021-03-08T00:00:00+08:00",
            "date_modified": "2021-03-08T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/02/28/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A857",
            "title": "思路探讨(五十七) 目标管理学习的第一周",
            "summary": "思路 随想 理念 逻辑 人生哲学",
            "content_text": "目标管理这个词已经听过很多次了，以前一直对它有点排斥，以为是陈词滥调，因此也一直没有去研究。但就在最近发现自己对目标管理这个东西越来越感兴趣了，越来越对目标这个事感兴趣，于是找了网上的学习资料学习了一下‘目标管理’，并在我生活中实践一下。其实这也符合我近些年一直练习的精力管理和时间管理，也让我回忆起，去年看过的一本书《精英们的清晨日课》，里面的一些话让我感同身受，后续再回顾总结一下这本书。这里简单介绍下目标在制定时必须遵守的原则。首先目标必须与我们的核心价值观一致，核心价值观就是我们自己认为我这一生想成为什么样的人，自律、智慧、真诚、可靠、进取、友爱、合作、魅力、独立、冒险、安全等等。其次我们的目标必须遵循3个准则：\t1. 目标必须遵循 SMART原则，即具体的、可测量的、可达到的、和其他目标相关联的、有时间限制的。\t2. 目标必须在人生的各领域平衡，包括，事业、家庭、健康、关系、财务、精神生活等人生各领域，一个不能少。\t3. 目标必须是有挑战性的，并且不能是够不到的，也不能是轻松就能办到的，必须我们使劲用力跳一下能够到的目标。\t\t有挑战性目标，会给你带来突破限制的想象力和创造力，让你看到自己都没发现的潜力。等等等….其实里面有很多内容和原理，待我日后一一跟大家详述。很不幸目标管理学习第一周，由于自己制定的目标太大，导致挫败感很强烈。在此我对这次失败的目标管理总结一下。第一，这周我给自己设定了一个周目标，可以我设定了很多的目标，把自己的目标排的很满。这周前3天动力很足但后几天就嫣了，因为前3天太用力了差点累垮了自己，虽然我做了很多事情，完成了比较重的任务，但没有感觉到成就感，相反挫败感却油然而生。这是因为自己给自己制定的目标太多，即使我花了大力气也没能完成，自己却发现用力过猛有点不适应。当我发现无法完成所有任务时，情绪就会低落，精神状态就会萎靡，接下来就越来越糟糕。第二，我在制定目标时并没有思考，它是否符合我的核心价值观，而是一味的觉得自己想达成这些目标。没有核心价值观的支撑，目标在执行时，显得很脆弱，一旦遇到不顺心的事，就没有底层原动力去支撑继续前进。目标必须符合我的核心价值观，我的核心价值观是，自律，智慧，团队合作，进取。当然核心价值观随着年龄的增大会有所不同，我也不断在审视自己的核心价值观。第三，我的目标并没有平衡我的生活，只是一味的在某个方向上尝试突破。在制定目标前，我并没有审视自己在人生各领域的进展，而一味的选择自己认为现在重要的方向去突破。这让我的工作和生活，在原来的基础上更加偏离轨道，向着一个更极端的方向驶去。也同时导致了我对世界和周围事物的理解更加偏执。总的来说，我并没有仔细认真的对待目标管理的每个细节，而是粗糙的将它理解为，定目标，执行目标，完成目标的简单过程，导致目标执行时很痛苦，最终也难以完成的结果。没关系，这只是第一周的学习，失败也是常有的，失败给我警示，总结复盘带给我进步。后面我会，调整目标，改善行动策略，设定奖励，写计划，拆分目标等等，待我下回一一跟大家分享我学习的过程。也为了更加完善我的目标管理练习，接下去我也会加入目标执行的统计日志，记录每次执行目标时的原因、行动、结果，用数据统计和数据分析的方式来改善我执行目标的方式。仍然在学习中，希望我的分享能给大家一些启示。",
            "content_html": "<p>目标管理这个词已经听过很多次了，以前一直对它有点排斥，以为是陈词滥调，因此也一直没有去研究。</p><p>但就在最近发现自己对目标管理这个东西越来越感兴趣了，越来越对目标这个事感兴趣，于是找了网上的学习资料学习了一下‘目标管理’，并在我生活中实践一下。</p><p>其实这也符合我近些年一直练习的精力管理和时间管理，也让我回忆起，去年看过的一本书《精英们的清晨日课》，里面的一些话让我感同身受，后续再回顾总结一下这本书。</p><p>这里简单介绍下目标在制定时必须遵守的原则。</p><p>首先目标必须与我们的核心价值观一致，核心价值观就是我们自己认为我这一生想成为什么样的人，自律、智慧、真诚、可靠、进取、友爱、合作、魅力、独立、冒险、安全等等。</p><p>其次我们的目标必须遵循3个准则：</p><pre><code>\t1. 目标必须遵循 SMART原则，即具体的、可测量的、可达到的、和其他目标相关联的、有时间限制的。\t2. 目标必须在人生的各领域平衡，包括，事业、家庭、健康、关系、财务、精神生活等人生各领域，一个不能少。\t3. 目标必须是有挑战性的，并且不能是够不到的，也不能是轻松就能办到的，必须我们使劲用力跳一下能够到的目标。\t\t有挑战性目标，会给你带来突破限制的想象力和创造力，让你看到自己都没发现的潜力。</code></pre><p>等等等….其实里面有很多内容和原理，待我日后一一跟大家详述。</p><p>很不幸目标管理学习第一周，由于自己制定的目标太大，导致挫败感很强烈。</p><p>在此我对这次失败的目标管理总结一下。</p><h3 id=\"第一这周我给自己设定了一个周目标可以我设定了很多的目标把自己的目标排的很满\">第一，这周我给自己设定了一个周目标，可以我设定了很多的目标，把自己的目标排的很满。</h3><p>这周前3天动力很足但后几天就嫣了，因为前3天太用力了差点累垮了自己，虽然我做了很多事情，完成了比较重的任务，但没有感觉到成就感，相反挫败感却油然而生。</p><p>这是因为自己给自己制定的目标太多，即使我花了大力气也没能完成，自己却发现用力过猛有点不适应。当我发现无法完成所有任务时，情绪就会低落，精神状态就会萎靡，接下来就越来越糟糕。</p><h3 id=\"第二我在制定目标时并没有思考它是否符合我的核心价值观而是一味的觉得自己想达成这些目标\">第二，我在制定目标时并没有思考，它是否符合我的核心价值观，而是一味的觉得自己想达成这些目标。</h3><p>没有核心价值观的支撑，目标在执行时，显得很脆弱，一旦遇到不顺心的事，就没有底层原动力去支撑继续前进。</p><p>目标必须符合我的核心价值观，我的核心价值观是，自律，智慧，团队合作，进取。当然核心价值观随着年龄的增大会有所不同，我也不断在审视自己的核心价值观。</p><h3 id=\"第三我的目标并没有平衡我的生活只是一味的在某个方向上尝试突破\">第三，我的目标并没有平衡我的生活，只是一味的在某个方向上尝试突破。</h3><p>在制定目标前，我并没有审视自己在人生各领域的进展，而一味的选择自己认为现在重要的方向去突破。</p><p>这让我的工作和生活，在原来的基础上更加偏离轨道，向着一个更极端的方向驶去。也同时导致了我对世界和周围事物的理解更加偏执。</p><h3 id=\"总的来说我并没有仔细认真的对待目标管理的每个细节而是粗糙的将它理解为定目标执行目标完成目标的简单过程导致目标执行时很痛苦最终也难以完成的结果\">总的来说，我并没有仔细认真的对待目标管理的每个细节，而是粗糙的将它理解为，定目标，执行目标，完成目标的简单过程，导致目标执行时很痛苦，最终也难以完成的结果。</h3><p>没关系，这只是第一周的学习，失败也是常有的，失败给我警示，总结复盘带给我进步。后面我会，调整目标，改善行动策略，设定奖励，写计划，拆分目标等等，待我下回一一跟大家分享我学习的过程。</p><p>也为了更加完善我的目标管理练习，接下去我也会加入目标执行的统计日志，记录每次执行目标时的原因、行动、结果，用数据统计和数据分析的方式来改善我执行目标的方式。</p><h3 id=\"仍然在学习中希望我的分享能给大家一些启示\">仍然在学习中，希望我的分享能给大家一些启示。</h3>",
            "url": "http://www.luzexi.com/2021/02/28/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A857",
            
            
            
            
            
            "date_published": "2021-02-28T00:00:00+08:00",
            "date_modified": "2021-02-28T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/02/27/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A19",
            "title": "给女儿的信(九) 关于定目标",
            "summary": "女儿 教育 亲情",
            "content_text": "Sharon，Anne，爸爸好想你们。还没过1周时间，爸爸就忍不住要想你们了，爸爸开始数剩下还有多少日子才能见到你们了。爸爸给你们讲讲最近爸爸的工作和生活。在新的一年里，爸爸想给自己在新的一年里有一个明确目标，这样爸爸学习和工作就会有方向。于是爸爸给自己定了几个目标，希望自己在新的一年里能完成它们。它们有，早起锻炼，看完某些爸爸想看但又一直没时间看的书，学习某个爸爸工作上的技能，总结爸爸学过的知识，等等等。在定目标的时候，爸爸看了本书，书中教我们如何定目标。原来定目标也有方法，你说搞笑不搞笑。爸爸还真的学到了不少东西，比如，它说，这个目标必须是具体的，不能含糊不清，比如锻炼就不行，必须是锻炼多少分钟，才是具体的。并且这个目标必须是有期限的，不能无限期延迟，比如以后在学习就不行，必须是这周每天学习半小时，才是有期限的。最后这个目标必须是自己经过努力后能够完成的，不能完不成，而且必须是经过自己努力后才能完成的目标，比如爸爸每天只能学习半小时，但爸爸努力下每天可以学习1个小时，这才是有挑战的目标。但是你知道么，爸爸在第一个星期，给自己定了目标后，发现自己定下的目标太多了，完不成。哈哈哈，爸爸很失落，心情很难受。第一个星期，定目标失败了，没关系，我们还有第二个星期，第三个星期，爸爸可以再定目标，调整目标难度，让自己能够努力一把就能达成的那种，但定目标的时候也要小心，不能定的太低，太低了，难度太小，自己都觉得没意思了。你说搞笑不搞笑。爸爸一直在努力，Sharon，Anne，小姨妈，妈妈，大家都要一起加油哦。加油~喜欢你们，笔心。",
            "content_html": "<p>Sharon，Anne，爸爸好想你们。还没过1周时间，爸爸就忍不住要想你们了，爸爸开始数剩下还有多少日子才能见到你们了。</p><p>爸爸给你们讲讲最近爸爸的工作和生活。</p><p>在新的一年里，爸爸想给自己在新的一年里有一个明确目标，这样爸爸学习和工作就会有方向。</p><p>于是爸爸给自己定了几个目标，希望自己在新的一年里能完成它们。</p><p>它们有，早起锻炼，看完某些爸爸想看但又一直没时间看的书，学习某个爸爸工作上的技能，总结爸爸学过的知识，等等等。</p><p>在定目标的时候，爸爸看了本书，书中教我们如何定目标。</p><p>原来定目标也有方法，你说搞笑不搞笑。</p><p>爸爸还真的学到了不少东西，比如，它说，</p><p>这个目标必须是具体的，不能含糊不清，比如锻炼就不行，必须是锻炼多少分钟，才是具体的。并且这个目标必须是有期限的，不能无限期延迟，比如以后在学习就不行，必须是这周每天学习半小时，才是有期限的。最后这个目标必须是自己经过努力后能够完成的，不能完不成，而且必须是经过自己努力后才能完成的目标，比如爸爸每天只能学习半小时，但爸爸努力下每天可以学习1个小时，这才是有挑战的目标。</p><p>但是你知道么，爸爸在第一个星期，给自己定了目标后，发现自己定下的目标太多了，完不成。</p><p>哈哈哈，爸爸很失落，心情很难受。</p><p>第一个星期，定目标失败了，没关系，我们还有第二个星期，第三个星期，爸爸可以再定目标，调整目标难度，让自己能够努力一把就能达成的那种，但定目标的时候也要小心，不能定的太低，太低了，难度太小，自己都觉得没意思了。</p><p>你说搞笑不搞笑。</p><p>爸爸一直在努力，Sharon，Anne，小姨妈，妈妈，大家都要一起加油哦。加油~</p><p>喜欢你们，笔心。</p>",
            "url": "http://www.luzexi.com/2021/02/27/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A19",
            
            
            
            
            
            "date_published": "2021-02-27T00:00:00+08:00",
            "date_modified": "2021-02-27T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/02/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B019",
            "title": "读书笔记(十九) 《十分钟冥想》",
            "summary": "读书 书 看书 读后感",
            "content_text": "背景：买此书《十分钟冥想》时，是在一个比较特殊的时期，自己的精神状态比较混乱，恰好在某本书中看到推荐此书的评语。抱着好奇心和神秘感读了此书，刚读前几章就深深体会到此书的精妙。于是在后面的几个月中，我逐步践行了书中所描述的冥想技巧，着实很受益，让自己在这个繁杂的社会中获得了一片小小的宁静。疑问：整本书大约有25万字，读完并践行后，我把整个过程分为四个部分：\t1. 第一部分，告诉你什么是冥想？为什么要冥想？\t2. 第二部分，告诉你如何去冥想？\t3. 第三部分，告诉你如何将冥想融入生活？\t4. 第四部分，我的冥想体验记录，增进你对冥想的了解结论：书对我的帮助很大，可以认为这是一本能教会你如何排除外界干扰的书，如果你肯坚定的去练习冥想的话，一切事情都会越来越专注。我也从冥想中学习到了如何保持专注，以及如何在平常事物中发现新的趣味（书中称觉醒），同时自己也日复一日的不断练习，希望自己能有一天在杂乱或危机的环境中仍然能保持定力，也希望自己能在发现事物的更多面。不只是学习，冥想从此成为了我排除干扰，练习专注的一个方法，我把它当作我日常生活中的一部分，借助它来缓解我的紧张、焦虑和急躁的性格，同时也借助它来帮助我练习心流体验（《心流》一书中所描绘的专注）。关于心流体验，我将在另一个篇文章中写关于我看了《心流》这本书后，在自己工作、学习、生活中是如何去实践，书中所描绘的心流，如何去整理内心秩序，让自己更加专注于当下的事物，挖掘更多当下事物的乐趣。内容：点击查看内容",
            "content_html": "<h2 id=\"背景\">背景：</h2><p>买此书《十分钟冥想》时，是在一个比较特殊的时期，自己的精神状态比较混乱，恰好在某本书中看到推荐此书的评语。抱着好奇心和神秘感读了此书，刚读前几章就深深体会到此书的精妙。</p><p>于是在后面的几个月中，我逐步践行了书中所描述的冥想技巧，着实很受益，让自己在这个繁杂的社会中获得了一片小小的宁静。</p><h2 id=\"疑问\">疑问：</h2><p>整本书大约有25万字，读完并践行后，我把整个过程分为四个部分：</p><pre><code>\t1. 第一部分，告诉你什么是冥想？为什么要冥想？\t2. 第二部分，告诉你如何去冥想？\t3. 第三部分，告诉你如何将冥想融入生活？\t4. 第四部分，我的冥想体验记录，增进你对冥想的了解</code></pre><h2 id=\"结论\">结论：</h2><p>书对我的帮助很大，可以认为这是一本能教会你如何排除外界干扰的书，如果你肯坚定的去练习冥想的话，一切事情都会越来越专注。</p><p>我也从冥想中学习到了如何保持专注，以及如何在平常事物中发现新的趣味（书中称觉醒），同时自己也日复一日的不断练习，希望自己能有一天在杂乱或危机的环境中仍然能保持定力，也希望自己能在发现事物的更多面。</p><p>不只是学习，冥想从此成为了我排除干扰，练习专注的一个方法，我把它当作我日常生活中的一部分，借助它来缓解我的紧张、焦虑和急躁的性格，同时也借助它来帮助我练习心流体验（《心流》一书中所描绘的专注）。关于心流体验，我将在另一个篇文章中写关于我看了《心流》这本书后，在自己工作、学习、生活中是如何去实践，书中所描绘的心流，如何去整理内心秩序，让自己更加专注于当下的事物，挖掘更多当下事物的乐趣。</p><h2 id=\"内容\">内容：</h2><h2 id=\"点击查看内容\"><a href=\"https://mp.weixin.qq.com/s/x3_Xq7-lUh8D2BCf0i9C1Q\">点击查看内容</a></h2>",
            "url": "http://www.luzexi.com/2021/02/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B019",
            
            
            
            
            
            "date_published": "2021-02-21T00:00:00+08:00",
            "date_modified": "2021-02-21T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/02/17/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A856",
            "title": "思路探讨(五十六) 自信的支撑点",
            "summary": "思路 随想 理念 逻辑 人生哲学",
            "content_text": "这篇聊聊自信的支撑点。事情的缘由是，最近看到很多人都会因为xxx而感到自豪。这个xxx指某件事，或某个能力，或某个项目，或某个企业。于是想到了自己是否会因为某个东西而感到自豪，想了想，我可能会因为自己看了很多书而感到自豪，也可能会因为自己坚持健身很多年而感到自豪，会因为自己在腾讯感到自豪，会因为自己写了很多文章感到自豪。每个人都有自信的支撑点，有些人会因为自己有钱而感到自信，有些人则会因为自己有学识而感到自信，有些人则是强壮的身体，有些人则是美貌，有些人则是说话表达技巧。除了自身的因素外，他人也会成为支撑自己信心的点，比如有亲人中的某位有权有势的人会支撑我们的自信，也有可能是工作在世界500强的这个企业支撑我们的自信，也有可能是自己的老师或朋友中有才或者有名支撑我们的自信。无论如何，自己身上的自信支撑点，比依赖他人的支撑点更加牢固。对自己有信心比对别人有信心更重要。因为他人因素是不由我们控制，我们所依赖的某亲戚、某公司、某朋友、某个政策，发生变化时，我们就会失去依赖或支撑。而自身因素上，钱、设备工具、荣誉名声、美貌，又是自身因素中的外在因素，它会随着时间的流逝而不断变化，虽然有些可控性，但不足以完全掌控。而自身内在因素，学识、身体、思维方式和习惯，则可以被我们完全掌控，并且随着日积月累，越来越多，越来越强。当然我们不能只关注内在因素，外在因素也是需要我们关注和维护的内容，只是没有内在因素那么重要，但也不可忽视。正好我半年前看过一本书《自信的力量》，他讲的很不错。他说，一个人的自信，首先是由自己与周围环境的和谐程度决定的，再由自己与周围朋友合作默契程度决定，其次和自己的高深的学识、强壮的身体息息相关，最后才和金钱、公司、职位挂钩。想来确实如此，自信心本就是他人给予的，它与周围的人和事息息相关，由自身素质从内而外散发出来，最后由其他外在因素景上添花。",
            "content_html": "<p>这篇聊聊自信的支撑点。</p><p>事情的缘由是，最近看到很多人都会因为xxx而感到自豪。</p><p>这个xxx指某件事，或某个能力，或某个项目，或某个企业。</p><p>于是想到了自己是否会因为某个东西而感到自豪，想了想，我可能会因为自己看了很多书而感到自豪，也可能会因为自己坚持健身很多年而感到自豪，会因为自己在腾讯感到自豪，会因为自己写了很多文章感到自豪。</p><p>每个人都有自信的支撑点，有些人会因为自己有钱而感到自信，有些人则会因为自己有学识而感到自信，有些人则是强壮的身体，有些人则是美貌，有些人则是说话表达技巧。</p><p>除了自身的因素外，他人也会成为支撑自己信心的点，比如有亲人中的某位有权有势的人会支撑我们的自信，也有可能是工作在世界500强的这个企业支撑我们的自信，也有可能是自己的老师或朋友中有才或者有名支撑我们的自信。</p><p>无论如何，自己身上的自信支撑点，比依赖他人的支撑点更加牢固。对自己有信心比对别人有信心更重要。因为他人因素是不由我们控制，我们所依赖的某亲戚、某公司、某朋友、某个政策，发生变化时，我们就会失去依赖或支撑。</p><p>而自身因素上，钱、设备工具、荣誉名声、美貌，又是自身因素中的外在因素，它会随着时间的流逝而不断变化，虽然有些可控性，但不足以完全掌控。</p><p>而自身内在因素，学识、身体、思维方式和习惯，则可以被我们完全掌控，并且随着日积月累，越来越多，越来越强。</p><hr /><p>当然我们不能只关注内在因素，外在因素也是需要我们关注和维护的内容，只是没有内在因素那么重要，但也不可忽视。</p><p>正好我半年前看过一本书《自信的力量》，他讲的很不错。</p><p>他说，一个人的自信，首先是由自己与周围环境的和谐程度决定的，再由自己与周围朋友合作默契程度决定，其次和自己的高深的学识、强壮的身体息息相关，最后才和金钱、公司、职位挂钩。</p><p>想来确实如此，自信心本就是他人给予的，它与周围的人和事息息相关，由自身素质从内而外散发出来，最后由其他外在因素景上添花。</p>",
            "url": "http://www.luzexi.com/2021/02/17/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A856",
            
            
            
            
            
            "date_published": "2021-02-17T00:00:00+08:00",
            "date_modified": "2021-02-17T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/02/10/%E6%94%B9%E9%80%A0jekyll%E4%B8%BAiframe%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9",
            "title": "改造jekyll 为iframe框架的博客内容",
            "summary": "jekyll liquid ruby related",
            "content_text": " ",
            "content_html": "<div class=\"static_post\"><iframe src=\"/static-page/post-2021-02-10/改造jekyll 为iframe框架的博客内容.html\" width=\"100%\" height=\"100%\"> </iframe></div>",
            "url": "http://www.luzexi.com/2021/02/10/%E6%94%B9%E9%80%A0jekyll%E4%B8%BAiframe%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9",
            
            
            
            "tags": ["前端技术","其他技术"],
            
            "date_published": "2021-02-10T00:00:00+08:00",
            "date_modified": "2021-02-10T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/02/09/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A855",
            "title": "思路探讨(五十五) 第一性原理",
            "summary": "思路 随想 理念 逻辑 人生哲学",
            "content_text": "最近越来越经常写文章但很少发出来（基本都是每周一篇总结 + 每日一篇自我反省的文章），没能分享到博客的原因第一是写的文章有些是属于公司保密级的，不能发布在博客上，甚至有几篇文章完全不能脱敏。第二是自己写的向内看系列的内容，真的越来越向内看越来越私密，由于太私密触及内心的兴奋与失落，起伏过大所以也不好拿出来跟大家分享。​在公众号中，我秉持着开放的态度与自己对话，也常与朋友和同事们聊聊自己的想法。希望能从不同的角度来看待事物，也希望能从各个方向上来改善自己做人做事的态度。由于年底事情特别多，也特别繁杂，因此只能将有限的精力用在照顾自己的工作和学习进度。在此跟大家说声抱歉。2021年会继续跟大家分享我的所思所想，以及公开自己的所学所为。前面听过第一性原理的概念，但没有了解的很清楚，在放假回老家最后一天突然兴致勃勃的看了，张善友教授讲的第一性原理的视频。感觉讲的很不错，也契合我一直以来秉持的理念，在听了他所讲的内容后，对这块理念更加深刻。什么是第一性原理？第一性原理，事物背后的不变的理念(原理)，根据这个原理可以推出所有的其他东西出来。这个理念就叫第一性原理。第一性原理是事物的本质、本性，是事物背后支配性的理念，而不是现象层面流变的物质。一旦在逻辑上导通一个共同的抽象概念，与此相关的所有具象问题，立即全部化解。随着我们年龄增大，接触的事情越来越复杂，处理这件复杂的事物需要花费的精力也通常越来越复杂。第一性原理告诉我们，越高深的事物，底层理念越简约，其原理通常具有简一性，即简约和单纯。找到第一性原理，就像是找到了支配事物运动的发动机。计算机程序执行原理、操作系统内核原理，对于每个编程的人来说都是第一性原理。为技术人拓展更扎实的编程思路提供了底层支撑。抽象能力是软件架构设计的第一性原理。为技术人拓展更简洁实用的架构能力提供了底层支撑。尊严与诚信是人在社会生存是第一性原理。为社会人拓展生活和工作中的方方面面提供了支撑。能量守恒是宇宙的第一性原理。为物理、化学的研究工作提供了支撑。等等等人们常说，道理说的很好，但听过就忘了。显然大多数人都没有将人生的底层原理铭刻在心中，时刻忘记遵守事物的本质规律，也时常不得不在所谓的现实面前妥协。你找到生活中的真正的第一性原理了吗？当第一性原理（事物的本质）和现象冲突的时候，你选择了什么？每个你的选择都决定了你今后的道路，你是坚持本质还是妥协现象，N个选择积累后，最终成为了今天的你。当然我们也需要注意下，第一性原理不是绝对真理，虽然事物的本质和原理适用于每个人，但对于每个人来说都需要有不同方式去执行。​",
            "content_html": "<p>最近越来越经常写文章但很少发出来（基本都是每周一篇总结 + 每日一篇自我反省的文章），没能分享到博客的原因第一是写的文章有些是属于公司保密级的，不能发布在博客上，甚至有几篇文章完全不能脱敏。第二是自己写的向内看系列的内容，真的越来越向内看越来越私密，由于太私密触及内心的兴奋与失落，起伏过大所以也不好拿出来跟大家分享。</p><p>​在公众号中，我秉持着开放的态度与自己对话，也常与朋友和同事们聊聊自己的想法。希望能从不同的角度来看待事物，也希望能从各个方向上来改善自己做人做事的态度。</p><p>由于年底事情特别多，也特别繁杂，因此只能将有限的精力用在照顾自己的工作和学习进度。在此跟大家说声抱歉。2021年会继续跟大家分享我的所思所想，以及公开自己的所学所为。</p><hr /><p>前面听过第一性原理的概念，但没有了解的很清楚，在放假回老家最后一天突然兴致勃勃的看了，张善友教授讲的第一性原理的视频。</p><p>感觉讲的很不错，也契合我一直以来秉持的理念，在听了他所讲的内容后，对这块理念更加深刻。</p><p>什么是第一性原理？第一性原理，事物背后的不变的理念(原理)，根据这个原理可以推出所有的其他东西出来。这个理念就叫第一性原理。</p><p>第一性原理是事物的本质、本性，是事物背后支配性的理念，而不是现象层面流变的物质。一旦在逻辑上导通一个共同的抽象概念，与此相关的所有具象问题，立即全部化解。</p><p>随着我们年龄增大，接触的事情越来越复杂，处理这件复杂的事物需要花费的精力也通常越来越复杂。第一性原理告诉我们，越高深的事物，底层理念越简约，其原理通常具有简一性，即简约和单纯。找到第一性原理，就像是找到了支配事物运动的发动机。</p><p>计算机程序执行原理、操作系统内核原理，对于每个编程的人来说都是第一性原理。为技术人拓展更扎实的编程思路提供了底层支撑。抽象能力是软件架构设计的第一性原理。为技术人拓展更简洁实用的架构能力提供了底层支撑。尊严与诚信是人在社会生存是第一性原理。为社会人拓展生活和工作中的方方面面提供了支撑。能量守恒是宇宙的第一性原理。为物理、化学的研究工作提供了支撑。等等等</p><p>人们常说，道理说的很好，但听过就忘了。显然大多数人都没有将人生的底层原理铭刻在心中，时刻忘记遵守事物的本质规律，也时常不得不在所谓的现实面前妥协。</p><p>你找到生活中的真正的第一性原理了吗？当第一性原理（事物的本质）和现象冲突的时候，你选择了什么？</p><p>每个你的选择都决定了你今后的道路，你是坚持本质还是妥协现象，N个选择积累后，最终成为了今天的你。</p><p>当然我们也需要注意下，第一性原理不是绝对真理，虽然事物的本质和原理适用于每个人，但对于每个人来说都需要有不同方式去执行。​</p>",
            "url": "http://www.luzexi.com/2021/02/09/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A855",
            
            
            
            
            
            "date_published": "2021-02-09T00:00:00+08:00",
            "date_modified": "2021-02-09T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        }
    
    ]
}