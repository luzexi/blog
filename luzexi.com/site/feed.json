{
    "version": "https://jsonfeed.org/version/1",
    "title": "技术人生",
    "home_page_url": "http://www.luzexi.com/",
    "feed_url": "http://www.luzexi.com/feed.json",
    "description": "技术，哲学，金融",
    "icon": "http://www.luzexi.com/apple-touch-icon.png",
    "favicon": "http://www.luzexi.com/favicon.ico",
    "expired": false,
    
    "author":  {
        "name": "Jesse Lu",
        "url": "http://www.luzexi.com",
        "avatar": null
    },
    
"items": [
    
        {
            "id": "http://www.luzexi.com/2022/01/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B053",
            "title": "读书笔记(五十二) 《如何精彩演讲》#3 如何即兴演讲",
            "summary": "读书 书 看书 读后感",
            "content_text": "背景不知不觉看完了6本关于演讲的主题，按推荐顺序排列分别是《高效演讲》、《演讲与口才》、《即兴演讲》、《关键对话》、《TED演讲的力量》、《说话的艺术》。我希望自己能够对演讲有一个系统性的学习，于是自己在平常的生活和工作中做了很多实践和训练。目标是，改善平常的工作、生活中表达的流畅和清晰度，能让人感觉到舒服，让人感觉有活力。同时在公众演讲上，希望自己能够很好的呈现所思所想以及所知所学。因此开启这个精彩演讲系列的总结文章，我将对这六本书（其实不止六本）的内容加上我的实践经验做一次全面的系统性的总结。概述：1.即兴演讲与普通演讲的区别2.即兴演讲的框架3.即兴演讲的练习方法内容：如果你仔细一些，就会发现我们生活当中会用到很多很多的机械演讲，很多人并不在意进行演讲认为进行演讲，只是脑袋里迸发出了一些火花，或者说自己总结的那些方法。那其实在我们平常的沟通沟通跟表达过程当中进行演讲，在我们沟通表达当中占据的位置非常重要。（即兴演讲运用场景）特别是作为领导人，作为一个想要做更多有效工作的人。更多的需要激情演讲来，让自己的沟通效率更高，让自己的工作效率更高，让自己的生活效率更高。欣欣的我们会发现，在我们生活当中经常会有一些即兴演讲。讲的不好的情况让。让对话让对方让大家感觉到非常不舒服。其中一些高调的领导者，会在即兴时刻跟着感觉走，结果让自己。悔恨终生一些管理者在会议上被点名发言却无语无伦次，舌头就像打了结一样，还有一些管理者一开口就滔滔不绝没完没了，最后连自己讲了什么都忘记了。另一些领导者呢，在回答问题时没有主题，东拉西扯，最后拼命解释说我的意思是这种体验非常非常的不好。因此进行演讲，需要引起我们足够多的重视，这在我们平常沟通工作生活当中，有非常非常多的场景可以运用，并且它是我们。提高效率。让自己生活工作更美好的一个非常非常好的技巧。即兴演讲与普通演讲的区别（普通演讲特点）我们可以用几个星期甚至几个月的时间来准备我们的演讲稿，从计划、研究、大纲、讨论、草拟、完善的步骤来为即将到来的演讲准备演讲稿。这是一件非常有趣的事情，也非常值得去准备。（即兴演讲特点）只是平时的生活和工作当中，我们90%情况都没有任何准备，大部分人都会“临时抱佛脚”或“跟着感觉走”说两句，这让我们错失了很多关键时刻。对于普通的有预期的演讲，我们可以提前花时间去准备去练习，而即兴演讲大部分情况都不在我们的预料范围内，难道即兴演讲就只能靠天赋吗？并不是，它也是有方法可寻，并且可以通过练习来加强和巩固的。实际上，优秀的即兴演讲，它的秘密就在于准备。也就说，你必须为“看起来像是很自然的即兴发挥”而做充分的准备。（即兴演讲准备工作）我们要为此准备的东西很多，包括选择合适的时间和地点，在什么样的场合说什么样的话，会让对方感觉更自然。与此同时，在讲话前需要快速整理思路，知道自己要说的内容，围绕自己的中心思想讲话。同时自己的讲话的主题和内容要有价值，这是能够让周围的人愿意倾听且被你吸引的关键。最后要意识到我们的“麦克风”始终是开着的，要保持这种麦克风始终开着的状态，不管在办公室内还是办公室外，都要得体的沟通，语言可以激发人也可以威胁人，说符合自己身份的话。大量的练习让乔布斯可以在讲话时基本不用草稿。他在展示产品时，虽然也会小心遮住笔记不让观众看见，但他从来不会逐字逐句念出来。如果你什么都不准备就跟着感觉走，很容易让自己陷入尴尬的境地，到时候你只能胡乱说一些你不了解的东西。（即兴内容知识分类图）对于要说的主题人们总是期望你展示出科学、丰富、经验的知识内容。因此知识内容，通常分为三类：科学知识，讲话的内容有扎实的知识背景一般性知识，丰富的观点让你更有说服力经验性知识，讲述个人经历让讲话更有吸引力在我们即兴讲话前，写下这些关键信息和支持性信息，将这些信息记在脑子里，这将构成你即兴演讲草稿的基础。如果所有即兴演讲都事先做好准备、构建扎实的知识基础，牢记关键信息，相信我们会体会到最棒的即兴演讲体验：“最棒的即兴演讲，是当我做足准备，熟知相关材料时，脱口而出的状况。”（即兴演讲时的心态）演讲的心态非常重要，是与听众连接的通道，也是我们保持真实自我和正念的好方法。演讲心态，保持真实、保持专注、保持尊重非常重要，同时也是保持我们保持真实领导力的好方法。我们一定要有当领导者的意愿，让自己始终处于领导位置，将每一次讲话和沟通都视为潜在的领导力时刻，为此做出自己的进行领导力即兴讲话。真实领导力，让自己专注于当下的对话，真实有勇气的分享你的想法、价值观和信念，分享自己的感受、自己的故事和自己的脆弱。成为真正的领导者需要挖掘自己内在，不断与同事、队友和朋友分享你的当下、想法、价值观、信念、感受和故事。通过保持自己的真实性，激励鼓舞他人，这让我们变得更加温暖，同时也能让我们找到更多乐趣。即兴演讲的框架很多人会问“为什么要用框架？”，这会让我们感觉是把自己禁锢在一个笼子里，看上去有些死板。当然这也是我一开始接触框架的感受，但练习一段时间后我就改变了我的想法。实际上，我们在即兴演讲中，如果没有可依的规则会感觉迷茫。特别是在练习即兴演讲时，没有规则没有方法没有可依的练习方式，很容易迷失在五花八门的“错觉”中。因此框架就起到了重要作用，它为长期技能的练习提供规则，为技能成长提供了依据。用模板去建立自己的即兴演讲框架是一种非常好又非常有效提高自己即兴演讲水平的方法。框架让我们更好的总结完善自己的即兴技巧，通过模板（也有很多人称为模型）和框架，让我们有道可循的思考自己的即兴演讲该如何改进。（即兴演讲框架图）《即兴演讲》为我们介绍了一种即兴演讲的框架：抓手、要点、结构体、呼吁行动。实际上即兴演讲有很多种框架，但都离不开上述这个结构，因此我认为从这个最通用最中心的框架出发来看即兴演讲会更好一些。注意，即使有了即兴框架，也并不代表我们就万事大吉了，这是一个不断打磨和练习的过程。通过框架来练习，最终会做到将框架融会融入心中，做到心中有框架，口中无框架。如果我们可以无论事先还是在讲话现场，都用这个模板去写自己的讲话草稿，通过不断的练习，我们就能让即兴效果更好。（即兴模板应用步骤与调整）即使完全不允许我们打底草稿，我们也可以借助这个模板去讲话。这里有个关键点，即在每讲完每个部分后暂停下来，思考下一个部分的内容，然后再讲。在思考抓手时暂停；讲完抓手内容后暂停，思考一下讲话的核心要点；讲完要点后暂停，思考结构体的内容；讲完结构体后暂停，思考呼吁行动部分；最后讲呼吁行动部分。简而言之，在讲完每一部分后都要暂停，以便思考下一部分内容。但你暂停时，你会看起来更自信，而你讲话的脚本也会更好。注意，模板和模型在实际情况中需要我们灵活的去调整，例如，当你发现讲话的时间已经不允许我们继续完整的讲完所有部分时要即使的调整，特别是当你发现对方表现焦虑不安时，你就要马上精简模板，可能只说要点和呼吁，但无论什么情况下都必须包含要点。即兴框架：要点（即兴演讲框架-要点的关键点）坦率的说，说话没有要点就等于在浪费大家的时间。你会发现，当我们没有要点时，语音中会充满很多赘词，“你知道…”，“就是”，“那么”，“然后”，“是吧”等。究其原因时语言背后的思路不清。所以，一定要确保你的讲话有核心要点。乔布斯越成熟、自信，他就越能与周围实力强大、有想法的管理者自信地对话，而对方在和他争论时也感觉很舒适。要点的关键是三个部分：1.必须是你的观点2.要点要有吸引力3.要点必须积极正面首先，确保要点是的观点，是承载你信念的一部分，只要这样你才能有信心，并强势、明确的凸显出你的观点，并提炼中心思想，一句话简洁表达你的观点。其次，你的观点要有吸引力，这意味着你要了解什么会触动听众的内心，只有这样才能吸引听众的全部注意力，让你的即兴演讲效果发挥到极致。最后，要点必须是积极正面的，这是打动整个会场的必备前提。注意，你也可以在听众中先建立一种紧迫感，然后再转向更高层次的要点，但一定要确保最后以积极因素结尾。通过练习，每次即兴演讲都要有要点，让要点自然的成为你演讲时的第二天性。当你讲话时，胡自然地想讲要点，这在与上级对话，或汇报时尤为重要，它们希望你说话清晰、切中要害，而不浪费他们的时间。即兴框架：结构体一个合理的结构体，可以让你的讲话举重若轻，它可以让你更清楚地传达要点。（结构体组织模式）在讲具体内容是，最好用结构体的组织方式去讲话，这样会让讲话更有条理，清晰的表达我们的观点，支撑我们提出的要点。结构体组织模式：1.原因模式，罗列各种原因和理由来支撑我们提出的要点。2.方法模式，围绕提出的要点，我们可以罗列各种方法来支撑它。3.情况模式，通过描述当前的状况和对应的实施措施来支撑要点。4.时间模式，通过时间顺序来描述支撑要点的关键点。注意，我们在说完要点后一定要暂停，花一点时间思考后，再选择恰当的结构体模式。学习以上四种组织模式，构建讲话核心要点并加上标志词，如果你能做到这些，那么你的即兴演讲将非常有说服力。即兴框架：抓手我们必须思考如何讲话才能在争夺注意力中胜出，因为“获得整个会场”的注意力是很难的，甚至获得一个人的注意力也很难，如今社会有太多信息干扰我们的注意力，包括智能手机、电子邮件、主流话题、八卦信息等，所以我们更应该仔细思考这个部分。也就是说只有抓住大家的注意力，才能让我们的演讲放到最大的效果。(图：抓手关键点)把抓手部分看作是一种“口头的握手”会更好，它让你与听众建立联结，使听众想要跟随你。一旦与听众联结，你就可以讲述要点部分，而你也将获得听众的注意力并发挥领导力作用。抓手的关键点有三个：1.抓住听众注意力2.与听众建立联结3.避免偏离主题可以通过，直呼名称、说关于他们的事情、讲他们曾经的观点、提出与他们的某次对话、询问他们的情况等方式来抓住听众的注意力。总之，与听众有关的事情，才能将听众的注意力转移到你这里。同时，为了能更好的与听众链接，我们需要讲听众感兴趣的事，找到与他们的共同点和共同利益，建立积极、正面、有建设性的对话，来建立与听众的链接。总之，通过找对方的兴趣点和彼此共同利益点，才能触及听众的内心，通过触及内心来建立更好的链接。最后对话中避免抵触和反抗，或者让对话时间过长，以及说些无关紧要的话题。即兴框架：以呼吁行动结束呼吁行动通常要求听众采取行动，一旦后续行动发生，你将实现你的领导力。（图：呼吁行动分解）即兴演讲的收尾特别重要，我们人能记忆的东西很少，对于一件不是特别重要的事情来说，我们只会记住开头和结尾。如果开头和结尾是非常愉悦的，即使中间过程比较枯燥乏味，在人们的心中都是一场还不错的演讲和对话。这里罗列下如何收尾的方法：1.将话语权交给对方2.要求做出最终决定3.介绍具体步骤4.鼓励他人5.传达最后通牒根据现场实际和即兴的内容来选择收尾会更好一些，特别是在结构体讲完后，应该给自己暂停一下，流一点时间来思考该用什么方式收尾。了解听众当我们了解听众时会让即兴演讲更成功。（图：如何了解听众）听众分析包括：1.事前分析：提前了解听众会让你意识到可能存在与你想法完全不同的人，通过事先分析听众可以知道我们会遇到哪些问题，该如何应对。听众们关心什么事，把自己的观点建立在他们的想法上，这样才能有一个更稳固的协作式讨论。对方背景（组织）文化是如何，文化冲突有哪些，建立在尊重互利的基础上，会让即兴更加舒适。2.演讲中调整：现在观众的注意力如何哪些观点有吸引力可以把听众的注意力拉回来哪些听众头脑反应比较迅速是关键决策者，可以去征求他的意见，让他主动发言。最后，在讲话结束后，要对自己的即兴演讲做一个复盘，这是我们提高演讲技能有效快速的方法。关于生活中的即兴谈话在生活中交谈时尽量找到自己谈话的目标，否则将会成为一场空前浪费时间的闲聊。你可以这样想，当人们转身离开时，你想让他们记住关于你的什么信息？只要带着这个问题去思考，你将会让每次即兴谈话都畅快淋漓。一位副总裁这样说：“我发现闲谈非常耗费精力，除非是有目的的聊天。如果毫无准备就交谈，我就会觉得自己迫不及待地想结束谈话。但是如果事先准备了，谈话就会变得很顺利。”优秀的管理者会问自己，“我想让他们从这次谈话中记住什么？”，或者“人们为什么和我做生意”。让我们一起为每一场即兴谈话成为更有效的沟通。",
            "content_html": "<h2 id=\"背景\">背景</h2><p>不知不觉看完了6本关于演讲的主题，按推荐顺序排列分别是《高效演讲》、《演讲与口才》、《即兴演讲》、《关键对话》、《TED演讲的力量》、《说话的艺术》。</p><p>我希望自己能够对演讲有一个系统性的学习，于是自己在平常的生活和工作中做了很多实践和训练。</p><p>目标是，改善平常的工作、生活中表达的流畅和清晰度，能让人感觉到舒服，让人感觉有活力。</p><p>同时在公众演讲上，希望自己能够很好的呈现所思所想以及所知所学。</p><p>因此开启这个精彩演讲系列的总结文章，我将对这六本书（其实不止六本）的内容加上我的实践经验做一次全面的系统性的总结。</p><h2 id=\"概述\">概述：</h2><h3 id=\"1即兴演讲与普通演讲的区别\">1.即兴演讲与普通演讲的区别</h3><h3 id=\"2即兴演讲的框架\">2.即兴演讲的框架</h3><h3 id=\"3即兴演讲的练习方法\">3.即兴演讲的练习方法</h3><h2 id=\"内容\">内容：</h2><p>如果你仔细一些，就会发现我们生活当中会用到很多很多的机械演讲，很多人并不在意进行演讲认为进行演讲，只是脑袋里迸发出了一些火花，或者说自己总结的那些方法。那其实在我们平常的沟通沟通跟表达过程当中进行演讲，在我们沟通表达当中占据的位置非常重要。</p><p>（即兴演讲运用场景）</p><p>特别是作为领导人，作为一个想要做更多有效工作的人。更多的需要激情演讲来，让自己的沟通效率更高，让自己的工作效率更高，让自己的生活效率更高。</p><p>欣欣的我们会发现，在我们生活当中经常会有一些即兴演讲。讲的不好的情况让。让对话让对方让大家感觉到非常不舒服。</p><p>其中一些高调的领导者，会在即兴时刻跟着感觉走，结果让自己。悔恨终生一些管理者在会议上被点名发言却无语无伦次，舌头就像打了结一样，还有一些管理者一开口就滔滔不绝没完没了，最后连自己讲了什么都忘记了。另一些领导者呢，在回答问题时没有主题，东拉西扯，最后拼命解释说我的意思是这种体验非常非常的不好。</p><p>因此进行演讲，需要引起我们足够多的重视，这在我们平常沟通工作生活当中，有非常非常多的场景可以运用，并且它是我们。提高效率。让自己生活工作更美好的一个非常非常好的技巧。</p><h2 id=\"即兴演讲与普通演讲的区别\">即兴演讲与普通演讲的区别</h2><p>（普通演讲特点）</p><p>我们可以用几个星期甚至几个月的时间来准备我们的演讲稿，从计划、研究、大纲、讨论、草拟、完善的步骤来为即将到来的演讲准备演讲稿。这是一件非常有趣的事情，也非常值得去准备。</p><p>（即兴演讲特点）</p><p>只是平时的生活和工作当中，我们90%情况都没有任何准备，大部分人都会“临时抱佛脚”或“跟着感觉走”说两句，这让我们错失了很多关键时刻。</p><p>对于普通的有预期的演讲，我们可以提前花时间去准备去练习，而即兴演讲大部分情况都不在我们的预料范围内，难道即兴演讲就只能靠天赋吗？并不是，它也是有方法可寻，并且可以通过练习来加强和巩固的。</p><h3 id=\"实际上优秀的即兴演讲它的秘密就在于准备\">实际上，优秀的即兴演讲，它的秘密就在于准备。</h3><h3 id=\"也就说你必须为看起来像是很自然的即兴发挥而做充分的准备\">也就说，你必须为“看起来像是很自然的即兴发挥”而做充分的准备。</h3><p>（即兴演讲准备工作）</p><p>我们要为此准备的东西很多，包括选择合适的时间和地点，在什么样的场合说什么样的话，会让对方感觉更自然。与此同时，在讲话前需要快速整理思路，知道自己要说的内容，围绕自己的中心思想讲话。同时自己的讲话的主题和内容要有价值，这是能够让周围的人愿意倾听且被你吸引的关键。最后要意识到我们的“麦克风”始终是开着的，要保持这种麦克风始终开着的状态，不管在办公室内还是办公室外，都要得体的沟通，语言可以激发人也可以威胁人，说符合自己身份的话。</p><p>大量的练习让乔布斯可以在讲话时基本不用草稿。他在展示产品时，虽然也会小心遮住笔记不让观众看见，但他从来不会逐字逐句念出来。如果你什么都不准备就跟着感觉走，很容易让自己陷入尴尬的境地，到时候你只能胡乱说一些你不了解的东西。</p><p>（即兴内容知识分类图）</p><p>对于要说的主题人们总是期望你展示出科学、丰富、经验的知识内容。因此知识内容，通常分为三类：科学知识，讲话的内容有扎实的知识背景一般性知识，丰富的观点让你更有说服力经验性知识，讲述个人经历让讲话更有吸引力</p><p>在我们即兴讲话前，写下这些关键信息和支持性信息，将这些信息记在脑子里，这将构成你即兴演讲草稿的基础。如果所有即兴演讲都事先做好准备、构建扎实的知识基础，牢记关键信息，相信我们会体会到最棒的即兴演讲体验：“最棒的即兴演讲，是当我做足准备，熟知相关材料时，脱口而出的状况。”</p><p>（即兴演讲时的心态）</p><p>演讲的心态非常重要，是与听众连接的通道，也是我们保持真实自我和正念的好方法。</p><p>演讲心态，保持真实、保持专注、保持尊重非常重要，同时也是保持我们保持真实领导力的好方法。</p><p>我们一定要有当领导者的意愿，让自己始终处于领导位置，将每一次讲话和沟通都视为潜在的领导力时刻，为此做出自己的进行领导力即兴讲话。</p><p>真实领导力，让自己专注于当下的对话，真实有勇气的分享你的想法、价值观和信念，分享自己的感受、自己的故事和自己的脆弱。</p><p>成为真正的领导者需要挖掘自己内在，不断与同事、队友和朋友分享你的当下、想法、价值观、信念、感受和故事。</p><h3 id=\"通过保持自己的真实性激励鼓舞他人这让我们变得更加温暖同时也能让我们找到更多乐趣\">通过保持自己的真实性，激励鼓舞他人，这让我们变得更加温暖，同时也能让我们找到更多乐趣。</h3><h2 id=\"即兴演讲的框架\">即兴演讲的框架</h2><p>很多人会问“为什么要用框架？”，这会让我们感觉是把自己禁锢在一个笼子里，看上去有些死板。当然这也是我一开始接触框架的感受，但练习一段时间后我就改变了我的想法。</p><p>实际上，我们在即兴演讲中，如果没有可依的规则会感觉迷茫。特别是在练习即兴演讲时，没有规则没有方法没有可依的练习方式，很容易迷失在五花八门的“错觉”中。因此框架就起到了重要作用，它为长期技能的练习提供规则，为技能成长提供了依据。</p><h3 id=\"用模板去建立自己的即兴演讲框架是一种非常好又非常有效提高自己即兴演讲水平的方法\">用模板去建立自己的即兴演讲框架是一种非常好又非常有效提高自己即兴演讲水平的方法。</h3><p>框架让我们更好的总结完善自己的即兴技巧，通过模板（也有很多人称为模型）和框架，让我们有道可循的思考自己的即兴演讲该如何改进。</p><p>（即兴演讲框架图）</p><p>《即兴演讲》为我们介绍了一种即兴演讲的框架：抓手、要点、结构体、呼吁行动。</p><p>实际上即兴演讲有很多种框架，但都离不开上述这个结构，因此我认为从这个最通用最中心的框架出发来看即兴演讲会更好一些。</p><h3 id=\"注意即使有了即兴框架也并不代表我们就万事大吉了这是一个不断打磨和练习的过程通过框架来练习最终会做到将框架融会融入心中做到心中有框架口中无框架\">注意，即使有了即兴框架，也并不代表我们就万事大吉了，这是一个不断打磨和练习的过程。通过框架来练习，最终会做到将框架融会融入心中，做到心中有框架，口中无框架。</h3><p>如果我们可以无论事先还是在讲话现场，都用这个模板去写自己的讲话草稿，通过不断的练习，我们就能让即兴效果更好。</p><p>（即兴模板应用步骤与调整）</p><p>即使完全不允许我们打底草稿，我们也可以借助这个模板去讲话。</p><h3 id=\"这里有个关键点即在每讲完每个部分后暂停下来思考下一个部分的内容然后再讲\">这里有个关键点，即在每讲完每个部分后暂停下来，思考下一个部分的内容，然后再讲。</h3><h3 id=\"在思考抓手时暂停讲完抓手内容后暂停思考一下讲话的核心要点讲完要点后暂停思考结构体的内容讲完结构体后暂停思考呼吁行动部分最后讲呼吁行动部分\">在思考抓手时暂停；讲完抓手内容后暂停，思考一下讲话的核心要点；讲完要点后暂停，思考结构体的内容；讲完结构体后暂停，思考呼吁行动部分；最后讲呼吁行动部分。</h3><h3 id=\"简而言之在讲完每一部分后都要暂停以便思考下一部分内容但你暂停时你会看起来更自信而你讲话的脚本也会更好\">简而言之，在讲完每一部分后都要暂停，以便思考下一部分内容。但你暂停时，你会看起来更自信，而你讲话的脚本也会更好。</h3><h3 id=\"注意模板和模型在实际情况中需要我们灵活的去调整例如当你发现讲话的时间已经不允许我们继续完整的讲完所有部分时要即使的调整特别是当你发现对方表现焦虑不安时你就要马上精简模板可能只说要点和呼吁但无论什么情况下都必须包含要点\">注意，模板和模型在实际情况中需要我们灵活的去调整，例如，当你发现讲话的时间已经不允许我们继续完整的讲完所有部分时要即使的调整，特别是当你发现对方表现焦虑不安时，你就要马上精简模板，可能只说要点和呼吁，但无论什么情况下都必须包含要点。</h3><h2 id=\"即兴框架要点\">即兴框架：要点</h2><p>（即兴演讲框架-要点的关键点）</p><p>坦率的说，说话没有要点就等于在浪费大家的时间。</p><p>你会发现，当我们没有要点时，语音中会充满很多赘词，“你知道…”，“就是”，“那么”，“然后”，“是吧”等。</p><p>究其原因时语言背后的思路不清。所以，一定要确保你的讲话有核心要点。</p><p>乔布斯越成熟、自信，他就越能与周围实力强大、有想法的管理者自信地对话，而对方在和他争论时也感觉很舒适。</p><p>要点的关键是三个部分：</p><p>1.必须是你的观点</p><p>2.要点要有吸引力</p><p>3.要点必须积极正面</p><p>首先，确保要点是的观点，是承载你信念的一部分，只要这样你才能有信心，并强势、明确的凸显出你的观点，并提炼中心思想，一句话简洁表达你的观点。</p><p>其次，你的观点要有吸引力，这意味着你要了解什么会触动听众的内心，只有这样才能吸引听众的全部注意力，让你的即兴演讲效果发挥到极致。</p><p>最后，要点必须是积极正面的，这是打动整个会场的必备前提。</p><p>注意，你也可以在听众中先建立一种紧迫感，然后再转向更高层次的要点，但一定要确保最后以积极因素结尾。</p><p>通过练习，每次即兴演讲都要有要点，让要点自然的成为你演讲时的第二天性。当你讲话时，胡自然地想讲要点，这在与上级对话，或汇报时尤为重要，它们希望你说话清晰、切中要害，而不浪费他们的时间。</p><h2 id=\"即兴框架结构体\">即兴框架：结构体</h2><p>一个合理的结构体，可以让你的讲话举重若轻，它可以让你更清楚地传达要点。</p><p>（结构体组织模式）</p><p>在讲具体内容是，最好用结构体的组织方式去讲话，这样会让讲话更有条理，清晰的表达我们的观点，支撑我们提出的要点。</p><p>结构体组织模式：1.原因模式，罗列各种原因和理由来支撑我们提出的要点。2.方法模式，围绕提出的要点，我们可以罗列各种方法来支撑它。3.情况模式，通过描述当前的状况和对应的实施措施来支撑要点。4.时间模式，通过时间顺序来描述支撑要点的关键点。</p><p>注意，我们在说完要点后一定要暂停，花一点时间思考后，再选择恰当的结构体模式。</p><p>学习以上四种组织模式，构建讲话核心要点并加上标志词，如果你能做到这些，那么你的即兴演讲将非常有说服力。</p><h2 id=\"即兴框架抓手\">即兴框架：抓手</h2><p>我们必须思考如何讲话才能在争夺注意力中胜出，因为“获得整个会场”的注意力是很难的，甚至获得一个人的注意力也很难，如今社会有太多信息干扰我们的注意力，包括智能手机、电子邮件、主流话题、八卦信息等，所以我们更应该仔细思考这个部分。</p><p>也就是说只有抓住大家的注意力，才能让我们的演讲放到最大的效果。</p><p>(图：抓手关键点)</p><h3 id=\"把抓手部分看作是一种口头的握手会更好它让你与听众建立联结使听众想要跟随你一旦与听众联结你就可以讲述要点部分而你也将获得听众的注意力并发挥领导力作用\">把抓手部分看作是一种“口头的握手”会更好，它让你与听众建立联结，使听众想要跟随你。一旦与听众联结，你就可以讲述要点部分，而你也将获得听众的注意力并发挥领导力作用。</h3><p>抓手的关键点有三个：1.抓住听众注意力2.与听众建立联结3.避免偏离主题</p><p>可以通过，直呼名称、说关于他们的事情、讲他们曾经的观点、提出与他们的某次对话、询问他们的情况等方式来抓住听众的注意力。</p><h3 id=\"总之与听众有关的事情才能将听众的注意力转移到你这里\">总之，与听众有关的事情，才能将听众的注意力转移到你这里。</h3><p>同时，为了能更好的与听众链接，我们需要讲听众感兴趣的事，找到与他们的共同点和共同利益，建立积极、正面、有建设性的对话，来建立与听众的链接。</p><h3 id=\"总之通过找对方的兴趣点和彼此共同利益点才能触及听众的内心通过触及内心来建立更好的链接\">总之，通过找对方的兴趣点和彼此共同利益点，才能触及听众的内心，通过触及内心来建立更好的链接。</h3><p>最后对话中避免抵触和反抗，或者让对话时间过长，以及说些无关紧要的话题。</p><h2 id=\"即兴框架以呼吁行动结束\">即兴框架：以呼吁行动结束</h2><p>呼吁行动通常要求听众采取行动，一旦后续行动发生，你将实现你的领导力。</p><p>（图：呼吁行动分解）</p><p>即兴演讲的收尾特别重要，我们人能记忆的东西很少，对于一件不是特别重要的事情来说，我们只会记住开头和结尾。</p><p>如果开头和结尾是非常愉悦的，即使中间过程比较枯燥乏味，在人们的心中都是一场还不错的演讲和对话。</p><p>这里罗列下如何收尾的方法：</p><p>1.将话语权交给对方2.要求做出最终决定3.介绍具体步骤4.鼓励他人5.传达最后通牒</p><p>根据现场实际和即兴的内容来选择收尾会更好一些，特别是在结构体讲完后，应该给自己暂停一下，流一点时间来思考该用什么方式收尾。</p><h2 id=\"了解听众\">了解听众</h2><p>当我们了解听众时会让即兴演讲更成功。</p><p>（图：如何了解听众）</p><p>听众分析包括：</p><p>1.事前分析：</p><p>提前了解听众会让你意识到可能存在与你想法完全不同的人，通过事先分析听众可以知道我们会遇到哪些问题，该如何应对。</p><p>听众们关心什么事，把自己的观点建立在他们的想法上，这样才能有一个更稳固的协作式讨论。</p><p>对方背景（组织）文化是如何，文化冲突有哪些，建立在尊重互利的基础上，会让即兴更加舒适。</p><p>2.演讲中调整：</p><p>现在观众的注意力如何</p><p>哪些观点有吸引力可以把听众的注意力拉回来</p><p>哪些听众头脑反应比较迅速是关键决策者，可以去征求他的意见，让他主动发言。</p><h3 id=\"最后在讲话结束后要对自己的即兴演讲做一个复盘这是我们提高演讲技能有效快速的方法\">最后，在讲话结束后，要对自己的即兴演讲做一个复盘，这是我们提高演讲技能有效快速的方法。</h3><h2 id=\"关于生活中的即兴谈话\">关于生活中的即兴谈话</h2><p>在生活中交谈时尽量找到自己谈话的目标，否则将会成为一场空前浪费时间的闲聊。</p><p>你可以这样想，当人们转身离开时，你想让他们记住关于你的什么信息？</p><p>只要带着这个问题去思考，你将会让每次即兴谈话都畅快淋漓。</p><h3 id=\"一位副总裁这样说我发现闲谈非常耗费精力除非是有目的的聊天如果毫无准备就交谈我就会觉得自己迫不及待地想结束谈话但是如果事先准备了谈话就会变得很顺利\">一位副总裁这样说：“我发现闲谈非常耗费精力，除非是有目的的聊天。如果毫无准备就交谈，我就会觉得自己迫不及待地想结束谈话。但是如果事先准备了，谈话就会变得很顺利。”</h3><p>优秀的管理者会问自己，“我想让他们从这次谈话中记住什么？”，或者“人们为什么和我做生意”。</p><p>让我们一起为每一场即兴谈话成为更有效的沟通。</p>",
            "url": "http://www.luzexi.com/2022/01/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B053",
            
            
            
            
            
            "date_published": "2022-01-06T00:00:00+08:00",
            "date_modified": "2022-01-06T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2022/01/03/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A120",
            "title": "给女儿的信(二十) 观察自己的情绪",
            "summary": "女儿 教育 亲情",
            "content_text": "要点：用跟自己说说话和闭上眼睛数数的方式，观察自己的情绪，同时化解了自己的情绪结构：  遇到困难的时候心里很难受  当遇到枯燥乏味的工作时心里很苦闷  爸爸想解决这些困难，但就是提不起劲  于是爸爸闭上眼睛观察自己  爸爸观察自己的情绪是怎样的  是难受还是紧张  难受是怎么个难受法，是脑袋嗡嗡的吗，还是整个人紧绷的  紧张是怎样的表现，是肌肉很痛吗，还是腿和胳膊在抖动  细致的观察自己的在难受和紧张时的身体状况  慢慢发现自己的难受和紧张被化解了  当我发现，原来紧张和难受时，脑袋时这样的感觉，肌肉时这样在抖动  难受和紧张就慢慢消失了，神奇吗  原来难受和紧张只是我们想当然的感受，其根本原因是因为肌肉在收缩内容：Hello 秀恩，Hello Anne。爸爸好想你们爸爸喜欢你们啊，爱你们哟。爸爸在深圳又过了2周多的时间了，这里的天气比以往更冷一些。爸爸给你们讲一讲爸爸最近的状况好不好？最近爸爸遇到一些困难，工作上的和学习上的困难都有。爸爸心里感觉到很难受。爸爸发现每次当遇到枯燥的乏味的工作时，心里就很郁闷。除了工作呢，有时候自己想要学习，但是又提不起劲的时候，心里也很难受。有时候爸爸觉得自己心里很浮躁，心情很急躁，就是看不进书，写不进东西，心里安静不下来。所以爸爸想着该怎么办呢？怎么解决这个心里难受情绪混乱的状态呢？爸爸想了两个办法，第1个办法是跟自己说说话，爸爸每天抽15分钟到20分钟的时间来跟自己说说话，每天跟自己说说今天我遇到了什么困难，我的感受怎样。然后跟自己说说，我应该怎么去解决这个困难，跟自己说说我应该怎样去调整自己的情绪。你知道吗？爸爸跟自己说着说着，自己的情绪就真的慢慢好起来了，不那么难受，也不那么急躁了，也不紧张了。所以爸爸觉得跟自己说说话，这个办法非常棒。跟自己说说话，不但练习了口头的表达能力和沟通能力，并且还化解了自己的情绪，爸爸觉得这个方法非常非常棒。所以呢，爸爸每天都在坚持跟自己说说话，像跟秀恩聊天一样跟自己说说话。第2个办法是。当爸爸感觉到紧张、难受、急躁的时候，就坐下来闭上眼睛去数数，数数的时候，我会观察自己。观察自己的哪里难受，哪里紧张，是哪块肌肉很难受，是紧张还是疼痛？细致的观察自己。爸爸就这样去观察自己的身体，在这种紧张和难受的状态下，肌肉是怎么收缩和抖动的？慢慢地观察着观察着，爸爸发现自己的情绪开始化解了，爸爸发现自己没有这么难受和紧张了，原来只要爸爸闭上眼睛专注地观察他们，观察肌肉的疼痛和收缩，观察脑袋的紧绷，观察整个人的状态的时候，难受和紧张就慢慢的消失了。这种感觉太棒了。就感觉自己重新平静了下来，无论是生气还是难受，情绪都被化解了。爸发现用这两种调节情绪的办法非常棒。爸爸现在常用这种方式去化解自己的情绪，那些痛苦啊、难受啊、紧张啊、焦虑啊、急躁啊，都可以通过这样的方式去把它化解。太棒了，爸爸每天都要坚持跟自己说说，观察自己的状态和身体的变化，化解掉自己的情绪。今天的写信就到这里喽，宝宝们喜欢你们，爸爸爱你们哟。",
            "content_html": "<h2 id=\"要点\">要点：</h2><p>用跟自己说说话和闭上眼睛数数的方式，观察自己的情绪，同时化解了自己的情绪</p><h2 id=\"结构\">结构：</h2><ol>  <li>遇到困难的时候心里很难受</li>  <li>当遇到枯燥乏味的工作时心里很苦闷</li>  <li>爸爸想解决这些困难，但就是提不起劲</li>  <li>于是爸爸闭上眼睛观察自己</li>  <li>爸爸观察自己的情绪是怎样的</li>  <li>是难受还是紧张</li>  <li>难受是怎么个难受法，是脑袋嗡嗡的吗，还是整个人紧绷的</li>  <li>紧张是怎样的表现，是肌肉很痛吗，还是腿和胳膊在抖动</li>  <li>细致的观察自己的在难受和紧张时的身体状况</li>  <li>慢慢发现自己的难受和紧张被化解了</li>  <li>当我发现，原来紧张和难受时，脑袋时这样的感觉，肌肉时这样在抖动</li>  <li>难受和紧张就慢慢消失了，神奇吗</li>  <li>原来难受和紧张只是我们想当然的感受，其根本原因是因为肌肉在收缩</li></ol><h2 id=\"内容\">内容：</h2><p>Hello 秀恩，Hello Anne。爸爸好想你们爸爸喜欢你们啊，爱你们哟。</p><p>爸爸在深圳又过了2周多的时间了，这里的天气比以往更冷一些。</p><p>爸爸给你们讲一讲爸爸最近的状况好不好？</p><p>最近爸爸遇到一些困难，工作上的和学习上的困难都有。爸爸心里感觉到很难受。</p><p>爸爸发现每次当遇到枯燥的乏味的工作时，心里就很郁闷。除了工作呢，有时候自己想要学习，但是又提不起劲的时候，心里也很难受。</p><p>有时候爸爸觉得自己心里很浮躁，心情很急躁，就是看不进书，写不进东西，心里安静不下来。所以爸爸想着该怎么办呢？怎么解决这个心里难受情绪混乱的状态呢？</p><p>爸爸想了两个办法，第1个办法是跟自己说说话，爸爸每天抽15分钟到20分钟的时间来跟自己说说话，每天跟自己说说今天我遇到了什么困难，我的感受怎样。然后跟自己说说，我应该怎么去解决这个困难，跟自己说说我应该怎样去调整自己的情绪。</p><p>你知道吗？爸爸跟自己说着说着，自己的情绪就真的慢慢好起来了，不那么难受，也不那么急躁了，也不紧张了。所以爸爸觉得跟自己说说话，这个办法非常棒。</p><p>跟自己说说话，不但练习了口头的表达能力和沟通能力，并且还化解了自己的情绪，爸爸觉得这个方法非常非常棒。所以呢，爸爸每天都在坚持跟自己说说话，像跟秀恩聊天一样跟自己说说话。</p><p>第2个办法是。当爸爸感觉到紧张、难受、急躁的时候，就坐下来闭上眼睛去数数，数数的时候，我会观察自己。</p><p>观察自己的哪里难受，哪里紧张，是哪块肌肉很难受，是紧张还是疼痛？细致的观察自己。</p><p>爸爸就这样去观察自己的身体，在这种紧张和难受的状态下，肌肉是怎么收缩和抖动的？</p><p>慢慢地观察着观察着，爸爸发现自己的情绪开始化解了，爸爸发现自己没有这么难受和紧张了，原来只要爸爸闭上眼睛专注地观察他们，观察肌肉的疼痛和收缩，观察脑袋的紧绷，观察整个人的状态的时候，难受和紧张就慢慢的消失了。这种感觉太棒了。就感觉自己重新平静了下来，无论是生气还是难受，情绪都被化解了。</p><p>爸发现用这两种调节情绪的办法非常棒。</p><p>爸爸现在常用这种方式去化解自己的情绪，那些痛苦啊、难受啊、紧张啊、焦虑啊、急躁啊，都可以通过这样的方式去把它化解。</p><p>太棒了，爸爸每天都要坚持跟自己说说，观察自己的状态和身体的变化，化解掉自己的情绪。</p><p>今天的写信就到这里喽，宝宝们喜欢你们，爸爸爱你们哟。</p>",
            "url": "http://www.luzexi.com/2022/01/03/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A120",
            
            
            
            
            
            "date_published": "2022-01-03T00:00:00+08:00",
            "date_modified": "2022-01-03T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/12/29/%E6%96%B0%E4%B9%A6%E5%8F%91%E5%94%AE",
            "title": "新书发售《Unity3D高级编程-主程手记》",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布微信公众号新书发售了，感恩朋友们的厚爱。这么多年读书与写作给我最大的体会是，静下心来保持专注，是最有效率的。希望自己继续保持这份专注，并用最真诚的方式对待朋友们。本书共10章，每章都是一个独立的知识领域，读者可以按照章节顺序阅读本书，也可以根据喜好挑选自己感兴趣的章节学习。第1章讲了架构的意义、架构的原理以及如何实现架构。第2章对C#技术的基础知识做了讲解。第3章针对客户端中的表格数据、程序的协作与应用进行讲解。第4章讲解了用户界面（UI）的工作原理与优化方法。第5章针对3D模型的原理、动画的原理以及两者的优化做了详细的讲解。第6章讲解的是网络层的业务架构与底层原理。第7章针对各类AI做了详细的讲解。第8章主要讲解场景构建与优化、地图构建以及寻路算法优化的相关知识。第9章讲解了图形数学、图形学常用算法、渲染管线的相关知识。第10章针对客户端各类渲染技术的渲染原理做了详细的解剖。此书非常适合那些上进、积极、热爱技术的伙伴们。如果你想更上一层楼，想了解主程需要做什么，主程需要哪方面的技术深度，就来看看这本书。整本书字里行间都透露着对游戏开发的深度理解，以及对主程工作的感悟。2021.12.28，预售开始了，后面的日子里会陆续上架各大平台，包括新华书店、机械工业出版社平台、以及当当网。感恩遇见",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247485108&amp;idx=1&amp;sn=b949ce0d6f031a2108586940aa0eadfa&amp;chksm=fc2263b3cb55eaa5b5c3fe41399d47d7f1e0f66ce5b130c0e31648be035e9535f5c6c3d5ed39&amp;token=330432434&amp;lang=zh_CN#rd\">已发布微信公众号</a></p><p><img src=\"/assets/book/fengmian.jpg\" alt=\"封面\" /></p><h3 id=\"新书发售了感恩朋友们的厚爱\">新书发售了，感恩朋友们的厚爱。</h3><p>这么多年读书与写作给我最大的体会是，</p><p>静下心来保持专注，是最有效率的。</p><p>希望自己继续保持这份专注，并用最真诚的方式对待朋友们。</p><h3 id=\"本书共10章每章都是一个独立的知识领域读者可以按照章节顺序阅读本书也可以根据喜好挑选自己感兴趣的章节学习\">本书共10章，每章都是一个独立的知识领域，读者可以按照章节顺序阅读本书，也可以根据喜好挑选自己感兴趣的章节学习。</h3><p>第1章讲了架构的意义、架构的原理以及如何实现架构。</p><p>第2章对C#技术的基础知识做了讲解。</p><p>第3章针对客户端中的表格数据、程序的协作与应用进行讲解。</p><p>第4章讲解了用户界面（UI）的工作原理与优化方法。</p><p>第5章针对3D模型的原理、动画的原理以及两者的优化做了详细的讲解。</p><p>第6章讲解的是网络层的业务架构与底层原理。</p><p>第7章针对各类AI做了详细的讲解。</p><p>第8章主要讲解场景构建与优化、地图构建以及寻路算法优化的相关知识。</p><p>第9章讲解了图形数学、图形学常用算法、渲染管线的相关知识。</p><p>第10章针对客户端各类渲染技术的渲染原理做了详细的解剖。</p><h3 id=\"此书非常适合那些上进积极热爱技术的伙伴们\">此书非常适合那些上进、积极、热爱技术的伙伴们。</h3><p>如果你想更上一层楼，想了解主程需要做什么，主程需要哪方面的技术深度，就来看看这本书。</p><p>整本书字里行间都透露着对游戏开发的深度理解，以及对主程工作的感悟。</p><h3 id=\"20211228预售开始了后面的日子里会陆续上架各大平台包括新华书店机械工业出版社平台以及当当网\">2021.12.28，预售开始了，后面的日子里会陆续上架各大平台，包括新华书店、机械工业出版社平台、以及当当网。</h3><h2 id=\"感恩遇见\">感恩遇见</h2><p><img src=\"/assets/book/shudian1.jpg\" alt=\"淘宝预售\" /></p><p><img src=\"/assets/book/shudian3.jpg\" alt=\"京东预售\" /></p><p><img src=\"/assets/book/shudian2.jpg\" alt=\"淘宝搜索\" /></p>",
            "url": "http://www.luzexi.com/2021/12/29/%E6%96%B0%E4%B9%A6%E5%8F%91%E5%94%AE",
            
            
            
            "tags": ["书籍著作","前端技术","Unity3D"],
            
            "date_published": "2021-12-29T00:00:00+08:00",
            "date_modified": "2021-12-29T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/12/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B051",
            "title": "读书笔记(五十一) 《游戏引擎架构》#4 低阶渲染器（4）",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：作为游戏开发从业者，从业务到语言到框架到引擎，积累了一些知识和经验，特别是在看了几遍《游戏引擎架构》后对引擎架构的理解又深入了些。近段时间有对引擎剖析的想法，正好借这书本对游戏引擎架构做一个完整分析。此书用简明、清楚的方式覆盖了游戏引擎架构的庞大领域，巧妙地平衡了广度与深度，并且提供了足够的细节。借助《游戏引擎架构》这本书、结合引擎源码和自己的经验，深入分析游戏引擎的历史、架构、模块，最后通过实践简单引擎开发来完成对引擎知识的掌握。游戏引擎知识面深而广，所以对这系列的文章书编写范围做个保护，即不对细节进行过多的阐述，重点剖析的是架构、流程以及模块的运作原理。同时《游戏引擎架构》中部分知识太过陈旧的部分，会重新深挖后总结出自己的观点。概述：本系列文章对引擎中的重要的模块和库进行详细的分析，我挑选了十五个库和模块来分析：1.时间库2.自定义容器库3.字符串散列库4.内存管理框架5.RTTI与反射模块6.图形计算库7.资产管理模块8.低阶渲染器9.剔除与合批模块10.动画模块11.物理模块12.UI底层框架13.性能剖析器的核心部分14.脚本系统15.视觉效果模块本篇内容为列表中的第8个部分的第1节。正文：简单回顾下前文前文我们聊了下显卡在计算机硬件主板中的位置与结构，知道了CPU、GPU的通信介质，并简单介绍了手机上的主板结构。本篇开头对上一篇做一些内容补充，PC和手机的不同硬件组织，以及CPU与其他芯片的通信过程。下面我们开始这篇内容本次内容会围绕GPU来写，从硬件架构到软件驱动再到引擎架构，目标是帮大家理解GPU硬件的运作原理，理解图形接口的架构，理解引擎低阶渲染器的架构。目录：  主板结构中的显卡  GPU功能发展史  GPU与CPU的差异  GPU硬件特点  图形驱动程序架构  引擎低阶渲染架构内容结构：  CPU硬件结构  GPU硬件结构  GPU手机管线与PC管线的差异接着上篇的内容。前面说了CPU、GPU的硬件结构，CPU的构造和GPU的构造，下面我们来聊聊GPU是如何工作的，以及GPU的管线在手机端和PC端的差异。NVIDIA基于Fermi管线的架构关于GPU的逻辑管线，这篇Nvidia这篇文章《Life of a triangle - NVIDIA’s logical pipeline》说的很清楚。（NVIDIA的整体架构图）下面我以此为标准进行翻译并重新剖析。为了简单起见，省略了几个细节，假设 drawcall 引用了一些已经充满数据并存在于 GPU DRAM 中的索引和顶点缓冲区，并且仅使用顶点和像素着色器（GL：片段着色器）。（从图形API调用到图元处理过程图）1.引擎或业务程序调用图形 API（DX 或 GL）中的绘图函数，接着驱动程序会被调用，驱动程序会进行一些验证以检查参数是否“合法”，再将指令写入到GPU可读写的缓冲队列中。在这个地方 CPU 方面可能会出现很多瓶颈，这也是为什么程序员要好好使用 API 以利用当今 GPU 的强大功能的技术很重要的原因。（绘制接口调用图）2.经过一段时间渲染，画面“刷新”被调用，驱动程序在缓冲区中已经缓冲了足够多的工作命令，接着将其发送给 GPU 进行处理（操作系统会参与）。最后 GPU 的主机接口接收命令并交给GPU前端的处理。（绘制队列与刷新图）3.接着图元分配器（Primitive Distributor）开始分配工作。为了批量处理索引和三角形，将数据发送给多个图形处理集群（GPC）并行处理。（SM整体结构图）4.在 GPC 中，每个 SM 的 Poly Morph 引擎负责从三角形索引中获取顶点数据(Vertex Fetch)。5.在获取数据后，SM中每32个线程为一捆线程束（Warp），它们被调度去处理这些顶点工作。 线程束（Warp）是典型的单指令多线程（SIMT，SIMD单指令多数据的升级）的实现，也就是32个线程同时执行的指令是一模一样的，只是线程数据不一样，这样的好处就是一个Warp只需要一套逻辑对指令进行解码和执行就可以了，芯片可以做的更小更快。（线程束与线程束调度器图）6.SM的线程束（Warp）调度器会按照顺序分发指令给整个线程束（Warp），单个线程束（Warp）中的线程会锁步(lock-step)执行各自的指令。线程束（Warp）会使用SIMT的方式来做分支预测，每个线程执行的分支会不同，当线程遇到到错误判断的执行情况会被遮蔽(be masked out)。（单个GPU线程与存储设备的关系图）被遮蔽的原因是SIMT执行中错误预测，例如当前的指令是if(true)的分支，但是当前线程的数据的条件是false，或者循环的次数不一样（比如for循环次数n不是常量，或被break提前终止了但是别的还在走），因此在Shader中的分支会显著增加时间消耗，在一个线程束（Warp）中的分支除非32个线程都走到同一个里面，否则相当于所有的分支都走了一遍，线程不能独立执行指令而是以线程束（Warp）为单位，而这些线程束中的线程之间才是相互独立的。（SIMT线程束做分支预测图）7、线程束（Warp）中的指令可以被一次完成，也可能经过多次调度，例如通常SM中的LD/ST(加载存取)单元数量明显少于基础数学操作单元。8、由于某些指令比其他指令需要更长的时间才能完成，特别是内存加载，线程束（Warp）调度器可能会简单地切换到另一个没有内存等待的线程束（Warp），这是GPU如何克服内存读取延迟的关键，其操作为简单地切换活动线程组。为了使这种切换更快，调度器管理的所有线程束（Warp）在寄存器列阵（Register File）中都有自己的寄存器。这里就会有个矛盾产生，Shader需要的寄存器越多，给线程束（Warp）留下的空间就越少，于是就会导致能用的线程束（Warp）就越少。此时如果碰到指令在内存获取数据等待就只会等待，而没有其他可以运行的线程束（Warp）可以切换。（线程与寄存器列阵关系图）（线程束调度器调度线程图）9、一旦线程束（Warp）完成了顶点着色器（vertex-shader）的所有指令，运算结果会被Viewport Transform模块处理，三角形会被裁剪然后准备光栅化，此时GPU会使用L1和L2缓存来进行顶点着色起（vertex-shader）和片元着色起（pixel-shader）的数据通信。（管线中节点、数据、存储器的关系图）10、接下来这些三角形将被分割，通过 Work Distribution Crossbar 将三角形再分配给多个GPC，三角形的范围决定着它将被分配到哪个光栅引擎(raster engines)，每个光栅引擎（raster engines）覆盖了多个屏幕上的图块（tile），这等于把三角形的渲染分配到多个图块（tile）上面。也就是说在像素阶段前就把三角形划分成了方块格式范围，三角形处理分成许多较小的工作。（三角形被拆分成多个块派发到多个光栅引擎图）（图块拆分任务派发图）11、SM上的属性安装器（Attribute Setup）保证了从顶点着色器（vertex-shader）生成的数据，经过插值后，在片元着色器（pixel-shade）上是可读的。12、GPC上的光栅引擎(raster engines)处理它接收到的三角形，并为它负责的那些部分生成像素信息（同时会处理裁剪Clipping、背面剔除和Early-Z剔除）。13、再次做批量处理，32个像素线程被分成一组（或者说8个2x2的像素块），这是在像素着色器上面的最小工作单元（2x2 四边形允许我们计算诸如纹理 mip 贴图过滤之类的导数–四边形内纹理坐标的大变化会导致更高的 mip）。在这个像素线程内，如果没有被任何三角形覆盖就会被剔除。SM中的线程束（Warp）调度器会管理像素着色器的任务。（2x2像素组传入到线程束处理像素着色器的图）14、接下来是同样的线程束调度策略，和顶点着色器（vertex-shader）中的逻辑步骤完全一样，但是变成了在像素着色器线程中执行。 由于不耗费任何性能从2x2四边形中获取一个像素，这使得锁步执行非常便利，于是所有的线程可以保证指令可以在同一点同步执行。（线程束锁步执行图）15、最后一步，现在像素着色器已经完成了颜色的计算和深度值的计算。在这个点上，我们必须考虑三角形的调用API顺序，然后才将数据移交给ROP(render output unit，渲染输出单元)，一个ROP内部有很多ROP单元，在ROP单元中处理深度测试和帧缓冲（framebuffer）的混合等，深度和颜色的设置必须是原子操作，否则两个不同的三角形在同一个像素点就会有冲突和错误。NVIDIA 通常应用内存压缩，以减少内存带宽要求，从而增加“有效”带宽。（像素着色器后的像素处理过程图）以上这些信息有助于我们理解 GPU 中的一些工作和数据流，还可以帮助我们理解CPU与GPU之间的交互。总结CPU和GPU的交互GPU是设备，设备都有驱动，CPU可以直接执行二进制指令集，对于GPU设备，图形接口有opengl，directx标准及库封装，计算有cuda和opencl封装。程序代码调用这些图形或计算库，这些库调用驱动，驱动再来对接操作GPU设备，CPU与GPU直接的通信是遵循总线和内存的规则。原则上CPU、内存外的设备都属于IO设备，通过总线连上来，它们必须遵守IO总线规范，如显卡就走pcie总线，这里还有ionmu，统一内存等，来共享资源，缩短路径，提升效率等。这里专门说下驱动，计算机有专门的程序接口指定一个计算任务到GPU上，这个接口程序就是驱动程序。CPU给GPU下发任务时通过调用驱动程序，不同GPU厂商实现自己的驱动，并且提供了各种的编程接口。图形计算上实现了OpenGL标准接口规范的图形库，它会调用各厂商的驱动，用户可以通过GLSL编写计算任务进行通用计算。后来的CUDA编程模型专门推出用于编写通用计算任务的接口，于是OpenGL就专门用于图形渲染了。而CUDA则是通过kenel函数来编写计算任务，通过cudaLaunch接口来下发任务。（从图形库到驱动到GPU指令队列的图）从硬件角度看：（从硬件角度看指令和数据处理流程图）1.GPU设备的配置空间物理地址映射到虚拟地址，可以被程序直接访问；同时建立任务队列缓冲，声明中断等等；2.CPU在进程内准备数据和缓冲，基于虚拟地址VA、VM将其转换为显存的物理地址IPA。驱动程序获取任务，再将任务信息填充至任务队列内。3.根据虚拟内存绑定的地址信息，将任务队列的指针更新至GPU设备侧，这个端口称为doorbell寄存器；4.设备接收到doorbell操作，会触发中断，再读取主存中的任务队列，包括队列内的信息和其指向的任务数据，GPU设备侧读取该数据。5.完成后，再将数据发送给CPU侧。一般来说，GPU设备侧发送至CPU的读写请求使用的是虚拟地址，由CPU的IOMMU或SMMU转换为物理地址。GPU手机管线与PC管线的差异为什么要了解手机与PC管线的差异？PC的能耗和发热比手机端可以更大一些，因此PC与手机在硬件架构上有天然的不同，进而使得它们在GPU管线上也有很大的差异，这使得我们在优化手机端时必须了解这种差异再做针对性的做优化。TBDR(Tile-Base-Deffered-Rendering)是现代移动端GPU的设计架构，它同传统PC上IR（Immediate-Rendering）架构的GPU在硬件设计上有很大的差别。为什么呢？因为功耗是Mobile设备设计的第一考虑因素，而带宽是功耗的第一杀手。我们来看PC的GPU管线，即传统的IR（Immediate-Rendering）模式：（IMR管线图：源自网络）IMR（Immediate Mode Rendering）模式中，GPU直接在主存或显存上读写深度缓存（Depth Buffer）和帧缓存（Frame Buffer），这导致带宽消耗很大，如果在手机上耗电和发热都无法承受。手机使用统一内存架构，CPU和GPU都通过总线来访问主存。GPU需要获取三角形数据（Geometry Data）、贴图数据（Texture Data）以及帧缓存（Frame Buffer），它们都在主存中。如果GPU直接从主存频繁地访问这些数据，就会导致带宽消耗大，成为性能瓶颈。TBR（Tile-Based-Rendering）管线基于以上所述原因，手机GPU使用自己的缓存区（SRAM），例如On-Chip深度缓存（On-Chip Depth Buffer）和On-Chip颜色缓存（On-Chip Color Buffer），它们与存取主存相比，速度更快，功耗更低。但它们的存储空间很小。（SRAM不需要充电来保持存储记忆，因此SRAM的读写基本不耗电，缺点是价格昂贵）如果手机直接读写帧缓存（Frame Buffer）就相当于让一辆火车在你家和公司之间来回奔跑，非常耗电。于是手机端想要拆分绘制内容，每次只绘制一小部分，再把所有绘制完成的部分拼起来。把帧缓存（Frame Buffer）拆分成很多个小块，使得每个小块可以被GPU附近的SRAM容纳，块的多少取决于GPU硬件的SRAM大小。这样GPU就可以分批的一块块的在SRAM上读写帧缓存（Frame Buffer），一整块都读写完毕后，再整体转移回主存上。这种模式就叫做TBR（Tile-Based-Rendering），整体管线如下图：（TBR管线图：源自网络）屏幕分块后的大小一般为16x16或32x32像素 ，在几何阶段之后再执行分块(Tiling)，接着将各个块（Tile）逐个光栅化，最后写入帧缓存中（Frame Buffer）中 。这里有一些细节要注意，TBR在接受每个指令（CommandBuffer）时并不立即绘制，而是先对这些数据做顶点处理，把顶点处理的结果暂时保存在主存上，等到非得刷新整个帧缓存时，才真正的用这批数据做光栅化。因此，TBR的管线实际可以认为被切分成两部分，前半部分为顶点数据部分，后半部分为片元数据部分：（TBR把管线切分为光栅化前和光栅化后）顶点数据先被处理并存储在Frame Data中，等到必须刷新时（例如帧缓存置换，调用glflush，调用glfinish，调用glreadpixels读取帧缓存像素时，调用glcopytexiamge拷贝贴图时，调用glbitframebuffer获取帧缓存时，调用queryingocclusion，解绑帧缓存时等等）才被集中的拿去处理光栅化。那么为什么PC不使用TBR呢？实际上直接对主存或显存（这里也有多级缓存）进行整块数据的读写速度是最快的，而TBR需要一块块的绘制，然后再回拷给主存。可以简单的认为TBR牺牲了执行效率，换来了相对更难解决的带宽功耗。如果哪一天手机上解决了带宽的功耗问题，或者说SRAM足够大了，可能就没有TBR了。TBDR（Tile-based deferred rendering）管线TBR会把顶点数据处理完毕后存储在Frame Data中，那么就会有很多厂商针对Frame Data做优化。TBDR整体的管线图如下：（TBDR管线图：源自网络）我们看到相比TBR，TBDR在光栅化（Raster）后多了一个HSR（Hidden Surface Removal）处理，这部分处理主要剔除无需绘制的元素，减少重绘（Overdraw）数量（高通通过优化划分块（Tile）之后执行顶点着色器（Vertex Shader）之前的节点来达到此目的，称为LRZ）。例如提前对不透明像素做深度测试并剔除，剔除被模板裁剪掉的像素等等，总之它们不会进入到像素着色器阶段（Pixel Shader）。因此在TBDR上，不透明物体的排序没有太大意义，Early-Z这种策略也不存在IOS上。这些GPU硬件巧妙的利用TBR的Frame Data队列实现了一种延迟渲染，尽可能只渲染那些会最终影响帧缓存（Frame Buffer）的像素。TBDR和软件上的延迟渲染相比有什么区别呢？软件层面的延迟渲染与TBDR不同。软件层面的延迟渲染是针对一个Drawcall，对于从后到前的不透明物体绘制是每次都要绘制的，而硬件层面的延迟渲染，处理的是一整批Drawcall，剔除这一整批Drawcall中不会绘制的像素最后再渲染。可以说现在大部分的移动端的GPU都使用TBDR架构。参考资料：《How Shader Cores Work》https://engineering.purdue.edu/~smidkiff/KKU/files/GPUIntro.pdf《CPU体系结构》https://my.oschina.net/fileoptions/blog/1633021《深入理解CPU的分支预测(Branch Prediction)模型》https://zhuanlan.zhihu.com/p/22469702《分析Unity在移动设备的GPU内存机制（iOS篇）》https://www.jianshu.com/p/68b41a8d0b37《PC与Mobile硬件架构对比》https://www.cnblogs.com/kekec/p/14487050.html《针对移动端TBDR架构GPU特性的渲染优化》https://gameinstitute.qq.com/community/detail/123220《A look at the PowerVR graphics architecture: Tile-based rendering》https://www.imaginationtech.com/blog/a-look-at-the-powervr-graphics-architecture-tile-based-rendering/《A look at the PowerVR graphics architecture: Deferred rendering》https://www.imaginationtech.com/blog/the-dr-in-tbdr-deferred-rendering-in-rogue/《深入GPU硬件架构及运行机制》https://www.cnblogs.com/timlly/p/11471507.html《深入浅出计算机组成原理》https://time.geekbang.org/column/article/105401?code=7VZ-Md9oM7vSBSE6JyOgcoQhDWTOd-bz5CY8xqGx234%3D《Nvidia Geforce RTX-series is born》https://www.fudzilla.com/reviews/47224-nvidia-geforce-rtx-series-is-born?start=2《渲染管线与GPU（Shading前置知识）》https://zhuanlan.zhihu.com/p/336999443《剖析虚幻渲染体系（12）- 移动端专题Part 1（UE移动端渲染分析）》https://www.cnblogs.com/timlly/p/15511402.html《tpc-texture-processing-cluster》https://gputoaster.wordpress.com/2010/12/11/tpc-texture-processing-cluster/《Life of a triangle - NVIDIA’s logical pipeline》https://developer.nvidia.com/content/life-triangle-nvidias-logical-pipeline《Rasterisation wiki》https://en.wikipedia.org/wiki/Rasterisation《PolyMorph engine and Data Caches by Hilbert Hagedoorn》https://www.guru3d.com/articles-pages/nvidia-gf100-(fermi)-technology-preview,3.html《NVIDIA GPU的一些解析》https://zhuanlan.zhihu.com/p/258196004《tensor-core-performance-the-ultimate-guide》https://developer.download.nvidia.cn/video/gputechconf/gtc/2019/presentation/s9926-tensor-core-performance-the-ultimate-guide.pdf《Understanding the Understanding the graphics pipeline》https://www.seas.upenn.edu/~cis565/LECTURES/Lecture2%20New.pdf已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247485096&amp;idx=1&amp;sn=c027b6af4677515ba1e5950aac8ba68d&amp;chksm=fc2263afcb55eab9204898b39fb77ee04f5767ac450507b6192a5c6d5612a45b6d29b1bcee16&amp;token=853743270&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h1 id=\"背景\">背景：</h1><p>作为游戏开发从业者，从业务到语言到框架到引擎，积累了一些知识和经验，特别是在看了几遍《游戏引擎架构》后对引擎架构的理解又深入了些。</p><p>近段时间有对引擎剖析的想法，正好借这书本对游戏引擎架构做一个完整分析。</p><p>此书用简明、清楚的方式覆盖了游戏引擎架构的庞大领域，巧妙地平衡了广度与深度，并且提供了足够的细节。</p><p>借助《游戏引擎架构》这本书、结合引擎源码和自己的经验，深入分析游戏引擎的历史、架构、模块，最后通过实践简单引擎开发来完成对引擎知识的掌握。</p><p>游戏引擎知识面深而广，所以对这系列的文章书编写范围做个保护，即不对细节进行过多的阐述，重点剖析的是架构、流程以及模块的运作原理。</p><p>同时《游戏引擎架构》中部分知识太过陈旧的部分，会重新深挖后总结出自己的观点。</p><h1 id=\"概述\">概述：</h1><p>本系列文章对引擎中的重要的模块和库进行详细的分析，我挑选了十五个库和模块来分析：</p><p>1.时间库2.自定义容器库3.字符串散列库4.内存管理框架5.RTTI与反射模块6.图形计算库7.资产管理模块8.低阶渲染器9.剔除与合批模块10.动画模块11.物理模块12.UI底层框架13.性能剖析器的核心部分14.脚本系统15.视觉效果模块</p><p>本篇内容为列表中的第8个部分的第1节。</p><h1 id=\"正文\">正文：</h1><p>简单回顾下前文</p><p>前文我们聊了下显卡在计算机硬件主板中的位置与结构，知道了CPU、GPU的通信介质，并简单介绍了手机上的主板结构。本篇开头对上一篇做一些内容补充，PC和手机的不同硬件组织，以及CPU与其他芯片的通信过程。</p><p>下面我们开始这篇内容</p><p>本次内容会围绕GPU来写，从硬件架构到软件驱动再到引擎架构，目标是帮大家理解GPU硬件的运作原理，理解图形接口的架构，理解引擎低阶渲染器的架构。</p><p>目录：</p><ul>  <li>主板结构中的显卡</li>  <li>GPU功能发展史</li>  <li>GPU与CPU的差异</li>  <li>GPU硬件特点</li>  <li>图形驱动程序架构</li>  <li>引擎低阶渲染架构</li></ul><p>内容结构：</p><ul>  <li>CPU硬件结构</li>  <li>GPU硬件结构</li>  <li>GPU手机管线与PC管线的差异</li></ul><p>接着上篇的内容。前面说了CPU、GPU的硬件结构，CPU的构造和GPU的构造，下面我们来聊聊GPU是如何工作的，以及GPU的管线在手机端和PC端的差异。</p><h2 id=\"nvidia基于fermi管线的架构\">NVIDIA基于Fermi管线的架构</h2><p>关于GPU的逻辑管线，这篇Nvidia这篇文章《Life of a triangle - NVIDIA’s logical pipeline》说的很清楚。</p><p>（NVIDIA的整体架构图）</p><p>下面我以此为标准进行翻译并重新剖析。</p><p>为了简单起见，省略了几个细节，假设 drawcall 引用了一些已经充满数据并存在于 GPU DRAM 中的索引和顶点缓冲区，并且仅使用顶点和像素着色器（GL：片段着色器）。</p><p>（从图形API调用到图元处理过程图）</p><p>1.引擎或业务程序调用图形 API（DX 或 GL）中的绘图函数，接着驱动程序会被调用，驱动程序会进行一些验证以检查参数是否“合法”，再将指令写入到GPU可读写的缓冲队列中。在这个地方 CPU 方面可能会出现很多瓶颈，这也是为什么程序员要好好使用 API 以利用当今 GPU 的强大功能的技术很重要的原因。</p><p>（绘制接口调用图）</p><p>2.经过一段时间渲染，画面“刷新”被调用，驱动程序在缓冲区中已经缓冲了足够多的工作命令，接着将其发送给 GPU 进行处理（操作系统会参与）。最后 GPU 的主机接口接收命令并交给GPU前端的处理。</p><p>（绘制队列与刷新图）</p><p>3.接着图元分配器（Primitive Distributor）开始分配工作。为了批量处理索引和三角形，将数据发送给多个图形处理集群（GPC）并行处理。</p><p>（SM整体结构图）</p><p>4.在 GPC 中，每个 SM 的 Poly Morph 引擎负责从三角形索引中获取顶点数据(Vertex Fetch)。</p><p>5.在获取数据后，SM中每32个线程为一捆线程束（Warp），它们被调度去处理这些顶点工作。 线程束（Warp）是典型的单指令多线程（SIMT，SIMD单指令多数据的升级）的实现，也就是32个线程同时执行的指令是一模一样的，只是线程数据不一样，这样的好处就是一个Warp只需要一套逻辑对指令进行解码和执行就可以了，芯片可以做的更小更快。</p><p>（线程束与线程束调度器图）</p><p>6.SM的线程束（Warp）调度器会按照顺序分发指令给整个线程束（Warp），单个线程束（Warp）中的线程会锁步(lock-step)执行各自的指令。线程束（Warp）会使用SIMT的方式来做分支预测，每个线程执行的分支会不同，当线程遇到到错误判断的执行情况会被遮蔽(be masked out)。</p><p>（单个GPU线程与存储设备的关系图）</p><p>被遮蔽的原因是SIMT执行中错误预测，例如当前的指令是if(true)的分支，但是当前线程的数据的条件是false，或者循环的次数不一样（比如for循环次数n不是常量，或被break提前终止了但是别的还在走），因此在Shader中的分支会显著增加时间消耗，在一个线程束（Warp）中的分支除非32个线程都走到同一个里面，否则相当于所有的分支都走了一遍，线程不能独立执行指令而是以线程束（Warp）为单位，而这些线程束中的线程之间才是相互独立的。</p><p>（SIMT线程束做分支预测图）</p><p>7、线程束（Warp）中的指令可以被一次完成，也可能经过多次调度，例如通常SM中的LD/ST(加载存取)单元数量明显少于基础数学操作单元。</p><p>8、由于某些指令比其他指令需要更长的时间才能完成，特别是内存加载，线程束（Warp）调度器可能会简单地切换到另一个没有内存等待的线程束（Warp），这是GPU如何克服内存读取延迟的关键，其操作为简单地切换活动线程组。为了使这种切换更快，调度器管理的所有线程束（Warp）在寄存器列阵（Register File）中都有自己的寄存器。这里就会有个矛盾产生，Shader需要的寄存器越多，给线程束（Warp）留下的空间就越少，于是就会导致能用的线程束（Warp）就越少。此时如果碰到指令在内存获取数据等待就只会等待，而没有其他可以运行的线程束（Warp）可以切换。</p><p>（线程与寄存器列阵关系图）</p><p>（线程束调度器调度线程图）</p><p>9、一旦线程束（Warp）完成了顶点着色器（vertex-shader）的所有指令，运算结果会被Viewport Transform模块处理，三角形会被裁剪然后准备光栅化，此时GPU会使用L1和L2缓存来进行顶点着色起（vertex-shader）和片元着色起（pixel-shader）的数据通信。</p><p>（管线中节点、数据、存储器的关系图）</p><p>10、接下来这些三角形将被分割，通过 Work Distribution Crossbar 将三角形再分配给多个GPC，三角形的范围决定着它将被分配到哪个光栅引擎(raster engines)，每个光栅引擎（raster engines）覆盖了多个屏幕上的图块（tile），这等于把三角形的渲染分配到多个图块（tile）上面。也就是说在像素阶段前就把三角形划分成了方块格式范围，三角形处理分成许多较小的工作。</p><p>（三角形被拆分成多个块派发到多个光栅引擎图）</p><p>（图块拆分任务派发图）</p><p>11、SM上的属性安装器（Attribute Setup）保证了从顶点着色器（vertex-shader）生成的数据，经过插值后，在片元着色器（pixel-shade）上是可读的。</p><p>12、GPC上的光栅引擎(raster engines)处理它接收到的三角形，并为它负责的那些部分生成像素信息（同时会处理裁剪Clipping、背面剔除和Early-Z剔除）。</p><p>13、再次做批量处理，32个像素线程被分成一组（或者说8个2x2的像素块），这是在像素着色器上面的最小工作单元（2x2 四边形允许我们计算诸如纹理 mip 贴图过滤之类的导数–四边形内纹理坐标的大变化会导致更高的 mip）。在这个像素线程内，如果没有被任何三角形覆盖就会被剔除。SM中的线程束（Warp）调度器会管理像素着色器的任务。</p><p>（2x2像素组传入到线程束处理像素着色器的图）</p><p>14、接下来是同样的线程束调度策略，和顶点着色器（vertex-shader）中的逻辑步骤完全一样，但是变成了在像素着色器线程中执行。 由于不耗费任何性能从2x2四边形中获取一个像素，这使得锁步执行非常便利，于是所有的线程可以保证指令可以在同一点同步执行。</p><p>（线程束锁步执行图）</p><p>15、最后一步，现在像素着色器已经完成了颜色的计算和深度值的计算。在这个点上，我们必须考虑三角形的调用API顺序，然后才将数据移交给ROP(render output unit，渲染输出单元)，一个ROP内部有很多ROP单元，在ROP单元中处理深度测试和帧缓冲（framebuffer）的混合等，深度和颜色的设置必须是原子操作，否则两个不同的三角形在同一个像素点就会有冲突和错误。NVIDIA 通常应用内存压缩，以减少内存带宽要求，从而增加“有效”带宽。</p><p>（像素着色器后的像素处理过程图）</p><p>以上这些信息有助于我们理解 GPU 中的一些工作和数据流，还可以帮助我们理解CPU与GPU之间的交互。</p><h2 id=\"总结cpu和gpu的交互\">总结CPU和GPU的交互</h2><p>GPU是设备，设备都有驱动，CPU可以直接执行二进制指令集，对于GPU设备，图形接口有opengl，directx标准及库封装，计算有cuda和opencl封装。程序代码调用这些图形或计算库，这些库调用驱动，驱动再来对接操作GPU设备，CPU与GPU直接的通信是遵循总线和内存的规则。</p><p>原则上CPU、内存外的设备都属于IO设备，通过总线连上来，它们必须遵守IO总线规范，如显卡就走pcie总线，这里还有ionmu，统一内存等，来共享资源，缩短路径，提升效率等。</p><p>这里专门说下驱动，计算机有专门的程序接口指定一个计算任务到GPU上，这个接口程序就是驱动程序。CPU给GPU下发任务时通过调用驱动程序，不同GPU厂商实现自己的驱动，并且提供了各种的编程接口。图形计算上实现了OpenGL标准接口规范的图形库，它会调用各厂商的驱动，用户可以通过GLSL编写计算任务进行通用计算。后来的CUDA编程模型专门推出用于编写通用计算任务的接口，于是OpenGL就专门用于图形渲染了。而CUDA则是通过kenel函数来编写计算任务，通过cudaLaunch接口来下发任务。</p><p>（从图形库到驱动到GPU指令队列的图）</p><p>从硬件角度看：</p><p>（从硬件角度看指令和数据处理流程图）</p><p>1.GPU设备的配置空间物理地址映射到虚拟地址，可以被程序直接访问；同时建立任务队列缓冲，声明中断等等；</p><p>2.CPU在进程内准备数据和缓冲，基于虚拟地址VA、VM将其转换为显存的物理地址IPA。驱动程序获取任务，再将任务信息填充至任务队列内。</p><p>3.根据虚拟内存绑定的地址信息，将任务队列的指针更新至GPU设备侧，这个端口称为doorbell寄存器；</p><p>4.设备接收到doorbell操作，会触发中断，再读取主存中的任务队列，包括队列内的信息和其指向的任务数据，GPU设备侧读取该数据。</p><p>5.完成后，再将数据发送给CPU侧。一般来说，GPU设备侧发送至CPU的读写请求使用的是虚拟地址，由CPU的IOMMU或SMMU转换为物理地址。</p><h2 id=\"gpu手机管线与pc管线的差异\">GPU手机管线与PC管线的差异</h2><p>为什么要了解手机与PC管线的差异？PC的能耗和发热比手机端可以更大一些，因此PC与手机在硬件架构上有天然的不同，进而使得它们在GPU管线上也有很大的差异，这使得我们在优化手机端时必须了解这种差异再做针对性的做优化。</p><h2 id=\"tbdrtile-base-deffered-rendering是现代移动端gpu的设计架构它同传统pc上irimmediate-rendering架构的gpu在硬件设计上有很大的差别\">TBDR(Tile-Base-Deffered-Rendering)是现代移动端GPU的设计架构，它同传统PC上IR（Immediate-Rendering）架构的GPU在硬件设计上有很大的差别。</h2><p>为什么呢？因为功耗是Mobile设备设计的第一考虑因素，而带宽是功耗的第一杀手。</p><p>我们来看PC的GPU管线，即传统的IR（Immediate-Rendering）模式：</p><p>（IMR管线图：源自网络）</p><p>IMR（Immediate Mode Rendering）模式中，GPU直接在主存或显存上读写深度缓存（Depth Buffer）和帧缓存（Frame Buffer），这导致带宽消耗很大，如果在手机上耗电和发热都无法承受。</p><p>手机使用统一内存架构，CPU和GPU都通过总线来访问主存。GPU需要获取三角形数据（Geometry Data）、贴图数据（Texture Data）以及帧缓存（Frame Buffer），它们都在主存中。如果GPU直接从主存频繁地访问这些数据，就会导致带宽消耗大，成为性能瓶颈。</p><h2 id=\"tbrtile-based-rendering管线\">TBR（Tile-Based-Rendering）管线</h2><p>基于以上所述原因，手机GPU使用自己的缓存区（SRAM），例如On-Chip深度缓存（On-Chip Depth Buffer）和On-Chip颜色缓存（On-Chip Color Buffer），它们与存取主存相比，速度更快，功耗更低。但它们的存储空间很小。（SRAM不需要充电来保持存储记忆，因此SRAM的读写基本不耗电，缺点是价格昂贵）</p><p>如果手机直接读写帧缓存（Frame Buffer）就相当于让一辆火车在你家和公司之间来回奔跑，非常耗电。于是手机端想要拆分绘制内容，每次只绘制一小部分，再把所有绘制完成的部分拼起来。</p><p>把帧缓存（Frame Buffer）拆分成很多个小块，使得每个小块可以被GPU附近的SRAM容纳，块的多少取决于GPU硬件的SRAM大小。这样GPU就可以分批的一块块的在SRAM上读写帧缓存（Frame Buffer），一整块都读写完毕后，再整体转移回主存上。</p><p>这种模式就叫做TBR（Tile-Based-Rendering），整体管线如下图：</p><p>（TBR管线图：源自网络）</p><p>屏幕分块后的大小一般为16x16或32x32像素 ，在几何阶段之后再执行分块(Tiling)，接着将各个块（Tile）逐个光栅化，最后写入帧缓存中（Frame Buffer）中 。</p><p>这里有一些细节要注意，TBR在接受每个指令（CommandBuffer）时并不立即绘制，而是先对这些数据做顶点处理，把顶点处理的结果暂时保存在主存上，等到非得刷新整个帧缓存时，才真正的用这批数据做光栅化。</p><p>因此，TBR的管线实际可以认为被切分成两部分，前半部分为顶点数据部分，后半部分为片元数据部分：</p><p>（TBR把管线切分为光栅化前和光栅化后）</p><h3 id=\"顶点数据先被处理并存储在frame-data中等到必须刷新时例如帧缓存置换调用glflush调用glfinish调用glreadpixels读取帧缓存像素时调用glcopytexiamge拷贝贴图时调用glbitframebuffer获取帧缓存时调用queryingocclusion解绑帧缓存时等等才被集中的拿去处理光栅化\">顶点数据先被处理并存储在Frame Data中，等到必须刷新时（例如帧缓存置换，调用glflush，调用glfinish，调用glreadpixels读取帧缓存像素时，调用glcopytexiamge拷贝贴图时，调用glbitframebuffer获取帧缓存时，调用queryingocclusion，解绑帧缓存时等等）才被集中的拿去处理光栅化。</h3><h3 id=\"那么为什么pc不使用tbr呢\">那么为什么PC不使用TBR呢？</h3><p>实际上直接对主存或显存（这里也有多级缓存）进行整块数据的读写速度是最快的，而TBR需要一块块的绘制，然后再回拷给主存。可以简单的认为TBR牺牲了执行效率，换来了相对更难解决的带宽功耗。如果哪一天手机上解决了带宽的功耗问题，或者说SRAM足够大了，可能就没有TBR了。</p><h2 id=\"tbdrtile-based-deferred-rendering管线\">TBDR（Tile-based deferred rendering）管线</h2><p>TBR会把顶点数据处理完毕后存储在Frame Data中，那么就会有很多厂商针对Frame Data做优化。</p><p>TBDR整体的管线图如下：</p><p>（TBDR管线图：源自网络）</p><p>我们看到相比TBR，TBDR在光栅化（Raster）后多了一个HSR（Hidden Surface Removal）处理，这部分处理主要剔除无需绘制的元素，减少重绘（Overdraw）数量（高通通过优化划分块（Tile）之后执行顶点着色器（Vertex Shader）之前的节点来达到此目的，称为LRZ）。例如提前对不透明像素做深度测试并剔除，剔除被模板裁剪掉的像素等等，总之它们不会进入到像素着色器阶段（Pixel Shader）。</p><p>因此在TBDR上，不透明物体的排序没有太大意义，Early-Z这种策略也不存在IOS上。这些GPU硬件巧妙的利用TBR的Frame Data队列实现了一种延迟渲染，尽可能只渲染那些会最终影响帧缓存（Frame Buffer）的像素。</p><h3 id=\"tbdr和软件上的延迟渲染相比有什么区别呢\">TBDR和软件上的延迟渲染相比有什么区别呢？</h3><p>软件层面的延迟渲染与TBDR不同。软件层面的延迟渲染是针对一个Drawcall，对于从后到前的不透明物体绘制是每次都要绘制的，而硬件层面的延迟渲染，处理的是一整批Drawcall，剔除这一整批Drawcall中不会绘制的像素最后再渲染。可以说现在大部分的移动端的GPU都使用TBDR架构。</p><h3 id=\"参考资料\">参考资料：</h3><p>《How Shader Cores Work》https://engineering.purdue.edu/~smidkiff/KKU/files/GPUIntro.pdf</p><p>《CPU体系结构》https://my.oschina.net/fileoptions/blog/1633021</p><p>《深入理解CPU的分支预测(Branch Prediction)模型》https://zhuanlan.zhihu.com/p/22469702</p><p>《分析Unity在移动设备的GPU内存机制（iOS篇）》https://www.jianshu.com/p/68b41a8d0b37</p><p>《PC与Mobile硬件架构对比》https://www.cnblogs.com/kekec/p/14487050.html</p><p>《针对移动端TBDR架构GPU特性的渲染优化》https://gameinstitute.qq.com/community/detail/123220</p><p>《A look at the PowerVR graphics architecture: Tile-based rendering》https://www.imaginationtech.com/blog/a-look-at-the-powervr-graphics-architecture-tile-based-rendering/</p><p>《A look at the PowerVR graphics architecture: Deferred rendering》https://www.imaginationtech.com/blog/the-dr-in-tbdr-deferred-rendering-in-rogue/</p><p>《深入GPU硬件架构及运行机制》https://www.cnblogs.com/timlly/p/11471507.html</p><p>《深入浅出计算机组成原理》https://time.geekbang.org/column/article/105401?code=7VZ-Md9oM7vSBSE6JyOgcoQhDWTOd-bz5CY8xqGx234%3D</p><p>《Nvidia Geforce RTX-series is born》https://www.fudzilla.com/reviews/47224-nvidia-geforce-rtx-series-is-born?start=2</p><p>《渲染管线与GPU（Shading前置知识）》https://zhuanlan.zhihu.com/p/336999443</p><p>《剖析虚幻渲染体系（12）- 移动端专题Part 1（UE移动端渲染分析）》https://www.cnblogs.com/timlly/p/15511402.html</p><p>《tpc-texture-processing-cluster》https://gputoaster.wordpress.com/2010/12/11/tpc-texture-processing-cluster/</p><p>《Life of a triangle - NVIDIA’s logical pipeline》https://developer.nvidia.com/content/life-triangle-nvidias-logical-pipeline</p><p>《Rasterisation wiki》https://en.wikipedia.org/wiki/Rasterisation</p><p>《PolyMorph engine and Data Caches by Hilbert Hagedoorn》https://www.guru3d.com/articles-pages/nvidia-gf100-(fermi)-technology-preview,3.html</p><p>《NVIDIA GPU的一些解析》https://zhuanlan.zhihu.com/p/258196004</p><p>《tensor-core-performance-the-ultimate-guide》https://developer.download.nvidia.cn/video/gputechconf/gtc/2019/presentation/s9926-tensor-core-performance-the-ultimate-guide.pdf</p><p>《Understanding the Understanding the graphics pipeline》https://www.seas.upenn.edu/~cis565/LECTURES/Lecture2%20New.pdf</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247485096&amp;idx=1&amp;sn=c027b6af4677515ba1e5950aac8ba68d&amp;chksm=fc2263afcb55eab9204898b39fb77ee04f5767ac450507b6192a5c6d5612a45b6d29b1bcee16&amp;token=853743270&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/12/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B051",
            
            
            
            "tags": ["读书笔记","前端技术"],
            
            "date_published": "2021-12-12T00:00:00+08:00",
            "date_modified": "2021-12-12T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/12/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B049",
            "title": "读书笔记(五十) 《如何精彩演讲》#2 克服演讲时的恐惧",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景不知不觉看完了6本关于演讲的主题，按推荐顺序排列分别是《高效演讲》、《演讲与口才》、《即兴演讲》、《关键对话》、《TED演讲的力量》、《说话的艺术》。我希望自己能够对演讲有一个系统性的学习。于是自己在平常的生活和工作中实践了一段时间，前前后后加起来有两个月时间。目标是，改善平常的工作、生活中表达的流畅和清晰度，能让人感觉到舒服让人感觉有活力。同时在公众演讲上，希望自己能够很好的呈现自己的所思所想以及所知所学。因此开启这个演讲学习系列的总结文章，我将对这6本书的内容加上我的实践经验做一次全面的系统性的总结。概述：  恐惧的原因  克服恐惧的原理  制定克服恐惧的行动内容：为什么要了解演讲时的恐惧？  只有了解恐惧的原理才能正确认识它  它会使得事情更加糟糕  它会对我们的心理产生长短期的变化在平时的生活工作学习当中，当我们恐惧时很多时候并不能了解自己的恐惧情绪。由于在很多情况下，我们观察不到自己的情绪，导致我们常常无法在情绪有问题时，及时的调整它。因此你会看到很多时候，当出现了恐惧的症状时，我们没有调整它，这直接导致事情发展变得糟糕。（恐惧表情图：来源网络）不止如此，如果没有去很好的应对恐惧的话，长此以往我们在心里会有比较大的阴影。这使得，我们在一件比较重要的会议上，由于你的恐惧而退缩或退却，会使你在精神上遭受更大的打击。如果次数多了，你会发现你对这些重要的场所，重要的机会，会产生习惯性的恐惧，这常常使你对人生产生比较多的怀疑。因此无论从长期或短期来看，我们都需要去主动的了解恐惧。这是我们必须去了解恐惧的重要原因。它会将生活弄得更加糟糕，因此我们必须了解他，特别是在演讲时。恐惧有很多种，这里我们只关注演讲时的恐惧。但其实演讲的恐惧已经覆盖了生活中很多的方面，它与生活中的恐惧有很多共性。是什么让你恐惧？了解恐惧产生的原因，可以让我们对恐惧问题的形成有更深刻的认识。不管是普通焦虑还是惊恐障碍，都没有单一的成因，也不可能在消除这个成因后问题就得到彻底根除。焦虑问题是有多方面，多种原因引起的，包括遗传因素，生物因素，家庭背景和教养方式、心理条件作用、近期生活转变、自我对话和个人信念体系、表达情感的能力、当前环境压力等。恐惧的原因：  面对重要场面，准备不充分  对周围的环境很陌生  经历不足，导致的对事情没有底气  在意别人对自己的看法  生理反应，肌肉紧张、心跳加速、头脑晕眩  近期自己身边的环境变动较大  长期积累的心里因素，过分在意过去发生的事情我们在面对演讲时通常会有很多的恐惧，特别是在上台前一段时间，自己的恐惧心理被放大的特别多。其实说来不只是演讲，恐惧在我们平常的生活跟工作当中也非常多，我们心里常常会对某件即将到来的事产生恐惧。因此呢。并不是说在演讲时你才会恐惧，在平常的生活当中，你同样会有很多令你焦虑不安的事情。演讲跟平常我们生活、工作时产生的恐惧是一样的，并没有说因为演讲而特殊。我们究竟为什么而恐惧？我们来分析一下。前面列了7条恐惧的原因，但其实这7条可以归类一下变得更精简一些。（恐惧原因）恐惧的原因总的来说为三方面：  准备不充分  环境变化导致的恐惧  长期积累的心理因素（恐惧原因细节图）第一，准备不充分当我们知道我们将要去面对一件事情，但是这件事情并没有充足的把握时我们就会感到恐惧。因为这件事情是未知的，而且我预感到他可能不会有太好的结果，因为我对他没有把握，我也没有对他做任何的准备工作。可能有这么一件事情你是从来没有做过的，或者说你也不知道他将会发生什么样的情况。甚至在你的预感当中，这件事会发生比较差的或者糟糕的情况，此时你就会对这件事情产生恐惧。因而有逃避去面对这件事情的心理状态。在演讲时也是同样的，大部分人没有台上演讲的经验和习惯，因此对于上台演讲这件事情，大部分人都是有恐惧心理的。这个恐惧心理是因为我们没有，为这件事情做过任何的准备，也不知道这件事情会发生怎样的情况。此时我们心里隐隐的感觉到这这件事情会比较糟糕。因此，我们对演讲产生了恐惧。总之，当你面对一件即将到来，但未知的事情时，当你面对一件你觉得可能会发生比较糟糕的事情时，通常是因为我们没有做好足够的准备工作。这个准备工作可能需要花去几小时、几天、几个月甚至几年的时间，总之我们并没有为这件事做好足够的准备。第二，环境变化导致的恐惧我们周围的环境时常在变化，包括我们的工作，上下级人员调动，以及你身边人的来往，以及你亲人的离去与归来，这些的环境都在时刻变化着，影响着我们的心理。可能是你最近比较倒霉，碰到了一些小概率事件，或者可能会因为大环境的变化使得感到沮丧。甚至有可能你出差到了某个陌生的环境，让你感到很不舒服。这些环境的变化都会让你产生焦虑甚至恐惧的心理。总之，在当前这样的环境下，是你并不熟悉的环境，不是你能掌控而环境，因此导致你对周围的环境有一种隔离感，像是没有依靠的感觉。第三，长期积累的心理因素你可能会因为曾经的遭遇而感到痛苦，这些遭遇在你的脑中挥之不去，当再次发生或者即将发生这样的事情的时候，你就会感到焦虑和恐惧。这些痛苦的场景通常会延伸到我们生活的各个角落，比如说，你可能曾经在小组发言时，磕磕巴巴导致你对公众发言产生了恐惧，致使你在现在上台演讲时都会表现的异常的惊恐，当回忆起自己以前在小组发言时的那些场景，以及当时人们都的表情，你会不自觉的把这些场景延伸到现在的公众演讲以及公众表达上。常见比如，人们小时候玩水时掉入水中呛到过，成人后就对游泳产生了恐惧。或者在爬树时掉下来过，就对过山车产生了恐惧等等。不仅如此，人们通常会将一种痛苦的经历延展到另一个场景中，比如说，某人会因为小学里遭到过坏学生的殴打，致使他觉得现在自己面对他人安排的工作任务时会感觉自己是被压迫的或受虐待的，因此有很大的抵触情绪。总之，人们常常会延展过去的痛苦回忆，将这些痛苦的回忆放入到现在的场景里面去，这使得他们感到恐惧，同时也使他们有一个最佳的逃避借口。如何行动去克服恐惧？我罗列了所有的方法，有些方法是我自己总结的，有些则是参考《应对焦虑》埃德蒙.伯恩写的这本书。（克服恐惧的方法全图）  观察自己的恐惧  提前做好准备  积极变化适应环境  冥想练习排除杂念  渐进式肌肉放松  暴露疗法，应对暴露，完全暴露，想象暴露  运动，增加运动频率，增加强度增加抗压力  自我关怀，爱的言语、规律作息、简化生活、  转移注意力，专注于技巧，找人聊天，体验愉悦的事，听音乐以上这些技巧，可以用在我们生活当中面对焦虑与恐惧时的情况。虽然大部分技巧都可以用到演讲中，但我想讲其中在演讲时运用最有效的方法，我们来看下图：（克服演讲恐惧的有效方法）观察自己的恐惧我们最先要做的是观察自己的恐惧，这是所有技巧的前提。（观察恐惧图：来源网络）恐惧也是情绪的一种，我们需要观察恐惧发生时候我们的表现，我们的眼神，我们心跳，我们的肌肉，在做怎样的颤抖。通过观察我们身体上的变化，我们可以感知到自己的恐惧。当我们能够观察到恐惧时，恐惧本身就没有这么强烈了，所以我们首先要做的是，用第三者的角度观察自己的恐惧表现。通过观察我们能及时的发现我们的精神状态在变化，只要我们观察到恐惧，它就不会再扩散，此时我们就可以想办法逐渐的释放它。最糟糕的是你观察不到自己的恐惧，但仍然继续逼迫自己向前对劲，这时你会有一种无力感，同时恐惧会不断的蔓延到你的全身，使你的精神状态陷入更加崩溃的边缘。我们只有识别自己的恐惧状态，识别自己的恐惧表现，才能真正的认识到自己的情绪变化，以及事物对我们的影响程度。这为后面的措施，调整打下了好的基础。提前做好准备提前做好准备，通常是最明智的选择，也是克服恐惧的最好方法。（提前准备图：来源网络）它需要我们抽出时间去为这场演讲做准备。我需要写演讲稿，并且在演讲前打磨多次。通过自己不断的练习和打磨演讲，将演讲稿打磨成自己认为完美的样子。同时，在我们平时的生活中，要为未来的可能的演讲做好准备。所以，在我们平常的生活当中，要注重收集生活的细节，收集演讲的素材，这些素材能够更快更有效的运用在未来的演讲中，让演讲和故事呈现的效果更好。因此，提前做好准备，是每个演讲达人的最重要的工作之一。积极拥抱变化适应环境（拥抱变化：来源网络）很多时候我们避免不了会去自己陌生的地方演讲。这个时候，环境的变化对我们的精神冲击力很大，周围没有熟悉的环境没有熟悉的人，我们感到被隔离脱离群体从而感到恐惧。这个时候，我们需要积极的去拥抱变化。与台上台下的工作人员沟通，积极的与嘉宾沟通，与在场的观众沟通。通过这样沟通交流我们能够舒展我们的心情，能够释放我们的紧张情绪，能够释放我们的恐惧情绪。如果在现场当我们遇到困难的时候，需要主动寻求帮助。特别是当下环境中的管理者，或者比较熟悉的朋友，通过他们的帮助让自己这份不安的心能够安定下来，减少恐惧的蔓延。特别是在演讲开场时，自己在一个陌生的环境下非常容易紧张焦虑和恐惧，此时在开场时需要跟大家有一个沟通交流的时间，留出这样一个前置的时间跟大家沟通交流非常必要，然后再慢慢进入状态，开始自己的演讲。也可以通过说出自己的感受来跟大家做一些互动，这样让自己的紧张情绪和压力能够释放掉，这为后面的事情进展顺利而铺平了道路。放松练习我们可以用身体上的练习和精神的上的练习来放松自己。（冥想图：来源网络）精神上的练习，可以通过说出感受来接纳自己释放压力。也可以通过就地坐下或稳定站立并闭上眼睛来做冥想，通过专注于自己的呼吸，将杂念排除，也可以通过腹式呼吸来将注意力转移到自己的腹部上，让自己更加专注于当下。冥想的要点是专注于呼吸，这会让你排除杂念，专注于当下。身体上的练习，也可以起到放松作用。（与文无关的放松练习图：来源网络）这里有一个叫渐进式肌肉放松法。我们来具体介绍一下：腹式呼吸，用腹部呼吸，吸气时肚子吸入空气突出呼气时因气体排除而扁平，呼吸要慢，想象全身的紧张感开始从体内流去。撰紧拳头，保持7-10秒，再从开拳头15-20秒，反复循环双手前臂抬起，前臂与上臂尽量靠拢，紧绷肱二头肌，保持，然后放松。双手手臂向外延展到水平位置，伸肘，拉紧肱三头肌，保持，然后放松。尽量抬高眉毛，收缩前额肌肉，保持，然后放松。放松时，想象前额肌肉慢慢舒展、松弛。紧闭双眼，绷紧眼周肌肉，保持，然后放松。想象深度放松的感觉在眼镜周围蔓延。张大嘴巴，拉伸下颚关节周围的肌肉，绷紧下巴，保持，然后放松。张着嘴，让下巴自然放松。头向后仰，尽量靠向后背，收紧脖子后面的肌肉，专注于收紧颈部肌肉的动作，保持，然后放松。双肩同时最大限度地向上耸起，绷紧肩部肌肉，保持，然后放松。双肩外展，尽量向背部中线靠拢，绷紧肩胛骨周围的肌肉。让肩胛处的肌肉保持绷紧，然后放松。深吸一口气，绷紧胸部肌肉，保持10秒，然后慢慢呼气。收紧腹部肌肉，保持，然后放松。背部弓起，拉紧下背部肌肉，保持，然后放松。收紧臀部，保持，然后放松。收缩大腿肌肉，保持，然后放松。向自己的方向用力伸脚趾，绷紧小腿肌肉，保持，然后放松。卷起脚趾，绷紧脚面，保持，然后放松。以上是一整套的渐进式肌肉放松法，一整套下来需要20-30分钟，在平时的放松练习可以通过抽取几个对自己比较有效的姿势去做放松练习，这样更容易将这些放松练习融入到我们的生活中，特别是演讲前的放松练习。参考资料：《三招搞定演讲构思》朱林滢《应对焦虑》埃德蒙.伯恩《高效演讲》彼得.迈尔斯，尚恩.尼克斯",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247485068&amp;idx=1&amp;sn=464d36573e97c69aeab4ab996885ccee&amp;chksm=fc22638bcb55ea9d3e4472e92a760b147dc2a816268e9d3a435842995723d3a02e9a26b0f4b5&amp;token=1416441933&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h1 id=\"背景\">背景</h1><p>不知不觉看完了6本关于演讲的主题，按推荐顺序排列分别是《高效演讲》、《演讲与口才》、《即兴演讲》、《关键对话》、《TED演讲的力量》、《说话的艺术》。</p><p>我希望自己能够对演讲有一个系统性的学习。于是自己在平常的生活和工作中实践了一段时间，前前后后加起来有两个月时间。</p><p>目标是，改善平常的工作、生活中表达的流畅和清晰度，能让人感觉到舒服让人感觉有活力。同时在公众演讲上，希望自己能够很好的呈现自己的所思所想以及所知所学。</p><p>因此开启这个演讲学习系列的总结文章，我将对这6本书的内容加上我的实践经验做一次全面的系统性的总结。</p><h3 id=\"概述\">概述：</h3><ol>  <li>恐惧的原因</li>  <li>克服恐惧的原理</li>  <li>制定克服恐惧的行动</li></ol><h3 id=\"内容\">内容：</h3><p>为什么要了解演讲时的恐惧？</p><ol>  <li>只有了解恐惧的原理才能正确认识它</li>  <li>它会使得事情更加糟糕</li>  <li>它会对我们的心理产生长短期的变化</li></ol><p>在平时的生活工作学习当中，当我们恐惧时很多时候并不能了解自己的恐惧情绪。由于在很多情况下，我们观察不到自己的情绪，导致我们常常无法在情绪有问题时，及时的调整它。</p><p>因此你会看到很多时候，当出现了恐惧的症状时，我们没有调整它，这直接导致事情发展变得糟糕。</p><p>（恐惧表情图：来源网络）</p><p>不止如此，如果没有去很好的应对恐惧的话，长此以往我们在心里会有比较大的阴影。这使得，我们在一件比较重要的会议上，由于你的恐惧而退缩或退却，会使你在精神上遭受更大的打击。</p><p>如果次数多了，你会发现你对这些重要的场所，重要的机会，会产生习惯性的恐惧，这常常使你对人生产生比较多的怀疑。</p><p>因此无论从长期或短期来看，我们都需要去主动的了解恐惧。这是我们必须去了解恐惧的重要原因。它会将生活弄得更加糟糕，因此我们必须了解他，特别是在演讲时。</p><p>恐惧有很多种，这里我们只关注演讲时的恐惧。但其实演讲的恐惧已经覆盖了生活中很多的方面，它与生活中的恐惧有很多共性。</p><h2 id=\"是什么让你恐惧\">是什么让你恐惧？</h2><p>了解恐惧产生的原因，可以让我们对恐惧问题的形成有更深刻的认识。</p><p>不管是普通焦虑还是惊恐障碍，都没有单一的成因，也不可能在消除这个成因后问题就得到彻底根除。焦虑问题是有多方面，多种原因引起的，包括遗传因素，生物因素，家庭背景和教养方式、心理条件作用、近期生活转变、自我对话和个人信念体系、表达情感的能力、当前环境压力等。</p><p>恐惧的原因：</p><ol>  <li>面对重要场面，准备不充分</li>  <li>对周围的环境很陌生</li>  <li>经历不足，导致的对事情没有底气</li>  <li>在意别人对自己的看法</li>  <li>生理反应，肌肉紧张、心跳加速、头脑晕眩</li>  <li>近期自己身边的环境变动较大</li>  <li>长期积累的心里因素，过分在意过去发生的事情</li></ol><p>我们在面对演讲时通常会有很多的恐惧，特别是在上台前一段时间，自己的恐惧心理被放大的特别多。</p><p>其实说来不只是演讲，恐惧在我们平常的生活跟工作当中也非常多，我们心里常常会对某件即将到来的事产生恐惧。</p><p>因此呢。并不是说在演讲时你才会恐惧，在平常的生活当中，你同样会有很多令你焦虑不安的事情。</p><p>演讲跟平常我们生活、工作时产生的恐惧是一样的，并没有说因为演讲而特殊。</p><p>我们究竟为什么而恐惧？我们来分析一下。</p><p>前面列了7条恐惧的原因，但其实这7条可以归类一下变得更精简一些。</p><p>（恐惧原因）</p><p>恐惧的原因总的来说为三方面：</p><ol>  <li>准备不充分</li>  <li>环境变化导致的恐惧</li>  <li>长期积累的心理因素</li></ol><p>（恐惧原因细节图）</p><h3 id=\"第一准备不充分\">第一，准备不充分</h3><p>当我们知道我们将要去面对一件事情，但是这件事情并没有充足的把握时我们就会感到恐惧。</p><p>因为这件事情是未知的，而且我预感到他可能不会有太好的结果，因为我对他没有把握，我也没有对他做任何的准备工作。</p><p>可能有这么一件事情你是从来没有做过的，或者说你也不知道他将会发生什么样的情况。甚至在你的预感当中，这件事会发生比较差的或者糟糕的情况，此时你就会对这件事情产生恐惧。因而有逃避去面对这件事情的心理状态。</p><p>在演讲时也是同样的，大部分人没有台上演讲的经验和习惯，因此对于上台演讲这件事情，大部分人都是有恐惧心理的。</p><p>这个恐惧心理是因为我们没有，为这件事情做过任何的准备，也不知道这件事情会发生怎样的情况。此时我们心里隐隐的感觉到这这件事情会比较糟糕。因此，我们对演讲产生了恐惧。</p><p>总之，当你面对一件即将到来，但未知的事情时，当你面对一件你觉得可能会发生比较糟糕的事情时，通常是因为我们没有做好足够的准备工作。这个准备工作可能需要花去几小时、几天、几个月甚至几年的时间，总之我们并没有为这件事做好足够的准备。</p><h3 id=\"第二环境变化导致的恐惧\">第二，环境变化导致的恐惧</h3><p>我们周围的环境时常在变化，包括我们的工作，上下级人员调动，以及你身边人的来往，以及你亲人的离去与归来，这些的环境都在时刻变化着，影响着我们的心理。可能是你最近比较倒霉，碰到了一些小概率事件，或者可能会因为大环境的变化使得感到沮丧。甚至有可能你出差到了某个陌生的环境，让你感到很不舒服。</p><p>这些环境的变化都会让你产生焦虑甚至恐惧的心理。</p><p>总之，在当前这样的环境下，是你并不熟悉的环境，不是你能掌控而环境，因此导致你对周围的环境有一种隔离感，像是没有依靠的感觉。</p><h3 id=\"第三长期积累的心理因素\">第三，长期积累的心理因素</h3><p>你可能会因为曾经的遭遇而感到痛苦，这些遭遇在你的脑中挥之不去，当再次发生或者即将发生这样的事情的时候，你就会感到焦虑和恐惧。</p><p>这些痛苦的场景通常会延伸到我们生活的各个角落，比如说，你可能曾经在小组发言时，磕磕巴巴导致你对公众发言产生了恐惧，致使你在现在上台演讲时都会表现的异常的惊恐，当回忆起自己以前在小组发言时的那些场景，以及当时人们都的表情，你会不自觉的把这些场景延伸到现在的公众演讲以及公众表达上。</p><p>常见比如，人们小时候玩水时掉入水中呛到过，成人后就对游泳产生了恐惧。或者在爬树时掉下来过，就对过山车产生了恐惧等等。</p><p>不仅如此，人们通常会将一种痛苦的经历延展到另一个场景中，比如说，某人会因为小学里遭到过坏学生的殴打，致使他觉得现在自己面对他人安排的工作任务时会感觉自己是被压迫的或受虐待的，因此有很大的抵触情绪。</p><p>总之，人们常常会延展过去的痛苦回忆，将这些痛苦的回忆放入到现在的场景里面去，这使得他们感到恐惧，同时也使他们有一个最佳的逃避借口。</p><h2 id=\"如何行动去克服恐惧\">如何行动去克服恐惧？</h2><p>我罗列了所有的方法，有些方法是我自己总结的，有些则是参考《应对焦虑》埃德蒙.伯恩写的这本书。</p><p>（克服恐惧的方法全图）</p><ol>  <li>观察自己的恐惧</li>  <li>提前做好准备</li>  <li>积极变化适应环境</li>  <li>冥想练习排除杂念</li>  <li>渐进式肌肉放松</li>  <li>暴露疗法，应对暴露，完全暴露，想象暴露</li>  <li>运动，增加运动频率，增加强度增加抗压力</li>  <li>自我关怀，爱的言语、规律作息、简化生活、</li>  <li>转移注意力，专注于技巧，找人聊天，体验愉悦的事，听音乐</li></ol><p>以上这些技巧，可以用在我们生活当中面对焦虑与恐惧时的情况。</p><p>虽然大部分技巧都可以用到演讲中，但我想讲其中在演讲时运用最有效的方法，我们来看下图：</p><p>（克服演讲恐惧的有效方法）</p><h3 id=\"观察自己的恐惧\">观察自己的恐惧</h3><p>我们最先要做的是观察自己的恐惧，这是所有技巧的前提。</p><p>（观察恐惧图：来源网络）</p><p>恐惧也是情绪的一种，我们需要观察恐惧发生时候我们的表现，我们的眼神，我们心跳，我们的肌肉，在做怎样的颤抖。通过观察我们身体上的变化，我们可以感知到自己的恐惧。当我们能够观察到恐惧时，恐惧本身就没有这么强烈了，所以我们首先要做的是，用第三者的角度观察自己的恐惧表现。</p><p>通过观察我们能及时的发现我们的精神状态在变化，只要我们观察到恐惧，它就不会再扩散，此时我们就可以想办法逐渐的释放它。</p><p>最糟糕的是你观察不到自己的恐惧，但仍然继续逼迫自己向前对劲，这时你会有一种无力感，同时恐惧会不断的蔓延到你的全身，使你的精神状态陷入更加崩溃的边缘。</p><p>我们只有识别自己的恐惧状态，识别自己的恐惧表现，才能真正的认识到自己的情绪变化，以及事物对我们的影响程度。这为后面的措施，调整打下了好的基础。</p><h3 id=\"提前做好准备\">提前做好准备</h3><p>提前做好准备，通常是最明智的选择，也是克服恐惧的最好方法。</p><p>（提前准备图：来源网络）</p><p>它需要我们抽出时间去为这场演讲做准备。</p><p>我需要写演讲稿，并且在演讲前打磨多次。通过自己不断的练习和打磨演讲，将演讲稿打磨成自己认为完美的样子。</p><p>同时，在我们平时的生活中，要为未来的可能的演讲做好准备。所以，在我们平常的生活当中，要注重收集生活的细节，收集演讲的素材，这些素材能够更快更有效的运用在未来的演讲中，让演讲和故事呈现的效果更好。</p><p>因此，提前做好准备，是每个演讲达人的最重要的工作之一。</p><h3 id=\"积极拥抱变化适应环境\">积极拥抱变化适应环境</h3><p>（拥抱变化：来源网络）</p><p>很多时候我们避免不了会去自己陌生的地方演讲。这个时候，环境的变化对我们的精神冲击力很大，周围没有熟悉的环境没有熟悉的人，我们感到被隔离脱离群体从而感到恐惧。</p><p>这个时候，我们需要积极的去拥抱变化。与台上台下的工作人员沟通，积极的与嘉宾沟通，与在场的观众沟通。通过这样沟通交流我们能够舒展我们的心情，能够释放我们的紧张情绪，能够释放我们的恐惧情绪。</p><p>如果在现场当我们遇到困难的时候，需要主动寻求帮助。特别是当下环境中的管理者，或者比较熟悉的朋友，通过他们的帮助让自己这份不安的心能够安定下来，减少恐惧的蔓延。</p><p>特别是在演讲开场时，自己在一个陌生的环境下非常容易紧张焦虑和恐惧，此时在开场时需要跟大家有一个沟通交流的时间，留出这样一个前置的时间跟大家沟通交流非常必要，然后再慢慢进入状态，开始自己的演讲。也可以通过说出自己的感受来跟大家做一些互动，这样让自己的紧张情绪和压力能够释放掉，这为后面的事情进展顺利而铺平了道路。</p><h3 id=\"放松练习\">放松练习</h3><p>我们可以用身体上的练习和精神的上的练习来放松自己。</p><p>（冥想图：来源网络）</p><p>精神上的练习，可以通过说出感受来接纳自己释放压力。也可以通过就地坐下或稳定站立并闭上眼睛来做冥想，通过专注于自己的呼吸，将杂念排除，也可以通过腹式呼吸来将注意力转移到自己的腹部上，让自己更加专注于当下。</p><p>冥想的要点是专注于呼吸，这会让你排除杂念，专注于当下。</p><p>身体上的练习，也可以起到放松作用。</p><p>（与文无关的放松练习图：来源网络）</p><p>这里有一个叫渐进式肌肉放松法。我们来具体介绍一下：</p><p>腹式呼吸，用腹部呼吸，吸气时肚子吸入空气突出呼气时因气体排除而扁平，呼吸要慢，想象全身的紧张感开始从体内流去。</p><p>撰紧拳头，保持7-10秒，再从开拳头15-20秒，反复循环</p><p>双手前臂抬起，前臂与上臂尽量靠拢，紧绷肱二头肌，保持，然后放松。</p><p>双手手臂向外延展到水平位置，伸肘，拉紧肱三头肌，保持，然后放松。</p><p>尽量抬高眉毛，收缩前额肌肉，保持，然后放松。放松时，想象前额肌肉慢慢舒展、松弛。</p><p>紧闭双眼，绷紧眼周肌肉，保持，然后放松。想象深度放松的感觉在眼镜周围蔓延。</p><p>张大嘴巴，拉伸下颚关节周围的肌肉，绷紧下巴，保持，然后放松。张着嘴，让下巴自然放松。</p><p>头向后仰，尽量靠向后背，收紧脖子后面的肌肉，专注于收紧颈部肌肉的动作，保持，然后放松。</p><p>双肩同时最大限度地向上耸起，绷紧肩部肌肉，保持，然后放松。</p><p>双肩外展，尽量向背部中线靠拢，绷紧肩胛骨周围的肌肉。让肩胛处的肌肉保持绷紧，然后放松。</p><p>深吸一口气，绷紧胸部肌肉，保持10秒，然后慢慢呼气。</p><p>收紧腹部肌肉，保持，然后放松。</p><p>背部弓起，拉紧下背部肌肉，保持，然后放松。</p><p>收紧臀部，保持，然后放松。</p><p>收缩大腿肌肉，保持，然后放松。</p><p>向自己的方向用力伸脚趾，绷紧小腿肌肉，保持，然后放松。</p><p>卷起脚趾，绷紧脚面，保持，然后放松。</p><p>以上是一整套的渐进式肌肉放松法，一整套下来需要20-30分钟，在平时的放松练习可以通过抽取几个对自己比较有效的姿势去做放松练习，这样更容易将这些放松练习融入到我们的生活中，特别是演讲前的放松练习。</p><h3 id=\"参考资料\">参考资料：</h3><p>《三招搞定演讲构思》朱林滢</p><p>《应对焦虑》埃德蒙.伯恩</p><p>《高效演讲》彼得.迈尔斯，尚恩.尼克斯</p>",
            "url": "http://www.luzexi.com/2021/12/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B049",
            
            
            
            
            
            "date_published": "2021-12-05T00:00:00+08:00",
            "date_modified": "2021-12-05T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/11/27/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A119",
            "title": "给女儿的信(十九) 说出自己的感受积极化解情绪",
            "summary": "女儿 教育 亲情",
            "content_text": "要点：说出自己的感受，积极化解情绪结构：  半年一次的俱乐部选举即将开始  我自己写了ppt，做了选举前的准备  选举很激烈，主席选举经过2次平分后终于选出结果，大家也很欢乐  接着我上台选举VPE，上台很紧张，自己讲的有点死板  由于最近在俱乐部里挺活跃的，抱着一线希望，但最后还是败下阵来  接着收拾下心情，继续竞选后面的职位  有人提议VPM，我接受了  我上台后，先化解自己的情绪，说出了自己的感受  同时为VPM制定了目标，并真诚说出自己的内心话，希望跟大家交朋友  爸爸认为练习技巧前应该先交朋友，有了朋友技巧才有用，得到大家的认可，最后成功选举获得VPM  价值升华，失败不可怕，及时调整心态，说出感受，主动卸下压力，能让事情进展的更加顺利内容：Hello Sharon and hello，Anne，爸爸喜欢你们。爸爸到深圳了，要再过一个月回来，到时候再跟你玩，爸爸喜欢跟你们玩游戏，喜欢跟你们聊天，喜欢跟你们一起学习，喜欢跟你们一起加油。今天爸爸跟你们聊一下，爸爸最近在演讲俱乐部里面做的一些事情好不好？最近半年爸爸都在演讲俱乐部里面练习演讲，练习表达，这和Sharon在学校里面练小主播一样，非常像，爸爸每天都会练习那个绕口令，都会练习口步操，是不是跟你们很像？平时的时候爸爸会做一些演讲，上台演讲，这样呢会让爸爸在公众表达上更好一些，平常跟人沟通交流时，也能更自然一些。那爸爸想跟确认跟安妮说说说最近爸爸在俱乐部里面的一件事好不好？最近俱乐部里面要选举官员，怎么是官员？呢就是嗯宣传学校里面选班长，选学习委员，选体育委员，这些是一样的，爸爸在俱乐部里面也要选主席，要选副会长，要选秘书长等这些岗位，那这些岗位呢要做竞选演讲。于是爸爸上台做了竞选演讲，爸爸上台了两次，做了两次竞选演讲，分别去竞选了两个职位。第一个职位的时候爸爸上台很紧张，自己说话也有点很死板，说话的内容不是很清楚，因为爸爸太紧张了，通常紧张的时候爸爸说话都是有一点点啊有语无伦次，虽然抱着一线希望，但是最后还是败下阵来了。于是就收拾了一下心情继续的后面的竞选岗位。等爸爸第二次上台的时候，爸爸先做的一件事情就是爸爸先化解情绪，再开始自己的演讲内容，爸爸第二次上台的时候也还是很紧张，于是我上台时先说出自己的感受，说说自己为什么紧张，说自己还在想怎么去改进就第二次上台了。在说出自己的感受的时候，爸爸已经慢慢的化解了自己的情绪，接着爸爸就说出自己的内心话，希望能跟大家交朋友，希望能在这个俱乐部里面啊有更好的练习，跟大家一起学习，真心真诚的跟大家交朋友。那当爸爸说出这些真心话的时候，得到了大家的认可，爸爸也同时告诉大家，来这里练习演讲，爸爸首先希望能跟大家先交朋友，然后再练习，这种方式。得到了大家的认可，最后成功获得了会员副主席的这个职位。爸爸想跟Sharon和安妮说，这次经历告诉爸爸，其实失败并不可怕，在失败以后要及时调整自己的状态，调整自己的心情，怎么去调整呢，就是说出自己的感受，向周围人说出自己的感受，说出自己的看法，这样就能主动卸下自己的压力，让自己放松下来，这杨可以让后面的事情进展的更加顺利。今天的故事就讲到这里，爸爸爱你们，喜欢你们了。",
            "content_html": "<h2 id=\"要点\">要点：</h2><p>说出自己的感受，积极化解情绪</p><h2 id=\"结构\">结构：</h2><ol>  <li>半年一次的俱乐部选举即将开始</li>  <li>我自己写了ppt，做了选举前的准备</li>  <li>选举很激烈，主席选举经过2次平分后终于选出结果，大家也很欢乐</li>  <li>接着我上台选举VPE，上台很紧张，自己讲的有点死板</li>  <li>由于最近在俱乐部里挺活跃的，抱着一线希望，但最后还是败下阵来</li>  <li>接着收拾下心情，继续竞选后面的职位</li>  <li>有人提议VPM，我接受了</li>  <li>我上台后，先化解自己的情绪，说出了自己的感受</li>  <li>同时为VPM制定了目标，并真诚说出自己的内心话，希望跟大家交朋友</li>  <li>爸爸认为练习技巧前应该先交朋友，有了朋友技巧才有用，得到大家的认可，最后成功选举获得VPM</li>  <li>价值升华，失败不可怕，及时调整心态，说出感受，主动卸下压力，能让事情进展的更加顺利</li></ol><h2 id=\"内容\">内容：</h2><p>Hello Sharon and hello，Anne，爸爸喜欢你们。爸爸到深圳了，要再过一个月回来，到时候再跟你玩，爸爸喜欢跟你们玩游戏，喜欢跟你们聊天，喜欢跟你们一起学习，喜欢跟你们一起加油。</p><p>今天爸爸跟你们聊一下，爸爸最近在演讲俱乐部里面做的一些事情好不好？</p><p>最近半年爸爸都在演讲俱乐部里面练习演讲，练习表达，这和Sharon在学校里面练小主播一样，非常像，爸爸每天都会练习那个绕口令，都会练习口步操，是不是跟你们很像？平时的时候爸爸会做一些演讲，上台演讲，这样呢会让爸爸在公众表达上更好一些，平常跟人沟通交流时，也能更自然一些。</p><p>那爸爸想跟确认跟安妮说说说最近爸爸在俱乐部里面的一件事好不好？最近俱乐部里面要选举官员，怎么是官员？呢就是嗯宣传学校里面选班长，选学习委员，选体育委员，这些是一样的，爸爸在俱乐部里面也要选主席，要选副会长，要选秘书长等这些岗位，那这些岗位呢要做竞选演讲。</p><p>于是爸爸上台做了竞选演讲，爸爸上台了两次，做了两次竞选演讲，分别去竞选了两个职位。</p><p>第一个职位的时候爸爸上台很紧张，自己说话也有点很死板，说话的内容不是很清楚，因为爸爸太紧张了，通常紧张的时候爸爸说话都是有一点点啊有语无伦次，虽然抱着一线希望，但是最后还是败下阵来了。</p><p>于是就收拾了一下心情继续的后面的竞选岗位。等爸爸第二次上台的时候，爸爸先做的一件事情就是爸爸先化解情绪，再开始自己的演讲内容，爸爸第二次上台的时候也还是很紧张，于是我上台时先说出自己的感受，说说自己为什么紧张，说自己还在想怎么去改进就第二次上台了。</p><p>在说出自己的感受的时候，爸爸已经慢慢的化解了自己的情绪，接着爸爸就说出自己的内心话，希望能跟大家交朋友，希望能在这个俱乐部里面啊有更好的练习，跟大家一起学习，真心真诚的跟大家交朋友。</p><p>那当爸爸说出这些真心话的时候，得到了大家的认可，爸爸也同时告诉大家，来这里练习演讲，爸爸首先希望能跟大家先交朋友，然后再练习，这种方式。得到了大家的认可，最后成功获得了会员副主席的这个职位。</p><p>爸爸想跟Sharon和安妮说，这次经历告诉爸爸，其实失败并不可怕，在失败以后要及时调整自己的状态，调整自己的心情，怎么去调整呢，就是说出自己的感受，向周围人说出自己的感受，说出自己的看法，这样就能主动卸下自己的压力，让自己放松下来，这杨可以让后面的事情进展的更加顺利。</p><p>今天的故事就讲到这里，爸爸爱你们，喜欢你们了。</p>",
            "url": "http://www.luzexi.com/2021/11/27/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A119",
            
            
            
            
            
            "date_published": "2021-11-27T00:00:00+08:00",
            "date_modified": "2021-11-27T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/11/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B050",
            "title": "读书笔记(四十九) 《游戏引擎架构》#4 低阶渲染器（3）",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：作为游戏开发从业者，从业务到语言到框架到引擎，积累了一些知识和经验，特别是在看了几遍《游戏引擎架构》后对引擎架构的理解又深入了些。近段时间有对引擎剖析的想法，正好借这书本对游戏引擎架构做一个完整分析。此书用简明、清楚的方式覆盖了游戏引擎架构的庞大领域，巧妙地平衡了广度与深度，并且提供了足够的细节。借助《游戏引擎架构》这本书、结合引擎源码和自己的经验，深入分析游戏引擎的历史、架构、模块，最后通过实践简单引擎开发来完成对引擎知识的掌握。游戏引擎知识面深而广，所以对这系列的文章书编写范围做个保护，即不对细节进行过多的阐述，重点剖析的是架构、流程以及模块的运作原理。同时《游戏引擎架构》中部分知识太过陈旧的部分，会重新深挖后总结出自己的观点。概述：本系列文章对引擎中的重要的模块和库进行详细的分析，我挑选了十五个库和模块来分析：  时间库  自定义容器库  字符串散列库  内存管理框架  RTTI与反射模块  图形计算库  资产管理模块  低阶渲染器  剔除与合批模块  动画模块  物理模块  UI底层框架  性能剖析器的核心部分  脚本系统  视觉效果模块本篇内容为列表中的第8个部分的第1节。正文：简单回顾下前文前文我们聊了下显卡在计算机硬件主板中的位置与结构，知道了CPU、GPU的通信介质，并简单介绍了手机上的主板结构。本篇开头对上一篇做一些内容补充，PC和手机的不同硬件组织，以及CPU与其他芯片的通信过程。下面我们开始这篇内容本次内容会围绕GPU来写，从硬件架构到软件驱动再到引擎架构，目标是帮大家理解GPU硬件的运作原理，理解图形接口的架构，理解引擎低阶渲染器的架构。目录：  主板结构中的显卡  GPU功能发展史  GPU与CPU的差异  GPU硬件特点  图形驱动程序架构  引擎低阶渲染架构内容结构  CPU硬件结构  GPU硬件结构  GPU手机管线与PC管线的差异简单回顾下前文，前文我们主要讲了显卡的发展历史，知道了显卡功能和管线是如何一步步转变为现在这样子的。CPU结构与工作原理我们知道，CPU运行时有三类元器件构成，取指器、译码器、运算器（逻辑算术运算器、浮点数运算器、单指令多数据运算器等）。这三类元器件代表三个阶段取指阶段（Fetch）、指令译码阶段（Decode）、执行阶段（Execute），它们在CPU内执行的步骤如下图：（图-取指-译指-执行三步骤）取指阶段为从内存或缓存中取得指令并存放到寄存器中的过程。接着，译码器会将寄存器中的指令翻译成操作指令，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类别以及各种获取操作数的方法。在组合逻辑控制的计算机中，指令译码器对不同的指令操作码产生不同的控制电位，以形成不同的微操作序列；在微程序控制的计算机中，指令译码器用指令操作码来找到执行该指令的微程序的入口，并从此入口开始执行。运算阶段，则根据指令执行不同的运算单元，完成指令所规定的各种操作，具体实现指令的功能。为此，CPU 的不同部分被连接起来，以执行所需的操作。（图-控制单元-运算单元-存储单元）因此，通常我们将取指器、译码器统称为控制单元，计算器称为算术逻辑单元（ALU），寄存器和高速缓存称为存储单元。除了这三个基本单元，当下这样复杂的CPU中还有包括分支预测器、乱序控制器、内存预加载器等等。这里简单介绍下CPU指令流水线、分支预测、乱序执行的原理。指令流水线起初CPU指令执行是线性的，只靠取指、译码、运算顺序执行三个模块，这导致元器件的工作顺序是线性的，当一个元器件执行时，其他元器件是空等待状态，CPU执行效率比较低。为了提高效率，提高空等待的元器件的利用率，对指令执行流水线进行了拆分，并同时增加多个流水线不断减少元器件的空等待装填。如下图：（拆分多级流水线）将原本线性的三个指令执行顺序，拆分成一个个小模块，让这些独立的小模块可以自顾自的循环工作，减少前后的等待时间，从而提高了指令执行效率。用这种方式把一个指令拆分成“取指令 - 指令译码 - 执行指令”这样三个部分，这就是一个三级的流水线。进一步把“执行指令”拆分成“ALU 计算（指令执行）- 内存访问 - 数据写回”，就会变成一个五级的流水线。继续拆分，将一个长时间的操作步骤，拆分成更多的步骤，让所有步骤需要执行的时间尽量都差不多长。这样，也就可以解决我们在单指令周期处理器中遇到的复杂指令性能问题。（同时多级流水线会出现许多问题，例如模块间寄存器的写入次数太多，多模块读写同一个资源相互冲突等，这里不细说，CPU最终都有解决方案去解决）现代的 ARM 或 Intel 的 CPU，流水线级数都已经到了 14 级。乱序执行我们在写程序时，常常会发现函数内几个执行操作顺序并不互相依赖，哪个在前哪个在后都没有太大的关系。此时不仅编译器会对这些不相互依赖的计算操作进行重新顺序排序用于优化CPU执行效率（这也是导致线程不同步的其中一个原因），CPU也会将不相互依赖的指令放在不相同的指令流水线上以加快执行速度。（指令在不同CPU流水线上乱序执行：图来源网络）我们从图中可以看到，在流水线里，当后面的指令不依赖前面的指令时，就不用等待前面的指令执行完毕后再执行，可以另起一个流水线执行，否则就需要用NOP隔周期等待的方式将执行单元延后计算。因此我们所写的代码的执行顺序其实并不是我们所想象的那样，在CPU中大部分时候其实是乱序执行的，这样元器件的利用率更高，执行效率也更高，而依赖而停顿的次数也更少。（乱序执行的流程图）乱序执行实际的过程比我们想象的要复杂一些，总体上它会先拆分指令，再分发给执行单元，结束后将结果重新排序，最后提交缓冲。分支预测程序中有很多true或false的判断来跳转下文要执行的指令，这种跳转会使得执行流水线发生停顿，因为要依赖前面代码计算的结果再决定要执行哪段程序，因此流水线不中断并等待结果，这会使CPU执行效率降低。在CPU中有分支预测器，它是一种数字电路，在分支指令执行前，猜测哪一个分支会被执行，这样能显著提高pipeline的性能。可以理解为，分支预测器会主动猜测分支是true还是false。如果猜错了，处理器要flush掉pipeline, 回滚到之前的分支，然后重新热启动，选择另一条路径。 如果猜对了，处理器不需要暂停，继续往下执行。也就是说，如果CPU每次都猜错，处理器将耗费大量时间在停止-回滚-热启动这一周期性过程里。反之，如果侥幸每次都猜对了，那么处理器将从不停止、无需等待的执行后面的指令。（分支预测图）CPU执行指令遇到条件时不知道该读取哪些指令，需要等待判断条件中的计算结果，这样就中断了后面指令执行流水线使得执行效率下降。于是CPU增加了分支预测器，猜if条件中是True还是False，如果猜对了效率就会提高，如果猜错了，则重新计算。分支预测的关键是，预测算法能猜对多少。分支预测分为动态分支预测和静态分支预测。动态预测在执行过程中统计了通过率，根据通过率去调整预测方向，静态则始终以一个值作为判断标准。动态预测有好几种，最常见的是双模预测，通过四个状态位来动态调整预测结果。其它常见分支预测器如两级自适应预测器，局部/全局分支预测器，融合分支预测器，Agree预测期，神经分支预测器等。CPU原理小结（CPU抽象元件图）现在我们知道了CPU指令周期的工作方式，分为三个步骤，取指、译码、运算。运算后需要寄存器和高速缓存来作为存储器，CPU会从内存中获取指令并最终将数据写入内存。我们把CPU中的元件抽象成，取指和译码元件、逻辑运算元件、数据缓存，就有了上面这幅简单抽象的CPU结构图。下面我们来看看硬件上的元器件是如何分布的：（CPU硬件结构图：来源网络）我们看到CPU除了基本的控制器、运算器、寄存器、高速缓存外，还额外放置了乱序执行器、分支预测器、内存预装载器等用于提高CPU效率。这些元器件全部加起来，整个就是一个CPU Core。（多核架构图：来源网络）实际的设备中通常由多个CPU Core组成多核的架构，每个CPU Core都有自己的高速缓存L1，不同CPU Core之间也有共享的高速缓存L2，通常每级缓存的存取速度有10倍的差距，而内存的存取速度比高速缓存差的更多，对于CPU Core来说可以认为它是一个外部存储设备，通过桥接芯片连接。GPU硬件结构与原理前面介绍了CPU的内部结构，现代无论是手机还是PC机基本都是多核的，每个核就是1个CPU Core，每个CPU Core里都有取指器和译码器，还有逻辑运算器，以及寄存器和高速缓存。除了上述基本元件外还有其他元器件用于优化CPU执行效率，包括乱序执行器、分支预测器、内存预装载器等。GPU图形管线的变迁我们从GPU历史里知道，原本显卡只是一个数据传输和画面转换接口，在不断的变革下成了主板上一个独立的芯片，之后就有了GPU的概念。CPU将数据传输到显存再通知GPU处理这些数据，GPU则拥有图形图像的处理流水线，专门处理图像。起初图形的顶点、片元都在CPU上计算，到了Voodoo FX显卡时已经将图元生成后的步骤拆分到了GPU上，最后再将顶点处理部分的计算合入到GPU上，此时GPU才真正形成了自己的图形管线。如下图：（图形计算管线变迁1-1982年前的纯2D时代）1982年前，CPU承担大部分的工作，当时还没有GPU的概念，还只能以显示适配器的名称称呼。（图形计算管线变迁2-1996年3dfx Voodoo）到1996年，GPU已经可以分担CPU的部分功能，只留下顶点处理部分部分给CPU。（图形计算管线变迁3-1998年GeForce）到1998年，所有顶点处理和片元处理都由GPU来完成了，但没有可编程部分，管线是固定的，传入顶点后无法控制顶点和片元的变化。（图形计算管线变迁4-2002年GeForce FX）到2002年，正式加入了可编程着色器，让顶点和片元的计算和展示有了更多变化。（图形计算管线变迁5-2006年GeForce 8800）到2006年，GPU管线中又增加了细分着色器，pre-Z等节点。这部分历史我们也可以通过OpenGL的功能变化来看这段历史的发展过程。（来源 wiki）1.1 1997 年 3 月，纹理对象，顶点数组1.2 1998 年 3 月，3D 纹理、BGRA 和打包像素格式1.2.1 1998年10月，ARB 扩展概念1.3 2001 年 8 月，多重纹理、多重采样、纹理压缩1.4 2002 年 7 月，深度图，GLSlang1.5 2003 年 7 月，顶点缓冲对象 (VBO)，遮挡查询2.0 2004 年 9 月， GLSL 1.1，MRT，两个纹理的非幂，点精灵，双面模板2.1 2006 年 7 月 ，GLSL 1.2，像素缓冲对象 (PBO)，sRGB 纹理3.0 2008 年 8 月 ，GLSL 1.3，纹理数组，条件渲染，帧缓冲对象 (FBO)3.1 2009 年 3 月， GLSL 1.4，Instancing，纹理缓存对象，统一缓存对象，图元重启3.2 2009 年 8 月， GLSL 1.5，几何着色器，多重采样纹理3.3 2010 年 3 月， GLSL 3.30，从 OpenGL 4.0 规范向后移植尽可能多的功能4.0 2010 年 3 月， GLSL 4.00，GPU 上的曲面细分，具有 64 位精度的着色器4.1 2010 年 7 月， GLSL 4.10，开发人员友好的调试输出，与 OpenGL ES 2.0 的兼容性4.2 2011 年 8 月， GLSL 4.20，带原子计数器的着色器，绘制传输给Feed back实例，着色器打包，性能改进4.3 2012 年 8 月， GLSL 4.30，利用 GPU 并行性的计算着色器、着色器存储缓冲区对象、高质量 ETC2/EAC 纹理压缩、增强的内存安全性、多应用程序稳健性扩展、与 OpenGL ES 3.0 的兼容性4.4 2013 年 7 月， GLSL 4.40，缓冲区放置控制，高效异步查询，着色器变量布局，高效多对象绑定，Direct3D 应用程序的流线型移植，无绑定纹理扩展，稀疏纹理扩展4.5 2014 年 8 月， GLSL 4.50，直接状态访问 (DSA)，刷新控制，鲁棒性，OpenGL ES 3.1 API 和着色器兼容性，DX11 仿真功能4.6 2017 年 7 月， GLSL 4.60，更高效的几何处理和着色器执行，更多信息，无错误上下文，多边形偏移钳位，SPIR-V，各向异性过滤经过显卡历史、GPU管线的变化历史、OpenGL的功能变迁史，让我们把GPU看的更清楚。GPU Core结构我们知道现代的 CPU 里除了基本的元器件外，还有许多围绕提高执行效率的元器件，以及增加诸多功能的其他元器件。这些元器件在 GPU 里有点多余了，GPU 的整个处理过程是一个流式处理过程，没有那么多分支条件，以及复杂的依赖关系。因此我们可以把 GPU 里这些对应的元器件去掉，只留下取指令、指令译码、ALU 以及执行这些计算需要的寄存器和缓存。如图：（GPU元器件瘦身图）这样看来GPU core比CPU Core的构造简单的多了，由于传输GPU的数据并不相互依赖的，因此我们可以用很多个GPU Core来并行计算这些数据。于是就有了，多GPU Core的结构，如下图：（多个Core并行工作图）多个Core并行工作时它们使用了相同的取指器并且有相同的代码，为什么不把它们并起来呢。前面我们说过SIMD，它把4个数据一起提交并用一个指令执行它完成计算。在GPU中借鉴了SIMD，用了一种跟它很像的处理技术叫做SIMT（Single Instruction Multiple Threads），如下图：（ 单指令多数据流管线）在SIMT中，向GPU Core输入的是8个图元或片元，同时输出8个结果，每次输入多个数据到GPU Core中，并获得多个结果。SIMT 比 SIMD 更加灵活。SIMT可以把多条数据，交给不同的线程去处理。各个线程里面执行的指令流程是一样的，但是可能根据数据的不同，走到不同的条件分支。这样，相同的代码和相同的流程，可能执行不同的具体的指令。这个线程走到的是 if 的条件分支，另外一个线程走到的就是 else 的条件分支了。GPU的分支处理我们CPU有对分支做预测，让流水线停顿更少，GPU Core也会对分支做优化处理。（GPU的分支处理）常用的GPU分支处理SIMD里，为每个指令都分配一个ALU做并行处理，用多个周期分别计算分支的两种结果。这样做就不会让流水线停滞，但是这样做有效率问题，在一个指令周期里，很多ALU是闲置的。因此在SIMD之后，SIMT（Single Instruction，Multiple Threads）技术可以变相的做分支的顺序执行，如下图：（SIMT 分支预测并行计算）在SIMT中，各个线程里面执行的指令流程是一样的，只是走的不同的分支。相同的代码和相同的流程，执行不同的分支。可能一些线程走到的是 if 的条件分支，而另外一些线程走到的就是 else 的条件分支，这种并行计算使得计算本身无需依赖上文，也让ALU不再空闲停滞。这里简单说下解决SIMIT流水线中的卡顿问题拆分存储缓存，让上下文依赖的计算在不同时段同时计算，以提高ALU的利用率。（卡顿时启动另一条管线）（拆分整个缓存为独立缓存）GPU为了不等待分支条件而导致的停顿流水线，就要对每个分支做都做计算。分支内的数据仍然会有依赖关系，依赖关系就会造成卡顿，需要等待计算或等待获取资源。因此将原来的一整个缓存，拆分为多个缓存，使得流水线在阻塞时能更好的使用闲置ALU计算下一条数据。这样就能更好的利用ALU计算做优化了。现实GPU硬件中的物理架构前面我们说的都是抽象的GPU Core结构，下面我们来看下实际中的GPU物理架构。看到这些GPU架构可以发现它们虽然彼此有差异，但很多概念相同，下面我们俩理清一下这些架构中组建的概念：GPC（Graphics Processing Cluster） ： 图形处理集群，GPU划分多个GPC，每个GPC里有多个TPC，每个TPC里包含了多个SM和1个Rester EngineTPC（Texture Processing Cluster） ： 图像处理集群，是由若干个SM、1个纹理单元（Texture Unit）和一些逻辑控制和ALU组成。RT Core（Ray Trace Core） ： RT Core是SM里面加了一条专用的流水线(ASIC)来计算射线和三角形求交（可以访问BVH，用于光线追踪）。由于是ASIC专用电路逻辑，与shader code做求交计算相比，性能有数量级的提升。Rester Engine ： 光栅引擎，处理它接收到的三角形，并为它负责的那些部分生成像素信息（也处理背面剔除和 Z 剔除）。PolyMorp Engine：曲面引擎，是一个带有顶点提取器、视口变换的累积集群，它处理属性设置和流输出，这些都合并到了这个处理器中，极大地扩展了曲面细分和（当发送到光栅引擎时）光栅化性能。Thread Engine：线程引擎，调度线程到核的引擎SM（Stream Multiprocessor）、SMX、SMM ：SM包含GPU Core内核，指令单位，调度程序。Warp Scheduler、Dispatch Unit：负责线程束调度，将软件线程按一捆一捆（不是一个一个）的方式分配到计算核上。一个Warp由32个线程组成，Warp Scheduler的指令通过Dispatch Units派送到Core核上执行。SP（Streaming Processors）、Core ：SP有时也叫CUDA core，一个 SP 包括多个 ALU 和 FPU。SP是作用于顶点或像素数据的真正处理单元。ALU（Arithmetic Logic Unit）、FPU（Float Point Unit）：ALU 是算术和逻辑单元，FPU 是浮点单元。INT32，FP32 ：在GPU里支持单精度运算的Single Precision ALU称之为FP32 core或简称core，而把双精度运算的Double Precision ALU称之为DP unit或者FP64 core。第三代的Kepler架构里，FP64单元和FP32单元的比例是高端机1:3或者低端机1:24，到了第五代比例为1:2，低端型号里仍然保持为1:32。SFU（Special Function Unit）：执行特殊数学运算（sin、cos、log等）TENSO CORE ： 精度混合计算单元，转换不同精度之间的运算结果，用于执行矩阵乘法的计算单元，精度混合分为整数精度和浮点数精度。ROP（Render Output Unit） ：渲染输出单元 ，一个ROP内部有很多ROP单元，在ROP单元中有深度测试和Framebuffer混合，深度和颜色的设置必须是原子操作，否则两个不同的三角形在同一个像素点就会有冲突和错误。LD/ST（Load/Store Unit）：加载和存储数据Share Memory、L1 Data Cache、L1 Cache、L2 Cache ：共享内存，以及多级的高速缓存RF（Register File）：寄存器堆，多个寄存器组成的阵列Instruction Cache ：指令缓存未完待续…参考资料：《How Shader Cores Work》https://engineering.purdue.edu/~smidkiff/KKU/files/GPUIntro.pdf《CPU体系结构》https://my.oschina.net/fileoptions/blog/1633021《深入理解CPU的分支预测(Branch Prediction)模型》https://zhuanlan.zhihu.com/p/22469702《分析Unity在移动设备的GPU内存机制（iOS篇）》https://www.jianshu.com/p/68b41a8d0b37《针对移动端TBDR架构GPU特性的渲染优化》https://gameinstitute.qq.com/community/detail/123220《A look at the PowerVR graphics architecture: Tile-based rendering》https://www.imaginationtech.com/blog/a-look-at-the-powervr-graphics-architecture-tile-based-rendering/《A look at the PowerVR graphics architecture: Deferred rendering》https://www.imaginationtech.com/blog/the-dr-in-tbdr-deferred-rendering-in-rogue/《深入GPU硬件架构及运行机制》https://www.cnblogs.com/timlly/p/11471507.html《深入浅出计算机组成原理》https://time.geekbang.org/column/article/105401?code=7VZ-Md9oM7vSBSE6JyOgcoQhDWTOd-bz5CY8xqGx234%3D《Nvidia Geforce RTX-series is born》https://www.fudzilla.com/reviews/47224-nvidia-geforce-rtx-series-is-born?start=2《渲染管线与GPU（Shading前置知识）》https://zhuanlan.zhihu.com/p/336999443《剖析虚幻渲染体系（12）- 移动端专题Part 1（UE移动端渲染分析）》https://www.cnblogs.com/timlly/p/15511402.html《tpc-texture-processing-cluster》https://gputoaster.wordpress.com/2010/12/11/tpc-texture-processing-cluster/《Life of a triangle - NVIDIA’s logical pipeline》https://developer.nvidia.com/content/life-triangle-nvidias-logical-pipeline《Rasterisation wiki》https://en.wikipedia.org/wiki/Rasterisation《PolyMorph engine and Data Caches by Hilbert Hagedoorn》https://www.guru3d.com/articles-pages/nvidia-gf100-(fermi)-technology-preview,3.html《NVIDIA GPU的一些解析》https://zhuanlan.zhihu.com/p/258196004《tensor-core-performance-the-ultimate-guide》https://developer.download.nvidia.cn/video/gputechconf/gtc/2019/presentation/s9926-tensor-core-performance-the-ultimate-guide.pdf《Understanding the Understanding the graphics pipeline》https://www.seas.upenn.edu/~cis565/LECTURES/Lecture2%20New.pdf已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247485051&amp;idx=1&amp;sn=e98f1e1971d56ce6543926b4f9bad204&amp;chksm=fc22637ccb55ea6a4c16c5c0d8fd43cff936350490d79f1e377b61e4914300c39c4fc2911da1&amp;token=53415989&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h1 id=\"背景\">背景：</h1><p>作为游戏开发从业者，从业务到语言到框架到引擎，积累了一些知识和经验，特别是在看了几遍《游戏引擎架构》后对引擎架构的理解又深入了些。</p><p>近段时间有对引擎剖析的想法，正好借这书本对游戏引擎架构做一个完整分析。</p><p>此书用简明、清楚的方式覆盖了游戏引擎架构的庞大领域，巧妙地平衡了广度与深度，并且提供了足够的细节。</p><p>借助《游戏引擎架构》这本书、结合引擎源码和自己的经验，深入分析游戏引擎的历史、架构、模块，最后通过实践简单引擎开发来完成对引擎知识的掌握。</p><p>游戏引擎知识面深而广，所以对这系列的文章书编写范围做个保护，即不对细节进行过多的阐述，重点剖析的是架构、流程以及模块的运作原理。</p><p>同时《游戏引擎架构》中部分知识太过陈旧的部分，会重新深挖后总结出自己的观点。</p><p>概述：</p><p>本系列文章对引擎中的重要的模块和库进行详细的分析，我挑选了十五个库和模块来分析：</p><ol>  <li>时间库</li>  <li>自定义容器库</li>  <li>字符串散列库</li>  <li>内存管理框架</li>  <li>RTTI与反射模块</li>  <li>图形计算库</li>  <li>资产管理模块</li>  <li>低阶渲染器</li>  <li>剔除与合批模块</li>  <li>动画模块</li>  <li>物理模块</li>  <li>UI底层框架</li>  <li>性能剖析器的核心部分</li>  <li>脚本系统</li>  <li>视觉效果模块</li></ol><p>本篇内容为列表中的第8个部分的第1节。</p><h1 id=\"正文\">正文：</h1><p>简单回顾下前文</p><p>前文我们聊了下显卡在计算机硬件主板中的位置与结构，知道了CPU、GPU的通信介质，并简单介绍了手机上的主板结构。本篇开头对上一篇做一些内容补充，PC和手机的不同硬件组织，以及CPU与其他芯片的通信过程。</p><p>下面我们开始这篇内容</p><p>本次内容会围绕GPU来写，从硬件架构到软件驱动再到引擎架构，目标是帮大家理解GPU硬件的运作原理，理解图形接口的架构，理解引擎低阶渲染器的架构。</p><p>目录：</p><ol>  <li>主板结构中的显卡</li>  <li>GPU功能发展史</li>  <li>GPU与CPU的差异</li>  <li>GPU硬件特点</li>  <li>图形驱动程序架构</li>  <li>引擎低阶渲染架构</li></ol><p>内容结构</p><ol>  <li>CPU硬件结构</li>  <li>GPU硬件结构</li>  <li>GPU手机管线与PC管线的差异</li></ol><p>简单回顾下前文，前文我们主要讲了显卡的发展历史，知道了显卡功能和管线是如何一步步转变为现在这样子的。</p><h2 id=\"cpu结构与工作原理\">CPU结构与工作原理</h2><p>我们知道，CPU运行时有三类元器件构成，取指器、译码器、运算器（逻辑算术运算器、浮点数运算器、单指令多数据运算器等）。</p><p>这三类元器件代表三个阶段取指阶段（Fetch）、指令译码阶段（Decode）、执行阶段（Execute），它们在CPU内执行的步骤如下图：</p><p>（图-取指-译指-执行三步骤）</p><p>取指阶段为从内存或缓存中取得指令并存放到寄存器中的过程。</p><p>接着，译码器会将寄存器中的指令翻译成操作指令，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类别以及各种获取操作数的方法。在组合逻辑控制的计算机中，指令译码器对不同的指令操作码产生不同的控制电位，以形成不同的微操作序列；在微程序控制的计算机中，指令译码器用指令操作码来找到执行该指令的微程序的入口，并从此入口开始执行。</p><p>运算阶段，则根据指令执行不同的运算单元，完成指令所规定的各种操作，具体实现指令的功能。为此，CPU 的不同部分被连接起来，以执行所需的操作。</p><p>（图-控制单元-运算单元-存储单元）</p><p>因此，通常我们将取指器、译码器统称为控制单元，计算器称为算术逻辑单元（ALU），寄存器和高速缓存称为存储单元。</p><p>除了这三个基本单元，当下这样复杂的CPU中还有包括分支预测器、乱序控制器、内存预加载器等等。</p><p>这里简单介绍下CPU指令流水线、分支预测、乱序执行的原理。</p><h2 id=\"指令流水线\">指令流水线</h2><p>起初CPU指令执行是线性的，只靠取指、译码、运算顺序执行三个模块，这导致元器件的工作顺序是线性的，当一个元器件执行时，其他元器件是空等待状态，CPU执行效率比较低。</p><p>为了提高效率，提高空等待的元器件的利用率，对指令执行流水线进行了拆分，并同时增加多个流水线不断减少元器件的空等待装填。如下图：</p><p>（拆分多级流水线）</p><p>将原本线性的三个指令执行顺序，拆分成一个个小模块，让这些独立的小模块可以自顾自的循环工作，减少前后的等待时间，从而提高了指令执行效率。</p><p>用这种方式把一个指令拆分成“取指令 - 指令译码 - 执行指令”这样三个部分，这就是一个三级的流水线。进一步把“执行指令”拆分成“ALU 计算（指令执行）- 内存访问 - 数据写回”，就会变成一个五级的流水线。</p><p>继续拆分，将一个长时间的操作步骤，拆分成更多的步骤，让所有步骤需要执行的时间尽量都差不多长。这样，也就可以解决我们在单指令周期处理器中遇到的复杂指令性能问题。（同时多级流水线会出现许多问题，例如模块间寄存器的写入次数太多，多模块读写同一个资源相互冲突等，这里不细说，CPU最终都有解决方案去解决）现代的 ARM 或 Intel 的 CPU，流水线级数都已经到了 14 级。</p><h2 id=\"乱序执行\">乱序执行</h2><p>我们在写程序时，常常会发现函数内几个执行操作顺序并不互相依赖，哪个在前哪个在后都没有太大的关系。此时不仅编译器会对这些不相互依赖的计算操作进行重新顺序排序用于优化CPU执行效率（这也是导致线程不同步的其中一个原因），CPU也会将不相互依赖的指令放在不相同的指令流水线上以加快执行速度。</p><p>（指令在不同CPU流水线上乱序执行：图来源网络）</p><p>我们从图中可以看到，在流水线里，当后面的指令不依赖前面的指令时，就不用等待前面的指令执行完毕后再执行，可以另起一个流水线执行，否则就需要用NOP隔周期等待的方式将执行单元延后计算。因此我们所写的代码的执行顺序其实并不是我们所想象的那样，在CPU中大部分时候其实是乱序执行的，这样元器件的利用率更高，执行效率也更高，而依赖而停顿的次数也更少。</p><p>（乱序执行的流程图）</p><p>乱序执行实际的过程比我们想象的要复杂一些，总体上它会先拆分指令，再分发给执行单元，结束后将结果重新排序，最后提交缓冲。</p><h2 id=\"分支预测\">分支预测</h2><p>程序中有很多true或false的判断来跳转下文要执行的指令，这种跳转会使得执行流水线发生停顿，因为要依赖前面代码计算的结果再决定要执行哪段程序，因此流水线不中断并等待结果，这会使CPU执行效率降低。</p><p>在CPU中有分支预测器，它是一种数字电路，在分支指令执行前，猜测哪一个分支会被执行，这样能显著提高pipeline的性能。</p><p>可以理解为，分支预测器会主动猜测分支是true还是false。</p><p>如果猜错了，处理器要flush掉pipeline, 回滚到之前的分支，然后重新热启动，选择另一条路径。 如果猜对了，处理器不需要暂停，继续往下执行。</p><p>也就是说，如果CPU每次都猜错，处理器将耗费大量时间在停止-回滚-热启动这一周期性过程里。反之，如果侥幸每次都猜对了，那么处理器将从不停止、无需等待的执行后面的指令。</p><p>（分支预测图）</p><p>CPU执行指令遇到条件时不知道该读取哪些指令，需要等待判断条件中的计算结果，这样就中断了后面指令执行流水线使得执行效率下降。于是CPU增加了分支预测器，猜if条件中是True还是False，如果猜对了效率就会提高，如果猜错了，则重新计算。</p><p>分支预测的关键是，预测算法能猜对多少。</p><p>分支预测分为动态分支预测和静态分支预测。动态预测在执行过程中统计了通过率，根据通过率去调整预测方向，静态则始终以一个值作为判断标准。动态预测有好几种，最常见的是双模预测，通过四个状态位来动态调整预测结果。其它常见分支预测器如两级自适应预测器，局部/全局分支预测器，融合分支预测器，Agree预测期，神经分支预测器等。</p><h2 id=\"cpu原理小结\">CPU原理小结</h2><p>（CPU抽象元件图）</p><p>现在我们知道了CPU指令周期的工作方式，分为三个步骤，取指、译码、运算。运算后需要寄存器和高速缓存来作为存储器，CPU会从内存中获取指令并最终将数据写入内存。</p><p>我们把CPU中的元件抽象成，取指和译码元件、逻辑运算元件、数据缓存，就有了上面这幅简单抽象的CPU结构图。</p><p>下面我们来看看硬件上的元器件是如何分布的：</p><p>（CPU硬件结构图：来源网络）</p><p>我们看到CPU除了基本的控制器、运算器、寄存器、高速缓存外，还额外放置了乱序执行器、分支预测器、内存预装载器等用于提高CPU效率。这些元器件全部加起来，整个就是一个CPU Core。</p><p>（多核架构图：来源网络）</p><p>实际的设备中通常由多个CPU Core组成多核的架构，每个CPU Core都有自己的高速缓存L1，不同CPU Core之间也有共享的高速缓存L2，通常每级缓存的存取速度有10倍的差距，而内存的存取速度比高速缓存差的更多，对于CPU Core来说可以认为它是一个外部存储设备，通过桥接芯片连接。</p><p>GPU硬件结构与原理</p><p>前面介绍了CPU的内部结构，现代无论是手机还是PC机基本都是多核的，每个核就是1个CPU Core，每个CPU Core里都有取指器和译码器，还有逻辑运算器，以及寄存器和高速缓存。除了上述基本元件外还有其他元器件用于优化CPU执行效率，包括乱序执行器、分支预测器、内存预装载器等。</p><p>GPU图形管线的变迁</p><p>我们从GPU历史里知道，原本显卡只是一个数据传输和画面转换接口，在不断的变革下成了主板上一个独立的芯片，之后就有了GPU的概念。CPU将数据传输到显存再通知GPU处理这些数据，GPU则拥有图形图像的处理流水线，专门处理图像。</p><p>起初图形的顶点、片元都在CPU上计算，到了Voodoo FX显卡时已经将图元生成后的步骤拆分到了GPU上，最后再将顶点处理部分的计算合入到GPU上，此时GPU才真正形成了自己的图形管线。如下图：</p><p>（图形计算管线变迁1-1982年前的纯2D时代）</p><p>1982年前，CPU承担大部分的工作，当时还没有GPU的概念，还只能以显示适配器的名称称呼。</p><p>（图形计算管线变迁2-1996年3dfx Voodoo）</p><p>到1996年，GPU已经可以分担CPU的部分功能，只留下顶点处理部分部分给CPU。</p><p>（图形计算管线变迁3-1998年GeForce）</p><p>到1998年，所有顶点处理和片元处理都由GPU来完成了，但没有可编程部分，管线是固定的，传入顶点后无法控制顶点和片元的变化。</p><p>（图形计算管线变迁4-2002年GeForce FX）</p><p>到2002年，正式加入了可编程着色器，让顶点和片元的计算和展示有了更多变化。</p><p>（图形计算管线变迁5-2006年GeForce 8800）</p><p>到2006年，GPU管线中又增加了细分着色器，pre-Z等节点。</p><p>这部分历史我们也可以通过OpenGL的功能变化来看这段历史的发展过程。</p><p>（来源 wiki）</p><p>1.1 1997 年 3 月，纹理对象，顶点数组</p><p>1.2 1998 年 3 月，3D 纹理、BGRA 和打包像素格式</p><p>1.2.1 1998年10月，ARB 扩展概念</p><p>1.3 2001 年 8 月，多重纹理、多重采样、纹理压缩</p><p>1.4 2002 年 7 月，深度图，GLSlang</p><p>1.5 2003 年 7 月，顶点缓冲对象 (VBO)，遮挡查询</p><p>2.0 2004 年 9 月， GLSL 1.1，MRT，两个纹理的非幂，点精灵，双面模板</p><p>2.1 2006 年 7 月 ，GLSL 1.2，像素缓冲对象 (PBO)，sRGB 纹理</p><p>3.0 2008 年 8 月 ，GLSL 1.3，纹理数组，条件渲染，帧缓冲对象 (FBO)</p><p>3.1 2009 年 3 月， GLSL 1.4，Instancing，纹理缓存对象，统一缓存对象，图元重启</p><p>3.2 2009 年 8 月， GLSL 1.5，几何着色器，多重采样纹理</p><p>3.3 2010 年 3 月， GLSL 3.30，从 OpenGL 4.0 规范向后移植尽可能多的功能</p><p>4.0 2010 年 3 月， GLSL 4.00，GPU 上的曲面细分，具有 64 位精度的着色器</p><p>4.1 2010 年 7 月， GLSL 4.10，开发人员友好的调试输出，与 OpenGL ES 2.0 的兼容性</p><p>4.2 2011 年 8 月， GLSL 4.20，带原子计数器的着色器，绘制传输给Feed back实例，着色器打包，性能改进</p><p>4.3 2012 年 8 月， GLSL 4.30，利用 GPU 并行性的计算着色器、着色器存储缓冲区对象、高质量 ETC2/EAC 纹理压缩、增强的内存安全性、多应用程序稳健性扩展、与 OpenGL ES 3.0 的兼容性</p><p>4.4 2013 年 7 月， GLSL 4.40，缓冲区放置控制，高效异步查询，着色器变量布局，高效多对象绑定，Direct3D 应用程序的流线型移植，无绑定纹理扩展，稀疏纹理扩展</p><p>4.5 2014 年 8 月， GLSL 4.50，直接状态访问 (DSA)，刷新控制，鲁棒性，OpenGL ES 3.1 API 和着色器兼容性，DX11 仿真功能</p><p>4.6 2017 年 7 月， GLSL 4.60，更高效的几何处理和着色器执行，更多信息，无错误上下文，多边形偏移钳位，SPIR-V，各向异性过滤</p><p>经过显卡历史、GPU管线的变化历史、OpenGL的功能变迁史，让我们把GPU看的更清楚。</p><h2 id=\"gpu-core结构\">GPU Core结构</h2><p>我们知道现代的 CPU 里除了基本的元器件外，还有许多围绕提高执行效率的元器件，以及增加诸多功能的其他元器件。这些元器件在 GPU 里有点多余了，GPU 的整个处理过程是一个流式处理过程，没有那么多分支条件，以及复杂的依赖关系。</p><p>因此我们可以把 GPU 里这些对应的元器件去掉，只留下取指令、指令译码、ALU 以及执行这些计算需要的寄存器和缓存。如图：</p><p>（GPU元器件瘦身图）</p><p>这样看来GPU core比CPU Core的构造简单的多了，由于传输GPU的数据并不相互依赖的，因此我们可以用很多个GPU Core来并行计算这些数据。</p><p>于是就有了，多GPU Core的结构，如下图：</p><p>（多个Core并行工作图）</p><p>多个Core并行工作时它们使用了相同的取指器并且有相同的代码，为什么不把它们并起来呢。</p><p>前面我们说过SIMD，它把4个数据一起提交并用一个指令执行它完成计算。在GPU中借鉴了SIMD，用了一种跟它很像的处理技术叫做SIMT（Single Instruction Multiple Threads），如下图：</p><p>（ 单指令多数据流管线）</p><p>在SIMT中，向GPU Core输入的是8个图元或片元，同时输出8个结果，每次输入多个数据到GPU Core中，并获得多个结果。SIMT 比 SIMD 更加灵活。</p><p>SIMT可以把多条数据，交给不同的线程去处理。各个线程里面执行的指令流程是一样的，但是可能根据数据的不同，走到不同的条件分支。这样，相同的代码和相同的流程，可能执行不同的具体的指令。这个线程走到的是 if 的条件分支，另外一个线程走到的就是 else 的条件分支了。</p><h2 id=\"gpu的分支处理\">GPU的分支处理</h2><p>我们CPU有对分支做预测，让流水线停顿更少，GPU Core也会对分支做优化处理。</p><p>（GPU的分支处理）</p><p>常用的GPU分支处理SIMD里，为每个指令都分配一个ALU做并行处理，用多个周期分别计算分支的两种结果。</p><p>这样做就不会让流水线停滞，但是这样做有效率问题，在一个指令周期里，很多ALU是闲置的。</p><p>因此在SIMD之后，SIMT（Single Instruction，Multiple Threads）技术可以变相的做分支的顺序执行，如下图：</p><p>（SIMT 分支预测并行计算）</p><p>在SIMT中，各个线程里面执行的指令流程是一样的，只是走的不同的分支。相同的代码和相同的流程，执行不同的分支。可能一些线程走到的是 if 的条件分支，而另外一些线程走到的就是 else 的条件分支，这种并行计算使得计算本身无需依赖上文，也让ALU不再空闲停滞。</p><p>这里简单说下解决SIMIT流水线中的卡顿问题</p><p>拆分存储缓存，让上下文依赖的计算在不同时段同时计算，以提高ALU的利用率。</p><p>（卡顿时启动另一条管线）</p><p>（拆分整个缓存为独立缓存）</p><p>GPU为了不等待分支条件而导致的停顿流水线，就要对每个分支做都做计算。分支内的数据仍然会有依赖关系，依赖关系就会造成卡顿，需要等待计算或等待获取资源。</p><p>因此将原来的一整个缓存，拆分为多个缓存，使得流水线在阻塞时能更好的使用闲置ALU计算下一条数据。这样就能更好的利用ALU计算做优化了。</p><p>现实GPU硬件中的物理架构</p><p>前面我们说的都是抽象的GPU Core结构，下面我们来看下实际中的GPU物理架构。</p><p>看到这些GPU架构可以发现它们虽然彼此有差异，但很多概念相同，下面我们俩理清一下这些架构中组建的概念：</p><p>GPC（Graphics Processing Cluster） ： 图形处理集群，GPU划分多个GPC，每个GPC里有多个TPC，每个TPC里包含了多个SM和1个Rester Engine</p><p>TPC（Texture Processing Cluster） ： 图像处理集群，是由若干个SM、1个纹理单元（Texture Unit）和一些逻辑控制和ALU组成。</p><p>RT Core（Ray Trace Core） ： RT Core是SM里面加了一条专用的流水线(ASIC)来计算射线和三角形求交（可以访问BVH，用于光线追踪）。由于是ASIC专用电路逻辑，与shader code做求交计算相比，性能有数量级的提升。</p><p>Rester Engine ： 光栅引擎，处理它接收到的三角形，并为它负责的那些部分生成像素信息（也处理背面剔除和 Z 剔除）。</p><p>PolyMorp Engine：曲面引擎，是一个带有顶点提取器、视口变换的累积集群，它处理属性设置和流输出，这些都合并到了这个处理器中，极大地扩展了曲面细分和（当发送到光栅引擎时）光栅化性能。</p><p>Thread Engine：线程引擎，调度线程到核的引擎</p><p>SM（Stream Multiprocessor）、SMX、SMM ：SM包含GPU Core内核，指令单位，调度程序。</p><p>Warp Scheduler、Dispatch Unit：负责线程束调度，将软件线程按一捆一捆（不是一个一个）的方式分配到计算核上。一个Warp由32个线程组成，Warp Scheduler的指令通过Dispatch Units派送到Core核上执行。</p><p>SP（Streaming Processors）、Core ：SP有时也叫CUDA core，一个 SP 包括多个 ALU 和 FPU。SP是作用于顶点或像素数据的真正处理单元。</p><p>ALU（Arithmetic Logic Unit）、FPU（Float Point Unit）：ALU 是算术和逻辑单元，FPU 是浮点单元。</p><p>INT32，FP32 ：在GPU里支持单精度运算的Single Precision ALU称之为FP32 core或简称core，而把双精度运算的Double Precision ALU称之为DP unit或者FP64 core。第三代的Kepler架构里，FP64单元和FP32单元的比例是高端机1:3或者低端机1:24，到了第五代比例为1:2，低端型号里仍然保持为1:32。</p><p>SFU（Special Function Unit）：执行特殊数学运算（sin、cos、log等）</p><p>TENSO CORE ： 精度混合计算单元，转换不同精度之间的运算结果，用于执行矩阵乘法的计算单元，精度混合分为整数精度和浮点数精度。</p><p>ROP（Render Output Unit） ：渲染输出单元 ，一个ROP内部有很多ROP单元，在ROP单元中有深度测试和Framebuffer混合，深度和颜色的设置必须是原子操作，否则两个不同的三角形在同一个像素点就会有冲突和错误。</p><p>LD/ST（Load/Store Unit）：加载和存储数据</p><p>Share Memory、L1 Data Cache、L1 Cache、L2 Cache ：共享内存，以及多级的高速缓存</p><p>RF（Register File）：寄存器堆，多个寄存器组成的阵列</p><p>Instruction Cache ：指令缓存</p><p>未完待续…</p><p>参考资料：</p><p>《How Shader Cores Work》</p><p>https://engineering.purdue.edu/~smidkiff/KKU/files/GPUIntro.pdf</p><p>《CPU体系结构》</p><p>https://my.oschina.net/fileoptions/blog/1633021</p><p>《深入理解CPU的分支预测(Branch Prediction)模型》</p><p>https://zhuanlan.zhihu.com/p/22469702</p><p>《分析Unity在移动设备的GPU内存机制（iOS篇）》</p><p>https://www.jianshu.com/p/68b41a8d0b37</p><p>《针对移动端TBDR架构GPU特性的渲染优化》</p><p>https://gameinstitute.qq.com/community/detail/123220</p><p>《A look at the PowerVR graphics architecture: Tile-based rendering》</p><p>https://www.imaginationtech.com/blog/a-look-at-the-powervr-graphics-architecture-tile-based-rendering/</p><p>《A look at the PowerVR graphics architecture: Deferred rendering》</p><p>https://www.imaginationtech.com/blog/the-dr-in-tbdr-deferred-rendering-in-rogue/</p><p>《深入GPU硬件架构及运行机制》</p><p>https://www.cnblogs.com/timlly/p/11471507.html</p><p>《深入浅出计算机组成原理》</p><p>https://time.geekbang.org/column/article/105401?code=7VZ-Md9oM7vSBSE6JyOgcoQhDWTOd-bz5CY8xqGx234%3D</p><p>《Nvidia Geforce RTX-series is born》</p><p>https://www.fudzilla.com/reviews/47224-nvidia-geforce-rtx-series-is-born?start=2</p><p>《渲染管线与GPU（Shading前置知识）》</p><p>https://zhuanlan.zhihu.com/p/336999443</p><p>《剖析虚幻渲染体系（12）- 移动端专题Part 1（UE移动端渲染分析）》</p><p>https://www.cnblogs.com/timlly/p/15511402.html</p><p>《tpc-texture-processing-cluster》</p><p>https://gputoaster.wordpress.com/2010/12/11/tpc-texture-processing-cluster/</p><p>《Life of a triangle - NVIDIA’s logical pipeline》</p><p>https://developer.nvidia.com/content/life-triangle-nvidias-logical-pipeline</p><p>《Rasterisation wiki》</p><p>https://en.wikipedia.org/wiki/Rasterisation</p><p>《PolyMorph engine and Data Caches by Hilbert Hagedoorn》</p><p>https://www.guru3d.com/articles-pages/nvidia-gf100-(fermi)-technology-preview,3.html</p><p>《NVIDIA GPU的一些解析》</p><p>https://zhuanlan.zhihu.com/p/258196004</p><p>《tensor-core-performance-the-ultimate-guide》</p><p>https://developer.download.nvidia.cn/video/gputechconf/gtc/2019/presentation/s9926-tensor-core-performance-the-ultimate-guide.pdf</p><p>《Understanding the Understanding the graphics pipeline》</p><p>https://www.seas.upenn.edu/~cis565/LECTURES/Lecture2%20New.pdf</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247485051&amp;idx=1&amp;sn=e98f1e1971d56ce6543926b4f9bad204&amp;chksm=fc22637ccb55ea6a4c16c5c0d8fd43cff936350490d79f1e377b61e4914300c39c4fc2911da1&amp;token=53415989&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/11/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B050",
            
            
            
            "tags": ["读书笔记","前端技术"],
            
            "date_published": "2021-11-22T00:00:00+08:00",
            "date_modified": "2021-11-22T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/11/08/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B048",
            "title": "读书笔记(四十八) 《游戏引擎架构》#4 低阶渲染器（2）",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：作为游戏开发从业者，从业务到语言到框架到引擎，积累了一些知识和经验，特别是在看了几遍《游戏引擎架构》后对引擎架构的理解又深入了些。近段时间有对引擎剖析的想法，正好借这书本对游戏引擎架构做一个完整分析。此书用简明、清楚的方式覆盖了游戏引擎架构的庞大领域，巧妙地平衡了广度与深度，并且提供了足够的细节。借助《游戏引擎架构》这本书、结合引擎源码和自己的经验，深入分析游戏引擎的历史、架构、模块，最后通过实践简单引擎开发来完成对引擎知识的掌握。游戏引擎知识面深而广，所以对这系列的文章书编写范围做个保护，即不对细节进行过多的阐述，重点剖析的是架构、流程以及模块的运作原理。同时《游戏引擎架构》中部分知识太过陈旧的部分，会重新深挖后总结出自己的观点。概述：本系列文章对引擎中的重要的模块和库进行详细的分析，我挑选了十五个库和模块来分析：  时间库  自定义容器库  字符串散列库  内存管理框架  RTTI与反射模块  图形计算库  资产管理模块  低阶渲染器  剔除与合批模块  动画模块  物理模块  UI底层框架  性能剖析器的核心部分  脚本系统  视觉效果模块本篇内容为列表中的第8个部分的第1节。正文：简单回顾下前文前文我们聊了下显卡在计算机硬件主板中的位置与结构，知道了CPU、GPU的通信介质，并简单介绍了手机上的主板结构。本篇开头对上一篇做一些内容补充，PC和手机的不同硬件组织，以及CPU与其他芯片的通信过程。下面我们开始这篇内容本次内容会围绕GPU来写，从硬件架构到软件驱动再到引擎架构，目标是帮大家理解GPU硬件的运作原理，理解图形接口的架构，理解引擎低阶渲染器的架构。目录：  主板结构中的显卡  GPU功能发展史  GPU与CPU的差异  GPU硬件特点  图形驱动程序架构  引擎低阶渲染架构继续上篇未结束的内容说硬件结构时，我们常常从台式 PC 开始说起，因为智能手机本质上是袖珍型计算机，具有一些额外的无线电，并且在功耗、热量输出等方面极其受限的条件下运行。PC 主要由主板芯片组组成（通常分为连接处理器和内存“北桥”（例如 Intel 的 P45）和连接各种外围总线（例如 PCI-Express、USB 等）的“南桥”（例如 Intel 的 ICH10R） )、中央处理器（例如 CPU – Intel 的 Core 2 Duo）、随机存储器内存 (RAM)、永久存储器（硬盘或固态硬盘）、图形处理单元（例如 GPU – ATI 的 Radeon HD5890） 、电源和多个连接到 PCI 或 PCI-Express 总线的外围设备（例如，内置声音芯片组或附加 Wi-Fi 卡）。（三星手机拓扑图：图片来源网络）（iPhone6p A8 正面图：图片来源网络）（iPhone6p A8 背面图：图片来源网络）（苹果A8芯片内部结构：图片来源网络）智能手机也具有所有这些组件，只是集成度更高而已。一些主要芯片通常可以包含 CPU、GPU、其他专用协处理器、主板总线、内存控制器、LCD 控制器、声音芯片组、CMOS 摄像头接口、板载内存 ，以及一些外围设备（例如 Cell、Wifi 和蓝牙无线电）。 “应用处理器”是负责一般处理的芯片（类似于 CPU + 主板芯片组），并且可能内置了一些其他功能。 “基带处理器”负责蜂窝无线通信。智能手机与 PC 如此相似，那么为什么我们今天在智能手机中看不到像 Core 2 Duo 这样的 x86 CPU？答案是，Core 2 Duo 消耗的功率和产生的热量远远超出手机的可接受范围。典型的台式机 Core 2 Duo CPU 的功耗最高可达 65W，并且需要一个主动冷却系统来防止过热。即使是英特尔的 Atom 芯片也消耗 4W（峰值 TDP），而整个手机通常必须满足低于 1W 的功率。今天我们很多智能手机都使用 ARM 芯片， ARM 的运作方式与Intel截然不同。 Intel 自己设计和构建所有处理器，而 ARM 则创建指令集，任何跟随它们的 CPU 都将能够运行与 ARM 兼容的代码。 它还为适合其指令集的处理器创建参考设计，这使公司能够围绕 ARM 的核心设计轻松生产自己的芯片组。 一些公司，如英伟达、三星和德州仪器，只是简单地许可并采用 ARM CPU 参考设计，而其他公司，如高通和 Marvell，只许可指令集并创建自己的处理器以适应它们。 第一个 ARMv7 参考设计是 Cortex A8，其架构可在今天的智能手机中找到。很久以前低端智能手机倾向于使用实现 ARMv6 指令集的 ARM11 芯片，现在已经不复存在。这里再补充一下前文的硬件通信过程，每个带有处理程序的硬件都有自己的芯片，CPU是整个电脑的主要计算芯片，GPU则被单独拆分出来作为图像的处理芯片，除了这两个大家熟知的芯片，还有内存芯片，硬盘芯片，声卡芯片，网卡芯片等，这些芯片都通过总线进行数据交互。其中前面我们提到南桥和北桥芯片桥接了快慢不同的芯片之间的通信，让不同种类的设备通信效率更高更有序。（PC端CPU与GPU通信结构图）（手机端CPU与GPU通信结构图）CPU与其他芯片之间的通信步骤，可以简单理解为，CPU通过总线发送指令数据到其他芯片，芯片收到指令并处理后，再通过总线将反馈数据给CPU，中间处理过程也会与内存芯片或其他芯片通信后再反馈给CPU。（CPU用虚拟地址访问内存拓扑图）CPU 在访问内存时需要通过 MMU 把虚拟地址转化为物理地址，再通过总线访问内存。MMU 开启后 CPU 看到的所有地址都是虚拟地址，CPU 把这个虚拟地址发给 MMU 后，MMU 会在页表里查出这个虚拟地址对应的物理地址，再通过总线去访问DDR内存芯片。从这个芯片通信角度看，我们可以明白，总线传输数据的速度，限制了计算机的运行速度。因此我们在优化计算机程序时会常常去减少CPU与GPU之间通信量，原因就是在无法增加带宽上限这个大前提下，尽量减少它们之间通信数据量，从而减少访问消耗时间。GPU功能发展史第一篇中我们介绍过一些图形接口的发展历史，现在我们来介绍一下GPU硬件的发展历史。硬件的发展史其实是一个商业的竞争过程，中间夹杂着很多商业战略与决策。尤其是当大家都看到GPU这块高新的技术’蛋糕’，有一系列公司参与进来相互竞争。因此这里不过多的介绍商业上的活动与竞争，而是专注于介绍GPU功能的发展过程。第一个真正的3D图形卡始于早期的显示控制器，即视频移位器和视频地址生成器（video shifters and video address generators）。它们充当主处理器和显示器之间的直通通道（pass-through）。传入的数据流被转换为串行位图视频输出，例如亮度，颜色以及垂直和水平复合同步，这将像素行保持在显示生成中，并同步每条连续行以及消隐间隔（时间间隔为 结束一条扫描线并开始下一条扫描线）。（图片来源网络）1970年代开始这些视频适配器出现了一系列的改进，主要兼容了不同分辨率以及不同的视频信号。1976年，ANTIC使用直接存储器访问（DMA）处理2D显示指令。1978年，英特尔82720图形卡芯片，它能够以256x256的分辨率（或以512x512的单色）显示八种颜色数据。其32KB的显示内存足以绘制线，弧，圆，矩形和字符位图。该芯片还提供了缩放，屏幕分区和滚动的功能。1979年，SGI推出了用于工作站的IRIS图形卡-GR1.x图形卡板，其中提供了用于颜色选项，几何图形卡，Z缓冲区和覆盖/底层的单独的外接（子）板。从第一块图形卡发明到现在，整个过程可以分为，视频适配器时代，2D时代、3D时代启程、3D时代崛起、3D时代巅峰，这4个部分。为此我画了一副时序图并标出了重要节点，便于大家理解显卡的发展史，同时以文字形式告知大家图形显卡的发展历史。（显卡发展史）2D时代1981年, IBM推出了个人电脑时，它提供了两种显卡，一种是“单色显卡”(简称 MDA), 一种是 “彩色绘图卡” (简称 CGA), 从名字上就可以看出，MDA是与单色显示器配合运用的, 它可以显示80行x25列的文数字, CGA则可以用在RGB的显示屏上, 它可以绘制的图形和文数字资料。1982年，IBM又推出了MGA（Monochrome Graphic Adapter）, 又称Hercules Card (大力士卡),  除了能显示图形外，还保留了原来 MDA 的功能。这些显卡均为采纳使用数字方式的，直到MCGA（Multi-Color Graphics Array）的出现，才揭开了采纳使用模拟方式的显卡的序幕。MCGA是整合在 PS/2 Model 25和30上的影像系统。它采纳使用了Analog RGA影像信号, 解析度可高达640x480, 数位RGB和类比RGB不同的的方就像是ON-OFF式切换和微调式切换之间的差别。1986年ATI推出了第一款产品，即OEM颜色仿真卡。它用于通过9针DE-9连接器将黑色背景的单色绿色，琥珀色或白色磷光体文本输出到TTL监视器，该卡至少配备了16KB的内存。1987年，ATI在其OEM产品线中增加了Graphics Solution Plus系列，该产品线将IBM PC / XT ISA 8位总线用于基于Intel 8086/8088的IBM PC。该芯片通过DIP开关支持MDA，CGA和EGA图形卡模式。ATI EGA 800：16色VGA仿真，支持800x600。VGA（Video Graphic Array）即显示绘图阵列，它IBM是在其 PS/2 的Model 50, 60和80内建的影像系统。它的数字模式可以达到720x400色, 绘图模式则可以达到640x480x16色, 以及320x200x256色，这是显卡首次可以相应情况下最大限度显示256种色彩，而这些模式更成为其后所有显卡的共同标准。1988年，带有游戏控制器端口和复合输出选项的Small Wonder Graphics解决方案问世（用于CGA和MDA仿真），以及具有扩展EGA和16位VGA支持的EGA Wonder 480和800+，以及VGA 新增了VGA和SVGA支持的Wonder和Wonder 16。1988年，Trident 8900/9000显卡，它第一次使显卡成为一个独立的配件出现在电脑里，而不再是集成的一块芯片。而后其推出的Trident 9685更是第一代3D显卡的代表。不过真正称得上开启3D显卡大门的却应该是1996年的GLINT 300SX，虽然当时其3D功能非常简单，却具有里程碑的意义。1989年推出了更新的VGA Wonder / Wonder 16系列，其中包括降低成本的VGA Edge 16（Wonder 1024系列）。新功能包括一个总线鼠标端口，并支持VESA功能连接器。这是一个金手指连接器，类似于缩短的数据总线插槽连接器，它通过带状电缆链接到另一个视频控制器，以绕过拥挤的数据总线。1991年，Wonder系列的更新继续向前发展。WonderXL卡增加了VESA 32K颜色兼容性和Sierra RAMDAC，从而将最大显示分辨率提高到640x480 @ 72Hz 或 800x600 @ 60Hz。1991年5月，ATI的Mach系列与Mach8一同推出。它以芯片或电路板的形式出售，可以通过编程接口（AI）卸载有限的2D绘图操作，例如线条画，颜色填充和位图组合（Bit BLIT）.ATI添加了Wonder的一种变体 XL在扩展PCB上集成了Creative Sound Blaster 1.5芯片。它被称为VGA Stereo-F / X，它能够模拟Sound Blaster单声道文件中的立体声，并且其质量接近FM广播质量。ATI图形卡Ultra ISA（Mach8 + VGA）,将Mach8与VGA Wonder +的图形卡核心（28800-2）结合在一起以实现其3D功能。1992年1月，Silicon Graphics Inc（SGI）发布了OpenGL 1.0，这是一个针对2D和3D图形卡的多平台供应商不可知的应用程序编程接口（API）。OpenGL是从SGI专有的API（称为IRIS GL（集成的栅格成像系统图形卡库））演变而来的。最初，OpenGL瞄准的是基于UNIX的专业市场，但是由于开发人员对扩展实施的友好支持，很快将其用于3D游戏。同时微软正在开发自己的竞争对手Direct3D API，并没有确保OpenGL在Windows下也能正常运行。1993年11月，ATI宣布68890 PC电视解码器芯片的发布，该芯片首次在Video-It卡里面亮相。借助板载Intel i750PD VCP（视频压缩处理器），该芯片能够以320x240 @ 15 fps或160x120 @ 30 fps捕获视频，并能够实时压缩/解压缩。它还能够通过数据总线与图形卡板通信，从而无需使用加密狗或端口和带状电缆。1995年，ATI的Mach8发布，创造了许多著名的首创。它成为第一个以Xclaim形式在PC和Mac计算机上使用的图形卡适配器，并且与S3的Trio一起提供了全动态视频播放加速功能。3D时代开启1995年5月，nVidia推出了他们的第一款图形卡芯片NV1，并成为首款能够进行3D渲染，视频加速和集成GUI加速的商业图形卡处理器。供应商发布显卡支持规格的主板（Diamond Edge 3D），D3D（Diamond Edge 3D）图形卡API确认依赖于渲染三角形多边形，而NV1则使用四边形纹理映射。nVidia通过驱动程序添加了有限的D3D兼容性，以将三角形包装为二次曲面，但是市面上仍然很少针对NV1量身定制的游戏。1995年11月，ATI宣布了他们的首个3D加速器芯片3D Rage（也称为Mach 64 GT）。1995年，3Dfx推出了业界的口碑极佳的3D图形加速卡：Voodoo。3Dfx的专利技术Glide引擎接口一度称霸了整个3D世界，直至D3D和OpenGL的出现才改变了这种局面。Voodoo标配为4Mb EDO显存，可以提供在640×480分辨率下3D显示速度和最华丽的画面。Voodoo也有硬伤，它只是一块具有3D加速功能的子卡，运用时需搭配一块具有2D功能的显卡，因此当时S3 765+Voodoo是为人津津乐道的黄金组合。S3 765显卡是当时兼容机的标准配置，最大限度支持2MB EDO显存，可以实现高分辨率显示，可以支持1024×768的分辨率，并且在低分辨率下支持最大限度32Bit真彩色，而且性能和价格比也较强。1995年，VideoLogic开发了一种基于图块的延迟渲染技术（TBDR），该技术在纹理、阴影和光照应用于剩下的渲染之前，抛弃了所有可见的几何形状，从而消除了对大规模z缓冲(在最终渲染中去除遮挡/隐藏的像素)的需求。这个过程产生的框架被分割成矩形块，每个图块都可以自行进行多边形渲染并发送到输出。一旦计算了帧所需的像素并剔除了多余的多边形(z缓冲只在平铺层发生)，对多边形渲染就开始了，这样就只需要进行最基本的计算。1995年，Rendition的VéritéV1000成为第一张具有可编程核心的显卡，它使用了基于MIPS的RISC处理器和Pixel Pipelines(像素管线)。处理器负责设置和组织管线的工作负载。 Vérité1000最初于1995年底开发，后来成为Microsoft用于开发Direct3D的主板之一。1996年 3DLabs 研制出Glint，该公司诞生于杜邦的Pixel图形卡部门。GLINT 300SX处理器能够进行OpenGL渲染，片段处理和光栅化。GLINT 300SX增加了2MB的内存。它为纹理和Z缓冲区使用了1MB，为帧缓冲区使用了1MB，但是还提供了一个选项，以增加VRAM的Direct3D兼容性。1997年3月ATI推出 3D Rage Pro，它在4MB格式下几乎可以媲美Voodoo Graphics的性能。在使用8MB和AGP接口时，其性能则优于3Dfx卡。它扩展了4kB高速缓存并增加了边缘抗锯齿功能，该显卡改进了Rage II的透视校正，纹理处理能力以及三线性滤波性能。还集成了一个浮点单元，以减少对CPU的依赖以及对DVD的硬件加速和显示支持。1997年4月，nVidia推出了RIVA 128（实时交互式视频和动画加速器），并通过渲染三角形多边形增加了Direct3D兼容性，使用新的350nm工艺，并开发了RAMDAC和视频转换器，这是nVidia具有里程碑意义的显卡。1998年1月，英特尔发布i740，它结合了R3D/100上两种不同的图形和纹理芯片的资源，实现了AGP纹理，纹理被上传到系统内存中(渲染缓冲区也可以存储在RAM中)。此前一些设计会选择使用显卡的帧缓冲区用来保存纹理，如果帧缓冲区饱和或纹理太大而无法存储在本地图形内存中，则纹理交换到系统RAM中。为了最大程度地减少延迟，英特尔的设计使用了AGP Direct Memory Execute（DiME）功能，该功能仅调用光栅化所需的那些纹理，其余的存储在系统RAM中。性能和图像质量可以接受的，性能大致与上一年的高端产品相匹配，因此该产品大放异彩。1998年3月，3Dfx推出Voodoo2。Voodoo2本身带有8Mb/12Mb EDO显存，PCI接口，卡上有双芯片，可以做到单周期多纹理运算。缺点是它的卡身很长，并且芯片发热量相当大，依然只作为一块3D加速子卡，需要一块2D显卡的支持。Voodoo2的推出使得3D加速又到达了一个新的里程碑，依仗Voodoo2的效果、画面和速度，征服了不少当时盛行一时的3D游戏，比如Fifa98，NBA98，Quake2等等。1998年7月，Matrox公司发布MGA G200继承了自己超一流的2D水准，3D方面有了革命性的提高，不但可以提供和Voodoo2差不多的处理速度和特技效果，另外还支持DVD硬解码和视频输出，并且独一无二的首创了128位独立双重总线技术，大大提高了性能，配合当时相当走红的AGP总线技术，G200也赢得了不少用户的喜爱。1998年的S3的野人系列Savage系列显卡，Savage3D采纳使用128位总线结构及单周期三线性多重贴图技术，最大像素填充率达到了125M Pixels/s，三角形生成速率也达到了每秒500万个。通过S3新设计的AGP引擎和S3TC纹理压缩技术，支持Direct3D与OpenGL，最大显存容量可达8MB SGRAM或SDRAM，支持AGP 4×规范。相应情况下也支持当时流行的如反射和散射、Alpha混合、多重纹理、衬底纹理、边缘抗锯齿、16/24位Z-buffering、Tri-linear Filtering（三线性过滤技术）、S3TC纹理压缩技术等技术。可惜就是受到驱动程序不兼容的严重影响，最终在99年时惨淡收场。3D时代崛起1999年2月，S3发布Savage4，成为的第一张支持多重纹理的显卡，也是第一张支持AGP 4x接口的显卡。1999年，NVidia推出TNT2 Ultra、TNT2和TNT2 M64三个版本的芯片，后来又有PRO和VANTA两个版本。这种分类方式也促使后来各个生产厂家对同一芯片进行高中低端的划分，以满足不同层次的消费需要。TNT系列配置了8Mb到32Mb的显存，支持AGP2X/4X，支持32位渲染等等众多技术。nVidia能战胜Voodoo3，与3Dfx公司推行的策略迫使众多生产厂家投奔nVidia也不无关系，促进了TNT系列的推广。1999年，Matrox推出 MGA G400，它拥有16Mb/32Mb的显存容量，支持AGP 2X/4X，还有支持大纹理以及32位渲染等等，独特漂亮的EMBM硬件凹凸贴图技术，营造出的完美凹凸感并能实现动态光影效果的技术，并且G400拥有优秀的DVD回放能力，只是价格有些昂贵。通过双显示控制器（被Matrox称为DualHead）驱动两台显示器的能力开始了公司的多显示器支持趋势。1999年，nVidia终于爆发了，它在99年末推出了当前革命性的显卡—Geforce 256，彻底打败了3Dfx。代号NV10的GeForce 256支持Cube-Environment Mapping，完全的硬件T&amp;L（Transform &amp; Lighting），把原来有CPU计算的数据直接交给显示芯片处理，大大解放了CPU，也提高了芯片的运用效率。GeForce256拥有4条图形纹理通道，单周期每条通道处理两个象素纹理，工作频率120MHz，全速可以达到480Mpixels/Sec，支持SDRAM和DDR RAM，运用DDR的产品能更好的发挥GeForce256的性能。其不足之处就在于采纳使用了0.22纳米的工艺技术，发热量相对其它的来说很高的。2000年7月，3Dfx发布的Voodoo 5引入了T-buffer技术，作为变换和照明的一种替代方法，它基本上采用了一些渲染帧并将它们聚合为一个图像的方法。这产生了稍微模糊的图片，当按帧顺序运行时，可以平滑动画的运动。2000年末，3Dfx最终被nVidia收购。3D时代巅峰2000年，ATI依仗T&amp;L技术打开市场，在经历“曙光女神”的失败后，ATI推出了自己的T&amp;L芯片RADEON 256。RADEON和NVIDIA一样具有高低端的版本，完全硬件T&amp;L，Dot3和环境映射凹凸贴图，还有两条纹理流水线，可以相应情况下处理三种纹理。最出彩的是HYPER-Z技术，大大提高了RADEON显卡的3D速度，拉近了与GEFORCE 2系列的距离，ATI的显卡开始在市场占据主导地位。2000年4月，nVidia发布了GeForce 2 GTS（GigaTexel Shader），称为Nvidia Shading Rasterizer，它允许将高光阴影，体积爆炸，折射，波浪，顶点混合，阴影体积，凹凸贴图和高程贴图等效果应用于每个像素通过硬件的基础。2000年8月，ATI Radeon DDR上市。在卓越的T&amp;L实现和对即将推出的DirectX 8特性的支持下，Radeon DDR与GeForce 2 GTS一起，通过将对接口的支持集成到芯片本身，引入了DVI输出的使用。2001年，nVidia推出的Geforce 3系列，这张卡成为了该领域的新王者，GeForce 3显卡增加了可编程T&amp;L功能，可以对几乎所有的画面效果提供硬件支持。GeForce 3总共具有4条像素管道，填充速率最大限度可以达到每秒钟800 Mpixels。支持DirectX 8，多重采样AA，梅花AA（基本上是2xMSAA +后期处理模糊），8x各向异性滤光以及无与伦比的处理8xAF +三线性滤光的能力以及可编程的顶点着色器，用于更紧密地控制多边形网格运动和更流畅的动画序列。还有LMA(光速内存架构)支持——基本上是Nvidia的HyperZ版本——用于剔除隐藏在屏幕上其他像素后面的像素(Z遮挡剔除)，以及压缩和解压数据以优化带宽使用(Z压缩)。最后，Nvidia实现了负载平衡算法，将其称为Crossbar内存控制器，该控制器由四个独立的内存子控制器（与行业标准的单个控制器相对）组成，从而可以更有效地路由传入的内存请求。2001年，ATI则推出Radeon 8500/7500系列，采纳使用0.15微米工艺制造，包括6000万个晶体管，采纳使用了不少新技术(如Truform、Smartshader等)。并根据显卡的核心/显存工作频率分成不同的档次——核心/显存分别为275/550MHz的标准版，核心/显存为250/500MHz的RADEON 8500LE，生产核心/显存频率分别为300/600MHz的Ultra版，以及中端的Radeon 7500，低端的Radeon 7200，7000等产品。值得一提的是Radeon 8500还支持双头显示技术。2002年，ATI R300 GPU发布，由最初构成ArtX核心的团队开发，交付出色。它是第一个提供DirectX 9.0支持的应用程序，并且扩展了第一个支持着色器模型2.0，顶点着色器2.0和像素着色器2.0的体系结构。2002年，nVidia与ATI的竞争更加白热化。为巩固其图形芯片市场霸主的位，nVidia推出了Geforce 4系列，GeForce4 Ti系列择定确定是最具性能和价格比的，其代号是NV25，主要针对当时的高端图形市场，是DirectX 8时代下最劲爆强大的GPU图形处理器。芯片内部包含的晶体管数量高达6千3百万，运用0.15微米工艺生产，采纳使用了新的PBGA封装，运行频率达到了300MHz，配合频率为650MHz DDR显存，可以实现每秒49亿次的采样。GeForce4 Ti核心内建4条渲染流水线，每条流水线包含2个TMU（材质贴图单元）。Geforce 4系列从高到低，横扫了整个显卡市场。2002年，ATI推出R9700/9000/9500系列，首次支持DirectX 9，使其在与NVidia的竞争中抢得先机。同时R9700支持AGP 8X、DirectX 9，核心频率是300MHz，显存时钟是550MHz。RADEON 9700实现了可程序化的革命性硬件架构。符合AGP 8X最新标准，配有8个平等处理的渲染管线，每秒可处理25亿个像素，4个并列的几何处理引擎能处理每秒3亿个形迹及光效多边形。R9000则面向低端的产品，R9500则对标Ti4200。2003年的显卡市场依旧为N系与A系所统治。nVidia的Gf FX 5800（NV30）系列拥有32位着色，颜色画面有质的提高，在基础上推出的GeForce FX 5900，提高了晶体管数，降低了核心频率与显存频率，改用了256BIT DDR以提高显存带宽。2003年7月，nVidia推出了GF FX 5950/5700系列，以取代GF FX 5900/5600。新的Detonator FX驱动程序大大改善了AA和AF。2003年9月，ATI推出了RADEON 9800/pro/SE/XT，依仗其超强的性能以及较低的售价，再次打败GF GX 5800。2004年是ATI大放异彩的一年，其最大的功臣却是来自于面向中低端的Radeon 9550。2004年最具性能和价格比的显卡，让ATI在低端市场呼风唤雨。R9550基于RV350核心，采纳使用0.13微米制程，核心频率为250MHz，显存频率为400MHz，4条渲染管道，1个纹理单元，相应情况下兼容64bit和128bit。2005年，Nvidia推出6000系列显卡，特性包括DirectX 9.0c支持、shader model 3.0(尽管显卡从未完全利用这一点)、Nvidia的PureVideo解码和播放引擎，以及SLI支持。2006年10月25日，ATI被AMD收购，总价为54亿美元。–NVIDIA发展表：1995年，NV150K triangles/sec1M pixel ops/sec1M transistors16-bit colorNearest filtering1997年，Riva 128 (NV3), DX31998 – Riva TNT (NV4), DX532位颜色,24位Z缓存,8位模板缓存双纹理,双线性过滤每时钟2像素 (2 ppc)1999 - GeForce 256（NV10）固定管线，支持DirectX 7.0硬件T&amp;L（Transform &amp; lighting，坐标变换和光照）立方体环境图（Cubemaps）DOT3 – bump mapping2倍各向异性过滤三线性过滤DXT纹理压缩4ppc引入“GPU”术语2001 - GeForce 3DirectX 8.0Shader Model 1.0可编程渲染管线顶点着色器像素着色器3D纹理硬件阴影图8倍各向异性过滤多采样抗锯齿（MSAA）2003 - GeForce FX系列（NV3x）DirectX 9.0Shader Model 2.0256顶点操作指令32纹理 + 64算术像素操作指令512像素操作指令着色语言：HLSL、CGSL、GLSL2004 - GeForce 6系列 (NV4x)DirectX 9.0cShader Model 3.0动态流控制分支、循环、声明等顶点纹理读取高动态范围（HDR）64位渲染纹理（Render Target）FP16*4 纹理过滤和混合2006 - GeForce 8系列 (G8x)DirectX 10.0Shader Model 4.0几何着色器（Geometry Shaders）没有上限位（No caps bits）统一的着色器（Unified Shaders）Vista系统全新驱动基于GPU计算的CUDA问世GPU计算能力以GFLOPS计量。2010 - GeForce 405（GF119）DirectX 11.0曲面细分（Tessellation）外壳着色器（Hull Shader）镶嵌单元（tessellator）域着色器（Domain Shader）计算着色器（Compute Shader）支持Stream OutputShader Model 5.0DirectX 11的渲染管线。多线程支持改进的纹理压缩Shader Model 5.0更多指令、存储单元、寄存器面向对象着色语言曲面细分计算着色器2014 - GeForceGT 710（GK208）DirectX 12.0轻量化驱动层硬件级多线程渲染支持更完善的硬件资源管理2016 - GeForceGTX 1060 6GB首次支持RTX和DXR技术，即光线追踪引入RT Core（光线追踪核心）支持RTX光线追踪的显卡列表2018 - TITAN RTX（TU102）DirectX 12.1，OpenGL 4.56GPC，36TPC，72SM，72RT Core，...8K分辨率，1770MHz主频，24G显存，384位带宽参考资料：《GPU历史系列》https://new.qq.com/omn/20200506/20200506A0GP6H00.html?pc《GPU发展史》http://www.360doc.com/content/16/0607/16/30123241_565810074.shtml《显卡发展史1》http://www.360doc.com/content/20/0504/17/32196507_910185372.shtml《显卡发展史2》http://www.360doc.com/content/20/0504/17/32196507_910185435.shtml《显卡发展史3》http://www.360doc.com/content/20/0504/17/32196507_910187350.shtml《Making Sense of Smartphone Processors: The Mobile CPU/GPU Guide》https://www.techautos.com/2010/03/14/smartphone-processor-guide/《移动设备GPU架构知识汇总》https://zhuanlan.zhihu.com/p/112120206《针对移动端TBDR架构GPU特性的渲染优化》https://gameinstitute.qq.com/community/detail/123220《A look at the PowerVR graphics architecture: Tile-based rendering》https://www.imaginationtech.com/blog/a-look-at-the-powervr-graphics-architecture-tile-based-rendering/《A look at the PowerVR graphics architecture: Deferred rendering》https://www.imaginationtech.com/blog/the-dr-in-tbdr-deferred-rendering-in-rogue/《深入GPU硬件架构及运行机制》https://www.cnblogs.com/timlly/p/11471507.html已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484981&amp;idx=1&amp;sn=b5199f84ed73d28916dbb9143eeeb992&amp;chksm=fc226332cb55ea2417b89e499284ab3a552ce591caba09d637912306503e4b457ed45c2e1d2d&amp;token=1023740201&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h2 id=\"背景\">背景：</h2><p>作为游戏开发从业者，从业务到语言到框架到引擎，积累了一些知识和经验，特别是在看了几遍《游戏引擎架构》后对引擎架构的理解又深入了些。</p><p>近段时间有对引擎剖析的想法，正好借这书本对游戏引擎架构做一个完整分析。</p><p>此书用简明、清楚的方式覆盖了游戏引擎架构的庞大领域，巧妙地平衡了广度与深度，并且提供了足够的细节。</p><p>借助《游戏引擎架构》这本书、结合引擎源码和自己的经验，深入分析游戏引擎的历史、架构、模块，最后通过实践简单引擎开发来完成对引擎知识的掌握。</p><p>游戏引擎知识面深而广，所以对这系列的文章书编写范围做个保护，即不对细节进行过多的阐述，重点剖析的是架构、流程以及模块的运作原理。</p><p>同时《游戏引擎架构》中部分知识太过陈旧的部分，会重新深挖后总结出自己的观点。</p><h2 id=\"概述\">概述：</h2><p>本系列文章对引擎中的重要的模块和库进行详细的分析，我挑选了十五个库和模块来分析：</p><ol>  <li>时间库</li>  <li>自定义容器库</li>  <li>字符串散列库</li>  <li>内存管理框架</li>  <li>RTTI与反射模块</li>  <li>图形计算库</li>  <li>资产管理模块</li>  <li>低阶渲染器</li>  <li>剔除与合批模块</li>  <li>动画模块</li>  <li>物理模块</li>  <li>UI底层框架</li>  <li>性能剖析器的核心部分</li>  <li>脚本系统</li>  <li>视觉效果模块</li></ol><p>本篇内容为列表中的第8个部分的第1节。</p><h2 id=\"正文\">正文：</h2><p>简单回顾下前文</p><p>前文我们聊了下显卡在计算机硬件主板中的位置与结构，知道了CPU、GPU的通信介质，并简单介绍了手机上的主板结构。本篇开头对上一篇做一些内容补充，PC和手机的不同硬件组织，以及CPU与其他芯片的通信过程。</p><p>下面我们开始这篇内容</p><h3 id=\"本次内容会围绕gpu来写从硬件架构到软件驱动再到引擎架构目标是帮大家理解gpu硬件的运作原理理解图形接口的架构理解引擎低阶渲染器的架构\">本次内容会围绕GPU来写，从硬件架构到软件驱动再到引擎架构，目标是帮大家理解GPU硬件的运作原理，理解图形接口的架构，理解引擎低阶渲染器的架构。</h3><p>目录：</p><ol>  <li>主板结构中的显卡</li>  <li>GPU功能发展史</li>  <li>GPU与CPU的差异</li>  <li>GPU硬件特点</li>  <li>图形驱动程序架构</li>  <li>引擎低阶渲染架构</li></ol><p>继续上篇未结束的内容</p><p>说硬件结构时，我们常常从台式 PC 开始说起，因为智能手机本质上是袖珍型计算机，具有一些额外的无线电，并且在功耗、热量输出等方面极其受限的条件下运行。PC 主要由主板芯片组组成（通常分为连接处理器和内存“北桥”（例如 Intel 的 P45）和连接各种外围总线（例如 PCI-Express、USB 等）的“南桥”（例如 Intel 的 ICH10R） )、中央处理器（例如 CPU – Intel 的 Core 2 Duo）、随机存储器内存 (RAM)、永久存储器（硬盘或固态硬盘）、图形处理单元（例如 GPU – ATI 的 Radeon HD5890） 、电源和多个连接到 PCI 或 PCI-Express 总线的外围设备（例如，内置声音芯片组或附加 Wi-Fi 卡）。</p><p>（三星手机拓扑图：图片来源网络）</p><p>（iPhone6p A8 正面图：图片来源网络）</p><p>（iPhone6p A8 背面图：图片来源网络）</p><p>（苹果A8芯片内部结构：图片来源网络）</p><p>智能手机也具有所有这些组件，只是集成度更高而已。一些主要芯片通常可以包含 CPU、GPU、其他专用协处理器、主板总线、内存控制器、LCD 控制器、声音芯片组、CMOS 摄像头接口、板载内存 ，以及一些外围设备（例如 Cell、Wifi 和蓝牙无线电）。 “应用处理器”是负责一般处理的芯片（类似于 CPU + 主板芯片组），并且可能内置了一些其他功能。 “基带处理器”负责蜂窝无线通信。</p><p>智能手机与 PC 如此相似，那么为什么我们今天在智能手机中看不到像 Core 2 Duo 这样的 x86 CPU？答案是，Core 2 Duo 消耗的功率和产生的热量远远超出手机的可接受范围。典型的台式机 Core 2 Duo CPU 的功耗最高可达 65W，并且需要一个主动冷却系统来防止过热。即使是英特尔的 Atom 芯片也消耗 4W（峰值 TDP），而整个手机通常必须满足低于 1W 的功率。</p><p>今天我们很多智能手机都使用 ARM 芯片， ARM 的运作方式与Intel截然不同。 Intel 自己设计和构建所有处理器，而 ARM 则创建指令集，任何跟随它们的 CPU 都将能够运行与 ARM 兼容的代码。 它还为适合其指令集的处理器创建参考设计，这使公司能够围绕 ARM 的核心设计轻松生产自己的芯片组。 一些公司，如英伟达、三星和德州仪器，只是简单地许可并采用 ARM CPU 参考设计，而其他公司，如高通和 Marvell，只许可指令集并创建自己的处理器以适应它们。 第一个 ARMv7 参考设计是 Cortex A8，其架构可在今天的智能手机中找到。很久以前低端智能手机倾向于使用实现 ARMv6 指令集的 ARM11 芯片，现在已经不复存在。</p><p>这里再补充一下前文的硬件通信过程，每个带有处理程序的硬件都有自己的芯片，CPU是整个电脑的主要计算芯片，GPU则被单独拆分出来作为图像的处理芯片，除了这两个大家熟知的芯片，还有内存芯片，硬盘芯片，声卡芯片，网卡芯片等，这些芯片都通过总线进行数据交互。其中前面我们提到南桥和北桥芯片桥接了快慢不同的芯片之间的通信，让不同种类的设备通信效率更高更有序。</p><p>（PC端CPU与GPU通信结构图）</p><p>（手机端CPU与GPU通信结构图）</p><h3 id=\"cpu与其他芯片之间的通信步骤可以简单理解为cpu通过总线发送指令数据到其他芯片芯片收到指令并处理后再通过总线将反馈数据给cpu中间处理过程也会与内存芯片或其他芯片通信后再反馈给cpu\">CPU与其他芯片之间的通信步骤，可以简单理解为，CPU通过总线发送指令数据到其他芯片，芯片收到指令并处理后，再通过总线将反馈数据给CPU，中间处理过程也会与内存芯片或其他芯片通信后再反馈给CPU。</h3><p>（CPU用虚拟地址访问内存拓扑图）</p><h3 id=\"cpu-在访问内存时需要通过-mmu-把虚拟地址转化为物理地址再通过总线访问内存mmu-开启后-cpu-看到的所有地址都是虚拟地址cpu-把这个虚拟地址发给-mmu-后mmu-会在页表里查出这个虚拟地址对应的物理地址再通过总线去访问ddr内存芯片\">CPU 在访问内存时需要通过 MMU 把虚拟地址转化为物理地址，再通过总线访问内存。MMU 开启后 CPU 看到的所有地址都是虚拟地址，CPU 把这个虚拟地址发给 MMU 后，MMU 会在页表里查出这个虚拟地址对应的物理地址，再通过总线去访问DDR内存芯片。</h3><p>从这个芯片通信角度看，我们可以明白，总线传输数据的速度，限制了计算机的运行速度。因此我们在优化计算机程序时会常常去减少CPU与GPU之间通信量，原因就是在无法增加带宽上限这个大前提下，尽量减少它们之间通信数据量，从而减少访问消耗时间。</p><h2 id=\"gpu功能发展史\">GPU功能发展史</h2><p>第一篇中我们介绍过一些图形接口的发展历史，现在我们来介绍一下GPU硬件的发展历史。硬件的发展史其实是一个商业的竞争过程，中间夹杂着很多商业战略与决策。尤其是当大家都看到GPU这块高新的技术’蛋糕’，有一系列公司参与进来相互竞争。因此这里不过多的介绍商业上的活动与竞争，而是专注于介绍GPU功能的发展过程。</p><p>第一个真正的3D图形卡始于早期的显示控制器，即视频移位器和视频地址生成器（video shifters and video address generators）。它们充当主处理器和显示器之间的直通通道（pass-through）。传入的数据流被转换为串行位图视频输出，例如亮度，颜色以及垂直和水平复合同步，这将像素行保持在显示生成中，并同步每条连续行以及消隐间隔（时间间隔为 结束一条扫描线并开始下一条扫描线）。</p><p>（图片来源网络）</p><p>1970年代开始这些视频适配器出现了一系列的改进，主要兼容了不同分辨率以及不同的视频信号。</p><p>1976年，ANTIC使用直接存储器访问（DMA）处理2D显示指令。</p><p>1978年，英特尔82720图形卡芯片，它能够以256x256的分辨率（或以512x512的单色）显示八种颜色数据。其32KB的显示内存足以绘制线，弧，圆，矩形和字符位图。该芯片还提供了缩放，屏幕分区和滚动的功能。</p><p>1979年，SGI推出了用于工作站的IRIS图形卡-GR1.x图形卡板，其中提供了用于颜色选项，几何图形卡，Z缓冲区和覆盖/底层的单独的外接（子）板。</p><p>从第一块图形卡发明到现在，整个过程可以分为，视频适配器时代，2D时代、3D时代启程、3D时代崛起、3D时代巅峰，这4个部分。</p><p>为此我画了一副时序图并标出了重要节点，便于大家理解显卡的发展史，同时以文字形式告知大家图形显卡的发展历史。</p><p>（显卡发展史）</p><h2 id=\"2d时代\">2D时代</h2><p>1981年, IBM推出了个人电脑时，它提供了两种显卡，一种是“单色显卡”(简称 MDA), 一种是 “彩色绘图卡” (简称 CGA), 从名字上就可以看出，MDA是与单色显示器配合运用的, 它可以显示80行x25列的文数字, CGA则可以用在RGB的显示屏上, 它可以绘制的图形和文数字资料。</p><p>1982年，IBM又推出了MGA（Monochrome Graphic Adapter）, 又称Hercules Card (大力士卡),  除了能显示图形外，还保留了原来 MDA 的功能。</p><p>这些显卡均为采纳使用数字方式的，直到MCGA（Multi-Color Graphics Array）的出现，才揭开了采纳使用模拟方式的显卡的序幕。MCGA是整合在 PS/2 Model 25和30上的影像系统。它采纳使用了Analog RGA影像信号, 解析度可高达640x480, 数位RGB和类比RGB不同的的方就像是ON-OFF式切换和微调式切换之间的差别。</p><p>1986年ATI推出了第一款产品，即OEM颜色仿真卡。它用于通过9针DE-9连接器将黑色背景的单色绿色，琥珀色或白色磷光体文本输出到TTL监视器，该卡至少配备了16KB的内存。</p><p>1987年，ATI在其OEM产品线中增加了Graphics Solution Plus系列，该产品线将IBM PC / XT ISA 8位总线用于基于Intel 8086/8088的IBM PC。该芯片通过DIP开关支持MDA，CGA和EGA图形卡模式。ATI EGA 800：16色VGA仿真，支持800x600。</p><p>VGA（Video Graphic Array）即显示绘图阵列，它IBM是在其 PS/2 的Model 50, 60和80内建的影像系统。它的数字模式可以达到720x400色, 绘图模式则可以达到640x480x16色, 以及320x200x256色，这是显卡首次可以相应情况下最大限度显示256种色彩，而这些模式更成为其后所有显卡的共同标准。</p><p>1988年，带有游戏控制器端口和复合输出选项的Small Wonder Graphics解决方案问世（用于CGA和MDA仿真），以及具有扩展EGA和16位VGA支持的EGA Wonder 480和800+，以及VGA 新增了VGA和SVGA支持的Wonder和Wonder 16。</p><p>1988年，Trident 8900/9000显卡，它第一次使显卡成为一个独立的配件出现在电脑里，而不再是集成的一块芯片。而后其推出的Trident 9685更是第一代3D显卡的代表。不过真正称得上开启3D显卡大门的却应该是1996年的GLINT 300SX，虽然当时其3D功能非常简单，却具有里程碑的意义。</p><p>1989年推出了更新的VGA Wonder / Wonder 16系列，其中包括降低成本的VGA Edge 16（Wonder 1024系列）。新功能包括一个总线鼠标端口，并支持VESA功能连接器。这是一个金手指连接器，类似于缩短的数据总线插槽连接器，它通过带状电缆链接到另一个视频控制器，以绕过拥挤的数据总线。</p><p>1991年，Wonder系列的更新继续向前发展。WonderXL卡增加了VESA 32K颜色兼容性和Sierra RAMDAC，从而将最大显示分辨率提高到640x480 @ 72Hz 或 800x600 @ 60Hz。</p><p>1991年5月，ATI的Mach系列与Mach8一同推出。它以芯片或电路板的形式出售，可以通过编程接口（AI）卸载有限的2D绘图操作，例如线条画，颜色填充和位图组合（Bit BLIT）.ATI添加了Wonder的一种变体 XL在扩展PCB上集成了Creative Sound Blaster 1.5芯片。它被称为VGA Stereo-F / X，它能够模拟Sound Blaster单声道文件中的立体声，并且其质量接近FM广播质量。ATI图形卡Ultra ISA（Mach8 + VGA）,将Mach8与VGA Wonder +的图形卡核心（28800-2）结合在一起以实现其3D功能。</p><p>1992年1月，Silicon Graphics Inc（SGI）发布了OpenGL 1.0，这是一个针对2D和3D图形卡的多平台供应商不可知的应用程序编程接口（API）。OpenGL是从SGI专有的API（称为IRIS GL（集成的栅格成像系统图形卡库））演变而来的。最初，OpenGL瞄准的是基于UNIX的专业市场，但是由于开发人员对扩展实施的友好支持，很快将其用于3D游戏。同时微软正在开发自己的竞争对手Direct3D API，并没有确保OpenGL在Windows下也能正常运行。</p><p>1993年11月，ATI宣布68890 PC电视解码器芯片的发布，该芯片首次在Video-It卡里面亮相。借助板载Intel i750PD VCP（视频压缩处理器），该芯片能够以320x240 @ 15 fps或160x120 @ 30 fps捕获视频，并能够实时压缩/解压缩。它还能够通过数据总线与图形卡板通信，从而无需使用加密狗或端口和带状电缆。</p><p>1995年，ATI的Mach8发布，创造了许多著名的首创。它成为第一个以Xclaim形式在PC和Mac计算机上使用的图形卡适配器，并且与S3的Trio一起提供了全动态视频播放加速功能。</p><h2 id=\"3d时代开启\">3D时代开启</h2><p>1995年5月，nVidia推出了他们的第一款图形卡芯片NV1，并成为首款能够进行3D渲染，视频加速和集成GUI加速的商业图形卡处理器。供应商发布显卡支持规格的主板（Diamond Edge 3D），D3D（Diamond Edge 3D）图形卡API确认依赖于渲染三角形多边形，而NV1则使用四边形纹理映射。nVidia通过驱动程序添加了有限的D3D兼容性，以将三角形包装为二次曲面，但是市面上仍然很少针对NV1量身定制的游戏。</p><p>1995年11月，ATI宣布了他们的首个3D加速器芯片3D Rage（也称为Mach 64 GT）。</p><p>1995年，3Dfx推出了业界的口碑极佳的3D图形加速卡：Voodoo。3Dfx的专利技术Glide引擎接口一度称霸了整个3D世界，直至D3D和OpenGL的出现才改变了这种局面。</p><p>Voodoo标配为4Mb EDO显存，可以提供在640×480分辨率下3D显示速度和最华丽的画面。Voodoo也有硬伤，它只是一块具有3D加速功能的子卡，运用时需搭配一块具有2D功能的显卡，因此当时S3 765+Voodoo是为人津津乐道的黄金组合。</p><p>S3 765显卡是当时兼容机的标准配置，最大限度支持2MB EDO显存，可以实现高分辨率显示，可以支持1024×768的分辨率，并且在低分辨率下支持最大限度32Bit真彩色，而且性能和价格比也较强。</p><p>1995年，VideoLogic开发了一种基于图块的延迟渲染技术（TBDR），该技术在纹理、阴影和光照应用于剩下的渲染之前，抛弃了所有可见的几何形状，从而消除了对大规模z缓冲(在最终渲染中去除遮挡/隐藏的像素)的需求。这个过程产生的框架被分割成矩形块，每个图块都可以自行进行多边形渲染并发送到输出。一旦计算了帧所需的像素并剔除了多余的多边形(z缓冲只在平铺层发生)，对多边形渲染就开始了，这样就只需要进行最基本的计算。</p><p>1995年，Rendition的VéritéV1000成为第一张具有可编程核心的显卡，它使用了基于MIPS的RISC处理器和Pixel Pipelines(像素管线)。处理器负责设置和组织管线的工作负载。 Vérité1000最初于1995年底开发，后来成为Microsoft用于开发Direct3D的主板之一。</p><p>1996年 3DLabs 研制出Glint，该公司诞生于杜邦的Pixel图形卡部门。GLINT 300SX处理器能够进行OpenGL渲染，片段处理和光栅化。GLINT 300SX增加了2MB的内存。它为纹理和Z缓冲区使用了1MB，为帧缓冲区使用了1MB，但是还提供了一个选项，以增加VRAM的Direct3D兼容性。</p><p>1997年3月ATI推出 3D Rage Pro，它在4MB格式下几乎可以媲美Voodoo Graphics的性能。在使用8MB和AGP接口时，其性能则优于3Dfx卡。它扩展了4kB高速缓存并增加了边缘抗锯齿功能，该显卡改进了Rage II的透视校正，纹理处理能力以及三线性滤波性能。还集成了一个浮点单元，以减少对CPU的依赖以及对DVD的硬件加速和显示支持。</p><p>1997年4月，nVidia推出了RIVA 128（实时交互式视频和动画加速器），并通过渲染三角形多边形增加了Direct3D兼容性，使用新的350nm工艺，并开发了RAMDAC和视频转换器，这是nVidia具有里程碑意义的显卡。</p><p>1998年1月，英特尔发布i740，它结合了R3D/100上两种不同的图形和纹理芯片的资源，实现了AGP纹理，纹理被上传到系统内存中(渲染缓冲区也可以存储在RAM中)。此前一些设计会选择使用显卡的帧缓冲区用来保存纹理，如果帧缓冲区饱和或纹理太大而无法存储在本地图形内存中，则纹理交换到系统RAM中。为了最大程度地减少延迟，英特尔的设计使用了AGP Direct Memory Execute（DiME）功能，该功能仅调用光栅化所需的那些纹理，其余的存储在系统RAM中。性能和图像质量可以接受的，性能大致与上一年的高端产品相匹配，因此该产品大放异彩。</p><p>1998年3月，3Dfx推出Voodoo2。Voodoo2本身带有8Mb/12Mb EDO显存，PCI接口，卡上有双芯片，可以做到单周期多纹理运算。缺点是它的卡身很长，并且芯片发热量相当大，依然只作为一块3D加速子卡，需要一块2D显卡的支持。Voodoo2的推出使得3D加速又到达了一个新的里程碑，依仗Voodoo2的效果、画面和速度，征服了不少当时盛行一时的3D游戏，比如Fifa98，NBA98，Quake2等等。</p><p>1998年7月，Matrox公司发布MGA G200继承了自己超一流的2D水准，3D方面有了革命性的提高，不但可以提供和Voodoo2差不多的处理速度和特技效果，另外还支持DVD硬解码和视频输出，并且独一无二的首创了128位独立双重总线技术，大大提高了性能，配合当时相当走红的AGP总线技术，G200也赢得了不少用户的喜爱。</p><p>1998年的S3的野人系列Savage系列显卡，Savage3D采纳使用128位总线结构及单周期三线性多重贴图技术，最大像素填充率达到了125M Pixels/s，三角形生成速率也达到了每秒500万个。通过S3新设计的AGP引擎和S3TC纹理压缩技术，支持Direct3D与OpenGL，最大显存容量可达8MB SGRAM或SDRAM，支持AGP 4×规范。相应情况下也支持当时流行的如反射和散射、Alpha混合、多重纹理、衬底纹理、边缘抗锯齿、16/24位Z-buffering、Tri-linear Filtering（三线性过滤技术）、S3TC纹理压缩技术等技术。可惜就是受到驱动程序不兼容的严重影响，最终在99年时惨淡收场。</p><h2 id=\"3d时代崛起\">3D时代崛起</h2><p>1999年2月，S3发布Savage4，成为的第一张支持多重纹理的显卡，也是第一张支持AGP 4x接口的显卡。</p><p>1999年，NVidia推出TNT2 Ultra、TNT2和TNT2 M64三个版本的芯片，后来又有PRO和VANTA两个版本。这种分类方式也促使后来各个生产厂家对同一芯片进行高中低端的划分，以满足不同层次的消费需要。TNT系列配置了8Mb到32Mb的显存，支持AGP2X/4X，支持32位渲染等等众多技术。nVidia能战胜Voodoo3，与3Dfx公司推行的策略迫使众多生产厂家投奔nVidia也不无关系，促进了TNT系列的推广。</p><p>1999年，Matrox推出 MGA G400，它拥有16Mb/32Mb的显存容量，支持AGP 2X/4X，还有支持大纹理以及32位渲染等等，独特漂亮的EMBM硬件凹凸贴图技术，营造出的完美凹凸感并能实现动态光影效果的技术，并且G400拥有优秀的DVD回放能力，只是价格有些昂贵。通过双显示控制器（被Matrox称为DualHead）驱动两台显示器的能力开始了公司的多显示器支持趋势。</p><p>1999年，nVidia终于爆发了，它在99年末推出了当前革命性的显卡—Geforce 256，彻底打败了3Dfx。代号NV10的GeForce 256支持Cube-Environment Mapping，完全的硬件T&amp;L（Transform &amp; Lighting），把原来有CPU计算的数据直接交给显示芯片处理，大大解放了CPU，也提高了芯片的运用效率。GeForce256拥有4条图形纹理通道，单周期每条通道处理两个象素纹理，工作频率120MHz，全速可以达到480Mpixels/Sec，支持SDRAM和DDR RAM，运用DDR的产品能更好的发挥GeForce256的性能。其不足之处就在于采纳使用了0.22纳米的工艺技术，发热量相对其它的来说很高的。</p><p>2000年7月，3Dfx发布的Voodoo 5引入了T-buffer技术，作为变换和照明的一种替代方法，它基本上采用了一些渲染帧并将它们聚合为一个图像的方法。这产生了稍微模糊的图片，当按帧顺序运行时，可以平滑动画的运动。</p><p>2000年末，3Dfx最终被nVidia收购。</p><h2 id=\"3d时代巅峰\">3D时代巅峰</h2><p>2000年，ATI依仗T&amp;L技术打开市场，在经历“曙光女神”的失败后，ATI推出了自己的T&amp;L芯片RADEON 256。RADEON和NVIDIA一样具有高低端的版本，完全硬件T&amp;L，Dot3和环境映射凹凸贴图，还有两条纹理流水线，可以相应情况下处理三种纹理。最出彩的是HYPER-Z技术，大大提高了RADEON显卡的3D速度，拉近了与GEFORCE 2系列的距离，ATI的显卡开始在市场占据主导地位。</p><p>2000年4月，nVidia发布了GeForce 2 GTS（GigaTexel Shader），称为Nvidia Shading Rasterizer，它允许将高光阴影，体积爆炸，折射，波浪，顶点混合，阴影体积，凹凸贴图和高程贴图等效果应用于每个像素通过硬件的基础。</p><p>2000年8月，ATI Radeon DDR上市。在卓越的T&amp;L实现和对即将推出的DirectX 8特性的支持下，Radeon DDR与GeForce 2 GTS一起，通过将对接口的支持集成到芯片本身，引入了DVI输出的使用。</p><p>2001年，nVidia推出的Geforce 3系列，这张卡成为了该领域的新王者，GeForce 3显卡增加了可编程T&amp;L功能，可以对几乎所有的画面效果提供硬件支持。GeForce 3总共具有4条像素管道，填充速率最大限度可以达到每秒钟800 Mpixels。支持DirectX 8，多重采样AA，梅花AA（基本上是2xMSAA +后期处理模糊），8x各向异性滤光以及无与伦比的处理8xAF +三线性滤光的能力以及可编程的顶点着色器，用于更紧密地控制多边形网格运动和更流畅的动画序列。还有LMA(光速内存架构)支持——基本上是Nvidia的HyperZ版本——用于剔除隐藏在屏幕上其他像素后面的像素(Z遮挡剔除)，以及压缩和解压数据以优化带宽使用(Z压缩)。最后，Nvidia实现了负载平衡算法，将其称为Crossbar内存控制器，该控制器由四个独立的内存子控制器（与行业标准的单个控制器相对）组成，从而可以更有效地路由传入的内存请求。</p><p>2001年，ATI则推出Radeon 8500/7500系列，采纳使用0.15微米工艺制造，包括6000万个晶体管，采纳使用了不少新技术(如Truform、Smartshader等)。并根据显卡的核心/显存工作频率分成不同的档次——核心/显存分别为275/550MHz的标准版，核心/显存为250/500MHz的RADEON 8500LE，生产核心/显存频率分别为300/600MHz的Ultra版，以及中端的Radeon 7500，低端的Radeon 7200，7000等产品。值得一提的是Radeon 8500还支持双头显示技术。</p><p>2002年，ATI R300 GPU发布，由最初构成ArtX核心的团队开发，交付出色。它是第一个提供DirectX 9.0支持的应用程序，并且扩展了第一个支持着色器模型2.0，顶点着色器2.0和像素着色器2.0的体系结构。</p><p>2002年，nVidia与ATI的竞争更加白热化。为巩固其图形芯片市场霸主的位，nVidia推出了Geforce 4系列，GeForce4 Ti系列择定确定是最具性能和价格比的，其代号是NV25，主要针对当时的高端图形市场，是DirectX 8时代下最劲爆强大的GPU图形处理器。芯片内部包含的晶体管数量高达6千3百万，运用0.15微米工艺生产，采纳使用了新的PBGA封装，运行频率达到了300MHz，配合频率为650MHz DDR显存，可以实现每秒49亿次的采样。GeForce4 Ti核心内建4条渲染流水线，每条流水线包含2个TMU（材质贴图单元）。Geforce 4系列从高到低，横扫了整个显卡市场。</p><p>2002年，ATI推出R9700/9000/9500系列，首次支持DirectX 9，使其在与NVidia的竞争中抢得先机。同时R9700支持AGP 8X、DirectX 9，核心频率是300MHz，显存时钟是550MHz。RADEON 9700实现了可程序化的革命性硬件架构。符合AGP 8X最新标准，配有8个平等处理的渲染管线，每秒可处理25亿个像素，4个并列的几何处理引擎能处理每秒3亿个形迹及光效多边形。R9000则面向低端的产品，R9500则对标Ti4200。</p><p>2003年的显卡市场依旧为N系与A系所统治。nVidia的Gf FX 5800（NV30）系列拥有32位着色，颜色画面有质的提高，在基础上推出的GeForce FX 5900，提高了晶体管数，降低了核心频率与显存频率，改用了256BIT DDR以提高显存带宽。</p><p>2003年7月，nVidia推出了GF FX 5950/5700系列，以取代GF FX 5900/5600。新的Detonator FX驱动程序大大改善了AA和AF。2003年9月，ATI推出了RADEON 9800/pro/SE/XT，依仗其超强的性能以及较低的售价，再次打败GF GX 5800。</p><p>2004年是ATI大放异彩的一年，其最大的功臣却是来自于面向中低端的Radeon 9550。2004年最具性能和价格比的显卡，让ATI在低端市场呼风唤雨。R9550基于RV350核心，采纳使用0.13微米制程，核心频率为250MHz，显存频率为400MHz，4条渲染管道，1个纹理单元，相应情况下兼容64bit和128bit。</p><p>2005年，Nvidia推出6000系列显卡，特性包括DirectX 9.0c支持、shader model 3.0(尽管显卡从未完全利用这一点)、Nvidia的PureVideo解码和播放引擎，以及SLI支持。</p><p>2006年10月25日，ATI被AMD收购，总价为54亿美元。</p><p>–</p><p>NVIDIA发展表：</p><p>1995年，NV1</p><pre><code>50K triangles/sec1M pixel ops/sec1M transistors16-bit colorNearest filtering</code></pre><p>1997年，Riva 128 (NV3), DX3</p><p>1998 – Riva TNT (NV4), DX5</p><pre><code>32位颜色,24位Z缓存,8位模板缓存双纹理,双线性过滤每时钟2像素 (2 ppc)</code></pre><p>1999 - GeForce 256（NV10）</p><pre><code>固定管线，支持DirectX 7.0硬件T&amp;L（Transform &amp; lighting，坐标变换和光照）立方体环境图（Cubemaps）DOT3 – bump mapping2倍各向异性过滤三线性过滤DXT纹理压缩4ppc引入“GPU”术语</code></pre><p>2001 - GeForce 3</p><pre><code>DirectX 8.0Shader Model 1.0可编程渲染管线顶点着色器像素着色器3D纹理硬件阴影图8倍各向异性过滤多采样抗锯齿（MSAA）</code></pre><p>2003 - GeForce FX系列（NV3x）</p><pre><code>DirectX 9.0Shader Model 2.0256顶点操作指令32纹理 + 64算术像素操作指令512像素操作指令着色语言：HLSL、CGSL、GLSL</code></pre><p>2004 - GeForce 6系列 (NV4x)</p><pre><code>DirectX 9.0cShader Model 3.0动态流控制分支、循环、声明等顶点纹理读取高动态范围（HDR）64位渲染纹理（Render Target）FP16*4 纹理过滤和混合</code></pre><p>2006 - GeForce 8系列 (G8x)</p><pre><code>DirectX 10.0Shader Model 4.0几何着色器（Geometry Shaders）没有上限位（No caps bits）统一的着色器（Unified Shaders）Vista系统全新驱动基于GPU计算的CUDA问世GPU计算能力以GFLOPS计量。</code></pre><p>2010 - GeForce 405（GF119）</p><pre><code>DirectX 11.0曲面细分（Tessellation）外壳着色器（Hull Shader）镶嵌单元（tessellator）域着色器（Domain Shader）计算着色器（Compute Shader）支持Stream OutputShader Model 5.0</code></pre><p>DirectX 11的渲染管线。</p><pre><code>多线程支持改进的纹理压缩</code></pre><p>Shader Model 5.0</p><pre><code>更多指令、存储单元、寄存器面向对象着色语言曲面细分计算着色器</code></pre><p>2014 - GeForceGT 710（GK208）</p><pre><code>DirectX 12.0轻量化驱动层硬件级多线程渲染支持更完善的硬件资源管理</code></pre><p>2016 - GeForceGTX 1060 6GB</p><pre><code>首次支持RTX和DXR技术，即光线追踪引入RT Core（光线追踪核心）支持RTX光线追踪的显卡列表</code></pre><p>2018 - TITAN RTX（TU102）</p><pre><code>DirectX 12.1，OpenGL 4.56GPC，36TPC，72SM，72RT Core，...8K分辨率，1770MHz主频，24G显存，384位带宽</code></pre><p>参考资料：</p><p>《GPU历史系列》</p><p>https://new.qq.com/omn/20200506/20200506A0GP6H00.html?pc</p><p>《GPU发展史》</p><p>http://www.360doc.com/content/16/0607/16/30123241_565810074.shtml</p><p>《显卡发展史1》</p><p>http://www.360doc.com/content/20/0504/17/32196507_910185372.shtml</p><p>《显卡发展史2》</p><p>http://www.360doc.com/content/20/0504/17/32196507_910185435.shtml</p><p>《显卡发展史3》</p><p>http://www.360doc.com/content/20/0504/17/32196507_910187350.shtml</p><p>《Making Sense of Smartphone Processors: The Mobile CPU/GPU Guide》</p><p>https://www.techautos.com/2010/03/14/smartphone-processor-guide/</p><p>《移动设备GPU架构知识汇总》</p><p>https://zhuanlan.zhihu.com/p/112120206</p><p>《针对移动端TBDR架构GPU特性的渲染优化》</p><p>https://gameinstitute.qq.com/community/detail/123220</p><p>《A look at the PowerVR graphics architecture: Tile-based rendering》</p><p>https://www.imaginationtech.com/blog/a-look-at-the-powervr-graphics-architecture-tile-based-rendering/</p><p>《A look at the PowerVR graphics architecture: Deferred rendering》</p><p>https://www.imaginationtech.com/blog/the-dr-in-tbdr-deferred-rendering-in-rogue/</p><p>《深入GPU硬件架构及运行机制》</p><p>https://www.cnblogs.com/timlly/p/11471507.html</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484981&amp;idx=1&amp;sn=b5199f84ed73d28916dbb9143eeeb992&amp;chksm=fc226332cb55ea2417b89e499284ab3a552ce591caba09d637912306503e4b457ed45c2e1d2d&amp;token=1023740201&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/11/08/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B048",
            
            
            
            "tags": ["读书笔记","前端技术"],
            
            "date_published": "2021-11-08T00:00:00+08:00",
            "date_modified": "2021-11-08T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/11/01/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A118",
            "title": "给女儿的信(十八) 面对困难时该如何去做",
            "summary": "女儿 教育 亲情",
            "content_text": "要点：遇到困难时，如果我们积极的去突破，则会让情况更加明朗，反之则会陷入消沉。结构：  阐述与孩子们有一样的情景  举例遇到的困难，以及自己的行动  呼吁孩子们跟我一起勇敢的面对困难大纲：  在练习演讲和表达后，自己的表达和公众说话能力有了些进步  开始原地踏步，甚至感觉有点倒退，很疑惑，也很难受  面对困难和困境的几种做法。  激励自己勇敢面对困难，积极寻找解决问题的途径和方法，专注提高解决问题的技巧。  鼓励孩子们跟我一起勇敢面对困难。内容：Hello Sharon, hello Annie.爸爸好想你们啊。爸爸喜欢你们。又到了一个月一次的视频时间了。爸爸跟你们说说爸爸最近遇到的事情好不好？最近爸爸一直在练习演讲和表达，因为爸爸发现自己在表达跟上台演讲时。表达的不够清楚，有很多紧张感。于是爸爸就找了很多的资料去练习自己的表达，以及上台说话的能力，让自己不那么紧张，在表达时也表达得更清楚一些，让别人听得更容易一些。经过一段时间的练习以后，爸爸发现自己的表达能力提升了不少。爸爸很开心，经过练习了以后，爸爸自己的说话能力提高了。然后又过了一段时间，爸爸发现爸爸在原地停了，停留了好久。甚至感觉自己的表达能力以及演讲能力有点倒退。爸爸好难受，感到很困惑，心里也很难受，爸爸。前面学习到的技巧慢慢的又退化了，又没有进步了。于是爸爸在想，其实我们生活当中常常遇到这样跟那样的困难以及阻碍。每当爸爸遇到这种困难跟阻碍的时候，我该怎么去做才能解决这个困难，才能化解现在的困境呢？爸爸想到通常我们面对困难的时候总是会选择退缩和逃避。因为每个人都害怕未知的挑战和困难。但是退缩和逃避不仅仅没有解决问题，而且让问题变得更加糟糕。于是爸爸就在想，我可不可以积极的面对困难，当困难来临时，我要主动的去寻找解决问题的方法和途径，把自己的注意力专注于解决问题的技巧。比如说爸爸最近遇到的表达上无法进步的困难。爸爸先仔细观察了自己表达上的问题，发现爸爸在说话的时候老是用喉咙和脑袋去说话，这个让爸爸感觉到自己在喉咙震动的时候脑袋也在震动，说多了就感觉自己的脑袋嗡嗡的，自己的脑袋嗡嗡的就会让自己陷入一种晕眩的状态。于是爸爸就想让在想可不可以不用喉咙去发声，不用脑袋去发声，用腹部去发声，这样的话我在说话的时候用力的是腹部，而不是脑袋和喉咙，这个让我说话变得更加的简单，更加的轻松，不必费这么大的力气。爸爸也在慢慢的练习腹部说话，练习一段时间以后吧，就会有进步，那个时候爸爸就会又开心了。雪儿跟安妮要像爸爸一样跟爸爸一起勇敢的面对困难哦，当我们面对困难时，我们要专注于寻找解决困难的途径和方法，把注意力集中在解决问题的技巧上。改善我们的技巧。寻找解决问题的途径。这样困难就变得不困难了。",
            "content_html": "<h2 id=\"要点\">要点：</h2><p>遇到困难时，如果我们积极的去突破，则会让情况更加明朗，反之则会陷入消沉。</p><h2 id=\"结构\">结构：</h2><ol>  <li>阐述与孩子们有一样的情景</li>  <li>举例遇到的困难，以及自己的行动</li>  <li>呼吁孩子们跟我一起勇敢的面对困难</li></ol><h2 id=\"大纲\">大纲：</h2><ol>  <li>在练习演讲和表达后，自己的表达和公众说话能力有了些进步</li>  <li>开始原地踏步，甚至感觉有点倒退，很疑惑，也很难受</li>  <li>面对困难和困境的几种做法。</li>  <li>激励自己勇敢面对困难，积极寻找解决问题的途径和方法，专注提高解决问题的技巧。</li>  <li>鼓励孩子们跟我一起勇敢面对困难。</li></ol><p>内容：</p><p>Hello Sharon, hello Annie.爸爸好想你们啊。爸爸喜欢你们。</p><p>又到了一个月一次的视频时间了。爸爸跟你们说说爸爸最近遇到的事情好不好？</p><p>最近爸爸一直在练习演讲和表达，因为爸爸发现自己在表达跟上台演讲时。表达的不够清楚，有很多紧张感。</p><p>于是爸爸就找了很多的资料去练习自己的表达，以及上台说话的能力，让自己不那么紧张，在表达时也表达得更清楚一些，让别人听得更容易一些。</p><p>经过一段时间的练习以后，爸爸发现自己的表达能力提升了不少。爸爸很开心，经过练习了以后，爸爸自己的说话能力提高了。</p><p>然后又过了一段时间，爸爸发现爸爸在原地停了，停留了好久。甚至感觉自己的表达能力以及演讲能力有点倒退。爸爸好难受，感到很困惑，心里也很难受，爸爸。前面学习到的技巧慢慢的又退化了，又没有进步了。</p><p>于是爸爸在想，其实我们生活当中常常遇到这样跟那样的困难以及阻碍。每当爸爸遇到这种困难跟阻碍的时候，我该怎么去做才能解决这个困难，才能化解现在的困境呢？</p><p>爸爸想到通常我们面对困难的时候总是会选择退缩和逃避。因为每个人都害怕未知的挑战和困难。</p><p>但是退缩和逃避不仅仅没有解决问题，而且让问题变得更加糟糕。</p><p>于是爸爸就在想，我可不可以积极的面对困难，当困难来临时，我要主动的去寻找解决问题的方法和途径，把自己的注意力专注于解决问题的技巧。</p><p>比如说爸爸最近遇到的表达上无法进步的困难。爸爸先仔细观察了自己表达上的问题，发现爸爸在说话的时候老是用喉咙和脑袋去说话，这个让爸爸感觉到自己在喉咙震动的时候脑袋也在震动，说多了就感觉自己的脑袋嗡嗡的，自己的脑袋嗡嗡的就会让自己陷入一种晕眩的状态。</p><p>于是爸爸就想让在想可不可以不用喉咙去发声，不用脑袋去发声，用腹部去发声，这样的话我在说话的时候用力的是腹部，而不是脑袋和喉咙，这个让我说话变得更加的简单，更加的轻松，不必费这么大的力气。</p><p>爸爸也在慢慢的练习腹部说话，练习一段时间以后吧，就会有进步，那个时候爸爸就会又开心了。</p><p>雪儿跟安妮要像爸爸一样跟爸爸一起勇敢的面对困难哦，当我们面对困难时，我们要专注于寻找解决困难的途径和方法，把注意力集中在解决问题的技巧上。改善我们的技巧。寻找解决问题的途径。这样困难就变得不困难了。</p>",
            "url": "http://www.luzexi.com/2021/11/01/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A118",
            
            
            
            
            
            "date_published": "2021-11-01T00:00:00+08:00",
            "date_modified": "2021-11-01T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/10/29/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A117",
            "title": "给女儿的信(十七) 在挫折中前进",
            "summary": "女儿 教育 亲情",
            "content_text": "Hi, Sharon Annie, 爸爸好想你。爸爸跟你们说说，爸爸最近，的学习跟工作的状况好不好？要点：爸爸最近遇到些挫折，但爸爸没有气馁，一直在想办法如何改善自己的技巧，下次不让它失败。结构：  观察到自己的表达能力比较弱  很难受也很困惑，不知道该怎么办  寻找练习的方法并练习  单一的练习方法很快无效了，寻找另一种练习方法  学习速度又变快了内容：爸爸最近遇到一些挫折，爸爸没有气馁，一直在想办法，怎么去完善自己的技巧，来让这个事情进行的更顺利一些。爸爸观察到自己的表达能力比较弱。观察到自己的在表达的时候的逻辑不是非常清晰，再跟别人讲事情或者说我想表达我的意思的时候，别人经常听不懂我在讲什么，或者说要听好几遍才能听明白。甚至有时候，别人听了好几遍，也没有听明白，但是假装明白了，最后把事情搞得很糟糕。所以，爸爸想改进一下自己的表达能力，希望自己在跟别人说话的时候，能够更清楚的表达爸爸的想说的意思。爸爸有时候会讲故事给别人听。其实讲故事里有很多的技巧，爸爸对于这些技桥都不太了解，所以爸爸在跟别人讲故事的时候，我发现讲的不清楚也不精彩，原本一个很好的故事，被爸爸讲的非常烂。于是爸爸很困惑，很难受。我想清楚的表达自己的意思，也很想把故事讲好，把故事讲得更有趣。爸爸就从平常的练习开始寻找方法，我在每天的打卡中加入了一个练习，想在平时每天都练习一下，如何说好一个故事，如何去表达的更清楚。爸爸每天早上都给自己布置一个任务，练习绕口令，练习发音。绕口令和发音是嘴巴的肌肉最基础的运动部分，爸爸希望自己在嘴巴的肌肉上能够运用的更好一些。在这样不断的练习过程当中，爸爸进步速度不是非常快。这个让爸爸受到很大的挫折感，爸爸花了很多时间去练习，但是效果不好，爸爸很难受啊。于是爸爸想办法在改进练习的方式，因为爸爸知道只有改进了练习的方式才能让练习的效果更好，让爸爸的练习效率更高。于是爸爸换了几种方法，第1种方法是爸爸有目标的去练习，比如说，爸爸想先把自己的，嗯啊这个词这个发音给去掉，因为爸爸在说话的时候经常会说啊额嗯、这个、然后、这些、那些等等。爸爸想把这些填充词给去掉，称它为哼哈词。做的第1步目标就是把这些填充词，在说话的时候去掉，用别的方式去代替，爸爸用沉默的方式去代替这些词语，当爸爸想发，嗯跟R的时候，想说然后、这个、那个时，用沉默去代替。爸爸发现练习了一段时间以后有比较大的效果，很开心。接着，练习着练习着，爸爸又遇到了瓶瓶颈。第1种练习方式，变得没有效果了，又变得低效了。于是爸爸又换了一种方法。第2种方法，爸爸想让自己说话的语气放慢一些，这样爸爸说话的时候，别人接受到的信息就会更清楚一些，也能听得更懂一些。于是爸爸就每天跟自己说话，并且跟自己说话的时候给自己定一个主题。比如爸爸想说今天学习到了新的知识，我把学习到的新知识说给别人听，在说话的时候，我要故意放慢语气，慢慢说慢慢说，慢慢说的时候对方也接收的也很一些。就这样爸爸，每天想一个主题，围绕这个主题去说自己的故事，在说故事的时候让自己的语速放慢一些。过了一段时间，真的起了效果，爸爸的表达能力越来越好了，很开心噢。不断的更换方法去练习，去有目标的练习自己的技能。当我发现遇到瓶颈的时候去主动更换练习方式，这让爸爸的学习效率很高，提升的效果也非常好。爸爸很开心，在这样不断更换练习方式的过程当中，爸爸的学习能力越来越强了，学习速度也越来越快了，学习效率越来越高了，爸爸很开心哦，希望Sharon跟安妮，也跟爸爸一样，当发现自己的进步少的时候主动去更换自己的练习方式，当你发现自己的练习方式进步速度比较慢时，可能是因为你的练习方式有问题哦。爸爸爱你们哦，爸爸喜欢你们，爸爸爱你们，我们来一起加油。",
            "content_html": "<p>Hi, Sharon Annie, 爸爸好想你。</p><p>爸爸跟你们说说，爸爸最近，的学习跟工作的状况好不好？</p><h2 id=\"要点\">要点：</h2><p>爸爸最近遇到些挫折，但爸爸没有气馁，一直在想办法如何改善自己的技巧，下次不让它失败。</p><h2 id=\"结构\">结构：</h2><ol>  <li>观察到自己的表达能力比较弱</li>  <li>很难受也很困惑，不知道该怎么办</li>  <li>寻找练习的方法并练习</li>  <li>单一的练习方法很快无效了，寻找另一种练习方法</li>  <li>学习速度又变快了</li></ol><h2 id=\"内容\">内容：</h2><p>爸爸最近遇到一些挫折，爸爸没有气馁，一直在想办法，怎么去完善自己的技巧，来让这个事情进行的更顺利一些。</p><p>爸爸观察到自己的表达能力比较弱。观察到自己的在表达的时候的逻辑不是非常清晰，再跟别人讲事情或者说我想表达我的意思的时候，别人经常听不懂我在讲什么，或者说要听好几遍才能听明白。</p><p>甚至有时候，别人听了好几遍，也没有听明白，但是假装明白了，最后把事情搞得很糟糕。</p><p>所以，爸爸想改进一下自己的表达能力，希望自己在跟别人说话的时候，能够更清楚的表达爸爸的想说的意思。</p><p>爸爸有时候会讲故事给别人听。其实讲故事里有很多的技巧，爸爸对于这些技桥都不太了解，所以爸爸在跟别人讲故事的时候，我发现讲的不清楚也不精彩，原本一个很好的故事，被爸爸讲的非常烂。</p><p>于是爸爸很困惑，很难受。我想清楚的表达自己的意思，也很想把故事讲好，把故事讲得更有趣。</p><p>爸爸就从平常的练习开始寻找方法，我在每天的打卡中加入了一个练习，想在平时每天都练习一下，如何说好一个故事，如何去表达的更清楚。</p><p>爸爸每天早上都给自己布置一个任务，练习绕口令，练习发音。绕口令和发音是嘴巴的肌肉最基础的运动部分，爸爸希望自己在嘴巴的肌肉上能够运用的更好一些。</p><p>在这样不断的练习过程当中，爸爸进步速度不是非常快。这个让爸爸受到很大的挫折感，爸爸花了很多时间去练习，但是效果不好，爸爸很难受啊。</p><p>于是爸爸想办法在改进练习的方式，因为爸爸知道只有改进了练习的方式才能让练习的效果更好，让爸爸的练习效率更高。</p><p>于是爸爸换了几种方法，第1种方法是爸爸有目标的去练习，比如说，爸爸想先把自己的，嗯啊这个词这个发音给去掉，因为爸爸在说话的时候经常会说啊额嗯、这个、然后、这些、那些等等。爸爸想把这些填充词给去掉，称它为哼哈词。</p><p>做的第1步目标就是把这些填充词，在说话的时候去掉，用别的方式去代替，爸爸用沉默的方式去代替这些词语，当爸爸想发，嗯跟R的时候，想说然后、这个、那个时，用沉默去代替。</p><p>爸爸发现练习了一段时间以后有比较大的效果，很开心。</p><p>接着，练习着练习着，爸爸又遇到了瓶瓶颈。第1种练习方式，变得没有效果了，又变得低效了。</p><p>于是爸爸又换了一种方法。第2种方法，爸爸想让自己说话的语气放慢一些，这样爸爸说话的时候，别人接受到的信息就会更清楚一些，也能听得更懂一些。</p><p>于是爸爸就每天跟自己说话，并且跟自己说话的时候给自己定一个主题。比如爸爸想说今天学习到了新的知识，我把学习到的新知识说给别人听，在说话的时候，我要故意放慢语气，慢慢说慢慢说，慢慢说的时候对方也接收的也很一些。</p><p>就这样爸爸，每天想一个主题，围绕这个主题去说自己的故事，在说故事的时候让自己的语速放慢一些。</p><p>过了一段时间，真的起了效果，爸爸的表达能力越来越好了，很开心噢。</p><p>不断的更换方法去练习，去有目标的练习自己的技能。当我发现遇到瓶颈的时候去主动更换练习方式，这让爸爸的学习效率很高，提升的效果也非常好。</p><p>爸爸很开心，在这样不断更换练习方式的过程当中，爸爸的学习能力越来越强了，学习速度也越来越快了，学习效率越来越高了，爸爸很开心哦，希望Sharon跟安妮，也跟爸爸一样，当发现自己的进步少的时候主动去更换自己的练习方式，当你发现自己的练习方式进步速度比较慢时，可能是因为你的练习方式有问题哦。</p><p>爸爸爱你们哦，爸爸喜欢你们，爸爸爱你们，我们来一起加油。</p>",
            "url": "http://www.luzexi.com/2021/10/29/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A117",
            
            
            
            
            
            "date_published": "2021-10-29T00:00:00+08:00",
            "date_modified": "2021-10-29T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/10/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B047",
            "title": "读书笔记(四十七) 《游戏引擎架构》#4 低阶渲染器（1）",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：作为游戏开发从业者，从业务到语言到框架到引擎，积累了一些知识和经验，特别是在看了几遍《游戏引擎架构》后对引擎架构的理解又深入了些。近段时间有对引擎剖析的想法，正好借这书本对游戏引擎架构做一个完整分析。此书用简明、清楚的方式覆盖了游戏引擎架构的庞大领域，巧妙地平衡了广度与深度，并且提供了足够的细节。我将借助《游戏引擎架构》这本书、结合引擎源码和自己的经验，深入分析游戏引擎的历史、架构、模块，最后通过实践简单引擎开发来完成对引擎知识的掌握。游戏引擎知识面深而广，所以对这系列的文章书编写范围做个保护，即不对细节进行过多的阐述，重点剖析的是架构、流程以及模块的运作原理。同时《游戏引擎架构》中部分知识太过陈旧的部分，会重新深挖后总结出自己的观点。概述：本系列文章对引擎中的重要的模块和库进行详细的分析，我挑选了十五个库和模块来分析：  时间库  自定义容器库  字符串散列库  内存管理框架  RTTI与反射模块  图形计算库  资产管理模块  低阶渲染器  剔除与合批模块  动画模块  物理模块  UI底层框架  性能剖析器的核心部分  脚本系统  视觉效果模块本篇内容为列表中的第8个部分。正文：简单回顾下前文前文简单提了下C++编译过程、C++内存布局、文件内核读取原理、图形计算的常用库内容，以及大篇幅的引擎资产管理。引擎资产管理简单回顾下：首先，资产分为DCC资产、中间格式资产、引擎资产，这三者是从制作到导入到使用的顺序。其次，引擎资产分为元数据和引擎资产文件，引擎不仅需要资产也需要资产的配置数据。接着，引擎内存中的资产有资源映射关系，资产路径、资产GUID、资产实例、资产实例ID。最后，引擎通常都有资源包，资源包的格式通常都差不多，头信息（包括索引信息和数据概要信息）+数据文件，压缩可以是整体压缩也可以是每个独立数据单独压缩，通过解剖资源包的数据格式，我们可以知道如何去做差量更新。这里补充一点，引擎在读取资产时，与读取资产配置的原理是一样的，它可以有自己的数据格式也可以用标准格式，引擎通常使用自定义格式。通过区分读取不同类型的资产数据来实例化引擎内不同的资源对象，包括网格、材质、动画、粒子、节点、组件配置等。下面我们开始这篇内容本次内容会围绕GPU来写，从硬件架构到软件驱动再到引擎架构，目标是帮大家理解GPU硬件的运作原理，理解图形接口的架构，理解引擎低阶渲染器的架构。目录：  主板结构中的显卡  GPU功能发展史  GPU与CPU的差异  GPU硬件特点  图形驱动程序架构  引擎低阶渲染架构主板结构中的显卡我们讨论GPU和显卡时经常混为一谈，严格来说GPU是显卡（Video card、Display card、Graphics card）最核心的部件。显卡除了GPU，还有扇热器、通讯元件、与主板和显示器连接的各类插槽。图1（主板结构图）早期计算机设备中的CPU都是由系统总线来与所有其他设备通信，当图形芯片需要跟CPU和内存大量交换数据时就出现了巨大瓶颈，于是人们设计了高速的北桥芯片和低速的南桥芯片，一来协调CPU、内存、图形设备之间的高速通信，二来专门处理磁盘、USB、键盘鼠标等低速设备。从上图中我们看到，离CPU越近，存取数据越快，最近的就是CPU内的组件了，其次是高速缓存总线，再是本地总线，接着是内存总线，最后是高速总线。我们的GPU被安排在高速总线上，而且总线还有其他设备需要兼顾。因此从通信速度上来说，高速总线并不是那么快，这也是CPU与GPU的通信带宽通常成为瓶颈的其中一个原因。图1（现实中主板结构图：图片来自网络）这里重点介绍下北桥芯片，一个主板上最重要的部分可以说就是主板的芯片组了，主板的芯片组一般由北桥芯片和南桥芯片组成，两者共同组成主板的芯片组。北桥芯片主要负责实现与CPU、内存、AGP接口之间的数据传输，同时还通过特定的数据通道和南桥芯片相连接。南桥芯片主要负责和IDE设备、PCI设备、声音设备、网络设备以及其他的I/O设备的通信。主板和CPU发展都现在，北桥芯片慢慢开始消失被集成了CPU中。往后发展，主板芯片组可以看成是以往南桥芯片组的加强版，CPU与主板芯片采用DMI总线进行通信。虽然从Lynnfield Core i5/i7开始把北桥集成到CPU上，但是其内部仍是采用QPI总线来通讯，而外部与主板芯片组通讯，其实就是以往主板上南桥与北桥通讯，采用的是DMI总线。因此不能说Lynnfield Core i5/i7是精简了，只是集成度更高而已。手机主板结构与PC不同以下图片均来源网络图1图2图3图4手机的主板布局则不同，由于主板不能横向扩展，所以采用双或三层叠层的主板，GPU内嵌在处理器上与CPU同框，且它们周围布满了内存，这样通信更快。同时由于空间小，功率和高速缓存大小也受到限制。多层主板虽然看上去设计巧妙，同时也将几个发热大户都贴在了一起，发热量和速度加倍。现代CPU都有一种过热自动降频或者关闭核心的保护措施，因此当玩王者或吃鸡等大型游戏时，就会因为发热而导致它更快的达到阈值温度而降频，这也是很多游戏优化后仍然会卡顿的主要原因。因此很多手机引入了水冷（热导管技术）CPU散热技术，用超大一块热导管来散热降温，让CPU不会因为过热而降频或锁核，从而能更长时间甚至全时运行在最大工作频率上，从而发挥出手机宣传时100%的性能。已发布在微信公众号上，点击跳转参考资料：《主板北桥百科》https://baike.baidu.com/item/%E4%B8%BB%E6%9D%BF%E5%8C%97%E6%A1%A5/10252486?fr=aladdin《总线百科》https://baike.baidu.com/item/%E6%80%BB%E7%BA%BF/108823《iPhone 11/Pro Max内部结构示意图》http://www.itqianyan.com/m/view.php?aid=5479《拆解 iPhone 12 系列》https://www.igao7.com/news/202010/L2RP34HNtTEZ2yYC.html《iPhone 8和X拆解》https://m.iphonediule.com/hot/qiangxian.html",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484964&amp;idx=1&amp;sn=99fd35baa5ad829cbae99753f14aa64b&amp;chksm=fc226323cb55ea3598d74dd2508841f01e149176b2c857c54c077a2d8a3f493033ce8f57b56f&amp;token=1534435063&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h2 id=\"背景\">背景：</h2><p>作为游戏开发从业者，从业务到语言到框架到引擎，积累了一些知识和经验，特别是在看了几遍《游戏引擎架构》后对引擎架构的理解又深入了些。</p><p>近段时间有对引擎剖析的想法，正好借这书本对游戏引擎架构做一个完整分析。</p><p>此书用简明、清楚的方式覆盖了游戏引擎架构的庞大领域，巧妙地平衡了广度与深度，并且提供了足够的细节。</p><p>我将借助《游戏引擎架构》这本书、结合引擎源码和自己的经验，深入分析游戏引擎的历史、架构、模块，最后通过实践简单引擎开发来完成对引擎知识的掌握。</p><p>游戏引擎知识面深而广，所以对这系列的文章书编写范围做个保护，即不对细节进行过多的阐述，重点剖析的是架构、流程以及模块的运作原理。</p><p>同时《游戏引擎架构》中部分知识太过陈旧的部分，会重新深挖后总结出自己的观点。</p><h2 id=\"概述\">概述：</h2><p>本系列文章对引擎中的重要的模块和库进行详细的分析，我挑选了十五个库和模块来分析：</p><ol>  <li>时间库</li>  <li>自定义容器库</li>  <li>字符串散列库</li>  <li>内存管理框架</li>  <li>RTTI与反射模块</li>  <li>图形计算库</li>  <li>资产管理模块</li>  <li>低阶渲染器</li>  <li>剔除与合批模块</li>  <li>动画模块</li>  <li>物理模块</li>  <li>UI底层框架</li>  <li>性能剖析器的核心部分</li>  <li>脚本系统</li>  <li>视觉效果模块</li></ol><p>本篇内容为列表中的第8个部分。</p><h2 id=\"正文\">正文：</h2><p>简单回顾下前文</p><p>前文简单提了下C++编译过程、C++内存布局、文件内核读取原理、图形计算的常用库内容，以及大篇幅的引擎资产管理。</p><p>引擎资产管理简单回顾下：</p><p>首先，资产分为DCC资产、中间格式资产、引擎资产，这三者是从制作到导入到使用的顺序。</p><p>其次，引擎资产分为元数据和引擎资产文件，引擎不仅需要资产也需要资产的配置数据。</p><p>接着，引擎内存中的资产有资源映射关系，资产路径、资产GUID、资产实例、资产实例ID。</p><p>最后，引擎通常都有资源包，资源包的格式通常都差不多，头信息（包括索引信息和数据概要信息）+数据文件，压缩可以是整体压缩也可以是每个独立数据单独压缩，通过解剖资源包的数据格式，我们可以知道如何去做差量更新。</p><p>这里补充一点，引擎在读取资产时，与读取资产配置的原理是一样的，它可以有自己的数据格式也可以用标准格式，引擎通常使用自定义格式。通过区分读取不同类型的资产数据来实例化引擎内不同的资源对象，包括网格、材质、动画、粒子、节点、组件配置等。</p><h3 id=\"下面我们开始这篇内容\">下面我们开始这篇内容</h3><p>本次内容会围绕GPU来写，从硬件架构到软件驱动再到引擎架构，目标是帮大家理解GPU硬件的运作原理，理解图形接口的架构，理解引擎低阶渲染器的架构。</p><h2 id=\"目录\">目录：</h2><ol>  <li>主板结构中的显卡</li>  <li>GPU功能发展史</li>  <li>GPU与CPU的差异</li>  <li>GPU硬件特点</li>  <li>图形驱动程序架构</li>  <li>引擎低阶渲染架构</li></ol><h2 id=\"主板结构中的显卡\">主板结构中的显卡</h2><p>我们讨论GPU和显卡时经常混为一谈，严格来说GPU是显卡（Video card、Display card、Graphics card）最核心的部件。显卡除了GPU，还有扇热器、通讯元件、与主板和显示器连接的各类插槽。</p><p>图1</p><p>（主板结构图）</p><p>早期计算机设备中的CPU都是由系统总线来与所有其他设备通信，当图形芯片需要跟CPU和内存大量交换数据时就出现了巨大瓶颈，于是人们设计了高速的北桥芯片和低速的南桥芯片，一来协调CPU、内存、图形设备之间的高速通信，二来专门处理磁盘、USB、键盘鼠标等低速设备。</p><p>从上图中我们看到，离CPU越近，存取数据越快，最近的就是CPU内的组件了，其次是高速缓存总线，再是本地总线，接着是内存总线，最后是高速总线。我们的GPU被安排在高速总线上，而且总线还有其他设备需要兼顾。因此从通信速度上来说，高速总线并不是那么快，这也是CPU与GPU的通信带宽通常成为瓶颈的其中一个原因。</p><p>图1</p><p>（现实中主板结构图：图片来自网络）</p><p>这里重点介绍下北桥芯片，一个主板上最重要的部分可以说就是主板的芯片组了，主板的芯片组一般由北桥芯片和南桥芯片组成，两者共同组成主板的芯片组。北桥芯片主要负责实现与CPU、内存、AGP接口之间的数据传输，同时还通过特定的数据通道和南桥芯片相连接。南桥芯片主要负责和IDE设备、PCI设备、声音设备、网络设备以及其他的I/O设备的通信。</p><p>主板和CPU发展都现在，北桥芯片慢慢开始消失被集成了CPU中。往后发展，主板芯片组可以看成是以往南桥芯片组的加强版，CPU与主板芯片采用DMI总线进行通信。</p><p>虽然从Lynnfield Core i5/i7开始把北桥集成到CPU上，但是其内部仍是采用QPI总线来通讯，而外部与主板芯片组通讯，其实就是以往主板上南桥与北桥通讯，采用的是DMI总线。因此不能说Lynnfield Core i5/i7是精简了，只是集成度更高而已。</p><h3 id=\"手机主板结构与pc不同\">手机主板结构与PC不同</h3><p>以下图片均来源网络</p><p>图1</p><p>图2</p><p>图3</p><p>图4</p><p>手机的主板布局则不同，由于主板不能横向扩展，所以采用双或三层叠层的主板，GPU内嵌在处理器上与CPU同框，且它们周围布满了内存，这样通信更快。同时由于空间小，功率和高速缓存大小也受到限制。</p><p>多层主板虽然看上去设计巧妙，同时也将几个发热大户都贴在了一起，发热量和速度加倍。</p><p>现代CPU都有一种过热自动降频或者关闭核心的保护措施，因此当玩王者或吃鸡等大型游戏时，就会因为发热而导致它更快的达到阈值温度而降频，这也是很多游戏优化后仍然会卡顿的主要原因。</p><p>因此很多手机引入了水冷（热导管技术）CPU散热技术，用超大一块热导管来散热降温，让CPU不会因为过热而降频或锁核，从而能更长时间甚至全时运行在最大工作频率上，从而发挥出手机宣传时100%的性能。</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484964&amp;idx=1&amp;sn=99fd35baa5ad829cbae99753f14aa64b&amp;chksm=fc226323cb55ea3598d74dd2508841f01e149176b2c857c54c077a2d8a3f493033ce8f57b56f&amp;token=1534435063&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h2 id=\"参考资料\">参考资料：</h2><p>《主板北桥百科》</p><p>https://baike.baidu.com/item/%E4%B8%BB%E6%9D%BF%E5%8C%97%E6%A1%A5/10252486?fr=aladdin</p><p>《总线百科》</p><p>https://baike.baidu.com/item/%E6%80%BB%E7%BA%BF/108823</p><p>《iPhone 11/Pro Max内部结构示意图》</p><p>http://www.itqianyan.com/m/view.php?aid=5479</p><p>《拆解 iPhone 12 系列》</p><p>https://www.igao7.com/news/202010/L2RP34HNtTEZ2yYC.html</p><p>《iPhone 8和X拆解》</p><p>https://m.iphonediule.com/hot/qiangxian.html</p>",
            "url": "http://www.luzexi.com/2021/10/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B047",
            
            
            
            "tags": ["读书笔记","前端技术"],
            
            "date_published": "2021-10-26T00:00:00+08:00",
            "date_modified": "2021-10-26T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/10/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B046",
            "title": "读书笔记(四十六) 《如何精彩演讲》#1 演讲的结构",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景不知不觉看完了6本关于演讲的主题，按推荐顺序排列分别是《高效演讲》、《演讲与口才》、《即兴演讲》、《关键对话》、《TED演讲的力量》、《说话的艺术》。我希望自己能够对演讲有一个系统性的学习。于是自己在平常的生活和工作中实践了一段时间，前前后后加起来有两个月时间。目标是，改善平常的工作、生活中表达的流畅和清晰度，能让人感觉到舒服让人感觉有活力。同时在公众演讲上，希望自己能够很好的呈现自己的所思所想以及所知所学。因此开启这个演讲学习系列的总结文章，我将对这6本书的内容加上我的实践经验做一次全面的系统性的总结。内容这一篇主要讲演讲的结构。一场演讲分为三个部分：第1个部分是，开场。第2个部分是，核心内容。第3个部分是，收尾。这三个部分都有各自的技巧，而此篇主要来说说具体的演讲内容中的其中一点，即演讲结构。首先来说一下为什么我们需要结构？我们在平常的表达过程当中，一般是不会去刻意在意逻辑。因此，我们在表述过程当中通常是按照时间线来进行表述。表达过程当中，通常只是说出了自己脑中不断冒出的想法。在这样的表达下，对方是很难get到我们想要说的内容的。一旦我们说的内容稍微多一些时，对方很容易进入完全听不懂我们在说了什么情况。那么如何才能让对方听清楚，听明白，听得懂我们在说什么呢？我们就得用演讲结构去规范我们的演讲内容，让我们的演讲内容能够更清晰的呈现在听众的脑中，让脑袋更容易去记住我们的要点以及中心思想。那什么才是好的演讲结构呢？首先演讲的内容必须围绕着一个中心思想去讲。如果中心思想太多，很难让听众记得住，就不会是一个好的演讲。因此一个演讲最好只有一个中心思想。中心思想最好是能引起观众共鸣的。（在后面的内容中再讲如何让中心思想引起共鸣）其次你的演讲内容要有层次感。在我们表达时最好有意识的按简单顺序进行表达，这样听众们的大脑才能记得住。比如第一第二第三；过去现在未来；昨天，今天，明天；最重要其次最后等等。除了这种层次方式，还有另一种方式，即故事方式。（后面的文章中再解剖如何讲好一个故事）这里先简单介绍一下一个好故事设计要有4个部分，情景带入、遇到危机、冲突和转折、大好结局。除了设计故事内容还要注意好故事有4个要点，篇幅小、通俗易懂、简单容易记、有共鸣。接着你的演讲内容，最好以总分总的形式去部署。即提出观点、剖析观点、总结观点。在开头时阐述演讲要点，结尾时进行要点总结，中间内容分成三个论点，每个论点都由三个句子组成演讲结构。这样的演讲结构即“1-3-3-3-1”形式组成的结构，让人听了更舒服也更容易记得住。最后在你平时的讲话和沟通表达的过程中，有意识的将自己说话的内容以层次感的形式表现出来。一开始你可以在讲话前先先打好附稿或准备稿，按123规律来讲，注意不要把第3点和第1点说重复了。经过长时间的练习，你可以自如的应对各种各样的演讲模式以及各种各样的即兴发挥。那么怎样才能“练”好演讲结构呢？这里给出三个要点。第一，每次讲话前先打好腹稿再开口。为每次的公众演讲以及平时的沟通交流都打好腹稿，这是一种非常好的练习方式。这让你时时刻刻提醒自己，在讲话时要有层次感，将这种方法印刻在脑海里，形成肌肉记忆。时间长了，你自然而然就有了说话的层次感，形成了强有力的肌肉记忆。第二，多上台，多在台上运用演讲层次结构。台上的感觉和台下的感觉是完全不同的。在台上你会更加紧张，也更加容易出错，同时更加在意别人对你的看法，也更加害怕。多上台，多在台上运用演讲的层次结构，会让你在面对陌生场合，在面对激烈、紧张、恐惧时，也能够自如的运用层次感肌肉记忆，让演讲内容流畅清晰的表达出来。第三，发现生活中的主题进行层次训练。生活和工作中，周围每天都会发生很多的事情，我们可以通过仔细观察我们生活当中发生的事情，叙述或表达我们的观点。表达时运用层次结构去跟自己对话，这样的训练每天都可以进行，有助于我们更快更好的形成肌肉记忆。最后告诉大家，如何获得练习反馈。这里有三个方法告诉大家。1.录制后自我复盘。我们演讲的反馈可以通过自己录制视频，录制音频后进行复听来复盘自己的演讲。2.通过他人获得评价。可以通过同事、朋友、家人、以及专门演讲圈的人对自己的评价来复盘自己的演讲，从而获得自己改进的方向。但要注意，别人对你的负面评价要小心。通常那些不专业的人给你的评价，都是打击你自信心的一个常见途径。我们需要的是鼓励，而不是打击。鼓励让我们更有动力前进。而打击则适得其反。3.通过专业演讲训练师来反馈。最好是通过专业的演讲导师来纠正你的演讲问题，从而给予你正确的演讲练习方式和修正方向。已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484952&amp;idx=1&amp;sn=aa014404eb8b71222820f1f3bbff437e&amp;chksm=fc22631fcb55ea0981c20cab77f66da58a2697ab2e8a792f4b4c6ba15a3bc6b57dd2ba7309a1&amp;token=1211671052&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h1 id=\"背景\">背景</h1><p>不知不觉看完了6本关于演讲的主题，按推荐顺序排列分别是《高效演讲》、《演讲与口才》、《即兴演讲》、《关键对话》、《TED演讲的力量》、《说话的艺术》。</p><p>我希望自己能够对演讲有一个系统性的学习。于是自己在平常的生活和工作中实践了一段时间，前前后后加起来有两个月时间。</p><p>目标是，改善平常的工作、生活中表达的流畅和清晰度，能让人感觉到舒服让人感觉有活力。同时在公众演讲上，希望自己能够很好的呈现自己的所思所想以及所知所学。</p><p>因此开启这个演讲学习系列的总结文章，我将对这6本书的内容加上我的实践经验做一次全面的系统性的总结。</p><h1 id=\"内容\">内容</h1><p>这一篇主要讲演讲的结构。</p><p>一场演讲分为三个部分：</p><p>第1个部分是，开场。第2个部分是，核心内容。第3个部分是，收尾。</p><p>这三个部分都有各自的技巧，而此篇主要来说说具体的演讲内容中的其中一点，即演讲结构。</p><h2 id=\"首先来说一下为什么我们需要结构\">首先来说一下为什么我们需要结构？</h2><p>我们在平常的表达过程当中，一般是不会去刻意在意逻辑。因此，我们在表述过程当中通常是按照时间线来进行表述。表达过程当中，通常只是说出了自己脑中不断冒出的想法。在这样的表达下，对方是很难get到我们想要说的内容的。一旦我们说的内容稍微多一些时，对方很容易进入完全听不懂我们在说了什么情况。</p><p>那么如何才能让对方听清楚，听明白，听得懂我们在说什么呢？</p><p>我们就得用演讲结构去规范我们的演讲内容，让我们的演讲内容能够更清晰的呈现在听众的脑中，让脑袋更容易去记住我们的要点以及中心思想。</p><h2 id=\"那什么才是好的演讲结构呢\">那什么才是好的演讲结构呢？</h2><p>首先演讲的内容必须围绕着一个中心思想去讲。如果中心思想太多，很难让听众记得住，就不会是一个好的演讲。因此一个演讲最好只有一个中心思想。中心思想最好是能引起观众共鸣的。（在后面的内容中再讲如何让中心思想引起共鸣）</p><p>其次你的演讲内容要有层次感。</p><p>在我们表达时最好有意识的按简单顺序进行表达，这样听众们的大脑才能记得住。比如第一第二第三；过去现在未来；昨天，今天，明天；最重要其次最后等等。</p><p>除了这种层次方式，还有另一种方式，即故事方式。（后面的文章中再解剖如何讲好一个故事）</p><p>这里先简单介绍一下一个好故事设计要有4个部分，情景带入、遇到危机、冲突和转折、大好结局。</p><p>除了设计故事内容还要注意好故事有4个要点，篇幅小、通俗易懂、简单容易记、有共鸣。</p><p>接着你的演讲内容，最好以总分总的形式去部署。即提出观点、剖析观点、总结观点。在开头时阐述演讲要点，结尾时进行要点总结，中间内容分成三个论点，每个论点都由三个句子组成演讲结构。</p><p>这样的演讲结构即“1-3-3-3-1”形式组成的结构，让人听了更舒服也更容易记得住。</p><p>最后在你平时的讲话和沟通表达的过程中，有意识的将自己说话的内容以层次感的形式表现出来。一开始你可以在讲话前先先打好附稿或准备稿，按123规律来讲，注意不要把第3点和第1点说重复了。经过长时间的练习，你可以自如的应对各种各样的演讲模式以及各种各样的即兴发挥。</p><h2 id=\"那么怎样才能练好演讲结构呢\">那么怎样才能“练”好演讲结构呢？</h2><p>这里给出三个要点。</p><p>第一，每次讲话前先打好腹稿再开口。</p><p>为每次的公众演讲以及平时的沟通交流都打好腹稿，这是一种非常好的练习方式。这让你时时刻刻提醒自己，在讲话时要有层次感，将这种方法印刻在脑海里，形成肌肉记忆。时间长了，你自然而然就有了说话的层次感，形成了强有力的肌肉记忆。</p><p>第二，多上台，多在台上运用演讲层次结构。</p><p>台上的感觉和台下的感觉是完全不同的。在台上你会更加紧张，也更加容易出错，同时更加在意别人对你的看法，也更加害怕。多上台，多在台上运用演讲的层次结构，会让你在面对陌生场合，在面对激烈、紧张、恐惧时，也能够自如的运用层次感肌肉记忆，让演讲内容流畅清晰的表达出来。</p><p>第三，发现生活中的主题进行层次训练。</p><p>生活和工作中，周围每天都会发生很多的事情，我们可以通过仔细观察我们生活当中发生的事情，叙述或表达我们的观点。表达时运用层次结构去跟自己对话，这样的训练每天都可以进行，有助于我们更快更好的形成肌肉记忆。</p><h2 id=\"最后告诉大家如何获得练习反馈\">最后告诉大家，如何获得练习反馈。</h2><p>这里有三个方法告诉大家。</p><p>1.录制后自我复盘。</p><p>我们演讲的反馈可以通过自己录制视频，录制音频后进行复听来复盘自己的演讲。</p><p>2.通过他人获得评价。</p><p>可以通过同事、朋友、家人、以及专门演讲圈的人对自己的评价来复盘自己的演讲，从而获得自己改进的方向。</p><p>但要注意，别人对你的负面评价要小心。通常那些不专业的人给你的评价，都是打击你自信心的一个常见途径。我们需要的是鼓励，而不是打击。鼓励让我们更有动力前进。而打击则适得其反。</p><p>3.通过专业演讲训练师来反馈。</p><p>最好是通过专业的演讲导师来纠正你的演讲问题，从而给予你正确的演讲练习方式和修正方向。</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484952&amp;idx=1&amp;sn=aa014404eb8b71222820f1f3bbff437e&amp;chksm=fc22631fcb55ea0981c20cab77f66da58a2697ab2e8a792f4b4c6ba15a3bc6b57dd2ba7309a1&amp;token=1211671052&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/10/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B046",
            
            
            
            
            
            "date_published": "2021-10-17T00:00:00+08:00",
            "date_modified": "2021-10-17T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/10/12/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A866",
            "title": "思路探讨(六十六) 人和事",
            "summary": "思路 随想 理念 逻辑 人生哲学",
            "content_text": "已发布在微信公众号上，点击跳转有两周时间没有发文章了，最近有些忙，自己也遇到了瓶颈，正在突破。前几个月发现我的表达能力有些弱，表达逻辑混乱，表达时没有自信。所以呢，我特别花了一些精力去加强这方面的训练。自己做了一些训练，去演讲俱乐部练习演讲，去读书聚会的地方做演讲，以及做主持人的表达工作。我希望通过这样的锻炼，提升表达能力。也看了几本书，暂时还没有去总结它们，希望后面能够挤出时间来写些关于这个主题书的读书总结。为什么要去做沟通跟表达演讲的训练呢？我内心声音是，我要解决人与人之间的关系，人与人之间的沟通。前面10几年都在做练习解决事情的技巧，比如我要写好程序，写书，写文章，都是去总结一些解决事情的经验。不管是程序还是项目还是工作分配工作拆解，都是需要我们去解决事情。这是我前面12年做的事情。我最近领悟到，其实解决事情只占了30%的部分，剩余的70%的部分并不是靠解决事情来解决的，而是靠做人，解决人与人之间关系来搞定的。一个典型的例子，在工作当中如果我们跟上级相处不好的话，跟家人的关系不好，你即使把成绩做出来了，也得不到家人的肯定，和领导的赏识，这对我们的感受有巨大影响，甚至会有强烈的挫败感。因此现阶段的我认为，解决人与人之间的关系比解决事情更重要。最重要的其实不是事情本身，而是与事情有关的人，这些人才是关键。例如事情提出的人是领导，或与事件有关的人是同事，在他们提出问题时，先确立这是不是个事实。我相信大部分时候是事实，也可能是被夸大的事实。当我们去做事时，其实应该首先跟他们聊一聊，跟老板聊一聊，跟这些部门的人来聊一聊，这样的才能体会到对方的感受，以及看到对方究竟想要的。跟人联系、寒暄后，才能知道对方的情绪、想法、需要，这时再想办法来解决问题已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484939&amp;idx=1&amp;sn=e3df251c9cb4733784e5df9ccd21e3ab&amp;chksm=fc22630ccb55ea1a27f035c062122bf9e40a504d0dac7143b0a383b4f7dc729dc8596cc10958&amp;token=254199611&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><p>有两周时间没有发文章了，最近有些忙，自己也遇到了瓶颈，正在突破。</p><p>前几个月发现我的表达能力有些弱，表达逻辑混乱，表达时没有自信。</p><p>所以呢，我特别花了一些精力去加强这方面的训练。</p><p>自己做了一些训练，去演讲俱乐部练习演讲，去读书聚会的地方做演讲，以及做主持人的表达工作。</p><p>我希望通过这样的锻炼，提升表达能力。也看了几本书，暂时还没有去总结它们，希望后面能够挤出时间来写些关于这个主题书的读书总结。</p><p>为什么要去做沟通跟表达演讲的训练呢？我内心声音是，我要解决人与人之间的关系，人与人之间的沟通。</p><p>前面10几年都在做练习解决事情的技巧，比如我要写好程序，写书，写文章，都是去总结一些解决事情的经验。</p><p>不管是程序还是项目还是工作分配工作拆解，都是需要我们去解决事情。这是我前面12年做的事情。</p><p>我最近领悟到，其实解决事情只占了30%的部分，剩余的70%的部分并不是靠解决事情来解决的，而是靠做人，解决人与人之间关系来搞定的。</p><p>一个典型的例子，在工作当中如果我们跟上级相处不好的话，跟家人的关系不好，你即使把成绩做出来了，也得不到家人的肯定，和领导的赏识，这对我们的感受有巨大影响，甚至会有强烈的挫败感。</p><p>因此现阶段的我认为，解决人与人之间的关系比解决事情更重要。</p><p>最重要的其实不是事情本身，而是与事情有关的人，这些人才是关键。例如事情提出的人是领导，或与事件有关的人是同事，在他们提出问题时，先确立这是不是个事实。</p><p>我相信大部分时候是事实，也可能是被夸大的事实。当我们去做事时，其实应该首先跟他们聊一聊，跟老板聊一聊，跟这些部门的人来聊一聊，这样的才能体会到对方的感受，以及看到对方究竟想要的。</p><p>跟人联系、寒暄后，才能知道对方的情绪、想法、需要，这时再想办法来解决问题</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484939&amp;idx=1&amp;sn=e3df251c9cb4733784e5df9ccd21e3ab&amp;chksm=fc22630ccb55ea1a27f035c062122bf9e40a504d0dac7143b0a383b4f7dc729dc8596cc10958&amp;token=254199611&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/10/12/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A866",
            
            
            
            
            
            "date_published": "2021-10-12T00:00:00+08:00",
            "date_modified": "2021-10-12T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/09/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B045",
            "title": "读书笔记(四十五) 《游戏引擎架构》#3 链接、图形计算库、资产管理模块",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：作为游戏开发从业者，从业务到语言到框架到引擎，积累了一些知识和经验，特别是在看了好几遍《游戏引擎架构》后对引擎的架构感触颇深。近段时间对引擎剖析的想法也较多，正好借着书本对游戏引擎架构做一个完整分析。此书用简明、清楚的方式覆盖了游戏引擎架构的庞大领域，巧妙地平衡了广度与深度，并且提供了足够的细节，使得初学者也能很容易地理解其中的各种概念。我的目标是掌握游戏引擎架构知识，我的方法是借助《游戏引擎架构》这本书、结合引擎源码和自己的经验，深入分析游戏引擎的历史、架构、模块。最后通过实践简单引擎开发来完成对引擎知识的掌握。游戏引擎知识面深而广，所以对这系列的文章书编写范围做个保护，即不对细节进行过多的阐述，重点剖析的是架构、流程以及模块的运作原理。由于《游戏引擎架构》此书的部分知识太浅或太过陈旧，所以不得不将部分知识重新深挖后总结出自己的观点。概述：本章开始对引擎中的重要的模块和库进行详细的分析，我挑选了十五个库和模块来分析：  时间库  自定义容器库  字符串散列库  内存管理框架  RTTI与反射模块  图形计算库  资产管理模块  低阶渲染器  剔除与合批模块  动画模块  物理模块  UI核心框架  性能剖析器的核心部分  脚本系统  视觉效果模块本篇内容为列表中的6、7。正文：简单回顾下前文，前面我们聊了时间库、自定义容器、字符串、内存管理这四个模块的技术原理和特点，它们都是大型软件架构所必备的模块，同时简单讲述了它们在Unreal和Unity中存在的特点。编译链接过程与内存布局图1图2简单回顾一下C++编译过程：  源文件.cpp文件被编译成.o文件后由链接器链接成可执行文件或库文件。  库分为静态库和动态库。其中静态库为只是简单集合了.o文件，而动态库则是一个完整的编译、链接产物。  头文件.h文件不是编译的必需品，它只是包含在源文件中的声明文件。  Linux的so和Windows的DLL虽然都是ELF文件格式，但最终格式差了很多，因此不能互相使用。  编译器开启优化后（一般是Release时），会优化代码，包括内联、调换代码顺序、更改代码为最优等。具体可以看我前面写的《链接、装载与库》http://luzexi.com/2021/06/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B029也同时回顾下C++内存布局：    1.C++内存布局中有，类、变量、内存对齐、虚表、RTTI    2.类和结构在C++中差异较少    3.每个变量内存占用量不同，int（32bit）、short int（16bit）、long long int（64bit）、float（4bit）、double（8bit）、char（8bit）等    4.默认按4字节（32bit）对齐，不足4字节的编译器会补齐    5.虚函数或虚继承的类有虚表及虚表指针    6.没有RTTI的情况下，虚表只有当前的虚函数指针    7.有RTTI的情况下，虚表中有type_info指针    8.有RTTI的情况下，虚指针指向虚表中的第二个格子，即虚指针，第一个格子为type_info指针具体可以看我前面写的《深度探索C++对象模型-总结》http://luzexi.com/2020/11/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B014图形计算库图形库涉及内容有图形元素和运算两种，它们分别包含，点、矢量、矩阵、四元数、图形对象以及相关的运算（包括SIMD）。下面我们来介绍一下：矢量运算包括：矢量加减法、模、归一化、点积、投影、叉积、线性插值等。矩阵有，单位矩阵、转置矩阵、逆矩阵、齐次坐标。矩阵运算，包括矩阵乘法、加减法、除、与、或等。四元数运算包括，四元数乘法、加减法、逆运算、旋转矢量、等价的四元数矩阵、旋转线性插值、球面线性插值等。各图形转换操作，包括旋转、缩放、投影、平移、LookAt等。图形对象包括，直线、线段、球体、平面、包围盒、平截头体、圆形、矩形、三角形等。这部分内容可以在Unreal的Engine\\Source\\Runtime\\Core\\Public\\Math中找到。下面简单介绍下SIMD：硬件加速SIMD运算（Single instruction multiple data），单指令多数据，是指，现代微处理器用一个指令并行地对多个数据执行数学运算，它能帮助我们加速运算。游戏引擎中最常用的是SSE模式（Streaming SIMD extensions，SSE），它包裹了4个32位float值，它们都被打包进了一个128位寄存器。单个指令可对4对浮点数进行并行运算，如加法或乘法。在计算四元矢量和4x4矩阵相乘时特别有用。需要注意的是1.由于在浮点运算器和SSE寄存器之间传输数据很糟糕，所以不要混合使用普通浮点数和SIMD运算，这样会使得CPU整个指令执行流水线停顿，浪费CPU周期。2.在VS中用SIMD数据类型__m128声明的临时变量或参数，编译器通常会把它们直接置于SSE寄存器中而非内存栈。3.动态分配SIMD结构时要注意内存按16字节对齐资产管理模块先说文件系统文件系统游戏引擎中的文件系统相对比较简单：1.每个平台的路径、API不同，对平台需要做些封装。2.文件读取的阻塞方式分同步和异步。其中同步需要阻塞当前进程来等待IO，异步则通过分线程阻塞等待IO，其两者原理是一样，都是调用内核读取文件且都需要等待IO。以前写过一篇关于操作系统内核中文件操作的底层原理《链接、装载与库 - 内核运行库》大家可以参考下。这里顺便简单回顾一下文件内核原理：图1图2这两张图清晰的表达了内核文件的读写原理：1.操作系统内核中对每个打开的文件都有个内核对象2.所有文件内核对象都被集中索引到一个数组中，称为文件打开表3.文件表数组前三个元素填充的是stdin、stdout、stderr这三个内核对象4.为了增加读写效率，内核已经实现了文件读取缓冲，会读取一段一段的读取5.读取步骤，用户程序先开辟一段内存，内核程序则利用缓冲读取，不足时多次读取，结束时返回数据。资产管理器早前很多引擎都有独立的资产管理器，它被制作成了一个独立的软件，专门用于管理游戏资产，包括网格、材质、纹理、着色器程序、动画、音频、配置等。资产管理器本身是一个具有清晰设计、统一、中心化的子系统，负责管理游戏中用到的所有类型的资产，只是现代大多引擎已经将资产管理整合到引擎编辑器中。资产管理器解决了什么问题？答案是：1.资产预览，资产在引擎中快速预览，并对不同资产类型区分展示。2.资产查找，通过查找功能快速查找到资产。3.资产组合，通过组合信息管理资产各个依赖。    资产通常组合在一起使用，因此组合信息是资产管理的一部分。    加载时需要依赖多个资产，引擎通过资产元数据将这些信息保存下来。4.资产转换，将外部资产导入到引擎中使用。    外部资产需要经过一定的转换才能在引擎中使用。    引擎通常有自己的资产导入系统，将外部资产转换为自身使用的数据格式。5.运行时资产管理，引擎向应用层提供加载和释放资产接口，并管理已加载资产对象。    资产的加载和释放，引擎需要提供给应用层加载和释放资产的接口，引擎本身也需要对这些资产进行管理。下面我们从资产管道、资产类型、运行时资产管理、元文件、资产包，四个方面介绍下引擎中的资产管理器。资产管道：每个资产都需要通过资产管道才能最终被游戏引擎所使用。每个资产管道的始端都是DCC原生格式的源资产（Maya的.ma或.mb、3DMax的.max或.obj、Photoshop的.psd文件等）。资产经过资产管道的导出器、资产编译器、资产链接器，最终生成了游戏引擎可以使用的数据格式。第一步，通常DCC工具需要撰写自定义插件（大都已提供现成统一的插件），把DCC里的数据导出为某种中间格式（例如.fbx格式），一般DCC工具都会提供接口或脚本供程序员写导出插件。第二步，中间格式数据仍然需要经过一定的转换才能被引擎使用，因此引擎通过资产编译器转换中间格式。第三步，通常多个资产组合后才成为一个完整资产，例如网格文件、材质文件、动画文件、贴图文件等，它们经过资产链接器连接后组合成为完整的资产。资产类型：资产经过资产管道后会生成相应的资产相关文件，包括：1.资产源文件2.资产配置文件（元数据文件）3.资产目标文件资产也分为外部和内部资产，外部资产由DCC导出，内部资产则通过引擎生成，例如材质球、动画控制器、蓝图、粒子等。资产配置文件记录了资产在引擎中的配置信息和依赖关系。资产目标文件是引擎根据资产源文件和配置信息生成的符合引擎使用格式的资产文件。生成资产元数据文件和目标文件的目的是：1.在保留原资产文件格式的前提下，生成引擎能使用的格式文件。2.便于引擎获取每个资产文件的配置及依赖关系。3.便于引擎统一管理资产，管理资产的目的是，提供例如建立资产数据库、查找、同步、打包等功能。Unity引擎使用Mate文件存储资产的配置和依赖关系。当引擎导入资产时就会生成相应的Mate文件，并根据这个Mate文件在Library文件夹下生成目标文件，同时根据修改的Mate文件配置来调整或重新生成目标文件。Unreal引擎则稍稍有些不同，资产源文件仍然会转换成资产目标文件，只是它把资产配置文件和资产目标文件合并在一个uasset文件中，这样导入后源文件就不再需要。如果你想要获取元数据，UE4也提供了python接口和蓝图接口。运行时资产管理：运行时资产管理通常包括，资产对象管理、资产对象映射管理。资产从加载到实例化，在引擎内部必须有一个有效的管理机制，其职责为：1.同一份资源只会存在一个副本2.管理资产生命周期，确保不需要时卸载3.处理复合资产，复合资产依赖多个资产组合而成。4.维护引用，确保复合资产在内存中的引用关系正确。5.资产接口，提供资产载入与卸载接口，包含同步和异步的载入方式。基于这五个职责，资产在运行时的引擎中必须拥有信息为，资产地址，资产对象，资产对象ID（运行时ID）。部分引擎对每个资源都配备了资产唯一ID（GUID），让资产地址与资产唯一ID有绑定关系，这使得引擎在资产迁移时能发挥更好的作用。资产对象映射管理包括：  资产路径与资产唯一ID的映射关系  资产唯一ID与资产对象ID的映射关系  资产对象ID与资产对象的映射关系有了这些映射关系，引擎就能通过资产路径查找到资产对象，从而保证不重复加载，并维护好各资产之间的引用关系。在UE4和Unity上也同样做了这种类型的资产映射关系的管理。资产加载和卸载资产加载与卸载接口必不可少，通常引擎都会定制一些依赖数据，例如前面提到的资产配置文件（也可以说是资产元数据），多个资产组合达成资源包时，资源包之间的依赖关系也同样需要有数据来维护。引擎都会有资源加载的统一接口，包括加载和卸载，同步和异步，资源包和非资源包形式。图引擎的资产加载和卸载框架各引擎之间稍有不同，不过总体差不了太多，或直接IO调用，或用开启线程后做IO调用，然后通过存储资产对象与映射关系来搭建资产加载和释放的框架，由于各个引擎接口都不一样，不做详细介绍。资源包数据格式通常引擎都会提供类似AssetBundle的资源组合包，便于外部资源下载和更新。在UE4和Unity上都有相同的功能，只是命名不同，UE4为Pak，Unity为AssetBundle。Pak或AssetBundle中存放着多个复合资产，通过引擎接口加载指定资产。图为了方便理解，我把数据格式从头往下画。实际中的Pak和AssetBundle数据格式要倒一下，头信息在最底部，资产数据块在最前头。资源包数据格式：1.文件头信息与数据块拆分2.可整体压缩或部分压缩3.通过依赖配置加载外部资源包资源包可以通俗的认为是一个多文件的组合，它可以自己做压缩，也可以让资产压缩后再组合成文件。通常资源包的数据格式由文件头和数据块两部分组成。文件头信息中包含了资产信息和偏移量，通过加载文件头，就能知道资产在文件中的位置、类型、名称、大小等。这种资产组织方式使得我们通过差量方式更新资产成为可能。图根据资源包的数据格式特点，可以规划差量更新步骤：1.打差量包，包头保持完整，数据块则只加入差量部分2.下载差量包3.合并两个资源包文件4.合并时使用差量包头作为文件头5.合并时提取原资源包中的不更新部分和差量包中的更新部分放入新的资源包文件中6.更新完成生成新的资源文件这部分内容Unity和Unreal并无太大差异。资产规范资产规范目标：规范命名，防止程序报错，方便自动化检测，方便筛选找寻。优化内容，每个项目资源都应该有存在目的。减短路径，路径简短易寻。图网上有同学分享的很详细了，这里就不赘述，参考《UE4工程规范》：https://github.com/skylens-inc/ue4-style-guide/blob/master/README.md#12-%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B%E8%A1%A8-参考资料：《游戏引擎架构》叶劲峰 译《游戏引擎原理与实践》 程东哲 著《vmath》https://github.com/BlackMATov/vmath.hpp#Matrix-Transform-3D《从虚函数表到RTTI》https://zhuanlan.zhihu.com/p/150579874《虚幻引擎4文档》https://docs.unrealengine.com/4.27/zh-CN/Basics/AssetsAndPackages/AssetMetadata/《UE4工程规范》https://github.com/skylens-inc/ue4-style-guide/blob/master/README.md#12-%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B%E8%A1%A8-《链接、装载与库 - 内核运行库》https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484809&amp;idx=1&amp;sn=89091ecce47229ebf10e4855c0ccceca&amp;chksm=fc22608ecb55e998cdff3952057e6d1c6f099463797d57458ec1f4d37a432d46dc3c5bfcfbb5&amp;token=557108361&amp;lang=zh_CN#rd《链接、装载与库 - 静态链接》http://luzexi.com/2021/06/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B029《深度探索C++对象模型-总结》http://luzexi.com/2020/11/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B014已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484932&amp;idx=1&amp;sn=13c96ed5d6a24abe43d9a63a5e2aca23&amp;chksm=fc226303cb55ea1527fead1e2d90b435a6eb911cb54e58ffbde95b674f1982859fa6a66f3837&amp;token=1405609858&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h1 id=\"背景\">背景：</h1><p>作为游戏开发从业者，从业务到语言到框架到引擎，积累了一些知识和经验，特别是在看了好几遍《游戏引擎架构》后对引擎的架构感触颇深。</p><p>近段时间对引擎剖析的想法也较多，正好借着书本对游戏引擎架构做一个完整分析。此书用简明、清楚的方式覆盖了游戏引擎架构的庞大领域，巧妙地平衡了广度与深度，并且提供了足够的细节，使得初学者也能很容易地理解其中的各种概念。</p><p>我的目标是掌握游戏引擎架构知识，我的方法是借助《游戏引擎架构》这本书、结合引擎源码和自己的经验，深入分析游戏引擎的历史、架构、模块。最后通过实践简单引擎开发来完成对引擎知识的掌握。</p><p>游戏引擎知识面深而广，所以对这系列的文章书编写范围做个保护，即不对细节进行过多的阐述，重点剖析的是架构、流程以及模块的运作原理。</p><p>由于《游戏引擎架构》此书的部分知识太浅或太过陈旧，所以不得不将部分知识重新深挖后总结出自己的观点。</p><h1 id=\"概述\">概述：</h1><p>本章开始对引擎中的重要的模块和库进行详细的分析，我挑选了十五个库和模块来分析：</p><ol>  <li>时间库</li>  <li>自定义容器库</li>  <li>字符串散列库</li>  <li>内存管理框架</li>  <li>RTTI与反射模块</li>  <li>图形计算库</li>  <li>资产管理模块</li>  <li>低阶渲染器</li>  <li>剔除与合批模块</li>  <li>动画模块</li>  <li>物理模块</li>  <li>UI核心框架</li>  <li>性能剖析器的核心部分</li>  <li>脚本系统</li>  <li>视觉效果模块</li></ol><p>本篇内容为列表中的6、7。</p><h1 id=\"正文\">正文：</h1><p>简单回顾下前文，前面我们聊了时间库、自定义容器、字符串、内存管理这四个模块的技术原理和特点，它们都是大型软件架构所必备的模块，同时简单讲述了它们在Unreal和Unity中存在的特点。</p><h2 id=\"编译链接过程与内存布局\">编译链接过程与内存布局</h2><p>图1</p><p>图2</p><p>简单回顾一下C++编译过程：</p><ol>  <li>源文件.cpp文件被编译成.o文件后由链接器链接成可执行文件或库文件。</li>  <li>库分为静态库和动态库。其中静态库为只是简单集合了.o文件，而动态库则是一个完整的编译、链接产物。</li>  <li>头文件.h文件不是编译的必需品，它只是包含在源文件中的声明文件。</li>  <li>Linux的so和Windows的DLL虽然都是ELF文件格式，但最终格式差了很多，因此不能互相使用。</li>  <li>编译器开启优化后（一般是Release时），会优化代码，包括内联、调换代码顺序、更改代码为最优等。</li></ol><p>具体可以看我前面写的《链接、装载与库》</p><p>http://luzexi.com/2021/06/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B029</p><p>也同时回顾下C++内存布局：    1.C++内存布局中有，类、变量、内存对齐、虚表、RTTI    2.类和结构在C++中差异较少    3.每个变量内存占用量不同，int（32bit）、short int（16bit）、long long int（64bit）、float（4bit）、double（8bit）、char（8bit）等    4.默认按4字节（32bit）对齐，不足4字节的编译器会补齐    5.虚函数或虚继承的类有虚表及虚表指针    6.没有RTTI的情况下，虚表只有当前的虚函数指针    7.有RTTI的情况下，虚表中有type_info指针    8.有RTTI的情况下，虚指针指向虚表中的第二个格子，即虚指针，第一个格子为type_info指针</p><p>具体可以看我前面写的《深度探索C++对象模型-总结》</p><p>http://luzexi.com/2020/11/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B014</p><h2 id=\"图形计算库\">图形计算库</h2><p>图形库涉及内容有图形元素和运算两种，它们分别包含，点、矢量、矩阵、四元数、图形对象以及相关的运算（包括SIMD）。</p><p>下面我们来介绍一下：</p><p>矢量运算包括：矢量加减法、模、归一化、点积、投影、叉积、线性插值等。</p><p>矩阵有，单位矩阵、转置矩阵、逆矩阵、齐次坐标。矩阵运算，包括矩阵乘法、加减法、除、与、或等。</p><p>四元数运算包括，四元数乘法、加减法、逆运算、旋转矢量、等价的四元数矩阵、旋转线性插值、球面线性插值等。</p><p>各图形转换操作，包括旋转、缩放、投影、平移、LookAt等。</p><p>图形对象包括，直线、线段、球体、平面、包围盒、平截头体、圆形、矩形、三角形等。</p><p>这部分内容可以在Unreal的Engine\\Source\\Runtime\\Core\\Public\\Math中找到。</p><h3 id=\"下面简单介绍下simd\">下面简单介绍下SIMD：</h3><p>硬件加速SIMD运算（Single instruction multiple data），单指令多数据，是指，现代微处理器用一个指令并行地对多个数据执行数学运算，它能帮助我们加速运算。</p><p>游戏引擎中最常用的是SSE模式（Streaming SIMD extensions，SSE），它包裹了4个32位float值，它们都被打包进了一个128位寄存器。</p><p>单个指令可对4对浮点数进行并行运算，如加法或乘法。在计算四元矢量和4x4矩阵相乘时特别有用。</p><p>需要注意的是1.由于在浮点运算器和SSE寄存器之间传输数据很糟糕，所以不要混合使用普通浮点数和SIMD运算，这样会使得CPU整个指令执行流水线停顿，浪费CPU周期。2.在VS中用SIMD数据类型__m128声明的临时变量或参数，编译器通常会把它们直接置于SSE寄存器中而非内存栈。3.动态分配SIMD结构时要注意内存按16字节对齐</p><h2 id=\"资产管理模块\">资产管理模块</h2><p>先说文件系统</p><h3 id=\"文件系统\">文件系统</h3><p>游戏引擎中的文件系统相对比较简单：1.每个平台的路径、API不同，对平台需要做些封装。2.文件读取的阻塞方式分同步和异步。</p><p>其中同步需要阻塞当前进程来等待IO，异步则通过分线程阻塞等待IO，其两者原理是一样，都是调用内核读取文件且都需要等待IO。</p><p>以前写过一篇关于操作系统内核中文件操作的底层原理《链接、装载与库 - 内核运行库》大家可以参考下。</p><p>这里顺便简单回顾一下文件内核原理：</p><p>图1</p><p>图2</p><p>这两张图清晰的表达了内核文件的读写原理：1.操作系统内核中对每个打开的文件都有个内核对象2.所有文件内核对象都被集中索引到一个数组中，称为文件打开表3.文件表数组前三个元素填充的是stdin、stdout、stderr这三个内核对象4.为了增加读写效率，内核已经实现了文件读取缓冲，会读取一段一段的读取5.读取步骤，用户程序先开辟一段内存，内核程序则利用缓冲读取，不足时多次读取，结束时返回数据。</p><h2 id=\"资产管理器\">资产管理器</h2><p>早前很多引擎都有独立的资产管理器，它被制作成了一个独立的软件，专门用于管理游戏资产，包括网格、材质、纹理、着色器程序、动画、音频、配置等。</p><p>资产管理器本身是一个具有清晰设计、统一、中心化的子系统，负责管理游戏中用到的所有类型的资产，只是现代大多引擎已经将资产管理整合到引擎编辑器中。</p><h3 id=\"资产管理器解决了什么问题答案是\">资产管理器解决了什么问题？答案是：</h3><p>1.资产预览，资产在引擎中快速预览，并对不同资产类型区分展示。2.资产查找，通过查找功能快速查找到资产。3.资产组合，通过组合信息管理资产各个依赖。    资产通常组合在一起使用，因此组合信息是资产管理的一部分。    加载时需要依赖多个资产，引擎通过资产元数据将这些信息保存下来。4.资产转换，将外部资产导入到引擎中使用。    外部资产需要经过一定的转换才能在引擎中使用。    引擎通常有自己的资产导入系统，将外部资产转换为自身使用的数据格式。5.运行时资产管理，引擎向应用层提供加载和释放资产接口，并管理已加载资产对象。    资产的加载和释放，引擎需要提供给应用层加载和释放资产的接口，引擎本身也需要对这些资产进行管理。</p><p>下面我们从资产管道、资产类型、运行时资产管理、元文件、资产包，四个方面介绍下引擎中的资产管理器。</p><h3 id=\"资产管道\">资产管道：</h3><p>每个资产都需要通过资产管道才能最终被游戏引擎所使用。每个资产管道的始端都是DCC原生格式的源资产（Maya的.ma或.mb、3DMax的.max或.obj、Photoshop的.psd文件等）。资产经过资产管道的导出器、资产编译器、资产链接器，最终生成了游戏引擎可以使用的数据格式。</p><p>第一步，通常DCC工具需要撰写自定义插件（大都已提供现成统一的插件），把DCC里的数据导出为某种中间格式（例如.fbx格式），一般DCC工具都会提供接口或脚本供程序员写导出插件。第二步，中间格式数据仍然需要经过一定的转换才能被引擎使用，因此引擎通过资产编译器转换中间格式。第三步，通常多个资产组合后才成为一个完整资产，例如网格文件、材质文件、动画文件、贴图文件等，它们经过资产链接器连接后组合成为完整的资产。</p><h3 id=\"资产类型\">资产类型：</h3><p>资产经过资产管道后会生成相应的资产相关文件，包括：1.资产源文件2.资产配置文件（元数据文件）3.资产目标文件</p><p>资产也分为外部和内部资产，外部资产由DCC导出，内部资产则通过引擎生成，例如材质球、动画控制器、蓝图、粒子等。资产配置文件记录了资产在引擎中的配置信息和依赖关系。资产目标文件是引擎根据资产源文件和配置信息生成的符合引擎使用格式的资产文件。</p><p>生成资产元数据文件和目标文件的目的是：1.在保留原资产文件格式的前提下，生成引擎能使用的格式文件。2.便于引擎获取每个资产文件的配置及依赖关系。3.便于引擎统一管理资产，管理资产的目的是，提供例如建立资产数据库、查找、同步、打包等功能。</p><p>Unity引擎使用Mate文件存储资产的配置和依赖关系。当引擎导入资产时就会生成相应的Mate文件，并根据这个Mate文件在Library文件夹下生成目标文件，同时根据修改的Mate文件配置来调整或重新生成目标文件。</p><p>Unreal引擎则稍稍有些不同，资产源文件仍然会转换成资产目标文件，只是它把资产配置文件和资产目标文件合并在一个uasset文件中，这样导入后源文件就不再需要。如果你想要获取元数据，UE4也提供了python接口和蓝图接口。</p><h3 id=\"运行时资产管理\">运行时资产管理：</h3><p>运行时资产管理通常包括，资产对象管理、资产对象映射管理。</p><p>资产从加载到实例化，在引擎内部必须有一个有效的管理机制，其职责为：1.同一份资源只会存在一个副本2.管理资产生命周期，确保不需要时卸载3.处理复合资产，复合资产依赖多个资产组合而成。4.维护引用，确保复合资产在内存中的引用关系正确。5.资产接口，提供资产载入与卸载接口，包含同步和异步的载入方式。</p><p>基于这五个职责，资产在运行时的引擎中必须拥有信息为，资产地址，资产对象，资产对象ID（运行时ID）。</p><p>部分引擎对每个资源都配备了资产唯一ID（GUID），让资产地址与资产唯一ID有绑定关系，这使得引擎在资产迁移时能发挥更好的作用。</p><p>资产对象映射管理包括：</p><ol>  <li>资产路径与资产唯一ID的映射关系</li>  <li>资产唯一ID与资产对象ID的映射关系</li>  <li>资产对象ID与资产对象的映射关系</li></ol><p>有了这些映射关系，引擎就能通过资产路径查找到资产对象，从而保证不重复加载，并维护好各资产之间的引用关系。</p><p>在UE4和Unity上也同样做了这种类型的资产映射关系的管理。</p><h3 id=\"资产加载和卸载\">资产加载和卸载</h3><p>资产加载与卸载接口必不可少，通常引擎都会定制一些依赖数据，例如前面提到的资产配置文件（也可以说是资产元数据），多个资产组合达成资源包时，资源包之间的依赖关系也同样需要有数据来维护。</p><p>引擎都会有资源加载的统一接口，包括加载和卸载，同步和异步，资源包和非资源包形式。</p><p>图</p><p>引擎的资产加载和卸载框架各引擎之间稍有不同，不过总体差不了太多，或直接IO调用，或用开启线程后做IO调用，然后通过存储资产对象与映射关系来搭建资产加载和释放的框架，由于各个引擎接口都不一样，不做详细介绍。</p><h3 id=\"资源包数据格式\">资源包数据格式</h3><p>通常引擎都会提供类似AssetBundle的资源组合包，便于外部资源下载和更新。</p><p>在UE4和Unity上都有相同的功能，只是命名不同，UE4为Pak，Unity为AssetBundle。</p><p>Pak或AssetBundle中存放着多个复合资产，通过引擎接口加载指定资产。</p><p>图</p><p>为了方便理解，我把数据格式从头往下画。实际中的Pak和AssetBundle数据格式要倒一下，头信息在最底部，资产数据块在最前头。</p><p>资源包数据格式：1.文件头信息与数据块拆分2.可整体压缩或部分压缩3.通过依赖配置加载外部资源包</p><p>资源包可以通俗的认为是一个多文件的组合，它可以自己做压缩，也可以让资产压缩后再组合成文件。</p><p>通常资源包的数据格式由文件头和数据块两部分组成。文件头信息中包含了资产信息和偏移量，通过加载文件头，就能知道资产在文件中的位置、类型、名称、大小等。</p><p>这种资产组织方式使得我们通过差量方式更新资产成为可能。</p><p>图</p><p>根据资源包的数据格式特点，可以规划差量更新步骤：1.打差量包，包头保持完整，数据块则只加入差量部分2.下载差量包3.合并两个资源包文件4.合并时使用差量包头作为文件头5.合并时提取原资源包中的不更新部分和差量包中的更新部分放入新的资源包文件中6.更新完成生成新的资源文件</p><p>这部分内容Unity和Unreal并无太大差异。</p><h2 id=\"资产规范\">资产规范</h2><p>资产规范目标：规范命名，防止程序报错，方便自动化检测，方便筛选找寻。优化内容，每个项目资源都应该有存在目的。减短路径，路径简短易寻。</p><p>图</p><p>网上有同学分享的很详细了，这里就不赘述，参考《UE4工程规范》：</p><p>https://github.com/skylens-inc/ue4-style-guide/blob/master/README.md#12-%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B%E8%A1%A8-</p><h3 id=\"参考资料\">参考资料：</h3><p>《游戏引擎架构》叶劲峰 译</p><p>《游戏引擎原理与实践》 程东哲 著</p><p>《vmath》</p><p>https://github.com/BlackMATov/vmath.hpp#Matrix-Transform-3D</p><p>《从虚函数表到RTTI》</p><p>https://zhuanlan.zhihu.com/p/150579874</p><p>《虚幻引擎4文档》</p><p>https://docs.unrealengine.com/4.27/zh-CN/Basics/AssetsAndPackages/AssetMetadata/</p><p>《UE4工程规范》</p><p>https://github.com/skylens-inc/ue4-style-guide/blob/master/README.md#12-%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B%E8%A1%A8-</p><p>《链接、装载与库 - 内核运行库》</p><p>https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484809&amp;idx=1&amp;sn=89091ecce47229ebf10e4855c0ccceca&amp;chksm=fc22608ecb55e998cdff3952057e6d1c6f099463797d57458ec1f4d37a432d46dc3c5bfcfbb5&amp;token=557108361&amp;lang=zh_CN#rd</p><p>《链接、装载与库 - 静态链接》</p><p>http://luzexi.com/2021/06/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B029</p><p>《深度探索C++对象模型-总结》</p><p>http://luzexi.com/2020/11/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B014</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484932&amp;idx=1&amp;sn=13c96ed5d6a24abe43d9a63a5e2aca23&amp;chksm=fc226303cb55ea1527fead1e2d90b435a6eb911cb54e58ffbde95b674f1982859fa6a66f3837&amp;token=1405609858&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/09/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B045",
            
            
            
            "tags": ["读书笔记","前端技术"],
            
            "date_published": "2021-09-28T00:00:00+08:00",
            "date_modified": "2021-09-28T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/09/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B044",
            "title": "读书笔记(四十四) 《心流》#3 专注时人们的表现",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：在2020年初就买了《心流》，直到2021年1月才读完第一遍，读完的那一刻，我知道我又打开了一个新世界。不得不承认就是这本书让我的专注力提高了整整一个级别，这是最让我非常兴奋的地方。而我只是读了第一遍，吸收不到10%的结果，可想而知它的魔力有多么强大。于是决定好好回顾总结一下整本书，便开启了第二遍、第三遍的读书之旅。读此书的起源是由于我在平时工作、交流、学习时，常常难以集中注意力，因此带着好奇心阅读了这本书。我猜大家应该也和我一样，常常为自己难以击中注意力而烦恼，其实我们都希望自己在专注做一件事情的时候能够拥有更高的效率。本书的核心是心流的最优体验，简单来说就是“如何让你高兴地专注”。作者想表达的是，当你的心流会的体验最佳时，也是学习效率最高的时候，同时也是你最幸福的时刻。书本中讲到了关于学习、工作、运动、社交等各方面的心流原理和技巧，我作为知识的搬运工，做了一些精炼和总结的工作。正文：简单回顾下前文：前文我们说了专注力能带给我们幸福，生活让我们感到痛苦的一个重要原因是人们欲望无法填满，我们生活在这个社会被这个的规则所牵动，已经沦为社会的奴隶，在这种环境培养独立意识非常重要同时也非常艰难。控制意识能改善体验的品质想要控制意识，首先要了解它。那么意识究竟是如何运作的呢？“意识”简单来说就是，某些我们能感觉到的，且有能力引导其方向的东西，诸如情绪、感觉、思想、企图等。首先，一个人可以不管外界不管发生什么事，只靠改变意识的内涵，使自己快乐或悲伤。其次，意识的力量可以把无助的境况转变为有机会反败为胜的挑战。我们口中所说的奋斗不辍、克服万难的毅力，它不但是成功的要素，也是享受人生的不二法门。最后，控制意识需要毅力，而培养毅力应该从建立意识的秩序、控制感觉与思想着手，且最好不要企图走捷径。瑜伽行者就是控制意识的高手，但跟任何高手一样，他们下了多年功夫苦练，一刻都不懈怠。唯有这样投注所有时间与心力，提升操纵内在体验的技巧，方能成为专家。意识的极限生活中有太多的事情需要我们的注意，但我们顶多同时应付七组资讯，诸如分辨声音、影像、情绪或思想中可辨识的弦外之音等。大多数人在每天的三分之一的闲暇时间里，都尽可能避免用脑子，这段空档一半以上都在电视前、杂志、抖音、微信聊天、看app资讯上消磨掉。因此对于我们来说，准许哪些资讯进入意识就显得格外重要，这实际上，就决定了我们生活的内涵与品质。神经系统在特定时间内能处理的资讯极为有限，每次只能认知和回应一定数量的事件，而新涌进来的会把旧的挤掉。所以思绪必须井然有序，否则就会混乱。注意力是无价的资源注意力再强大也无法超越我们前面谈到的限制，它只能在一定时间内处理一定数量的资讯。从记忆库中取出资讯，理解、比较、评估，然后做决定，都需要心灵有限的资讯处理能力。控制意识最明显的指标就是能随心所欲地集中注意力，不因任何事情而分心。若能做到这一点，就能在日常生活中找乐趣。作者举例一位学员E女士：她无时无刻不在写作、解决问题、阅读报纸、翻阅当日行程，或只是提出问题，仔细观察周遭事物，并计划下一步的工作。她只花很少的时间在日常例行公事上。她每天都会抽出时间来位心灵充电，如在湖畔伫立15分钟，闭上眼睛让阳光洒在脸上，或牵着狗在镇外山坡上散步。她能充分控制注意力，可以随时把意识关闭，打个盹，然后恢复精神。另一位学员R先生：说话时目光深邃；听人说话时，往往从多方面分析对话的话语。一般人视为理所当然的事常令他感到困惑；在用原创但十分贴切的方式详加分析前，他绝不让任何事轻易溜走。R先生尽管不断地磨炼知性，外表却给人一种沉着、宁静的感觉。他似乎永远能察觉到周遭最微小的变动。他注意一件事，目的不在于改善或批判它，只要能够观察和了解事实，并表达自己的看法，他就心满意足了。R先生不像E女士那样对社会造成立刻的冲击，但他的意识同样复杂而有条理。他把注意力尽可能延伸，跟周遭的世界密切结合起来。跟E女士一样，他也能充分享受人生。像探照灯那样集中注意力大多数人都不能像E女士或R先生那样，把有限的注意力像探照灯一般集中成一道光束，而是任它毫无章法的散开。这说明生活中人们应用注意力的方式足以决定人生的外观与内涵，从而反应人们为人处世的现象。例如，在同一个宴会上，外向的人热衷于与人交际；成就不凡的人寻求有用的商界人脉；偏执狂则随时警惕，怕碰到危险等等。每种人都有自己的注意力探照灯，这也是不同人之间的差异。实际上工作生活中，我们每个职业都在训练自己的集中注意力的方式，例如，软件工程师会更多关注计算机软件运行过程，销售人员更关注人与人之间的交流与谈判，银行家更专注财务状况，运动员更关注动作协调与身体素质等等等等。这种探照灯一样的集中方式正是他们在专业领域中学会了如何抓住领域中易受忽略的讯号。内在失序与精神熵内在失序的意思是，外来资讯跟当下的意图发生冲突，使我们分心，使我们无法为现实意图而努力，造成对意识极为不利的影响。作者举了一个例子，胡里欧破轮胎的故事。他的汽车轮胎破了，于是他一大早小心翼翼地把车开到加油站，把轮胎的气打满，又尽快开到工厂。下班时轮胎气又漏光了，他再到工厂附近加油站打满气后再开回家。胡里欧如法炮制了三天，一整天他都在担心，今晚是否能回家以及明天是否能到岗。这使得他无法专心工作，情绪也变得烦躁不安。每当周围的环境对意识的目标构成威胁，就会发生内在的失序现象，这称为精神熵。它会导致自我解体，使效率大打折扣。这种状况若持续太久，对自身造成严重的损害，使自我再也不能集中注意力实现任何目标。井然有序的意识精神熵的反面就是最优体验。当我们专注于资讯与目标时，精神能量就会源源不断涌上来，这时我们就没有了忧虑情绪，也不再猜疑自己的能力。我们不再怀疑自己，也是因为我们得到了明确的鼓励，你做的很好。这种积极的反馈，强化了自我，使我们能投入更多的注意力，照顾内心与外在环境的平衡。作者举了一个例子。麦德林的工作是装配线上的工人，每天要重复600次的工作，像这样枯燥的工作，他做了五年，但还是觉得很快乐。因为他对工作的态度跟一名奥运选手差不多，常常思索如何打破纪录。他像外科医生一般一丝不苟的设计工具的安放顺序和每一步动作，经过五年的努力，他最好的成绩是28秒装配完一个单元。心流的最优体验出现时，一个人可以投入全部的注意力以求实现目标。没有失序现象需要整顿，自我也没有受到任何威胁，因此不需要分心防卫。一个人若能充分掌控意识，尽可能创造心流体验，生活品质势必会提高。在心流中，我们是精神能量的主宰，无论做什么事，都能使意识更有秩序。一位攀岩专家简要说明了自己的心流感觉：越来越完美的自我控制，产生一种痛快的感觉。你不断逼迫身体发挥所有极限，直到全身隐隐作痛。然后你会满怀敬畏地回顾自己，回顾你所做的一切。那种佩服的感觉，简直无法形容。它带给你一种狂喜，一种自我满足。只要在这种战役中战胜过自己，人生其他战场的挑战也就变得容易多了。其实战斗中对抗的不是自己，而是使意识失序的精神熵。体验过心流的人都知道，那份深沉的快乐，是严格的自律、集中注意力换来的。独特性与复杂性的完美结合复杂性是由两种广泛的心理过程造成的，一种是独特化，另一种是整合。1.独特化是把自己与他人区分开来，朝独一无二的方向发展。2.整合则恰好相反，是借着超越自我的观念和实体与他人连结。独特化和整合，两者都是使不可或缺的。如果独特化而不整合，体系就会出现一片混乱，反之也是一样。当我们只有独特化的自我时，虽然也能获得极高的成就，但会陷入以自我为中心的危险。同样的，如果一个人的自我若是完全建立在整合上，固然也能有良好的人际关系和安全感，却缺乏独立的个性。只有一个人把精神能量平均投注在这两方面，既不过分自私，也不盲从，才算达到自我所追求的复杂性。复杂的自我能够成功地融合这两种乍看矛盾的过程。心流体验会使自我变得比过去更复杂，这可以说是一种成长。我们在克服挑战时，必然会使我们变得更有能力和技巧，因此心流就是经由这种过程加深自我独特化的。当我们每经历一次心流后，我们就会变得更独特，更难预测，并拥有非凡的技能。选定一个目标，投入全部的注意力，不论做什么事情，都会觉得乐趣无穷。一旦尝到这种快乐，我们就会加倍努力，重温它的滋味，自我就这样开始成长。心流之所以重要，不仅是因为他能使现在更快乐，也是因为它会强化我们的自信心。虽然心流没有捷径可走，但只要我们了解它的运作方式，就有可能使生活改观。已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484913&amp;idx=1&amp;sn=9589d58b41c85d01d1aaa68872260539&amp;chksm=fc2260f6cb55e9e08222aa5096a65949a05c98edc73eb005e289e11010c68a4816ed35a50035&amp;token=134603822&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h1 id=\"背景\">背景：</h1><p>在2020年初就买了《心流》，直到2021年1月才读完第一遍，读完的那一刻，我知道我又打开了一个新世界。</p><p>不得不承认就是这本书让我的专注力提高了整整一个级别，这是最让我非常兴奋的地方。而我只是读了第一遍，吸收不到10%的结果，可想而知它的魔力有多么强大。</p><p>于是决定好好回顾总结一下整本书，便开启了第二遍、第三遍的读书之旅。</p><p>读此书的起源是由于我在平时工作、交流、学习时，常常难以集中注意力，因此带着好奇心阅读了这本书。</p><p>我猜大家应该也和我一样，常常为自己难以击中注意力而烦恼，其实我们都希望自己在专注做一件事情的时候能够拥有更高的效率。</p><p>本书的核心是心流的最优体验，简单来说就是“如何让你高兴地专注”。</p><p>作者想表达的是，当你的心流会的体验最佳时，也是学习效率最高的时候，同时也是你最幸福的时刻。</p><p>书本中讲到了关于学习、工作、运动、社交等各方面的心流原理和技巧，我作为知识的搬运工，做了一些精炼和总结的工作。</p><h1 id=\"正文\">正文：</h1><p>简单回顾下前文：</p><p>前文我们说了专注力能带给我们幸福，生活让我们感到痛苦的一个重要原因是人们欲望无法填满，我们生活在这个社会被这个的规则所牵动，已经沦为社会的奴隶，在这种环境培养独立意识非常重要同时也非常艰难。</p><h2 id=\"控制意识能改善体验的品质\">控制意识能改善体验的品质</h2><p>想要控制意识，首先要了解它。那么意识究竟是如何运作的呢？</p><p>“意识”简单来说就是，某些我们能感觉到的，且有能力引导其方向的东西，诸如情绪、感觉、思想、企图等。</p><p>首先，一个人可以不管外界不管发生什么事，只靠改变意识的内涵，使自己快乐或悲伤。</p><h3 id=\"其次意识的力量可以把无助的境况转变为有机会反败为胜的挑战\">其次，意识的力量可以把无助的境况转变为有机会反败为胜的挑战。</h3><p>我们口中所说的奋斗不辍、克服万难的毅力，它不但是成功的要素，也是享受人生的不二法门。</p><h3 id=\"最后控制意识需要毅力而培养毅力应该从建立意识的秩序控制感觉与思想着手且最好不要企图走捷径\">最后，控制意识需要毅力，而培养毅力应该从建立意识的秩序、控制感觉与思想着手，且最好不要企图走捷径。</h3><p>瑜伽行者就是控制意识的高手，但跟任何高手一样，他们下了多年功夫苦练，一刻都不懈怠。</p><p>唯有这样投注所有时间与心力，提升操纵内在体验的技巧，方能成为专家。</p><h2 id=\"意识的极限\">意识的极限</h2><p>生活中有太多的事情需要我们的注意，但我们顶多同时应付七组资讯，诸如分辨声音、影像、情绪或思想中可辨识的弦外之音等。</p><p>大多数人在每天的三分之一的闲暇时间里，都尽可能避免用脑子，这段空档一半以上都在电视前、杂志、抖音、微信聊天、看app资讯上消磨掉。</p><p>因此对于我们来说，准许哪些资讯进入意识就显得格外重要，这实际上，就决定了我们生活的内涵与品质。</p><h3 id=\"神经系统在特定时间内能处理的资讯极为有限每次只能认知和回应一定数量的事件而新涌进来的会把旧的挤掉所以思绪必须井然有序否则就会混乱\">神经系统在特定时间内能处理的资讯极为有限，每次只能认知和回应一定数量的事件，而新涌进来的会把旧的挤掉。所以思绪必须井然有序，否则就会混乱。</h3><h2 id=\"注意力是无价的资源\">注意力是无价的资源</h2><p>注意力再强大也无法超越我们前面谈到的限制，它只能在一定时间内处理一定数量的资讯。</p><p>从记忆库中取出资讯，理解、比较、评估，然后做决定，都需要心灵有限的资讯处理能力。</p><h3 id=\"控制意识最明显的指标就是能随心所欲地集中注意力不因任何事情而分心若能做到这一点就能在日常生活中找乐趣\">控制意识最明显的指标就是能随心所欲地集中注意力，不因任何事情而分心。若能做到这一点，就能在日常生活中找乐趣。</h3><p>作者举例一位学员E女士：</p><p>她无时无刻不在写作、解决问题、阅读报纸、翻阅当日行程，或只是提出问题，仔细观察周遭事物，并计划下一步的工作。</p><p>她只花很少的时间在日常例行公事上。</p><p>她每天都会抽出时间来位心灵充电，如在湖畔伫立15分钟，闭上眼睛让阳光洒在脸上，或牵着狗在镇外山坡上散步。</p><p>她能充分控制注意力，可以随时把意识关闭，打个盹，然后恢复精神。</p><p>另一位学员R先生：</p><p>说话时目光深邃；听人说话时，往往从多方面分析对话的话语。</p><p>一般人视为理所当然的事常令他感到困惑；在用原创但十分贴切的方式详加分析前，他绝不让任何事轻易溜走。</p><p>R先生尽管不断地磨炼知性，外表却给人一种沉着、宁静的感觉。他似乎永远能察觉到周遭最微小的变动。</p><p>他注意一件事，目的不在于改善或批判它，只要能够观察和了解事实，并表达自己的看法，他就心满意足了。</p><p>R先生不像E女士那样对社会造成立刻的冲击，但他的意识同样复杂而有条理。</p><p>他把注意力尽可能延伸，跟周遭的世界密切结合起来。</p><p>跟E女士一样，他也能充分享受人生。</p><h2 id=\"像探照灯那样集中注意力\">像探照灯那样集中注意力</h2><p>大多数人都不能像E女士或R先生那样，把有限的注意力像探照灯一般集中成一道光束，而是任它毫无章法的散开。</p><h3 id=\"这说明生活中人们应用注意力的方式足以决定人生的外观与内涵从而反应人们为人处世的现象\">这说明生活中人们应用注意力的方式足以决定人生的外观与内涵，从而反应人们为人处世的现象。</h3><p>例如，在同一个宴会上，外向的人热衷于与人交际；成就不凡的人寻求有用的商界人脉；偏执狂则随时警惕，怕碰到危险等等。</p><p>每种人都有自己的注意力探照灯，这也是不同人之间的差异。</p><p>实际上工作生活中，我们每个职业都在训练自己的集中注意力的方式，例如，软件工程师会更多关注计算机软件运行过程，销售人员更关注人与人之间的交流与谈判，银行家更专注财务状况，运动员更关注动作协调与身体素质等等等等。</p><p>这种探照灯一样的集中方式正是他们在专业领域中学会了如何抓住领域中易受忽略的讯号。</p><h2 id=\"内在失序与精神熵\">内在失序与精神熵</h2><p>内在失序的意思是，外来资讯跟当下的意图发生冲突，使我们分心，使我们无法为现实意图而努力，造成对意识极为不利的影响。</p><p>作者举了一个例子，胡里欧破轮胎的故事。他的汽车轮胎破了，于是他一大早小心翼翼地把车开到加油站，把轮胎的气打满，又尽快开到工厂。下班时轮胎气又漏光了，他再到工厂附近加油站打满气后再开回家。胡里欧如法炮制了三天，一整天他都在担心，今晚是否能回家以及明天是否能到岗。这使得他无法专心工作，情绪也变得烦躁不安。</p><h3 id=\"每当周围的环境对意识的目标构成威胁就会发生内在的失序现象这称为精神熵\">每当周围的环境对意识的目标构成威胁，就会发生内在的失序现象，这称为精神熵。</h3><h3 id=\"它会导致自我解体使效率大打折扣\">它会导致自我解体，使效率大打折扣。</h3><h3 id=\"这种状况若持续太久对自身造成严重的损害使自我再也不能集中注意力实现任何目标\">这种状况若持续太久，对自身造成严重的损害，使自我再也不能集中注意力实现任何目标。</h3><h2 id=\"井然有序的意识\">井然有序的意识</h2><p>精神熵的反面就是最优体验。</p><h3 id=\"当我们专注于资讯与目标时精神能量就会源源不断涌上来这时我们就没有了忧虑情绪也不再猜疑自己的能力\">当我们专注于资讯与目标时，精神能量就会源源不断涌上来，这时我们就没有了忧虑情绪，也不再猜疑自己的能力。</h3><p>我们不再怀疑自己，也是因为我们得到了明确的鼓励，你做的很好。这种积极的反馈，强化了自我，使我们能投入更多的注意力，照顾内心与外在环境的平衡。</p><p>作者举了一个例子。麦德林的工作是装配线上的工人，每天要重复600次的工作，像这样枯燥的工作，他做了五年，但还是觉得很快乐。因为他对工作的态度跟一名奥运选手差不多，常常思索如何打破纪录。他像外科医生一般一丝不苟的设计工具的安放顺序和每一步动作，经过五年的努力，他最好的成绩是28秒装配完一个单元。</p><p>心流的最优体验出现时，一个人可以投入全部的注意力以求实现目标。没有失序现象需要整顿，自我也没有受到任何威胁，因此不需要分心防卫。</p><h3 id=\"一个人若能充分掌控意识尽可能创造心流体验生活品质势必会提高\">一个人若能充分掌控意识，尽可能创造心流体验，生活品质势必会提高。</h3><p>在心流中，我们是精神能量的主宰，无论做什么事，都能使意识更有秩序。</p><p>一位攀岩专家简要说明了自己的心流感觉：</p><h3 id=\"越来越完美的自我控制产生一种痛快的感觉\">越来越完美的自我控制，产生一种痛快的感觉。</h3><h3 id=\"你不断逼迫身体发挥所有极限直到全身隐隐作痛\">你不断逼迫身体发挥所有极限，直到全身隐隐作痛。</h3><h3 id=\"然后你会满怀敬畏地回顾自己回顾你所做的一切\">然后你会满怀敬畏地回顾自己，回顾你所做的一切。</h3><h3 id=\"那种佩服的感觉简直无法形容\">那种佩服的感觉，简直无法形容。</h3><h3 id=\"它带给你一种狂喜一种自我满足\">它带给你一种狂喜，一种自我满足。</h3><h3 id=\"只要在这种战役中战胜过自己人生其他战场的挑战也就变得容易多了\">只要在这种战役中战胜过自己，人生其他战场的挑战也就变得容易多了。</h3><p>其实战斗中对抗的不是自己，而是使意识失序的精神熵。</p><h3 id=\"体验过心流的人都知道那份深沉的快乐是严格的自律集中注意力换来的\">体验过心流的人都知道，那份深沉的快乐，是严格的自律、集中注意力换来的。</h3><h2 id=\"独特性与复杂性的完美结合\">独特性与复杂性的完美结合</h2><p>复杂性是由两种广泛的心理过程造成的，一种是独特化，另一种是整合。</p><p>1.独特化是把自己与他人区分开来，朝独一无二的方向发展。</p><p>2.整合则恰好相反，是借着超越自我的观念和实体与他人连结。</p><p>独特化和整合，两者都是使不可或缺的。如果独特化而不整合，体系就会出现一片混乱，反之也是一样。</p><h3 id=\"当我们只有独特化的自我时虽然也能获得极高的成就但会陷入以自我为中心的危险\">当我们只有独特化的自我时，虽然也能获得极高的成就，但会陷入以自我为中心的危险。</h3><h3 id=\"同样的如果一个人的自我若是完全建立在整合上固然也能有良好的人际关系和安全感却缺乏独立的个性\">同样的，如果一个人的自我若是完全建立在整合上，固然也能有良好的人际关系和安全感，却缺乏独立的个性。</h3><h3 id=\"只有一个人把精神能量平均投注在这两方面既不过分自私也不盲从才算达到自我所追求的复杂性\">只有一个人把精神能量平均投注在这两方面，既不过分自私，也不盲从，才算达到自我所追求的复杂性。</h3><p>复杂的自我能够成功地融合这两种乍看矛盾的过程。心流体验会使自我变得比过去更复杂，这可以说是一种成长。</p><h3 id=\"我们在克服挑战时必然会使我们变得更有能力和技巧因此心流就是经由这种过程加深自我独特化的当我们每经历一次心流后我们就会变得更独特更难预测并拥有非凡的技能\">我们在克服挑战时，必然会使我们变得更有能力和技巧，因此心流就是经由这种过程加深自我独特化的。当我们每经历一次心流后，我们就会变得更独特，更难预测，并拥有非凡的技能。</h3><p>选定一个目标，投入全部的注意力，不论做什么事情，都会觉得乐趣无穷。</p><h3 id=\"一旦尝到这种快乐我们就会加倍努力重温它的滋味自我就这样开始成长\">一旦尝到这种快乐，我们就会加倍努力，重温它的滋味，自我就这样开始成长。</h3><p>心流之所以重要，不仅是因为他能使现在更快乐，也是因为它会强化我们的自信心。</p><p>虽然心流没有捷径可走，但只要我们了解它的运作方式，就有可能使生活改观。</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484913&amp;idx=1&amp;sn=9589d58b41c85d01d1aaa68872260539&amp;chksm=fc2260f6cb55e9e08222aa5096a65949a05c98edc73eb005e289e11010c68a4816ed35a50035&amp;token=134603822&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/09/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B044",
            
            
            
            
            
            "date_published": "2021-09-22T00:00:00+08:00",
            "date_modified": "2021-09-22T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/09/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B043",
            "title": "读书笔记(四十三) 《游戏引擎架构》#2 容器、内存、RTTI与反射",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：作为游戏开发从业者，从业务到语言到框架到引擎，积累了一些知识和经验，特别是在看了好几遍《游戏引擎架构》后对引擎的架构感触颇深。近段时间对引擎剖析的想法也较多，正好借着书本对游戏引擎架构做一个完整分析。此书用简明、清楚的方式覆盖了游戏引擎架构的庞大领域，巧妙地平衡了广度与深度，并且提供了足够的细节，使得初学者也能很容易地理解其中的各种概念。目标是掌握游戏引擎架构知识，方法是跟随《游戏引擎架构》这本书、结合引擎源码、自己的经验，分析游戏引擎的历史、架构、模块。最后通过实践自主引擎的开发来完成对引擎知识的掌握。游戏引擎知识面深而广，所以对这系列的文章书编写范围做个保护，即不对细节进行过多的阐述，重点剖析的是架构、流程以及模块的运作原理。虽然参考了《游戏引擎架构》这本书，但由于它的部分知识太陈旧，所以我不得不将这些知识重新深挖后总结自己的观点。概述：本章开始对引擎中的重要的模块和库进行详细的分析，我挑选了十五个库和模块来分析：  时间库  自定义容器库  字符串散列库  内存管理框架  RTTI与反射模块  图形计算库  资产管理模块  低阶渲染器  剔除与合批模块  动画模块  物理模块  UI核心框架  性能剖析器的核心部分  脚本系统  视觉效果模块本篇内容为列表中的前五个。正文：由易到难，我们从最简单的说起。时间库时间库最简单使用的也最多，在引擎中的每个模块都会使用到。其时间信息包括：真实时间、游戏时间、全局时间、相对时间，时间缩放因子。其常见问题为各平台的时间获取方式不同，因此基本都会针对每个平台分别实现一个时间获取函数。测量时间在时间库中占重要位置，游戏中循环调用间隔、帧率、以及移动速度都会使用时间测量的单位来进行。通常引擎都会用帧率调控的方法来稳定帧率，例如我们在引擎上设置了30帧/s，那么当本帧耗时小于33ms时，则在主循环结束时让线程在剩下的时间里休眠。反之，如果主循环耗时大于33ms，则等待到下一帧再执行。通过这样调控的方式来稳定帧率。垂直同步是另一种帧率调控方法，由于前置缓冲区和后置缓冲区在交换时会有部分消隐问题导致画面撕裂，因此垂直同步会等待消隐时间，错过了则等待下一次消隐区间，这会让画面更加稳定，但并不保证以某个特定帧率运行而且时常会降低帧率，因此很少有游戏使用这种技术。当使用测量时间时，通常都会以帧的形式更新时间跨度，例如计算每帧之间的时间、计算动画当前帧、移动速度下当前帧的移动距离等。除此之外，最常用的如最大帧率、固定帧率、全局时间缩放等，这些因子在很多引擎模块中也常会用到，例如动画时间、音频时间，粒子生命时间等。自定义容器库我们在使用的各式各样集合型数据结构也被称为容器，它们的任务都是一样的，存储及管理多个数据元素。然而细节上各种容器运行方式会有一些差异，它们各自也有各自的优缺点。它们包括但不仅限于：  数组（Array）  动态数组（Dynamic Array）  链表（Linked List）  堆栈（Stack）  队列（Queue）  双端队列（Double-ended Queue）  优先队列（Priority Queue）  树（Tree）  二叉查找树（Binary Search Tree，BST）  二叉堆（Binary Heap）  字典（Dictionary）  集合（Set）  图（Graph）  有向无环图（Directed Acyclic Graph，DAG）我们在操作容器时，常用的操作有：插入、移除、顺序访问（迭代）、随机访问、查找、排序。这里介绍下第三方标准库的优缺点：  STL，功能丰富、可移植能力强，但内存分配效率差一些，部分容器算法性能较差。  Boost，在STL上更多功能、效率高，发布许可证有些问题。  Loki，功能丰富，复杂度较高，性能未知。许多引擎都会提供常见的自定义容器实现，建立自定义容器类一般都处于如下原因：  完全掌控：控制数据结构的内存需求、使用的算法、内存分配规则。  优化性能：针对某个业务做出适合性的调整，或借助某些硬件功能可以优化数据结构和算法。  可定制性：根据业务需要增加第三方库没有的功能、例如容器性能调试、内存统计、内存快照等。  消除外部依赖：当第三方库出现问题时，需要依赖外部的团队，这可能无法提供及时的服务。自定义容器，能在库出现问题时做到可自行修复。  并发同步：常用第三方容器在线程间并发同步上的操作可能没有你想的那么完美，用自定义容器就能为自己定制更合适的同步机制。Unreal容器一看名字就知道是什么，它们包括：TArray、TArrayView、TBasicArray、FBinaryHeap、TBitArray、TChunkedArray、TCircularBuffer、TCircularQueue、TDiscardableKeyValueCache、TResourceArray、FHashTable、TIndirectArray、TLinkedList、TIntrusiveLinkedList、TDoubleLinkedList、TList、TMapBase、TSortableMapBase、TQueue、FScriptArray、TSet、TSortedMap、TSparseArray、TStaticArray、TStaticBitArray、TTripleBuffer、TUnion等等Unity容器方面基本上与Unreal差不多，Unreal有的Unity也基本有，各自也都有一些特殊用途的容器，只是这些容器代码分散较开，说明容器部分的架构Unity编排的相对混乱一些。字符串散列库字符串在程序中占据了很大的内存，通常有这三个问题，  拷贝多  拼接多  判断相同字符串拷贝多，原因：在函数的形参和返回值上，常常会使用实例的方式去做，这导致字符串拷贝变的频繁。每次字符串拷贝都需要经历，内存分配，内存拷贝，内存销毁这三步骤，可想而知字符串在拷贝上的消耗非常大。拷贝多，解决方案：通常是由于业务代码引起的，因此也只有调整业务代码才能缓解。包括修改函数形参类型和返回值类型。拼接多，原因：每个字符串在拼接完毕后通常都会生成一个临时的新的字符串，这导致拼接的那几个字符串内存被丢弃而浪费。拼接多，解决方案：1.编码规范问题，具体业务具体分析2.用对象池方式重复利用内存判断相同字符串，原因：相同字符串的判断逻辑在代码中占比通常比较大，特别是在业务逻辑中。如果只是单纯的比较两个字符串的每个字符，效率会变得非常低下判断相同字符串，解决方案：使用HashID就能解决这个问题，即把字符串计算成Hash值，用数字比较来代替字符串比较。注意，并不是一定要让字符串做Hash才能增加效率，如果相同字符的判断操作比较少，而Hash计算和加入容器的操作比较多，那么就会得不偿失。Unreal引擎的字符串FString构建：1.用TArray动态数组作为容器2.通过TArray扩容构建和拼接字符串3.TArray使用专门的内存块作为管理，能做到提前分配和释放回池Unreal引擎字符串的FName：1.FName和FString有些不同，FName有HashID，是含有一个uint32整数的结构体，而FString则没有2.FName的字符串存储在FNameEntry实例中3.每个FName都有自己的HashID，用于比较相同的字符串4.FNameEntry是一个Char数组+HashID+Header的实例5.通过FNamePool存储FNameEntry，FNamePool就是一个字典容器，存储着所有的FNameEntry实例6.FName通过HashID从对象池中获得字符串实体FNameEntry7.也可以直接通过HashID比较两个字符串是否相同，从而提高效率Unity与Unreal不同，使用对象池方式重复利用字符串内存，并且没有字符串散列机制（因为引擎内部不需要）。内存管理框架先介绍下操作系统自身的内存管理方式：1.操作系统以进程为单位来运行每个程序。2.同时为每个进程分配了一个独立的虚拟空间。3.每个虚拟空间里有内核空间和用户空间之分。4.内核空间为共享库和内核程序使用的堆栈空间。5.每个虚拟空间都会拆分成多个段来存储各类数据和程序指令6.虚拟内存和物理内存之间使用页表进行映射，因此在虚拟空间中连续的内存在物理空间中不一定连续。7.操作系统会将不使用的内存块交换（Swap）出去成为硬盘空间的一部分，当需要访问时再交换（Swap）回来。下面我画了3个图，用图来解释会更容易理解些：图1图2图3以上三张图完整的体现了操作系统内存的运作方式。1.图1描述了，每个进程都有各自的独立虚拟空间，分为用户空间和内核空间，并且32位和64的空间大小不同。2.图2描述了，一个虚拟空间中有很多个段，其中包括栈段、堆段、代码段、数据段等。3.图3描述了，虚拟内存和物理内存通过页表映射，物理内容与硬盘会有一个Swap机制。写程序时我们比较关心堆内存，那么操作系统是如何管理堆内存的呢？我们来了解下堆内存的分配和释放机制图1：图2：图3：为了快速学习，画了三张图方便大家理解堆内存分配机制：1.图1描述了，堆内存会切割成不同的块2.图2描述了，堆内存分配设计为大堆、小堆和缓冲堆3.图3描述了，堆内存分配流程，先找索引再从缓冲区中找最后切割大块内存一句话概括为，堆内存以分块方式切割设计，并分为大堆、小堆、和缓冲堆，通过索引和缓冲区来加速内存的分配和释放。游戏引擎中通常不依赖操作系统内存分配机制，原因是对于引擎来说操作系统的内存分配效率太差，因此每个引擎都有自建的内存管理框架。自建的内存管理框架通常由一些分配规则构成，这些分配规则通常会写成内存分配器（Allocator）被用于引擎的各个模块中。虽然内存管理框架有很多种，但内存分配的规则都是相似的，每一种内存分配规则我们称为内存分配器（Allocator），下面我们简单列举一下内存分配器的种类及其规则。这里列举了11种（还有更多）内存分配器并分别用一句话概括它们：  线性内存分配器，分配一块大内存，并不断向前分配。  环形内存分配器，支持循环利用的内存分配器。  双端内存分配器，两个模块共享一个线性内存分配，并从两端分别进行分配。  固定大小内存分配器，把一大块内存拆分成固定大小的N个内存块，每次分配一块。  泛化的固定大小内存分配器，拆分成M个大块内存，每个大块内存都有自己固定大小的N个内存块， 且不同块间的小内存块的大小不同。  散列式页内存分配器，按某个固定大小的页拆分内存块，用多叉树索引方式连接内存块，一次分配多页并调整树形索引。  栈型内存分配器，不断向前分配，并按先进后出的原则回收内存。  动态合并内存分配器，从一大块内存块开始分配，分配时不断切割，并在回收时合并相邻的内存块。  大小池内存分配器，有大内存池和小内存池之分，大小内存池的分配策略不同，小内存池通常使用泛型固定大小内存分配规则，大内存池由于分配频率低因此分配方式更自由些，可切割可固定可合并。  批量内存分配器，多次连续分配多个小内存，先临时分配并立即使用，最后提交锁定内存区间。  线程安全的内存分配器，在分配时加入了更多的原子操作或同步锁，让多个同线程可以共享一个内存块。引擎内存管理框架不同种类的引擎中的内存框架其实都是大同小异：1.大都使用内存分配器来搭建内存框架2.多种类型的内存分配器混合使用很常见3.每个模块都有自己的内存分配器4.经常多个模块共享一个内存分配器Unreal引擎的内存分配框架Unreal有个HAL（Hardware Abstraction Layer）存放了大部分内存管理内容。用图来表示为：Unreal的内存管理框架总结：1.Unreal有统一的内存分配和释放接口FMemory2.内存统计，使用的是获取堆栈、回溯堆栈信息的方式3.虽然内存分配器有很多种，但主内存分配器只能选择一种4.容器有自己专属的分配器，它封装了FMemory接口5.UObject等业务逻辑有专属的分配器，它封装了FMemory接口，并在此基础上做了垃圾回收设计。6.引擎各模块大部分使用了FMemory接口来分配和释放内存，少数封装了自己的分配器。7.主内存分配器中FMallocBinned为主内存分配器（1、2、3代），其分配原则为大小内存池。Unity与Unreal稍有不同，它将GC和引擎内存分开管理，并且引擎独立模块有独立内存分配器自己管理。理论上来说这种做法会更好一些，每个模块需要有合适的内存分配算法。RTTI与反射模块RTTI(Run-Time Type Information)运行时类型检查，它提供了运行时确定对象类型的方法。C++内建的RTTI通常很难满足我们的业务需求，特别是在需要做反射的业务上尤其明显，因此引擎通常都需要自建RTTI并增加反射系统。先说C++内建的RTTI。与内建RTTI相关的运算符为：typeid 和 dynamic_cast快速回顾下typeid 和 dynamic_cast两个运算符的原理我在前面的文章中详细介绍过C++内存模型，可以参考下《深度探索C++对象模型》每个有虚继承或虚函数的C++类都会在运行时有一个type_info数据，通过虚表中的指针指向type_info数据。type_info数据结构包含了类名字和父类指针，因此我们可以通过typeid来获得多态类的type_info数据。dynamic_cast就是借助type_info来做的功能，它通过多态的type_info来识别是否可以转换类型。例如：Point2D pt2d = dynamic_cast&lt;Point2D&gt;(pt);可以拆解为：Point2D pt2d = NULL;type_info type_pt2d = typeid(Point2D);type_info type_pt = typeid(Point);if(type_pt2d == type_pt || type_pt.before(&amp;type_pt2d)){        pt2d = (Point2D)pt;}return pt2d;自建RTTI由于内置C++的RTTI时常无法满足业务需求，所以通常人们都会自己去建立自己的RTTI。人们自建RTTI通常是因为：1.有反射需求，例如查找类、调用函数、获取变量、遍历属性等。2.优化性能，包括减少RTTI内存，提高查找type_info效率等。Unreal引擎内部RTTI是默认被禁用的，它通过枚举或整数的方式来定制需要识别的类型。Unity也是一样，在引擎内核中，无法使用内置的RTTI。禁用仅限于引擎实时运行库上，在工具套件和编辑器上仍然被使用。反射模块反射模块是建立在自建RTTI之上的，因为反射需要通过RTTI来获取足够多的类、变量、函数的信息。通常当我们通过RTTI来建立反射框架时，通常需要对type信息结构做些规划。例如在type结构中增加动态数组或字典容器将变量和函数的名字和类型存储起来。示例代码例如：struct RTTR_LOCAL class_data{    class_data(get_derived_info_func func, std::vector&lt;type&gt; nested_types)    :   m_derived_info_func(func),        m_nested_types(nested_types),        m_dtor(create_invalid_item&lt;destructor&gt;())    {}    get_derived_info_func       m_derived_info_func;    std::vector&lt;type&gt;           m_base_types;    std::vector&lt;type&gt;           m_derived_types;    std::vector&lt;rttr_cast_func&gt; m_conversion_list;    std::vector&lt;property&gt;       m_properties;    std::vector&lt;method&gt;         m_methods;    std::vector&lt;constructor&gt;    m_ctors;    std::vector&lt;type&gt;           m_nested_types;    destructor                  m_dtor;};如上代码中我们看到，type实例结构中通常有属性结构实例容器、类型结构实例容器、函数结构实例容器等，目的就是为了存储变量和函数的信息。在实时运行过程中，当我们需要用字符串查找某个函数，或者查找某个变量时，则会从这些容器中去查找。自建RTTI是通过对象信息来构建RTTI信息集合代码的，因此每个需要RTTI类的实例都需要写相应的编码，通常都会用宏和自动化来代替繁琐的实例化RTTI编码。其基本思想是采用宏来代替常规的变量定义，这样我们就可以在宏函数中将定义的变量添加至自建的反射系统。例如：#include &lt;rttr/registration&gt;using namespace rttr;struct MyStruct { MyStruct() {}; void func(double) {}; int data; };RTTR_REGISTRATION{    registration::class_&lt;MyStruct&gt;(\"MyStruct\")         .constructor&lt;&gt;()         .property(\"data\", &amp;MyStruct::data)         .method(\"func\", &amp;MyStruct::func);}Unreal的RTTI和反射用途较多，主要包括蓝图和垃圾回收。与其他所有引擎一样，Unreal生成反射代码的步骤是：1.利用特殊的宏来对变量做标记2.对C++代码文件进行语法分析3.用指定的宏提取出对应的数据4.扫描工具生成RTTI代码5.最后在初始化时运行生成的代码6.启动时将收集到的数据保存UE4定义了一系列的宏，来帮助开发者将自定义的字段和函数添加至反射系统：UCLASS，告诉UE这个类是一个反射类。类必须派生自UObjectUSTRUCT，可以不用派生自UObject。不支持GC，也不能包含函数UPROPERTY，定义一个反射的变量UFUNCTION，定义一个反射的函数UENUM，告诉UE这是一个反射的枚举类。支持enum, enum class, enum namespaceUINTERFACE，定义一个反射接口类，只能包含函数UMETA，反射的一些元数据定义，可以通过标签定义一些该变量的属性UPARAM，定义函数的参数属性。主要就是显示名字和Ref属性UDELEGATE，告诉UE这是一个可反射的delegate例如：// 一定要声明UCLASSUCLASS()class MYGAME_API UMyClass : public UObject{    GENERATED_BODY()    public:        // 定义一个可反射的函数        UFUNCTION(BluprintCallable)        void MyFunc();private:        // 定义一个可反射的变量        UPROPERTY(EditAnywhere, BlueprintReadWrite, meta=(AllowPrivateAccess = \"true\"))        int MyIntValue;}通过声明反射将数据结构、变量和函数添加到反射中。UE4的UHT（Unreal Header Tool）模块扫描之后生成的代码反射两个代码文件：.generated.h文件：重载各种操作符函数，声明各种构造函数。.gen.cpp文件：单例实现，构造UClass（提取信息并注册）Unity与Unreal的稍有不同，一部分为C++调用Mono，另一部分为C#利用反射调用具体的函数。1.C++通过Mono获取C#接口2.反过来C#调用C++则不需要反射。可以通过数组将C++句柄存储起来，用索引获取句柄的方式调用。3.C#使用反射调用C#代码则比较常见，在编辑器与业务逻辑交互之间会比较多。参考资料：《动态链接与装载》https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484788&amp;idx=1&amp;sn=8e4f7f36e4ddf6dd2f7c086463c089de&amp;chksm=fc226073cb55e965e5ab259f04293c48f718a2fd72858b11397852d8ba8c7fab656b0f46e248&amp;token=283688006&amp;lang=zh_CN#rd《深度探索C++对象模型》http://luzexi.com/2020/11/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B014《malloc和free的实现原理解析》https://jacktang816.github.io/post/mallocandfree/《UE4 反射系统详细剖析》https://cloud.tencent.com/developer/article/1606872《UE4内存分配器概述》https://www.cnblogs.com/kekec/p/12012537.html《RTTR C++ Reflection Library》https://github.com/rttrorg/rttr《UE4 MallocBinned2分配器》https://zhuanlan.zhihu.com/p/79715624《FMallocBinned2内存分配器》https://www.cnblogs.com/kekec/p/14675228.html《UE4垃圾回收》https://zhuanlan.zhihu.com/p/67055774《UE4蓝图》https://zhuanlan.zhihu.com/p/67683606已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484906&amp;idx=1&amp;sn=70443040745649b082a93650d180959e&amp;chksm=fc2260edcb55e9fb318468bd6f0ce4b2df2277338c3aeb1d0f31b00e4dcd01c18fba4b75581b&amp;token=2034706848&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h1 id=\"背景\">背景：</h1><p>作为游戏开发从业者，从业务到语言到框架到引擎，积累了一些知识和经验，特别是在看了好几遍《游戏引擎架构》后对引擎的架构感触颇深。</p><p>近段时间对引擎剖析的想法也较多，正好借着书本对游戏引擎架构做一个完整分析。此书用简明、清楚的方式覆盖了游戏引擎架构的庞大领域，巧妙地平衡了广度与深度，并且提供了足够的细节，使得初学者也能很容易地理解其中的各种概念。</p><p>目标是掌握游戏引擎架构知识，方法是跟随《游戏引擎架构》这本书、结合引擎源码、自己的经验，分析游戏引擎的历史、架构、模块。最后通过实践自主引擎的开发来完成对引擎知识的掌握。</p><p>游戏引擎知识面深而广，所以对这系列的文章书编写范围做个保护，即不对细节进行过多的阐述，重点剖析的是架构、流程以及模块的运作原理。</p><p>虽然参考了《游戏引擎架构》这本书，但由于它的部分知识太陈旧，所以我不得不将这些知识重新深挖后总结自己的观点。</p><h1 id=\"概述\">概述：</h1><p>本章开始对引擎中的重要的模块和库进行详细的分析，我挑选了十五个库和模块来分析：</p><ol>  <li>时间库</li>  <li>自定义容器库</li>  <li>字符串散列库</li>  <li>内存管理框架</li>  <li>RTTI与反射模块</li>  <li>图形计算库</li>  <li>资产管理模块</li>  <li>低阶渲染器</li>  <li>剔除与合批模块</li>  <li>动画模块</li>  <li>物理模块</li>  <li>UI核心框架</li>  <li>性能剖析器的核心部分</li>  <li>脚本系统</li>  <li>视觉效果模块</li></ol><p>本篇内容为列表中的前五个。</p><h1 id=\"正文\">正文：</h1><p>由易到难，我们从最简单的说起。</p><h2 id=\"时间库\">时间库</h2><p>时间库最简单使用的也最多，在引擎中的每个模块都会使用到。其时间信息包括：真实时间、游戏时间、全局时间、相对时间，时间缩放因子。其常见问题为各平台的时间获取方式不同，因此基本都会针对每个平台分别实现一个时间获取函数。</p><p>测量时间在时间库中占重要位置，游戏中循环调用间隔、帧率、以及移动速度都会使用时间测量的单位来进行。</p><p>通常引擎都会用帧率调控的方法来稳定帧率，例如我们在引擎上设置了30帧/s，那么当本帧耗时小于33ms时，则在主循环结束时让线程在剩下的时间里休眠。反之，如果主循环耗时大于33ms，则等待到下一帧再执行。通过这样调控的方式来稳定帧率。</p><p>垂直同步是另一种帧率调控方法，由于前置缓冲区和后置缓冲区在交换时会有部分消隐问题导致画面撕裂，因此垂直同步会等待消隐时间，错过了则等待下一次消隐区间，这会让画面更加稳定，但并不保证以某个特定帧率运行而且时常会降低帧率，因此很少有游戏使用这种技术。</p><p>当使用测量时间时，通常都会以帧的形式更新时间跨度，例如计算每帧之间的时间、计算动画当前帧、移动速度下当前帧的移动距离等。除此之外，最常用的如最大帧率、固定帧率、全局时间缩放等，这些因子在很多引擎模块中也常会用到，例如动画时间、音频时间，粒子生命时间等。</p><h2 id=\"自定义容器库\">自定义容器库</h2><p>我们在使用的各式各样集合型数据结构也被称为容器，它们的任务都是一样的，存储及管理多个数据元素。然而细节上各种容器运行方式会有一些差异，它们各自也有各自的优缺点。它们包括但不仅限于：</p><ol>  <li>数组（Array）</li>  <li>动态数组（Dynamic Array）</li>  <li>链表（Linked List）</li>  <li>堆栈（Stack）</li>  <li>队列（Queue）</li>  <li>双端队列（Double-ended Queue）</li>  <li>优先队列（Priority Queue）</li>  <li>树（Tree）</li>  <li>二叉查找树（Binary Search Tree，BST）</li>  <li>二叉堆（Binary Heap）</li>  <li>字典（Dictionary）</li>  <li>集合（Set）</li>  <li>图（Graph）</li>  <li>有向无环图（Directed Acyclic Graph，DAG）</li></ol><p>我们在操作容器时，常用的操作有：插入、移除、顺序访问（迭代）、随机访问、查找、排序。</p><p>这里介绍下第三方标准库的优缺点：</p><ul>  <li>STL，功能丰富、可移植能力强，但内存分配效率差一些，部分容器算法性能较差。</li>  <li>Boost，在STL上更多功能、效率高，发布许可证有些问题。</li>  <li>Loki，功能丰富，复杂度较高，性能未知。</li></ul><p>许多引擎都会提供常见的自定义容器实现，建立自定义容器类一般都处于如下原因：</p><ol>  <li>完全掌控：控制数据结构的内存需求、使用的算法、内存分配规则。</li>  <li>优化性能：针对某个业务做出适合性的调整，或借助某些硬件功能可以优化数据结构和算法。</li>  <li>可定制性：根据业务需要增加第三方库没有的功能、例如容器性能调试、内存统计、内存快照等。</li>  <li>消除外部依赖：当第三方库出现问题时，需要依赖外部的团队，这可能无法提供及时的服务。自定义容器，能在库出现问题时做到可自行修复。</li>  <li>并发同步：常用第三方容器在线程间并发同步上的操作可能没有你想的那么完美，用自定义容器就能为自己定制更合适的同步机制。</li></ol><p>Unreal容器一看名字就知道是什么，它们包括：TArray、TArrayView、TBasicArray、FBinaryHeap、TBitArray、TChunkedArray、TCircularBuffer、TCircularQueue、TDiscardableKeyValueCache、TResourceArray、FHashTable、TIndirectArray、TLinkedList、TIntrusiveLinkedList、TDoubleLinkedList、TList、TMapBase、TSortableMapBase、TQueue、FScriptArray、TSet、TSortedMap、TSparseArray、TStaticArray、TStaticBitArray、TTripleBuffer、TUnion等等</p><p>Unity容器方面基本上与Unreal差不多，Unreal有的Unity也基本有，各自也都有一些特殊用途的容器，只是这些容器代码分散较开，说明容器部分的架构Unity编排的相对混乱一些。</p><h2 id=\"字符串散列库\">字符串散列库</h2><p>字符串在程序中占据了很大的内存，通常有这三个问题，</p><ol>  <li>拷贝多</li>  <li>拼接多</li>  <li>判断相同字符串</li></ol><h3 id=\"拷贝多原因\">拷贝多，原因：</h3><p>在函数的形参和返回值上，常常会使用实例的方式去做，这导致字符串拷贝变的频繁。每次字符串拷贝都需要经历，内存分配，内存拷贝，内存销毁这三步骤，可想而知字符串在拷贝上的消耗非常大。</p><h3 id=\"拷贝多解决方案\">拷贝多，解决方案：</h3><p>通常是由于业务代码引起的，因此也只有调整业务代码才能缓解。包括修改函数形参类型和返回值类型。</p><h3 id=\"拼接多原因\">拼接多，原因：</h3><p>每个字符串在拼接完毕后通常都会生成一个临时的新的字符串，这导致拼接的那几个字符串内存被丢弃而浪费。</p><h3 id=\"拼接多解决方案\">拼接多，解决方案：</h3><p>1.编码规范问题，具体业务具体分析2.用对象池方式重复利用内存</p><h3 id=\"判断相同字符串原因\">判断相同字符串，原因：</h3><p>相同字符串的判断逻辑在代码中占比通常比较大，特别是在业务逻辑中。如果只是单纯的比较两个字符串的每个字符，效率会变得非常低下</p><h3 id=\"判断相同字符串解决方案\">判断相同字符串，解决方案：</h3><p>使用HashID就能解决这个问题，即把字符串计算成Hash值，用数字比较来代替字符串比较。</p><p>注意，并不是一定要让字符串做Hash才能增加效率，如果相同字符的判断操作比较少，而Hash计算和加入容器的操作比较多，那么就会得不偿失。</p><h4 id=\"unreal引擎的字符串fstring构建\">Unreal引擎的字符串FString构建：</h4><p>1.用TArray<TCHAR>动态数组作为容器2.通过TArray<TCHAR>扩容构建和拼接字符串3.TArray<TCHAR>使用专门的内存块作为管理，能做到提前分配和释放回池</TCHAR></TCHAR></TCHAR></p><h3 id=\"unreal引擎字符串的fname\">Unreal引擎字符串的FName：</h3><p>1.FName和FString有些不同，FName有HashID，是含有一个uint32整数的结构体，而FString则没有2.FName的字符串存储在FNameEntry实例中3.每个FName都有自己的HashID，用于比较相同的字符串4.FNameEntry是一个Char数组+HashID+Header的实例5.通过FNamePool存储FNameEntry，FNamePool就是一个字典容器，存储着所有的FNameEntry实例6.FName通过HashID从对象池中获得字符串实体FNameEntry7.也可以直接通过HashID比较两个字符串是否相同，从而提高效率</p><h3 id=\"unity与unreal不同使用对象池方式重复利用字符串内存并且没有字符串散列机制因为引擎内部不需要\">Unity与Unreal不同，使用对象池方式重复利用字符串内存，并且没有字符串散列机制（因为引擎内部不需要）。</h3><h2 id=\"内存管理框架\">内存管理框架</h2><p>先介绍下操作系统自身的内存管理方式：</p><p>1.操作系统以进程为单位来运行每个程序。2.同时为每个进程分配了一个独立的虚拟空间。3.每个虚拟空间里有内核空间和用户空间之分。4.内核空间为共享库和内核程序使用的堆栈空间。5.每个虚拟空间都会拆分成多个段来存储各类数据和程序指令6.虚拟内存和物理内存之间使用页表进行映射，因此在虚拟空间中连续的内存在物理空间中不一定连续。7.操作系统会将不使用的内存块交换（Swap）出去成为硬盘空间的一部分，当需要访问时再交换（Swap）回来。</p><p>下面我画了3个图，用图来解释会更容易理解些：</p><p>图1</p><p>图2</p><p>图3</p><p>以上三张图完整的体现了操作系统内存的运作方式。</p><p>1.图1描述了，每个进程都有各自的独立虚拟空间，分为用户空间和内核空间，并且32位和64的空间大小不同。2.图2描述了，一个虚拟空间中有很多个段，其中包括栈段、堆段、代码段、数据段等。3.图3描述了，虚拟内存和物理内存通过页表映射，物理内容与硬盘会有一个Swap机制。</p><p>写程序时我们比较关心堆内存，那么操作系统是如何管理堆内存的呢？</p><p>我们来了解下堆内存的分配和释放机制</p><p>图1：</p><p>图2：</p><p>图3：</p><p>为了快速学习，画了三张图方便大家理解堆内存分配机制：1.图1描述了，堆内存会切割成不同的块2.图2描述了，堆内存分配设计为大堆、小堆和缓冲堆3.图3描述了，堆内存分配流程，先找索引再从缓冲区中找最后切割大块内存</p><p>一句话概括为，堆内存以分块方式切割设计，并分为大堆、小堆、和缓冲堆，通过索引和缓冲区来加速内存的分配和释放。</p><h3 id=\"游戏引擎中通常不依赖操作系统内存分配机制原因是对于引擎来说操作系统的内存分配效率太差因此每个引擎都有自建的内存管理框架\">游戏引擎中通常不依赖操作系统内存分配机制，原因是对于引擎来说操作系统的内存分配效率太差，因此每个引擎都有自建的内存管理框架。</h3><p>自建的内存管理框架通常由一些分配规则构成，这些分配规则通常会写成内存分配器（Allocator）被用于引擎的各个模块中。</p><p>虽然内存管理框架有很多种，但内存分配的规则都是相似的，每一种内存分配规则我们称为内存分配器（Allocator），下面我们简单列举一下内存分配器的种类及其规则。</p><p>这里列举了11种（还有更多）内存分配器并分别用一句话概括它们：</p><ol>  <li>线性内存分配器，分配一块大内存，并不断向前分配。</li>  <li>环形内存分配器，支持循环利用的内存分配器。</li>  <li>双端内存分配器，两个模块共享一个线性内存分配，并从两端分别进行分配。</li>  <li>固定大小内存分配器，把一大块内存拆分成固定大小的N个内存块，每次分配一块。</li>  <li>泛化的固定大小内存分配器，拆分成M个大块内存，每个大块内存都有自己固定大小的N个内存块， 且不同块间的小内存块的大小不同。</li>  <li>散列式页内存分配器，按某个固定大小的页拆分内存块，用多叉树索引方式连接内存块，一次分配多页并调整树形索引。</li>  <li>栈型内存分配器，不断向前分配，并按先进后出的原则回收内存。</li>  <li>动态合并内存分配器，从一大块内存块开始分配，分配时不断切割，并在回收时合并相邻的内存块。</li>  <li>大小池内存分配器，有大内存池和小内存池之分，大小内存池的分配策略不同，小内存池通常使用泛型固定大小内存分配规则，大内存池由于分配频率低因此分配方式更自由些，可切割可固定可合并。</li>  <li>批量内存分配器，多次连续分配多个小内存，先临时分配并立即使用，最后提交锁定内存区间。</li>  <li>线程安全的内存分配器，在分配时加入了更多的原子操作或同步锁，让多个同线程可以共享一个内存块。</li></ol><h2 id=\"引擎内存管理框架\">引擎内存管理框架</h2><p>不同种类的引擎中的内存框架其实都是大同小异：</p><p>1.大都使用内存分配器来搭建内存框架2.多种类型的内存分配器混合使用很常见3.每个模块都有自己的内存分配器4.经常多个模块共享一个内存分配器</p><h2 id=\"unreal引擎的内存分配框架\">Unreal引擎的内存分配框架</h2><p>Unreal有个HAL（Hardware Abstraction Layer）存放了大部分内存管理内容。</p><p>用图来表示为：</p><p>Unreal的内存管理框架总结：</p><p>1.Unreal有统一的内存分配和释放接口FMemory2.内存统计，使用的是获取堆栈、回溯堆栈信息的方式3.虽然内存分配器有很多种，但主内存分配器只能选择一种4.容器有自己专属的分配器，它封装了FMemory接口5.UObject等业务逻辑有专属的分配器，它封装了FMemory接口，并在此基础上做了垃圾回收设计。6.引擎各模块大部分使用了FMemory接口来分配和释放内存，少数封装了自己的分配器。7.主内存分配器中FMallocBinned为主内存分配器（1、2、3代），其分配原则为大小内存池。</p><p>Unity与Unreal稍有不同，它将GC和引擎内存分开管理，并且引擎独立模块有独立内存分配器自己管理。理论上来说这种做法会更好一些，每个模块需要有合适的内存分配算法。</p><h2 id=\"rtti与反射模块\">RTTI与反射模块</h2><p>RTTI(Run-Time Type Information)运行时类型检查，它提供了运行时确定对象类型的方法。</p><p>C++内建的RTTI通常很难满足我们的业务需求，特别是在需要做反射的业务上尤其明显，因此引擎通常都需要自建RTTI并增加反射系统。</p><p>先说C++内建的RTTI。与内建RTTI相关的运算符为：typeid 和 dynamic_cast</p><p>快速回顾下typeid 和 dynamic_cast两个运算符的原理</p><p>我在前面的文章中详细介绍过C++内存模型，可以参考下</p><p><a href=\"http://luzexi.com/2020/11/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B014\">《深度探索C++对象模型》</a></p><p>每个有虚继承或虚函数的C++类都会在运行时有一个type_info数据，通过虚表中的指针指向type_info数据。</p><p>type_info数据结构包含了类名字和父类指针，因此我们可以通过typeid来获得多态类的type_info数据。</p><p>dynamic_cast就是借助type_info来做的功能，它通过多态的type_info来识别是否可以转换类型。</p><p>例如：</p><pre><code>Point2D pt2d = dynamic_cast&lt;Point2D&gt;(pt);可以拆解为：Point2D pt2d = NULL;type_info type_pt2d = typeid(Point2D);type_info type_pt = typeid(Point);if(type_pt2d == type_pt || type_pt.before(&amp;type_pt2d)){        pt2d = (Point2D)pt;}return pt2d;</code></pre><h2 id=\"自建rtti\">自建RTTI</h2><p>由于内置C++的RTTI时常无法满足业务需求，所以通常人们都会自己去建立自己的RTTI。</p><p>人们自建RTTI通常是因为：</p><p>1.有反射需求，例如查找类、调用函数、获取变量、遍历属性等。2.优化性能，包括减少RTTI内存，提高查找type_info效率等。</p><p>Unreal引擎内部RTTI是默认被禁用的，它通过枚举或整数的方式来定制需要识别的类型。Unity也是一样，在引擎内核中，无法使用内置的RTTI。</p><p>禁用仅限于引擎实时运行库上，在工具套件和编辑器上仍然被使用。</p><h2 id=\"反射模块\">反射模块</h2><p>反射模块是建立在自建RTTI之上的，因为反射需要通过RTTI来获取足够多的类、变量、函数的信息。</p><p>通常当我们通过RTTI来建立反射框架时，通常需要对type信息结构做些规划。例如在type结构中增加动态数组或字典容器将变量和函数的名字和类型存储起来。</p><p>示例代码例如：</p><pre><code>struct RTTR_LOCAL class_data{    class_data(get_derived_info_func func, std::vector&lt;type&gt; nested_types)    :   m_derived_info_func(func),        m_nested_types(nested_types),        m_dtor(create_invalid_item&lt;destructor&gt;())    {}    get_derived_info_func       m_derived_info_func;    std::vector&lt;type&gt;           m_base_types;    std::vector&lt;type&gt;           m_derived_types;    std::vector&lt;rttr_cast_func&gt; m_conversion_list;    std::vector&lt;property&gt;       m_properties;    std::vector&lt;method&gt;         m_methods;    std::vector&lt;constructor&gt;    m_ctors;    std::vector&lt;type&gt;           m_nested_types;    destructor                  m_dtor;};</code></pre><p>如上代码中我们看到，type实例结构中通常有属性结构实例容器、类型结构实例容器、函数结构实例容器等，目的就是为了存储变量和函数的信息。在实时运行过程中，当我们需要用字符串查找某个函数，或者查找某个变量时，则会从这些容器中去查找。</p><p>自建RTTI是通过对象信息来构建RTTI信息集合代码的，因此每个需要RTTI类的实例都需要写相应的编码，通常都会用宏和自动化来代替繁琐的实例化RTTI编码。</p><p>其基本思想是采用宏来代替常规的变量定义，这样我们就可以在宏函数中将定义的变量添加至自建的反射系统。</p><p>例如：</p><pre><code>#include &lt;rttr/registration&gt;using namespace rttr;struct MyStruct { MyStruct() {}; void func(double) {}; int data; };RTTR_REGISTRATION{    registration::class_&lt;MyStruct&gt;(\"MyStruct\")         .constructor&lt;&gt;()         .property(\"data\", &amp;MyStruct::data)         .method(\"func\", &amp;MyStruct::func);}</code></pre><h3 id=\"unreal的rtti和反射用途较多主要包括蓝图和垃圾回收\">Unreal的RTTI和反射用途较多，主要包括蓝图和垃圾回收。</h3><p>与其他所有引擎一样，Unreal生成反射代码的步骤是：</p><p>1.利用特殊的宏来对变量做标记2.对C++代码文件进行语法分析3.用指定的宏提取出对应的数据4.扫描工具生成RTTI代码5.最后在初始化时运行生成的代码6.启动时将收集到的数据保存</p><p>UE4定义了一系列的宏，来帮助开发者将自定义的字段和函数添加至反射系统：</p><pre><code>UCLASS，告诉UE这个类是一个反射类。类必须派生自UObjectUSTRUCT，可以不用派生自UObject。不支持GC，也不能包含函数UPROPERTY，定义一个反射的变量UFUNCTION，定义一个反射的函数UENUM，告诉UE这是一个反射的枚举类。支持enum, enum class, enum namespaceUINTERFACE，定义一个反射接口类，只能包含函数UMETA，反射的一些元数据定义，可以通过标签定义一些该变量的属性UPARAM，定义函数的参数属性。主要就是显示名字和Ref属性UDELEGATE，告诉UE这是一个可反射的delegate</code></pre><p>例如：</p><pre><code>// 一定要声明UCLASSUCLASS()class MYGAME_API UMyClass : public UObject{    GENERATED_BODY()    public:        // 定义一个可反射的函数        UFUNCTION(BluprintCallable)        void MyFunc();private:        // 定义一个可反射的变量        UPROPERTY(EditAnywhere, BlueprintReadWrite, meta=(AllowPrivateAccess = \"true\"))        int MyIntValue;}</code></pre><p>通过声明反射将数据结构、变量和函数添加到反射中。</p><p>UE4的UHT（Unreal Header Tool）模块扫描之后生成的代码反射两个代码文件：</p><p>.generated.h文件：重载各种操作符函数，声明各种构造函数。.gen.cpp文件：单例实现，构造UClass（提取信息并注册）</p><p>Unity与Unreal的稍有不同，一部分为C++调用Mono，另一部分为C#利用反射调用具体的函数。</p><p>1.C++通过Mono获取C#接口2.反过来C#调用C++则不需要反射。可以通过数组将C++句柄存储起来，用索引获取句柄的方式调用。3.C#使用反射调用C#代码则比较常见，在编辑器与业务逻辑交互之间会比较多。</p><h3 id=\"参考资料\">参考资料：</h3><p>《动态链接与装载》</p><p>https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484788&amp;idx=1&amp;sn=8e4f7f36e4ddf6dd2f7c086463c089de&amp;chksm=fc226073cb55e965e5ab259f04293c48f718a2fd72858b11397852d8ba8c7fab656b0f46e248&amp;token=283688006&amp;lang=zh_CN#rd</p><p>《深度探索C++对象模型》</p><p>http://luzexi.com/2020/11/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B014</p><p>《malloc和free的实现原理解析》</p><p>https://jacktang816.github.io/post/mallocandfree/</p><p>《UE4 反射系统详细剖析》</p><p>https://cloud.tencent.com/developer/article/1606872</p><p>《UE4内存分配器概述》</p><p>https://www.cnblogs.com/kekec/p/12012537.html</p><p>《RTTR C++ Reflection Library》</p><p>https://github.com/rttrorg/rttr</p><p>《UE4 MallocBinned2分配器》</p><p>https://zhuanlan.zhihu.com/p/79715624</p><p>《FMallocBinned2内存分配器》</p><p>https://www.cnblogs.com/kekec/p/14675228.html</p><p>《UE4垃圾回收》</p><p>https://zhuanlan.zhihu.com/p/67055774</p><p>《UE4蓝图》</p><p>https://zhuanlan.zhihu.com/p/67683606</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484906&amp;idx=1&amp;sn=70443040745649b082a93650d180959e&amp;chksm=fc2260edcb55e9fb318468bd6f0ce4b2df2277338c3aeb1d0f31b00e4dcd01c18fba4b75581b&amp;token=2034706848&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/09/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B043",
            
            
            
            "tags": ["读书笔记","前端技术"],
            
            "date_published": "2021-09-17T00:00:00+08:00",
            "date_modified": "2021-09-17T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/09/13/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A116",
            "title": "给女儿的信(十六) 如何练习表达",
            "summary": "女儿 教育 亲情",
            "content_text": "Hi Sharon Hi Anne，爸爸好想你们哟。爸爸给你们讲讲爸爸最近的状况好不好。爸爸最近在练习表达，爸爸最近觉得表达能力很重要，过去几年爸爸对这方面没有重视。现在才明白过来，表达是生活的第一要素，所以爸爸想更多的学习表达，并且在平时的时候运用表达。爸爸给自己设定了一个习惯，每天早上起来，做一次表达训练。怎么做表达训练呢，爸爸跟你说说。爸爸先做一个自我介绍，爸爸对着镜子介绍自己，大家好，我是陆泽西，大家可以叫我西西，很高兴见到大家。然后介绍我的爱好，我来自哪里，我喜欢看什么书。介绍完自己后，爸爸会自己跟自己说说自己昨天做了什么，今天打算做什么，最后要感恩谁。就这样，每天早起早起跟自己练习一遍，最近爸爸的表达能力提高不少呢。爸爸希望Sharon和Anne在平时的生活中能够流畅、清晰、舒服的表达出自己想要说的内容。跟爸爸一起加油好吗。加油Sharon、加油Anne，爸爸爱你们。",
            "content_html": "<p>Hi Sharon Hi Anne，爸爸好想你们哟。</p><p>爸爸给你们讲讲爸爸最近的状况好不好。</p><p>爸爸最近在练习表达，爸爸最近觉得表达能力很重要，过去几年爸爸对这方面没有重视。</p><p>现在才明白过来，表达是生活的第一要素，所以爸爸想更多的学习表达，并且在平时的时候运用表达。</p><p>爸爸给自己设定了一个习惯，每天早上起来，做一次表达训练。</p><p>怎么做表达训练呢，爸爸跟你说说。</p><p>爸爸先做一个自我介绍，爸爸对着镜子介绍自己，</p><p>大家好，我是陆泽西，大家可以叫我西西，很高兴见到大家。</p><p>然后介绍我的爱好，我来自哪里，我喜欢看什么书。</p><p>介绍完自己后，爸爸会自己跟自己说说自己昨天做了什么，今天打算做什么，最后要感恩谁。</p><p>就这样，每天早起早起跟自己练习一遍，最近爸爸的表达能力提高不少呢。</p><p>爸爸希望Sharon和Anne在平时的生活中能够流畅、清晰、舒服的表达出自己想要说的内容。</p><p>跟爸爸一起加油好吗。加油Sharon、加油Anne，爸爸爱你们。</p>",
            "url": "http://www.luzexi.com/2021/09/13/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A116",
            
            
            
            
            
            "date_published": "2021-09-13T00:00:00+08:00",
            "date_modified": "2021-09-13T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/08/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B042",
            "title": "读书笔记(四十二) 《游戏引擎架构》#1 历史、现状、架构、团队",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：作为游戏开发从业者，从业务到算法到语言到框架到引擎，积累了一些知识和经验，特别是在看了好几遍《游戏引擎架构》后对引擎的架构感触颇深。近段时间对引擎剖析的想法也较多，正好借着书本对游戏引擎架构做一个完整分析。此书用简明、清楚的方式覆盖了游戏引擎架构的庞大领域，巧妙地平衡了广度与深度，并且提供了足够的细节，使得初学者也能很容易地理解其中的各种概念。目标是掌握游戏引擎架构知识，方法是跟随《游戏引擎架构》这本书、结合引擎源码、自己的经验，分析游戏引擎的历史、架构、模块。最后通过实践自主引擎的开发来完成对引擎知识的掌握。游戏引擎知识面深而广，所以对这系列的文章书编写范围做个保护，即不对细节进行过多的阐述，重点剖析的是架构、流程以及模块的运作原理。概述：文章分为五个部分：  游戏引擎历史  现代引擎概览  计算机图形技术发展史  游戏制作团队  运行时引擎架构概述正文：此篇分四个主题来概述一下游戏引擎的基础知识，我会分别从历史、现状、架构、团队，这四个方面来阐述。游戏引擎历史有些同学会问，为什么要讲历史？为什么要讲现状？那是因为了解历史和现状能帮助我们更好的理解引擎的每个部分。实际上，每每当你回顾历史，就会发现它是由很多巧合构成的，当知道它的来龙去脉时，我们也就能更好的理解“今天为什么它成为这个样子”。我认为游戏引擎这个词语用的非常好，它很好的概括它在游戏开发中的地位。我们说所有的程序都可以用工具两个字来描述，那么游戏引擎到底带给了我们什么，才让它成为今天人们普遍关注的焦点呢。十几年前的游戏都很简单，容量大小都是以兆计的，通常一款游戏的开发周期在8到10个月左右，最主要的是每款游戏开发都需要重头编写代码，期间存在着大量的重复劳动，耗时耗力。慢慢地开发人员总结出些规律，某些游戏逻辑总是有些相似的代码，可以做成模块重复使用，这样就可以大大减少游戏开发周期和开发费用。一开始，只是做些低耦合的通用方法，然后逐渐形成了模块，接着演变成了复合型框架，最后形成了大型软件工程，即现在的游戏引擎。Id Tech 引擎发展史说到引擎发展史不得不说ID software这家游戏公司，很早就开始开发起游戏，从一个小游戏到游戏移植再到《Wolfenstein 3D》，游戏技术让这家公司从无到有，不断创造出一个又一个技术巅峰。最后《Wolfenstein 3D》成了游戏引擎的始祖，它不但开创了3D 射击游戏世界，而且程序也被其他游戏所使用。对ID公司来说《Wolfenstein 3D》只是小试身手，DOOM（毁灭战士）游戏引擎才是引擎技术的代表，DOOM使用的引擎正是Id Tech 1。在DOOM发布后，获得了350万的销量，为ID公司带来了滚滚财源。更重要的是DOOM成了ID公司第一款用于商业授权的引擎，这为ID公司增加了一条创收之路，即商业引擎之路从此开始。引擎从Id Tech 1到Id Tech 5，每一代升级都是质的飞越。游戏Id Tech引擎也制作出了很多优秀的游戏，包括《Quake》、《半条命》、《反恐精英》等。Unreal 引擎发展史EPIC公司在1998年发布了Unreal引擎，同时《虚幻》这款FPS游戏也发布出来，画面精致绚丽得到大众的认可。不仅如此，重要的是Unreal引擎得益于画面精美和DX规范的通用性，很快就得到了许多游戏公司的支持。而且，由于Unreal引擎的通用性，除了游戏，它还广泛使用在3D建模、建筑设计、动作捕捉、电影特效等等领域。Unreal引擎一战成名后，便开启了升级之路，引擎从Unreal 1到 Unreal 5，凭借着优秀的画质表现、适中的显卡要求、强大的自定义工具和一站式配套开发使得Unreal具备了各个平台各种游戏的适应性，因此越来越多的游戏采用Unreal引擎。目前已成为全球最流行的游戏引擎之一。Unity 引擎发展史Unity在2005年6月时发布了1.0版本的引擎。最初，是在2005年苹果公司的全球开发者大会上对外公布并开放使用，当时只是一款面向Mac OS X平台的游戏引擎。由于其引擎的易用性，受到广大开发者的喜爱，之后Unity公司便开启了快速升级之路，用了10年时间从1.0一路升级到5.0。鉴于引擎的更新速度逐渐加快，Unity官方决定不再在其版本号中标注纯数字，而改用年份与版本号的复合形式，如Unity 2018.2，发布时间为2018年7月10日。截止目前使用Unity引擎开发出了的手机游戏，无论是在数量上还是在流行度上，都是所有引擎中最多也是最受欢迎的。随着显卡性能越来越强，游戏的画质越来越高，游戏开发周期也越来越长，通常都会达到3到5年，自行开发游戏引擎的话时间还会更长，所以大多数游戏公司还是选择购买现成的游戏引擎，简化游戏的开发过程。现代引擎概览雷神之锤引擎，与游戏业务密切融合，它的第一款游戏是《德军总部》，后相继开发了《毁灭战士》、《雷神之锤》等游戏。Source引擎中的技术也能追溯到雷神之锤的技术。原始雷神之锤引擎的架构相当优秀并且整洁。这些代码都是非常好的例子，能说明工业级游戏引擎是怎样炼成的。虚幻引擎，从《虚幻》游戏开始进化，进化到虚幻4代引擎时，号称是业界最好的工具和最丰富的引擎功能。它有方便且强大的着色器制作工具，还提供一个方便快捷的图形用户界面编辑器，虚幻引擎以其全面的功能及内聚易用的工具著称。但虚幻引擎并非完美，大部分开发者都需要用不同方式优化它，才能在具体的目标硬件上运行。可贵的是虚幻引擎拥有极为强大的原型制作工具和商业游戏平台，可用来制作几乎任何3D游戏。Source引擎，《半条命2》起家的游戏引擎，其图形能力和工具套件可与虚幻引擎4娉美。寒霜引擎，是从《战地：叛逆连队》开发开始的，之后成为艺电应用最广泛的引擎。寒霜引擎拥有强大的统一资产创作工具FrostEd，以及强大的Backend Services工具管道。CryEngine，原本是为NVIDIA开发的技术演示程序。确立这个技术具有潜力后，就把演示程序改为了完整的游戏《孤岛惊魂》，最后演化成了游戏引擎。经过多年迭代，CryEngine3已经是一个强大的资产创作工具，具有丰富的功能并拥有高品质的图形渲染引擎。索尼的PhyreEngine，专为支持索尼的PS2，PS3，PS4等平台提供技术服务。PhyreEngine3.5让开发者能使用PS3 Cell架构的高度并行能力、PS4的高级演算能力，以及包括其他世界编辑器和开发工具。微软的XNA Game Studio，XNA基于微软的C#语言并使用Visual Studio管理游戏项目资产。Unity，支持广泛的平台，它的主要设计目标是容易开发及跨平台游戏开发。因此它提供了容易使用的整合编辑环境，我们可以在此环境中创建及处理游戏世界中的资产及实体，并能快速地在编辑器中浏览游戏运行的样子，同时也提供了直接在目标硬件上运行的功能。不仅如此它还提供了全面的资产调节管道，可以为每个平台独立调节性能与品质以达到两者的平衡。计算机图形技术发展史我把计算机图形技术发展史分为了四个部分，它们分别是，硬件发展史、图形API发展史、图形软件发展史、以及图形技术发展史。图形硬件发展史图形硬件，最初由SGI公司（Silicon Graphics Inc）开发的IRIS（综合光栅成像系统）受到市场热捧，它使用2MB内存的8 MHz M68000处理器，定制1024x1024帧缓冲器和几何引擎。其最初的市场定位为3D图形显示终端。随着市场策略的推进，SGI公司在电影、电视等领域的发展迅速并且它们的产品受到欢迎。接着是Sun微系统公司，它于1982年由安迪·贝托尔斯海姆与其他同门研究生在斯坦福大学成立。贝托尔斯海姆最初将SUN计算机设计为斯坦福大学网络（因此缩写为“SUN”）的个人CAD工作站。它是围绕Motorola 68000处理器设计的，具有Unix操作系统和虚拟内存，并且与SGI一样，具有嵌入式帧缓冲区。后来的发展包括计算机服务器和基于RISC处理器架构和一系列软件产品（如Solaris操作系统和Java平台）构建的工作站。GPU英文全称Graphic Processing Unit，20世纪70年代末GPU概念被提出，它的优点是具有高并行结构，所以GPU在处理图形数据和复杂算法方面由比CPU更高的效率。CPU大部分面积为控制器和寄存器，与之相比，GPU拥有更多的ALU（Arithmetic Logic Unit,逻辑运算单元）用于数据处理，这样的结构适合对密集型数据进行并行处理。GPU采用流式并行计算模式，可对每个数据进行独立的并行计算，所谓“对数据进行独立计算”即：流内任意元素的计算不依赖于其他同类型数据，例如，计算一个顶点的世界位置坐标，不依赖于其他顶点的位置，所谓“并行计算”是指“多个数据可以同时被使用，多个数据并行运算的时间和1个数据单独执行的时间是一样的”。所以，在顶点处理程序中，可以同时处理N个顶点数据。目前，线性代数，物理仿真和光线跟踪算法都已经成功的一直到GPU上。第一代GPU，NVIDIA于1998年宣布Modern GPU研发成功，这标志着第一代Mondern GPU的诞生，第一代GPU包括NVIDIA TNT2,ATI的Rage和3Dfx的Voodoo。这些GPU可以独立CPU进行像素缓存区的更新，并可以光栅化三角面片以及进行纹理操作，但是缺乏三维顶点的空间坐标变换能力，这意味着“必须依赖与CPU执行顶点坐标变换的计算”。这一时期的GPU功能非常有限，只能用于纹理组合的数学计算或者像素颜色值得计算。第二代GPU，NVIDIA于1999年推出一款显示核心代号NV10的geforce 256，率先将硬体T&amp;L整合到显示核中。T&amp;L原先由CPU负责，或者由另一个独立处理机处理。这次整合T&amp;L是一大进步，原因是显视核心从CPU接管了大量工作。硬件T&amp;L引擎带来的效果是3D 模型可以用更多的多边形来描绘，这样就拥有了更加细腻的效果。而对光照来说，CPU不必在计算大量的光照数据，直接通过显卡就能获得更好的效能。同时，这一阶段的GPU对于纹理的操作也扩展到了立方体纹理（Cube Map）。NVIDIA的GeForce MAX,ATI的Radeon 7500等都是在这一阶段研发的。第三代GPU，2001年是第三代Modern GPU的发展时期，这一时期研发的GPU提供Vertex Programmability (顶点编程能力)，如GeForce 3，GeForce 4Ti，ATI 的8500等。这些GPU允许应用程序指定一个序列的指令进行顶点操作控制，这是一个具有开创意义的时期，这一时期确立的GPU编程思想一直延续到今天，不但深入到工程领域帮助改善人类日常生活（医疗、地质勘探、游戏、电影），而且开创或延伸了计算机科学的诸多研究领域（人体绘制、光照模拟、人群动画、通用计算等）。同时Direct8和OpenGL都本着与时俱进的精神，提供了支持Vertex Programmability的发展。不过，这一时期的GPU还不支持像素级的编程能力，即Fragment Programmability(片段编程能力)。第四代GPU，发展时期从2002年末到2003年。NVIDIA的GeForceFX和ATI Radeon 9700同时在市场的舞台上闪亮登场，这两种GPU都支持顶点编程和片段编程。同时DriectX和OpenGL也扩展了自身的API，用以支持顶点编程和片段编程。自2003年起，可编程图形处理器正式诞生，并且由于DirectX和OpenGL契而不舍的追赶潮流，导致基于图形硬件的编程技术，简称GPU编程，也宣告诞生。图形API发展史在 1980 年代，开发可与各种图形硬件配合使用的软件是一项真正的挑战。软件开发人员为每个硬件编写自定义接口和驱动程序。这个代价是昂贵的，将导致工作量成倍增加。到 1990 年代初，Silicon Graphics (SGI) 是工作站 3D 图形领域的领导者。他们的 IRIS GL API成为行业标准，比基于开放标准的 PHIGS 使用更广泛。OpenGL、DirectX、Vulkan、Metal等都属于图形API，它的本质是封装好的显卡接口，用来将应用程序与显卡驱动联系起来。有了图形API我们可以仅仅调用它的函数来更改渲染状态、缓存顶点数据、开始绘制等等，而如果没有它，我们就需要直接调用显卡驱动的接口来进行渲染，这会涉及到非常多的硬件接口，例如对寄存器的操作，相当繁琐。一般来说我们都不会希望在渲染的同时还要去关注对硬件的控制。目前比较常用的图形API：  OpenGL  OpenGL ES  OpenCV  DirectX  Metal  VunkanOpenGL（Open Graphics Library），是一个跨平台、跨语言的编程图形框架，主要用于windows、mac等PC端。它将计算机资源抽象成一个个OpenGL对象，对这些资源的操作抽象为一个个OpenGL指令。OpenGL ES（OpenGL for Embedded Systems），OpenGL三维图像API的子集，主要是针对嵌入式设备的图形处理，比如安卓、iOS等。它在OpenGL之上去除了许多不必要的接口，以及性能较低的接口，并且兼容了GLSL着色器语法。OpenCV（Open Source Computer Vision Library），它与 OpenGL是图形API中两个大的分支，类似于iOS中的OC和swift，是两个不同的方向。OpenCV主要用于识别技术，例如人脸识别、身份识别、物体识别等，该API的使用需要与人工智能相结合。目前市面上用的最多的识别三方是 face++，且是收费的，支付宝等大厂的识别功能也是集成的face++。DirectX，仅支持Windows平台，由很多API组成，是一个多媒体处理框架，并不是单一的图形API。该框架可以大致分为4类，显示、声音、输入、网络。Metal，是苹果为了解决3D渲染问题而推出的框架，是为游戏开发者提供的新的平台技术，并且它将3D渲染图像的性能提高了原来的10倍。苹果系统中的CoreGraphics、CoreAnimation、CoreImage框架在2018年以前是基于OpenGL ES封装的，在2018年以后是基于Metal封装的。Vunkan，Vulkan API 最初被 Khronos 称为“下一代 OpenGL 计划”，与 OpenGL、Direct3D 11 和 Metal 相比，Vulkan 旨在提供更高的性能和更平衡的 CPU 和 GPU 使用，并为应用程序提供相当低级别的 API 和并行任务。OpenGL历史SGI 的竞争对手（包括 Sun Microsystems、Hewlett-Packard 和 IBM）也能够将 PHIGS 标准扩展支持的 3D 硬件推向市场，这迫使 SGI 将 IrisGL 版本作为公共标准开源，称为 OpenGL。然而，SGI的许多客户从 IrisGL 到 OpenGL 的转变需要大量投资。此外，IrisGL 具有与 3D 图形无关的 API 函数。例如，它包括一个窗口、键盘和鼠标 API等。其原因是，它是在 X Window System 和 Sun 的 NeWS 之前开发的。而且，由于许可和专利问题，IrisGL的库不适合开放。因此这个转变难度相当大，SGI公司付出了艰辛的努力，得到了市场的认可。IrisGL 的限制之一是它只提供对底层硬件支持的功能的访问。如果图形硬件本身不支持某个功能，则应用程序将无法使用它。OpenGL 通过提供硬件不支持的功能的软件实现来克服这个问题，允许应用程序在相对低功耗的系统上使用高级图形。OpenGL标准化了对硬件的访问，将硬件接口程序（设备驱动程序）的开发责任推给了硬件制造商，并将窗口功能委托给了底层操作系统。有了这么多不同种类的图形硬件，通过为软件开发人员提供一个用于 3D 软件开发的更高级别的平台，让它们以这种方式使用同一种语言产生了显着的影响。OpenGL在1992年由SGI（Silicon Graphics Inc）发布。起初它是作为Iris GL的一个替代品而出现的。Iris GL是SGI的专用图形API，由于它有一些与3D图形无关的API以及一些专利等原因，不适合作为行业的广泛标准，于是SGI编写了OpenGL 1.0规范。在之后，每隔一段时间OpenGL便会出现新的增量更新。  1992年，SGI发布了OpenGL 1.0。  2003年7月，OpenGL ES 1.0发布，它是专为手机、平板电脑、游戏主机等嵌入式系统设计的一个OpenGL API子集。  2004年9月，SGI发布了OpenGL 2.0，这其中就有GLSL 1.0（OpenGL Shading Language）的面世，这是一种类C语言，可以用它对固定管线的顶点/片段着色器进行编程。与之相伴的还支持了MRT（Multiple render targets）和NPOT（Non-power-of-two textures）。  2006年7月，OpenGL API规范的控制权转交给非盈利组织Khronos团队。  2008年8月，OpenGL 3.0发布，支持FBO（Framebuffer Objects）以及VAO（Vertex Array Objects）等多个功能，同时支持了非常多的特性，并且从这版开始OpenGL支持了向后兼容。  2009年8月，OpenGL 3.2发布，废弃了固定渲染管线，发布了核心模式（Core Profile），这种模式的灵活性与效率更高，之后的迭代也都是基于这个核心架构，同时版本中增加了新的着色器阶段：几何着色器。  2010年3月，OpenGL 3.3和OpenGL 4.0一起发布，带来了新的标准规范，自此之后GLSL的版本号与OpenGL版本号保持一致，即GLSL 3.3/4.0，同时新增了曲面细分着色器。  2017年7月，OpenGL 4.6发布，增加了SPIR-V 着色器，SPIR-V 使高级语言前端能够以标准化的中间形式发出程序，供 Vulkan、OpenGL 或 OpenCL 驱动程序摄取。Vulkan历史Vulkan于Khronos在GDC 2015上首次公开，它也曾被叫做是“Next Generation OpenGL Initiative”(glNext)，旨在对OpenGL和OpenGL ES的一次重新设计，将两者统一到一个API中。与OpenGL相同它也是一个跨平台的2D、3D图形API，不同的是它是一个Low Level图形API，即会开放出更多与内存控制相关的接口。Vulkan能较好的支持多线程并行（OpenGL4.0+是为单线程设计的），这使得它的操作和维护比OpenGL复杂得多。另外OpenGL使用GLSL来编写着色器，每个显卡商需要为GLSL单独编写编译器来转换为在显卡上运行的机器码。在这点上Vulkan不同，它会先由操作系统把GLSL预编译为一种名为SPIR-V（Standard Portable Intermediate Representation）的中间码，再由显卡商编写Vulkan驱动程序对GPU进行一些特定的优化，加载速度变快了还节省了显卡商的开发及维护成本。这和Direct3D的HLSL预编译很像。  2016年2月，Vulkan 1.0发布。  2018年2月，Khronos发布MoltenVK，可以理解为MoltenVK是用Metal实现了Vulkan的API，这使得macOS和iOS也能支持Vulkan了。虽然绕了趟远路，但从Dota2的表现上来看，依旧比OpenGL高出了50%的帧率。  2018年3月，Khronos和GPUOpen公开V-EZ项目，它是“Easy Mode”的缩写，是一个基于Vulkan的中间层，相比于Vulkan它保留了Vulkan的大部分API，提供了更简单的内存管理API，封装了诸多底层细节。旨在开发者更容易上手Vulkan。  2018年3月，Vulkan 1.1发布。支持了HLSL语法以及光线追踪。可以更好的模拟DirectX 12。spirv更新至1.3。  2020年1月，Vulkan 1.2发布。新增了23项扩展以及更好的支持HLSL。Direct3D历史Direct3D 是 Microsoft Windows 的图形应用程序编程接口 (API)。作为 DirectX 的一部分，Direct3D 用于在性能很重要的应用程序（例如游戏）中渲染 3D 图形。Direct3D 使用硬件加速（如果它在显卡上可用），允许对整个 3D 渲染管道进行硬件加速，也支持仅部分加速。Direct3D 公开了 3D 图形硬件的高级图形功能，包括 Z 缓冲、W 缓冲、模板缓冲、空间抗锯齿、alpha 混合、颜色混合、Mipmapping、纹理混合，剪裁、剔除、大气效果、透视校正纹理映射、可编程 HLSL 着色器等其他图形效果。与其他 DirectX 技术的集成使 Direct3D 能够提供视频映射、2D 覆盖平面中的硬件 3D 渲染甚至精灵等功能，从而在交互式媒体关系中提供 2D 和 3D 图形的使用。Direct3D 是一种立即模式图形 API。它为每个显卡的 3D 功能（转换、剪辑、照明、材质、纹理、深度缓冲等）提供了一个低级接口。立即模式呈现三个主要抽象：设备、资源和交换链。设备有四种类型，HAL（硬件抽象层）设备（支持硬件加速）、参考设备（模拟不可用的新功能）、软件设备（执行软件渲染）、空设备。每个设备都有一个交换链，交换链由一个或多个后台缓冲区组成，渲染发生在后台缓冲区中。资源有四个属性，资源类型（表面网格、立方体纹理、索引缓冲、顶点缓冲等）、池（内存管理与存储位置）、格式（资源在内存中的布局）、用法（用标志位方式确定如何使用资源）。  1996年6月，第一版Direct3D 2.0跟随DirectX 2.0发布，有”Retained mode”和”Immediate mode”。  1998年8月，Direct3D 6.0发布，增加了许多新特性，如Multitexture、模板缓冲区等。  1999年9月，Direct3D 7.0支持了T&amp;L硬件加速。  2000年11月，Direct3D 8.0发布，引进了可编程管道概念，新增了顶点/片段着色器，这个时候Direct3D完全超越了OpenGL。  2002年12月，Direct3D 9.0发布，发布了Shader Model 2.0。支持浮点纹理格式、MRT（Multiple render targets），9.0是最后一个支持WindowsXP的版本。  2006年11月，Direct3D 10.0发布，仅支持Windows Vista以上操作系统。固定功能管线被淘汰，取而代之的是可编程渲染管线。新增了几何着色器阶段，发布了Shader Model 4.0。  2009年7月，Direct3D 11.0与Windows7一块被发布，Direct3D 11.0新增了曲面细分着色器和Computer Shader，支持了多线程处理技术，发布了Shader Model 5.0。  2015年1月，Direct3D 12.0包含在Windows10一块被发布，更好支持多核心、多线程的优化，降低GPU处理瓶颈，并提升硬件功耗表现。简化了Direct3D 11中的管道状态对象（Pipeline state objects）。  2018年10月，发布了Direct3D 12光线追踪DirectX Raytracing (DXR)的扩展包。Metal历史Metal是一款Low Level、Low Overhead的3D图形API，由苹果公司开发，并在2014年6月随iOS8公开。相比于OpenGL，Metal对底层拥有更大的操控性，同时又有着多线程上大量的优化。Metal Shader使用的是Metal Shader Language（MSL），是一种基于C++ 14的语言。  2014 年 6 月，Metal发布。在由 Apple A7 或更高版本驱动的 iOS 设备上可用，并自 2015 年 6 月 8 日起在运行 OS X El Capitan 的 Mac（2012 型号或更高版本）上可用。  2017 年 6 月，Metal第二个版本发布，Metal 2 可以在 Xcode 中实现更高效的分析和调试、加速机器学习、降低 CPU 工作负载、支持 macOS 上的虚拟现实，以及 Apple A11 GPU 的特性。  2020 年，Apple 宣布将 Mac 迁移到 Apple 芯片，使用 Apple 芯片的 Mac 将配备 Apple GPU，其功能集结合了以前在 macOS 和 iOS 上可用的功能，并将能够利用为 Apple GPU 的基于图块的延迟渲染 (TBDR) 架构量身定制的功能。图形软件发展史20世纪80年代，出现了许多著名的新型商业软件产品，例如Autodesk公司的AutoCAD专注于平面设计，以及它的另一个作品3D Studio专注于3D模型设计，Alias Research公司开发的Alias专注于3D模型设计。Softimage公司开发的Softimage 3D专注于集成建模、动画、渲染并成为业内标准的动画解决方案，副作用软件公司开发的Side Effects软件将程序化建模和运动产品开发成高度紧密集成的2D / 3D动画软件，并融合了多项技术突破。到了20世纪90年代，随着硬件技术的提升，图形软件技术也开始蓬勃发展，产生一批顶级的3D图形软件，例如CAD、3MAX、MAYA、SOFTIMAGE、HOUDINI等。借助这些软件，可以大大降低制作模型和动画的成本。因此90年开始，图形技术发展进入了重大的改革，不仅在技术上大举突破了各类瓶颈，在图形软件上有了大的进化，而且计算机图形技术开始渗透影视、动画、游戏等各行各业。图形技术发展史群体动物移动行为，群体行为的数学模型首先由Craig Reynolds于1986年在计算机上模拟，并很快在3D动画开始大规模使用。动作捕捉，80年代就开始基于计算机的动作捕作为摄影测量分析工具，表演者佩戴标记每个关节附近的标记之间的位置或角度来识别运动。运动跟踪，90年代中期，匹配移动（也称为运动跟踪或摄像头跟踪）虽然与动作捕捉有关，但却是一种完全不同的技术。除了使用特殊的相机和传感器来记录主体的运动外，还会将移动作品与预先存在的实时镜头相匹配，并单独使用计算机软件通过多个框架跟踪场景中的特定点，从而允许插入CGI元素以相对于现有材料的正确位置、比例、方向和运动进入镜头。虚拟演播室，虚拟演播室是一个工作室，这种虚拟场景在90年代电视节目中很普遍，它可以以无缝方式，实时组合人或其他真实物体，包括计算机生成的环境和物体。它要求3D CGI环境自动锁定，进而精确跟踪角色在实时相机和镜头前的任何移动。这种系统的精髓在于它使用某种形式的相机来跟踪创建一个实时的数据流，同时会使用CGI渲染软件，软件使用相机跟踪数据并生成完美拼接的虚拟合成图像。法线贴图，1996年，Krishnamurty和Levoy发明了法线贴图，这是对Jim Blinn 凹凸贴图的改进。PBR&amp;卡通材质，这两个技术都是围绕画风的，PBR 指的是”Physically Based Rendering”， 简化了物理材质的计算流程，用接近物理正确的效果来渲染材质表面，材质包括绝缘体和金属材质两种。卡通渲染（英语：Toon Shading）是一种非真实感绘制（NPR），卡通渲染又称赛璐珞渲染（Cel-shading），旨在使电脑生成的图像呈现出手绘般的效果。为了使图像可以与漫画或者卡通达到形似的效果，专业人员通常使用卡通渲染着色器进行处理。高动态光照（HDRR，High-Dynamic Range rendering），人在黑暗的地方，为了看清楚对象，瞳孔会放大，以吸收更多光线；当突然走到光亮的地方，瞳孔来不及收缩，所以眯起眼睛，保护视网膜上的视神经。而电脑无法判断光线明暗，唯有靠HDRR技术模拟这效果——人眼自动适应光线变化的能力。方法是快速将光线渲染得非常光亮，然后将亮度逐渐降低。HDRR的最终效果是亮处的效果是鲜亮，而黑暗处的效果是能分辨物体的轮廓和深度，而不是以往的一团黑。体积光，可以让用户看到光束效果，例如在一个画面中用户能看到太阳光束射入敞开的窗户，这就是典型的体体积光技术体现。early-z-test，发生在顶点着色器后像素着色器之前的深度测试，原本深度测试在填充率、光照、纹理或像素着色器成为主要瓶颈的情况下已经成为了一个很好的优化，early-z-test这种技术将深度测试更进一步，提前到顶点着色器之后去完成，它节省了片元着色器的计算，但前提是片元着色器中不会有alpha混合和discard操作。光线追踪（Ray Tracing），是三维计算机图形学中的特殊渲染算法，追踪光线从来源开始照射到物体上，再由物体反射的光线“路径”，由于完整运算所有路径十分消耗运算资源，因此现有光线追踪技术仅运算“目所能及”的光线路径，由于是从玩家视角开始进行运算，有时被误解为光线追踪是追踪“从眼睛发出的光线”。通过这样一项技术生成编排好的场景的数学模型显现出来。这样得到的结果类似于光线投射与扫描线渲染方法的结果，但是这种方法有更好的光学效果，例如对于反射与折射有更准确的模拟效果，并且效率非常高，所以当追求高质量的效果时经常使用这种方法。 在物理学中，光线追迹可以用来计算光束在介质中传播的情况。在介质中传播时，光束可能会被介质吸收，改变传播方向或者射出介质表面等。我们通过计算理想化的窄光束（光线）通过介质中的情形来解决这种复杂的情况。 在实际应用中，可以将各种电磁波或者微小粒子看成理想化的窄波束（即光线），基于这种假设，人们利用光线追迹来计算光线在介质中传播的情况。光线追迹方法首先计算一条光线在被介质吸收，或者改变方向前，光线在介质中传播的距离，方向以及到达的新位置，然后从这个新的位置产生出一条新的光线，使用同样的处理方法，最终计算出一个完整的光线在介质中传播的路径。其他等等渲染技术非常多，这里点到为止不再延伸开来。游戏制作团队这里简单介绍下游戏制作团队，虽然大多数人都知道这些知识，但不妨碍我们回顾与总结。艺术家：概念艺术家、三维建模师、纹理艺术家、灯光师、动画师、动捕演员、音效师、配音演员、作曲家等产品设计：游戏设计师、数值设计师、关卡设计师、系统设计师、AI设计师、剧情设计师、操作设计师、技能设计师、制作人等软件工程师：引擎工程师、渲染工程师、游戏系统工程师、AI工程师、网络工程师、构建工程师、工具开发工程师、架构工程师、效能工程师、中间件工程师、安全工程师、测试工程师等运行时引擎架构概述游戏引擎通常由工具套件和运行时组件两部分构成。这里我们主要来说说运行时组件部分。与所有软件系统一样，游戏引擎也是由软件层构建的，即我们通常说的，上层依赖下层，下层不依赖上层，每层中各模块之间不相互依赖，这样的低耦合、高重用度架构在大型软件系统架构中是非常关键的设计。《游戏引擎架构》一书中对整体架构做了介绍，但我认为内容过于粗浅，也有点过时了，于是我自己重新画了架构图。我把整个运行时引擎架构分为十三个层级，每个层级都是只依赖下层，这十三个层级分别为：  目标硬件层  设备驱动层  操作系统层  平台独立层  第三方中间件  核心库  资产管理层  底层渲染器  引擎核心层  引擎应用层  业务基础层  游戏框架层  游戏业务层下面来简单解释一下每个层级的拆解理念：目标硬件层，代表用来执行游戏的主机硬件。设备驱动层，是操作系统或硬件商提供的最低阶软件组件。负责管理硬件资源、也隔离了操作系统及上层引擎。操作系统层，管理协调整台计算机上多个程序的执行工作，进程通过调用操作系统的接口来访问操作系统。平台独立层，包装了常用的库和操作系统接口，供所有平台使用。第三方中间件，提供了独立的解决方案，简化开发流程，缩短开发时间。包括标准库、图形接口等。核心库，是由许许多多独立的软件工具库组成。这些库常常被引擎上层频繁使用，同时也是非常实用的软件工具。资产管理层，提供资源增删改查的完整解决方案，通常会提供一组统一的接口，供引擎和业务去访问任意的游戏资源。底层渲染器，提供最原始的渲染功能，根据应用层的数据调用图形API进行渲染。它通常会经过封装，从业务渲染提交的过程中拆解出来。引擎核心层，为应用层提供了最核心的功能，包括音频、动画、物理、剔除与合批、手柄设备接口等。引擎应用层，在核心层之上建立起来的引擎业务，包括性能剖析工具、UI核心框架、粒子系统、后处理系统等。业务基础层，引擎为游戏框架搭建而做的基础功能，是提供给实现游戏逻辑的重要功能与接口。游戏框架层，通过调用业务基础层来搭建的游戏框架，是游戏实现自身逻辑的框架，也是游戏逻辑的核心。游戏业务层，是实现具体游戏业务的逻辑，通过调用游戏框架来实现具体的业务逻辑。游戏引擎架构图在拆解了整个引擎的架构时，由于模块太多，因此只列了一些主要的模块，保持了基本架构的完整性：架构图中的重要模块，将在后面的文章中做详细的分析和解剖。参考资料：《游戏引擎架构》 译者：叶劲峰《3D游戏引擎发展史》https://www.bilibili.com/read/cv6499569/《游戏引擎wiki》https://zh.wikipedia.org/wiki/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E《你不能不知道的计算机图形技术发展史》1、2https://www.bilibili.com/read/cv196689https://www.bilibili.com/read/cv221830《了解图形接口》https://www.jianshu.com/p/9dea5f163837《图形API发展历史》https://blog.csdn.net/ce1061183126/article/details/106159169《卡通渲染 Wiki》https://zh.wikipedia.org/wiki/%E5%8D%A1%E9%80%9A%E6%B8%B2%E6%9F%93《高动态光照渲染》https://zh.wikipedia.org/wiki/%E9%AB%98%E5%8A%A8%E6%80%81%E5%85%89%E7%85%A7%E6%B8%B2%E6%9F%93《Metal Wiki》https://en.wikipedia.org/wiki/Metal_(API)#History《Direct3D Wiki》https://en.wikipedia.org/wiki/Direct3D#Direct3D_12《OpenGL Wiki》https://en.wikipedia.org/wiki/OpenGL《Vulkan Wiki》https://en.wikipedia.org/wiki/Vulkan_(API)已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484890&amp;idx=1&amp;sn=1d319050c82fed232d22f1f3dfce0cd3&amp;chksm=fc2260ddcb55e9cbbda832e90def1e8e7440b7ffc85c60264be83d9c6bc62162c5b05839839b&amp;token=834275592&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h1 id=\"背景\">背景：</h1><p>作为游戏开发从业者，从业务到算法到语言到框架到引擎，积累了一些知识和经验，特别是在看了好几遍《游戏引擎架构》后对引擎的架构感触颇深。</p><p>近段时间对引擎剖析的想法也较多，正好借着书本对游戏引擎架构做一个完整分析。此书用简明、清楚的方式覆盖了游戏引擎架构的庞大领域，巧妙地平衡了广度与深度，并且提供了足够的细节，使得初学者也能很容易地理解其中的各种概念。</p><p>目标是掌握游戏引擎架构知识，方法是跟随《游戏引擎架构》这本书、结合引擎源码、自己的经验，分析游戏引擎的历史、架构、模块。最后通过实践自主引擎的开发来完成对引擎知识的掌握。</p><p>游戏引擎知识面深而广，所以对这系列的文章书编写范围做个保护，即不对细节进行过多的阐述，重点剖析的是架构、流程以及模块的运作原理。</p><h1 id=\"概述\">概述：</h1><p>文章分为五个部分：</p><ol>  <li>游戏引擎历史</li>  <li>现代引擎概览</li>  <li>计算机图形技术发展史</li>  <li>游戏制作团队</li>  <li>运行时引擎架构概述</li></ol><h1 id=\"正文\">正文：</h1><p>此篇分四个主题来概述一下游戏引擎的基础知识，我会分别从历史、现状、架构、团队，这四个方面来阐述。</p><h2 id=\"游戏引擎历史\">游戏引擎历史</h2><p>有些同学会问，为什么要讲历史？为什么要讲现状？那是因为了解历史和现状能帮助我们更好的理解引擎的每个部分。</p><p>实际上，每每当你回顾历史，就会发现它是由很多巧合构成的，当知道它的来龙去脉时，我们也就能更好的理解“今天为什么它成为这个样子”。</p><p>我认为游戏引擎这个词语用的非常好，它很好的概括它在游戏开发中的地位。</p><p>我们说所有的程序都可以用工具两个字来描述，那么游戏引擎到底带给了我们什么，才让它成为今天人们普遍关注的焦点呢。</p><p>十几年前的游戏都很简单，容量大小都是以兆计的，通常一款游戏的开发周期在8到10个月左右，最主要的是每款游戏开发都需要重头编写代码，期间存在着大量的重复劳动，耗时耗力。</p><p>慢慢地开发人员总结出些规律，某些游戏逻辑总是有些相似的代码，可以做成模块重复使用，这样就可以大大减少游戏开发周期和开发费用。</p><p>一开始，只是做些低耦合的通用方法，然后逐渐形成了模块，接着演变成了复合型框架，最后形成了大型软件工程，即现在的游戏引擎。</p><h3 id=\"id-tech-引擎发展史\">Id Tech 引擎发展史</h3><p>说到引擎发展史不得不说ID software这家游戏公司，很早就开始开发起游戏，从一个小游戏到游戏移植再到《Wolfenstein 3D》，游戏技术让这家公司从无到有，不断创造出一个又一个技术巅峰。</p><p>最后《Wolfenstein 3D》成了游戏引擎的始祖，它不但开创了3D 射击游戏世界，而且程序也被其他游戏所使用。</p><p>对ID公司来说《Wolfenstein 3D》只是小试身手，DOOM（毁灭战士）游戏引擎才是引擎技术的代表，DOOM使用的引擎正是Id Tech 1。</p><p>在DOOM发布后，获得了350万的销量，为ID公司带来了滚滚财源。</p><p>更重要的是DOOM成了ID公司第一款用于商业授权的引擎，这为ID公司增加了一条创收之路，即商业引擎之路从此开始。</p><p>引擎从Id Tech 1到Id Tech 5，每一代升级都是质的飞越。游戏Id Tech引擎也制作出了很多优秀的游戏，包括《Quake》、《半条命》、《反恐精英》等。</p><h3 id=\"unreal-引擎发展史\">Unreal 引擎发展史</h3><p>EPIC公司在1998年发布了Unreal引擎，同时《虚幻》这款FPS游戏也发布出来，画面精致绚丽得到大众的认可。</p><p>不仅如此，重要的是Unreal引擎得益于画面精美和DX规范的通用性，很快就得到了许多游戏公司的支持。而且，由于Unreal引擎的通用性，除了游戏，它还广泛使用在3D建模、建筑设计、动作捕捉、电影特效等等领域。</p><p>Unreal引擎一战成名后，便开启了升级之路，引擎从Unreal 1到 Unreal 5，凭借着优秀的画质表现、适中的显卡要求、强大的自定义工具和一站式配套开发使得Unreal具备了各个平台各种游戏的适应性，因此越来越多的游戏采用Unreal引擎。目前已成为全球最流行的游戏引擎之一。</p><h3 id=\"unity-引擎发展史\">Unity 引擎发展史</h3><p>Unity在2005年6月时发布了1.0版本的引擎。</p><p>最初，是在2005年苹果公司的全球开发者大会上对外公布并开放使用，当时只是一款面向Mac OS X平台的游戏引擎。</p><p>由于其引擎的易用性，受到广大开发者的喜爱，之后Unity公司便开启了快速升级之路，用了10年时间从1.0一路升级到5.0。</p><p>鉴于引擎的更新速度逐渐加快，Unity官方决定不再在其版本号中标注纯数字，而改用年份与版本号的复合形式，如Unity 2018.2，发布时间为2018年7月10日。</p><p>截止目前使用Unity引擎开发出了的手机游戏，无论是在数量上还是在流行度上，都是所有引擎中最多也是最受欢迎的。</p><p>随着显卡性能越来越强，游戏的画质越来越高，游戏开发周期也越来越长，通常都会达到3到5年，自行开发游戏引擎的话时间还会更长，所以大多数游戏公司还是选择购买现成的游戏引擎，简化游戏的开发过程。</p><h2 id=\"现代引擎概览\">现代引擎概览</h2><p>雷神之锤引擎，与游戏业务密切融合，它的第一款游戏是《德军总部》，后相继开发了《毁灭战士》、《雷神之锤》等游戏。Source引擎中的技术也能追溯到雷神之锤的技术。原始雷神之锤引擎的架构相当优秀并且整洁。这些代码都是非常好的例子，能说明工业级游戏引擎是怎样炼成的。</p><p>虚幻引擎，从《虚幻》游戏开始进化，进化到虚幻4代引擎时，号称是业界最好的工具和最丰富的引擎功能。它有方便且强大的着色器制作工具，还提供一个方便快捷的图形用户界面编辑器，虚幻引擎以其全面的功能及内聚易用的工具著称。但虚幻引擎并非完美，大部分开发者都需要用不同方式优化它，才能在具体的目标硬件上运行。可贵的是虚幻引擎拥有极为强大的原型制作工具和商业游戏平台，可用来制作几乎任何3D游戏。</p><p>Source引擎，《半条命2》起家的游戏引擎，其图形能力和工具套件可与虚幻引擎4娉美。</p><p>寒霜引擎，是从《战地：叛逆连队》开发开始的，之后成为艺电应用最广泛的引擎。寒霜引擎拥有强大的统一资产创作工具FrostEd，以及强大的Backend Services工具管道。</p><p>CryEngine，原本是为NVIDIA开发的技术演示程序。确立这个技术具有潜力后，就把演示程序改为了完整的游戏《孤岛惊魂》，最后演化成了游戏引擎。经过多年迭代，CryEngine3已经是一个强大的资产创作工具，具有丰富的功能并拥有高品质的图形渲染引擎。</p><p>索尼的PhyreEngine，专为支持索尼的PS2，PS3，PS4等平台提供技术服务。PhyreEngine3.5让开发者能使用PS3 Cell架构的高度并行能力、PS4的高级演算能力，以及包括其他世界编辑器和开发工具。</p><p>微软的XNA Game Studio，XNA基于微软的C#语言并使用Visual Studio管理游戏项目资产。</p><p>Unity，支持广泛的平台，它的主要设计目标是容易开发及跨平台游戏开发。因此它提供了容易使用的整合编辑环境，我们可以在此环境中创建及处理游戏世界中的资产及实体，并能快速地在编辑器中浏览游戏运行的样子，同时也提供了直接在目标硬件上运行的功能。不仅如此它还提供了全面的资产调节管道，可以为每个平台独立调节性能与品质以达到两者的平衡。</p><h2 id=\"计算机图形技术发展史\">计算机图形技术发展史</h2><p>我把计算机图形技术发展史分为了四个部分，它们分别是，硬件发展史、图形API发展史、图形软件发展史、以及图形技术发展史。</p><h3 id=\"图形硬件发展史\">图形硬件发展史</h3><p>图形硬件，最初由SGI公司（Silicon Graphics Inc）开发的IRIS（综合光栅成像系统）受到市场热捧，它使用2MB内存的8 MHz M68000处理器，定制1024x1024帧缓冲器和几何引擎。其最初的市场定位为3D图形显示终端。随着市场策略的推进，SGI公司在电影、电视等领域的发展迅速并且它们的产品受到欢迎。</p><p>接着是Sun微系统公司，它于1982年由安迪·贝托尔斯海姆与其他同门研究生在斯坦福大学成立。贝托尔斯海姆最初将SUN计算机设计为斯坦福大学网络（因此缩写为“SUN”）的个人CAD工作站。它是围绕Motorola 68000处理器设计的，具有Unix操作系统和虚拟内存，并且与SGI一样，具有嵌入式帧缓冲区。后来的发展包括计算机服务器和基于RISC处理器架构和一系列软件产品（如Solaris操作系统和Java平台）构建的工作站。</p><p>GPU英文全称Graphic Processing Unit，20世纪70年代末GPU概念被提出，它的优点是具有高并行结构，所以GPU在处理图形数据和复杂算法方面由比CPU更高的效率。CPU大部分面积为控制器和寄存器，与之相比，GPU拥有更多的ALU（Arithmetic Logic Unit,逻辑运算单元）用于数据处理，这样的结构适合对密集型数据进行并行处理。GPU采用流式并行计算模式，可对每个数据进行独立的并行计算，所谓“对数据进行独立计算”即：流内任意元素的计算不依赖于其他同类型数据，例如，计算一个顶点的世界位置坐标，不依赖于其他顶点的位置，所谓“并行计算”是指“多个数据可以同时被使用，多个数据并行运算的时间和1个数据单独执行的时间是一样的”。所以，在顶点处理程序中，可以同时处理N个顶点数据。目前，线性代数，物理仿真和光线跟踪算法都已经成功的一直到GPU上。</p><p>第一代GPU，NVIDIA于1998年宣布Modern GPU研发成功，这标志着第一代Mondern GPU的诞生，第一代GPU包括NVIDIA TNT2,ATI的Rage和3Dfx的Voodoo。这些GPU可以独立CPU进行像素缓存区的更新，并可以光栅化三角面片以及进行纹理操作，但是缺乏三维顶点的空间坐标变换能力，这意味着“必须依赖与CPU执行顶点坐标变换的计算”。这一时期的GPU功能非常有限，只能用于纹理组合的数学计算或者像素颜色值得计算。</p><p>第二代GPU，NVIDIA于1999年推出一款显示核心代号NV10的geforce 256，率先将硬体T&amp;L整合到显示核中。T&amp;L原先由CPU负责，或者由另一个独立处理机处理。这次整合T&amp;L是一大进步，原因是显视核心从CPU接管了大量工作。硬件T&amp;L引擎带来的效果是3D 模型可以用更多的多边形来描绘，这样就拥有了更加细腻的效果。而对光照来说，CPU不必在计算大量的光照数据，直接通过显卡就能获得更好的效能。同时，这一阶段的GPU对于纹理的操作也扩展到了立方体纹理（Cube Map）。NVIDIA的GeForce MAX,ATI的Radeon 7500等都是在这一阶段研发的。</p><p>第三代GPU，2001年是第三代Modern GPU的发展时期，这一时期研发的GPU提供Vertex Programmability (顶点编程能力)，如GeForce 3，GeForce 4Ti，ATI 的8500等。这些GPU允许应用程序指定一个序列的指令进行顶点操作控制，这是一个具有开创意义的时期，这一时期确立的GPU编程思想一直延续到今天，不但深入到工程领域帮助改善人类日常生活（医疗、地质勘探、游戏、电影），而且开创或延伸了计算机科学的诸多研究领域（人体绘制、光照模拟、人群动画、通用计算等）。同时Direct8和OpenGL都本着与时俱进的精神，提供了支持Vertex Programmability的发展。不过，这一时期的GPU还不支持像素级的编程能力，即Fragment Programmability(片段编程能力)。</p><p>第四代GPU，发展时期从2002年末到2003年。NVIDIA的GeForceFX和ATI Radeon 9700同时在市场的舞台上闪亮登场，这两种GPU都支持顶点编程和片段编程。同时DriectX和OpenGL也扩展了自身的API，用以支持顶点编程和片段编程。自2003年起，可编程图形处理器正式诞生，并且由于DirectX和OpenGL契而不舍的追赶潮流，导致基于图形硬件的编程技术，简称GPU编程，也宣告诞生。</p><h3 id=\"图形api发展史\">图形API发展史</h3><p>在 1980 年代，开发可与各种图形硬件配合使用的软件是一项真正的挑战。软件开发人员为每个硬件编写自定义接口和驱动程序。这个代价是昂贵的，将导致工作量成倍增加。到 1990 年代初，Silicon Graphics (SGI) 是工作站 3D 图形领域的领导者。他们的 IRIS GL API成为行业标准，比基于开放标准的 PHIGS 使用更广泛。</p><p>OpenGL、DirectX、Vulkan、Metal等都属于图形API，它的本质是封装好的显卡接口，用来将应用程序与显卡驱动联系起来。有了图形API我们可以仅仅调用它的函数来更改渲染状态、缓存顶点数据、开始绘制等等，而如果没有它，我们就需要直接调用显卡驱动的接口来进行渲染，这会涉及到非常多的硬件接口，例如对寄存器的操作，相当繁琐。一般来说我们都不会希望在渲染的同时还要去关注对硬件的控制。</p><p>目前比较常用的图形API：</p><ol>  <li>OpenGL</li>  <li>OpenGL ES</li>  <li>OpenCV</li>  <li>DirectX</li>  <li>Metal</li>  <li>Vunkan</li></ol><p>OpenGL（Open Graphics Library），是一个跨平台、跨语言的编程图形框架，主要用于windows、mac等PC端。它将计算机资源抽象成一个个OpenGL对象，对这些资源的操作抽象为一个个OpenGL指令。</p><p>OpenGL ES（OpenGL for Embedded Systems），OpenGL三维图像API的子集，主要是针对嵌入式设备的图形处理，比如安卓、iOS等。它在OpenGL之上去除了许多不必要的接口，以及性能较低的接口，并且兼容了GLSL着色器语法。</p><p>OpenCV（Open Source Computer Vision Library），它与 OpenGL是图形API中两个大的分支，类似于iOS中的OC和swift，是两个不同的方向。OpenCV主要用于识别技术，例如人脸识别、身份识别、物体识别等，该API的使用需要与人工智能相结合。目前市面上用的最多的识别三方是 face++，且是收费的，支付宝等大厂的识别功能也是集成的face++。</p><p>DirectX，仅支持Windows平台，由很多API组成，是一个多媒体处理框架，并不是单一的图形API。该框架可以大致分为4类，显示、声音、输入、网络。</p><p>Metal，是苹果为了解决3D渲染问题而推出的框架，是为游戏开发者提供的新的平台技术，并且它将3D渲染图像的性能提高了原来的10倍。苹果系统中的CoreGraphics、CoreAnimation、CoreImage框架在2018年以前是基于OpenGL ES封装的，在2018年以后是基于Metal封装的。</p><p>Vunkan，Vulkan API 最初被 Khronos 称为“下一代 OpenGL 计划”，与 OpenGL、Direct3D 11 和 Metal 相比，Vulkan 旨在提供更高的性能和更平衡的 CPU 和 GPU 使用，并为应用程序提供相当低级别的 API 和并行任务。</p><h3 id=\"opengl历史\">OpenGL历史</h3><p>SGI 的竞争对手（包括 Sun Microsystems、Hewlett-Packard 和 IBM）也能够将 PHIGS 标准扩展支持的 3D 硬件推向市场，这迫使 SGI 将 IrisGL 版本作为公共标准开源，称为 OpenGL。</p><p>然而，SGI的许多客户从 IrisGL 到 OpenGL 的转变需要大量投资。此外，IrisGL 具有与 3D 图形无关的 API 函数。例如，它包括一个窗口、键盘和鼠标 API等。其原因是，它是在 X Window System 和 Sun 的 NeWS 之前开发的。而且，由于许可和专利问题，IrisGL的库不适合开放。因此这个转变难度相当大，SGI公司付出了艰辛的努力，得到了市场的认可。</p><p>IrisGL 的限制之一是它只提供对底层硬件支持的功能的访问。如果图形硬件本身不支持某个功能，则应用程序将无法使用它。OpenGL 通过提供硬件不支持的功能的软件实现来克服这个问题，允许应用程序在相对低功耗的系统上使用高级图形。</p><p>OpenGL标准化了对硬件的访问，将硬件接口程序（设备驱动程序）的开发责任推给了硬件制造商，并将窗口功能委托给了底层操作系统。有了这么多不同种类的图形硬件，通过为软件开发人员提供一个用于 3D 软件开发的更高级别的平台，让它们以这种方式使用同一种语言产生了显着的影响。</p><p>OpenGL在1992年由SGI（Silicon Graphics Inc）发布。起初它是作为Iris GL的一个替代品而出现的。Iris GL是SGI的专用图形API，由于它有一些与3D图形无关的API以及一些专利等原因，不适合作为行业的广泛标准，于是SGI编写了OpenGL 1.0规范。在之后，每隔一段时间OpenGL便会出现新的增量更新。</p><ul>  <li>1992年，SGI发布了OpenGL 1.0。</li>  <li>2003年7月，OpenGL ES 1.0发布，它是专为手机、平板电脑、游戏主机等嵌入式系统设计的一个OpenGL API子集。</li>  <li>2004年9月，SGI发布了OpenGL 2.0，这其中就有GLSL 1.0（OpenGL Shading Language）的面世，这是一种类C语言，可以用它对固定管线的顶点/片段着色器进行编程。与之相伴的还支持了MRT（Multiple render targets）和NPOT（Non-power-of-two textures）。</li>  <li>2006年7月，OpenGL API规范的控制权转交给非盈利组织Khronos团队。</li>  <li>2008年8月，OpenGL 3.0发布，支持FBO（Framebuffer Objects）以及VAO（Vertex Array Objects）等多个功能，同时支持了非常多的特性，并且从这版开始OpenGL支持了向后兼容。</li>  <li>2009年8月，OpenGL 3.2发布，废弃了固定渲染管线，发布了核心模式（Core Profile），这种模式的灵活性与效率更高，之后的迭代也都是基于这个核心架构，同时版本中增加了新的着色器阶段：几何着色器。</li>  <li>2010年3月，OpenGL 3.3和OpenGL 4.0一起发布，带来了新的标准规范，自此之后GLSL的版本号与OpenGL版本号保持一致，即GLSL 3.3/4.0，同时新增了曲面细分着色器。</li>  <li>2017年7月，OpenGL 4.6发布，增加了SPIR-V 着色器，SPIR-V 使高级语言前端能够以标准化的中间形式发出程序，供 Vulkan、OpenGL 或 OpenCL 驱动程序摄取。</li></ul><h3 id=\"vulkan历史\">Vulkan历史</h3><p>Vulkan于Khronos在GDC 2015上首次公开，它也曾被叫做是“Next Generation OpenGL Initiative”(glNext)，旨在对OpenGL和OpenGL ES的一次重新设计，将两者统一到一个API中。</p><p>与OpenGL相同它也是一个跨平台的2D、3D图形API，不同的是它是一个Low Level图形API，即会开放出更多与内存控制相关的接口。</p><p>Vulkan能较好的支持多线程并行（OpenGL4.0+是为单线程设计的），这使得它的操作和维护比OpenGL复杂得多。另外OpenGL使用GLSL来编写着色器，每个显卡商需要为GLSL单独编写编译器来转换为在显卡上运行的机器码。在这点上Vulkan不同，它会先由操作系统把GLSL预编译为一种名为SPIR-V（Standard Portable Intermediate Representation）的中间码，再由显卡商编写Vulkan驱动程序对GPU进行一些特定的优化，加载速度变快了还节省了显卡商的开发及维护成本。这和Direct3D的HLSL预编译很像。</p><ul>  <li>2016年2月，Vulkan 1.0发布。</li>  <li>2018年2月，Khronos发布MoltenVK，可以理解为MoltenVK是用Metal实现了Vulkan的API，这使得macOS和iOS也能支持Vulkan了。虽然绕了趟远路，但从Dota2的表现上来看，依旧比OpenGL高出了50%的帧率。</li>  <li>2018年3月，Khronos和GPUOpen公开V-EZ项目，它是“Easy Mode”的缩写，是一个基于Vulkan的中间层，相比于Vulkan它保留了Vulkan的大部分API，提供了更简单的内存管理API，封装了诸多底层细节。旨在开发者更容易上手Vulkan。</li>  <li>2018年3月，Vulkan 1.1发布。支持了HLSL语法以及光线追踪。可以更好的模拟DirectX 12。spirv更新至1.3。</li>  <li>2020年1月，Vulkan 1.2发布。新增了23项扩展以及更好的支持HLSL。</li></ul><h3 id=\"direct3d历史\">Direct3D历史</h3><p>Direct3D 是 Microsoft Windows 的图形应用程序编程接口 (API)。作为 DirectX 的一部分，Direct3D 用于在性能很重要的应用程序（例如游戏）中渲染 3D 图形。Direct3D 使用硬件加速（如果它在显卡上可用），允许对整个 3D 渲染管道进行硬件加速，也支持仅部分加速。</p><p>Direct3D 公开了 3D 图形硬件的高级图形功能，包括 Z 缓冲、W 缓冲、模板缓冲、空间抗锯齿、alpha 混合、颜色混合、Mipmapping、纹理混合，剪裁、剔除、大气效果、透视校正纹理映射、可编程 HLSL 着色器等其他图形效果。与其他 DirectX 技术的集成使 Direct3D 能够提供视频映射、2D 覆盖平面中的硬件 3D 渲染甚至精灵等功能，从而在交互式媒体关系中提供 2D 和 3D 图形的使用。</p><p>Direct3D 是一种立即模式图形 API。它为每个显卡的 3D 功能（转换、剪辑、照明、材质、纹理、深度缓冲等）提供了一个低级接口。立即模式呈现三个主要抽象：设备、资源和交换链。</p><p>设备有四种类型，HAL（硬件抽象层）设备（支持硬件加速）、参考设备（模拟不可用的新功能）、软件设备（执行软件渲染）、空设备。</p><p>每个设备都有一个交换链，交换链由一个或多个后台缓冲区组成，渲染发生在后台缓冲区中。</p><p>资源有四个属性，资源类型（表面网格、立方体纹理、索引缓冲、顶点缓冲等）、池（内存管理与存储位置）、格式（资源在内存中的布局）、用法（用标志位方式确定如何使用资源）。</p><ul>  <li>1996年6月，第一版Direct3D 2.0跟随DirectX 2.0发布，有”Retained mode”和”Immediate mode”。</li>  <li>1998年8月，Direct3D 6.0发布，增加了许多新特性，如Multitexture、模板缓冲区等。</li>  <li>1999年9月，Direct3D 7.0支持了T&amp;L硬件加速。</li>  <li>2000年11月，Direct3D 8.0发布，引进了可编程管道概念，新增了顶点/片段着色器，这个时候Direct3D完全超越了OpenGL。</li>  <li>2002年12月，Direct3D 9.0发布，发布了Shader Model 2.0。支持浮点纹理格式、MRT（Multiple render targets），9.0是最后一个支持WindowsXP的版本。</li>  <li>2006年11月，Direct3D 10.0发布，仅支持Windows Vista以上操作系统。固定功能管线被淘汰，取而代之的是可编程渲染管线。新增了几何着色器阶段，发布了Shader Model 4.0。</li>  <li>2009年7月，Direct3D 11.0与Windows7一块被发布，Direct3D 11.0新增了曲面细分着色器和Computer Shader，支持了多线程处理技术，发布了Shader Model 5.0。</li>  <li>2015年1月，Direct3D 12.0包含在Windows10一块被发布，更好支持多核心、多线程的优化，降低GPU处理瓶颈，并提升硬件功耗表现。简化了Direct3D 11中的管道状态对象（Pipeline state objects）。</li>  <li>2018年10月，发布了Direct3D 12光线追踪DirectX Raytracing (DXR)的扩展包。</li></ul><h3 id=\"metal历史\">Metal历史</h3><p>Metal是一款Low Level、Low Overhead的3D图形API，由苹果公司开发，并在2014年6月随iOS8公开。相比于OpenGL，Metal对底层拥有更大的操控性，同时又有着多线程上大量的优化。Metal Shader使用的是Metal Shader Language（MSL），是一种基于C++ 14的语言。</p><ul>  <li>2014 年 6 月，Metal发布。在由 Apple A7 或更高版本驱动的 iOS 设备上可用，并自 2015 年 6 月 8 日起在运行 OS X El Capitan 的 Mac（2012 型号或更高版本）上可用。</li>  <li>2017 年 6 月，Metal第二个版本发布，Metal 2 可以在 Xcode 中实现更高效的分析和调试、加速机器学习、降低 CPU 工作负载、支持 macOS 上的虚拟现实，以及 Apple A11 GPU 的特性。</li>  <li>2020 年，Apple 宣布将 Mac 迁移到 Apple 芯片，使用 Apple 芯片的 Mac 将配备 Apple GPU，其功能集结合了以前在 macOS 和 iOS 上可用的功能，并将能够利用为 Apple GPU 的基于图块的延迟渲染 (TBDR) 架构量身定制的功能。</li></ul><h3 id=\"图形软件发展史\">图形软件发展史</h3><p>20世纪80年代，出现了许多著名的新型商业软件产品，例如Autodesk公司的AutoCAD专注于平面设计，以及它的另一个作品3D Studio专注于3D模型设计，Alias Research公司开发的Alias专注于3D模型设计。Softimage公司开发的Softimage 3D专注于集成建模、动画、渲染并成为业内标准的动画解决方案，副作用软件公司开发的Side Effects软件将程序化建模和运动产品开发成高度紧密集成的2D / 3D动画软件，并融合了多项技术突破。</p><p>到了20世纪90年代，随着硬件技术的提升，图形软件技术也开始蓬勃发展，产生一批顶级的3D图形软件，例如CAD、3MAX、MAYA、SOFTIMAGE、HOUDINI等。借助这些软件，可以大大降低制作模型和动画的成本。</p><p>因此90年开始，图形技术发展进入了重大的改革，不仅在技术上大举突破了各类瓶颈，在图形软件上有了大的进化，而且计算机图形技术开始渗透影视、动画、游戏等各行各业。</p><h2 id=\"图形技术发展史\">图形技术发展史</h2><p>群体动物移动行为，群体行为的数学模型首先由Craig Reynolds于1986年在计算机上模拟，并很快在3D动画开始大规模使用。</p><p>动作捕捉，80年代就开始基于计算机的动作捕作为摄影测量分析工具，表演者佩戴标记每个关节附近的标记之间的位置或角度来识别运动。</p><p>运动跟踪，90年代中期，匹配移动（也称为运动跟踪或摄像头跟踪）虽然与动作捕捉有关，但却是一种完全不同的技术。除了使用特殊的相机和传感器来记录主体的运动外，还会将移动作品与预先存在的实时镜头相匹配，并单独使用计算机软件通过多个框架跟踪场景中的特定点，从而允许插入CGI元素以相对于现有材料的正确位置、比例、方向和运动进入镜头。</p><p>虚拟演播室，虚拟演播室是一个工作室，这种虚拟场景在90年代电视节目中很普遍，它可以以无缝方式，实时组合人或其他真实物体，包括计算机生成的环境和物体。它要求3D CGI环境自动锁定，进而精确跟踪角色在实时相机和镜头前的任何移动。这种系统的精髓在于它使用某种形式的相机来跟踪创建一个实时的数据流，同时会使用CGI渲染软件，软件使用相机跟踪数据并生成完美拼接的虚拟合成图像。</p><p>法线贴图，1996年，Krishnamurty和Levoy发明了法线贴图，这是对Jim Blinn 凹凸贴图的改进。</p><p>PBR&amp;卡通材质，这两个技术都是围绕画风的，PBR 指的是”Physically Based Rendering”， 简化了物理材质的计算流程，用接近物理正确的效果来渲染材质表面，材质包括绝缘体和金属材质两种。卡通渲染（英语：Toon Shading）是一种非真实感绘制（NPR），卡通渲染又称赛璐珞渲染（Cel-shading），旨在使电脑生成的图像呈现出手绘般的效果。为了使图像可以与漫画或者卡通达到形似的效果，专业人员通常使用卡通渲染着色器进行处理。</p><p>高动态光照（HDRR，High-Dynamic Range rendering），人在黑暗的地方，为了看清楚对象，瞳孔会放大，以吸收更多光线；当突然走到光亮的地方，瞳孔来不及收缩，所以眯起眼睛，保护视网膜上的视神经。而电脑无法判断光线明暗，唯有靠HDRR技术模拟这效果——人眼自动适应光线变化的能力。方法是快速将光线渲染得非常光亮，然后将亮度逐渐降低。HDRR的最终效果是亮处的效果是鲜亮，而黑暗处的效果是能分辨物体的轮廓和深度，而不是以往的一团黑。</p><p>体积光，可以让用户看到光束效果，例如在一个画面中用户能看到太阳光束射入敞开的窗户，这就是典型的体体积光技术体现。</p><p>early-z-test，发生在顶点着色器后像素着色器之前的深度测试，原本深度测试在填充率、光照、纹理或像素着色器成为主要瓶颈的情况下已经成为了一个很好的优化，early-z-test这种技术将深度测试更进一步，提前到顶点着色器之后去完成，它节省了片元着色器的计算，但前提是片元着色器中不会有alpha混合和discard操作。</p><p>光线追踪（Ray Tracing），是三维计算机图形学中的特殊渲染算法，追踪光线从来源开始照射到物体上，再由物体反射的光线“路径”，由于完整运算所有路径十分消耗运算资源，因此现有光线追踪技术仅运算“目所能及”的光线路径，由于是从玩家视角开始进行运算，有时被误解为光线追踪是追踪“从眼睛发出的光线”。通过这样一项技术生成编排好的场景的数学模型显现出来。这样得到的结果类似于光线投射与扫描线渲染方法的结果，但是这种方法有更好的光学效果，例如对于反射与折射有更准确的模拟效果，并且效率非常高，所以当追求高质量的效果时经常使用这种方法。 在物理学中，光线追迹可以用来计算光束在介质中传播的情况。在介质中传播时，光束可能会被介质吸收，改变传播方向或者射出介质表面等。我们通过计算理想化的窄光束（光线）通过介质中的情形来解决这种复杂的情况。 在实际应用中，可以将各种电磁波或者微小粒子看成理想化的窄波束（即光线），基于这种假设，人们利用光线追迹来计算光线在介质中传播的情况。光线追迹方法首先计算一条光线在被介质吸收，或者改变方向前，光线在介质中传播的距离，方向以及到达的新位置，然后从这个新的位置产生出一条新的光线，使用同样的处理方法，最终计算出一个完整的光线在介质中传播的路径。</p><p>其他等等渲染技术非常多，这里点到为止不再延伸开来。</p><h2 id=\"游戏制作团队\">游戏制作团队</h2><p>这里简单介绍下游戏制作团队，虽然大多数人都知道这些知识，但不妨碍我们回顾与总结。</p><p>艺术家：概念艺术家、三维建模师、纹理艺术家、灯光师、动画师、动捕演员、音效师、配音演员、作曲家等</p><p>产品设计：游戏设计师、数值设计师、关卡设计师、系统设计师、AI设计师、剧情设计师、操作设计师、技能设计师、制作人等</p><p>软件工程师：引擎工程师、渲染工程师、游戏系统工程师、AI工程师、网络工程师、构建工程师、工具开发工程师、架构工程师、效能工程师、中间件工程师、安全工程师、测试工程师等</p><h2 id=\"运行时引擎架构概述\">运行时引擎架构概述</h2><p>游戏引擎通常由工具套件和运行时组件两部分构成。这里我们主要来说说运行时组件部分。</p><p>与所有软件系统一样，游戏引擎也是由软件层构建的，即我们通常说的，上层依赖下层，下层不依赖上层，每层中各模块之间不相互依赖，这样的低耦合、高重用度架构在大型软件系统架构中是非常关键的设计。</p><p>《游戏引擎架构》一书中对整体架构做了介绍，但我认为内容过于粗浅，也有点过时了，于是我自己重新画了架构图。</p><p>我把整个运行时引擎架构分为十三个层级，每个层级都是只依赖下层，这十三个层级分别为：</p><ol>  <li>目标硬件层</li>  <li>设备驱动层</li>  <li>操作系统层</li>  <li>平台独立层</li>  <li>第三方中间件</li>  <li>核心库</li>  <li>资产管理层</li>  <li>底层渲染器</li>  <li>引擎核心层</li>  <li>引擎应用层</li>  <li>业务基础层</li>  <li>游戏框架层</li>  <li>游戏业务层</li></ol><p>下面来简单解释一下每个层级的拆解理念：</p><p>目标硬件层，代表用来执行游戏的主机硬件。</p><p>设备驱动层，是操作系统或硬件商提供的最低阶软件组件。负责管理硬件资源、也隔离了操作系统及上层引擎。</p><p>操作系统层，管理协调整台计算机上多个程序的执行工作，进程通过调用操作系统的接口来访问操作系统。</p><p>平台独立层，包装了常用的库和操作系统接口，供所有平台使用。</p><p>第三方中间件，提供了独立的解决方案，简化开发流程，缩短开发时间。包括标准库、图形接口等。</p><p>核心库，是由许许多多独立的软件工具库组成。这些库常常被引擎上层频繁使用，同时也是非常实用的软件工具。</p><p>资产管理层，提供资源增删改查的完整解决方案，通常会提供一组统一的接口，供引擎和业务去访问任意的游戏资源。</p><p>底层渲染器，提供最原始的渲染功能，根据应用层的数据调用图形API进行渲染。它通常会经过封装，从业务渲染提交的过程中拆解出来。</p><p>引擎核心层，为应用层提供了最核心的功能，包括音频、动画、物理、剔除与合批、手柄设备接口等。</p><p>引擎应用层，在核心层之上建立起来的引擎业务，包括性能剖析工具、UI核心框架、粒子系统、后处理系统等。</p><p>业务基础层，引擎为游戏框架搭建而做的基础功能，是提供给实现游戏逻辑的重要功能与接口。</p><p>游戏框架层，通过调用业务基础层来搭建的游戏框架，是游戏实现自身逻辑的框架，也是游戏逻辑的核心。</p><p>游戏业务层，是实现具体游戏业务的逻辑，通过调用游戏框架来实现具体的业务逻辑。</p><h3 id=\"游戏引擎架构图\">游戏引擎架构图</h3><p>在拆解了整个引擎的架构时，由于模块太多，因此只列了一些主要的模块，保持了基本架构的完整性：</p><p>架构图中的重要模块，将在后面的文章中做详细的分析和解剖。</p><h3 id=\"参考资料\">参考资料：</h3><p>《游戏引擎架构》 译者：叶劲峰</p><p>《3D游戏引擎发展史》</p><p>https://www.bilibili.com/read/cv6499569/</p><p>《游戏引擎wiki》</p><p>https://zh.wikipedia.org/wiki/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E</p><p>《你不能不知道的计算机图形技术发展史》1、2</p><p>https://www.bilibili.com/read/cv196689</p><p>https://www.bilibili.com/read/cv221830</p><p>《了解图形接口》</p><p>https://www.jianshu.com/p/9dea5f163837</p><p>《图形API发展历史》</p><p>https://blog.csdn.net/ce1061183126/article/details/106159169</p><p>《卡通渲染 Wiki》</p><p>https://zh.wikipedia.org/wiki/%E5%8D%A1%E9%80%9A%E6%B8%B2%E6%9F%93</p><p>《高动态光照渲染》</p><p>https://zh.wikipedia.org/wiki/%E9%AB%98%E5%8A%A8%E6%80%81%E5%85%89%E7%85%A7%E6%B8%B2%E6%9F%93</p><p>《Metal Wiki》</p><p>https://en.wikipedia.org/wiki/Metal_(API)#History</p><p>《Direct3D Wiki》</p><p>https://en.wikipedia.org/wiki/Direct3D#Direct3D_12</p><p>《OpenGL Wiki》</p><p>https://en.wikipedia.org/wiki/OpenGL</p><p>《Vulkan Wiki》</p><p>https://en.wikipedia.org/wiki/Vulkan_(API)</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484890&amp;idx=1&amp;sn=1d319050c82fed232d22f1f3dfce0cd3&amp;chksm=fc2260ddcb55e9cbbda832e90def1e8e7440b7ffc85c60264be83d9c6bc62162c5b05839839b&amp;token=834275592&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/08/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B042",
            
            
            
            "tags": ["读书笔记","前端技术"],
            
            "date_published": "2021-08-29T00:00:00+08:00",
            "date_modified": "2021-08-29T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/08/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B041",
            "title": "读书笔记(四十一) 《心流》#2 为何要培养独立意识",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：在2020年初就买了《心流》，直到2021年1月才读完第一遍，读完的那一刻，我知道我又打开了一个新世界。不得不承认就是这本书让我的专注力提高了整整一个级别，这是最让我非常兴奋的地方。而我只是读了第一遍，吸收不到10%的结果，可想而知它的魔力有多么强大。于是决定好好回顾总结一下整本书，便开启了第二遍、第三遍的读书之旅。读此书的起源是由于我在平时工作、交流、学习时，常常难以集中注意力，因此带着好奇心阅读了这本书。我猜大家应该也和我一样，常常为自己难以击中注意力而烦恼，其实我们都希望自己在专注做一件事情的时候能够拥有更高的效率。本书的核心是心流的最优体验，简单来说就是“如何让你高兴地专注”。作者想表达的是，当你的心流会的体验最佳时，也是学习效率最高的时候，同时也是你最幸福的时刻。书本中讲到了关于学习、工作、运动、社交等各方面的心流原理和技巧，我作为知识的搬运工，做了一些精炼和总结的工作。正文：简单回顾下前文，前文我们说，结果其实并不重要，过程才是我们幸福的来源，专注就是注重过程保持幸福的一种方法。我们常常心灵处于混乱状态，专注能让我们保持有序的心流。人生要的不是最后的终点，而是每时每刻点点滴滴成长的过程，成长本身就是我们的目的。为何我们在为拥有幸福而追求幸福作者说我们常常为拥有幸福而追求幸福，同时我们也在追求其他目标，例如健康、美貌、金钱、权利，追求这些无非也是因为我们以为拥有这些就能得到幸福。维克多在《活出意义来》序言里写道：不要以成功为目标，你越是对它念念不忘，就越有可能错过它。因为成功如同幸福，不是追求就能得到；它必须因缘际会，是一个人全心全意投入并把自己置之度外时，意外获得的副产品。经研究表明，运动、游戏、音乐、绘画、嗜好等都是比较容易产生心流的活动，但我们不能光靠游戏和艺术来改善我们的生活啊，所以我们要学会如何将枯燥的工作转化为产生心流的活动。我们大多数人几乎一生时间都花在工作和社交上，因此学习把工作转化为产生心流的活动，以及设法与父母、配偶、儿女、朋友相处得更愉快，是格外重要的事。如何反转苦难的生活不仅如此，生活还不断给我们各种挑战和苦难，这阻碍了我们享受幸福享受人生。那么如何不为苦难所阻，继续享受人生呢？人生的悲剧在所难免，即使是幸运儿也难免遭逢压力，但遭受这些打击未必就是与幸福绝缘。人在压力下的反应，往往决定他们是否能转祸为福，否则只能徒然地受苦受难。如果我们能做到在困难和压力下转祸为福，就能对人生掌控自如，使生命丰富璀璨。此时，是否苗条、是否富裕、是否掌权都已无关紧要，甚至最单调的体验也会变得趣味盎然。幸福之所以难求是因为我们的贪得无厌的欲望难以填满我们说一个人如果不靠任何支持，试图仅凭自己的力量去追求幸福，很可能他会从极致的生理快乐和社会公认的最具吸引力的事物开始着手。因此财富、权势、性就成为很多人奋斗的主要目标，然而大多数人并不明白这些并不能改善我们生活的品质。那该怎么办呢？作者说唯有直接控制体验感受，从我们所做的每一件事、每一个此时此刻中汲取快乐，才能克服欲望的障碍，从而得到满足。各种证据表明，大多数人会陷入期望值不断升高的恶性循环中无力自拔，但也有不少人能从中逃脱出来。这些人或许物质条件不够优越，却仍然能改善生活品质，他们不但自己知足常乐，也常能使周遭的人生活得比其他人更快乐。这种人充满活力，愿意接纳各式各样的经历，活到老学到老，而且对别人及周遭的环境有强烈的责任感。那么到底有多少人热爱自己的工作，满意自己的运气，不追悔过去，对前途满怀信心呢？答案是：极少的。这种普遍的“病态”并非直接由外界因素引起。不满的根源存乎于一心，自己的问题唯有依靠自己才能解决。我们从小到大，在渐渐长大的过程中，从满怀希望的无知少年，长成冷静沉稳的大人。童年或许令人痛苦，青春期或许令人困惑，但对大多数人而言，痛苦与困惑的背后，至少还有个长大后一切会好转的希望。然而，长大后，各种老化的迹象明明白白地告诉我们“你的时间快到了，准备动身吧”，但很少人在这时候已经准备妥当。人们会反问，“等一下，不可能是我吧，我还没开始生活呢，我该赚的那些钱在哪儿，我该享受的那些好时光在哪儿”这番觉悟使我们有种受骗上当的感觉，似乎是慈悲的命运为我们安排好的一切。当这番觉悟来临时，每个人都会以不同的方式面对这个问题。有些人选择继续奋斗不息，金钱、名誉、权利，不得到誓不罢休。有些人则选择对症下药，节食、健身、跳舞、整容、上提高自信的课、参加权贵人士的午餐聚会等等。但不久人们就会发现，这些零星的解决方案根本发挥不了作用。无论下多少功夫，老化的定律不会因此而改写。提升了自信，无形中却疏远了朋友。花太多时间结交新朋友，又疏忽了配偶和家人。人们会发现，堤坝太多缺口，濒临溃决，根本来不及抢救。在无法同时满足太多要求的挫折之下，有些人干脆投降认输，躲进自己的小天地。他们可能培养一种高雅的嗜好，如搜集抽象画或陶瓷人像，甚至也会沉溺于酒精或麻醉品构筑的迷幻堡垒里。这些异国情调的娱乐和所费不菲的消遣活动，纵然能使人暂时忘记根本的疑问，却不能提供答案。我们是如何沦为社会控制的奴隶心理学家指出，文明就是建立在压抑个人欲望基础上的。社会成员不论乐意与否，都被迫接受既定的习惯与技能，否则就不可能维持社会秩序和复杂的分工制度。所以对于我们，个人的社会化是必然的。社会化的真谛在于使个人依赖社会的控制，并对赏罚有既定的反应。社会化的最高境界就是使每个人都完全认同社会秩序，根本不想触犯任何规则。我们应该了解到，“寻求快乐”是基因为物种延续而设的一种即时反射，其目的并非个人利益。例如，美食的快乐、性爱的快乐、娱乐的快乐都其实是人类基因的布局。跟随基因的反应，享受自然的乐趣，并没有什么不好，但我们应该认清事实真相，在必要的时候，按照自己的优先顺序，做自己的主人。彻底社会化的人，只追求周遭他人认定的、应该期望的东西，这些东西往往都是与天性密切结合的欲望。他可能会有机会经历到许多难能可贵的事，但由于这些事与他们的欲望不符而被他们完全忽略掉。其实他们在意的并非他们现在拥有什么，而是满足别人的要求后能获得什么。这种沦为社会控制的奴隶人，只知道周而复始地追逐“一到手”就化为泡影的奖赏，他们的局限性太强，被社会和他人牢牢地控制。虽然在这个复杂的社会求生，绝对有必要实现外在的目标而去暂时牺牲一些自我意识，但不必因此而成为傀儡。为了不让自己成为傀儡，最好的方法是不以社会的奖赏为念，试着以自己所能控制的奖赏取而代之。当然这也并不表示，我们要完全放弃社会认可的每项目标，而是在社会用以利诱我们的目标之外，另行建立自己的目标。然而，从社会制约下解放自我，最重要的步骤就是，时时刻刻发掘每一事件中的回馈。如果我们学会在不断向前推进的体验中找到快乐与意义，社会制约的重担就会从肩上自动滑落。当奖赏不再受外在力量管制时，生命的权力就回到了个人手中。社会根据生物倾向而设计的“刺激–反应”模式，就是受外界所控制的。无论是迷人的广告使我们对产品垂涎不已，还是老板皱一下眉头就使我们整天提心吊胆，都代表着我们没有决定体验内涵的自由。人们害怕的其实是自己对事物的看法，而非事物本身。外界事物令你痛苦并不是因为它们打扰了你，而是归因于你对它们的判断，而你有能力立刻消除这种判断。培养独立意识有多难在亚洲有很多控制意识的技巧，能使人达到高层次的满足感。例如，印度瑜伽、佛教禅宗、宗教祷告等，目的都在于摆脱混沌的威胁和生理冲动的制约，从而释放内在生命。但各派的哲学都依赖于当时所创生的环境，这些额外的成分若不能从基本要素中剔除，那么通往自由的路上就不免要长出许多莠草。形式一旦逾越内容，追寻者就只得重回起点。所以想要培养我们的独立意识，对意识的控制就不能予以制度化，一旦成为社会规则与标准，它就失去了原有的作用。在时代更迭频繁的时代，每隔几年，培养独立意识所需的条件就会变化，我们必须重新加以考虑与组合。既然掌握人生是永远的中心议题，现代知识对此有什么看法呢？一个人又如何消除焦虑与恐惧，摆脱对社会奖赏的患得患失之心呢？作者给出了简短的回答，控制意识才能控制体验的品质，任何在这方面的进步都能够提升生活的品质，使快乐更快乐、也更有意义。已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484880&amp;idx=1&amp;sn=869424bd26f3c3fd8524ede6ced2d7a0&amp;chksm=fc2260d7cb55e9c16f0a6d8c314dcb211bd43e7e6143d5f2dceee208ded17bb9bcd5d662854f&amp;token=1516544318&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h2 id=\"背景\">背景：</h2><p>在2020年初就买了《心流》，直到2021年1月才读完第一遍，读完的那一刻，我知道我又打开了一个新世界。</p><p>不得不承认就是这本书让我的专注力提高了整整一个级别，这是最让我非常兴奋的地方。而我只是读了第一遍，吸收不到10%的结果，可想而知它的魔力有多么强大。</p><p>于是决定好好回顾总结一下整本书，便开启了第二遍、第三遍的读书之旅。</p><p>读此书的起源是由于我在平时工作、交流、学习时，常常难以集中注意力，因此带着好奇心阅读了这本书。</p><p>我猜大家应该也和我一样，常常为自己难以击中注意力而烦恼，其实我们都希望自己在专注做一件事情的时候能够拥有更高的效率。</p><p>本书的核心是心流的最优体验，简单来说就是“如何让你高兴地专注”。</p><p>作者想表达的是，当你的心流会的体验最佳时，也是学习效率最高的时候，同时也是你最幸福的时刻。</p><p>书本中讲到了关于学习、工作、运动、社交等各方面的心流原理和技巧，我作为知识的搬运工，做了一些精炼和总结的工作。</p><h2 id=\"正文\">正文：</h2><p>简单回顾下前文，前文我们说，结果其实并不重要，过程才是我们幸福的来源，专注就是注重过程保持幸福的一种方法。我们常常心灵处于混乱状态，专注能让我们保持有序的心流。人生要的不是最后的终点，而是每时每刻点点滴滴成长的过程，成长本身就是我们的目的。</p><h2 id=\"为何我们在为拥有幸福而追求幸福\">为何我们在为拥有幸福而追求幸福</h2><p>作者说我们常常为拥有幸福而追求幸福，同时我们也在追求其他目标，例如健康、美貌、金钱、权利，追求这些无非也是因为我们以为拥有这些就能得到幸福。</p><p>维克多在《活出意义来》序言里写道：</p><h3 id=\"不要以成功为目标你越是对它念念不忘就越有可能错过它\">不要以成功为目标，你越是对它念念不忘，就越有可能错过它。</h3><h3 id=\"因为成功如同幸福不是追求就能得到它必须因缘际会是一个人全心全意投入并把自己置之度外时意外获得的副产品\">因为成功如同幸福，不是追求就能得到；它必须因缘际会，是一个人全心全意投入并把自己置之度外时，意外获得的副产品。</h3><p>经研究表明，运动、游戏、音乐、绘画、嗜好等都是比较容易产生心流的活动，但我们不能光靠游戏和艺术来改善我们的生活啊，所以我们要学会如何将枯燥的工作转化为产生心流的活动。</p><p>我们大多数人几乎一生时间都花在工作和社交上，因此学习把工作转化为产生心流的活动，以及设法与父母、配偶、儿女、朋友相处得更愉快，是格外重要的事。</p><h2 id=\"如何反转苦难的生活\">如何反转苦难的生活</h2><p>不仅如此，生活还不断给我们各种挑战和苦难，这阻碍了我们享受幸福享受人生。</p><p>那么如何不为苦难所阻，继续享受人生呢？</p><p>人生的悲剧在所难免，即使是幸运儿也难免遭逢压力，但遭受这些打击未必就是与幸福绝缘。</p><h3 id=\"人在压力下的反应往往决定他们是否能转祸为福否则只能徒然地受苦受难\">人在压力下的反应，往往决定他们是否能转祸为福，否则只能徒然地受苦受难。</h3><h3 id=\"如果我们能做到在困难和压力下转祸为福就能对人生掌控自如使生命丰富璀璨\">如果我们能做到在困难和压力下转祸为福，就能对人生掌控自如，使生命丰富璀璨。</h3><h3 id=\"此时是否苗条是否富裕是否掌权都已无关紧要甚至最单调的体验也会变得趣味盎然\">此时，是否苗条、是否富裕、是否掌权都已无关紧要，甚至最单调的体验也会变得趣味盎然。</h3><h2 id=\"幸福之所以难求是因为我们的贪得无厌的欲望难以填满\">幸福之所以难求是因为我们的贪得无厌的欲望难以填满</h2><h3 id=\"我们说一个人如果不靠任何支持试图仅凭自己的力量去追求幸福很可能他会从极致的生理快乐和社会公认的最具吸引力的事物开始着手\">我们说一个人如果不靠任何支持，试图仅凭自己的力量去追求幸福，很可能他会从极致的生理快乐和社会公认的最具吸引力的事物开始着手。</h3><h3 id=\"因此财富权势性就成为很多人奋斗的主要目标然而大多数人并不明白这些并不能改善我们生活的品质\">因此财富、权势、性就成为很多人奋斗的主要目标，然而大多数人并不明白这些并不能改善我们生活的品质。</h3><p>那该怎么办呢？作者说唯有直接控制体验感受，从我们所做的每一件事、每一个此时此刻中汲取快乐，才能克服欲望的障碍，从而得到满足。</p><p>各种证据表明，大多数人会陷入期望值不断升高的恶性循环中无力自拔，但也有不少人能从中逃脱出来。</p><h3 id=\"这些人或许物质条件不够优越却仍然能改善生活品质他们不但自己知足常乐也常能使周遭的人生活得比其他人更快乐\">这些人或许物质条件不够优越，却仍然能改善生活品质，他们不但自己知足常乐，也常能使周遭的人生活得比其他人更快乐。</h3><h3 id=\"这种人充满活力愿意接纳各式各样的经历活到老学到老而且对别人及周遭的环境有强烈的责任感\">这种人充满活力，愿意接纳各式各样的经历，活到老学到老，而且对别人及周遭的环境有强烈的责任感。</h3><p>那么到底有多少人热爱自己的工作，满意自己的运气，不追悔过去，对前途满怀信心呢？答案是：极少的。</p><p>这种普遍的“病态”并非直接由外界因素引起。不满的根源存乎于一心，自己的问题唯有依靠自己才能解决。</p><p>我们从小到大，在渐渐长大的过程中，从满怀希望的无知少年，长成冷静沉稳的大人。</p><p>童年或许令人痛苦，青春期或许令人困惑，但对大多数人而言，痛苦与困惑的背后，至少还有个长大后一切会好转的希望。</p><p>然而，长大后，各种老化的迹象明明白白地告诉我们“你的时间快到了，准备动身吧”，但很少人在这时候已经准备妥当。</p><p>人们会反问，“等一下，不可能是我吧，我还没开始生活呢，我该赚的那些钱在哪儿，我该享受的那些好时光在哪儿”</p><p>这番觉悟使我们有种受骗上当的感觉，似乎是慈悲的命运为我们安排好的一切。</p><p>当这番觉悟来临时，每个人都会以不同的方式面对这个问题。有些人选择继续奋斗不息，金钱、名誉、权利，不得到誓不罢休。有些人则选择对症下药，节食、健身、跳舞、整容、上提高自信的课、参加权贵人士的午餐聚会等等。</p><p>但不久人们就会发现，这些零星的解决方案根本发挥不了作用。</p><p>无论下多少功夫，老化的定律不会因此而改写。</p><p>提升了自信，无形中却疏远了朋友。</p><p>花太多时间结交新朋友，又疏忽了配偶和家人。</p><p>人们会发现，堤坝太多缺口，濒临溃决，根本来不及抢救。</p><p>在无法同时满足太多要求的挫折之下，有些人干脆投降认输，躲进自己的小天地。</p><p>他们可能培养一种高雅的嗜好，如搜集抽象画或陶瓷人像，甚至也会沉溺于酒精或麻醉品构筑的迷幻堡垒里。</p><p>这些异国情调的娱乐和所费不菲的消遣活动，纵然能使人暂时忘记根本的疑问，却不能提供答案。</p><h2 id=\"我们是如何沦为社会控制的奴隶\">我们是如何沦为社会控制的奴隶</h2><h3 id=\"心理学家指出文明就是建立在压抑个人欲望基础上的社会成员不论乐意与否都被迫接受既定的习惯与技能否则就不可能维持社会秩序和复杂的分工制度\">心理学家指出，文明就是建立在压抑个人欲望基础上的。社会成员不论乐意与否，都被迫接受既定的习惯与技能，否则就不可能维持社会秩序和复杂的分工制度。</h3><p>所以对于我们，个人的社会化是必然的。社会化的真谛在于使个人依赖社会的控制，并对赏罚有既定的反应。社会化的最高境界就是使每个人都完全认同社会秩序，根本不想触犯任何规则。</p><h3 id=\"我们应该了解到寻求快乐是基因为物种延续而设的一种即时反射其目的并非个人利益例如美食的快乐性爱的快乐娱乐的快乐都其实是人类基因的布局\">我们应该了解到，“寻求快乐”是基因为物种延续而设的一种即时反射，其目的并非个人利益。例如，美食的快乐、性爱的快乐、娱乐的快乐都其实是人类基因的布局。</h3><p>跟随基因的反应，享受自然的乐趣，并没有什么不好，但我们应该认清事实真相，在必要的时候，按照自己的优先顺序，做自己的主人。</p><h3 id=\"彻底社会化的人只追求周遭他人认定的应该期望的东西这些东西往往都是与天性密切结合的欲望\">彻底社会化的人，只追求周遭他人认定的、应该期望的东西，这些东西往往都是与天性密切结合的欲望。</h3><h3 id=\"他可能会有机会经历到许多难能可贵的事但由于这些事与他们的欲望不符而被他们完全忽略掉\">他可能会有机会经历到许多难能可贵的事，但由于这些事与他们的欲望不符而被他们完全忽略掉。</h3><h3 id=\"其实他们在意的并非他们现在拥有什么而是满足别人的要求后能获得什么\">其实他们在意的并非他们现在拥有什么，而是满足别人的要求后能获得什么。</h3><h3 id=\"这种沦为社会控制的奴隶人只知道周而复始地追逐一到手就化为泡影的奖赏他们的局限性太强被社会和他人牢牢地控制\">这种沦为社会控制的奴隶人，只知道周而复始地追逐“一到手”就化为泡影的奖赏，他们的局限性太强，被社会和他人牢牢地控制。</h3><p>虽然在这个复杂的社会求生，绝对有必要实现外在的目标而去暂时牺牲一些自我意识，但不必因此而成为傀儡。</p><h3 id=\"为了不让自己成为傀儡最好的方法是不以社会的奖赏为念试着以自己所能控制的奖赏取而代之\">为了不让自己成为傀儡，最好的方法是不以社会的奖赏为念，试着以自己所能控制的奖赏取而代之。</h3><h3 id=\"当然这也并不表示我们要完全放弃社会认可的每项目标而是在社会用以利诱我们的目标之外另行建立自己的目标\">当然这也并不表示，我们要完全放弃社会认可的每项目标，而是在社会用以利诱我们的目标之外，另行建立自己的目标。</h3><p>然而，从社会制约下解放自我，最重要的步骤就是，时时刻刻发掘每一事件中的回馈。</p><p>如果我们学会在不断向前推进的体验中找到快乐与意义，社会制约的重担就会从肩上自动滑落。</p><p>当奖赏不再受外在力量管制时，生命的权力就回到了个人手中。</p><p>社会根据生物倾向而设计的“刺激–反应”模式，就是受外界所控制的。</p><p>无论是迷人的广告使我们对产品垂涎不已，还是老板皱一下眉头就使我们整天提心吊胆，都代表着我们没有决定体验内涵的自由。</p><h3 id=\"人们害怕的其实是自己对事物的看法而非事物本身外界事物令你痛苦并不是因为它们打扰了你而是归因于你对它们的判断而你有能力立刻消除这种判断\">人们害怕的其实是自己对事物的看法，而非事物本身。外界事物令你痛苦并不是因为它们打扰了你，而是归因于你对它们的判断，而你有能力立刻消除这种判断。</h3><h2 id=\"培养独立意识有多难\">培养独立意识有多难</h2><p>在亚洲有很多控制意识的技巧，能使人达到高层次的满足感。</p><p>例如，印度瑜伽、佛教禅宗、宗教祷告等，目的都在于摆脱混沌的威胁和生理冲动的制约，从而释放内在生命。</p><p>但各派的哲学都依赖于当时所创生的环境，这些额外的成分若不能从基本要素中剔除，那么通往自由的路上就不免要长出许多莠草。形式一旦逾越内容，追寻者就只得重回起点。</p><h3 id=\"所以想要培养我们的独立意识对意识的控制就不能予以制度化一旦成为社会规则与标准它就失去了原有的作用\">所以想要培养我们的独立意识，对意识的控制就不能予以制度化，一旦成为社会规则与标准，它就失去了原有的作用。</h3><h3 id=\"在时代更迭频繁的时代每隔几年培养独立意识所需的条件就会变化我们必须重新加以考虑与组合\">在时代更迭频繁的时代，每隔几年，培养独立意识所需的条件就会变化，我们必须重新加以考虑与组合。</h3><p>既然掌握人生是永远的中心议题，现代知识对此有什么看法呢？一个人又如何消除焦虑与恐惧，摆脱对社会奖赏的患得患失之心呢？</p><h3 id=\"作者给出了简短的回答控制意识才能控制体验的品质任何在这方面的进步都能够提升生活的品质使快乐更快乐也更有意义\">作者给出了简短的回答，控制意识才能控制体验的品质，任何在这方面的进步都能够提升生活的品质，使快乐更快乐、也更有意义。</h3><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484880&amp;idx=1&amp;sn=869424bd26f3c3fd8524ede6ced2d7a0&amp;chksm=fc2260d7cb55e9c16f0a6d8c314dcb211bd43e7e6143d5f2dceee208ded17bb9bcd5d662854f&amp;token=1516544318&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/08/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B041",
            
            
            
            
            
            "date_published": "2021-08-22T00:00:00+08:00",
            "date_modified": "2021-08-22T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/08/19/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A115",
            "title": "给女儿的信(十五) 如何表达",
            "summary": "女儿 教育 亲情",
            "content_text": "hi Sharon、Anne，爸爸喜欢你们哟。爸爸最近在学习如何表达。爸爸知道表达很重要，但由于爸爸前些年没有注意到自己表达上的问题，所以表达到现在还是很烂。爸爸最近在看有关表达方面的书，看了后发现自己在平时说话时有很多问题，但是以前一直没有察觉到。爸爸也在不断努力改进自己说话的能力，让自己说话更清楚，说出来的话让别人更容易懂。爸爸想让大家与我交流时更舒服，听的也更清楚。此外，爸爸也在看演讲类的书，爸爸想在表达上更进一步。爸爸参加了一个演讲培训的课程，在这个课程上，大家都要上去演讲，通过不断的上台练习演讲，爸爸现在进步了一些，但离真正的好的演讲还差很远，爸爸还要多努力，多学习，多上台。Sharon和Anne，我们一起加油。",
            "content_html": "<p>hi Sharon、Anne，爸爸喜欢你们哟。</p><p>爸爸最近在学习如何表达。爸爸知道表达很重要，但由于爸爸前些年没有注意到自己表达上的问题，所以表达到现在还是很烂。</p><p>爸爸最近在看有关表达方面的书，看了后发现自己在平时说话时有很多问题，但是以前一直没有察觉到。</p><p>爸爸也在不断努力改进自己说话的能力，让自己说话更清楚，说出来的话让别人更容易懂。</p><p>爸爸想让大家与我交流时更舒服，听的也更清楚。</p><p>此外，爸爸也在看演讲类的书，爸爸想在表达上更进一步。</p><p>爸爸参加了一个演讲培训的课程，在这个课程上，大家都要上去演讲，通过不断的上台练习演讲，爸爸现在进步了一些，但离真正的好的演讲还差很远，爸爸还要多努力，多学习，多上台。</p><p>Sharon和Anne，我们一起加油。</p>",
            "url": "http://www.luzexi.com/2021/08/19/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A115",
            
            
            
            
            
            "date_published": "2021-08-19T00:00:00+08:00",
            "date_modified": "2021-08-19T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/08/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B040",
            "title": "读书笔记(四十) 《非暴力沟通》#3 - 沟通中如何爱自己",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：表达能力和沟通技巧有诸多问题，工作和生活上出现了比较大的瓶颈，于是看了些表达和沟通方面的书，其中三本最为经典《非暴力沟通》、《关键对话》、《说话的艺术》。细细品读了这三本书并且收获满满，分享出来希望大家一同进步。看完书后反观自己以前的沟通技巧和表达方式，明白了以前自己在这些方面都有比较大的认知错误，回想起来可以用愚蠢来形容。既然有这么好的沟通技巧和表达方式，我希望将这些方法和技巧实实在在的落地到实际生活中，让生活、工作、学习更美好。下面我就以《非暴力沟通》这本书为主线，来阐述我们在沟通过程中遇到的一些问题和对应的解决方法。正文：简单回顾下前文，前面我们说在提出的请求要明确，请求越详细越具体，才能让别人更清楚的了解我们的想法。同时说了，倾听很重要，它能治愈身心也能预防潜在的暴力，倾听后向对方做出良好的反馈使得对话能够保持顺畅温和。这节也是非暴力沟通学习的最后一篇，主题是在沟通时如何爱自己。爱自己而不是自责非暴力沟通最重要的应用在于 - 爱护自己我们常常对自己做出负面的评价，严厉的苛责自己。但负面的自我评价使我们看不到生命的美，让我们忘记自己是“特殊的生命”，而把自己当做一个工具。如果我们习惯于将自己视为工具，充满各种缺陷的工具，那么自我憎恨是自然的。其实我们都希望自己所做的任何事情都是有益的，良好的自我评价的方式就要有助于学习，使我们的选择符合生命的需要。然而不幸的是，我们的自我评价方式往往是负面，这直接导致了自我憎恨，而无助于学习。许多人会陷入自责，他们认为自己所做的事情是错的，并且应当为此感到痛苦。虽然我们犯的错误揭示了我们的局限性从而引导我们成长，但陷入自责使得我们无法从错误中获益。作者认为我们的改变最好要出于对生命的爱，而不是出于羞愧或内疚这些具有负面影响的心理。因为羞愧是自我憎恨的一种形式，出于羞愧的行为不是自由快乐的行为。即使我们试图更加友善和体贴，一旦人们意识到我们行为背后的羞愧或内疚，他们对这些行为的欣赏也就比不上那些只是出于爱的行为了。我们的话语中常常带有一些容易引起羞愧和内疚的词，例如，“应该”，“不得不”，“必须”，举个简单的例子：  我应该早点知道  我真的应该戒烟了  我必须加强锻炼  我真的受不了自己，我必须改改一旦我们顺从了这些羞愧和内疚的命令，生活也就会失去了乐趣。如果我们经常责备自己、强迫自己，也使我们更像工具而不像人，从而引起自我的憎恨。因此当发现自己在做错误的事时，其实我们的挑战是如何对需要和价值观保持清醒的认识，这促进我们转变。其中专注于需要能帮助我们从自我评价中获益，那么怎样才算是“专注于需要”呢？下面作者为我们做了解释。我们应该尽可能的直面人生的苦难：在遇到挫折时，充分体会人生的悲哀和内心的渴望。感到遗憾是难免的，无须责备自己，它能帮助我们从经历中学习。专注于需要如果我们能专注于尚未满足的需要，我们就能从中获益并考虑如何满足它。只要我们对自己的需要保持清醒的认识，我们就能建设性地满足它们。反之，如果用苛刻的语言指责自己，我们不仅难以找到解决办法，而且容易陷于自我惩罚的痛苦中。那么什么是专注于需要呢？作者举了一个自己的例子：有一天他买了一件漂亮的外衣出席会议，在外衣口袋里放了一只钢笔，到达会议才发现钢笔帽忘盖了，外套上染上了一片黑色。他不停的训斥自己“你怎么可以这么粗心！”，此刻其实正是作者需要得到体谅的时刻。幸运的是他很快就意识到了自己的自责，于是他停下来，回想了下，发现其实他是想要照顾好自己，在匆忙地回应他人的请求时，多留意些自己的需要让自己更体面更舒适一些。想到这里，他的心情也开始变化，不再感到恼怒、羞愧和内疚，身体也放松了下来。故事中，作者把恼怒和内疚的情绪转移为观察自己“去了解自己，需要什么”，了解到了自己的真实需求后，心情也开始发生了变化，最后身体放松了下来。如果我们能致力于满足他人及自己健康成长的需要，那么即使艰难的工作也不乏乐趣。反之，如果我们的行为是出于义务、职责、恐惧、内疚或羞愧，那么即使有意思的事情也会变得枯燥无味。在我们的社会中内疚常常被运用来控制人，这造成指责他人常常成为一种习惯。有时为了使这种手段奏效，我们可能就会认为一个人可以主导另一个人的情绪。这是极其错误的想法。对于每个人来说，同一件事情有不同的需要，也导致了不同的感受。如果意识不到自己尚未满足的需要，一心考虑别人的过错，我们难免就会生气。其实我们无须压抑愤怒，只要我们专注于他人的感受和需要，愤怒也就不再存在。作者说出了愤怒的根本原因，即愤怒其实是我们的思维方式造成的，正是由于我们的思维方式无法满足我们的需要导致了我们的愤怒。如果我们能够借助愤怒来提醒自己，我们的需要没有得到满足，这表明当下我们的思维方式有问题，因为它难以满足我们的需要，从这个角度思考的话愤怒就是有价值的。因此我们有必要了解自己的需要再采取行动。但是做到这一点并不容易，因为愤怒驱使我们去惩罚他人，而不是去满足需要，这是人性使然。作者建议我们有意识的去培养发现对方和自己需要的习惯，与其沉浸于“合理的愤怒”，不如倾听自己和他人的需要。当然，这需要一个过程，我们需要通过不断实践去培养这个思维习惯，有意识的将“我生气是因为他们xxx”代替为“我生气是因为我需要xxx，对方需要xxx”。这里又举了一个作者生活中的例子，有一次他去一所学校提供咨询服务时，被两个孩子各打了两拳，第一个孩子打他时他差点打回去，第二个孩子打他时他则没有。他回想起这段经历说，自己生气的原因并不在于别人到底做了什么，而在于自己怎么看待对方及其行为。因为第一个孩子作者一开始就认为对方是个调皮的坏孩子，所以打他时他很生气，而第二个孩子作者从一开始就认为是个可爱的孩子，所以打他时他能从容的面对。由此可知，如果人们认为自己的痛苦是由他人造成的，并认为那人应该受到谴责或惩罚，那么我们就播下了暴力的种子。同样的，如果我们满脑子是非对错，把某些人看作是贪婪的人、不负责任的人、骗子或其他类型的坏人，那么，我们就很难与他们建立良好的关系。说到底，我们通常生气的原因，并不在于别人到底做了什么，而是我们自己怎么看待对方及其行为。指责他人有时可以使我们达到目的，例如他们出于害怕、内疚或惭愧，使他们改变了自己的行为。然而，以这样的方式来满足我们的需要，其实我们也是在使用暴力。那么当我们愤怒时到底应该怎么做才能让表达更流畅呢？作者给出了，正确表达愤怒的四个步骤：  停下来，除了呼吸，什么都别做  想一想是什么想法使我们生气了  试着去了解自己的需要  表达当下的感受和尚未满足的需要有时在步骤4表达前需要先倾听了解别人的需要，当我们专注于他人的感受和需要时，我们就会发现彼此作为人的共同点。根据生活经验，在与人交往的过程中，我们的第一反应常常是习惯性的反应，因此运用非暴力沟通其实是很别扭的事。只要人们认为自己受到了指责，他们就很难体会到别人的痛苦。因此专注他人的感受和需要并不容易，我们需要有足够的耐心来学习和运用非暴力沟通。这里列举了几个生活中的方法，来练习非暴力沟通：方法1，把非暴力沟通的表达形式写在一张卡片上，每次有人批评时，就把卡片拿出来提醒自己用非暴力沟通方式表达。方法2，刚开始运用非暴力沟通时，把节奏放慢些，在说话前先想一想，有时甚至停下来，什么也不说。方法3，留意我们脑袋中“我不喜欢抽烟的人…”之类的想法，然后问自己“我不喜欢他们…，是因为我什么样的需要没有得到满足”，通过这样的方式，我们就把注意力放在了尚未得到满足的需要，而不是考虑他人有什么过错。运用强制力避免伤害作者列举了几个不够成熟的表现，它认为当人们不够成熟的时候我们可能会有以下的表现  我们意识不到自己行为的后果  我们认识不到，我们并不需要通过惩罚他人来满足自己的需要  我们相信，我们有“权利”去惩罚或伤害他人，因为他们是罪有应得。  我们产生了幻觉，例如，听到“某种声音”叫我们去杀人。在使用惩罚性的强制力时，我们在心里认为某些人是邪恶的，为了让他们悔改，必须给他们一点颜色看看。此时的我们希望痛苦能让他们，意识到自己的过程，或感到懊悔，或改变行为。然而，实际生活中，惩罚往往加强了对方的敌意和抵触心理，使双方的关系更加疏远。例如在我们面对的孩子教育时：有时候，孩子拒绝做一件对他们有益的事情，只是因为他们不想在父母的压力面前屈服。其次，即使体罚能带来立竿见影的效果，这也并不意味着，其他方法无法达到同样的效果。体罚孩子会造成不良的社会影响。除了体罚外，指责或否定他人也是常见的惩罚方式。惩罚的代价我们要清醒的认识到惩罚是有代价的，当我们为了回避惩罚去做事情时，我们可能会忽视事情本身的价值，而仅仅陷入了对失败的忧虑。如果员工的表现只是在服从管理层的命令，士气就会受到影响，工作效率迟早都会降低。惩罚也将导致关系的疏远，一旦我们被看作是施暴的人，我们就很难得到友善的回应。举个例子，作者有一次去校园培训，校长看到操场上有个学生在打人，校长抓住那个学生，重重推了他一下并训斥道他。作者告诉校长，他并没有达到目的，学生只是学会了在打比他弱小的人时要注意附近是否有比他强壮的人，并且强化了他们通过打架来解决问题的意识。当我们想要影响他人的行为时，存在两个问题：第一，当我不喜欢他现在的行为时，我希望他怎么做？第二，我希望他基于怎样的原因去做我想要他做的事情？威胁和惩罚确实可以影响第一个问题（我希望他怎么做），但我们可以发现它难以实现第二个问题（我希望他基于怎样的原因去做），这就是惩罚的局限性。再举了个例子，在一所秩序比较混乱的学校里，作者通过沟通了解到，上课时有些学生听不进去但又没有地方去，所以在课堂上捣乱。经过跟学生的一番讨论，他们主动提出，设置一个空教室，听不进课的学生可以选择去那个教室玩自己的事，这样课堂上其他想要学习的学生就不会被打扰了。于是作者请求校长设置这样一个空教室，并且在教室里安排一个熟练掌握非暴力沟通技巧的老师和他们交谈，最后慢慢地学校恢复了正常的秩序。了解别人基于什么样的原因来满足我们的需要是至关重要的，因为我们彼此相互依存，我们的幸福与他人的幸福息息相关。生活中我们也许需要使用强制力来保护自己和他人，但这样做只是为了避免伤害而不是为了惩罚他人。如果我们通过威胁和惩罚手段来制裁他人，人们常常会产生敌意和抵触心理。这样，彼此的关系将会疏远。重获生活的热情倾听内心的声音我们在社会文化影响下形成了许多不良的习惯，渗透到了生活的各个方面，以致于我们很难察觉到它们的存在。前面我们认识到，情感的根源在于个人的需要和想法，并且我们需要以建设性的语言提出明确的请求。在《精神病学的革命》一书中提出，“沮丧是因为一个人处于激烈的内心冲突之中，无所适从”，就像我们的内心中有两个声音在呼喊那样，一个说要这样做，另一个说要那样做，我们陷入了僵局。因此沮丧意味着，我们不了解自己的需要，我们不知道自己到底要什么以及如何满足愿望。举了一位女士的例子，这位女士很沮丧，在孩子出生后一直在家里照顾孩子，她很想出去工作，这两种声音一直在内心中冲突。于是她用非暴力沟通的方式表达出来，“为了照顾孩子我放弃了工作，我有点心灰意冷，因为我需要成就感，我想出去找份工作”，“我一想到上班，就很害怕，因为我要确保孩子得到很好的照顾，我想我需要一位好保姆来照顾孩子，而且我还要确保下班时有精力陪伴孩子”。这位女士用两次非暴力沟通与两个不同的自己对话，说出心里话后让她大大的松了一口气。这个故事告诉我们，当我们正确表达出我们的需要和感受时，我们会更爱护自己同时也会让自己“松一口气”。心灵环保现实告诉我们，如果我们时常以苛刻的态度对人对己，我们的心情也好不到哪里去。运用非暴力沟通，我们能不再试图分析自己或他人有什么毛病，而是用心去了解我们的需要，这样，我们的内心就会逐渐变得平和。作者举了两个学生的例子，以前他每次头痛时都会回忆前几天的经历来找到原因，现在则不同，他会先问自己需要做什么来缓解头痛，然后坐起来做一些柔和的头部运动，走到外面做一些别的事情，让自己放松下来。他观察到了自己的状态，并了解了自己的需要，通过这样的方式他有了重大的突破。另一个学生，他每次开车都有路怒症，看到别人开车不守规矩就会愤怒，现在他更多的会去关注自己的感受和需要，以及对方司机的感受和需要。“是的，我看到他们这样开车，我真的很害怕，我希望他们开车时能注意安全”，“前面的那位司机有点不知所措，希望得到后面司机的谅解。路渐宽时我超车看到司机是位老太太，她看上去确实是惊慌失措，我很庆幸，我曾用心去体会她的感受和需要。”用非暴力沟通代替诊断作者相信可以用非暴力沟通来代替诊断和治疗。他相信，在治疗过程中，表达个人的感受和需要是有益的。于是在诊所诊断病人时，作者不再根据他所学习的心理学理论来分析来访者的心理特点，而是用心去体会他们的话，并表达自己内心的感受。结果效果非常好，无论是来访者还是我自己，都十分满意。作者解释到，自己不会去分析病人有什么毛病，而是问自己以下问题，“她现在什么心情？有什么需要？和她在一起我是什么心情？我的心情反映了我怎样的需要？我想请她做出什么决定或采取什么行动，以使她能快乐些？”在回答这样的问题时，我们会揭示自己的内心活动以及个人需要。与平常的诊断相比，我们能深深体会到我们作为人的弱点。一旦我们不把人当作诊断的对象，而是专注于彼此作为人的感受和需要，人们通常都会有积极的反应。小节，在情绪低落时，我们也许会怨天尤人。如果我们以苛刻的态度对人对己，我们的心情也好不到哪里去。通过运用非暴力沟通，我们不再试图分析自己或他人有什么毛病，而是用心去了解我们的需要，这样，我们的内心就会逐渐变得平和。一旦我们发现自己心底深处的愿望，并采取积极的行动，我们将会重获生活的热情。如何正确的表达感激赞扬也可能造成人与人之间的隔阂。这听起来似乎很奇怪。不过请注意，在赞扬他人时，我们很少揭示内心活动，而把自己放在了裁判的位置。我们认为，赞扬并不总是有助于深化彼此的联系。如果学生或员工一旦意识到经理和老师赞扬的目的是为了操纵他们，员工和学生很可能就会产生逆反心理。当发现这些赞扬的潜在目的之后，人们对于由衷的感谢也会心存疑虑。同样的，如果我们利用赞扬来施加影响，对方还可能误解我们的意思。用非暴力沟通方式表达感激时，我们只是为了庆祝他人的行为提升我们的生活品质，而不是想得到任何回报。非暴力沟通表达感激的方式包含三部分：  对方做了什么事情时我们的生活得到了改善？  我们有哪些需要得到了满足？  得到满足后，我们的心情怎么样？我们常常假定人们已经知道我的情意，然而这是想当然的。即使人们在听到感激时也会感到尴尬，他们会想听到明确的表达，而不是泛泛而谈的感激。在别人表达感激时，人们通常有两种截然不同的反应。一种是自我膨胀，相信我们比别人优越；另一种是假谦虚，否定别人的欣赏，耸耸肩“哦，这没什么”。如果我们意识到我的能力是生命赋予我的，我就能够同时避免自我膨胀和假谦虚。当别人我们的感激时，我们可以与对方一起庆祝生命的美，这样既不自大也不假谦虚。以色列前总理哥达曾说，“不要那么谦虚，因为你没有那么伟大”。作家玛丽安也说，“我们让自己的光芒闪耀，也允许他人散发光芒。一旦我们从自我的恐惧中解放出来，我们的存在，也会让他人得到解放。”最后回顾下非暴力沟通模式，观察、感受、需要、请求1.观察我所观察到的有助于我的福祉的具体行为2.感受对于这些行为，我有什么样的感受3.需要什么样的需要或价值导致我那样的感受4.请求清楚地请求那些能丰富我生命的具体行为我们在表达时要注意两点：一.诚实地表达自己，而不批评、指责二.关切地倾听他人，而不解读为批评或指责已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484873&amp;idx=1&amp;sn=b7d9986ffd0f259ec3dc25bc50f528a5&amp;chksm=fc2260cecb55e9d8dec522275320a2211e2ebb4f2025ff415c6e730c66d0ce07b9aaa0892adb&amp;token=1516544318&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h2 id=\"背景\">背景：</h2><p>表达能力和沟通技巧有诸多问题，工作和生活上出现了比较大的瓶颈，于是看了些表达和沟通方面的书，其中三本最为经典《非暴力沟通》、《关键对话》、《说话的艺术》。细细品读了这三本书并且收获满满，分享出来希望大家一同进步。</p><p>看完书后反观自己以前的沟通技巧和表达方式，明白了以前自己在这些方面都有比较大的认知错误，回想起来可以用愚蠢来形容。</p><p>既然有这么好的沟通技巧和表达方式，我希望将这些方法和技巧实实在在的落地到实际生活中，让生活、工作、学习更美好。</p><p>下面我就以《非暴力沟通》这本书为主线，来阐述我们在沟通过程中遇到的一些问题和对应的解决方法。</p><h2 id=\"正文\">正文：</h2><p>简单回顾下前文，前面我们说在提出的请求要明确，请求越详细越具体，才能让别人更清楚的了解我们的想法。</p><p>同时说了，倾听很重要，它能治愈身心也能预防潜在的暴力，倾听后向对方做出良好的反馈使得对话能够保持顺畅温和。</p><p>这节也是非暴力沟通学习的最后一篇，主题是在沟通时如何爱自己。</p><h3 id=\"爱自己而不是自责\">爱自己而不是自责</h3><p>非暴力沟通最重要的应用在于 - 爱护自己</p><p>我们常常对自己做出负面的评价，严厉的苛责自己。</p><p>但负面的自我评价使我们看不到生命的美，让我们忘记自己是“特殊的生命”，而把自己当做一个工具。</p><h3 id=\"如果我们习惯于将自己视为工具充满各种缺陷的工具那么自我憎恨是自然的\">如果我们习惯于将自己视为工具，充满各种缺陷的工具，那么自我憎恨是自然的。</h3><p>其实我们都希望自己所做的任何事情都是有益的，良好的自我评价的方式就要有助于学习，使我们的选择符合生命的需要。</p><h3 id=\"然而不幸的是我们的自我评价方式往往是负面这直接导致了自我憎恨而无助于学习\">然而不幸的是，我们的自我评价方式往往是负面，这直接导致了自我憎恨，而无助于学习。</h3><p>许多人会陷入自责，他们认为自己所做的事情是错的，并且应当为此感到痛苦。</p><p>虽然我们犯的错误揭示了我们的局限性从而引导我们成长，但陷入自责使得我们无法从错误中获益。</p><p>作者认为我们的改变最好要出于对生命的爱，而不是出于羞愧或内疚这些具有负面影响的心理。因为羞愧是自我憎恨的一种形式，出于羞愧的行为不是自由快乐的行为。即使我们试图更加友善和体贴，一旦人们意识到我们行为背后的羞愧或内疚，他们对这些行为的欣赏也就比不上那些只是出于爱的行为了。</p><p>我们的话语中常常带有一些容易引起羞愧和内疚的词，例如，“应该”，“不得不”，“必须”，举个简单的例子：</p><ol>  <li>我应该早点知道</li>  <li>我真的应该戒烟了</li>  <li>我必须加强锻炼</li>  <li>我真的受不了自己，我必须改改</li></ol><h3 id=\"一旦我们顺从了这些羞愧和内疚的命令生活也就会失去了乐趣如果我们经常责备自己强迫自己也使我们更像工具而不像人从而引起自我的憎恨\">一旦我们顺从了这些羞愧和内疚的命令，生活也就会失去了乐趣。如果我们经常责备自己、强迫自己，也使我们更像工具而不像人，从而引起自我的憎恨。</h3><p>因此当发现自己在做错误的事时，其实我们的挑战是如何对需要和价值观保持清醒的认识，这促进我们转变。</p><p>其中专注于需要能帮助我们从自我评价中获益，那么怎样才算是“专注于需要”呢？下面作者为我们做了解释。</p><h3 id=\"我们应该尽可能的直面人生的苦难在遇到挫折时充分体会人生的悲哀和内心的渴望感到遗憾是难免的无须责备自己它能帮助我们从经历中学习\">我们应该尽可能的直面人生的苦难：在遇到挫折时，充分体会人生的悲哀和内心的渴望。感到遗憾是难免的，无须责备自己，它能帮助我们从经历中学习。</h3><h3 id=\"专注于需要\">专注于需要</h3><h3 id=\"如果我们能专注于尚未满足的需要我们就能从中获益并考虑如何满足它\">如果我们能专注于尚未满足的需要，我们就能从中获益并考虑如何满足它。</h3><h3 id=\"只要我们对自己的需要保持清醒的认识我们就能建设性地满足它们\">只要我们对自己的需要保持清醒的认识，我们就能建设性地满足它们。</h3><h3 id=\"反之如果用苛刻的语言指责自己我们不仅难以找到解决办法而且容易陷于自我惩罚的痛苦中\">反之，如果用苛刻的语言指责自己，我们不仅难以找到解决办法，而且容易陷于自我惩罚的痛苦中。</h3><p>那么什么是专注于需要呢？作者举了一个自己的例子：</p><p>有一天他买了一件漂亮的外衣出席会议，在外衣口袋里放了一只钢笔，到达会议才发现钢笔帽忘盖了，外套上染上了一片黑色。他不停的训斥自己“你怎么可以这么粗心！”，此刻其实正是作者需要得到体谅的时刻。幸运的是他很快就意识到了自己的自责，于是他停下来，回想了下，发现其实他是想要照顾好自己，在匆忙地回应他人的请求时，多留意些自己的需要让自己更体面更舒适一些。想到这里，他的心情也开始变化，不再感到恼怒、羞愧和内疚，身体也放松了下来。</p><p>故事中，作者把恼怒和内疚的情绪转移为观察自己“去了解自己，需要什么”，了解到了自己的真实需求后，心情也开始发生了变化，最后身体放松了下来。如果我们能致力于满足他人及自己健康成长的需要，那么即使艰难的工作也不乏乐趣。</p><p>反之，如果我们的行为是出于义务、职责、恐惧、内疚或羞愧，那么即使有意思的事情也会变得枯燥无味。</p><p>在我们的社会中内疚常常被运用来控制人，这造成指责他人常常成为一种习惯。有时为了使这种手段奏效，我们可能就会认为一个人可以主导另一个人的情绪。这是极其错误的想法。</p><p>对于每个人来说，同一件事情有不同的需要，也导致了不同的感受。</p><p>如果意识不到自己尚未满足的需要，一心考虑别人的过错，我们难免就会生气。</p><h3 id=\"其实我们无须压抑愤怒只要我们专注于他人的感受和需要愤怒也就不再存在\">其实我们无须压抑愤怒，只要我们专注于他人的感受和需要，愤怒也就不再存在。</h3><p>作者说出了愤怒的根本原因，即愤怒其实是我们的思维方式造成的，正是由于我们的思维方式无法满足我们的需要导致了我们的愤怒。如果我们能够借助愤怒来提醒自己，我们的需要没有得到满足，这表明当下我们的思维方式有问题，因为它难以满足我们的需要，从这个角度思考的话愤怒就是有价值的。</p><p>因此我们有必要了解自己的需要再采取行动。</p><p>但是做到这一点并不容易，因为愤怒驱使我们去惩罚他人，而不是去满足需要，这是人性使然。</p><p>作者建议我们有意识的去培养发现对方和自己需要的习惯，与其沉浸于“合理的愤怒”，不如倾听自己和他人的需要。</p><p>当然，这需要一个过程，我们需要通过不断实践去培养这个思维习惯，有意识的将“我生气是因为他们xxx”代替为“我生气是因为我需要xxx，对方需要xxx”。</p><p>这里又举了一个作者生活中的例子，</p><p>有一次他去一所学校提供咨询服务时，被两个孩子各打了两拳，第一个孩子打他时他差点打回去，第二个孩子打他时他则没有。他回想起这段经历说，自己生气的原因并不在于别人到底做了什么，而在于自己怎么看待对方及其行为。因为第一个孩子作者一开始就认为对方是个调皮的坏孩子，所以打他时他很生气，而第二个孩子作者从一开始就认为是个可爱的孩子，所以打他时他能从容的面对。</p><p>由此可知，如果人们认为自己的痛苦是由他人造成的，并认为那人应该受到谴责或惩罚，那么我们就播下了暴力的种子。</p><p>同样的，如果我们满脑子是非对错，把某些人看作是贪婪的人、不负责任的人、骗子或其他类型的坏人，那么，我们就很难与他们建立良好的关系。</p><h3 id=\"说到底我们通常生气的原因并不在于别人到底做了什么而是我们自己怎么看待对方及其行为\">说到底，我们通常生气的原因，并不在于别人到底做了什么，而是我们自己怎么看待对方及其行为。</h3><h3 id=\"指责他人有时可以使我们达到目的例如他们出于害怕内疚或惭愧使他们改变了自己的行为\">指责他人有时可以使我们达到目的，例如他们出于害怕、内疚或惭愧，使他们改变了自己的行为。</h3><h3 id=\"然而以这样的方式来满足我们的需要其实我们也是在使用暴力\">然而，以这样的方式来满足我们的需要，其实我们也是在使用暴力。</h3><p>那么当我们愤怒时到底应该怎么做才能让表达更流畅呢？</p><p>作者给出了，正确表达愤怒的四个步骤：</p><ol>  <li>停下来，除了呼吸，什么都别做</li>  <li>想一想是什么想法使我们生气了</li>  <li>试着去了解自己的需要</li>  <li>表达当下的感受和尚未满足的需要</li></ol><p>有时在步骤4表达前需要先倾听了解别人的需要，当我们专注于他人的感受和需要时，我们就会发现彼此作为人的共同点。</p><p>根据生活经验，在与人交往的过程中，我们的第一反应常常是习惯性的反应，因此运用非暴力沟通其实是很别扭的事。只要人们认为自己受到了指责，他们就很难体会到别人的痛苦。因此专注他人的感受和需要并不容易，我们需要有足够的耐心来学习和运用非暴力沟通。</p><p>这里列举了几个生活中的方法，来练习非暴力沟通：</p><p>方法1，把非暴力沟通的表达形式写在一张卡片上，每次有人批评时，就把卡片拿出来提醒自己用非暴力沟通方式表达。</p><p>方法2，刚开始运用非暴力沟通时，把节奏放慢些，在说话前先想一想，有时甚至停下来，什么也不说。</p><p>方法3，留意我们脑袋中“我不喜欢抽烟的人…”之类的想法，然后问自己“我不喜欢他们…，是因为我什么样的需要没有得到满足”，通过这样的方式，我们就把注意力放在了尚未得到满足的需要，而不是考虑他人有什么过错。</p><h3 id=\"运用强制力避免伤害\">运用强制力避免伤害</h3><p>作者列举了几个不够成熟的表现，它认为当人们不够成熟的时候我们可能会有以下的表现</p><ol>  <li>我们意识不到自己行为的后果</li>  <li>我们认识不到，我们并不需要通过惩罚他人来满足自己的需要</li>  <li>我们相信，我们有“权利”去惩罚或伤害他人，因为他们是罪有应得。</li>  <li>我们产生了幻觉，例如，听到“某种声音”叫我们去杀人。</li></ol><p>在使用惩罚性的强制力时，我们在心里认为某些人是邪恶的，为了让他们悔改，必须给他们一点颜色看看。</p><p>此时的我们希望痛苦能让他们，意识到自己的过程，或感到懊悔，或改变行为。然而，实际生活中，惩罚往往加强了对方的敌意和抵触心理，使双方的关系更加疏远。</p><p>例如在我们面对的孩子教育时：</p><p>有时候，孩子拒绝做一件对他们有益的事情，只是因为他们不想在父母的压力面前屈服。其次，即使体罚能带来立竿见影的效果，这也并不意味着，其他方法无法达到同样的效果。体罚孩子会造成不良的社会影响。除了体罚外，指责或否定他人也是常见的惩罚方式。</p><h3 id=\"惩罚的代价\">惩罚的代价</h3><h3 id=\"我们要清醒的认识到惩罚是有代价的当我们为了回避惩罚去做事情时我们可能会忽视事情本身的价值而仅仅陷入了对失败的忧虑如果员工的表现只是在服从管理层的命令士气就会受到影响工作效率迟早都会降低惩罚也将导致关系的疏远一旦我们被看作是施暴的人我们就很难得到友善的回应\">我们要清醒的认识到惩罚是有代价的，当我们为了回避惩罚去做事情时，我们可能会忽视事情本身的价值，而仅仅陷入了对失败的忧虑。如果员工的表现只是在服从管理层的命令，士气就会受到影响，工作效率迟早都会降低。惩罚也将导致关系的疏远，一旦我们被看作是施暴的人，我们就很难得到友善的回应。</h3><p>举个例子，作者有一次去校园培训，校长看到操场上有个学生在打人，校长抓住那个学生，重重推了他一下并训斥道他。作者告诉校长，他并没有达到目的，学生只是学会了在打比他弱小的人时要注意附近是否有比他强壮的人，并且强化了他们通过打架来解决问题的意识。</p><p>当我们想要影响他人的行为时，存在两个问题：</p><p>第一，当我不喜欢他现在的行为时，我希望他怎么做？</p><p>第二，我希望他基于怎样的原因去做我想要他做的事情？</p><h3 id=\"威胁和惩罚确实可以影响第一个问题我希望他怎么做但我们可以发现它难以实现第二个问题我希望他基于怎样的原因去做这就是惩罚的局限性\">威胁和惩罚确实可以影响第一个问题（我希望他怎么做），但我们可以发现它难以实现第二个问题（我希望他基于怎样的原因去做），这就是惩罚的局限性。</h3><p>再举了个例子，在一所秩序比较混乱的学校里，作者通过沟通了解到，上课时有些学生听不进去但又没有地方去，所以在课堂上捣乱。经过跟学生的一番讨论，他们主动提出，设置一个空教室，听不进课的学生可以选择去那个教室玩自己的事，这样课堂上其他想要学习的学生就不会被打扰了。</p><p>于是作者请求校长设置这样一个空教室，并且在教室里安排一个熟练掌握非暴力沟通技巧的老师和他们交谈，最后慢慢地学校恢复了正常的秩序。</p><h3 id=\"了解别人基于什么样的原因来满足我们的需要是至关重要的因为我们彼此相互依存我们的幸福与他人的幸福息息相关\">了解别人基于什么样的原因来满足我们的需要是至关重要的，因为我们彼此相互依存，我们的幸福与他人的幸福息息相关。</h3><p>生活中我们也许需要使用强制力来保护自己和他人，但这样做只是为了避免伤害而不是为了惩罚他人。</p><h3 id=\"如果我们通过威胁和惩罚手段来制裁他人人们常常会产生敌意和抵触心理这样彼此的关系将会疏远\">如果我们通过威胁和惩罚手段来制裁他人，人们常常会产生敌意和抵触心理。这样，彼此的关系将会疏远。</h3><h3 id=\"重获生活的热情\">重获生活的热情</h3><h3 id=\"倾听内心的声音\">倾听内心的声音</h3><p>我们在社会文化影响下形成了许多不良的习惯，渗透到了生活的各个方面，以致于我们很难察觉到它们的存在。</p><p>前面我们认识到，情感的根源在于个人的需要和想法，并且我们需要以建设性的语言提出明确的请求。在《精神病学的革命》一书中提出，“沮丧是因为一个人处于激烈的内心冲突之中，无所适从”，就像我们的内心中有两个声音在呼喊那样，一个说要这样做，另一个说要那样做，我们陷入了僵局。因此沮丧意味着，我们不了解自己的需要，我们不知道自己到底要什么以及如何满足愿望。</p><p>举了一位女士的例子，这位女士很沮丧，在孩子出生后一直在家里照顾孩子，她很想出去工作，这两种声音一直在内心中冲突。于是她用非暴力沟通的方式表达出来，“为了照顾孩子我放弃了工作，我有点心灰意冷，因为我需要成就感，我想出去找份工作”，“我一想到上班，就很害怕，因为我要确保孩子得到很好的照顾，我想我需要一位好保姆来照顾孩子，而且我还要确保下班时有精力陪伴孩子”。这位女士用两次非暴力沟通与两个不同的自己对话，说出心里话后让她大大的松了一口气。</p><p>这个故事告诉我们，当我们正确表达出我们的需要和感受时，我们会更爱护自己同时也会让自己“松一口气”。</p><h3 id=\"心灵环保\">心灵环保</h3><h3 id=\"现实告诉我们如果我们时常以苛刻的态度对人对己我们的心情也好不到哪里去\">现实告诉我们，如果我们时常以苛刻的态度对人对己，我们的心情也好不到哪里去。</h3><p>运用非暴力沟通，我们能不再试图分析自己或他人有什么毛病，而是用心去了解我们的需要，这样，我们的内心就会逐渐变得平和。</p><p>作者举了两个学生的例子，以前他每次头痛时都会回忆前几天的经历来找到原因，现在则不同，他会先问自己需要做什么来缓解头痛，然后坐起来做一些柔和的头部运动，走到外面做一些别的事情，让自己放松下来。他观察到了自己的状态，并了解了自己的需要，通过这样的方式他有了重大的突破。另一个学生，他每次开车都有路怒症，看到别人开车不守规矩就会愤怒，现在他更多的会去关注自己的感受和需要，以及对方司机的感受和需要。“是的，我看到他们这样开车，我真的很害怕，我希望他们开车时能注意安全”，“前面的那位司机有点不知所措，希望得到后面司机的谅解。路渐宽时我超车看到司机是位老太太，她看上去确实是惊慌失措，我很庆幸，我曾用心去体会她的感受和需要。”</p><h3 id=\"用非暴力沟通代替诊断\">用非暴力沟通代替诊断</h3><p>作者相信可以用非暴力沟通来代替诊断和治疗。他相信，在治疗过程中，表达个人的感受和需要是有益的。</p><p>于是在诊所诊断病人时，作者不再根据他所学习的心理学理论来分析来访者的心理特点，而是用心去体会他们的话，并表达自己内心的感受。结果效果非常好，无论是来访者还是我自己，都十分满意。</p><p>作者解释到，自己不会去分析病人有什么毛病，而是问自己以下问题，“她现在什么心情？有什么需要？和她在一起我是什么心情？我的心情反映了我怎样的需要？我想请她做出什么决定或采取什么行动，以使她能快乐些？”在回答这样的问题时，我们会揭示自己的内心活动以及个人需要。与平常的诊断相比，我们能深深体会到我们作为人的弱点。</p><p>一旦我们不把人当作诊断的对象，而是专注于彼此作为人的感受和需要，人们通常都会有积极的反应。</p><p>小节，在情绪低落时，我们也许会怨天尤人。如果我们以苛刻的态度对人对己，我们的心情也好不到哪里去。</p><p>通过运用非暴力沟通，我们不再试图分析自己或他人有什么毛病，而是用心去了解我们的需要，这样，我们的内心就会逐渐变得平和。一旦我们发现自己心底深处的愿望，并采取积极的行动，我们将会重获生活的热情。</p><h3 id=\"如何正确的表达感激\">如何正确的表达感激</h3><p>赞扬也可能造成人与人之间的隔阂。这听起来似乎很奇怪。不过请注意，在赞扬他人时，我们很少揭示内心活动，而把自己放在了裁判的位置。我们认为，赞扬并不总是有助于深化彼此的联系。</p><p>如果学生或员工一旦意识到经理和老师赞扬的目的是为了操纵他们，员工和学生很可能就会产生逆反心理。</p><p>当发现这些赞扬的潜在目的之后，人们对于由衷的感谢也会心存疑虑。</p><p>同样的，如果我们利用赞扬来施加影响，对方还可能误解我们的意思。</p><p>用非暴力沟通方式表达感激时，我们只是为了庆祝他人的行为提升我们的生活品质，而不是想得到任何回报。</p><p>非暴力沟通表达感激的方式包含三部分：</p><ol>  <li>对方做了什么事情时我们的生活得到了改善？</li>  <li>我们有哪些需要得到了满足？</li>  <li>得到满足后，我们的心情怎么样？</li></ol><h3 id=\"我们常常假定人们已经知道我的情意然而这是想当然的即使人们在听到感激时也会感到尴尬他们会想听到明确的表达而不是泛泛而谈的感激\">我们常常假定人们已经知道我的情意，然而这是想当然的。即使人们在听到感激时也会感到尴尬，他们会想听到明确的表达，而不是泛泛而谈的感激。</h3><p>在别人表达感激时，人们通常有两种截然不同的反应。一种是自我膨胀，相信我们比别人优越；另一种是假谦虚，否定别人的欣赏，耸耸肩“哦，这没什么”。如果我们意识到我的能力是生命赋予我的，我就能够同时避免自我膨胀和假谦虚。</p><h3 id=\"当别人我们的感激时我们可以与对方一起庆祝生命的美这样既不自大也不假谦虚\">当别人我们的感激时，我们可以与对方一起庆祝生命的美，这样既不自大也不假谦虚。</h3><p>以色列前总理哥达曾说，“不要那么谦虚，因为你没有那么伟大”。作家玛丽安也说，“我们让自己的光芒闪耀，也允许他人散发光芒。一旦我们从自我的恐惧中解放出来，我们的存在，也会让他人得到解放。”</p><p>最后回顾下非暴力沟通模式，观察、感受、需要、请求</p><p>1.观察</p><p>我所观察到的有助于我的福祉的具体行为</p><p>2.感受</p><p>对于这些行为，我有什么样的感受</p><p>3.需要</p><p>什么样的需要或价值导致我那样的感受</p><p>4.请求</p><p>清楚地请求那些能丰富我生命的具体行为</p><p>我们在表达时要注意两点：</p><p>一.诚实地表达自己，而不批评、指责</p><p>二.关切地倾听他人，而不解读为批评或指责</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484873&amp;idx=1&amp;sn=b7d9986ffd0f259ec3dc25bc50f528a5&amp;chksm=fc2260cecb55e9d8dec522275320a2211e2ebb4f2025ff415c6e730c66d0ce07b9aaa0892adb&amp;token=1516544318&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/08/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B040",
            
            
            
            
            
            "date_published": "2021-08-17T00:00:00+08:00",
            "date_modified": "2021-08-17T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/08/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B039",
            "title": "读书笔记(三十九) 《非暴力沟通》#2 - 请求帮助、用心倾听",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：表达能力和沟通技巧有诸多问题，工作和生活上出现了比较大的瓶颈，于是看了些表达和沟通方面的书，其中三本最为经典《非暴力沟通》、《关键对话》、《说话的艺术》。细细品读了这三本书并且收获满满，分享出来希望大家一同进步。看完书后反观自己以前的沟通技巧和表达方式，明白了以前自己在这些方面都有比较大的认知错误，回想起来可以用愚蠢来形容。既然有这么好的沟通技巧和表达方式，我希望将这些方法和技巧实实在在的落地到实际生活中，让生活、工作、学习更美好。下面我就以《非暴力沟通》这本书为主线，来阐述我们在沟通过程中遇到的一些问题和对应的解决方法。概述：作者认为我们在沟通过程中，提出请求时要明确详尽，谈话的目标要明确，他用生活中的例子来说明人们在平时沟通中常常不明确请求，或不明确谈话的目标，导致沟通的诸多问题，于是阐述了如何让请求明确，让谈话目标明确。然后又说了倾听的重要性，如何倾听以及倾听后如何反馈，做了通俗易懂的说明。  提出明确的请求  如何让谈话更加明确  如何用心倾听  倾听的力量  倾听后如何给他人反馈  当我们痛苦到无法倾听时怎么办正文：提出明确的请求作者说我们在提出请求时，应该清楚地告诉对方，我们希望他们做什么。而不是告诉他们，不要做什么，因为这很容易引起别人的反感。他举了两个例子：第一个例子是在越战期间，作者被请去辩论会上辩论，他告诫自己“这次辩论，绝不能这么被动”，但在辩论开始时他就发现他回应的方式和上次一模一样。这个教训让作者明白了：如果只是提醒要避免什么，而不是清楚的告诉需要做什么的话，结果大都是失败的。第二个例子是在学校里，学生们对校长很不满意，但每次对校长提出提意见时，只说了不希望他做什么，并且提出了一些比较抽象的要求，比如“公平对待”，因此双方的关系一直无法调和。作者告诉他们要说出希望对方做的事，并且在请求时提出具体的行动，这样他们就较有可能得到积极的回应和较满足的回答，最后化解了矛盾。当我们提出请求时，请求越具体越好，如果我们的意思含糊不清，别人就难以了解我们到底想要什么。此外，在提出请求时，如果我们使用的词语比较抽象，就无法让别人清楚的了解我们的想法，所以要在请求时要说具体的行动，这样就能清楚的表达我们需要。可以总结为，当我们提出请求时，请求越具体越好，越详细越好，这样就越能让别人清楚地了解我们的想法。作者感慨许多向他求助的人中，那些感到沮丧或灰心的人，很大程度上是因为他们不清楚自己对他人究竟有什么样的期待。如何让谈话更加明确有时候我们并没有直接提出请求，但却妄图他人知道我们想要什么，这是我们很多人错误的认知。例如我们常常在说话的时候，表面上是与他人在谈话，但其实是在自言自语，这时对方可能就不知道该如何回应，甚至会感到局促不安。举个例子，一个人生气的冲太太说“我从没见过开这么慢的火车”，此时他太太就看起来有点不知所措。相信每个人在和对方谈话的时候，总希望得到称心的回应。如果你对自己的认识越深刻、表达越清楚，我们就越有可能得到称心的回应。有时我们可以请求对方一些反馈，例如，“我的意思清楚吗”，或者反馈对方“我明白你的意思”，确保双方能充分表达和理解。参加集体会议时，说清楚我们希望得到怎样的反馈，是至关重要的。如果不清楚发言的目的，开会只是在浪费时间，而且无法满足任何人的需要。我们在集体讨论时如果漫无目的地发言，那么会议很可能就会毫无成果。有时即使我们提出了明确的请求，也同样可能造成交流的困难。例如如果人们认为我们的请求是对他们发出的命令。当一个人听到命令时，只能看到两种选择，服从或者反抗。只要人们认为我们时在强迫他们，他们就不会乐于满足我们的需要。如果我们在过去常常指责他人，那么，我们的请求很可能就会被看作是命令。而一个经常受到指责的人也会倾向于将请求解读为命令。那么我们在提出请求时，人们是如何区分命令和请求呢？  当请求没有得到满足时，提出请求的人如果批评和指责，那就是命令。  如果想利用对方的内疚来达到目的，也是命令。我们越是将他人的不顺从看作是对我们的排斥，我们所表达的愿望就越有可能被看作是命令。这将导致恶性循环，因为一旦人们认为我们是在强迫他们，他们就会不太想满足我们的愿望。在人们无法满足我们的愿望时，我们是否尊重他们的感受和需要，最能体现我们提出的是请求还是命令。如果我们愿意去体会是什么使他们无法说“是”，那么，我们提出的就是请求而非命令。通过请求而非命令来表达愿望，并不意味着一旦人们说“不”，我们就不再去满足自己的需要，而是在我们没有充分体会到，什么妨碍了他说“是”之前，不再试图说服他。非暴力沟通提倡在诚实和倾听的基础上与他人联系，它希望人们的改变和行动是处于对生命的爱。一旦人们相信我们看重彼此的感情，并能兼顾双方的需要，那么他们也就会相信我们所表达的愿望是请求而非命令。有时候即使我们以适当的方式提出请求，有些人仍会误以为是命令。特别是当我们处于强势的一方时，那些曾受过权威威胁的人尤其容易作出这样的判断。这需要我们经过一段时间引导才能矫正这种看法。如何用心倾听在沟通过程中，倾听非常重要，为了能倾听他人，我们需要先放下已有的想法和判断，全神贯注地体会对方。倾听意味着全心全意地体会他人的信息，这也为他人充分表达痛苦创造了条件，这时不要急着做什么，就站在那里。在倾听他人的痛苦经历时，他想要的是别人体会了解他的处境，但如果听到的却是安慰和建议，那么他就有可能觉得不太舒服。那么哪些行为会妨碍我们体会他人的处境呢，例如下边：建议：“我想你应该…”比较：“这算不了什么，你听听我的经历…”说教：“如果你这样做…你将会得到很大的好处”安慰：“这不是你的错；你已经尽最大努力了。”回忆：“这让我想起…”否定：“高兴一点。不要这么难过。”同情：“哦，你这可怜的人…”询问：“这种情况是什么时候开始的？”辩解：“我原想早点打电话给你，但昨晚…”纠正：“事情的经过不是这样的。”我们常常认为，在亲友感到痛苦时，我们应该想办法使他们好受一些，然而，急于采取行动使我们无法充分体会他们的状况。在非暴力沟通中，倾听他人意味着，放下已有的想法和判断，一心一意体会他人。倾听的这种品质体现了与理解以及同情之间的区别。不论别人说什么，我们只需要听到他们此时此刻的，观察、感受、需要、请求，然后我们可以通过询问来了解我们的猜测是否准确。不过在解决问题或询问他人的请求前，我们要为他人的充分表达创造条件。那么怎样判断对方的感受是否已经充分表达呢？  如果一个人觉得别人已经完全明白他的意思，他就会变得轻松。这时，我们也会感到放松。  另一个更为明显的标志是，他停止了谈话。  如果无法确定对方是否还有话要说，就不妨问一句“你还有什么要告诉我的么？”倾听的力量倾听使身心痊愈，我们有没发现，每当我们得到人们的倾听和理解时，我们就可以用新的眼光看世界，并继续前进。一旦有人倾听我们，本来看起来无法解决的问题就有了解决办法，千头万绪的思路也会变得清晰起来。在组织机构中，我们在听到上级的意见时，通常会把它看作是命令或指示。倾听同事或下级比倾听上级要容易得多。在上级面前，我们有时可能会有点紧张，以致于无法静下心来体会他们的感受和需要，并给予反馈。倾听和示弱的能力我们最不愿意示弱的时候往往是因为担心失去控制想显得强硬的时候。当我们表达自己示弱时，有时人们会说一些糟糕的话，如果我们将它看作是羞辱或攻击，我们很可能就会觉得自己受到了伤害，甚至因为过于愤怒或害怕而无法倾听他们。遇到这种情况，我们需要离开现场，来倾听自己心底的声音，或向好友倾诉，这将有助于我了解并体贴自己的感受和需要，等平静下来后，再回来与对方交流。在痛苦的情形中，为了了解自己深层的需要，建议首先获得必要的倾听，以避免为充斥头脑的各种想法所束缚。最后可以通过倾听他们的感受和需要，并给予他们反馈。倾听预防潜在的暴力那些被我们看作是恶魔的人，其实也是人，只是有时我们无法看到他们和我们的相同之处。我越是专注于他的感受和需要，我就越把他看作因需要没有得到满足而感到绝望的人。如果别人说“不”当别人说“不”的时候，我们常常会认为他们是在拒绝我们。有时，我们甚至还会觉得受到了伤害。然而，如果我们能够体会他人的感受和需要，我们也许就会发现是什么使他们无法答应我们的请求。使谈话生动有趣怎样使谈话生动有趣呢？作者建议说话的人留意自己的感受和需要。人们常常没有意识到，他们需要的是别人的理解和接纳。他们也没有意识到，直接表达自己的感受和需要，与讲故事相比，更容易得到他们所期待的联系。另一种方法是，直接表达我们的愿望。如果别人保持沉默有时候我们说了心里话，却发现对方一句话都不说，我们也许会很不安，容易把事情往坏处想，这时很难静下心来体会对方的感受和需要。但我们仍然要鼓起勇气体会对方，用平静的话语表达出来，询问对方当前的状态的原因。这里作者举了一个例子：在一次工作时，作者在交谈中动了感情，哭了起来，但却发现对方转过身去，默不作声。这使得作者心里很不安，也很困惑。于是就问他，“你生气了吗？你希望与你工作的人有很好的自制力？”对方则回答，“不是这样的。我在想我的太太多么希望我能哭。”他接着讲到他和太太正在闹离婚的事情。不安和困惑就这样化解了。小结下，倾听帮助人们治愈了心灵的创伤，也使我们勇于面对自己的弱点。如何给他人反馈在倾听他人的观察、感受、需要和请求之后，我们可以主动过表达我们的理解。在提问前，先表达我们的感受和需要，这会鼓励人们主动表达自己。那么什么时候需要反馈呢？他人的表达后，我们对他说的没有理解或没有把握时，我们需要与对方的确认。当我们在给他人反馈时，语气十分重要。因为当一个人在听别人谈自己的感受和需要时，总会留意其中是否暗含着批评和嘲讽。如果我们的语气很肯定，仿佛是在宣布他们的内心世界，那么，通常不会有好的反应。然而，如果对方通过我们的语气意识到我们是在体会他，而不是下结论，他们就不会产生反感了。我们在一般谈话时，通常对方并不信任我们，除非对我们的意图有进一步的了解，否则他不会喜欢我们表达的方式。然而，只要我们专注于他人的感受和需要，所有的批评、攻击、辱骂或嘲讽就会消失。我们越是这样做，就越能体会到一个简单的事实：  有时，我们认为自己受到了指责，实际上，那些话是他人表达需要和请求的方式。  如果意识到这一点，我们就不会认为自己的人格受到了伤害。  反之，如果一心分析自己或对方的过错，我们就会认为自己被贬低了。当然非暴力沟通并不是公式，有时候我们会机械地运用非暴力沟通模式，而忘记了其目的。这时我们应该问问自己，我们是否关心的是加深与人的联系。当我们痛苦的无法倾听时有时我们会发现，我们很痛苦，没有心情去关心别人。这时该怎么办？联合国前秘书长汉马斯克德曾说“你越是留意自己内心的声音，就越能够听到别人的声音。”一旦我们能够敏锐地察觉并顾及自己的感受和需要，我们就有能力迅速调整好状态，来倾听他人。第一种方式是，体会自己的感受和需要。另一种方式就是，大声提出请求。最后一种是换一个环境，用时间和空间来调整状态，等平静下来了，再回来。已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484864&amp;idx=1&amp;sn=da81a32d8fc50ce730259e03ea8344b1&amp;chksm=fc2260c7cb55e9d1ad4c9322f9d6f04c234fc72554d9a40050ff61639f80bbe701501151ae86&amp;token=326491610&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h2 id=\"背景\">背景：</h2><p>表达能力和沟通技巧有诸多问题，工作和生活上出现了比较大的瓶颈，于是看了些表达和沟通方面的书，其中三本最为经典《非暴力沟通》、《关键对话》、《说话的艺术》。</p><p>细细品读了这三本书并且收获满满，分享出来希望大家一同进步。</p><p>看完书后反观自己以前的沟通技巧和表达方式，明白了以前自己在这些方面都有比较大的认知错误，回想起来可以用愚蠢来形容。</p><p>既然有这么好的沟通技巧和表达方式，我希望将这些方法和技巧实实在在的落地到实际生活中，让生活、工作、学习更美好。</p><p>下面我就以《非暴力沟通》这本书为主线，来阐述我们在沟通过程中遇到的一些问题和对应的解决方法。</p><h2 id=\"概述\">概述：</h2><p>作者认为我们在沟通过程中，提出请求时要明确详尽，谈话的目标要明确，他用生活中的例子来说明人们在平时沟通中常常不明确请求，或不明确谈话的目标，导致沟通的诸多问题，于是阐述了如何让请求明确，让谈话目标明确。然后又说了倾听的重要性，如何倾听以及倾听后如何反馈，做了通俗易懂的说明。</p><ol>  <li>提出明确的请求</li>  <li>如何让谈话更加明确</li>  <li>如何用心倾听</li>  <li>倾听的力量</li>  <li>倾听后如何给他人反馈</li>  <li>当我们痛苦到无法倾听时怎么办</li></ol><h2 id=\"正文\">正文：</h2><h3 id=\"提出明确的请求\">提出明确的请求</h3><p>作者说我们在提出请求时，应该清楚地告诉对方，我们希望他们做什么。而不是告诉他们，不要做什么，因为这很容易引起别人的反感。</p><p>他举了两个例子：</p><p>第一个例子是在越战期间，作者被请去辩论会上辩论，他告诫自己“这次辩论，绝不能这么被动”，但在辩论开始时他就发现他回应的方式和上次一模一样。</p><h3 id=\"这个教训让作者明白了如果只是提醒要避免什么而不是清楚的告诉需要做什么的话结果大都是失败的\">这个教训让作者明白了：如果只是提醒要避免什么，而不是清楚的告诉需要做什么的话，结果大都是失败的。</h3><p>第二个例子是在学校里，学生们对校长很不满意，但每次对校长提出提意见时，只说了不希望他做什么，并且提出了一些比较抽象的要求，比如“公平对待”，因此双方的关系一直无法调和。</p><h3 id=\"作者告诉他们要说出希望对方做的事并且在请求时提出具体的行动这样他们就较有可能得到积极的回应和较满足的回答最后化解了矛盾\">作者告诉他们要说出希望对方做的事，并且在请求时提出具体的行动，这样他们就较有可能得到积极的回应和较满足的回答，最后化解了矛盾。</h3><p>当我们提出请求时，请求越具体越好，如果我们的意思含糊不清，别人就难以了解我们到底想要什么。</p><p>此外，在提出请求时，如果我们使用的词语比较抽象，就无法让别人清楚的了解我们的想法，所以要在请求时要说具体的行动，这样就能清楚的表达我们需要。</p><p>可以总结为，当我们提出请求时，请求越具体越好，越详细越好，这样就越能让别人清楚地了解我们的想法。</p><p>作者感慨许多向他求助的人中，那些感到沮丧或灰心的人，很大程度上是因为他们不清楚自己对他人究竟有什么样的期待。</p><h3 id=\"如何让谈话更加明确\">如何让谈话更加明确</h3><h3 id=\"有时候我们并没有直接提出请求但却妄图他人知道我们想要什么这是我们很多人错误的认知\">有时候我们并没有直接提出请求，但却妄图他人知道我们想要什么，这是我们很多人错误的认知。</h3><p>例如我们常常在说话的时候，表面上是与他人在谈话，但其实是在自言自语，这时对方可能就不知道该如何回应，甚至会感到局促不安。</p><p>举个例子，一个人生气的冲太太说“我从没见过开这么慢的火车”，此时他太太就看起来有点不知所措。</p><p>相信每个人在和对方谈话的时候，总希望得到称心的回应。如果你对自己的认识越深刻、表达越清楚，我们就越有可能得到称心的回应。</p><p>有时我们可以请求对方一些反馈，例如，“我的意思清楚吗”，或者反馈对方“我明白你的意思”，确保双方能充分表达和理解。</p><h3 id=\"参加集体会议时说清楚我们希望得到怎样的反馈是至关重要的\">参加集体会议时，说清楚我们希望得到怎样的反馈，是至关重要的。</h3><p>如果不清楚发言的目的，开会只是在浪费时间，而且无法满足任何人的需要。我们在集体讨论时如果漫无目的地发言，那么会议很可能就会毫无成果。</p><p>有时即使我们提出了明确的请求，也同样可能造成交流的困难。例如如果人们认为我们的请求是对他们发出的命令。</p><h3 id=\"当一个人听到命令时只能看到两种选择服从或者反抗\">当一个人听到命令时，只能看到两种选择，服从或者反抗。</h3><h3 id=\"只要人们认为我们时在强迫他们他们就不会乐于满足我们的需要\">只要人们认为我们时在强迫他们，他们就不会乐于满足我们的需要。</h3><h3 id=\"如果我们在过去常常指责他人那么我们的请求很可能就会被看作是命令而一个经常受到指责的人也会倾向于将请求解读为命令\">如果我们在过去常常指责他人，那么，我们的请求很可能就会被看作是命令。而一个经常受到指责的人也会倾向于将请求解读为命令。</h3><p>那么我们在提出请求时，人们是如何区分命令和请求呢？</p><ol>  <li>当请求没有得到满足时，提出请求的人如果批评和指责，那就是命令。</li>  <li>如果想利用对方的内疚来达到目的，也是命令。</li></ol><h3 id=\"我们越是将他人的不顺从看作是对我们的排斥我们所表达的愿望就越有可能被看作是命令这将导致恶性循环因为一旦人们认为我们是在强迫他们他们就会不太想满足我们的愿望\">我们越是将他人的不顺从看作是对我们的排斥，我们所表达的愿望就越有可能被看作是命令。这将导致恶性循环，因为一旦人们认为我们是在强迫他们，他们就会不太想满足我们的愿望。</h3><h3 id=\"在人们无法满足我们的愿望时我们是否尊重他们的感受和需要最能体现我们提出的是请求还是命令\">在人们无法满足我们的愿望时，我们是否尊重他们的感受和需要，最能体现我们提出的是请求还是命令。</h3><p>如果我们愿意去体会是什么使他们无法说“是”，那么，我们提出的就是请求而非命令。</p><p>通过请求而非命令来表达愿望，并不意味着一旦人们说“不”，我们就不再去满足自己的需要，而是在我们没有充分体会到，什么妨碍了他说“是”之前，不再试图说服他。</p><p>非暴力沟通提倡在诚实和倾听的基础上与他人联系，它希望人们的改变和行动是处于对生命的爱。</p><h3 id=\"一旦人们相信我们看重彼此的感情并能兼顾双方的需要那么他们也就会相信我们所表达的愿望是请求而非命令\">一旦人们相信我们看重彼此的感情，并能兼顾双方的需要，那么他们也就会相信我们所表达的愿望是请求而非命令。</h3><p>有时候即使我们以适当的方式提出请求，有些人仍会误以为是命令。特别是当我们处于强势的一方时，那些曾受过权威威胁的人尤其容易作出这样的判断。这需要我们经过一段时间引导才能矫正这种看法。</p><h3 id=\"如何用心倾听\">如何用心倾听</h3><p>在沟通过程中，倾听非常重要，为了能倾听他人，我们需要先放下已有的想法和判断，全神贯注地体会对方。</p><h3 id=\"倾听意味着全心全意地体会他人的信息这也为他人充分表达痛苦创造了条件这时不要急着做什么就站在那里\">倾听意味着全心全意地体会他人的信息，这也为他人充分表达痛苦创造了条件，这时不要急着做什么，就站在那里。</h3><h3 id=\"在倾听他人的痛苦经历时他想要的是别人体会了解他的处境但如果听到的却是安慰和建议那么他就有可能觉得不太舒服\">在倾听他人的痛苦经历时，他想要的是别人体会了解他的处境，但如果听到的却是安慰和建议，那么他就有可能觉得不太舒服。</h3><p>那么哪些行为会妨碍我们体会他人的处境呢，例如下边：</p><p>建议：“我想你应该…”比较：“这算不了什么，你听听我的经历…”说教：“如果你这样做…你将会得到很大的好处”安慰：“这不是你的错；你已经尽最大努力了。”回忆：“这让我想起…”否定：“高兴一点。不要这么难过。”同情：“哦，你这可怜的人…”询问：“这种情况是什么时候开始的？”辩解：“我原想早点打电话给你，但昨晚…”纠正：“事情的经过不是这样的。”</p><h3 id=\"我们常常认为在亲友感到痛苦时我们应该想办法使他们好受一些然而急于采取行动使我们无法充分体会他们的状况\">我们常常认为，在亲友感到痛苦时，我们应该想办法使他们好受一些，然而，急于采取行动使我们无法充分体会他们的状况。</h3><p>在非暴力沟通中，倾听他人意味着，放下已有的想法和判断，一心一意体会他人。倾听的这种品质体现了与理解以及同情之间的区别。</p><h3 id=\"不论别人说什么我们只需要听到他们此时此刻的观察感受需要请求然后我们可以通过询问来了解我们的猜测是否准确\">不论别人说什么，我们只需要听到他们此时此刻的，观察、感受、需要、请求，然后我们可以通过询问来了解我们的猜测是否准确。</h3><p>不过在解决问题或询问他人的请求前，我们要为他人的充分表达创造条件。</p><p>那么怎样判断对方的感受是否已经充分表达呢？</p><ol>  <li>如果一个人觉得别人已经完全明白他的意思，他就会变得轻松。这时，我们也会感到放松。</li>  <li>另一个更为明显的标志是，他停止了谈话。</li>  <li>如果无法确定对方是否还有话要说，就不妨问一句“你还有什么要告诉我的么？”</li></ol><h3 id=\"倾听的力量\">倾听的力量</h3><h3 id=\"倾听使身心痊愈我们有没发现每当我们得到人们的倾听和理解时我们就可以用新的眼光看世界并继续前进\">倾听使身心痊愈，我们有没发现，每当我们得到人们的倾听和理解时，我们就可以用新的眼光看世界，并继续前进。</h3><h3 id=\"一旦有人倾听我们本来看起来无法解决的问题就有了解决办法千头万绪的思路也会变得清晰起来\">一旦有人倾听我们，本来看起来无法解决的问题就有了解决办法，千头万绪的思路也会变得清晰起来。</h3><p>在组织机构中，我们在听到上级的意见时，通常会把它看作是命令或指示。倾听同事或下级比倾听上级要容易得多。</p><p>在上级面前，我们有时可能会有点紧张，以致于无法静下心来体会他们的感受和需要，并给予反馈。</p><h3 id=\"倾听和示弱的能力\">倾听和示弱的能力</h3><h3 id=\"我们最不愿意示弱的时候往往是因为担心失去控制想显得强硬的时候\">我们最不愿意示弱的时候往往是因为担心失去控制想显得强硬的时候。</h3><p>当我们表达自己示弱时，有时人们会说一些糟糕的话，如果我们将它看作是羞辱或攻击，我们很可能就会觉得自己受到了伤害，甚至因为过于愤怒或害怕而无法倾听他们。</p><p>遇到这种情况，我们需要离开现场，来倾听自己心底的声音，或向好友倾诉，这将有助于我了解并体贴自己的感受和需要，等平静下来后，再回来与对方交流。</p><p>在痛苦的情形中，为了了解自己深层的需要，建议首先获得必要的倾听，以避免为充斥头脑的各种想法所束缚。</p><p>最后可以通过倾听他们的感受和需要，并给予他们反馈。</p><h3 id=\"倾听预防潜在的暴力\">倾听预防潜在的暴力</h3><p>那些被我们看作是恶魔的人，其实也是人，只是有时我们无法看到他们和我们的相同之处。</p><p>我越是专注于他的感受和需要，我就越把他看作因需要没有得到满足而感到绝望的人。</p><p>如果别人说“不”</p><p>当别人说“不”的时候，我们常常会认为他们是在拒绝我们。有时，我们甚至还会觉得受到了伤害。</p><p>然而，如果我们能够体会他人的感受和需要，我们也许就会发现是什么使他们无法答应我们的请求。</p><h3 id=\"使谈话生动有趣\">使谈话生动有趣</h3><p>怎样使谈话生动有趣呢？作者建议说话的人留意自己的感受和需要。</p><p>人们常常没有意识到，他们需要的是别人的理解和接纳。他们也没有意识到，直接表达自己的感受和需要，与讲故事相比，更容易得到他们所期待的联系。</p><p>另一种方法是，直接表达我们的愿望。</p><h3 id=\"如果别人保持沉默\">如果别人保持沉默</h3><p>有时候我们说了心里话，却发现对方一句话都不说，我们也许会很不安，容易把事情往坏处想，这时很难静下心来体会对方的感受和需要。但我们仍然要鼓起勇气体会对方，用平静的话语表达出来，询问对方当前的状态的原因。</p><p>这里作者举了一个例子：</p><pre><code>在一次工作时，作者在交谈中动了感情，哭了起来，但却发现对方转过身去，默不作声。这使得作者心里很不安，也很困惑。于是就问他，“你生气了吗？你希望与你工作的人有很好的自制力？”对方则回答，“不是这样的。我在想我的太太多么希望我能哭。”他接着讲到他和太太正在闹离婚的事情。不安和困惑就这样化解了。</code></pre><p>小结下，倾听帮助人们治愈了心灵的创伤，也使我们勇于面对自己的弱点。</p><h3 id=\"如何给他人反馈\">如何给他人反馈</h3><p>在倾听他人的观察、感受、需要和请求之后，我们可以主动过表达我们的理解。在提问前，先表达我们的感受和需要，这会鼓励人们主动表达自己。</p><p>那么什么时候需要反馈呢？他人的表达后，我们对他说的没有理解或没有把握时，我们需要与对方的确认。</p><p>当我们在给他人反馈时，语气十分重要。因为当一个人在听别人谈自己的感受和需要时，总会留意其中是否暗含着批评和嘲讽。</p><p>如果我们的语气很肯定，仿佛是在宣布他们的内心世界，那么，通常不会有好的反应。然而，如果对方通过我们的语气意识到我们是在体会他，而不是下结论，他们就不会产生反感了。</p><p>我们在一般谈话时，通常对方并不信任我们，除非对我们的意图有进一步的了解，否则他不会喜欢我们表达的方式。</p><p>然而，只要我们专注于他人的感受和需要，所有的批评、攻击、辱骂或嘲讽就会消失。</p><p>我们越是这样做，就越能体会到一个简单的事实：</p><ol>  <li>有时，我们认为自己受到了指责，实际上，那些话是他人表达需要和请求的方式。</li>  <li>如果意识到这一点，我们就不会认为自己的人格受到了伤害。</li>  <li>反之，如果一心分析自己或对方的过错，我们就会认为自己被贬低了。</li></ol><p>当然非暴力沟通并不是公式，有时候我们会机械地运用非暴力沟通模式，而忘记了其目的。这时我们应该问问自己，我们是否关心的是加深与人的联系。</p><h3 id=\"当我们痛苦的无法倾听时\">当我们痛苦的无法倾听时</h3><p>有时我们会发现，我们很痛苦，没有心情去关心别人。这时该怎么办？</p><p>联合国前秘书长汉马斯克德曾说“你越是留意自己内心的声音，就越能够听到别人的声音。”一旦我们能够敏锐地察觉并顾及自己的感受和需要，我们就有能力迅速调整好状态，来倾听他人。</p><p>第一种方式是，体会自己的感受和需要。另一种方式就是，大声提出请求。最后一种是换一个环境，用时间和空间来调整状态，等平静下来了，再回来。</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484864&amp;idx=1&amp;sn=da81a32d8fc50ce730259e03ea8344b1&amp;chksm=fc2260c7cb55e9d1ad4c9322f9d6f04c234fc72554d9a40050ff61639f80bbe701501151ae86&amp;token=326491610&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/08/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B039",
            
            
            
            
            
            "date_published": "2021-08-10T00:00:00+08:00",
            "date_modified": "2021-08-10T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/08/08/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A866",
            "title": "思路探讨(六十六) 与千万营收女企业家的一次午餐交流",
            "summary": "思路 随想 理念 逻辑 人生哲学",
            "content_text": "已发布在微信公众号上，点击跳转背景：与玉姐聊的很开心，也受益良多。玉姐是我在深圳认识的众多牛人中比较特别的一个，自主创业打拼天下，不仅自己成功上岸，还能带动周围的小伙伴一起成功。有幸能约到她一起吃午餐，聊了下各自工作、生活上的观点和看法，深受启发。颇有听君一席话胜读十年书的感触。概述：我们边吃边聊，对话中话题的切换比较快，我选择了几个比较有趣的话题，对我们帮助比较大的话题来写总结。1.沟通能力是关键2.经营公司完善制度和流程3.向高人学习4.不要在意输赢5.争取自由避免被束缚6.认可的人正文：1.沟通能力是关键沟通能力是比较关键的能力，它不仅仅是你能力的放大器还是集思广益、团队合作的重要方法，我们应该在平时更多关注这种能力的培养和复盘。玉姐建议在交流过程中，要能感受到对方情绪变化，通过这种变化来转换话题，这样可以让对话更加顺畅。不管是陌生人还是普通朋友，或是亲密朋友，都需要有一些沟通技巧来让彼此的交流更加舒畅。看的出来玉姐社交能力很强，不管是与朋友、陌生人、下属、老板、亲人都能保持平衡的关系，让对方与自己相处时很舒服。2.经营公司完善制度和流程在经营公司方面，玉姐认为自己当下最重要的是去完善公司的制度和流程，让公司运作更加有秩序。当前公司已经向成功迈进了很大一步，所以在流程的每个节点上要有有效的保障，目标是保证流程是牢固，当外部因素侵扰时仍然能有效运作。3.向高人学习玉姐建议在不同领域中有很多牛人，可以跟他们交流过程中相互输出观点，交换观点来开阔眼界，提升自我的认知。找更多机会与职级高的、视野广的、社会等级高的人交流，例如大公司高管、中层、或者企业家等，能学习到很多东西也开阔很多眼界。4.不要在意输赢过程比结果重要，人生是过程不是结果。过程中奋斗、蜕变，很精彩，结果只是附带的产品，不要太在意，专注过程。（因此玉姐也更喜欢专注于自己领域的男生^_^）联想到最近我拿自己的弱项（去学习演讲，学习沟通）跟别人的强项碰撞输的很惨。因此我最近比较痛苦，虽然我认为这种痛苦是值得的。玉姐认为人本身有就有自己擅长的和不擅长的，不用强求自己去做自己不擅长的，学习可以，但在学习的过程中不要太在意输赢，更不要在意别人怎么看。5.争取自由避免被束缚坚持自由意志对人的思维有很大好处，自发的主动比照搬照抄墨守成规的行动厉害的多。比如说我会对理论比较关注，认为理论是基础，但很多时候我被这些理论限制住了，发散不开思维。玉姐认为实践出真知，行动中、交流中迸发出智慧的火花，理论学习只是其中一个小部分，更多的要靠交流和实践来得出自己的智慧。6.认可的人严于律己宽以待人的人。聊到我们看到的一些现象，一些人本身家庭底子就很好，通过自己努力破除自身的思想束缚，拉拢身边的人让自己的智慧和能力放大数倍。其中严于律己宽以待人的人不仅自己能力强，还能通过高超的沟通能力来吸引周围的人一起将事情做大做强。这种人最可贵，自身要求高的同时还能照顾到周围人的情绪，懂得换位思考懂得体谅。已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484857&amp;idx=1&amp;sn=fa886cfca425df55fe3a3e037ea73e5b&amp;chksm=fc2260becb55e9a83ddb0bd8e3d3d1cc170cef9de8af0e76f676d16208f74595c58bd7b9d8d9&amp;token=2087589290&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h2 id=\"背景\">背景：</h2><p>与玉姐聊的很开心，也受益良多。</p><p>玉姐是我在深圳认识的众多牛人中比较特别的一个，自主创业打拼天下，不仅自己成功上岸，还能带动周围的小伙伴一起成功。</p><p>有幸能约到她一起吃午餐，聊了下各自工作、生活上的观点和看法，深受启发。</p><p>颇有听君一席话胜读十年书的感触。</p><h2 id=\"概述\">概述：</h2><p>我们边吃边聊，对话中话题的切换比较快，我选择了几个比较有趣的话题，对我们帮助比较大的话题来写总结。</p><p>1.沟通能力是关键</p><p>2.经营公司完善制度和流程</p><p>3.向高人学习</p><p>4.不要在意输赢</p><p>5.争取自由避免被束缚</p><p>6.认可的人</p><h2 id=\"正文\">正文：</h2><h3 id=\"1沟通能力是关键\">1.沟通能力是关键</h3><p>沟通能力是比较关键的能力，它不仅仅是你能力的放大器还是集思广益、团队合作的重要方法，我们应该在平时更多关注这种能力的培养和复盘。</p><p>玉姐建议在交流过程中，要能感受到对方情绪变化，通过这种变化来转换话题，这样可以让对话更加顺畅。</p><p>不管是陌生人还是普通朋友，或是亲密朋友，都需要有一些沟通技巧来让彼此的交流更加舒畅。</p><p>看的出来玉姐社交能力很强，不管是与朋友、陌生人、下属、老板、亲人都能保持平衡的关系，让对方与自己相处时很舒服。</p><h3 id=\"2经营公司完善制度和流程\">2.经营公司完善制度和流程</h3><p>在经营公司方面，玉姐认为自己当下最重要的是去完善公司的制度和流程，让公司运作更加有秩序。</p><p>当前公司已经向成功迈进了很大一步，所以在流程的每个节点上要有有效的保障，目标是保证流程是牢固，当外部因素侵扰时仍然能有效运作。</p><h3 id=\"3向高人学习\">3.向高人学习</h3><p>玉姐建议在不同领域中有很多牛人，可以跟他们交流过程中相互输出观点，交换观点来开阔眼界，提升自我的认知。</p><p>找更多机会与职级高的、视野广的、社会等级高的人交流，例如大公司高管、中层、或者企业家等，能学习到很多东西也开阔很多眼界。</p><h3 id=\"4不要在意输赢\">4.不要在意输赢</h3><p>过程比结果重要，人生是过程不是结果。过程中奋斗、蜕变，很精彩，结果只是附带的产品，不要太在意，专注过程。（因此玉姐也更喜欢专注于自己领域的男生^_^）</p><p>联想到最近我拿自己的弱项（去学习演讲，学习沟通）跟别人的强项碰撞输的很惨。因此我最近比较痛苦，虽然我认为这种痛苦是值得的。玉姐认为人本身有就有自己擅长的和不擅长的，不用强求自己去做自己不擅长的，学习可以，但在学习的过程中不要太在意输赢，更不要在意别人怎么看。</p><h3 id=\"5争取自由避免被束缚\">5.争取自由避免被束缚</h3><p>坚持自由意志对人的思维有很大好处，自发的主动比照搬照抄墨守成规的行动厉害的多。</p><p>比如说我会对理论比较关注，认为理论是基础，但很多时候我被这些理论限制住了，发散不开思维。</p><p>玉姐认为实践出真知，行动中、交流中迸发出智慧的火花，理论学习只是其中一个小部分，更多的要靠交流和实践来得出自己的智慧。</p><h3 id=\"6认可的人\">6.认可的人</h3><p>严于律己宽以待人的人。</p><p>聊到我们看到的一些现象，一些人本身家庭底子就很好，通过自己努力破除自身的思想束缚，拉拢身边的人让自己的智慧和能力放大数倍。</p><p>其中严于律己宽以待人的人不仅自己能力强，还能通过高超的沟通能力来吸引周围的人一起将事情做大做强。</p><p>这种人最可贵，自身要求高的同时还能照顾到周围人的情绪，懂得换位思考懂得体谅。</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484857&amp;idx=1&amp;sn=fa886cfca425df55fe3a3e037ea73e5b&amp;chksm=fc2260becb55e9a83ddb0bd8e3d3d1cc170cef9de8af0e76f676d16208f74595c58bd7b9d8d9&amp;token=2087589290&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/08/08/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A866",
            
            
            
            
            
            "date_published": "2021-08-08T00:00:00+08:00",
            "date_modified": "2021-08-08T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/08/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B038",
            "title": "读书笔记(三十八) 《非暴力沟通》#1 - 观察并表达感受",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：我观察到自己表达能力和沟通技巧有诸多问题，工作和生活上出现了比较大的瓶颈。为了帮助自己成长，我看了些表达和沟通方面的书，其中三本最为经典《非暴力沟通》、《关键对话》、《说话的艺术》。细细品读了这三本书并且收获满满，分享出来希望同大家一起学习。自从看完书后，反观自己以前的沟通技巧和表达方式，明白了以前自己在这方面的认知有比较大的错误，回想起来可以用愚蠢来形容。既然有这么好的沟通技巧和表达方式，我希望将这些方法和技巧实实在在的落地到实际生活中，让生活、工作、学习更美好。下面我就以《非暴力沟通》这本书为主线，来阐述我们在沟通过程中遇到的一些问题和对应的解决方法。正文：开头我同作者一样对这个世界有个疑问，“究竟是什么，使我们难以体会到心中的爱，以致于互相伤害？又是什么，让人在充满敌意的环境中，也能心存爱意？”我认识到我们的话语及表达方式对周遭有着巨大影响，也许我们并不认为自己的谈话方式是“暴力”的，但我们的话语确实常常引发自己和他人的痛苦，而这种痛苦很大可能就会成为互相伤害的开始。非暴力沟通可以指导我们转变谈话和聆听的方式，这样我们就不再条件反射式地做出反应了，而是先去明了自己的观察、感受和愿望，有意识地使用言语。这样，我们既诚实、清晰地表达了自己、又尊重与倾听了他人。每一次互动我们都能聆听到自己和他人心灵深处的呼声。同时，还能促使我们观察、发现正影响我们的行为和事件，并提出明确的请求。在平时的交流中，当我们听到批评时，我们一般会申辩、退缩或反击。然而，如果我们专注于彼此的观察、感受及需要，而不反驳他人，我们便能发现内心的柔情，从而最大限度避免互相伤害，避免“暴力”。那怎样才能做到在沟通时专注于观察和感受呢？作者提出非暴力沟通的四个要素，观察、感受、需要、请求：  首先，留意发生的事情，要点是清楚地表达观察结果而不评判或评估。  接着，表达感受，例如受伤、害怕、喜悦、兴奋等。  然后，说出哪些事情导致那样的感受。  最后，提出具体的请求。这四要素并不是什么固定的公式，它需要我们根据不同情况做出调整，其关键是对这四要素的觉察，而不在于使用什么字眼进行交流。暴力的表达蒙蔽了爱我们的话语和表达方式中常常会致力于满足我们的某种愿望，却倾向于忽视人的感受和需要，以致彼此的疏远和伤害。这些都是我们说话和表达的习惯造成的问题，我们可以通过观察、记录、觉醒、改善来改变这些习惯。下面作者举例了一些我们沟通中的一些习惯性错误：1.说话的言语中附带着评判我们习惯于将人分为好人和坏人、正常或不正常、负责或不负责任、聪明或愚蠢，诸如此类的评论暗含着我们的价值观及需要。当我们以附带评判的方式提出主张时，很可能会招来敌意，使我们的愿望更加难以满足。即使对方接受批评，做出让步，通常也不是心甘情愿的。每个人都有自己的看法，我们可以提出自己的价值观但不要夹杂着评判。实际上暴力的根源在于人们忽视彼此的感受与需要，而将冲突归咎于对方。例如美国把前苏联看作是致力于摧毁美国生活的“邪恶帝国”。而前苏联则将美国看作是试图征服他们的“帝国主义压迫者”。其实双方都没有承认内心的恐惧。与他人比较也是一种评判，当你在言语或表达中夹杂着比较时，例如与他人比较身高、体型、成就、财富，无论自己还是对方都会受到很大的伤害，同时蒙蔽我们对人对己的爱。2.话语中带有回避责任的意思我们对自己的思想、情感和行动是负有责任的，但是人们却在言语和表达中常常广泛使用“不得不”、“你让我”这类短语来试图回避责任。例如：“我不得不打扫房间”、“是老板让我做”、“是学校规定所以我不得不做”、“是朋友们让我抽烟”等等。当我们以这种回避责任的方式表达时，常常会让人感到我们在逃避责任，是个不负责任的人，缺少了爱。同时，这种表达方式也忽视了我们情感的内在根源。3.强人所难我们对别人的要求往往暗含着威胁：如果不配合，他们就会受到惩罚。在社会中，这是强者常用的手段。例如作为父亲，我的职责就是管教孩子。可是我发现，我可以提出各种要求，但无法强迫孩子们按我的期待生活，实际上盛气凌人并无济于事。是的，我们可以通过惩罚来教训他们，但如果我们真的那样做了，他们迟早也会想出办法来对付我们。现实中我们大多数人使用的言语倾向于评判、比较、命令和指责，而不是鼓励我们倾听彼此的感受和需要。更糟糕的是长期以来，我们强调人性本恶以及通过教育来控制天性，这导致我们对自己的感受和需要常常心存疑虑，以致于不愿去体会自己的内心世界。举个例子，对贵族、沙皇、国王来说，将臣民训练得具有奴隶般的精神状态符合他们的利益。所以“不应该”、“应该”和“不得不”这些表达方式特别适合这个目的的人。即人们越是习惯于评定是非，他们也就越倾向于追随权威，来获得正确和错误的标准。区分观察与评论第一要素，观察在沟通中，我们需要仔细观察正在发生的事情，并且清楚地说出观察结果。如果将观察与评论混为一谈，人们就倾向于听到批评，并且产生逆反心理。举个例子，有人说他是一个懒惰的人，实际上只是他的行为是懒惰的；再如，有人说他是个愚蠢的孩子，实际上只是他懂的事情与我们不一样。这些带有负面标签的话语会伤害到对方。不仅负面标签会产生消极影响，正面或中性的标签也会妨碍我们全面了解一个人。例如，用“厨师”、“客服”、“清洁工”一词来定义一个人。也就是说，当我们用标签定义一个人时，是有局限性的。有时我们会这样定义我们自己，造成我们给自己的局限性。哲学家克里希那穆提曾说“不带评论的观察是人类智力的最高形式”。在我们观察时，总会不自觉的夹带这些评论，例如在评论句子中，往往会出现“每次”、“曾”、“总是”、“从不”等词语。我们不主张绝对化的结论，而提倡在特定的时间和情景中进行观察，并清楚地描述观察结果。体会和表达感受第二要素，感受很多人认为感受是无关紧要的，重要的是各种权威主张的“正确思想”。于是我们被鼓励服从权威而非倾听自己，渐渐地我们习惯于考虑，“人们期待我怎么做“，而非我的感受是什么。实际上表达内心的感受，不仅可以促进亲情，还可以改善工作。作者在一次管理层协助会议上请求管理层们告诉员工“我们感到不安”，这遭到负责人的反对。于是作者问为什么不能做，主席回答说“一旦我们示弱，他们就会更加盛气凌人。”对他的回答作者并不感到意外，毕竟对许多人来说，在工作时表达情感是无法想象的事情。但最终在作者的请求下主席还是尝试将不安的感受告诉了员工，意外的是接受到感受的员工们非常支持，最后项目顺利通过。这种表达自己感受的“示弱”会产生积极的影响，人们通常会通过我们的感受逐渐开始了解我们，并且对我们所关心的事物产生兴趣。区分感受和想法在沟通中，我们需要注意区分感受和想法。当我们说“我觉得”时，常常并不是在表达感受，而是在表达想法。换成“我认为”或许更恰当。还有些词表达想法而非感受的词语，如，被抛弃、被羞辱、被虐待、被打扰、被拒绝、不受重视、被束缚、被欺负、无人理睬、得不到支持、无人赏识、被利用等等。举例，我们在说话时表达的想法而非感受的例子：  我觉得你应该懂的更多  我觉得经常被打扰  我做的事总是得不到支持实际沟通中，当我们要清楚地表达感受时，需要丰富的词汇，因为简单的词语很难让人明白我们的实际状况。为了能更好的沟通情感，非暴力沟通主张使用具体的语言，下面举例来说哪些词语能很好的表达感受。表达满足的感受：兴奋、喜悦、欣喜、甜蜜、精力充沛、兴高采烈、感激、感动、乐观、自信、振作、振奋、开心、高兴、快乐、愉快、幸福、陶醉、满足、欣慰、心旷神怡、喜出望外、平静、自在、舒适、放松、踏实、安全、温暖、放心、无忧无虑表达没有满足的感受：害怕、担心、焦虑、忧虑、着急、紧张、心神不宁、心烦意乱、忧伤、沮丧、灰心、气馁、泄气、绝望、伤感、凄凉、悲伤、恼怒、愤怒、烦恼、苦恼、生气、厌烦、不满、不快、不耐烦、不高兴、震惊、失望、困惑、茫然、寂寞、郁闷、难过、悲观、沉重、麻木、精疲力尽、萎靡不振、疲惫不堪、昏昏欲睡、无精打采、尴尬、惭愧、内疚、妒忌、遗憾、不舒服通过建立表达感受的词汇表，我们可以更清楚地表达感受，从而使沟通更为顺畅。感受的根源感受的根源在于我们自身，我们的需要和期待以及对他人言行的看法，导致了我们的感受。平时沟通中，我们常会听到不中听的话，通常我们有四种选择：  认为自己犯了错  指责对方  了解我们的感受和需要  用心体会他人的感受和需要反过来也是一样的，当我们遇到不安时，会去指责他人，或利用他人的内疚。这时通常采取的办法是，把自己不愉快的感受归咎于对方。例如，家长会跟孩子说“你成绩不好让爸妈很伤心”，言下之意是爸妈的不快乐与否是孩子的行为造成的。看到父母的痛苦，孩子可能会感到内疚，并因此调整行为来迎合他们。但这种调整只是为了避免内疚，而非出自对学习的热爱，长期来看会造成更加糟糕的情况。通过了解我们的需要、愿望、期待以及想法，用心体会他人的感受和需要，承认我们的感受源于自身，我们就能做到不再指责他人。非暴力沟通需要：生命健康成长的要素批评往往暗含着期待，对他人的批评实际上间接表达了我们尚未满足的需要。如果我们通过批评来提出主张，人们的反应常常是申辩或反击。反之，如果我们直接说出需要，其他人就较有可能作出积极的回应。不幸的是，大多数人并不习惯从需求的角度来考虑问题。特别是在不顺心的时候，我们往往倾向于考虑别人有什么错。作者认为，只要我们开始谈论需要而不去指责对方，我们就有可能找到办法来满足双方的需要，让我们双赢。非暴力沟通把需要看作是有助于生命健康成长的要素，而不是某种具体的行为。如果我们不看重自己的需要，别人可能也不会。实际上，如果直接说出需要，获得积极回应的可能性就会增加。作者举了个例子一位朋友说自己小时候为了得到医院里赠送的小礼物，装病让妈妈陪他去看病并且动了手术，最后获得了这个小礼物，在病床时他把这个礼物递给护士看，但护士以为是送给她的于是就拿走了。这个不幸的故事告诉我们，如果一个人无法说出自己的需要，会是多么的痛苦。从“情感的奴隶”到“生活的主人”对于大多数人来说，个人成长分为三个阶段：第一阶段，情感的奴隶此时我们认为自己有义务使他人快乐。认为别人不高兴是我们的责任。因此我们特别容易把亲人看作是负担。许多人认为，爱情就是牺牲自己来满足爱人的需要。随着关系变得“严肃”，他们开始认为自己有责任让情人过的开心，于是，爱情开始沉重起来。作者举例自己女儿玛拉的经历玛拉以前是个“有礼貌的小女孩”，对别人的要求总是百依百顺，她习惯于委屈自己来迎合他人。注意这个情况后，作者鼓励她大胆地说出心里话，当作者告诉她自己的看法时，女儿哭了。她很无奈的说，“但是，爸爸，我不想让任何人失望！”。我回答说，真诚待人比委曲求全更为可贵。如果别人感到不安，我们可以认真地倾诉，但无须责备自己。不久后女儿有了些变化，学校规定不允许穿牛仔裤，玛拉没好气的说“见鬼去吧”，作者很高兴玛拉终于能说出自己的心里话，只是她还要学着尊重他人的需要，相信这只是时间问题。第二阶段，面目可憎此时我们拒绝考虑他人的感受和需要。认为牺牲自己迎合他人的代价实在太大，因此拒绝考虑他们。此时如果他人遭遇痛苦，我们可能就会无动于衷，“和我有什么关系！”。虽然不再愿意为他人负责，但我们还心存疑虑。第三阶段，生活的主人这个阶段，我们乐于互助。我们帮助他人，是出于爱，而不是出于恐惧、内疚或惭愧。那是自由而快乐的行为。此时我们意识到，我们对自己的意愿、感受和行动负有完全的责任，但无法为他人负责。同时还认识到，我们无法牺牲他人来满足自己的需要。这篇到此，希望对大家有所帮助，我们下篇继续已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484849&amp;idx=1&amp;sn=3f19b8b6b3295aa952641f62aadce98b&amp;chksm=fc2260b6cb55e9a0079d4f2254fd46699c6e5e345e7e92ba6fb9a15666a39aec9b62279c4de7&amp;token=347679726&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h2 id=\"背景\">背景：</h2><p>我观察到自己表达能力和沟通技巧有诸多问题，工作和生活上出现了比较大的瓶颈。为了帮助自己成长，我看了些表达和沟通方面的书，其中三本最为经典《非暴力沟通》、《关键对话》、《说话的艺术》。细细品读了这三本书并且收获满满，分享出来希望同大家一起学习。</p><p>自从看完书后，反观自己以前的沟通技巧和表达方式，明白了以前自己在这方面的认知有比较大的错误，回想起来可以用愚蠢来形容。</p><p>既然有这么好的沟通技巧和表达方式，我希望将这些方法和技巧实实在在的落地到实际生活中，让生活、工作、学习更美好。</p><p>下面我就以《非暴力沟通》这本书为主线，来阐述我们在沟通过程中遇到的一些问题和对应的解决方法。</p><h2 id=\"正文\">正文：</h2><p>开头我同作者一样对这个世界有个疑问，“究竟是什么，使我们难以体会到心中的爱，以致于互相伤害？又是什么，让人在充满敌意的环境中，也能心存爱意？”</p><h3 id=\"我认识到我们的话语及表达方式对周遭有着巨大影响也许我们并不认为自己的谈话方式是暴力的但我们的话语确实常常引发自己和他人的痛苦而这种痛苦很大可能就会成为互相伤害的开始\">我认识到我们的话语及表达方式对周遭有着巨大影响，也许我们并不认为自己的谈话方式是“暴力”的，但我们的话语确实常常引发自己和他人的痛苦，而这种痛苦很大可能就会成为互相伤害的开始。</h3><p>非暴力沟通可以指导我们转变谈话和聆听的方式，这样我们就不再条件反射式地做出反应了，而是先去明了自己的观察、感受和愿望，有意识地使用言语。这样，我们既诚实、清晰地表达了自己、又尊重与倾听了他人。每一次互动我们都能聆听到自己和他人心灵深处的呼声。同时，还能促使我们观察、发现正影响我们的行为和事件，并提出明确的请求。</p><h3 id=\"在平时的交流中当我们听到批评时我们一般会申辩退缩或反击\">在平时的交流中，当我们听到批评时，我们一般会申辩、退缩或反击。</h3><h3 id=\"然而如果我们专注于彼此的观察感受及需要而不反驳他人我们便能发现内心的柔情从而最大限度避免互相伤害避免暴力\">然而，如果我们专注于彼此的观察、感受及需要，而不反驳他人，我们便能发现内心的柔情，从而最大限度避免互相伤害，避免“暴力”。</h3><p>那怎样才能做到在沟通时专注于观察和感受呢？</p><h3 id=\"作者提出非暴力沟通的四个要素观察感受需要请求\">作者提出非暴力沟通的四个要素，观察、感受、需要、请求：</h3><ol>  <li>首先，留意发生的事情，要点是清楚地表达观察结果而不评判或评估。</li>  <li>接着，表达感受，例如受伤、害怕、喜悦、兴奋等。</li>  <li>然后，说出哪些事情导致那样的感受。</li>  <li>最后，提出具体的请求。</li></ol><h3 id=\"这四要素并不是什么固定的公式它需要我们根据不同情况做出调整其关键是对这四要素的觉察而不在于使用什么字眼进行交流\">这四要素并不是什么固定的公式，它需要我们根据不同情况做出调整，其关键是对这四要素的觉察，而不在于使用什么字眼进行交流。</h3><h2 id=\"暴力的表达蒙蔽了爱\">暴力的表达蒙蔽了爱</h2><h3 id=\"我们的话语和表达方式中常常会致力于满足我们的某种愿望却倾向于忽视人的感受和需要以致彼此的疏远和伤害\">我们的话语和表达方式中常常会致力于满足我们的某种愿望，却倾向于忽视人的感受和需要，以致彼此的疏远和伤害。</h3><p>这些都是我们说话和表达的习惯造成的问题，我们可以通过观察、记录、觉醒、改善来改变这些习惯。</p><p>下面作者举例了一些我们沟通中的一些习惯性错误：</p><p>1.说话的言语中附带着评判</p><p>我们习惯于将人分为好人和坏人、正常或不正常、负责或不负责任、聪明或愚蠢，诸如此类的评论暗含着我们的价值观及需要。</p><h3 id=\"当我们以附带评判的方式提出主张时很可能会招来敌意使我们的愿望更加难以满足即使对方接受批评做出让步通常也不是心甘情愿的\">当我们以附带评判的方式提出主张时，很可能会招来敌意，使我们的愿望更加难以满足。即使对方接受批评，做出让步，通常也不是心甘情愿的。</h3><p>每个人都有自己的看法，我们可以提出自己的价值观但不要夹杂着评判。</p><h3 id=\"实际上暴力的根源在于人们忽视彼此的感受与需要而将冲突归咎于对方\">实际上暴力的根源在于人们忽视彼此的感受与需要，而将冲突归咎于对方。</h3><p>例如美国把前苏联看作是致力于摧毁美国生活的“邪恶帝国”。而前苏联则将美国看作是试图征服他们的“帝国主义压迫者”。其实双方都没有承认内心的恐惧。</p><p>与他人比较也是一种评判，当你在言语或表达中夹杂着比较时，例如与他人比较身高、体型、成就、财富，无论自己还是对方都会受到很大的伤害，同时蒙蔽我们对人对己的爱。</p><p>2.话语中带有回避责任的意思</p><p>我们对自己的思想、情感和行动是负有责任的，但是人们却在言语和表达中常常广泛使用“不得不”、“你让我”这类短语来试图回避责任。</p><p>例如：“我不得不打扫房间”、“是老板让我做”、“是学校规定所以我不得不做”、“是朋友们让我抽烟”等等。</p><h3 id=\"当我们以这种回避责任的方式表达时常常会让人感到我们在逃避责任是个不负责任的人缺少了爱同时这种表达方式也忽视了我们情感的内在根源\">当我们以这种回避责任的方式表达时，常常会让人感到我们在逃避责任，是个不负责任的人，缺少了爱。同时，这种表达方式也忽视了我们情感的内在根源。</h3><p>3.强人所难</p><p>我们对别人的要求往往暗含着威胁：如果不配合，他们就会受到惩罚。在社会中，这是强者常用的手段。</p><p>例如作为父亲，我的职责就是管教孩子。可是我发现，我可以提出各种要求，但无法强迫孩子们按我的期待生活，实际上盛气凌人并无济于事。</p><p>是的，我们可以通过惩罚来教训他们，但如果我们真的那样做了，他们迟早也会想出办法来对付我们。</p><h3 id=\"现实中我们大多数人使用的言语倾向于评判比较命令和指责而不是鼓励我们倾听彼此的感受和需要\">现实中我们大多数人使用的言语倾向于评判、比较、命令和指责，而不是鼓励我们倾听彼此的感受和需要。</h3><h3 id=\"更糟糕的是长期以来我们强调人性本恶以及通过教育来控制天性这导致我们对自己的感受和需要常常心存疑虑以致于不愿去体会自己的内心世界\">更糟糕的是长期以来，我们强调人性本恶以及通过教育来控制天性，这导致我们对自己的感受和需要常常心存疑虑，以致于不愿去体会自己的内心世界。</h3><p>举个例子，对贵族、沙皇、国王来说，将臣民训练得具有奴隶般的精神状态符合他们的利益。所以“不应该”、“应该”和“不得不”这些表达方式特别适合这个目的的人。即人们越是习惯于评定是非，他们也就越倾向于追随权威，来获得正确和错误的标准。</p><h2 id=\"区分观察与评论\">区分观察与评论</h2><p>第一要素，观察</p><h3 id=\"在沟通中我们需要仔细观察正在发生的事情并且清楚地说出观察结果如果将观察与评论混为一谈人们就倾向于听到批评并且产生逆反心理\">在沟通中，我们需要仔细观察正在发生的事情，并且清楚地说出观察结果。如果将观察与评论混为一谈，人们就倾向于听到批评，并且产生逆反心理。</h3><p>举个例子，有人说他是一个懒惰的人，实际上只是他的行为是懒惰的；再如，有人说他是个愚蠢的孩子，实际上只是他懂的事情与我们不一样。</p><p>这些带有负面标签的话语会伤害到对方。</p><p>不仅负面标签会产生消极影响，正面或中性的标签也会妨碍我们全面了解一个人。</p><p>例如，用“厨师”、“客服”、“清洁工”一词来定义一个人。</p><h3 id=\"也就是说当我们用标签定义一个人时是有局限性的有时我们会这样定义我们自己造成我们给自己的局限性\">也就是说，当我们用标签定义一个人时，是有局限性的。有时我们会这样定义我们自己，造成我们给自己的局限性。</h3><h3 id=\"哲学家克里希那穆提曾说不带评论的观察是人类智力的最高形式\">哲学家克里希那穆提曾说“不带评论的观察是人类智力的最高形式”。</h3><p>在我们观察时，总会不自觉的夹带这些评论，例如在评论句子中，往往会出现“每次”、“曾”、“总是”、“从不”等词语。</p><p>我们不主张绝对化的结论，而提倡在特定的时间和情景中进行观察，并清楚地描述观察结果。</p><h2 id=\"体会和表达感受\">体会和表达感受</h2><p>第二要素，感受</p><p>很多人认为感受是无关紧要的，重要的是各种权威主张的“正确思想”。于是我们被鼓励服从权威而非倾听自己，渐渐地我们习惯于考虑，“人们期待我怎么做“，而非我的感受是什么。</p><h3 id=\"实际上表达内心的感受不仅可以促进亲情还可以改善工作\">实际上表达内心的感受，不仅可以促进亲情，还可以改善工作。</h3><p>作者在一次管理层协助会议上请求管理层们告诉员工“我们感到不安”，这遭到负责人的反对。于是作者问为什么不能做，主席回答说“一旦我们示弱，他们就会更加盛气凌人。”</p><p>对他的回答作者并不感到意外，毕竟对许多人来说，在工作时表达情感是无法想象的事情。但最终在作者的请求下主席还是尝试将不安的感受告诉了员工，意外的是接受到感受的员工们非常支持，最后项目顺利通过。</p><h3 id=\"这种表达自己感受的示弱会产生积极的影响人们通常会通过我们的感受逐渐开始了解我们并且对我们所关心的事物产生兴趣\">这种表达自己感受的“示弱”会产生积极的影响，人们通常会通过我们的感受逐渐开始了解我们，并且对我们所关心的事物产生兴趣。</h3><h2 id=\"区分感受和想法\">区分感受和想法</h2><p>在沟通中，我们需要注意区分感受和想法。</p><p>当我们说“我觉得”时，常常并不是在表达感受，而是在表达想法。换成“我认为”或许更恰当。</p><p>还有些词表达想法而非感受的词语，如，被抛弃、被羞辱、被虐待、被打扰、被拒绝、不受重视、被束缚、被欺负、无人理睬、得不到支持、无人赏识、被利用等等。</p><p>举例，我们在说话时表达的想法而非感受的例子：</p><ul>  <li>我觉得你应该懂的更多</li>  <li>我觉得经常被打扰</li>  <li>我做的事总是得不到支持</li></ul><h3 id=\"实际沟通中当我们要清楚地表达感受时需要丰富的词汇因为简单的词语很难让人明白我们的实际状况\">实际沟通中，当我们要清楚地表达感受时，需要丰富的词汇，因为简单的词语很难让人明白我们的实际状况。</h3><p>为了能更好的沟通情感，非暴力沟通主张使用具体的语言，下面举例来说哪些词语能很好的表达感受。</p><p>表达满足的感受：</p><p>兴奋、喜悦、欣喜、甜蜜、精力充沛、兴高采烈、感激、感动、乐观、自信、振作、振奋、开心、高兴、</p><p>快乐、愉快、幸福、陶醉、满足、欣慰、心旷神怡、喜出望外、平静、自在、舒适、放松、踏实、安全、</p><p>温暖、放心、无忧无虑</p><p>表达没有满足的感受：</p><p>害怕、担心、焦虑、忧虑、着急、紧张、心神不宁、心烦意乱、忧伤、沮丧、灰心、气馁、泄气、绝望、</p><p>伤感、凄凉、悲伤、恼怒、愤怒、烦恼、苦恼、生气、厌烦、不满、不快、不耐烦、不高兴、震惊、失望、</p><p>困惑、茫然、寂寞、郁闷、难过、悲观、沉重、麻木、精疲力尽、萎靡不振、疲惫不堪、昏昏欲睡、无精打采、</p><p>尴尬、惭愧、内疚、妒忌、遗憾、不舒服</p><h3 id=\"通过建立表达感受的词汇表我们可以更清楚地表达感受从而使沟通更为顺畅\">通过建立表达感受的词汇表，我们可以更清楚地表达感受，从而使沟通更为顺畅。</h3><h2 id=\"感受的根源\">感受的根源</h2><p>感受的根源在于我们自身，我们的需要和期待以及对他人言行的看法，导致了我们的感受。</p><p>平时沟通中，我们常会听到不中听的话，通常我们有四种选择：</p><ol>  <li>认为自己犯了错</li>  <li>指责对方</li>  <li>了解我们的感受和需要</li>  <li>用心体会他人的感受和需要</li></ol><p>反过来也是一样的，当我们遇到不安时，会去指责他人，或利用他人的内疚。这时通常采取的办法是，把自己不愉快的感受归咎于对方。</p><p>例如，家长会跟孩子说“你成绩不好让爸妈很伤心”，言下之意是爸妈的不快乐与否是孩子的行为造成的。</p><p>看到父母的痛苦，孩子可能会感到内疚，并因此调整行为来迎合他们。但这种调整只是为了避免内疚，而非出自对学习的热爱，长期来看会造成更加糟糕的情况。</p><h3 id=\"通过了解我们的需要愿望期待以及想法用心体会他人的感受和需要承认我们的感受源于自身我们就能做到不再指责他人\">通过了解我们的需要、愿望、期待以及想法，用心体会他人的感受和需要，承认我们的感受源于自身，我们就能做到不再指责他人。</h3><h2 id=\"非暴力沟通需要生命健康成长的要素\">非暴力沟通需要：生命健康成长的要素</h2><h3 id=\"批评往往暗含着期待对他人的批评实际上间接表达了我们尚未满足的需要\">批评往往暗含着期待，对他人的批评实际上间接表达了我们尚未满足的需要。</h3><h3 id=\"如果我们通过批评来提出主张人们的反应常常是申辩或反击\">如果我们通过批评来提出主张，人们的反应常常是申辩或反击。</h3><h3 id=\"反之如果我们直接说出需要其他人就较有可能作出积极的回应\">反之，如果我们直接说出需要，其他人就较有可能作出积极的回应。</h3><h3 id=\"不幸的是大多数人并不习惯从需求的角度来考虑问题特别是在不顺心的时候我们往往倾向于考虑别人有什么错\">不幸的是，大多数人并不习惯从需求的角度来考虑问题。特别是在不顺心的时候，我们往往倾向于考虑别人有什么错。</h3><p>作者认为，只要我们开始谈论需要而不去指责对方，我们就有可能找到办法来满足双方的需要，让我们双赢。</p><p>非暴力沟通把需要看作是有助于生命健康成长的要素，而不是某种具体的行为。如果我们不看重自己的需要，别人可能也不会。实际上，如果直接说出需要，获得积极回应的可能性就会增加。</p><p>作者举了个例子</p><p>一位朋友说自己小时候为了得到医院里赠送的小礼物，装病让妈妈陪他去看病并且动了手术，最后获得了这个小礼物，在病床时他把这个礼物递给护士看，但护士以为是送给她的于是就拿走了。</p><p>这个不幸的故事告诉我们，如果一个人无法说出自己的需要，会是多么的痛苦。</p><p>从“情感的奴隶”到“生活的主人”</p><p>对于大多数人来说，个人成长分为三个阶段：</p><p>第一阶段，情感的奴隶</p><p>此时我们认为自己有义务使他人快乐。认为别人不高兴是我们的责任。因此我们特别容易把亲人看作是负担。</p><h3 id=\"许多人认为爱情就是牺牲自己来满足爱人的需要随着关系变得严肃他们开始认为自己有责任让情人过的开心于是爱情开始沉重起来\">许多人认为，爱情就是牺牲自己来满足爱人的需要。随着关系变得“严肃”，他们开始认为自己有责任让情人过的开心，于是，爱情开始沉重起来。</h3><p>作者举例自己女儿玛拉的经历</p><p>玛拉以前是个“有礼貌的小女孩”，对别人的要求总是百依百顺，她习惯于委屈自己来迎合他人。</p><p>注意这个情况后，作者鼓励她大胆地说出心里话，当作者告诉她自己的看法时，女儿哭了。她很无奈的说，“但是，爸爸，我不想让任何人失望！”。我回答说，真诚待人比委曲求全更为可贵。如果别人感到不安，我们可以认真地倾诉，但无须责备自己。不久后女儿有了些变化，学校规定不允许穿牛仔裤，玛拉没好气的说“见鬼去吧”，作者很高兴玛拉终于能说出自己的心里话，只是她还要学着尊重他人的需要，相信这只是时间问题。</p><p>第二阶段，面目可憎</p><h3 id=\"此时我们拒绝考虑他人的感受和需要认为牺牲自己迎合他人的代价实在太大因此拒绝考虑他们\">此时我们拒绝考虑他人的感受和需要。认为牺牲自己迎合他人的代价实在太大，因此拒绝考虑他们。</h3><p>此时如果他人遭遇痛苦，我们可能就会无动于衷，“和我有什么关系！”。虽然不再愿意为他人负责，但我们还心存疑虑。</p><p>第三阶段，生活的主人</p><h3 id=\"这个阶段我们乐于互助我们帮助他人是出于爱而不是出于恐惧内疚或惭愧那是自由而快乐的行为\">这个阶段，我们乐于互助。我们帮助他人，是出于爱，而不是出于恐惧、内疚或惭愧。那是自由而快乐的行为。</h3><p>此时我们意识到，我们对自己的意愿、感受和行动负有完全的责任，但无法为他人负责。同时还认识到，我们无法牺牲他人来满足自己的需要。</p><p>这篇到此，希望对大家有所帮助，我们下篇继续</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484849&amp;idx=1&amp;sn=3f19b8b6b3295aa952641f62aadce98b&amp;chksm=fc2260b6cb55e9a0079d4f2254fd46699c6e5e345e7e92ba6fb9a15666a39aec9b62279c4de7&amp;token=347679726&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/08/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B038",
            
            
            
            
            
            "date_published": "2021-08-01T00:00:00+08:00",
            "date_modified": "2021-08-01T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/07/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B037",
            "title": "读书笔记(三十七) 《心流》#1 - 寻找生命的意义",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：在2020年初就买了《心流》，直到2021年1月才读完第一遍，刹那间开阔了我的眼界。读完本书让我的专注力提高了一个级别，这让我非常兴奋。而这只是我读了第一遍吸收到的10%都不到结果，我想它的魔力远不止于此，于是决定好好复习总结一下书本中的内容，开启了第二遍、第三遍的读书旅程。平时我在工作、生活、交流、学习时，常常很难集中注意力，因此我带着好奇心阅读了这本书。我猜大家应该也和我一样希望自己在专注做一件事情的时候能够拥有更高的效率。本书的核心是心流的最优体验，当你的心流体验最佳时是学习效率最高的时候同时也是最幸福的时刻，里面讲到了关于学习、工作、运动、交际等方面的心流原理和技巧，下面开始详细讲解一下。正文：本书的序是我所读过的书中最长的序，也是有最多名人写感悟的序，整整写了63页的序。序中写了几位高知在细品本书后的体会与感悟，这些体会与感悟给了我很多启发，同时让我对本书整体思想和逻辑有了一个大致的了解。于是本不想对序的内容进行总结的我，由于这本书的序实在太精彩，不由自主的将序也纳入了书本的内容范围，同时也侧面反映了这本书的精彩程度。作者米哈里是一位心理学家，同时他对生物学和社会学也非常关注，他认为这三大学科都是对幸福研究的重要领域。他说，动物的技巧总是能配合实际的需要，因为它们的心灵只容纳当下环境中与它们切身相关、能靠直觉判断的资讯。例如：饥饿的狮子只注意能帮助它猎到羚羊的资讯，吃饱的狮子注意力则完全集中在温暖的阳光上。人类与动物最大的差别就在于神经系统过于发达。虽然我们感知和摄取比其他动物更多的信息，这样有利于人类生存，但烦恼也更多，多知也多忧。例如金钱就困扰了我们大部分人，那么金钱到底是否能让人幸福呢？米哈里认为不是。虽然很多学者也有相同的看法，但这其中一部分人走向了另一个极端，即将幸福替代金钱，将它放在最重要的位置上（以前金钱的位置上），他们认为幸福才是人生理当直奔的主题。米哈里也否认这种判断。事实上，幸福感通常根本不是作为目标存在于人们的追求中，它只不过是表现为目标中附带的现象。米哈里认为，幸福是你全身心投入一桩事物，达到忘我的程度，并由此获得的内心秩序和安宁的状态。例如一位攀岩的选手，不断逼身体发挥所有的极限，直到全身隐隐作痛，然后满怀敬畏的回顾自我，回顾所做的一切，那种佩服的感觉简直无法形容。攀岩最终目的是攀岩，正如写作的目的是写作一样，你唯一征服的是自己的内心，而不是为了到达山顶或乌托邦。当你全力争取胜利时，其他就不那么重要了，甚至连胜利本身都不重要。专注的过程达到忘我的状态，虽说不是幸福的全部，但也是它很重要的一部分。练习专注的过程并不容易，我们往往要花三、五年甚至十年二十年的时间来学习剔除外部干扰、克服紧张，使自己的学习或表演能够放松、自然、快乐。可见学习快乐，并不是一件容易的事。有人认为专注某项活动精神消耗会更大，米哈里则不这么认为。他认为专注让大脑减轻了负担，心流较强的人在专注时会关闭其他资讯通道，只把注意力集中在接收闪光的刺激上。对于这种懂得如何控制意识的人而言，专注反而更轻松。专注通常伴随着挑战，如果挑战不是自愿的，通常无法达到心流。如果目标太难或者太简单，也同样会造成心流的消失，降低幸福感和体验。因此首先我们要自己去寻找目标，其次要去调整目标高度，让目标有一个适合我们的难度。例如历史上贵族阶层脱离生产后，缺少了生活上的挑战，从而面临生命不能承受之轻，一部分贵族陷入物欲不能自拔，另一部分选择体育、音乐、诗歌词赋的艺术化生活方式。这种工作而非无所事事的挑战，例如攀岩、舞蹈、下棋、运动、游戏也可以造就心流。其中体育具备造就心流的最佳条件：明确的目标、即时的回馈、易学难精带来的上不封顶的挑战。它最大的功能是帮助人们控制自己：学习控制自己的身体，学习控制自己的精神，学习控制自己的注意力。这种技巧不持续练习是不会提高的，持续下去主要考的也不是耐心，而是不断发现技巧上的微妙差异，靠的是持续存在的关注点。此外，书中提到了熵，熵是指系统的混乱程度，越混乱，熵值越高。反之，系统内部越有规律，结构越清晰，熵值就越低。例如水变成冰时熵值就很低，变成水蒸气后熵值就很大。熵延伸到我们的人身上也适用，人如果没有节制，没有经过训练，大脑常常会处于混乱状态，虽然你能意识到的可能只有少数几个念头，但在潜意识里却有很多念头在互相冲突，它们在争夺你的注意力，抢夺你的大脑的控制权，并且试图引导、影响你往南辕北辙的方向走。但是如果你进入了心流状态，那就不一样了，虽然你的大脑仍然在高速运转，但是所有这些念头都是非常有规律、有秩序的，就像一支有纪律的军队，被井井有条地组织了起来，高效地去完成一个任务。心流就是这样一个降熵的过程，把原来混乱的心序重新组合成有规律的集体。当心熵比较高时一片混乱，大脑的做功能力很低，很多心理能量都浪费在内耗上了。一旦进入心流状态，心理能量就围绕着同一个主题组织起来，向同一个方向高效输出，此时人的表现也最好。如果一个人经常经历心流，他的心理就会被训练得越来越有秩序，以后进入心流就越来越容易，即使平时不在心流状态下，也不会像一般人那样心猿意马了。降低心熵最典型的例子就是冥想，在冥想中，你摒除杂念，心灵澄净，如一道清澈的心流。经过长期练习之后，哪怕不在冥想之中，你的心灵也会比常人更平静，遇到意外变故时能更快地集中注意力，也就是你的心熵整体降低了。例如高僧冥想多年后才能达到波澜不惊，而我们也同样需要反复练习才能更容易进入心流，但这一切都是值得的。一些虔诚的基督徒也有同样的修为，当他们遇到生活的苦难时，也会难过，但在祷告和与亲友交流后会坦然接受这个苦难，“上帝爱我，他的安排一定自有他的深意”。这样一次次苦难中经历信念的动摇和重固的挑战，最终形成更加坚定的信仰，从而更好地指导自己生活的方方面面，这样全神贯注而又平安喜乐，就等于把整个人生过成了一场大心流。至于普通人怎么把一生过成心流体验，米哈里的建议是，首先要找一个终生的目标，其次不要害怕其复杂性，这就是对你人生意义的挑战。你可以用“行动式生活”和“反省式生活”相结合来逐步应对挑战实现你的目标，只要个人目标与宇宙心流汇合，意义的问题也就迎刃而解了。生命的意义会随着你的心流而升级，从简单舒适，到社会价值，从个人发展，到个人与社会的重新整合，不断升级，挑战也滚滚而来，生命就在这些不断挑战和升级中找到意义。其实降熵的过程有高下，心流也有高下，原本的混沌越多，整合进去的元素越复杂，这个心流就越伟大。也就是说，那些能够整合无比复杂的人生、找到人生意义，整合无比复杂的世界、形成自己的价值观的人，就会有最大的心流。当然，过犹不及，米哈里有时也过分强调了集中注意力的好处。新的研究表明“注意力不集中”也是一种对健康至关重要的状态。在注意力不集中的情况下，我们的大脑大部分时间处于默认模式，这种状态是发散思维和创新的必要条件。如果能在专注一段时候后放松一下准备下一段专注，这样的持续效率会更高。说到底心流只是一个方法，其背后的逻辑是，“通过锻炼控制自己的意识，去获得真正的幸福”。如果你直接追求的并不是幸福，而是把自己变得更复杂，在这个变复杂的过程中，你就能找到乐趣，此时这个状态就是幸福。人生要的不是最后终点的结果，而是每时每刻点点滴滴成长的过程，其实成长本身就是我们的目的。据我所知，90%的家长在孩子学习的时候设定了过重的目标，且常常过于重视技巧和速成，使得学习成为了孩子的负担，这样孩子们自然无法从中得到快乐。如果能把精神集中在过程上，比如优美的画面、欢快的节奏，更多的及时反馈，小目标达成的快乐，这样孩子们的体验就会更好，学习的劲头也更足。说了这么多，其实只有学会控制心灵的人才能决定自己的生活品质，而如果具备了这种能力，也就相当于接近幸福的境界了。快乐与否，取决于内心是否和谐，就得从掌握意识着手，学习从生活中创造乐趣，多加练习就能掌握，化无聊为有趣，也就兴趣盎然了。心流的这个态度是真正的以人为本，当我们做事的时候如果不在乎结果能不能给自己带来多大的利益，而是专注于做这件事本身，就能从中获巨大的乐趣。最后祝大家通过能心流找到人生的意义，我们下篇继续《心流》已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484840&amp;idx=1&amp;sn=a56725615b9e43cdb1f8848b1ef54183&amp;chksm=fc2260afcb55e9b9f3ee8b37a78872623bd55ec5e8151779fa477c30fb9be9c601ad3d78b43d&amp;token=1126834365&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h2 id=\"背景\">背景：</h2><p>在2020年初就买了《心流》，直到2021年1月才读完第一遍，刹那间开阔了我的眼界。</p><p>读完本书让我的专注力提高了一个级别，这让我非常兴奋。而这只是我读了第一遍吸收到的10%都不到结果，我想它的魔力远不止于此，于是决定好好复习总结一下书本中的内容，开启了第二遍、第三遍的读书旅程。</p><p>平时我在工作、生活、交流、学习时，常常很难集中注意力，因此我带着好奇心阅读了这本书。我猜大家应该也和我一样希望自己在专注做一件事情的时候能够拥有更高的效率。</p><p>本书的核心是心流的最优体验，当你的心流体验最佳时是学习效率最高的时候同时也是最幸福的时刻，里面讲到了关于学习、工作、运动、交际等方面的心流原理和技巧，下面开始详细讲解一下。</p><h2 id=\"正文\">正文：</h2><p>本书的序是我所读过的书中最长的序，也是有最多名人写感悟的序，整整写了63页的序。</p><p>序中写了几位高知在细品本书后的体会与感悟，这些体会与感悟给了我很多启发，同时让我对本书整体思想和逻辑有了一个大致的了解。于是本不想对序的内容进行总结的我，由于这本书的序实在太精彩，不由自主的将序也纳入了书本的内容范围，同时也侧面反映了这本书的精彩程度。</p><p>作者米哈里是一位心理学家，同时他对生物学和社会学也非常关注，他认为这三大学科都是对幸福研究的重要领域。</p><p>他说，动物的技巧总是能配合实际的需要，因为它们的心灵只容纳当下环境中与它们切身相关、能靠直觉判断的资讯。例如：饥饿的狮子只注意能帮助它猎到羚羊的资讯，吃饱的狮子注意力则完全集中在温暖的阳光上。</p><p>人类与动物最大的差别就在于神经系统过于发达。虽然我们感知和摄取比其他动物更多的信息，这样有利于人类生存，但烦恼也更多，多知也多忧。</p><h3 id=\"例如金钱就困扰了我们大部分人那么金钱到底是否能让人幸福呢米哈里认为不是\">例如金钱就困扰了我们大部分人，那么金钱到底是否能让人幸福呢？米哈里认为不是。</h3><h3 id=\"虽然很多学者也有相同的看法但这其中一部分人走向了另一个极端即将幸福替代金钱将它放在最重要的位置上以前金钱的位置上他们认为幸福才是人生理当直奔的主题米哈里也否认这种判断\">虽然很多学者也有相同的看法，但这其中一部分人走向了另一个极端，即将幸福替代金钱，将它放在最重要的位置上（以前金钱的位置上），他们认为幸福才是人生理当直奔的主题。米哈里也否认这种判断。</h3><p>事实上，幸福感通常根本不是作为目标存在于人们的追求中，它只不过是表现为目标中附带的现象。米哈里认为，幸福是你全身心投入一桩事物，达到忘我的程度，并由此获得的内心秩序和安宁的状态。</p><p>例如一位攀岩的选手，不断逼身体发挥所有的极限，直到全身隐隐作痛，然后满怀敬畏的回顾自我，回顾所做的一切，那种佩服的感觉简直无法形容。</p><h3 id=\"攀岩最终目的是攀岩正如写作的目的是写作一样你唯一征服的是自己的内心而不是为了到达山顶或乌托邦\">攀岩最终目的是攀岩，正如写作的目的是写作一样，你唯一征服的是自己的内心，而不是为了到达山顶或乌托邦。</h3><h3 id=\"当你全力争取胜利时其他就不那么重要了甚至连胜利本身都不重要\">当你全力争取胜利时，其他就不那么重要了，甚至连胜利本身都不重要。</h3><p>专注的过程达到忘我的状态，虽说不是幸福的全部，但也是它很重要的一部分。</p><p>练习专注的过程并不容易，我们往往要花三、五年甚至十年二十年的时间来学习剔除外部干扰、克服紧张，使自己的学习或表演能够放松、自然、快乐。可见学习快乐，并不是一件容易的事。</p><p>有人认为专注某项活动精神消耗会更大，米哈里则不这么认为。</p><p>他认为专注让大脑减轻了负担，心流较强的人在专注时会关闭其他资讯通道，只把注意力集中在接收闪光的刺激上。对于这种懂得如何控制意识的人而言，专注反而更轻松。</p><h3 id=\"专注通常伴随着挑战如果挑战不是自愿的通常无法达到心流\">专注通常伴随着挑战，如果挑战不是自愿的，通常无法达到心流。</h3><h3 id=\"如果目标太难或者太简单也同样会造成心流的消失降低幸福感和体验\">如果目标太难或者太简单，也同样会造成心流的消失，降低幸福感和体验。</h3><p>因此首先我们要自己去寻找目标，其次要去调整目标高度，让目标有一个适合我们的难度。</p><p>例如历史上贵族阶层脱离生产后，缺少了生活上的挑战，从而面临生命不能承受之轻，一部分贵族陷入物欲不能自拔，另一部分选择体育、音乐、诗歌词赋的艺术化生活方式。这种工作而非无所事事的挑战，例如攀岩、舞蹈、下棋、运动、游戏也可以造就心流。</p><p>其中体育具备造就心流的最佳条件：明确的目标、即时的回馈、易学难精带来的上不封顶的挑战。</p><p>它最大的功能是帮助人们控制自己：学习控制自己的身体，学习控制自己的精神，学习控制自己的注意力。</p><p>这种技巧不持续练习是不会提高的，持续下去主要考的也不是耐心，而是不断发现技巧上的微妙差异，靠的是持续存在的关注点。</p><h3 id=\"此外书中提到了熵熵是指系统的混乱程度越混乱熵值越高反之系统内部越有规律结构越清晰熵值就越低\">此外，书中提到了熵，熵是指系统的混乱程度，越混乱，熵值越高。反之，系统内部越有规律，结构越清晰，熵值就越低。</h3><p>例如水变成冰时熵值就很低，变成水蒸气后熵值就很大。</p><p>熵延伸到我们的人身上也适用，人如果没有节制，没有经过训练，大脑常常会处于混乱状态，虽然你能意识到的可能只有少数几个念头，但在潜意识里却有很多念头在互相冲突，它们在争夺你的注意力，抢夺你的大脑的控制权，并且试图引导、影响你往南辕北辙的方向走。但是如果你进入了心流状态，那就不一样了，虽然你的大脑仍然在高速运转，但是所有这些念头都是非常有规律、有秩序的，就像一支有纪律的军队，被井井有条地组织了起来，高效地去完成一个任务。</p><h3 id=\"心流就是这样一个降熵的过程把原来混乱的心序重新组合成有规律的集体\">心流就是这样一个降熵的过程，把原来混乱的心序重新组合成有规律的集体。</h3><p>当心熵比较高时一片混乱，大脑的做功能力很低，很多心理能量都浪费在内耗上了。一旦进入心流状态，心理能量就围绕着同一个主题组织起来，向同一个方向高效输出，此时人的表现也最好。</p><h3 id=\"如果一个人经常经历心流他的心理就会被训练得越来越有秩序以后进入心流就越来越容易即使平时不在心流状态下也不会像一般人那样心猿意马了\">如果一个人经常经历心流，他的心理就会被训练得越来越有秩序，以后进入心流就越来越容易，即使平时不在心流状态下，也不会像一般人那样心猿意马了。</h3><p>降低心熵最典型的例子就是冥想，在冥想中，你摒除杂念，心灵澄净，如一道清澈的心流。</p><p>经过长期练习之后，哪怕不在冥想之中，你的心灵也会比常人更平静，遇到意外变故时能更快地集中注意力，也就是你的心熵整体降低了。</p><p>例如高僧冥想多年后才能达到波澜不惊，而我们也同样需要反复练习才能更容易进入心流，但这一切都是值得的。</p><p>一些虔诚的基督徒也有同样的修为，当他们遇到生活的苦难时，也会难过，但在祷告和与亲友交流后会坦然接受这个苦难，“上帝爱我，他的安排一定自有他的深意”。</p><p>这样一次次苦难中经历信念的动摇和重固的挑战，最终形成更加坚定的信仰，从而更好地指导自己生活的方方面面，这样全神贯注而又平安喜乐，就等于把整个人生过成了一场大心流。</p><p>至于普通人怎么把一生过成心流体验，米哈里的建议是，首先要找一个终生的目标，其次不要害怕其复杂性，这就是对你人生意义的挑战。</p><p>你可以用“行动式生活”和“反省式生活”相结合来逐步应对挑战实现你的目标，只要个人目标与宇宙心流汇合，意义的问题也就迎刃而解了。</p><p>生命的意义会随着你的心流而升级，从简单舒适，到社会价值，从个人发展，到个人与社会的重新整合，不断升级，挑战也滚滚而来，生命就在这些不断挑战和升级中找到意义。</p><h3 id=\"其实降熵的过程有高下心流也有高下原本的混沌越多整合进去的元素越复杂这个心流就越伟大\">其实降熵的过程有高下，心流也有高下，原本的混沌越多，整合进去的元素越复杂，这个心流就越伟大。</h3><h3 id=\"也就是说那些能够整合无比复杂的人生找到人生意义整合无比复杂的世界形成自己的价值观的人就会有最大的心流\">也就是说，那些能够整合无比复杂的人生、找到人生意义，整合无比复杂的世界、形成自己的价值观的人，就会有最大的心流。</h3><p>当然，过犹不及，米哈里有时也过分强调了集中注意力的好处。新的研究表明“注意力不集中”也是一种对健康至关重要的状态。在注意力不集中的情况下，我们的大脑大部分时间处于默认模式，这种状态是发散思维和创新的必要条件。如果能在专注一段时候后放松一下准备下一段专注，这样的持续效率会更高。</p><p>说到底心流只是一个方法，其背后的逻辑是，“通过锻炼控制自己的意识，去获得真正的幸福”。</p><h3 id=\"如果你直接追求的并不是幸福而是把自己变得更复杂在这个变复杂的过程中你就能找到乐趣此时这个状态就是幸福\">如果你直接追求的并不是幸福，而是把自己变得更复杂，在这个变复杂的过程中，你就能找到乐趣，此时这个状态就是幸福。</h3><h3 id=\"人生要的不是最后终点的结果而是每时每刻点点滴滴成长的过程其实成长本身就是我们的目的\">人生要的不是最后终点的结果，而是每时每刻点点滴滴成长的过程，其实成长本身就是我们的目的。</h3><p>据我所知，90%的家长在孩子学习的时候设定了过重的目标，且常常过于重视技巧和速成，使得学习成为了孩子的负担，这样孩子们自然无法从中得到快乐。如果能把精神集中在过程上，比如优美的画面、欢快的节奏，更多的及时反馈，小目标达成的快乐，这样孩子们的体验就会更好，学习的劲头也更足。</p><p>说了这么多，其实只有学会控制心灵的人才能决定自己的生活品质，而如果具备了这种能力，也就相当于接近幸福的境界了。快乐与否，取决于内心是否和谐，就得从掌握意识着手，学习从生活中创造乐趣，多加练习就能掌握，化无聊为有趣，也就兴趣盎然了。</p><h3 id=\"心流的这个态度是真正的以人为本当我们做事的时候如果不在乎结果能不能给自己带来多大的利益而是专注于做这件事本身就能从中获巨大的乐趣\">心流的这个态度是真正的以人为本，当我们做事的时候如果不在乎结果能不能给自己带来多大的利益，而是专注于做这件事本身，就能从中获巨大的乐趣。</h3><p>最后祝大家通过能心流找到人生的意义，我们下篇继续《心流》</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484840&amp;idx=1&amp;sn=a56725615b9e43cdb1f8848b1ef54183&amp;chksm=fc2260afcb55e9b9f3ee8b37a78872623bd55ec5e8151779fa477c30fb9be9c601ad3d78b43d&amp;token=1126834365&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/07/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B037",
            
            
            
            
            
            "date_published": "2021-07-25T00:00:00+08:00",
            "date_modified": "2021-07-25T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/07/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B036",
            "title": "读书笔记(三十六) 《张爱玲传记》成就富家才女的落魄家族",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：这是一本张爱玲的他传《张爱玲-民国临水照花人》，读书前我问过自己，为什么要读这本书。大概是因为我有两个女儿的关系，使得我迫切想去了解女性的世界，包括她们的成长、她们的心理、她们的困惑、她们的烦恼等。因此我陆陆续续读完了国民四大才女的传记，《林徽因》，《陆小曼》、《张爱玲》、《三毛》传记，我希望通过这四个民国才女来了解女性在成长和发展过程中需要经历的困惑与煎熬。直到有了女儿我才体会到女性与男性有着完全不同的路径和体验，也因此在这些年读了很多关于女性书籍后更深有体会。《张爱玲-民国临水照花人》这本书着实也给了我很多震撼，为此我不得不给自己留下一篇回顾性的文章， 以记录下读完此书后给我带来的感受。正文：张爱玲这一生有很多成就，同时也伴随着很多人对她的负面评价，但无论怎样她都没有被这个世界改变，她一直在活出自己，一直都是那个有才但又羞涩的少女。张爱玲祖上有许多积累，她的祖父、外祖父、曾外祖父都是当时有名的人物，比如曾外祖父就是李鸿章，外祖父是张佩纶科举中榜并后来受军机处重用位于重要职务。整个家族从父亲张延重开始没落，和当时许多高官的子孙一样，由于祖辈只留下遗产而没有留下好的教养和精神力量，因此寻花问柳和赌博是这些富家子弟的常态。父亲张延重与长江水师提督孙女黄逸梵结婚后很快就生下女儿张爱玲，后来他们又生了一个弟弟张子静。母亲和父亲从小的家庭氛围完全不同，父亲更多的是老派作风，性格刻板拘谨，母亲则接受过开明的新式教育，风情漂亮，思想新潮，因此两人格格不入。其实张爱玲从小就在学习氛围浓重的家庭长大，父母很小开始就亲自教她读书写字，而且张爱玲也很喜欢读书，三岁就会背唐诗成了父亲的掌上明珠。好景不长，在那个动荡的时代每个家庭都处于风雨摇摆之中，虽然张家家底比较殷实没有那么辛苦，但父亲与母亲的矛盾愈演愈烈。父亲希望母亲能对自己言听计从，以弥补自己多年来所承受的束缚；母亲则为刚逃脱父权压制又落入夫权专横的家庭感到绝望。失落和失望中父亲开始堕落，出入风月场所，吸鸦片，还带姨太太回家。母亲则喜欢洋派的派对并到处旅游，东南亚、日本、欧洲，对父亲的行为很少在意。其实最初他们两彼此也曾试图为了靠近对方改变过自己的价值观，守旧的父亲为了能追随妻子的思想看起了洋书，一心向往新思想的黄逸梵读起了唐诗，但最终还是以失败告终。母亲对张爱玲的教育一直放在心上，她希望女儿得到新思想的熏陶，所以她精心为女儿安排了钢琴、英文和绘画等课程，这为张爱玲营造出了良好的艺术氛围。最终父亲与母亲还是劳燕分飞了，离婚前母亲告诉父亲自己心已如木头一般，父亲听了心潮涌动，想到对方屡次退步已退无可退不如海阔天空，放各自一条生路。离婚后母亲过的风生水起，旅游、派对、崇尚欧美风格的时尚着装，奢华洋派的生活再一次影响了张爱玲的人生观。这些所有的经历都会使人成长，无论最后定型为哪一种性格，都是自然而然的事情，习惯了分离，就会觉得一个人往前走是种常态。在这个乱世里体会过不同的感受，张爱玲小小年纪就学会了将喜怒哀乐都转换为坚强。因此她一生对任何事情和情感的漠然令人疑惑，殊不知，张爱玲在幼时就已经修炼成风轻云淡的心态，既然要来的早晚要来，不如看淡，走好眼前的路，才是当下最好的生活。父亲对女儿的新思想教育不太支持，所以每次张爱玲向父亲要上课的学费时，父亲都是冷漠以待，因为他无法容忍妻子的影子影射到女儿的身上。父亲后来娶了新妻子，继母对张爱玲很讨厌，也很讨厌前任妻子，这让原本曾一度父女相依为命的温情在继母的影响下落到不堪的地步。最后张爱玲离家出走去了亲身母亲家里，但其实亲生母亲家中并不富有，只能维持现状，无法给张爱玲更好的环境。所以张爱玲很小就知道，唯有知识才能改变命运，当别人还在懵懂迷茫的时候，她早已开始谋划未来。当然张爱玲与母亲也有很大的隔阂，由于张爱玲从习惯了小富家小姐的环境，懒散又不太会家务，出门连路都不认得，因此让母亲很不满意，时常斥责张爱玲。饱尝巨大落差的张爱玲，心里却是介意的，觉得母亲是个自私的女人，为了享乐还要挥霍有限的金钱，对待自己的女儿却要百般计较。张爱玲所经历的畸形家庭裂变，和身边亲人的冷漠自私，尤其是在金钱上遭受过的窘迫和难堪，都深深地影响了她的人生观。后来张爱玲在母亲的帮助下苦读，考上了香港大学。当时香港刚好在战火中，一边读书一边听炮火的经历让张爱玲刻骨铭心。张爱玲的姑姑是张爱玲生命中重要的亲人，母亲崇尚自由很早就去了国外，留下姑姑与她相伴。姑姑的品位与学识也深深影响着张爱玲，在张爱玲离开上海时，姑姑正在英商洋行做事，后来听了别人建议投资股票失败又遇时局动荡，辞职到电台工作了一段时间后，又去了大光明戏院做翻译，后来供职于外资企业，生活还算过的悠闲。在大学里张爱玲仍然需要一边读书一边赚取生活费，写稿的紧张节奏令张爱玲逐渐吃不消，于是她决定退学而正是走上写作的道路。在专注创作后不久，张爱玲体会到了中文小说的谋篇布局，畅意抒怀的创作更让她淋漓尽致发挥自己的才华，曾向往的林语堂方式的英文写作，远不如她书写生活中的市井生活，和身边人的人生百态。从小读《红楼梦》长大的张爱玲，又在港大将西方作家的作品统统学过，将文学精粹炼进自己的文字里，形成独树一帜的风格。张爱玲感情生活中，最著名也是最有争议的一段感情就是与“国民汉奸”胡兰成。胡兰成从桂系军阀到汪精卫伪政府一直走的是邪魔歪道的路线，但对于涉世不深的张爱玲来说她并没有意识到胡兰成的问题所在。汪精卫以重金拉拢胡兰成于羽翼之下，胡兰成成为他们的御用文人，汪精卫伪政府成立后胡兰成上任宣传部部长。当时的张爱玲在感情上相当于一张白纸，而胡兰成则早已经历了风风雨雨无论情场还是职场都是老手了，加之胡兰成在文学上有一些造诣让张爱玲很快就沦陷了。胡兰成一介寒士爬到如今的位置，那些上流社会的美好始终在他心中梦一般的存在着，不曾想到这一切在张爱玲心里竟不值一提。高傲的张爱玲自有她的万丈光芒，无须以自己的家世来衬托，她的不屑与他的渴望形成了鲜明的讽刺。但是胡兰成的细腻还是将张爱玲的骄傲清冷融化，令她产生出多年来从而有过的归属感。他与她之间共生出的默契是张爱玲从未感受过的强烈洪流。坊间的俗语，流氓不可怕，就怕流氓有文化，来形容胡兰成很是贴切。而常年孤僻生活和写作的幻想空间，使得张爱玲脱离了现实，她常常拿小说里的经验来判断胡兰成对待她的真伪。胡兰成在张爱玲结束前就有三位妻子，结婚后又与女同事出轨，在日本战败后逃离中又与好友家中的寡妇联结，最后张爱玲忍无可忍分手道别。可惜已经太晚，张爱玲已经背负了汉奸之妻的身份，出门也要伪装自己以免被人认出。母亲回国后看到张爱玲的样子，认为她沉浸在小城市里裹足不前，应该去往更远的地方看看世界，提高眼界。此时母亲自身的能力非常出色，在国外做尼赫鲁两姐妹的社交秘书，因此对于沉浸在小情小调文字中的张爱玲不屑一顾，甚至有几分怒其不争的愤慨。那个年轻风情文雅的母亲早已消失不见，站在眼前的是一个强势又自我的老太婆。张爱玲太过了解母亲黄逸梵，从小与父母有隔阂的张爱玲羞于喊出“妈妈”这般亲昵的字眼，母亲当年给她心理造成的阴影，让她一直以“婶婶”相称。同时在母亲回来看女儿的时刻，张爱玲提出了要用二两金子还清母女之情，母亲得知女儿的意思后潸然泪下后婉拒了女儿，又踏上了出国的旅程。张爱玲一生未育，当然也无法体会母亲年轻时候所承受的一切，而只是执拗地刺激着给了她生命的母亲。其实母女两人都是极端自我的女子，不同的是，黄逸梵不仅学历高，交际手腕也高明，还有非常远大的追求；张爱玲则大学没有上完因此没有大学毕业证，更不擅长为人处世。与胡兰成离婚后，张爱玲用剧本拍了几部电影非常火热，还与导演桑弧热恋，桑弧是个非常擅长人情世故的人，这是因为在电影行业里必定要学会处世才能混得风生水起。但谈到结婚生子时，张爱玲是抗拒的，她往前看似乎能看到未来的路上有一个身影，重叠着自己年少时的孤独和恐惧，她不想重蹈母亲的覆辙，她恨母亲的自私，但同时她也是与母亲一样的女人，没有能力去爱护幼小的生命。与导演桑弧分手后张爱玲回到了香港大学，继续漂泊继续流浪，漂泊对她与母亲来说似乎已经成为了一种信仰。在香港她认识了邝文美，邝文美相貌不仅秀丽端庄，又是个学识、有见地的才女，她的温柔像一条薄厚相宜的毯子，柔软的话语覆盖过来，让张爱玲四肢百骸都放松下来，像遇见多年未见的幼年伙伴怎么说话也说不完。在那个人人都想出人头地的时代，邝文美始终以家庭为重，将家庭和事业经营得有声有色。她放弃了荣华富贵的机遇，不攀附权贵，却愿意和远在异乡的张爱玲结为知己。邝文美在生活里应付自如的涵养，恰到好处地弥补了张爱玲不理俗事的弱点。邝文美本就对张爱玲非常欣赏，又加之她深谙人性特点，在这样的友谊中，她不但能理解张爱玲天真的幼稚，亦能包容她不明世故的观点。1953年美国放开移民政策，张爱玲在麦卡锡的担保下离开了香港去往美国。在那里她邂逅了共度半生的美国作家普德南.赖雅。赖雅是位德国移民后裔，在哈弗大学读到文艺硕士毕业后，从事英文教室工作。在艺术方面天赋极高，不仅文学作品优秀，摄影也非常出色。先后担任欧洲战地记者，自由撰稿人，欧洲采访知名作家等，经历非常丰富。但此时赖雅已经65岁了，而张爱玲才36岁，她曾坦言：一向对于年纪大一点的人感到亲切，对于和自己年纪差不多的人则有点看不起。在美国几年后，收到了母亲病重的来信，而张爱玲只写了封信，寄上100美元的支票安慰母亲，让她好好治病。母亲在她心里一直都是个强大的女人，她在追求自由的道路上，是个快乐的女神，怎么会被疾病轻易击垮？多年来在两人之间的隔膜已经深成了跨不过去的沟壑。张爱玲同时也流掉了与丈夫赖雅的孩子，这与张爱玲从小缺乏家庭关爱不无关系。母亲黄逸梵手术后不久，就离开了人世，张爱玲默然承受着这个结果，没能满足母亲最后的愿望，张爱玲为此大病一场。母亲走了为女儿留下一箱古董，黄逸梵在病体难抗的绝境里，完全可以卖掉古董来治病，一向有见地的她并没有这么做，而是留给了女人张爱玲，这是母亲对张爱玲最后的眷恋。黄逸梵从张爱玲四岁起就离开了上海前往国外，从此爱上了独自旅行。她跑到欧洲的学校学绘画，又去了马来西亚的华侨学校教书，在瑞士的阿尔卑斯山上，这个三寸金莲的美丽女子勇敢从山顶往下飞滑。在游历过程中所邂逅的情人，无不是浪漫多情又绅士的外国男子，这让她品尝到了爱情的真谛。从家庭角度讲，黄逸梵并不是个称职的母亲，但却对张爱玲的成长有着很深的影响，面对封建旧式家庭的规矩，她毅然站出来拒绝女儿缠足，还自作主张教导女儿英语、钢琴，从而也使得张爱玲熏陶到良好的西方文化。虽然母女俩不常见面，张爱玲在心里将母亲当作偶像，张爱玲对事业的追求和我行我素的风格，以及爱情上的观念，甚至是后来漂泊海外的流浪旅途都与母亲有着惊人的吻合，她们是相爱相杀的母女，黄逸梵的洒脱是留给张爱玲的华丽背影，也是投射在她心灵深处的阴影。1967年赖雅去世，张爱玲心情降到冰点。但天亮了，张爱玲还要将写作进行下去，生命的真相有时候没必要去追根究底，因为宿命的安排或是性格上的原因，也许是一个人最简单的寄托。张爱玲的弟弟张子静在新中国成立后在上海浦东一所小学任教，先后又更换了几所学校，于1986年正式退休搬到江苏路的一个14平方米小屋居住，这是父亲败光家产后遗留给他的最后遗产。1953年父亲张延重肺病去世，继母所依赖房屋被政府回收后的定息也在文革爆发后停止发放。1970年继母双目失明，弟弟给她请了个保姆，1986年离世。1983年弟弟联系到张爱玲并劝姐姐回国，但张爱玲拒绝了弟弟的请求，并告诉他能保持书信就好。到了晚年，张爱玲再读《红楼梦》时在书中读出了整个张氏大家族与贾府相似的命运，从而让她对世事产生出悲凉之感。她年轻时争名夺利的性情，如风过，已是了无痕。往事已过去多年，她对人生有了新的认识，不再是浮于表面的浅薄。虽是个老太太，举止言谈间却完全是一个自闭的少女状态，但神清里有说不出的柔和恬静，遇事的时候也已经能够泰然自若。晚年整理回忆录《对照记》时，选了100多幅她与家人、朋友的照片，母亲、姑姑、闺蜜和她的风华正茂，都定格在光影里。其中最为经典的是那张，最具张爱玲风范，她的脸庞轻轻上扬，眼睛望向侧上方，穿着缎子做的高领短袖，如生在世间的一枝兰，高傲贵气又出尘。1995年9月8日，张爱玲去世在自己的公寓里，旁边的书桌上是一叠铺开的稿纸和一支未合上的笔。张爱玲在遗嘱中把所有的遗产都留给了邝文美。已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484831&amp;idx=1&amp;sn=844da82b7868b494c0d71c1713a813f5&amp;chksm=fc226098cb55e98e222bcbeff2646b4fed2bbc6eb2416090a75aece54d9064258674990ccfc0&amp;token=1401123908&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h1 id=\"背景\">背景：</h1><p>这是一本张爱玲的他传《张爱玲-民国临水照花人》，读书前我问过自己，为什么要读这本书。</p><p>大概是因为我有两个女儿的关系，使得我迫切想去了解女性的世界，包括她们的成长、她们的心理、她们的困惑、她们的烦恼等。因此我陆陆续续读完了国民四大才女的传记，《林徽因》，《陆小曼》、《张爱玲》、《三毛》传记，我希望通过这四个民国才女来了解女性在成长和发展过程中需要经历的困惑与煎熬。</p><h3 id=\"直到有了女儿我才体会到女性与男性有着完全不同的路径和体验也因此在这些年读了很多关于女性书籍后更深有体会\">直到有了女儿我才体会到女性与男性有着完全不同的路径和体验，也因此在这些年读了很多关于女性书籍后更深有体会。</h3><p>《张爱玲-民国临水照花人》这本书着实也给了我很多震撼，为此我不得不给自己留下一篇回顾性的文章， 以记录下读完此书后给我带来的感受。</p><h1 id=\"正文\">正文：</h1><p>张爱玲这一生有很多成就，同时也伴随着很多人对她的负面评价，但无论怎样她都没有被这个世界改变，她一直在活出自己，一直都是那个有才但又羞涩的少女。</p><h3 id=\"张爱玲祖上有许多积累她的祖父外祖父曾外祖父都是当时有名的人物比如曾外祖父就是李鸿章外祖父是张佩纶科举中榜并后来受军机处重用位于重要职务\">张爱玲祖上有许多积累，她的祖父、外祖父、曾外祖父都是当时有名的人物，比如曾外祖父就是李鸿章，外祖父是张佩纶科举中榜并后来受军机处重用位于重要职务。</h3><h3 id=\"整个家族从父亲张延重开始没落和当时许多高官的子孙一样由于祖辈只留下遗产而没有留下好的教养和精神力量因此寻花问柳和赌博是这些富家子弟的常态\">整个家族从父亲张延重开始没落，和当时许多高官的子孙一样，由于祖辈只留下遗产而没有留下好的教养和精神力量，因此寻花问柳和赌博是这些富家子弟的常态。</h3><h3 id=\"父亲张延重与长江水师提督孙女黄逸梵结婚后很快就生下女儿张爱玲后来他们又生了一个弟弟张子静\">父亲张延重与长江水师提督孙女黄逸梵结婚后很快就生下女儿张爱玲，后来他们又生了一个弟弟张子静。</h3><p>母亲和父亲从小的家庭氛围完全不同，父亲更多的是老派作风，性格刻板拘谨，母亲则接受过开明的新式教育，风情漂亮，思想新潮，因此两人格格不入。</p><p>其实张爱玲从小就在学习氛围浓重的家庭长大，父母很小开始就亲自教她读书写字，而且张爱玲也很喜欢读书，三岁就会背唐诗成了父亲的掌上明珠。</p><p>好景不长，在那个动荡的时代每个家庭都处于风雨摇摆之中，虽然张家家底比较殷实没有那么辛苦，但父亲与母亲的矛盾愈演愈烈。</p><h3 id=\"父亲希望母亲能对自己言听计从以弥补自己多年来所承受的束缚母亲则为刚逃脱父权压制又落入夫权专横的家庭感到绝望\">父亲希望母亲能对自己言听计从，以弥补自己多年来所承受的束缚；母亲则为刚逃脱父权压制又落入夫权专横的家庭感到绝望。</h3><p>失落和失望中父亲开始堕落，出入风月场所，吸鸦片，还带姨太太回家。母亲则喜欢洋派的派对并到处旅游，东南亚、日本、欧洲，对父亲的行为很少在意。</p><h3 id=\"其实最初他们两彼此也曾试图为了靠近对方改变过自己的价值观守旧的父亲为了能追随妻子的思想看起了洋书一心向往新思想的黄逸梵读起了唐诗但最终还是以失败告终\">其实最初他们两彼此也曾试图为了靠近对方改变过自己的价值观，守旧的父亲为了能追随妻子的思想看起了洋书，一心向往新思想的黄逸梵读起了唐诗，但最终还是以失败告终。</h3><p>母亲对张爱玲的教育一直放在心上，她希望女儿得到新思想的熏陶，所以她精心为女儿安排了钢琴、英文和绘画等课程，这为张爱玲营造出了良好的艺术氛围。</p><h3 id=\"最终父亲与母亲还是劳燕分飞了离婚前母亲告诉父亲自己心已如木头一般父亲听了心潮涌动想到对方屡次退步已退无可退不如海阔天空放各自一条生路\">最终父亲与母亲还是劳燕分飞了，离婚前母亲告诉父亲自己心已如木头一般，父亲听了心潮涌动，想到对方屡次退步已退无可退不如海阔天空，放各自一条生路。</h3><p>离婚后母亲过的风生水起，旅游、派对、崇尚欧美风格的时尚着装，奢华洋派的生活再一次影响了张爱玲的人生观。</p><p>这些所有的经历都会使人成长，无论最后定型为哪一种性格，都是自然而然的事情，习惯了分离，就会觉得一个人往前走是种常态。</p><p>在这个乱世里体会过不同的感受，张爱玲小小年纪就学会了将喜怒哀乐都转换为坚强。</p><p>因此她一生对任何事情和情感的漠然令人疑惑，殊不知，张爱玲在幼时就已经修炼成风轻云淡的心态，既然要来的早晚要来，不如看淡，走好眼前的路，才是当下最好的生活。</p><p>父亲对女儿的新思想教育不太支持，所以每次张爱玲向父亲要上课的学费时，父亲都是冷漠以待，因为他无法容忍妻子的影子影射到女儿的身上。</p><p>父亲后来娶了新妻子，继母对张爱玲很讨厌，也很讨厌前任妻子，这让原本曾一度父女相依为命的温情在继母的影响下落到不堪的地步。</p><p>最后张爱玲离家出走去了亲身母亲家里，但其实亲生母亲家中并不富有，只能维持现状，无法给张爱玲更好的环境。</p><p>所以张爱玲很小就知道，唯有知识才能改变命运，当别人还在懵懂迷茫的时候，她早已开始谋划未来。</p><p>当然张爱玲与母亲也有很大的隔阂，由于张爱玲从习惯了小富家小姐的环境，懒散又不太会家务，出门连路都不认得，因此让母亲很不满意，时常斥责张爱玲。</p><h3 id=\"饱尝巨大落差的张爱玲心里却是介意的觉得母亲是个自私的女人为了享乐还要挥霍有限的金钱对待自己的女儿却要百般计较\">饱尝巨大落差的张爱玲，心里却是介意的，觉得母亲是个自私的女人，为了享乐还要挥霍有限的金钱，对待自己的女儿却要百般计较。</h3><h3 id=\"张爱玲所经历的畸形家庭裂变和身边亲人的冷漠自私尤其是在金钱上遭受过的窘迫和难堪都深深地影响了她的人生观\">张爱玲所经历的畸形家庭裂变，和身边亲人的冷漠自私，尤其是在金钱上遭受过的窘迫和难堪，都深深地影响了她的人生观。</h3><p>后来张爱玲在母亲的帮助下苦读，考上了香港大学。当时香港刚好在战火中，一边读书一边听炮火的经历让张爱玲刻骨铭心。</p><p>张爱玲的姑姑是张爱玲生命中重要的亲人，母亲崇尚自由很早就去了国外，留下姑姑与她相伴。</p><h3 id=\"姑姑的品位与学识也深深影响着张爱玲在张爱玲离开上海时姑姑正在英商洋行做事后来听了别人建议投资股票失败又遇时局动荡辞职到电台工作了一段时间后又去了大光明戏院做翻译后来供职于外资企业生活还算过的悠闲\">姑姑的品位与学识也深深影响着张爱玲，在张爱玲离开上海时，姑姑正在英商洋行做事，后来听了别人建议投资股票失败又遇时局动荡，辞职到电台工作了一段时间后，又去了大光明戏院做翻译，后来供职于外资企业，生活还算过的悠闲。</h3><p>在大学里张爱玲仍然需要一边读书一边赚取生活费，写稿的紧张节奏令张爱玲逐渐吃不消，于是她决定退学而正是走上写作的道路。</p><h3 id=\"在专注创作后不久张爱玲体会到了中文小说的谋篇布局畅意抒怀的创作更让她淋漓尽致发挥自己的才华曾向往的林语堂方式的英文写作远不如她书写生活中的市井生活和身边人的人生百态\">在专注创作后不久，张爱玲体会到了中文小说的谋篇布局，畅意抒怀的创作更让她淋漓尽致发挥自己的才华，曾向往的林语堂方式的英文写作，远不如她书写生活中的市井生活，和身边人的人生百态。</h3><h3 id=\"从小读红楼梦长大的张爱玲又在港大将西方作家的作品统统学过将文学精粹炼进自己的文字里形成独树一帜的风格\">从小读《红楼梦》长大的张爱玲，又在港大将西方作家的作品统统学过，将文学精粹炼进自己的文字里，形成独树一帜的风格。</h3><p>张爱玲感情生活中，最著名也是最有争议的一段感情就是与“国民汉奸”胡兰成。</p><p>胡兰成从桂系军阀到汪精卫伪政府一直走的是邪魔歪道的路线，但对于涉世不深的张爱玲来说她并没有意识到胡兰成的问题所在。</p><p>汪精卫以重金拉拢胡兰成于羽翼之下，胡兰成成为他们的御用文人，汪精卫伪政府成立后胡兰成上任宣传部部长。</p><p>当时的张爱玲在感情上相当于一张白纸，而胡兰成则早已经历了风风雨雨无论情场还是职场都是老手了，加之胡兰成在文学上有一些造诣让张爱玲很快就沦陷了。</p><p>胡兰成一介寒士爬到如今的位置，那些上流社会的美好始终在他心中梦一般的存在着，不曾想到这一切在张爱玲心里竟不值一提。</p><p>高傲的张爱玲自有她的万丈光芒，无须以自己的家世来衬托，她的不屑与他的渴望形成了鲜明的讽刺。</p><p>但是胡兰成的细腻还是将张爱玲的骄傲清冷融化，令她产生出多年来从而有过的归属感。他与她之间共生出的默契是张爱玲从未感受过的强烈洪流。</p><p>坊间的俗语，流氓不可怕，就怕流氓有文化，来形容胡兰成很是贴切。而常年孤僻生活和写作的幻想空间，使得张爱玲脱离了现实，她常常拿小说里的经验来判断胡兰成对待她的真伪。</p><p>胡兰成在张爱玲结束前就有三位妻子，结婚后又与女同事出轨，在日本战败后逃离中又与好友家中的寡妇联结，最后张爱玲忍无可忍分手道别。</p><p>可惜已经太晚，张爱玲已经背负了汉奸之妻的身份，出门也要伪装自己以免被人认出。</p><h3 id=\"母亲回国后看到张爱玲的样子认为她沉浸在小城市里裹足不前应该去往更远的地方看看世界提高眼界\">母亲回国后看到张爱玲的样子，认为她沉浸在小城市里裹足不前，应该去往更远的地方看看世界，提高眼界。</h3><h3 id=\"此时母亲自身的能力非常出色在国外做尼赫鲁两姐妹的社交秘书因此对于沉浸在小情小调文字中的张爱玲不屑一顾甚至有几分怒其不争的愤慨\">此时母亲自身的能力非常出色，在国外做尼赫鲁两姐妹的社交秘书，因此对于沉浸在小情小调文字中的张爱玲不屑一顾，甚至有几分怒其不争的愤慨。</h3><p>那个年轻风情文雅的母亲早已消失不见，站在眼前的是一个强势又自我的老太婆。</p><p>张爱玲太过了解母亲黄逸梵，从小与父母有隔阂的张爱玲羞于喊出“妈妈”这般亲昵的字眼，母亲当年给她心理造成的阴影，让她一直以“婶婶”相称。</p><h3 id=\"同时在母亲回来看女儿的时刻张爱玲提出了要用二两金子还清母女之情母亲得知女儿的意思后潸然泪下后婉拒了女儿又踏上了出国的旅程\">同时在母亲回来看女儿的时刻，张爱玲提出了要用二两金子还清母女之情，母亲得知女儿的意思后潸然泪下后婉拒了女儿，又踏上了出国的旅程。</h3><h3 id=\"张爱玲一生未育当然也无法体会母亲年轻时候所承受的一切而只是执拗地刺激着给了她生命的母亲\">张爱玲一生未育，当然也无法体会母亲年轻时候所承受的一切，而只是执拗地刺激着给了她生命的母亲。</h3><h3 id=\"其实母女两人都是极端自我的女子不同的是黄逸梵不仅学历高交际手腕也高明还有非常远大的追求张爱玲则大学没有上完因此没有大学毕业证更不擅长为人处世\">其实母女两人都是极端自我的女子，不同的是，黄逸梵不仅学历高，交际手腕也高明，还有非常远大的追求；张爱玲则大学没有上完因此没有大学毕业证，更不擅长为人处世。</h3><p>与胡兰成离婚后，张爱玲用剧本拍了几部电影非常火热，还与导演桑弧热恋，桑弧是个非常擅长人情世故的人，这是因为在电影行业里必定要学会处世才能混得风生水起。</p><h3 id=\"但谈到结婚生子时张爱玲是抗拒的她往前看似乎能看到未来的路上有一个身影重叠着自己年少时的孤独和恐惧她不想重蹈母亲的覆辙她恨母亲的自私但同时她也是与母亲一样的女人没有能力去爱护幼小的生命\">但谈到结婚生子时，张爱玲是抗拒的，她往前看似乎能看到未来的路上有一个身影，重叠着自己年少时的孤独和恐惧，她不想重蹈母亲的覆辙，她恨母亲的自私，但同时她也是与母亲一样的女人，没有能力去爱护幼小的生命。</h3><p>与导演桑弧分手后张爱玲回到了香港大学，继续漂泊继续流浪，漂泊对她与母亲来说似乎已经成为了一种信仰。</p><h3 id=\"在香港她认识了邝文美邝文美相貌不仅秀丽端庄又是个学识有见地的才女她的温柔像一条薄厚相宜的毯子柔软的话语覆盖过来让张爱玲四肢百骸都放松下来像遇见多年未见的幼年伙伴怎么说话也说不完\">在香港她认识了邝文美，邝文美相貌不仅秀丽端庄，又是个学识、有见地的才女，她的温柔像一条薄厚相宜的毯子，柔软的话语覆盖过来，让张爱玲四肢百骸都放松下来，像遇见多年未见的幼年伙伴怎么说话也说不完。</h3><h3 id=\"在那个人人都想出人头地的时代邝文美始终以家庭为重将家庭和事业经营得有声有色她放弃了荣华富贵的机遇不攀附权贵却愿意和远在异乡的张爱玲结为知己\">在那个人人都想出人头地的时代，邝文美始终以家庭为重，将家庭和事业经营得有声有色。她放弃了荣华富贵的机遇，不攀附权贵，却愿意和远在异乡的张爱玲结为知己。</h3><h3 id=\"邝文美在生活里应付自如的涵养恰到好处地弥补了张爱玲不理俗事的弱点邝文美本就对张爱玲非常欣赏又加之她深谙人性特点在这样的友谊中她不但能理解张爱玲天真的幼稚亦能包容她不明世故的观点\">邝文美在生活里应付自如的涵养，恰到好处地弥补了张爱玲不理俗事的弱点。邝文美本就对张爱玲非常欣赏，又加之她深谙人性特点，在这样的友谊中，她不但能理解张爱玲天真的幼稚，亦能包容她不明世故的观点。</h3><p>1953年美国放开移民政策，张爱玲在麦卡锡的担保下离开了香港去往美国。在那里她邂逅了共度半生的美国作家普德南.赖雅。</p><p>赖雅是位德国移民后裔，在哈弗大学读到文艺硕士毕业后，从事英文教室工作。在艺术方面天赋极高，不仅文学作品优秀，摄影也非常出色。先后担任欧洲战地记者，自由撰稿人，欧洲采访知名作家等，经历非常丰富。</p><p>但此时赖雅已经65岁了，而张爱玲才36岁，她曾坦言：一向对于年纪大一点的人感到亲切，对于和自己年纪差不多的人则有点看不起。</p><p>在美国几年后，收到了母亲病重的来信，而张爱玲只写了封信，寄上100美元的支票安慰母亲，让她好好治病。</p><p>母亲在她心里一直都是个强大的女人，她在追求自由的道路上，是个快乐的女神，怎么会被疾病轻易击垮？多年来在两人之间的隔膜已经深成了跨不过去的沟壑。</p><h3 id=\"张爱玲同时也流掉了与丈夫赖雅的孩子这与张爱玲从小缺乏家庭关爱不无关系\">张爱玲同时也流掉了与丈夫赖雅的孩子，这与张爱玲从小缺乏家庭关爱不无关系。</h3><h3 id=\"母亲黄逸梵手术后不久就离开了人世张爱玲默然承受着这个结果没能满足母亲最后的愿望张爱玲为此大病一场\">母亲黄逸梵手术后不久，就离开了人世，张爱玲默然承受着这个结果，没能满足母亲最后的愿望，张爱玲为此大病一场。</h3><h3 id=\"母亲走了为女儿留下一箱古董黄逸梵在病体难抗的绝境里完全可以卖掉古董来治病一向有见地的她并没有这么做而是留给了女人张爱玲这是母亲对张爱玲最后的眷恋\">母亲走了为女儿留下一箱古董，黄逸梵在病体难抗的绝境里，完全可以卖掉古董来治病，一向有见地的她并没有这么做，而是留给了女人张爱玲，这是母亲对张爱玲最后的眷恋。</h3><p>黄逸梵从张爱玲四岁起就离开了上海前往国外，从此爱上了独自旅行。</p><h3 id=\"她跑到欧洲的学校学绘画又去了马来西亚的华侨学校教书在瑞士的阿尔卑斯山上这个三寸金莲的美丽女子勇敢从山顶往下飞滑在游历过程中所邂逅的情人无不是浪漫多情又绅士的外国男子这让她品尝到了爱情的真谛从家庭角度讲黄逸梵并不是个称职的母亲但却对张爱玲的成长有着很深的影响面对封建旧式家庭的规矩她毅然站出来拒绝女儿缠足还自作主张教导女儿英语钢琴从而也使得张爱玲熏陶到良好的西方文化\">她跑到欧洲的学校学绘画，又去了马来西亚的华侨学校教书，在瑞士的阿尔卑斯山上，这个三寸金莲的美丽女子勇敢从山顶往下飞滑。在游历过程中所邂逅的情人，无不是浪漫多情又绅士的外国男子，这让她品尝到了爱情的真谛。从家庭角度讲，黄逸梵并不是个称职的母亲，但却对张爱玲的成长有着很深的影响，面对封建旧式家庭的规矩，她毅然站出来拒绝女儿缠足，还自作主张教导女儿英语、钢琴，从而也使得张爱玲熏陶到良好的西方文化。</h3><h3 id=\"虽然母女俩不常见面张爱玲在心里将母亲当作偶像张爱玲对事业的追求和我行我素的风格以及爱情上的观念甚至是后来漂泊海外的流浪旅途都与母亲有着惊人的吻合她们是相爱相杀的母女黄逸梵的洒脱是留给张爱玲的华丽背影也是投射在她心灵深处的阴影\">虽然母女俩不常见面，张爱玲在心里将母亲当作偶像，张爱玲对事业的追求和我行我素的风格，以及爱情上的观念，甚至是后来漂泊海外的流浪旅途都与母亲有着惊人的吻合，她们是相爱相杀的母女，黄逸梵的洒脱是留给张爱玲的华丽背影，也是投射在她心灵深处的阴影。</h3><p>1967年赖雅去世，张爱玲心情降到冰点。但天亮了，张爱玲还要将写作进行下去，生命的真相有时候没必要去追根究底，因为宿命的安排或是性格上的原因，也许是一个人最简单的寄托。</p><h3 id=\"张爱玲的弟弟张子静在新中国成立后在上海浦东一所小学任教先后又更换了几所学校于1986年正式退休搬到江苏路的一个14平方米小屋居住这是父亲败光家产后遗留给他的最后遗产\">张爱玲的弟弟张子静在新中国成立后在上海浦东一所小学任教，先后又更换了几所学校，于1986年正式退休搬到江苏路的一个14平方米小屋居住，这是父亲败光家产后遗留给他的最后遗产。</h3><p>1953年父亲张延重肺病去世，继母所依赖房屋被政府回收后的定息也在文革爆发后停止发放。1970年继母双目失明，弟弟给她请了个保姆，1986年离世。</p><p>1983年弟弟联系到张爱玲并劝姐姐回国，但张爱玲拒绝了弟弟的请求，并告诉他能保持书信就好。</p><h3 id=\"到了晚年张爱玲再读红楼梦时在书中读出了整个张氏大家族与贾府相似的命运从而让她对世事产生出悲凉之感\">到了晚年，张爱玲再读《红楼梦》时在书中读出了整个张氏大家族与贾府相似的命运，从而让她对世事产生出悲凉之感。</h3><h3 id=\"她年轻时争名夺利的性情如风过已是了无痕往事已过去多年她对人生有了新的认识不再是浮于表面的浅薄\">她年轻时争名夺利的性情，如风过，已是了无痕。往事已过去多年，她对人生有了新的认识，不再是浮于表面的浅薄。</h3><h3 id=\"虽是个老太太举止言谈间却完全是一个自闭的少女状态但神清里有说不出的柔和恬静遇事的时候也已经能够泰然自若\">虽是个老太太，举止言谈间却完全是一个自闭的少女状态，但神清里有说不出的柔和恬静，遇事的时候也已经能够泰然自若。</h3><p>晚年整理回忆录《对照记》时，选了100多幅她与家人、朋友的照片，母亲、姑姑、闺蜜和她的风华正茂，都定格在光影里。</p><p>其中最为经典的是那张，最具张爱玲风范，她的脸庞轻轻上扬，眼睛望向侧上方，穿着缎子做的高领短袖，如生在世间的一枝兰，高傲贵气又出尘。</p><p>1995年9月8日，张爱玲去世在自己的公寓里，旁边的书桌上是一叠铺开的稿纸和一支未合上的笔。</p><h3 id=\"张爱玲在遗嘱中把所有的遗产都留给了邝文美\">张爱玲在遗嘱中把所有的遗产都留给了邝文美。</h3><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484831&amp;idx=1&amp;sn=844da82b7868b494c0d71c1713a813f5&amp;chksm=fc226098cb55e98e222bcbeff2646b4fed2bbc6eb2416090a75aece54d9064258674990ccfc0&amp;token=1401123908&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/07/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B036",
            
            
            
            
            
            "date_published": "2021-07-17T00:00:00+08:00",
            "date_modified": "2021-07-17T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/07/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B035",
            "title": "读书笔记(三十五) 《如何高效阅读 - 下》",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：与前两本《如何阅读》、《如何阅读一本书》相比《如何有效阅读一本书》这本书更加注重阅读实用技巧，从选书、读书、笔记、重读四个方面详细讲解了作者自己在实践过程中的经验。正文：全书11万字分为五个部分，选书、读书、笔记、重读、实用技巧。如何选书？书有很多种，好坏也是天差地别，坏书不仅会浪费我们很多时间，还会灌输我们错误的观念。因此如何选书，如何选好书就成提高读书效率的关键。作者提到选书最重要的是主动选择而不是被动选择，主动去做筛选会比被动的选择遇到好书的概率要大的多。有这四个途径可以提高选到好书的概率：  生活中大众认可的经典书籍  自己看过的好书中提到的书  告知人书评中提到的好书  知识品位高的朋友提到的好书选书的过程中，我们依然要保持警惕，时时刻刻主动选择而不是被动被推荐无脑接受。有时候看到好书不一定要买，其实各领域的好书有很多，如果不是你当下需要的书，即使是好书买来也没有用，堆积在那里会成为你的心里负担。我们应该尽量做到，当真正需要的时候才购买，买回来尽量立即看起来，而不是认为是好书就买了堆积在那里给自己造成心里负担，其实买了没看也会给自己造成挫败感。作者说除了选好书，我们也需要一些能与自己长期共处的书，当失落时、走投无路时，那本书会成为我们的心灵支柱。如何读书？提高读书效率的一个重要指标就是养成好习惯，这个习惯包括：坚持每日读书的习惯，坚持做读书笔记的习惯，坚持重读巩固复习的习惯。其中做笔记的方法和技巧，以及重读的技巧特别重要，这两个话题在下面的内容中会详细介绍。前面说要读好书，但其实现实中坚持“只选好书，只读好书”可能不太现实，我们可以张弛有度地贯彻“好书要细细研读，其他书则粗读略读”原则，这样会让读书效率更高。其次在读书过程中，积极的“跳读”和“略读”，并在比较难理解的部分换上低速齿轮认真品读，保持读书张弛有度的节奏，可以把更多精力集中在好书的精华内容上，这样读书效率会更高。最后读书的目的是用自己的方式去学习，而不是模仿别人的方法。因此在读书学习过程中，用自己的方法吸收学到的知识才是最重要的，再根据书中提到的技巧加以改进，这样的学习效率会更高。我们可以看到整个读书流程为：  主动选择好书  只购买真正要看的书  读书并记录  读后总结与评价  复习与巩固为什么要做笔记？我们要学的东西实在太多，而我们的人脑记忆力又非常有限，无法在同一时间记住太多的知识和信息。学了忘，忘了学，如此往复效率太差。笔记就给予了我们快速恢复记忆的途径，它不但可以帮助我们快速恢复记忆，还可以帮助我们加深记忆，让知识记忆的保存时间更长一些。我们在做笔记时就相当于在做归纳和重读，特别是当我们要把笔记写成文章发表出去时，我们会不自觉的更加仔细、小心并且反复琢磨知识要点。即使不发表读书文章，你也会发现，在读完一本书后其实记不住多少内容，只有对书中内容做出反应，进行主动思考，才能真正掌握这本书的内容。读书笔记就是这种帮助我们升华的工具，可以让读书活动完成从生搬硬套到独创思维的飞跃。其实日常生活中说的所谓“理解精髓”就够了只是个美好的愿望，你不把整个知识理顺了并记录下来，即使长期读书的人也会在很长时间后把看过的书忘得一干二净。如果只是这样读过，就等于没有读过。如果只是用眼睛看过，而没有记在脑子里，读再多的书也都会忘记。读完每本书如果都能有扎实的收获，那么每个月读多少本书，一本书花几小时读完的能力，在这个目标面前都是苍白无力的。认真选择每一本满足自己需求的书，然后真挚地与每一本书对话，努力从书中学到知识，这才是明智的做法。当达到这样读书后扎实收获的目标后，再去训练更快的读书速度其实也为时不晚。当你以思想输出为前提去读书时，思想输入的质量也会提升，亲手写文章的好处比你想象的大很多。当你一遍遍思考如何写文章时，不由自主的就多读了几遍书，尤其是对没有读懂的部分，在不断思考和不断重读过程中，你对书本知识的理解也进入到了更深层次的境界。如果你以输出为目的去读书，那么读书的质量和效率会很高。如果读书的目标是写读书笔记，那么读书效率会比随便读一读要高出很多，如果你以发表自己的理解和总结性文章为目标，那么你的读书效率会更高，如果你以输出讲座为目标，那么你的读书效率会特别高。道理很简单因为当我们知道自己要在别人面前表达自己的想法后，我们才会去调查那些我们从未在意过的出处、资料，重新审视自己的观点，建立起系统的知识体系。这时你会发现，这个补充学习的过程就像从零学起一样，需要费不少功夫。而能够正视这些辛苦工作的人，最后都不再对知识一知半解了。因此掌握再多信息，如果不去积极输出，也无法形成知识体系。如何做笔记？有时你可能感觉到没什么可写的，但只要你拿起笔来随便写两句，说不定就有惊喜等着你。读书笔记三步骤：  读书  划重点  写读后总结读书阶段，要在书上做一些简单的记号，为写读书笔记做准备。这里作者介绍了自己的读书方法：第一遍通读时，把有价值的页折起来，第二遍重读时只读折起来的部分，并且认为重要的划线或标记，第三遍再重读时只读划线和标记部分，认为精华的部分摘抄到笔记里。最后把摘抄的精华加上自己的理解把它们写成文章。作者自己发明了葱郁火锅笔记法，它有两部分组成：  摘抄下重要语句  下方写上自己的感受即重要的内容摘抄下来，下面写下自己的感想和评论。（摘抄和评论交替进行，趁着自己印象还鲜明写下自己的感想）作者认为，自己当下的想法才是最重要的，摘抄这一段文章的原因和自己当时的想法才是日后值得参考的贵重资料。如何重读与巩固？读完一本书后的时间越长，在读书时产生的环境变化就会越模糊，你就越能冷静地看待书中的观点。因此不要在意一本书读完已经搁置了多久，再次重读时会有别样的风味。重读笔记的时间点：睡觉前、洗完澡后、晚饭后、思绪进入死胡同时，可以是碎片时间也最好是安静的环境。重读习惯养成：  量化重读频率，每周一次或者三天一次。  多种重读方式交替进行  重读后写复习总结并发布到博客上多种重读方式：  想要简单回顾时，重读读书笔记  想回忆起更多时，参考书中的重点段落  想从头开始看起时，重读原书每一次的复习总结都是对自己知识的再回顾和再理解，把这些复习总结放到博客上同样可以作为思想输出的一部分，而且每次复习总结后都会让自己对这部分知识理解的更加透彻，记忆也更加久远。吸收知识的重要手段主题阅读同一个主题的选出三本以上的书同时阅读或者依次阅读，读完记录要点，做笔记，再把三本笔记合起来写一篇文章，这篇文章就相当于是让三个专家围绕某个问题给自己提意见，让他们进行讨论而我则思考并听取意见。经过整理和总结后，渐渐的得出一些自己的结论，这些结论是由三个专家共同讨论得出的，这样的结论比较客观且符合当下的情况。让读书百遍更轻松的方法就是阅读读书笔记，通过读书笔记缩短复习时间、提高记忆恢复速度，以笔记内容为线索回忆整个读书过程，达到快速恢复记忆的目的。读书实用技巧作者列举了20条读书实用技巧，这里我筛选了一部分因为有些确实没什么用处，也是结合我实际阅读学习过程中的经验：  读书过程中多用参考书，地图、图鉴、统计数据、百科全书、年表、词典等帮助自己加深理解书中内容。  随机阅读，偶尔阅读一些自己从来没有接触过领域的书籍，打破你的常规思维，有时候这种方式会给你一种豁然开朗的感觉。  由浅入深的吃透难懂的书，太难的书会让我们有强烈的挫败感，不如先从入门版、图解版、漫画版、精编版开始阅读，逐步熟悉、理解、渗透，最后再去阅读原著能收获更多的成就感和自信。  把书份分类堆放，未阅读的、阅读过的、已经做过笔记的、已经写好总结文章，并且分类摆放，这样会给自己一个方向，随着时间推移读完的和做完笔记的书堆放的会越来越多，会有更多的成就感，也激励自己阅读更多的书。  把经典名著放在枕头边，这些书比较难度，我们可以睡觉前看两页慢慢读，反复读几年也非常好，因为这些书是经得起考验的，读的次数阅读读的时间越久，我们从中吸取的知识就越多。  同时阅读几本书，为了减少自己在读书时的枯燥感，三本书的领域应该是不一样的，当我们觉得一本书读的很痛苦时就可以换另外一本读，从而增加愉悦感保持心灵舒畅。  在办公桌和家里的每个角落都放满书，给自己一个身边满是书的氛围，同时当我们想看书的时候就可以随时抓到一本，不给自己找更多没有书看的理由。  去掉外封面让读书变得轻松，有多书的外封面有自己的宣传设计，这些外封面在读书的时候很不舒服，不如去掉它们给自己一个轻松的书。  用边撕边读的方式阅读杂志，并不一定要从头到尾顺序读，读完的就撕下来扔进垃圾桶。  偶尔的音频、视频读书也是一种读书的一种方式，当读书累的时候可以换一下轻松的方式阅读，特别读不熟悉的领域时这种轻松的方式可能会让我们更加容易的跨过这道门槛。  买一支你喜欢的钢笔，读书笔记时一直用它，这会带动我们写文章的热情，会有总想用这支笔写点什么感觉，同时调节钢笔出水、吸墨、擦拭等也能激发我们的写作热情。  把自己信奉的名言贴在显眼的位置，让自己更有长远的目标和行动指南。  从摘抄开始写作，写文章时时常会遇到瓶颈，我们可以尝试先把喜欢的文章抄写下来，抄写的同时自己想写的东西会从脑中涌现出来。  写好的文章打印出来，这样更方便我们随手翻阅，也更容易帮助我们重组知识创建出新的点子。  记录读书的时间过程，在书的首页上，记下自己的名字、购买日期、阅读结束日期、标记结束日期、完成读书标记日期，不但让自己的读书过程更清晰，也让这本书完完全全归属了我们。  经常整理书籍摆放归类，经常整理自己的读书笔记，会让自己在读书习惯，以及复习巩固时有更好的提升。已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484825&amp;idx=1&amp;sn=72548c4cb8aaf9961b3ea77cc0905ba6&amp;chksm=fc22609ecb55e988c328a3a7b71c9614dd6e5d4b0df369ffd8d5275603ab7afd3ec9e01b036a&amp;token=1401123908&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h1 id=\"背景\">背景：</h1><p>与前两本《如何阅读》、《如何阅读一本书》相比《如何有效阅读一本书》这本书更加注重阅读实用技巧，从选书、读书、笔记、重读四个方面详细讲解了作者自己在实践过程中的经验。</p><h1 id=\"正文\">正文：</h1><p>全书11万字分为五个部分，选书、读书、笔记、重读、实用技巧。</p><h1 id=\"如何选书\">如何选书？</h1><h3 id=\"书有很多种好坏也是天差地别坏书不仅会浪费我们很多时间还会灌输我们错误的观念因此如何选书如何选好书就成提高读书效率的关键\">书有很多种，好坏也是天差地别，坏书不仅会浪费我们很多时间，还会灌输我们错误的观念。因此如何选书，如何选好书就成提高读书效率的关键。</h3><p>作者提到选书最重要的是主动选择而不是被动选择，主动去做筛选会比被动的选择遇到好书的概率要大的多。</p><p>有这四个途径可以提高选到好书的概率：</p><ol>  <li>生活中大众认可的经典书籍</li>  <li>自己看过的好书中提到的书</li>  <li>告知人书评中提到的好书</li>  <li>知识品位高的朋友提到的好书</li></ol><p>选书的过程中，我们依然要保持警惕，时时刻刻主动选择而不是被动被推荐无脑接受。</p><p>有时候看到好书不一定要买，其实各领域的好书有很多，如果不是你当下需要的书，即使是好书买来也没有用，堆积在那里会成为你的心里负担。</p><h3 id=\"我们应该尽量做到当真正需要的时候才购买买回来尽量立即看起来而不是认为是好书就买了堆积在那里给自己造成心里负担其实买了没看也会给自己造成挫败感\">我们应该尽量做到，当真正需要的时候才购买，买回来尽量立即看起来，而不是认为是好书就买了堆积在那里给自己造成心里负担，其实买了没看也会给自己造成挫败感。</h3><p>作者说除了选好书，我们也需要一些能与自己长期共处的书，当失落时、走投无路时，那本书会成为我们的心灵支柱。</p><h1 id=\"如何读书\">如何读书？</h1><p>提高读书效率的一个重要指标就是养成好习惯，这个习惯包括：坚持每日读书的习惯，坚持做读书笔记的习惯，坚持重读巩固复习的习惯。</p><p>其中做笔记的方法和技巧，以及重读的技巧特别重要，这两个话题在下面的内容中会详细介绍。</p><h3 id=\"前面说要读好书但其实现实中坚持只选好书只读好书可能不太现实我们可以张弛有度地贯彻好书要细细研读其他书则粗读略读原则这样会让读书效率更高\">前面说要读好书，但其实现实中坚持“只选好书，只读好书”可能不太现实，我们可以张弛有度地贯彻“好书要细细研读，其他书则粗读略读”原则，这样会让读书效率更高。</h3><h3 id=\"其次在读书过程中积极的跳读和略读并在比较难理解的部分换上低速齿轮认真品读保持读书张弛有度的节奏可以把更多精力集中在好书的精华内容上这样读书效率会更高\">其次在读书过程中，积极的“跳读”和“略读”，并在比较难理解的部分换上低速齿轮认真品读，保持读书张弛有度的节奏，可以把更多精力集中在好书的精华内容上，这样读书效率会更高。</h3><h3 id=\"最后读书的目的是用自己的方式去学习而不是模仿别人的方法因此在读书学习过程中用自己的方法吸收学到的知识才是最重要的再根据书中提到的技巧加以改进这样的学习效率会更高\">最后读书的目的是用自己的方式去学习，而不是模仿别人的方法。因此在读书学习过程中，用自己的方法吸收学到的知识才是最重要的，再根据书中提到的技巧加以改进，这样的学习效率会更高。</h3><p>我们可以看到整个读书流程为：</p><ol>  <li>主动选择好书</li>  <li>只购买真正要看的书</li>  <li>读书并记录</li>  <li>读后总结与评价</li>  <li>复习与巩固</li></ol><h1 id=\"为什么要做笔记\">为什么要做笔记？</h1><p>我们要学的东西实在太多，而我们的人脑记忆力又非常有限，无法在同一时间记住太多的知识和信息。</p><h3 id=\"学了忘忘了学如此往复效率太差笔记就给予了我们快速恢复记忆的途径它不但可以帮助我们快速恢复记忆还可以帮助我们加深记忆让知识记忆的保存时间更长一些\">学了忘，忘了学，如此往复效率太差。笔记就给予了我们快速恢复记忆的途径，它不但可以帮助我们快速恢复记忆，还可以帮助我们加深记忆，让知识记忆的保存时间更长一些。</h3><p>我们在做笔记时就相当于在做归纳和重读，特别是当我们要把笔记写成文章发表出去时，我们会不自觉的更加仔细、小心并且反复琢磨知识要点。</p><p>即使不发表读书文章，你也会发现，在读完一本书后其实记不住多少内容，只有对书中内容做出反应，进行主动思考，才能真正掌握这本书的内容。</p><p>读书笔记就是这种帮助我们升华的工具，可以让读书活动完成从生搬硬套到独创思维的飞跃。</p><p>其实日常生活中说的所谓“理解精髓”就够了只是个美好的愿望，你不把整个知识理顺了并记录下来，即使长期读书的人也会在很长时间后把看过的书忘得一干二净。</p><h3 id=\"如果只是这样读过就等于没有读过如果只是用眼睛看过而没有记在脑子里读再多的书也都会忘记\">如果只是这样读过，就等于没有读过。如果只是用眼睛看过，而没有记在脑子里，读再多的书也都会忘记。</h3><h3 id=\"读完每本书如果都能有扎实的收获那么每个月读多少本书一本书花几小时读完的能力在这个目标面前都是苍白无力的\">读完每本书如果都能有扎实的收获，那么每个月读多少本书，一本书花几小时读完的能力，在这个目标面前都是苍白无力的。</h3><h3 id=\"认真选择每一本满足自己需求的书然后真挚地与每一本书对话努力从书中学到知识这才是明智的做法\">认真选择每一本满足自己需求的书，然后真挚地与每一本书对话，努力从书中学到知识，这才是明智的做法。</h3><p>当达到这样读书后扎实收获的目标后，再去训练更快的读书速度其实也为时不晚。</p><p>当你以思想输出为前提去读书时，思想输入的质量也会提升，亲手写文章的好处比你想象的大很多。</p><p>当你一遍遍思考如何写文章时，不由自主的就多读了几遍书，尤其是对没有读懂的部分，在不断思考和不断重读过程中，你对书本知识的理解也进入到了更深层次的境界。</p><p>如果你以输出为目的去读书，那么读书的质量和效率会很高。</p><h3 id=\"如果读书的目标是写读书笔记那么读书效率会比随便读一读要高出很多如果你以发表自己的理解和总结性文章为目标那么你的读书效率会更高如果你以输出讲座为目标那么你的读书效率会特别高\">如果读书的目标是写读书笔记，那么读书效率会比随便读一读要高出很多，如果你以发表自己的理解和总结性文章为目标，那么你的读书效率会更高，如果你以输出讲座为目标，那么你的读书效率会特别高。</h3><h3 id=\"道理很简单因为当我们知道自己要在别人面前表达自己的想法后我们才会去调查那些我们从未在意过的出处资料重新审视自己的观点建立起系统的知识体系这时你会发现这个补充学习的过程就像从零学起一样需要费不少功夫而能够正视这些辛苦工作的人最后都不再对知识一知半解了\">道理很简单因为当我们知道自己要在别人面前表达自己的想法后，我们才会去调查那些我们从未在意过的出处、资料，重新审视自己的观点，建立起系统的知识体系。这时你会发现，这个补充学习的过程就像从零学起一样，需要费不少功夫。而能够正视这些辛苦工作的人，最后都不再对知识一知半解了。</h3><h3 id=\"因此掌握再多信息如果不去积极输出也无法形成知识体系\">因此掌握再多信息，如果不去积极输出，也无法形成知识体系。</h3><h1 id=\"如何做笔记\">如何做笔记？</h1><p>有时你可能感觉到没什么可写的，但只要你拿起笔来随便写两句，说不定就有惊喜等着你。</p><p>读书笔记三步骤：</p><ol>  <li>读书</li>  <li>划重点</li>  <li>写读后总结</li></ol><p>读书阶段，要在书上做一些简单的记号，为写读书笔记做准备。</p><p>这里作者介绍了自己的读书方法：</p><p>第一遍通读时，把有价值的页折起来，</p><p>第二遍重读时只读折起来的部分，并且认为重要的划线或标记，</p><p>第三遍再重读时只读划线和标记部分，认为精华的部分摘抄到笔记里。</p><p>最后把摘抄的精华加上自己的理解把它们写成文章。</p><p>作者自己发明了葱郁火锅笔记法，它有两部分组成：</p><ol>  <li>摘抄下重要语句</li>  <li>下方写上自己的感受</li></ol><p>即重要的内容摘抄下来，下面写下自己的感想和评论。（摘抄和评论交替进行，趁着自己印象还鲜明写下自己的感想）</p><p>作者认为，自己当下的想法才是最重要的，摘抄这一段文章的原因和自己当时的想法才是日后值得参考的贵重资料。</p><h1 id=\"如何重读与巩固\">如何重读与巩固？</h1><p>读完一本书后的时间越长，在读书时产生的环境变化就会越模糊，你就越能冷静地看待书中的观点。</p><p>因此不要在意一本书读完已经搁置了多久，再次重读时会有别样的风味。</p><p>重读笔记的时间点：睡觉前、洗完澡后、晚饭后、思绪进入死胡同时，可以是碎片时间也最好是安静的环境。</p><p>重读习惯养成：</p><ol>  <li>量化重读频率，每周一次或者三天一次。</li>  <li>多种重读方式交替进行</li>  <li>重读后写复习总结并发布到博客上</li></ol><p>多种重读方式：</p><ol>  <li>想要简单回顾时，重读读书笔记</li>  <li>想回忆起更多时，参考书中的重点段落</li>  <li>想从头开始看起时，重读原书</li></ol><h3 id=\"每一次的复习总结都是对自己知识的再回顾和再理解把这些复习总结放到博客上同样可以作为思想输出的一部分而且每次复习总结后都会让自己对这部分知识理解的更加透彻记忆也更加久远\">每一次的复习总结都是对自己知识的再回顾和再理解，把这些复习总结放到博客上同样可以作为思想输出的一部分，而且每次复习总结后都会让自己对这部分知识理解的更加透彻，记忆也更加久远。</h3><h1 id=\"吸收知识的重要手段主题阅读\">吸收知识的重要手段主题阅读</h1><h3 id=\"同一个主题的选出三本以上的书同时阅读或者依次阅读读完记录要点做笔记再把三本笔记合起来写一篇文章这篇文章就相当于是让三个专家围绕某个问题给自己提意见让他们进行讨论而我则思考并听取意见\">同一个主题的选出三本以上的书同时阅读或者依次阅读，读完记录要点，做笔记，再把三本笔记合起来写一篇文章，这篇文章就相当于是让三个专家围绕某个问题给自己提意见，让他们进行讨论而我则思考并听取意见。</h3><p>经过整理和总结后，渐渐的得出一些自己的结论，这些结论是由三个专家共同讨论得出的，这样的结论比较客观且符合当下的情况。</p><h3 id=\"让读书百遍更轻松的方法就是阅读读书笔记通过读书笔记缩短复习时间提高记忆恢复速度以笔记内容为线索回忆整个读书过程达到快速恢复记忆的目的\">让读书百遍更轻松的方法就是阅读读书笔记，通过读书笔记缩短复习时间、提高记忆恢复速度，以笔记内容为线索回忆整个读书过程，达到快速恢复记忆的目的。</h3><h1 id=\"读书实用技巧\">读书实用技巧</h1><p>作者列举了20条读书实用技巧，这里我筛选了一部分因为有些确实没什么用处，也是结合我实际阅读学习过程中的经验：</p><ol>  <li>读书过程中多用参考书，地图、图鉴、统计数据、百科全书、年表、词典等帮助自己加深理解书中内容。</li>  <li>随机阅读，偶尔阅读一些自己从来没有接触过领域的书籍，打破你的常规思维，有时候这种方式会给你一种豁然开朗的感觉。</li>  <li>由浅入深的吃透难懂的书，太难的书会让我们有强烈的挫败感，不如先从入门版、图解版、漫画版、精编版开始阅读，逐步熟悉、理解、渗透，最后再去阅读原著能收获更多的成就感和自信。</li>  <li>把书份分类堆放，未阅读的、阅读过的、已经做过笔记的、已经写好总结文章，并且分类摆放，这样会给自己一个方向，随着时间推移读完的和做完笔记的书堆放的会越来越多，会有更多的成就感，也激励自己阅读更多的书。</li>  <li>把经典名著放在枕头边，这些书比较难度，我们可以睡觉前看两页慢慢读，反复读几年也非常好，因为这些书是经得起考验的，读的次数阅读读的时间越久，我们从中吸取的知识就越多。</li>  <li>同时阅读几本书，为了减少自己在读书时的枯燥感，三本书的领域应该是不一样的，当我们觉得一本书读的很痛苦时就可以换另外一本读，从而增加愉悦感保持心灵舒畅。</li>  <li>在办公桌和家里的每个角落都放满书，给自己一个身边满是书的氛围，同时当我们想看书的时候就可以随时抓到一本，不给自己找更多没有书看的理由。</li>  <li>去掉外封面让读书变得轻松，有多书的外封面有自己的宣传设计，这些外封面在读书的时候很不舒服，不如去掉它们给自己一个轻松的书。</li>  <li>用边撕边读的方式阅读杂志，并不一定要从头到尾顺序读，读完的就撕下来扔进垃圾桶。</li>  <li>偶尔的音频、视频读书也是一种读书的一种方式，当读书累的时候可以换一下轻松的方式阅读，特别读不熟悉的领域时这种轻松的方式可能会让我们更加容易的跨过这道门槛。</li>  <li>买一支你喜欢的钢笔，读书笔记时一直用它，这会带动我们写文章的热情，会有总想用这支笔写点什么感觉，同时调节钢笔出水、吸墨、擦拭等也能激发我们的写作热情。</li>  <li>把自己信奉的名言贴在显眼的位置，让自己更有长远的目标和行动指南。</li>  <li>从摘抄开始写作，写文章时时常会遇到瓶颈，我们可以尝试先把喜欢的文章抄写下来，抄写的同时自己想写的东西会从脑中涌现出来。</li>  <li>写好的文章打印出来，这样更方便我们随手翻阅，也更容易帮助我们重组知识创建出新的点子。</li>  <li>记录读书的时间过程，在书的首页上，记下自己的名字、购买日期、阅读结束日期、标记结束日期、完成读书标记日期，不但让自己的读书过程更清晰，也让这本书完完全全归属了我们。</li>  <li>经常整理书籍摆放归类，经常整理自己的读书笔记，会让自己在读书习惯，以及复习巩固时有更好的提升。</li></ol><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484825&amp;idx=1&amp;sn=72548c4cb8aaf9961b3ea77cc0905ba6&amp;chksm=fc22609ecb55e988c328a3a7b71c9614dd6e5d4b0df369ffd8d5275603ab7afd3ec9e01b036a&amp;token=1401123908&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/07/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B035",
            
            
            
            
            
            "date_published": "2021-07-12T00:00:00+08:00",
            "date_modified": "2021-07-12T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/07/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B034",
            "title": "读书笔记(三十四) 《C++ Primer》#6",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意。第三是当我们在巩固时创造出了新的知识，那么这些新的知识和旧的知识将同时变成智慧融合到身体中。本系列基于《C++ Primer》学习，由于重点放在“重学”，我略过了滚瓜烂熟的部分，挑出以前常忽略的部分，以及记忆没有那么深刻的部分，特别是那些重要的但没有上心的部分。正文：本文是全书总结的最后部分，在总结的同时我又重读了一遍整本书，对各个知识点的理解又加深了许多，希望这些回顾对各位都有所帮助。模版编程模版有两种，一种是类型模版参数，另一种是非类型模版参数。两种类型模版都是由编译器生成的代码，当两个不同的数据类型使用同一个模版时，会在模版实例化时生成的两份不同的代码。例如：template&lt;typename T&gt;T compare(const T v1, const T v2){    return v1 - v2;}count &lt;&lt; compare(1, 0) &lt;&lt; endl; // 编译器会生成 int compare(const int , const int)count &lt;&lt; compare(1.3F, 2.3F) &lt;&lt;endl; // 编译器会生成 int compare(const float, const float)编译器发现有两种数据类型分别调用了模版函数compare，此时编译器会生成两个版本的compare，应用在Class模版也是同样的道理。另一种是非类型模版，意思是参数为指定常量，例如：template&lt;unsigned N, unsigned M&gt;int compare(const char (&amp;p1)[N], const char (&amp;p2)[M]){    return strcmp(p1, p2);}compare(\"hi\",\"mon\"); // 编译器会生成 int compare(const char (&amp;p1)[3], const char (&amp;p2)[4]);compare(\"hello\", \"world\"); // 编译器会生成 int compare(const char(&amp;p1)[6], const char (&amp;p2)[6]);非类型参数是一个常量，而且必须是常量或者常量表达式，编译器会根据不同的常量生成不同类型的代码，应用在Class模版上也是同样的道理。编译器生成模版代码，当且仅当编译器检测到模版被使用时才发生，即如果一个成员函数没有被使用，则它不会被编译器实例化。另外编译器生成模版代码会分三个阶段，第一个阶段是检查语法，第二个阶段是检查模版调用的参数匹配，第三个阶段才是模版实例化，因此链接时发生错误在模版编程时是常有的事。在新标准中C++可以通过显示实例化来明确指定某个类或函数实例化。例如：extern template declaration; // 显式实例化申明template declaration; // 显式实例化定义当编译器遇到extern模版显式实例化声明时，表明程序会在其他地方有该程序的实例化。和普通模版实例化不同的是，如果一个类定义了模版显式实例化，则该模版的所有成员包括内联成员函数都会被实例化。此外在调用中如果有需要，我们也可以显式指定模版参数类型。例如：template&lt;tyepname T1, typename T2, typename T3&gt;T1 sum(T2, T3);long long var1 = sum(11,22L); // 编译错误long long var2 = sum&lt;long long&gt;(22, 33L); // 显式指定返回值为long longlong long var3 = sum&lt;long long, int, float&gt;(23, 34F); // 显式指定返回值和参数分别为 long long, int, float上述示例告诉我们，如果返回值使用了模版类型，则最好通过显式指定的方式来指定形参类型。理解右值引用、std::move和std::forward可以简单理解为，一个&amp;为左值引用，两个&amp;为右值引用，右值引用有些特殊，它转为转移数据而存在，即当右值引用赋值后，原值的内存数据将失效。通过右值引用可以做到数据转移的功能，例如：void f(int v1, int &amp;v2){    count &lt;&lt; v1 &lt;&lt; \" \" &lt;&lt; ++v2 &lt;&lt; endl;}template&lt;typename F, typename T1, typename T2&gt;void flip1(F f, T1 t1, T2 t2){    f(t2, t1);}template&lt;typename F, typename T1, typename T2&gt;void flip2(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2){    f(t2, t1);}int i = 0;f(42, i); // i变量被改变flip1(f, i, 42); // i变量没有被改变flip2(f, i, 42); // i变量被改变上述中filp1与flip2的差别是，filp2使用了右值引用，将实参转移到了形参上，进而在f中可以改变i本身的变量。模版可以接受右值引用参数，std::move的定义就是模版右值引用定义：template&lt;typename T&gt;typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; t){    return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);}move函数参数T&amp;&amp;是一个指向模版类型的右值引用。通过引用折叠，参数可以与任何类型的实参匹配。string s1(\"hi\"), s2;s2 = std::move(string(\"bye\")); // 实例化为 string&amp;&amp; move(string &amp;&amp;t)s2 = std::move(s1); // 实例化为 string&amp;&amp; move(string &amp;t)其实这两个模版实例化成了不同的函数，根本原因是右值引用可折叠，导致的结果是：  如果一个函数参数是一个指向模版类型参数的右值引用（如，T&amp;&amp;）则它可以被绑定到一个左值。  如果实参是一个左值，则推断出的模版实参类型将是一个左值引用，且函数参数将被实例化为一个（普通）左值引用参数（T&amp;）。标准库中std::forward可以帮助我们返回实参类型的右值引用，即std::forward的返回类型是T&amp;&amp;。例如：template&lt;type F, typename T1, typename T2&gt;void flip(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2){    f(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));}模版重载函数与可变参数模版模版重载函数在匹配规则上有些小规则，当有多个重载模版对一个调用提供同样好的匹配时，应选择最特例化的版本。对于一个调用，如果一个非函数模版与一个函数模版提供同样好的匹配，则选择非模版版本。可变参数模版中，编译器会根据识别到的函数参数类型生成多个不同类型形参的函数。可变参数模版可以与sizeof…运算符一起使用，sizeof…运算符也是通过预编译生成的模版函数，返回的是类型数目或者参数数目。例如：template&lt;typename T, typename... Args&gt;ostream &amp;print(ostream &amp;os, const T &amp;t, const Args&amp;... rest){    os &lt;&lt; t &lt;&lt; \",\";    return print(os, rest...); // 预编译会将函数展开成类似print(os, i, s, 42)}string debug_rep(char *p){    return string(p);}template&lt;typename... Args&gt;ostream &amp;errorMsg(ostream &amp;os, const Args&amp;... rest){    return print(os, debug_rep(rest)...); // 预编译会将函数展开成类似print(os, debug_rep(i), debug_rep(s), debug_rep(42));}编译器会在预编译时对可变参数展开，因此上述函数在调用展开后类似于 print(os, i, s, 42) 和 print(os, debug_rep(i), debug_rep(s), debug_rep(42))。模版特例化有时候我们不希望使用模版但又想跟模版的使用方式一样，此时就可以用一个特例化模版来独立定义模版中的一个或者多个参数指定为特定类型。template&lt;typename T, typename U&gt; int compare(const T&amp;, const U&amp;);  // 原模版template&lt;&gt; int compare(const char* const &amp;p1, const char* const &amp;p2); // 全特例化template&lt;typename T&gt; int compare(const T&amp;, const char* const &amp;p2); // 部分特例化int compare(const int const &amp;var1, const int const &amp;var2);   //  普通函数compare(3F,5F); // 调用源模版compare(\"HI\", \"HELLO\"); // 调用全特例化compare(3F,\"HELLO\"); // 调用部分特例化compare(3,5); // 调用普通函数当定义函数模版的特例化版本时，我们本质上接管了编译器的工作。即我们为原模版的一个特殊实例提供了定义。重要的是要弄清楚：一个特例化版本本质上是一个实例，而非函数名的一个重载版本，因此特例化不影响函数匹配。注意，当一个非模版函数提供与函数模版同样好的匹配时，编译器会选择非模版版本。另外特例化也可以应用到类定义上，类上的特例化也同样支持全特例化和部分特例化，例如：template&lt;class T, class U&gt; class testClass { // 原类    public：    T var1;    U var2;    void Func();}template&lt;&gt; class testClass&lt;int, double&gt; { // 全特例化    public：    int var1;    double var2;    void Func();}template&lt;T&gt; class testClass&lt;T, double&gt; { // 部分特例化    public：    T var1;    double var2;    void Func();}template&lt;class T, class U&gt; struct testClass { // 对函数成员特例化    public：    T var1;    U var2;    template&lt;&gt;    void Func&lt;int, double&gt;(); // 成员函数特例化}类也可以全特例化和部分特例化，其中成员函数特例化时必须全特例化，不支持部分特例化。标准库中的特殊类型tuple类似pair的模版，不过tuple可以有任意数量的成员，例如：tuple&lt;T1, T2, T3...Tn&gt; t; // 一个tuple变量可以有n个成员T2 item = get&lt;i&gt;(t); // 用索引值获取成员tuple的一个常见用途是从函数返回多值，当使用tuple作为多值返回值时，它相当于是一个可以方便临时构造的数据结构。bitset能使得二进制运算的使用更为容易，能处理超过整数大小的位集合。bitset&lt;n&gt; b; // b有n位，每一位均为0。bool item = b[i]; // 访问b中pos处位置的值b.set(27); // 第27个位置设置为1正则表达式regex类，这里不多说了，正则表达式网上说明太多。标准库中的rand随机数主要解决两类问题，第一是范围内随机，第二是非均匀分布。因此标准库提供了随机数引擎Engine，通过种子来锚定伪随机数。常用程序工具异常处理流程通常是从一处抛出异常，不断沿着函数调用链寻找异常匹配，如果没有找到则调用标准库函数terminate终止程序执行。其中一条catch语句可以通过重新抛出操作将异常传递给另外一个catch语句，函数也可以通过声明noexcept或throw来承诺不会抛出异常。新标准中引入了内联命名空间，内联命名空间中的名字可以被外层命名空间直接使用。多重继承，指从多个直接基类中派生类的能力。多重继承的派生类继承了所有父类的属性。多重继承的派生类的内存模型其实就是类属性的叠加，不同父类之间通过内存叠加来实现多重继承。在构造时按继承顺序调用构造函数，析构时的调用顺序则刚好相反。运行时类型识别（RTTI，run-time type identification）RTTI功能由两个运算符实现：  typeid 运算符，用于返回表达式的类型  dynamic_cast 运算符，用于将指针或引用安全地转换为派生类指针或引用我们知道不包含任何虚函数的类在内存模型中是没有虚表的，而虚表是运行时识别的重要关键。其实两个运算符都是针对虚函数实现的，其原理就是派生类中有虚表，虚表中有指向type_info的指针和虚函数指针。typeid通过虚表取得type_info返回给程序，dynamic_cast则通过比较目标类中的type_info和执行对象虚表中的type_info确定是否可以安全转换。有趣的一点是，typeid也可以用于静态类（即没有任何虚函数的类），此时获取的type_info则是通过编译器生成的，因为在编译阶段就能识别该对象类型。类成员指针与普通指针不同的是类成员指针指向的是成员而非对象。类成员指针分为数据成员指针和成员函数指针。数据成员指针指向的是数据成员，成员函数指针则指向成员函数，例如：class testClass{    public:    string content;    char * getChar();}const string testClass::*pdata = &amp;testClass::content; // pdata为成员指针const string testClass::*pfunc = &amp;testClass::getChar; //pfunc为成员函数指针testClass myObj; // 实例对象testClass *pObj = &amp;myObj; // 指针string s = myObj.*pdata; // 用成员指针获取实例成员数据string ss = myObj-&gt;*pdata; //  用成员指针获取指针成员数据char *c = (myObj.*pfunc)();char *cc = (myObj-&gt;*pfunc)();上述例子中我们可以清楚的看到pdata，pfunc是testClass成员指针，通过声明testClass + 类型来指定成员指针，用成员指针可以调用或者取得成员数据。通过这种成员指针的方式，我们可以将类成员的函数放入一个函数表中以方便逻辑使用，例如：class testClass{    public:    using Action = char* (testClass::*)();    char* getChar1();    char* getChar2();    char* getChar3();}testClass::Action funcMenu[] = { &amp;testClass::getChar1, &amp;testClass::getChar2, &amp;testClass::getChar3 };testClass obj;for(int i = 0; i&lt;3 ; i++){    char * c = (obj.*(funcMenu[i]))();}类成员指针与普通函数指针不同之处在于成员指针并不是一个可调用对象，因此它不支持函数调用运算符。这时我们可以用funciton和bind将类成员函数指针封装成可调用对象，这样可以让成员函数指针运用的更加灵活。例如：function&lt;bool (const string&amp;)&gt; fcn = &amp;string::empty;find_if(svec.begin(), svec.end(), fcn);auto it = find_if(svec.begin(), svec.end(), bind(&amp;string::empty, _1));联合union一个union可以有多数据成员，其空间大小为最大的那个数据成员，因为在任意时刻只有一个数据成员有效，当我们给某个成员赋值后，其他成员就变成了未定义状态。union可以有自己的构造函数和析构函数，但不能有虚函数不能作为基类更不能派生。有时我们需要最终union中存储了什么类型的值，因此通常会自己定义个独立的类对象，通过这个对象来判别union当前类型。其他特性位域，明确了变量的二进制位数，它必须是整数，当一个程序需要向其他程序或者硬件设备传递二进制数据时通常会使用位域，因为设备之间的编译环境不同。取地址运算符（&amp;）不能作用于位域，因此任何指针都无法指向类的位域。它声明的方式为成名名字之后紧跟冒号和常量，例如：class testClass{    public:    int mode: 2; // mode 占2位    int var1: 4: // var1 占4位}volatile，会告诉编译器阻止这个对象优化。由于不同设备之间存在差异，因此在移植或不同环境时会有所改变，因此我们需要使用volatile阻止编译器在当前环境下做编译优化，例如：volatile int var; // 阻止优化变量volatile用在如下的几个地方：  中断服务程序中修改的供其它程序检测的变量需要加volatile；  多任务环境下各任务间共享的标志应该加volatile；  存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；链接指示extern “C”，意味着我们声明了另一个语言的编译器，从而使得我们在编译时让编译器遵守另一个语言的规则（其他兼容例如extern “Ada”，extern “FORTRAN”等）所有在链接指示里的内容都被指向该语言编写的链接，例如：extern \"C\"{    #include &lt;string.h&gt; // 操作c风格字符串的c函数}extern \"C\" void (*pf)(int); // 当pf被调用时，编译器认定pf为C函数(*pf)(2);extern \"C\" typedef void FC(int); // 定义一个C函数void f2(FC *); // 将C函数指针作为C++函数的形参我们可以通过宏来判断当前编译器是C++编译器还是C编译器，即__cplusplus，例如：#ifdef __cplusplusextern \"C\"#endifint strcmp(const char*, const char*);上述代码通过预处理定义在代码中兼容C和C++。已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484819&amp;idx=1&amp;sn=229a9bb2eb6ca5fd7322c8b85bae6d8f&amp;chksm=fc226094cb55e98229f537079c784bcf16f42579928fd034b46a69a953f6ddab28f1b4cf3c1c&amp;token=1401123908&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h1 id=\"背景\">背景：</h1><p>我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意。第三是当我们在巩固时创造出了新的知识，那么这些新的知识和旧的知识将同时变成智慧融合到身体中。</p><p>本系列基于《C++ Primer》学习，由于重点放在“重学”，我略过了滚瓜烂熟的部分，挑出以前常忽略的部分，以及记忆没有那么深刻的部分，特别是那些重要的但没有上心的部分。</p><h1 id=\"正文\">正文：</h1><p>本文是全书总结的最后部分，在总结的同时我又重读了一遍整本书，对各个知识点的理解又加深了许多，希望这些回顾对各位都有所帮助。</p><h3 id=\"模版编程\">模版编程</h3><p>模版有两种，一种是类型模版参数，另一种是非类型模版参数。</p><p>两种类型模版都是由编译器生成的代码，当两个不同的数据类型使用同一个模版时，会在模版实例化时生成的两份不同的代码。例如：</p><pre><code class=\"language-c\">template&lt;typename T&gt;T compare(const T v1, const T v2){    return v1 - v2;}count &lt;&lt; compare(1, 0) &lt;&lt; endl; // 编译器会生成 int compare(const int , const int)count &lt;&lt; compare(1.3F, 2.3F) &lt;&lt;endl; // 编译器会生成 int compare(const float, const float)</code></pre><p>编译器发现有两种数据类型分别调用了模版函数compare，此时编译器会生成两个版本的compare，应用在Class模版也是同样的道理。</p><p>另一种是非类型模版，意思是参数为指定常量，例如：</p><pre><code class=\"language-c\">template&lt;unsigned N, unsigned M&gt;int compare(const char (&amp;p1)[N], const char (&amp;p2)[M]){    return strcmp(p1, p2);}compare(\"hi\",\"mon\"); // 编译器会生成 int compare(const char (&amp;p1)[3], const char (&amp;p2)[4]);compare(\"hello\", \"world\"); // 编译器会生成 int compare(const char(&amp;p1)[6], const char (&amp;p2)[6]);</code></pre><p>非类型参数是一个常量，而且必须是常量或者常量表达式，编译器会根据不同的常量生成不同类型的代码，应用在Class模版上也是同样的道理。</p><p>编译器生成模版代码，当且仅当编译器检测到模版被使用时才发生，即如果一个成员函数没有被使用，则它不会被编译器实例化。</p><p>另外编译器生成模版代码会分三个阶段，第一个阶段是检查语法，第二个阶段是检查模版调用的参数匹配，第三个阶段才是模版实例化，因此链接时发生错误在模版编程时是常有的事。</p><p>在新标准中C++可以通过显示实例化来明确指定某个类或函数实例化。例如：</p><pre><code class=\"language-c\">extern template declaration; // 显式实例化申明template declaration; // 显式实例化定义</code></pre><p>当编译器遇到extern模版显式实例化声明时，表明程序会在其他地方有该程序的实例化。和普通模版实例化不同的是，如果一个类定义了模版显式实例化，则该模版的所有成员包括内联成员函数都会被实例化。</p><p>此外在调用中如果有需要，我们也可以显式指定模版参数类型。例如：</p><pre><code class=\"language-c\">template&lt;tyepname T1, typename T2, typename T3&gt;T1 sum(T2, T3);long long var1 = sum(11,22L); // 编译错误long long var2 = sum&lt;long long&gt;(22, 33L); // 显式指定返回值为long longlong long var3 = sum&lt;long long, int, float&gt;(23, 34F); // 显式指定返回值和参数分别为 long long, int, float</code></pre><p>上述示例告诉我们，如果返回值使用了模版类型，则最好通过显式指定的方式来指定形参类型。</p><h3 id=\"理解右值引用stdmove和stdforward\">理解右值引用、std::move和std::forward</h3><p>可以简单理解为，一个&amp;为左值引用，两个&amp;为右值引用，右值引用有些特殊，它转为转移数据而存在，即当右值引用赋值后，原值的内存数据将失效。</p><p>通过右值引用可以做到数据转移的功能，例如：</p><pre><code class=\"language-c\">void f(int v1, int &amp;v2){    count &lt;&lt; v1 &lt;&lt; \" \" &lt;&lt; ++v2 &lt;&lt; endl;}template&lt;typename F, typename T1, typename T2&gt;void flip1(F f, T1 t1, T2 t2){    f(t2, t1);}template&lt;typename F, typename T1, typename T2&gt;void flip2(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2){    f(t2, t1);}int i = 0;f(42, i); // i变量被改变flip1(f, i, 42); // i变量没有被改变flip2(f, i, 42); // i变量被改变</code></pre><p>上述中filp1与flip2的差别是，filp2使用了右值引用，将实参转移到了形参上，进而在f中可以改变i本身的变量。</p><p>模版可以接受右值引用参数，std::move的定义就是模版右值引用定义：</p><pre><code class=\"language-c\">template&lt;typename T&gt;typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; t){    return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);}move函数参数T&amp;&amp;是一个指向模版类型的右值引用。通过引用折叠，参数可以与任何类型的实参匹配。string s1(\"hi\"), s2;s2 = std::move(string(\"bye\")); // 实例化为 string&amp;&amp; move(string &amp;&amp;t)s2 = std::move(s1); // 实例化为 string&amp;&amp; move(string &amp;t)</code></pre><p>其实这两个模版实例化成了不同的函数，根本原因是右值引用可折叠，导致的结果是：</p><ol>  <li>如果一个函数参数是一个指向模版类型参数的右值引用（如，T&amp;&amp;）则它可以被绑定到一个左值。</li>  <li>如果实参是一个左值，则推断出的模版实参类型将是一个左值引用，且函数参数将被实例化为一个（普通）左值引用参数（T&amp;）。</li></ol><p>标准库中std::forward可以帮助我们返回实参类型的右值引用，即std::forward<T>的返回类型是T&amp;&amp;。例如：</T></p><pre><code class=\"language-c\">template&lt;type F, typename T1, typename T2&gt;void flip(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2){    f(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));}</code></pre><h3 id=\"模版重载函数与可变参数模版\">模版重载函数与可变参数模版</h3><p>模版重载函数在匹配规则上有些小规则，当有多个重载模版对一个调用提供同样好的匹配时，应选择最特例化的版本。</p><p>对于一个调用，如果一个非函数模版与一个函数模版提供同样好的匹配，则选择非模版版本。</p><p>可变参数模版中，编译器会根据识别到的函数参数类型生成多个不同类型形参的函数。</p><p>可变参数模版可以与sizeof…运算符一起使用，sizeof…运算符也是通过预编译生成的模版函数，返回的是类型数目或者参数数目。</p><p>例如：</p><pre><code class=\"language-c\">template&lt;typename T, typename... Args&gt;ostream &amp;print(ostream &amp;os, const T &amp;t, const Args&amp;... rest){    os &lt;&lt; t &lt;&lt; \",\";    return print(os, rest...); // 预编译会将函数展开成类似print(os, i, s, 42)}string debug_rep(char *p){    return string(p);}template&lt;typename... Args&gt;ostream &amp;errorMsg(ostream &amp;os, const Args&amp;... rest){    return print(os, debug_rep(rest)...); // 预编译会将函数展开成类似print(os, debug_rep(i), debug_rep(s), debug_rep(42));}</code></pre><p>编译器会在预编译时对可变参数展开，因此上述函数在调用展开后类似于 print(os, i, s, 42) 和 print(os, debug_rep(i), debug_rep(s), debug_rep(42))。</p><h3 id=\"模版特例化\">模版特例化</h3><p>有时候我们不希望使用模版但又想跟模版的使用方式一样，此时就可以用一个特例化模版来独立定义模版中的一个或者多个参数指定为特定类型。</p><pre><code class=\"language-c\">template&lt;typename T, typename U&gt; int compare(const T&amp;, const U&amp;);  // 原模版template&lt;&gt; int compare(const char* const &amp;p1, const char* const &amp;p2); // 全特例化template&lt;typename T&gt; int compare(const T&amp;, const char* const &amp;p2); // 部分特例化int compare(const int const &amp;var1, const int const &amp;var2);   //  普通函数compare(3F,5F); // 调用源模版compare(\"HI\", \"HELLO\"); // 调用全特例化compare(3F,\"HELLO\"); // 调用部分特例化compare(3,5); // 调用普通函数</code></pre><p>当定义函数模版的特例化版本时，我们本质上接管了编译器的工作。即我们为原模版的一个特殊实例提供了定义。</p><p>重要的是要弄清楚：一个特例化版本本质上是一个实例，而非函数名的一个重载版本，因此特例化不影响函数匹配。</p><p>注意，当一个非模版函数提供与函数模版同样好的匹配时，编译器会选择非模版版本。</p><p>另外特例化也可以应用到类定义上，类上的特例化也同样支持全特例化和部分特例化，例如：</p><pre><code class=\"language-c\">template&lt;class T, class U&gt; class testClass { // 原类    public：    T var1;    U var2;    void Func();}template&lt;&gt; class testClass&lt;int, double&gt; { // 全特例化    public：    int var1;    double var2;    void Func();}template&lt;T&gt; class testClass&lt;T, double&gt; { // 部分特例化    public：    T var1;    double var2;    void Func();}template&lt;class T, class U&gt; struct testClass { // 对函数成员特例化    public：    T var1;    U var2;    template&lt;&gt;    void Func&lt;int, double&gt;(); // 成员函数特例化}</code></pre><p>类也可以全特例化和部分特例化，其中成员函数特例化时必须全特例化，不支持部分特例化。</p><h3 id=\"标准库中的特殊类型\">标准库中的特殊类型</h3><p>tuple类似pair的模版，不过tuple可以有任意数量的成员，例如：</p><pre><code class=\"language-c\">tuple&lt;T1, T2, T3...Tn&gt; t; // 一个tuple变量可以有n个成员T2 item = get&lt;i&gt;(t); // 用索引值获取成员</code></pre><p>tuple的一个常见用途是从函数返回多值，当使用tuple作为多值返回值时，它相当于是一个可以方便临时构造的数据结构。</p><p>bitset能使得二进制运算的使用更为容易，能处理超过整数大小的位集合。</p><pre><code class=\"language-c\">bitset&lt;n&gt; b; // b有n位，每一位均为0。bool item = b[i]; // 访问b中pos处位置的值b.set(27); // 第27个位置设置为1</code></pre><p>正则表达式regex类，这里不多说了，正则表达式网上说明太多。</p><p>标准库中的rand随机数主要解决两类问题，第一是范围内随机，第二是非均匀分布。因此标准库提供了随机数引擎Engine，通过种子来锚定伪随机数。</p><h3 id=\"常用程序工具\">常用程序工具</h3><p>异常处理流程通常是从一处抛出异常，不断沿着函数调用链寻找异常匹配，如果没有找到则调用标准库函数terminate终止程序执行。</p><p>其中一条catch语句可以通过重新抛出操作将异常传递给另外一个catch语句，函数也可以通过声明noexcept或throw来承诺不会抛出异常。</p><p>新标准中引入了内联命名空间，内联命名空间中的名字可以被外层命名空间直接使用。</p><p>多重继承，指从多个直接基类中派生类的能力。多重继承的派生类继承了所有父类的属性。</p><p>多重继承的派生类的内存模型其实就是类属性的叠加，不同父类之间通过内存叠加来实现多重继承。</p><p>在构造时按继承顺序调用构造函数，析构时的调用顺序则刚好相反。</p><h3 id=\"运行时类型识别rttirun-time-type-identification\">运行时类型识别（RTTI，run-time type identification）</h3><p>RTTI功能由两个运算符实现：</p><ol>  <li>typeid 运算符，用于返回表达式的类型</li>  <li>dynamic_cast 运算符，用于将指针或引用安全地转换为派生类指针或引用</li></ol><p>我们知道不包含任何虚函数的类在内存模型中是没有虚表的，而虚表是运行时识别的重要关键。</p><p>其实两个运算符都是针对虚函数实现的，其原理就是派生类中有虚表，虚表中有指向type_info的指针和虚函数指针。</p><p>typeid通过虚表取得type_info返回给程序，dynamic_cast则通过比较目标类中的type_info和执行对象虚表中的type_info确定是否可以安全转换。</p><p>有趣的一点是，typeid也可以用于静态类（即没有任何虚函数的类），此时获取的type_info则是通过编译器生成的，因为在编译阶段就能识别该对象类型。</p><h3 id=\"类成员指针\">类成员指针</h3><p>与普通指针不同的是类成员指针指向的是成员而非对象。</p><p>类成员指针分为数据成员指针和成员函数指针。</p><p>数据成员指针指向的是数据成员，成员函数指针则指向成员函数，例如：</p><pre><code class=\"language-c\">class testClass{    public:    string content;    char * getChar();}const string testClass::*pdata = &amp;testClass::content; // pdata为成员指针const string testClass::*pfunc = &amp;testClass::getChar; //pfunc为成员函数指针testClass myObj; // 实例对象testClass *pObj = &amp;myObj; // 指针string s = myObj.*pdata; // 用成员指针获取实例成员数据string ss = myObj-&gt;*pdata; //  用成员指针获取指针成员数据char *c = (myObj.*pfunc)();char *cc = (myObj-&gt;*pfunc)();</code></pre><p>上述例子中我们可以清楚的看到pdata，pfunc是testClass成员指针，通过声明testClass + 类型来指定成员指针，用成员指针可以调用或者取得成员数据。</p><p>通过这种成员指针的方式，我们可以将类成员的函数放入一个函数表中以方便逻辑使用，例如：</p><pre><code class=\"language-c\">class testClass{    public:    using Action = char* (testClass::*)();    char* getChar1();    char* getChar2();    char* getChar3();}testClass::Action funcMenu[] = { &amp;testClass::getChar1, &amp;testClass::getChar2, &amp;testClass::getChar3 };testClass obj;for(int i = 0; i&lt;3 ; i++){    char * c = (obj.*(funcMenu[i]))();}</code></pre><p>类成员指针与普通函数指针不同之处在于成员指针并不是一个可调用对象，因此它不支持函数调用运算符。</p><p>这时我们可以用funciton和bind将类成员函数指针封装成可调用对象，这样可以让成员函数指针运用的更加灵活。例如：</p><pre><code class=\"language-c\">function&lt;bool (const string&amp;)&gt; fcn = &amp;string::empty;find_if(svec.begin(), svec.end(), fcn);auto it = find_if(svec.begin(), svec.end(), bind(&amp;string::empty, _1));</code></pre><h3 id=\"联合union\">联合union</h3><p>一个union可以有多数据成员，其空间大小为最大的那个数据成员，因为在任意时刻只有一个数据成员有效，当我们给某个成员赋值后，其他成员就变成了未定义状态。</p><p>union可以有自己的构造函数和析构函数，但不能有虚函数不能作为基类更不能派生。</p><p>有时我们需要最终union中存储了什么类型的值，因此通常会自己定义个独立的类对象，通过这个对象来判别union当前类型。</p><h3 id=\"其他特性\">其他特性</h3><p>位域，明确了变量的二进制位数，它必须是整数，当一个程序需要向其他程序或者硬件设备传递二进制数据时通常会使用位域，因为设备之间的编译环境不同。</p><p>取地址运算符（&amp;）不能作用于位域，因此任何指针都无法指向类的位域。</p><p>它声明的方式为成名名字之后紧跟冒号和常量，例如：</p><pre><code class=\"language-c\">class testClass{    public:    int mode: 2; // mode 占2位    int var1: 4: // var1 占4位}</code></pre><p>volatile，会告诉编译器阻止这个对象优化。</p><p>由于不同设备之间存在差异，因此在移植或不同环境时会有所改变，因此我们需要使用volatile阻止编译器在当前环境下做编译优化，例如：</p><pre><code class=\"language-c\">volatile int var; // 阻止优化变量</code></pre><p>volatile用在如下的几个地方：</p><ol>  <li>中断服务程序中修改的供其它程序检测的变量需要加volatile；</li>  <li>多任务环境下各任务间共享的标志应该加volatile；</li>  <li>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；</li></ol><p>链接指示extern “C”，意味着我们声明了另一个语言的编译器，从而使得我们在编译时让编译器遵守另一个语言的规则（其他兼容例如extern “Ada”，extern “FORTRAN”等）</p><p>所有在链接指示里的内容都被指向该语言编写的链接，例如：</p><pre><code class=\"language-c\">extern \"C\"{    #include &lt;string.h&gt; // 操作c风格字符串的c函数}extern \"C\" void (*pf)(int); // 当pf被调用时，编译器认定pf为C函数(*pf)(2);extern \"C\" typedef void FC(int); // 定义一个C函数void f2(FC *); // 将C函数指针作为C++函数的形参</code></pre><p>我们可以通过宏来判断当前编译器是C++编译器还是C编译器，即__cplusplus，例如：</p><pre><code class=\"language-c\">#ifdef __cplusplusextern \"C\"#endifint strcmp(const char*, const char*);</code></pre><p>上述代码通过预处理定义在代码中兼容C和C++。</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484819&amp;idx=1&amp;sn=229a9bb2eb6ca5fd7322c8b85bae6d8f&amp;chksm=fc226094cb55e98229f537079c784bcf16f42579928fd034b46a69a953f6ddab28f1b4cf3c1c&amp;token=1401123908&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/07/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B034",
            
            
            
            "tags": ["读书笔记","前端技术"],
            
            "date_published": "2021-07-11T00:00:00+08:00",
            "date_modified": "2021-07-11T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/07/11/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A114",
            "title": "给女儿的信(十四) 合作",
            "summary": "女儿 教育 亲情",
            "content_text": "Hi Sharon Anne 爸爸好想你们哟。你们到阿婆家过暑假了，开心吗，爸爸视频看到你们很也开心哟。Sharon读书写字越来越棒了，Anne也越来越喜欢读书哟，你们都很棒哟，我们一起学习一起积累哟。爸爸最近看了一本书，书里写了关于我们人类历史的发展。爸爸想跟你们讲一下。书中说我们人类5万年都是智人，就是那种不会使用工具，只会嗷嗷叫的人。后来随着环境的变化慢慢演化成了我们现在的人类。人与动物到底有什么差别呢？差别就在于语言，我们人与人之间可以通过说话来交流，就像爸爸现在你们说话一样。这样就传达我想要传达的信息，你们也能听懂爸爸说了什么。通过这样信息的传达，我们人与人之间就有了合作，而且因为能交流所以这种合作比动物之间的合作会更加的好。所以我们人最大的优势就是合作，通过合作我们能办成很多大事情。古代人通过合作来捕杀大型的猎物，现代人通过合作来完成复杂而庞大的事情。由于我们一个人的能力非常有限，所以我们必须合作。通过合作我们能够让更多的人参与到事情中来，从而完成我们无法完成事情。所以合作特别重要。但合作并不是这么容易的哟，这需要我们有很好的沟通技巧，通过与别人沟通、交流，可以拉拢周围的人帮助我们完成事情。沟通技巧是可以训练也是需要训练的哟，通过训练我们可以提升自己的沟通技巧，这不仅让我们能够有合作的能力，还能让自己的心情更加愉快哟。好了，这次的信就写到这里，爸爸爱你们哟。",
            "content_html": "<p>Hi Sharon Anne 爸爸好想你们哟。</p><p>你们到阿婆家过暑假了，开心吗，爸爸视频看到你们很也开心哟。</p><p>Sharon读书写字越来越棒了，Anne也越来越喜欢读书哟，你们都很棒哟，我们一起学习一起积累哟。</p><p>爸爸最近看了一本书，书里写了关于我们人类历史的发展。爸爸想跟你们讲一下。</p><p>书中说我们人类5万年都是智人，就是那种不会使用工具，只会嗷嗷叫的人。</p><p>后来随着环境的变化慢慢演化成了我们现在的人类。</p><p>人与动物到底有什么差别呢？</p><p>差别就在于语言，我们人与人之间可以通过说话来交流，就像爸爸现在你们说话一样。</p><p>这样就传达我想要传达的信息，你们也能听懂爸爸说了什么。</p><p>通过这样信息的传达，我们人与人之间就有了合作，而且因为能交流所以这种合作比动物之间的合作会更加的好。</p><p>所以我们人最大的优势就是合作，通过合作我们能办成很多大事情。</p><p>古代人通过合作来捕杀大型的猎物，现代人通过合作来完成复杂而庞大的事情。</p><p>由于我们一个人的能力非常有限，所以我们必须合作。</p><p>通过合作我们能够让更多的人参与到事情中来，从而完成我们无法完成事情。</p><p>所以合作特别重要。</p><p>但合作并不是这么容易的哟，这需要我们有很好的沟通技巧，通过与别人沟通、交流，可以拉拢周围的人帮助我们完成事情。</p><p>沟通技巧是可以训练也是需要训练的哟，通过训练我们可以提升自己的沟通技巧，这不仅让我们能够有合作的能力，还能让自己的心情更加愉快哟。</p><p>好了，这次的信就写到这里，爸爸爱你们哟。</p>",
            "url": "http://www.luzexi.com/2021/07/11/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A114",
            
            
            
            
            
            "date_published": "2021-07-11T00:00:00+08:00",
            "date_modified": "2021-07-11T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/07/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B033",
            "title": "读书笔记(三十一) 《装载、链接与库》#4 内核运行库",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：看此书的起源是我在了解Linux注入技术的时候翻阅到的，由于注入技术需要用到很多ELF格式的内容，很多网络上的技术文章都指向了同一本书。也刚好周围的同事有此书，便翻阅了一下，这一番翻阅打开了我对程序世界的又一扇大门。很快我就自己买了此书并阅读完成，整本书给我很大的震撼，让我对程序从编译到链接到装载有了更深刻的认识。我把我的整个学习过程以及对书本的理解，用自己的语言和自己画的图表达出来，让读者能够更容易接受到我所学的知识。目标：了解编译过程了解动态库和静态库的装载细节了解可执行程序装载和执行过程了解可执行文件和动态库的数据格式疑问：c/c++编译器是如何将cpp编译为可执行文件的？多个c/c++文件是如何编译成一个可执行文件的？操作系统内存是如何初始化和管理的？动态库和静态库的链接和装载过程是怎样的？操作系统的用户态和内核态是如何运作的？正文：前面我们介绍了Linux的动态库在装载时的动态链接过程，以及可执行文件的装载过程。这里简单介绍下Windows的动态库的装载过程。Windows下的动态链接与Linux下的相比有很多相似之处，但也有很多不同的地方。Windows下的动态库称为DLL（Dynamic-Link Library），它和EXE文件实际上是一个概念，即都是PE格式的文件，区别在于PE文件头的符号位标识位不同，而且DLL文件的扩展名不一定是.dll，也可能是.ocx或.CPL。与Linux不同的是Windows有符号导入表和导出表概念，即必须使用“__declspec(dllimport)”和“__declspec(dllexport)”来显式的声明符号的导入与导出。Window编译器通过收集这些显式声明的导入符号，将它们放在一个导出表（Exprot Table）的符号集中，类似于Linux下的.dynsym段。动态链接器根据需要导入的符号从导出表上查找到真实的函数地址，这期间导入表则起到了存储符号和记录地址的作用，类似于Linux下的GOT。其实DLL中的代码段并不是地址无关的，Windows加载DLL时采用了重定基地址（Rebasing）的方法重定位每个绝对地址引用。由于DLL内部的地址都是基于基地址或相对于基地址的RVA，因此在重定位时只需要加上一个固定差值就能完成重定位工作。由于是绝对地址重定位，所以重定基地址比ELF的延迟定位机制要快很多，因为它不需要通过类似的GOT机制，对外部数据和函数的访问不需要每次都计算GOT位置。内存堆与栈前面我们说了很多关于系统内存的，包括虚拟内存、页表、缺页、置换等，而这节主要对堆内存和栈内存进行讲解。当我们调用函数时，需要将当前函数的信息保存到栈上以便调用结束回到原来位置时所有数据都能恢复到原样。我们把这些保存到栈上的数据称为栈帧（Stack Frame），这些数据主要包含：  调用需要的参数，以及调用结束时函数的返回地址  临时变量：包括函数的非静态局部变量以及编译器自动生成的临时变量  上下文：当前函数调用的寄存器数据注意，每种编译器都有自己的调用惯例，比如参数的传递顺序和方式、栈维护的方式、函数的签名规则、返回的寄存器等，在各个编译器之间可能有细微的差别。其中几乎所有的编译器调用惯例都将返回值存储在eax寄存器中，对于大于4字节的数据则存储在eax和edx中联合返回。堆内存我们在写内存分配时通常使用内存分配接口malloc或new，这两个接口分配的内存通常都放在.heap堆内存区域中，而动态库文件在加载的时候，则通过mmap将动态库映射到.libraries文件映射区域中。注意，malloc分配的内存到.heap段，mmap分配内存到.libraries段，而当malloc请求的内存大于MMAP_THRESHOLD时，则会转而调用mmap，申请的内存则在.libraries区域，这个阈值可以通过mallopt调整。这里作者介绍了下堆内存管理的几种方式不是非常详细，简单介绍下（后面会写一个操作系统内存专题）：  空闲链表法，把空闲的内存块加入到一个链表上，这个链表里全是空闲的内存块地址，当需要使用时就从这里找合适的。  分页分块法，把整个内存分成128K大小的XX页，然后再把每页分成32字节大小的内存块，用数组记录每个内存页和内存块的占用情况，这样在分配和释放时查找速度会比较快。  固定大小内存池，把整个分为固定大小的内存块，然后用空闲链表记录所有空闲的内存地址，每次分配都从空闲链表里推出一个内存使用。运行库作者专研的比较细，把进程启动到结束的整个过程都扒了出来，我们也跟着扒一下。程序从开始运行到结束的步骤如下：  操作系统fork（创建）进程，把控制权交到程序入口，这个入口通常都是公共库的某个函数（libc或MSVC）  入口函数对运行库和程序运行环境进行初始化，包括堆、I/O、线程、全局变量的构造等等  入口函数在完成初始化之后，调用main函数，正式开始执行程序主体部分  main函数执行完毕，返回入口函数，入口函数进行清理工作，包括全局变量析构、堆栈销毁、关闭I/O等，然后进程调用系统调用结束进程。下面我们来说说在整个系统调用里各部分是如何运作的。文件句柄原理这里不得不提一下文件句柄的原理，因为我们常常使用文件句柄，却不知道文件句柄究竟是什么，以及是什么产生了文件句柄。文件句柄总是和内核的文件对象相关联，内核可以通过句柄来计算出内核里文件对象的地址。在内核中，每个进程都有一个私有的“打开文件表”，这个表是一个指针数组，每一个元素都指向一个内核的打开文件对象，文件句柄就是数组的下标。当用户打开一个文件时，内核就会在内部生成一个文件对象，并在这个表里找到一个空项，让这一项指向生成的打开文件对象，并返回这一项的下标作为句柄值。由于这个“打开文件表”处于内核，并且用户无法访问到，因此用户即使拥有句柄值，也无法直接打开文件对象的地址，只能通过系统提供的函数来操作。Windows的句柄稍有不同，虽然类似于文件表的下标但它并不是下标而是经过某种线性变换的结果。注意，文件表数组前三个元素填充的是stdin、stdout、stderr这三个内核对象。读取文件实现原理我们知道标准库中，文件在写入时会有缓冲区，因此在写入完毕后可以手动调用刷新接口来将缓冲取的内容清空到文件。其实读取文件也是同样的道理，如果读取文件时总是对文件操作，那么每次都需要进入内核模式，完成后再回到用户模式。很明显这样的读取方式消耗的比较大，因此读取文件也需要自己的缓冲，以提高文件读取效率。那么标准库是如何实现文件读取的呢？标准库中文件读取时的执行步骤：  每个文件读取时都会有一个缓冲区，缓冲区存储了已经读取的文件数据和还未读取的文件数据，  当读取文件时，先判断缓冲区中是否有此数据，  如果缓冲区中有我们需要的数据，则直接取得后返回即可，  如果没有我们需要的数据或者数据不够，则读取文件并将其后的数据一并读取放入到缓冲区中后再返回变长参数的实现方式这里作者说明了printf这种函数可变参数的实现方式：  编译时将多个实参打包成byte数组传入函数  在函数中根据下标和大小从byte数组指针中提取形参数据glibc的组成glibc中的内容由两部分组成，一部分是头文件，比如stdio.h、stdlib.h等，它们位于/usr/include，另一部分则是库的二进制文件，/lib/libc.so，或者/usr/lib/libc.a。事实上glibc还有3个重要的运行库，  /usr/lib/crt1.o，包含了入口程序，负责调用__libc_start_main初始化libc，并调用main函数进入真正的程序主体。  /usr/lib/crti.o，包含了_init()部分的程序初始化指令， 所有的.init都会被收集起来在这里调用  /usr/lib/crtn.o，包含了_finit()部分的程序销毁指令，所有的.finit都会被收集起来在这里调用注意，收集全局构造函数和析构函数的过程是，在链接时，将各个目标文件中.ctors段中的构造函数和析构函数合并为一个数组，在初始化和销毁时依次调用由于crti.o必须保证在用户目标文件和系统库之前，crtn.o必须在用户目标文件和系统库之后，因此链接器输入文件顺序必须是：ld crt1.o crti.o [user_objects] [system_libraries] crtn.o注意，前面说的都是C语言，在C++中则提供了crtbeginT.o和crtend.o来配合glibc实现C++的全局构造和析构。线程局部存储(TLS，Thread Local Storage)线程也可以拥有私有数据，这就是线程局部存储机制(TLS，Thread Local Storage)。TLS的用法很简单，只需要在它定义的时候加上关键字__thread就可以，在MSVC里为__declspec(thread)。// Linux__thread in number;// MSVC__declspec(thread) int number;一旦一个全局变量被定义为TLS类型，那么每个线程都会拥有这个变量的副本，任何线程对该变量的修改都不会影响其他线程中该变量的副本。在Windows中TLS的实现方式为：  编译器把__declspec(thread)定义的线程私有变量放到.tls段中  当进程启动一个线程时，在进程堆中分配一块足够大小的空间  把.tls段中的内容复制到这块空间中  于是每个线程都有自己独立的一个.tls数据副本注意，在.rdata表中有一个TLS表，它保存了所有的TLS变量的构造和析构函数地址，在线程启动和退出时都会对TLS变量进行构造和析构。除了使用添加关键字定义TLS变量外，还可以通过系统接口的方式，实时申请TLS类型变量。系统内核调用原理为了安全操作系统将操作分为两种模式，一种用户模式，一种是内核模式，用户模式操作范围被限制在用户空间上，而内核模式的程序涉及的范围会更广一些，但也主要集中内核空间中。由于内核模式操作的权限更大，因此内核程序编写时需要更加谨慎并严格测试，通常我们都接触不到内核程序，除非自己编写或修改操作系统。当用户模式要调用内核模式中的程序，要先通过EAX寄存器设置调用号，再调用中断指令，内核通过中断向量表找到系统调用程序，系统调用程序根据系统调用表查找到系统函数，最后执行系统调用。x86下中断指令为0x80，通过寄存器EAX指定系统调用的调用号，内核程序根据EAX中的值找到系统函数最后执行。举例创建进程时的系统调用过程：  用户调用创建进程函数，  创建进程函数设置eax寄存器并调用中断指令进入内核态，  中断指令根据0x80和中断向量表找到系统调用程序，  系统调用程序根据eax寄存器和系统调用表找到需要调用的函数，  系统调用完毕返回用户态函数返回地址。当用户态和内核态切换时，首先SS要指向内核栈，ESP指向内核栈顶，这样才能让程序当前的栈从用户栈切换到内核栈。其实每个进程都有两个栈，用户栈和内核栈，在切换到内核栈时要保存当前上下文，因此要向内核栈中推入ESP、SS、EFLASHS、CS、EIP的值，以便切回用户态时再弹出恢复。除了这几个特殊的寄存器，向内核栈中推入的还有EBX、ECX、EDX、ESI、EDI和EBP这6个寄存器，而这6个寄存器刚好可以被系统调用函数用于实参。实现自定义CRT（C Runtime）作者根据前面的理论知识，实现了一个自己的CRT（C Runtime），在不使用标准库的情况下，支持自定义自己的函数入口、进程初始化与销毁、堆内存分配与释放、文件读取与写入、格式化输出。我们这里讲解下实现CRT的几个关键点。关键点一：入口函数可以使用编译命令来指定，例如：gcc -nostartfiles -e myentry source.c -o source-e：设置程序的入口函数关键点二：进入main函数前要初始化堆内存，堆内存的管理分配与释放要自己来实现，比如实现一个FreeList空闲链表来存储销毁的堆内存以便下次使用。例如：//自定义堆内存块结构typedef struct _heap_header{    unsigned size;    struct _heap_header * next;    struct _heap_header * prev;} heap_header;//空闲内存链表static heap_header * freelist_head = NULL;//自定义内存释放函数void free(void * ptr){    ....}//自定义堆内存申请函数void * malloc(unsigned size){    ....}关键点三：堆内存的扩容可以通过brk系统调用设置进程的数据段边界，而sbrk可以移动进程的数据段边界，其实将数据段边界后移就相当于分配了一个定量的内存。由brk/sbrk分配的内存仅仅分配了虚拟空间，这些空间是不会提交的（即不分配物理内存页），当进程访问某个地址时才会与物理页关联。关键点四：由于不使用标准库，因此文件系统也必须自己重写，重写文件读写底层时，我们可以用汇编写系统调用来实现。其中系统调用中，打开文件的系统调用号是5、读取文件的系统调用号是3、写入文件的系统调用号是4、关闭文件的系统调用号是6。因此在调用int 0x80前，设置eax为各调用号就可以，同时用ebx、ecx、edx将参数传入系统调用。举例打开文件的系统调用：asm(\"movl $5, %%eax \\n\\t\" // 设置eax的调用号    \"movl %1, %%ebx \\n\\t\" // 设置参数1    \"movl %2, %%ecx \\n\\t\" // 设置参数2    \"movl %3, %%edx \\n\\t\" // 设置参数3    \"int $0x80 \\n\\t\" // 调用0x80系统中断)前面我们说标准输入输出是文件表的前3个句柄，因此句柄0，1，2为标准输入、标准输出、标准错误的句柄。关键点五：实现全局构造和析构时，从.ctors段中读取构造和析构函数数据，将构造和析构函数都合并到指针数组中，依次调用函数指针数组中的方法。typedef void (*ctor_func)(void);ctor_func ctors_begin[1] __attribute__ ((section(\".ctors\"))) = {    (ctor_func) -1;};void run_ctors(){    const ctor_func * list = ctors_begin;    while( (int)*++list != -1 )    {        (**list)();    }}",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484809&amp;idx=1&amp;sn=89091ecce47229ebf10e4855c0ccceca&amp;chksm=fc22608ecb55e998cdff3952057e6d1c6f099463797d57458ec1f4d37a432d46dc3c5bfcfbb5&amp;token=557108361&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h2 id=\"背景\">背景：</h2><p>看此书的起源是我在了解Linux注入技术的时候翻阅到的，由于注入技术需要用到很多ELF格式的内容，很多网络上的技术文章都指向了同一本书。也刚好周围的同事有此书，便翻阅了一下，这一番翻阅打开了我对程序世界的又一扇大门。</p><p>很快我就自己买了此书并阅读完成，整本书给我很大的震撼，让我对程序从编译到链接到装载有了更深刻的认识。</p><p>我把我的整个学习过程以及对书本的理解，用自己的语言和自己画的图表达出来，让读者能够更容易接受到我所学的知识。</p><h2 id=\"目标\">目标：</h2><p>了解编译过程</p><p>了解动态库和静态库的装载细节</p><p>了解可执行程序装载和执行过程</p><p>了解可执行文件和动态库的数据格式</p><h2 id=\"疑问\">疑问：</h2><p>c/c++编译器是如何将cpp编译为可执行文件的？</p><p>多个c/c++文件是如何编译成一个可执行文件的？</p><p>操作系统内存是如何初始化和管理的？</p><p>动态库和静态库的链接和装载过程是怎样的？</p><p>操作系统的用户态和内核态是如何运作的？</p><h2 id=\"正文\">正文：</h2><p>前面我们介绍了Linux的动态库在装载时的动态链接过程，以及可执行文件的装载过程。这里简单介绍下Windows的动态库的装载过程。</p><p>Windows下的动态链接与Linux下的相比有很多相似之处，但也有很多不同的地方。Windows下的动态库称为DLL（Dynamic-Link Library），它和EXE文件实际上是一个概念，即都是PE格式的文件，区别在于PE文件头的符号位标识位不同，而且DLL文件的扩展名不一定是.dll，也可能是.ocx或.CPL。</p><p>与Linux不同的是Windows有符号导入表和导出表概念，即必须使用“__declspec(dllimport)”和“__declspec(dllexport)”来显式的声明符号的导入与导出。Window编译器通过收集这些显式声明的导入符号，将它们放在一个导出表（Exprot Table）的符号集中，类似于Linux下的.dynsym段。动态链接器根据需要导入的符号从导出表上查找到真实的函数地址，这期间导入表则起到了存储符号和记录地址的作用，类似于Linux下的GOT。</p><p>其实DLL中的代码段并不是地址无关的，Windows加载DLL时采用了重定基地址（Rebasing）的方法重定位每个绝对地址引用。由于DLL内部的地址都是基于基地址或相对于基地址的RVA，因此在重定位时只需要加上一个固定差值就能完成重定位工作。由于是绝对地址重定位，所以重定基地址比ELF的延迟定位机制要快很多，因为它不需要通过类似的GOT机制，对外部数据和函数的访问不需要每次都计算GOT位置。</p><h3 id=\"内存堆与栈\">内存堆与栈</h3><p>前面我们说了很多关于系统内存的，包括虚拟内存、页表、缺页、置换等，而这节主要对堆内存和栈内存进行讲解。</p><p>当我们调用函数时，需要将当前函数的信息保存到栈上以便调用结束回到原来位置时所有数据都能恢复到原样。我们把这些保存到栈上的数据称为栈帧（Stack Frame），这些数据主要包含：</p><ol>  <li>调用需要的参数，以及调用结束时函数的返回地址</li>  <li>临时变量：包括函数的非静态局部变量以及编译器自动生成的临时变量</li>  <li>上下文：当前函数调用的寄存器数据</li></ol><p>注意，每种编译器都有自己的调用惯例，比如参数的传递顺序和方式、栈维护的方式、函数的签名规则、返回的寄存器等，在各个编译器之间可能有细微的差别。</p><p>其中几乎所有的编译器调用惯例都将返回值存储在eax寄存器中，对于大于4字节的数据则存储在eax和edx中联合返回。</p><h3 id=\"堆内存\">堆内存</h3><p>我们在写内存分配时通常使用内存分配接口malloc或new，这两个接口分配的内存通常都放在.heap堆内存区域中，而动态库文件在加载的时候，则通过mmap将动态库映射到.libraries文件映射区域中。</p><p>注意，malloc分配的内存到.heap段，mmap分配内存到.libraries段，而当malloc请求的内存大于MMAP_THRESHOLD时，则会转而调用mmap，申请的内存则在.libraries区域，这个阈值可以通过mallopt调整。</p><p>这里作者介绍了下堆内存管理的几种方式不是非常详细，简单介绍下（后面会写一个操作系统内存专题）：</p><ol>  <li>空闲链表法，把空闲的内存块加入到一个链表上，这个链表里全是空闲的内存块地址，当需要使用时就从这里找合适的。</li>  <li>分页分块法，把整个内存分成128K大小的XX页，然后再把每页分成32字节大小的内存块，用数组记录每个内存页和内存块的占用情况，这样在分配和释放时查找速度会比较快。</li>  <li>固定大小内存池，把整个分为固定大小的内存块，然后用空闲链表记录所有空闲的内存地址，每次分配都从空闲链表里推出一个内存使用。</li></ol><h3 id=\"运行库\">运行库</h3><p>作者专研的比较细，把进程启动到结束的整个过程都扒了出来，我们也跟着扒一下。</p><p>程序从开始运行到结束的步骤如下：</p><ol>  <li>操作系统fork（创建）进程，把控制权交到程序入口，这个入口通常都是公共库的某个函数（libc或MSVC）</li>  <li>入口函数对运行库和程序运行环境进行初始化，包括堆、I/O、线程、全局变量的构造等等</li>  <li>入口函数在完成初始化之后，调用main函数，正式开始执行程序主体部分</li>  <li>main函数执行完毕，返回入口函数，入口函数进行清理工作，包括全局变量析构、堆栈销毁、关闭I/O等，然后进程调用系统调用结束进程。</li></ol><p>下面我们来说说在整个系统调用里各部分是如何运作的。</p><h3 id=\"文件句柄原理\">文件句柄原理</h3><p>这里不得不提一下文件句柄的原理，因为我们常常使用文件句柄，却不知道文件句柄究竟是什么，以及是什么产生了文件句柄。</p><p>文件句柄总是和内核的文件对象相关联，内核可以通过句柄来计算出内核里文件对象的地址。在内核中，每个进程都有一个私有的“打开文件表”，这个表是一个指针数组，每一个元素都指向一个内核的打开文件对象，文件句柄就是数组的下标。当用户打开一个文件时，内核就会在内部生成一个文件对象，并在这个表里找到一个空项，让这一项指向生成的打开文件对象，并返回这一项的下标作为句柄值。由于这个“打开文件表”处于内核，并且用户无法访问到，因此用户即使拥有句柄值，也无法直接打开文件对象的地址，只能通过系统提供的函数来操作。Windows的句柄稍有不同，虽然类似于文件表的下标但它并不是下标而是经过某种线性变换的结果。</p><p>注意，文件表数组前三个元素填充的是stdin、stdout、stderr这三个内核对象。</p><h3 id=\"读取文件实现原理\">读取文件实现原理</h3><p>我们知道标准库中，文件在写入时会有缓冲区，因此在写入完毕后可以手动调用刷新接口来将缓冲取的内容清空到文件。</p><p>其实读取文件也是同样的道理，如果读取文件时总是对文件操作，那么每次都需要进入内核模式，完成后再回到用户模式。很明显这样的读取方式消耗的比较大，因此读取文件也需要自己的缓冲，以提高文件读取效率。</p><p>那么标准库是如何实现文件读取的呢？</p><p>标准库中文件读取时的执行步骤：</p><ol>  <li>每个文件读取时都会有一个缓冲区，缓冲区存储了已经读取的文件数据和还未读取的文件数据，</li>  <li>当读取文件时，先判断缓冲区中是否有此数据，</li>  <li>如果缓冲区中有我们需要的数据，则直接取得后返回即可，</li>  <li>如果没有我们需要的数据或者数据不够，则读取文件并将其后的数据一并读取放入到缓冲区中后再返回</li></ol><h3 id=\"变长参数的实现方式\">变长参数的实现方式</h3><p>这里作者说明了printf这种函数可变参数的实现方式：</p><ol>  <li>编译时将多个实参打包成byte数组传入函数</li>  <li>在函数中根据下标和大小从byte数组指针中提取形参数据</li></ol><h3 id=\"glibc的组成\">glibc的组成</h3><p>glibc中的内容由两部分组成，一部分是头文件，比如stdio.h、stdlib.h等，它们位于/usr/include，另一部分则是库的二进制文件，/lib/libc.so，或者/usr/lib/libc.a。</p><p>事实上glibc还有3个重要的运行库，</p><ul>  <li>/usr/lib/crt1.o，包含了入口程序，负责调用__libc_start_main初始化libc，并调用main函数进入真正的程序主体。</li>  <li>/usr/lib/crti.o，包含了_init()部分的程序初始化指令， 所有的.init都会被收集起来在这里调用</li>  <li>/usr/lib/crtn.o，包含了_finit()部分的程序销毁指令，所有的.finit都会被收集起来在这里调用</li></ul><p>注意，收集全局构造函数和析构函数的过程是，在链接时，将各个目标文件中.ctors段中的构造函数和析构函数合并为一个数组，在初始化和销毁时依次调用</p><p>由于crti.o必须保证在用户目标文件和系统库之前，crtn.o必须在用户目标文件和系统库之后，因此链接器输入文件顺序必须是：</p><pre><code class=\"language-c++\">ld crt1.o crti.o [user_objects] [system_libraries] crtn.o</code></pre><p>注意，前面说的都是C语言，在C++中则提供了crtbeginT.o和crtend.o来配合glibc实现C++的全局构造和析构。</p><h3 id=\"线程局部存储tlsthread-local-storage\">线程局部存储(TLS，Thread Local Storage)</h3><p>线程也可以拥有私有数据，这就是线程局部存储机制(TLS，Thread Local Storage)。TLS的用法很简单，只需要在它定义的时候加上关键字__thread就可以，在MSVC里为__declspec(thread)。</p><pre><code class=\"language-c++\">// Linux__thread in number;// MSVC__declspec(thread) int number;</code></pre><p>一旦一个全局变量被定义为TLS类型，那么每个线程都会拥有这个变量的副本，任何线程对该变量的修改都不会影响其他线程中该变量的副本。</p><p>在Windows中TLS的实现方式为：</p><ol>  <li>编译器把__declspec(thread)定义的线程私有变量放到.tls段中</li>  <li>当进程启动一个线程时，在进程堆中分配一块足够大小的空间</li>  <li>把.tls段中的内容复制到这块空间中</li>  <li>于是每个线程都有自己独立的一个.tls数据副本</li></ol><p>注意，在.rdata表中有一个TLS表，它保存了所有的TLS变量的构造和析构函数地址，在线程启动和退出时都会对TLS变量进行构造和析构。除了使用添加关键字定义TLS变量外，还可以通过系统接口的方式，实时申请TLS类型变量。</p><h3 id=\"系统内核调用原理\">系统内核调用原理</h3><p>为了安全操作系统将操作分为两种模式，一种用户模式，一种是内核模式，用户模式操作范围被限制在用户空间上，而内核模式的程序涉及的范围会更广一些，但也主要集中内核空间中。由于内核模式操作的权限更大，因此内核程序编写时需要更加谨慎并严格测试，通常我们都接触不到内核程序，除非自己编写或修改操作系统。</p><p>当用户模式要调用内核模式中的程序，要先通过EAX寄存器设置调用号，再调用中断指令，内核通过中断向量表找到系统调用程序，系统调用程序根据系统调用表查找到系统函数，最后执行系统调用。x86下中断指令为0x80，通过寄存器EAX指定系统调用的调用号，内核程序根据EAX中的值找到系统函数最后执行。</p><p>举例创建进程时的系统调用过程：</p><ol>  <li>用户调用创建进程函数，</li>  <li>创建进程函数设置eax寄存器并调用中断指令进入内核态，</li>  <li>中断指令根据0x80和中断向量表找到系统调用程序，</li>  <li>系统调用程序根据eax寄存器和系统调用表找到需要调用的函数，</li>  <li>系统调用完毕返回用户态函数返回地址。</li></ol><p>当用户态和内核态切换时，首先SS要指向内核栈，ESP指向内核栈顶，这样才能让程序当前的栈从用户栈切换到内核栈。</p><p>其实每个进程都有两个栈，用户栈和内核栈，在切换到内核栈时要保存当前上下文，因此要向内核栈中推入ESP、SS、EFLASHS、CS、EIP的值，以便切回用户态时再弹出恢复。除了这几个特殊的寄存器，向内核栈中推入的还有EBX、ECX、EDX、ESI、EDI和EBP这6个寄存器，而这6个寄存器刚好可以被系统调用函数用于实参。</p><h3 id=\"实现自定义crtc-runtime\">实现自定义CRT（C Runtime）</h3><p>作者根据前面的理论知识，实现了一个自己的CRT（C Runtime），在不使用标准库的情况下，支持自定义自己的函数入口、进程初始化与销毁、堆内存分配与释放、文件读取与写入、格式化输出。</p><p>我们这里讲解下实现CRT的几个关键点。</p><h3 id=\"关键点一\">关键点一：</h3><p>入口函数可以使用编译命令来指定，例如：</p><pre><code class=\"language-c\">gcc -nostartfiles -e myentry source.c -o source</code></pre><p>-e：设置程序的入口函数</p><h3 id=\"关键点二\">关键点二：</h3><p>进入main函数前要初始化堆内存，堆内存的管理分配与释放要自己来实现，比如实现一个FreeList空闲链表来存储销毁的堆内存以便下次使用。</p><p>例如：</p><pre><code class=\"language-c++\">//自定义堆内存块结构typedef struct _heap_header{    unsigned size;    struct _heap_header * next;    struct _heap_header * prev;} heap_header;//空闲内存链表static heap_header * freelist_head = NULL;//自定义内存释放函数void free(void * ptr){    ....}//自定义堆内存申请函数void * malloc(unsigned size){    ....}</code></pre><h3 id=\"关键点三\">关键点三：</h3><p>堆内存的扩容可以通过brk系统调用设置进程的数据段边界，而sbrk可以移动进程的数据段边界，其实将数据段边界后移就相当于分配了一个定量的内存。</p><p>由brk/sbrk分配的内存仅仅分配了虚拟空间，这些空间是不会提交的（即不分配物理内存页），当进程访问某个地址时才会与物理页关联。</p><h3 id=\"关键点四\">关键点四：</h3><p>由于不使用标准库，因此文件系统也必须自己重写，重写文件读写底层时，我们可以用汇编写系统调用来实现。</p><p>其中系统调用中，打开文件的系统调用号是5、读取文件的系统调用号是3、写入文件的系统调用号是4、关闭文件的系统调用号是6。因此在调用int 0x80前，设置eax为各调用号就可以，同时用ebx、ecx、edx将参数传入系统调用。</p><p>举例打开文件的系统调用：</p><pre><code class=\"language-c++\">asm(\"movl $5, %%eax \\n\\t\" // 设置eax的调用号    \"movl %1, %%ebx \\n\\t\" // 设置参数1    \"movl %2, %%ecx \\n\\t\" // 设置参数2    \"movl %3, %%edx \\n\\t\" // 设置参数3    \"int $0x80 \\n\\t\" // 调用0x80系统中断)</code></pre><p>前面我们说标准输入输出是文件表的前3个句柄，因此句柄0，1，2为标准输入、标准输出、标准错误的句柄。</p><h3 id=\"关键点五\">关键点五：</h3><p>实现全局构造和析构时，从.ctors段中读取构造和析构函数数据，将构造和析构函数都合并到指针数组中，依次调用函数指针数组中的方法。</p><pre><code class=\"language-c++\">typedef void (*ctor_func)(void);ctor_func ctors_begin[1] __attribute__ ((section(\".ctors\"))) = {    (ctor_func) -1;};void run_ctors(){    const ctor_func * list = ctors_begin;    while( (int)*++list != -1 )    {        (**list)();    }}</code></pre>",
            "url": "http://www.luzexi.com/2021/07/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B033",
            
            
            
            "tags": ["读书笔记","前端技术"],
            
            "date_published": "2021-07-04T00:00:00+08:00",
            "date_modified": "2021-07-04T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/07/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B032",
            "title": "读书笔记(三十二) 《C++ Primer》#5",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意。第三是当我们在巩固时创造出了新的知识，那么这些新的知识和旧的知识将同时变成智慧融合到身体中。本系列基于《C++ Primer》学习，由于重点放在“重学”，我略过了滚瓜烂熟的部分，挑出以前常忽略的部分，以及记忆没有那么深刻的部分，特别是那些重要的但没有上心的部分。正文：关联容器关联容器包括map、set以及相应的扩展容器，包括可容纳重复关键字的multimap和multiset容器，以及用unordered为前缀的无序容器。注意，对map使用下标操作时，如果关键字在容器中不存在，则会添加一个关键字在容器中。无序容器大都使用哈希方式来做查找工作，它在存储上组织为一个数组，我们可以比喻为桶管理，每个数组中的元素为桶，它保存0个或多个元素，用哈希函数将元素映射到桶中，当一个桶保存多个元素时，需要顺序搜索这些元素来查找正确的那个。因此无序容器的性能通常依赖于哈希函数的质量和数组的大小。智能指针新的标准库中有两种智能指针，一种允许多个指针指向同一个对象shared_ptr，另一种则“独占”所指向的对象unique_ptr，标准库还提供了一个名为weak_ptr的弱引用方式，来指向shared_ptr所管理的对象。其实智能指针也是模版，它通过模版并重载=、+/-、==运算符来实现智能指针的逻辑。智能指针的逻辑很简单，通过计数器来记录现在有多少个shared_ptr指向相同的对象，当计数为0时它就会自动释放对象。智能指针可以帮助我们管理内存对象的销毁时机，但智能指针不是万能的，如果你忘记销毁了智能指针，则同样会造成内存泄漏。因此我们应该明白内存管理方式有很多种，用来防止内存泄漏的方法也不只智能指针这一种。动态内存管理我们常常自己来管理内存，内存泄漏也是常用的事，分配了内存但没有释放，或者没有及时释放堆积的太多等问题都是比较普遍的。常用的new和delete运算符，在分配内存的同时，也负责调用构造函数和析构函数。如果我们想更好的管理内存，提高内存使用效率，让内存泄漏更容易分析，那么我们就得设计内存分配器来管理内存，例如固定大小内存分配器、环形内存分配器、双端内存分配器等等，这里不详细介绍。阻止对象拷贝用“=delete”定义删除函数来阻止拷贝和赋值：struct NoCopy{  NoCopy() = default; // 默认构造函数  NoCopy(const NoCopy&amp;) = delete; // 阻止拷贝  NoCopy &amp;operator = (const NoCopy&amp;) = delete; // 阻止赋值}关键字“= delete”通知了编译器，告知它我们不希望定义这些成员。注意，析构函数不能被删除，因此不能被定义删除函数。另外父类和子类对删除函数具有一致性，即父类定义了删除函数时子类也同样具备。我们也常通过private来控制拷贝，即将构造函数和赋值运算符声明为private来阻止拷贝。对象移动在内置对象中常发生对象拷贝的情况，如果想避免拷贝又想移动对象，则可以考虑右值引用。所谓右值引用，就是必须绑定到右值的引用，我们可以通过&amp;&amp;（而不是&amp;）来获得右值引用。右值引用有一个重要性质，即只能绑定到一个将要销毁的对象。使用新标准库中move函数移动对象：int &amp;&amp;rr1 = 42; int &amp;&amp;rr3 = std::move(rr1);std::move函数除了获取rr1右值引用外，还负责销毁，因此std::move后我们将不能再使用它了。由于一个移后源对象具有不确定的状态，对其调用std::move是危险的，所以当我们使用move时，必须绝对确认移动后源对象没有其他用户。为了让自定义类支持移动操作，我们可以为其定义移动构造函数和移动赋值运算符。例如：// 移动构造函数testClass::testClass(testClass &amp;&amp;s) noexcept{  var1 = s.var1; // 移动var1  var2 = s.var2; // 移动var2  s.var1 = s.var2 = nullptr; // 移动后置空}// 移动赋值运算符testClass &amp; testClass::operator = (testClass &amp;&amp;s) noexcept{  var1 = s.var1; // 移动var1  var2 = s.var2; // 移动var2  s.var1 = s.var2 = nullptr; // 移动后置空}与构造函数不同的是，移动构造函数不分配任何新内存，它会接管给定对象中的内存。在接管内存后，它将给定对象中的指针都置为 nullptr 以便在后续在销毁源对象时不会销毁这部分内存。编译器也会帮助我们合成默认的移动构造函数和移动赋值运算符，当然必须是编译器发现移动操作被用到的时候，而且只有当一个类没有定义任何自己版本的拷贝控制成员且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成默认的移动构造函数或移动赋值运算符。可调用对象可调用对象包括，函数、函数指针、lambda表达式、bind创建的对象、以及重载了的运算符。从机器指令角度上来理解，函数实质是没有类型之分的，但实际调用时，仍然会需要对齐参数和返回值，因此区别在于参数数量、参数类型、返回值类型。编译器在识别两个可调用对象是否一致时，其实并不关注它是函数指针或者其他，而关心它们的形参和返回值是否相同。这样说来，任意两个可调用对象可以共享同一种调用形式，这使得建立函数表成为了可能，前提是它们的参数和返回类型相同。标准库提供了这样一个模版封装，function，让相同的可调用对象能够转换成同一类型指针，其中T为函数类型可以用lambda表达式。function&lt;int(int, int)&gt; f1 = add; // 加法函数指针function&lt;int(int, int)&gt; f2 = divide(); // 除法函数function&lt;int(int, int)&gt; f3 = [](int i, int j){ return i*j;}; // lambda表达式count &lt;&lt; f1(4,2) &lt;&lt; endl; // 打印6count &lt;&lt; f2(4,2) &lt;&lt; endl; // 打印2count &lt;&lt; f3(4,2) &lt;&lt; endl; // 打印8虚函数OOP的核心是多态，多态的核心就是虚函数，我们知道通过虚函数可以在运行时动态确定要调用的函数，派生类的虚函数会直接覆盖基类。class testClass1{   public:       int var1;       virtual int testFunc();}class testClass2{    public:        virtual int testFunc();}testClass1 * point = new testClass2();point-&gt;testFunc(); // 调用派生类函数point-&gt;testClass1::testFunc(); // 调用父类函数虚函数原理是在虚函数调用时根据虚表来的确定，虚表中存放了当前类的虚函数，每次调用虚函数都会按固定偏移在虚表中提取函数，所以派生类覆盖了父类后，在虚表中固定偏移的函数就成了派生类的函数了。既然派生类覆盖了父类的虚函数，派生类又怎么去调用父类的虚函数呢？其实是由于代码显式的指明了调用方向，所以在编译时编译器就已经知道要调用的哪个函数，也就不需要动态借助虚表来定位了，编译时直接静态绑定父类中函数便可。小知识，我们还可以通过final关键字，阻止虚函数派生类覆盖。虚函数在构造函数和析构函数中调用要特别小心，因为此时部分成员没有被初始化，例如在父类中调用虚函数，由于此时调用的是子类虚函数，而子类成员还未被初始化，调用虚函数有可能导致不可预测的错误，因此通常在构造和析构函数内执行虚函数时用显式的方式调用当前类的虚函数。改变类成员的访问规则用using声明可以改变基类的成员访问级别class Base{  private:    void testFunc();  public:    void testFunc2();}class Derived : private Base{  public:    using Base::testFunc;  protected:    using Base::testFunc2;}上述例子中，基类中的testFunc和testFunc2在派生类中的访问级别都被改变了，testFunc从private改为了public，而testFunc2从public改为了protected。其实成员变量的访问规则只是编译器的规则，在进程的内存和指令中没有做任何限制，在汇编里你完全可以随意访问所谓的私有变量，限制你的只是编译器。",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484794&amp;idx=1&amp;sn=03be5eab5f7014e7d612ffee2a193cb9&amp;chksm=fc22607dcb55e96bd6f1dd010815d3e382cbcacca18bb1a4c69ff96ca3c4644c3d2f6240f7ef&amp;token=557108361&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h2 id=\"背景\">背景：</h2><p>我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意。第三是当我们在巩固时创造出了新的知识，那么这些新的知识和旧的知识将同时变成智慧融合到身体中。</p><p>本系列基于《C++ Primer》学习，由于重点放在“重学”，我略过了滚瓜烂熟的部分，挑出以前常忽略的部分，以及记忆没有那么深刻的部分，特别是那些重要的但没有上心的部分。</p><h2 id=\"正文\">正文：</h2><h3 id=\"关联容器\">关联容器</h3><p>关联容器包括map、set以及相应的扩展容器，包括可容纳重复关键字的multimap和multiset容器，以及用unordered为前缀的无序容器。</p><p>注意，对map使用下标操作时，如果关键字在容器中不存在，则会添加一个关键字在容器中。</p><p>无序容器大都使用哈希方式来做查找工作，它在存储上组织为一个数组，我们可以比喻为桶管理，每个数组中的元素为桶，它保存0个或多个元素，用哈希函数将元素映射到桶中，当一个桶保存多个元素时，需要顺序搜索这些元素来查找正确的那个。因此无序容器的性能通常依赖于哈希函数的质量和数组的大小。</p><h3 id=\"智能指针\">智能指针</h3><p>新的标准库中有两种智能指针，一种允许多个指针指向同一个对象shared_ptr，另一种则“独占”所指向的对象unique_ptr，标准库还提供了一个名为weak_ptr的弱引用方式，来指向shared_ptr所管理的对象。</p><p>其实智能指针也是模版，它通过模版并重载=、+/-、==运算符来实现智能指针的逻辑。智能指针的逻辑很简单，通过计数器来记录现在有多少个shared_ptr指向相同的对象，当计数为0时它就会自动释放对象。</p><p>智能指针可以帮助我们管理内存对象的销毁时机，但智能指针不是万能的，如果你忘记销毁了智能指针，则同样会造成内存泄漏。因此我们应该明白内存管理方式有很多种，用来防止内存泄漏的方法也不只智能指针这一种。</p><h3 id=\"动态内存管理\">动态内存管理</h3><p>我们常常自己来管理内存，内存泄漏也是常用的事，分配了内存但没有释放，或者没有及时释放堆积的太多等问题都是比较普遍的。</p><p>常用的new和delete运算符，在分配内存的同时，也负责调用构造函数和析构函数。</p><p>如果我们想更好的管理内存，提高内存使用效率，让内存泄漏更容易分析，那么我们就得设计内存分配器来管理内存，例如固定大小内存分配器、环形内存分配器、双端内存分配器等等，这里不详细介绍。</p><p>阻止对象拷贝</p><p>用“=delete”定义删除函数来阻止拷贝和赋值：</p><pre><code class=\"language-c++\">struct NoCopy{  NoCopy() = default; // 默认构造函数  NoCopy(const NoCopy&amp;) = delete; // 阻止拷贝  NoCopy &amp;operator = (const NoCopy&amp;) = delete; // 阻止赋值}</code></pre><p>关键字“= delete”通知了编译器，告知它我们不希望定义这些成员。注意，析构函数不能被删除，因此不能被定义删除函数。另外父类和子类对删除函数具有一致性，即父类定义了删除函数时子类也同样具备。</p><p>我们也常通过private来控制拷贝，即将构造函数和赋值运算符声明为private来阻止拷贝。</p><h3 id=\"对象移动\">对象移动</h3><p>在内置对象中常发生对象拷贝的情况，如果想避免拷贝又想移动对象，则可以考虑右值引用。所谓右值引用，就是必须绑定到右值的引用，我们可以通过&amp;&amp;（而不是&amp;）来获得右值引用。右值引用有一个重要性质，即只能绑定到一个将要销毁的对象。</p><p>使用新标准库中move函数移动对象：</p><pre><code class=\"language-c++\">int &amp;&amp;rr1 = 42; int &amp;&amp;rr3 = std::move(rr1);</code></pre><p>std::move函数除了获取rr1右值引用外，还负责销毁，因此std::move后我们将不能再使用它了。由于一个移后源对象具有不确定的状态，对其调用std::move是危险的，所以当我们使用move时，必须绝对确认移动后源对象没有其他用户。</p><p>为了让自定义类支持移动操作，我们可以为其定义移动构造函数和移动赋值运算符。例如：</p><pre><code class=\"language-c++\">// 移动构造函数testClass::testClass(testClass &amp;&amp;s) noexcept{  var1 = s.var1; // 移动var1  var2 = s.var2; // 移动var2  s.var1 = s.var2 = nullptr; // 移动后置空}// 移动赋值运算符testClass &amp; testClass::operator = (testClass &amp;&amp;s) noexcept{  var1 = s.var1; // 移动var1  var2 = s.var2; // 移动var2  s.var1 = s.var2 = nullptr; // 移动后置空}</code></pre><p>与构造函数不同的是，移动构造函数不分配任何新内存，它会接管给定对象中的内存。在接管内存后，它将给定对象中的指针都置为 nullptr 以便在后续在销毁源对象时不会销毁这部分内存。编译器也会帮助我们合成默认的移动构造函数和移动赋值运算符，当然必须是编译器发现移动操作被用到的时候，而且只有当一个类没有定义任何自己版本的拷贝控制成员且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成默认的移动构造函数或移动赋值运算符。</p><h3 id=\"可调用对象\">可调用对象</h3><p>可调用对象包括，函数、函数指针、lambda表达式、bind创建的对象、以及重载了的运算符。从机器指令角度上来理解，函数实质是没有类型之分的，但实际调用时，仍然会需要对齐参数和返回值，因此区别在于参数数量、参数类型、返回值类型。编译器在识别两个可调用对象是否一致时，其实并不关注它是函数指针或者其他，而关心它们的形参和返回值是否相同。</p><p>这样说来，任意两个可调用对象可以共享同一种调用形式，这使得建立函数表成为了可能，前提是它们的参数和返回类型相同。</p><p>标准库提供了这样一个模版封装，function<T>，让相同的可调用对象能够转换成同一类型指针，其中T为函数类型可以用lambda表达式。</T></p><pre><code class=\"language-c++\">function&lt;int(int, int)&gt; f1 = add; // 加法函数指针function&lt;int(int, int)&gt; f2 = divide(); // 除法函数function&lt;int(int, int)&gt; f3 = [](int i, int j){ return i*j;}; // lambda表达式count &lt;&lt; f1(4,2) &lt;&lt; endl; // 打印6count &lt;&lt; f2(4,2) &lt;&lt; endl; // 打印2count &lt;&lt; f3(4,2) &lt;&lt; endl; // 打印8</code></pre><h3 id=\"虚函数\">虚函数</h3><p>OOP的核心是多态，多态的核心就是虚函数，我们知道通过虚函数可以在运行时动态确定要调用的函数，派生类的虚函数会直接覆盖基类。</p><pre><code class=\"language-c++\">class testClass1{   public:       int var1;       virtual int testFunc();}class testClass2{    public:        virtual int testFunc();}testClass1 * point = new testClass2();point-&gt;testFunc(); // 调用派生类函数point-&gt;testClass1::testFunc(); // 调用父类函数</code></pre><p>虚函数原理是在虚函数调用时根据虚表来的确定，虚表中存放了当前类的虚函数，每次调用虚函数都会按固定偏移在虚表中提取函数，所以派生类覆盖了父类后，在虚表中固定偏移的函数就成了派生类的函数了。</p><p>既然派生类覆盖了父类的虚函数，派生类又怎么去调用父类的虚函数呢？其实是由于代码显式的指明了调用方向，所以在编译时编译器就已经知道要调用的哪个函数，也就不需要动态借助虚表来定位了，编译时直接静态绑定父类中函数便可。</p><p>小知识，我们还可以通过final关键字，阻止虚函数派生类覆盖。</p><p>虚函数在构造函数和析构函数中调用要特别小心，因为此时部分成员没有被初始化，例如在父类中调用虚函数，由于此时调用的是子类虚函数，而子类成员还未被初始化，调用虚函数有可能导致不可预测的错误，因此通常在构造和析构函数内执行虚函数时用显式的方式调用当前类的虚函数。</p><h3 id=\"改变类成员的访问规则\">改变类成员的访问规则</h3><p>用using声明可以改变基类的成员访问级别</p><pre><code class=\"language-c++\">class Base{  private:    void testFunc();  public:    void testFunc2();}class Derived : private Base{  public:    using Base::testFunc;  protected:    using Base::testFunc2;}</code></pre><p>上述例子中，基类中的testFunc和testFunc2在派生类中的访问级别都被改变了，testFunc从private改为了public，而testFunc2从public改为了protected。</p><p>其实成员变量的访问规则只是编译器的规则，在进程的内存和指令中没有做任何限制，在汇编里你完全可以随意访问所谓的私有变量，限制你的只是编译器。</p>",
            "url": "http://www.luzexi.com/2021/07/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B032",
            
            
            
            "tags": ["读书笔记","前端技术"],
            
            "date_published": "2021-07-03T00:00:00+08:00",
            "date_modified": "2021-07-03T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/06/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B031",
            "title": "读书笔记(三十一) 《装载、链接与库》#3 动态链接与装载",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：看此书的起源是我在了解Linux注入技术的时候翻阅到的，由于注入技术需要用到很多ELF格式的内容，很多网络上的技术文章都指向了同一本书。也刚好周围的同事有此书，便翻阅了一下，这一番翻阅打开了我对程序世界的又一扇大门。很快我就自己买了此书并阅读完成，整本书给我很大的震撼，让我对程序从编译到链接到装载有了更深刻的认识。我把我的整个学习过程以及对书本的理解，用自己的语言和自己画的图表达出来，让读者能够更容易接受到我所学的知识。目标：了解编译过程了解动态库和静态库的装载细节了解可执行程序装载和执行过程了解可执行文件和动态库的数据格式疑问：c/c++编译器是如何将cpp编译为可执行文件的？多个c/c++文件是如何编译成一个可执行文件的？操作系统内存是如何初始化和管理的？动态库和静态库的链接和装载过程是怎样的？操作系统的用户态和内核态是如何运作的？正文：前面我们说了ELF格式，以及ELF格式的静态链接过程，Windows也有自己的二进制文件格式，这里简单说一下Windows部分的格式。Windows的二进制文件格式称为PE（Protable executable），PE文件格式与ELF同根同源，都是COFF格式发展而来。Windows平台使用Visual C++编译器产生的目标文件使用COFF文件，它们的结构很大程度上都是相同的。“cl”是Visual C++的编译器，即“Compiler”的缩写，Visual C++还提供了用于查看目标文件和可执行文件的工具“dumpbin”。可执行文件装载在讲解执行文件装载前先简单介绍下虚拟空间，因为可执行文件装载需要虚拟空间支持，那么什么是虚拟空间呢？虚拟空间虚拟空间很多人都认为是一个真实的空间，其实不然，它是我们想象出来的空间，其实并不存在。而我们在理解的时候却需要承认这个空间的存在，即每个进程都拥有一个自己想象的虚拟空间，地址从0到0xFFFFFFFFF（32位设备）操作系统上的使用的内存空间都是虚拟地址空间，而非实际物理空间，它是由操作系统虚构出来的一个地址空间。这就像是操作系统给了每个进程一个世界那样，在这个世界里，进程可以自由的申请和释放内存，而不需要理会物理内存如何分配和释放。每个进程中的内存从虚拟地址都从0开始，到0xFFFFFFFF结束，其中有1G的空间专门为内核空间所用，用户空间也做了不同的分段。因此整个虚拟空间地址可以分为：.kernel 内核空间段.stack 栈内存段.libraries  动态库映射段（文件映射段）.heap 堆内存段.bass 未初始化的全局/静态变量段.data 已初始化全局/静态变量段.text 程序指令字节段其中栈内存大小是固定的，只有1MB内存，栈会不断向下分配内存，回收时只需要调整栈顶指针，因此它的分配和回收效率很高，而堆内存则不断向上分配内存，效率相对较低，回收时也容易产生内存碎片。对于Windows操作系统来说，它的进程虚拟地址空间划分是操作系统占用2GB，用户空间剩下2GB。从硬件层面上来说原先的总线32位地址只能访问最多4GB物理内存。但自从扩展至36位地址线之后，Intel修改了页映射的方式，使得新的映射方式可以访问到更多的物理内存，这个扩展方式叫做PAE（Physical Address Extension）。原理就是多块物理内存随时交换映射为同一个虚拟内存地址，这样应用程序就不需要管超出部分的内存空间了。不过这只是在32位机时代的补救办法，现在逐渐淘汰了，但这个方法在其他领域里仍然在被使用。Linux和Windows操作系统都使用页映射方式管理虚拟内存和物理内存之间的关系虚拟内存与物理内存之间由一个页表作为映射连接它们之间的关系当我们访问一块虚拟空间时，操作系统发现没有这块地址没有被连接到真实的物理地址，此时才真正从真实物理内存中找到一块内存块用页表连接起来，这才真正分配成功并且可以使用。每次分配实际物理内存，也并不是分配一整块申请的虚拟内存空间，而是按页大小来分配。即，实际物理空间在使用到时才真正分配，而虚拟空间则已经先行分配。因此我们在虚拟内存上申请的连续内存，有可能在物理内存上是不连续的。当然，申请连续内存获得实际连续内存的概率要大很多。对虚拟空间来说，一块内存只是一个数据结构，没有实际的占用，也没有真正的空间之说，只是我们说起来容易理解一些。程序启动时虚拟内存中很多内存地址都没有被用到，因此也没有对应的物理页，只有当使用到该虚拟内存页时，发现有物理内存缺页的情况，才会发起物理内存申请和映射。除了虚拟内存，不一定有实际的物理内存外，实际的物理地址上的内存，也不一定在实际物理内存中。操作系统又在实际物理内存上加了一个系统用于更好的利用实际物理内存空间，即Swap。当检测到某些物理内存上一次使用时间过长时，则会被Swap置换到硬盘空间，为实际物理内存腾出更多空间给其他进程使用。我们前文提到，在虚拟存储中，现代的硬件MMU提供了地址转换功能，帮助我们在虚拟地址和物理地址之间的转换。那么执行文件是怎么被装载进进程的呢？大致过程为，先创建一个进程，然后将可执行文件装载进进程，再开始运行程序。其中装载可执行文件时需要分三步：  创建一个独立的虚拟地址空间  读取可执行文件头，并建立虚拟空间与可执行文件的映射关系  将CPU的指令寄存器设置成可执行文件的入口地址，开始运行注意，创建一个虚拟空间实际上并不是创建空间，而是创建映射函数所需要的相应的数据结构。在i386的Linux下，创建虚拟地址空间实际上只是分配一个页目录就可以了。另外，可执行文件与虚拟空间建立映射关系时，不会有磁盘和内存的装载，当我们读取可执行文件内容时才发生“缺页”并从磁盘中读取文件内容，装载到虚拟内存再通过页表分配实际物理内存。因此，由于可执行文件在装载时实际上是被映射的虚拟空间地址，所以可执行文件很多时候被称为映像文件（Image）。ELF可执行文件引入了Segment的概念，Segment段合并了多个Section，这样的好处是装载时能更高效且方便。所有相同属性的Section都会归类到一个Segment并映射到同一个匿名虚拟内存区域中（VMA，Anonymous Virtual Memory Area）。Linux内核装载ELF过程内核装载ELF的过程可以描述为如下步骤：  调用fork()创建一个新的进程  新的进程调用execve()执行指定的ELF文件  进入execve()后，Linux内核就开始进行真正的装载工作  先调用sys_execve()进行一些参数检查与复制  再调用do_execve()，它会先查找被执行的文件，去读文件的前128个字节做文件检查，比如魔数的检查。  调用search_binary_handle()搜索和匹配合适的可执行文件装载处理过程，比如ELF可执行文件的装载处理过程为load_elf_binary()，以及装载可执行脚本程序的处理过程叫做load_script()。  load_elf_binary()执行完毕后由于把系统调用的返回地址改为了装载ELF程序的入口地址，  所以当sys_execve()从内核态返回到用户态时，EIP寄存器直接跳转到ELF程序的入口地址，  于是新的程序开始执行，ELF可执行文件装载完成。其中load_elf_binary()执行过程为：  检查ELF可执行文件的有效性，比如魔数、ELF头数据中与Segment的数量  获取动态链接的“.interp”段，并设置动态链接器路径。  根据ELF可执行文件的头描述，对ELF文件进行映射，比如代码、数据、只读数据。  初始化ELF进程环境，比如进程启动时EDX寄存器的地址应该是DT_FINI的地址。  将系统调用的返回地址修改成ELF可执行文件的入口点，入口点对于静态链接来说就是ELF头中的e_entry所指的地址，对于动态链接的ELF可执行文件入口点就是动态链接器。Windows PE的装载过程比ELF简单一些：  读取文件第一页，里面包含了DOS头、PE文件头和段表  检查进程地址空间中目标地址是否可用。如果不可用则另外选一个装载地址，这里可执行文件装载不存在问题，主要针对DLL装载。  获取段表中提供的信息，将PE文件中所有的段一一映射到地址空间中相应的位置。  如果装载地址不是目标地址，则进行Rebasing重定位。  装载所有PE文件所需要的DLL文件。  对PE文件中的所有导入符号进行解析。  根据PE头中指定的参数，建立初始化栈和堆空间。  建立主线程并启动进程。动态链接注意，静态链接和动态链接，与静态库和动态库是两个概念，前者说的是程序链接，后者说的是库的不同组装方式。静态链接由于必须在编译时就确定好库文件而且每个进程都需要载入一份内存，所以它的缺点是更多内存、更多磁盘空间、模块更新困难。我们可以想象一下，每个程序内部都增加一份1MB库程序的内存，那么100个进程就要浪费近100MB的内存，如果磁盘中有2000个这样的程序，就要浪费近2GB磁盘空间，而且在编译后还不能及时更新某个模块，弊端确实挺大的。动态链接就很好的解决了这个问题，它不仅可以使得不同进程之间共享一个库内存，还可以减少物理页的换入换出，也可以增加CPU缓存的命中率。当我们升级程序库时，只要简单的覆盖原文件而无须将所有程序再重新链接一遍，当程序下次运行时新版本库文件就会自动装载到内存完成升级目标。注意，动态链接与静态链接在内存分布上也不同。静态链接后的库程序是可执行文件内不可分割的整体，动态链接后的库程序则有自己的独立内存模块。动态库的动态链接过程其实在需要进行动态装载动态库的可执行文件中，已经装载好了一个ld-2.6.so动态库，它实际上就是Linux下的动态链接器。我们在开启一个进程时，在装载完执行文件后，进程首先会把控制权交给动态链接器，由它完成所有的动态链接工作，再把控制权交给进程开始执行。当我们在代码中写下动态库的函数时，在程序模块动态装载时，应该不需要因为装载地址的改变而改变。所以实现动态链接的基本想法就是把指令中那些需要被修改的部分分离出来，放到数据那里去，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。这种方案称为，地址无关代码（PIC，Position-independent Code）技术方案，通常我们在编译时会加上PIC这个标记，就是告诉编译器，我们这个库是地址无关的。如果一个库不是以地址无关（PIC）模式编译的，那么毫无疑问，它需要在装载时被重定位，即在启动执行时就需要装载库文件并且重定位所有与库文件有关的函数调用地址。如果一个库是以地址无关（PIC）模式编译的，那么就不会在装载时对整个库函数相关调用进行重定位，而是会用延迟绑定（PLT）的方式实时定位函数。static int a;extern int b;extern void ext();void bar(){  a = 1; // 模块内数据访问  b = 2; // 外部模块数据访问}void foo(){  bar(); // 模块内函数调用  ext(); // 外部模块函数调用}以上图为例模块内和模块间的数据访问和函数调用方法，  模块内的函数调用使用相对地址调用  模块内的数据访问使用相对寻址方式  模块外的数据访问，由于无法知道外部数据的具体地址，所以需要借助全局偏移表（GOT）获取外部数据  模块外的函数调用，由于无法知道外部函数的具体地址，所以需要借助全局偏移表（GOT）获取外部函数地址后再调用这样说来GOT就是关键中的关键，那么GOT是怎么工作的呢？大致的方案得从编译说起，我们知道在使用printf，scanf()，strlen()这样的公用库函数时都需要加载公共库libc.so，但公共库并没有被合并到可执行文件中，也就没有可依赖的地址规则。所以编译器在编译这些外部函数的时候，其实并不知道它们的调用地址是多少，无法填充真实地址。但编译器会填充一个地址指向一段动态程序，当这个函数真正被调用时，先调用到动态程序，再由动态程序去寻找真正的调用地址，最后再调用真实地址的函数。这种方法就是延迟绑定（PLT），即进程启动加载外部so后并不立刻对任何调用到so函数的指令做重定位，而是当这些外部函数被调用到时才去寻找并且绑定函数与真实地址的关系。动态链接对全局和静态数据的访问要进行复杂的GOT定位，然后再间接寻址，对外部模块中的函数调用先定位GOT，然后再进行间接跳转。GOT延迟绑定（PLT）运行原理从上图中我们可以知道PLT有3个关键点：  跳转到动态绑定程序  查找外部函数地址的程序  GOT表中数据的存储与读取我们就从这三个关键点入手说明PLT的运行原理当我们在代码里编写外部模块函数，在编译时编译器为我们留下的其实是PLT程序的地址，这个地址就是专门为这个外部函数服务的动态绑定程序，在.plt段里，符号以@plt结尾。动态绑定程序中有3条指令：  第一条就是跳转到GOT中去获取真实地址，如果有就直接跳转，没有就再跳转回来到第二条。  第二条和第三条指令是去查找函数真实地址，找到函数真实地址后把数据写入GOT中并跳转到真实地址。.plt段里动态绑定程序才是真实的查找函数地址的过程，其查找函数真实地址步骤为：  将重定位表（.rel.plt）下标传入动态链接器_dl_runtime_resove()，  由它来完成符号解析和重定位工作，  再将函数的真实地址写入到GOT表中，最后跳转到真实地址。ELF将GOT拆分成两个表，“.got”和“.got.plt”，其中“.got”用来保存全局变量引用地址，“.got.plt”用来保存函数引用地址。其中“.got.plt”的前三项有着特殊意义：  第一项保存的是“.dynamic”段地址，该段描述了本模块动态链接相关的信息。  第二项保存的是本模块的ID。  第三项保存的是_dl_runtime_resolve()地址。三项中的第二项和第三项由动态链接器在装载模块时将它们填充。第四项也稍有些特殊，通常会将跳转指令的通用程序放在第四项中以减少代码重复，因此“.got.plt”基本上前4项都是确定的内容。动态链接相关的数据结构在整个PLT绑定、查找和定位过程中用到了好几个数据段，这里介绍一下。.interp段里保存了一个字符串，这个字符串就是可执行文件件所需要的动态链接器的路径，Linux下动态链接器通常都在“/lib/ld-linux.so.2”，它通常是个软连接指向真正的库。.dynamic段是ELF动态链接最重要的结构，里面保存了动态链接器所需要的基本信息，比如依赖于哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。它有点像ELF文件头，只是ELF文件头中保存的是静态链接时需要的信息，比如符号表、重定位表等，.dynamic可以看成是动态链接下所需要的信息。.dynsym段是动态符号表，与.symtab符号表不同的是，.dynsym动态符号表只保存了与链接相关的符号，也就是外部接口符号表，对于那些模块内部的符号则不保存。为了在.dynsym中查找到对应的符号，会有一个动态符号字符串表.dynstr和符号哈希表.hash来辅助定位和查找符号字符串，加快了符号查找过程。.rel.dyn和.rel.plt段位动态链接时的重定位表，与我们之前在静态链接里介绍的.rel.text和.rel.data的用途类似，存储的是需要重定位的符号和全局数据。与.rel.text和.rel.data的区别在于，.rel.dyn实际上只是修正地址的引用，并不是实际数据地址，他修正的位置其实位于.got以及数据段中；同样的，.rel.plt修正的也只是函数地址的引用，而不是实际地址，其真正地址位于.got.plt中。了解了这几个段的用途，我们可以把调用动态库的延迟重定位的整个过程串连起来了：  程序调用动态库中函数  跳转到PLT程序集中  从GOT中获取真实函数地址，有则直接跳转  没有则从.rela.plt中获取相关信息并调用_dl_runtime_resolve()查找真实函数地址  _dl_runtime_resolve()根据查找到的so中的.dynsym动态符号表找到真实函数地址  将真实地址填充到GOT中并跳转  库函数调用结束动态链接器自己重定位我们说动态链接器本身就是一个库文件（ld-linux.so），所以在进程把控制权交给动态链接器前必须先要将这个库装载到进程中，由于此时又没有程序能去重定位这个动态链接器的库，因此动态链接库必须自己来给自己做重定位，这个重定位过程称为“自举”。自举的过程可以简单描述为：  通过自己的.dynamic段，找到它自己的重定位表和符号表  再根据重定位表和符号表，重定位所有符号表自举期间不能调用函数，因为模块内函数调用必须采用GOT/PLT方式，但GOT/PLT没有被重定位，因此自举代码不可以使用任何全局变量或调用函数。动态链接器自举完成后，就可以通过.dynamic段获取所有需要装载的动态库依次装载、解析、重定位。每个需要被装载的动态库，在装载完成后它的符号表都会被合并到全局符号表（Global Symbol Table）中，全局符号表包含了进程中所有动态链接需要的符号。运行时链接前面说的静态链接和动态链接都是在程序还未完全启动前做的事情，运行时链接则是在程序进行中加载动态库的一种方式。运行时链接的接口有4个，分别是：  dlopen，装载指定动态库  dlsym，获取动态库中的某个符号的地址  dlerror，获取上次调用的错误信息  dlclose，关闭并卸载动态库运行时链接与动态链接的一模一样（除了自举部分），区别一个在启动时装载，另一个则在程序运行时装载。注意，由于所有加载的动态库中的符号都会合并到全局符号表，因此在加载多个库时如果有重复的符号，则后加载的符号可以根据参数选择是否覆盖前面的符号表，默认是不覆盖的。这里作者做了一个试验，因为在Windows中有个rundll的小程序可以直接调用DLL中的函数并返回结果，所以作者想在Linux上也实现一个。于是自己写代码读取动态库so中的函数并调用后打印返回结果，其原理就是利用这4个函数，先dlopen加载指定so，再根据函数名调用dlsym找到函数地址并且调用，最后调用dlerror卸载动态库。已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484788&amp;idx=1&amp;sn=8e4f7f36e4ddf6dd2f7c086463c089de&amp;chksm=fc226073cb55e965e5ab259f04293c48f718a2fd72858b11397852d8ba8c7fab656b0f46e248&amp;token=283688006&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h3 id=\"背景\">背景：</h3><p>看此书的起源是我在了解Linux注入技术的时候翻阅到的，由于注入技术需要用到很多ELF格式的内容，很多网络上的技术文章都指向了同一本书。也刚好周围的同事有此书，便翻阅了一下，这一番翻阅打开了我对程序世界的又一扇大门。</p><p>很快我就自己买了此书并阅读完成，整本书给我很大的震撼，让我对程序从编译到链接到装载有了更深刻的认识。</p><p>我把我的整个学习过程以及对书本的理解，用自己的语言和自己画的图表达出来，让读者能够更容易接受到我所学的知识。</p><h3 id=\"目标\">目标：</h3><p>了解编译过程了解动态库和静态库的装载细节了解可执行程序装载和执行过程了解可执行文件和动态库的数据格式</p><h3 id=\"疑问\">疑问：</h3><p>c/c++编译器是如何将cpp编译为可执行文件的？</p><p>多个c/c++文件是如何编译成一个可执行文件的？</p><p>操作系统内存是如何初始化和管理的？</p><p>动态库和静态库的链接和装载过程是怎样的？</p><p>操作系统的用户态和内核态是如何运作的？</p><h3 id=\"正文\">正文：</h3><p>前面我们说了ELF格式，以及ELF格式的静态链接过程，Windows也有自己的二进制文件格式，这里简单说一下Windows部分的格式。</p><p>Windows的二进制文件格式称为PE（Protable executable），PE文件格式与ELF同根同源，都是COFF格式发展而来。Windows平台使用Visual C++编译器产生的目标文件使用COFF文件，它们的结构很大程度上都是相同的。“cl”是Visual C++的编译器，即“Compiler”的缩写，Visual C++还提供了用于查看目标文件和可执行文件的工具“dumpbin”。</p><h3 id=\"可执行文件装载\">可执行文件装载</h3><p>在讲解执行文件装载前先简单介绍下虚拟空间，因为可执行文件装载需要虚拟空间支持，那么什么是虚拟空间呢？</p><h3 id=\"虚拟空间\">虚拟空间</h3><p>虚拟空间很多人都认为是一个真实的空间，其实不然，它是我们想象出来的空间，其实并不存在。而我们在理解的时候却需要承认这个空间的存在，即每个进程都拥有一个自己想象的虚拟空间，地址从0到0xFFFFFFFFF（32位设备）</p><p>操作系统上的使用的内存空间都是虚拟地址空间，而非实际物理空间，它是由操作系统虚构出来的一个地址空间。</p><p>这就像是操作系统给了每个进程一个世界那样，在这个世界里，进程可以自由的申请和释放内存，而不需要理会物理内存如何分配和释放。</p><p>每个进程中的内存从虚拟地址都从0开始，到0xFFFFFFFF结束，其中有1G的空间专门为内核空间所用，用户空间也做了不同的分段。因此整个虚拟空间地址可以分为：</p><pre><code class=\"language-c\">.kernel 内核空间段.stack 栈内存段.libraries  动态库映射段（文件映射段）.heap 堆内存段.bass 未初始化的全局/静态变量段.data 已初始化全局/静态变量段.text 程序指令字节段</code></pre><p>其中栈内存大小是固定的，只有1MB内存，栈会不断向下分配内存，回收时只需要调整栈顶指针，因此它的分配和回收效率很高，而堆内存则不断向上分配内存，效率相对较低，回收时也容易产生内存碎片。</p><p>对于Windows操作系统来说，它的进程虚拟地址空间划分是操作系统占用2GB，用户空间剩下2GB。</p><p>从硬件层面上来说原先的总线32位地址只能访问最多4GB物理内存。但自从扩展至36位地址线之后，Intel修改了页映射的方式，使得新的映射方式可以访问到更多的物理内存，这个扩展方式叫做PAE（Physical Address Extension）。原理就是多块物理内存随时交换映射为同一个虚拟内存地址，这样应用程序就不需要管超出部分的内存空间了。不过这只是在32位机时代的补救办法，现在逐渐淘汰了，但这个方法在其他领域里仍然在被使用。</p><p>Linux和Windows操作系统都使用页映射方式管理虚拟内存和物理内存之间的关系</p><h3 id=\"虚拟内存与物理内存之间由一个页表作为映射连接它们之间的关系\">虚拟内存与物理内存之间由一个页表作为映射连接它们之间的关系</h3><p>当我们访问一块虚拟空间时，操作系统发现没有这块地址没有被连接到真实的物理地址，此时才真正从真实物理内存中找到一块内存块用页表连接起来，这才真正分配成功并且可以使用。</p><p>每次分配实际物理内存，也并不是分配一整块申请的虚拟内存空间，而是按页大小来分配。即，实际物理空间在使用到时才真正分配，而虚拟空间则已经先行分配。</p><p>因此我们在虚拟内存上申请的连续内存，有可能在物理内存上是不连续的。当然，申请连续内存获得实际连续内存的概率要大很多。</p><p>对虚拟空间来说，一块内存只是一个数据结构，没有实际的占用，也没有真正的空间之说，只是我们说起来容易理解一些。</p><p>程序启动时虚拟内存中很多内存地址都没有被用到，因此也没有对应的物理页，只有当使用到该虚拟内存页时，发现有物理内存缺页的情况，才会发起物理内存申请和映射。</p><p>除了虚拟内存，不一定有实际的物理内存外，实际的物理地址上的内存，也不一定在实际物理内存中。操作系统又在实际物理内存上加了一个系统用于更好的利用实际物理内存空间，即Swap。</p><p>当检测到某些物理内存上一次使用时间过长时，则会被Swap置换到硬盘空间，为实际物理内存腾出更多空间给其他进程使用。</p><p>我们前文提到，在虚拟存储中，现代的硬件MMU提供了地址转换功能，帮助我们在虚拟地址和物理地址之间的转换。</p><h3 id=\"那么执行文件是怎么被装载进进程的呢\">那么执行文件是怎么被装载进进程的呢？</h3><p>大致过程为，先创建一个进程，然后将可执行文件装载进进程，再开始运行程序。</p><p>其中装载可执行文件时需要分三步：</p><ol>  <li>创建一个独立的虚拟地址空间</li>  <li>读取可执行文件头，并建立虚拟空间与可执行文件的映射关系</li>  <li>将CPU的指令寄存器设置成可执行文件的入口地址，开始运行</li></ol><p>注意，创建一个虚拟空间实际上并不是创建空间，而是创建映射函数所需要的相应的数据结构。在i386的Linux下，创建虚拟地址空间实际上只是分配一个页目录就可以了。</p><p>另外，可执行文件与虚拟空间建立映射关系时，不会有磁盘和内存的装载，当我们读取可执行文件内容时才发生“缺页”并从磁盘中读取文件内容，装载到虚拟内存再通过页表分配实际物理内存。因此，由于可执行文件在装载时实际上是被映射的虚拟空间地址，所以可执行文件很多时候被称为映像文件（Image）。</p><p>ELF可执行文件引入了Segment的概念，Segment段合并了多个Section，这样的好处是装载时能更高效且方便。所有相同属性的Section都会归类到一个Segment并映射到同一个匿名虚拟内存区域中（VMA，Anonymous Virtual Memory Area）。</p><h3 id=\"linux内核装载elf过程\">Linux内核装载ELF过程</h3><p>内核装载ELF的过程可以描述为如下步骤：</p><ol>  <li>调用fork()创建一个新的进程</li>  <li>新的进程调用execve()执行指定的ELF文件</li>  <li>进入execve()后，Linux内核就开始进行真正的装载工作</li>  <li>先调用sys_execve()进行一些参数检查与复制</li>  <li>再调用do_execve()，它会先查找被执行的文件，去读文件的前128个字节做文件检查，比如魔数的检查。</li>  <li>调用search_binary_handle()搜索和匹配合适的可执行文件装载处理过程，比如ELF可执行文件的装载处理过程为load_elf_binary()，以及装载可执行脚本程序的处理过程叫做load_script()。</li>  <li>load_elf_binary()执行完毕后由于把系统调用的返回地址改为了装载ELF程序的入口地址，</li>  <li>所以当sys_execve()从内核态返回到用户态时，EIP寄存器直接跳转到ELF程序的入口地址，</li>  <li>于是新的程序开始执行，ELF可执行文件装载完成。</li></ol><p>其中load_elf_binary()执行过程为：</p><ol>  <li>检查ELF可执行文件的有效性，比如魔数、ELF头数据中与Segment的数量</li>  <li>获取动态链接的“.interp”段，并设置动态链接器路径。</li>  <li>根据ELF可执行文件的头描述，对ELF文件进行映射，比如代码、数据、只读数据。</li>  <li>初始化ELF进程环境，比如进程启动时EDX寄存器的地址应该是DT_FINI的地址。</li>  <li>将系统调用的返回地址修改成ELF可执行文件的入口点，入口点对于静态链接来说就是ELF头中的e_entry所指的地址，对于动态链接的ELF可执行文件入口点就是动态链接器。</li></ol><p>Windows PE的装载过程比ELF简单一些：</p><ol>  <li>读取文件第一页，里面包含了DOS头、PE文件头和段表</li>  <li>检查进程地址空间中目标地址是否可用。如果不可用则另外选一个装载地址，这里可执行文件装载不存在问题，主要针对DLL装载。</li>  <li>获取段表中提供的信息，将PE文件中所有的段一一映射到地址空间中相应的位置。</li>  <li>如果装载地址不是目标地址，则进行Rebasing重定位。</li>  <li>装载所有PE文件所需要的DLL文件。</li>  <li>对PE文件中的所有导入符号进行解析。</li>  <li>根据PE头中指定的参数，建立初始化栈和堆空间。</li>  <li>建立主线程并启动进程。</li></ol><h3 id=\"动态链接\">动态链接</h3><p>注意，静态链接和动态链接，与静态库和动态库是两个概念，前者说的是程序链接，后者说的是库的不同组装方式。</p><p>静态链接由于必须在编译时就确定好库文件而且每个进程都需要载入一份内存，所以它的缺点是更多内存、更多磁盘空间、模块更新困难。</p><p>我们可以想象一下，每个程序内部都增加一份1MB库程序的内存，那么100个进程就要浪费近100MB的内存，如果磁盘中有2000个这样的程序，就要浪费近2GB磁盘空间，而且在编译后还不能及时更新某个模块，弊端确实挺大的。</p><p>动态链接就很好的解决了这个问题，它不仅可以使得不同进程之间共享一个库内存，还可以减少物理页的换入换出，也可以增加CPU缓存的命中率。当我们升级程序库时，只要简单的覆盖原文件而无须将所有程序再重新链接一遍，当程序下次运行时新版本库文件就会自动装载到内存完成升级目标。</p><p>注意，动态链接与静态链接在内存分布上也不同。静态链接后的库程序是可执行文件内不可分割的整体，动态链接后的库程序则有自己的独立内存模块。</p><h3 id=\"动态库的动态链接过程\">动态库的动态链接过程</h3><p>其实在需要进行动态装载动态库的可执行文件中，已经装载好了一个ld-2.6.so动态库，它实际上就是Linux下的动态链接器。</p><p>我们在开启一个进程时，在装载完执行文件后，进程首先会把控制权交给动态链接器，由它完成所有的动态链接工作，再把控制权交给进程开始执行。</p><p>当我们在代码中写下动态库的函数时，在程序模块动态装载时，应该不需要因为装载地址的改变而改变。所以实现动态链接的基本想法就是把指令中那些需要被修改的部分分离出来，放到数据那里去，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。</p><p>这种方案称为，地址无关代码（PIC，Position-independent Code）技术方案，通常我们在编译时会加上PIC这个标记，就是告诉编译器，我们这个库是地址无关的。</p><p>如果一个库不是以地址无关（PIC）模式编译的，那么毫无疑问，它需要在装载时被重定位，即在启动执行时就需要装载库文件并且重定位所有与库文件有关的函数调用地址。</p><p>如果一个库是以地址无关（PIC）模式编译的，那么就不会在装载时对整个库函数相关调用进行重定位，而是会用延迟绑定（PLT）的方式实时定位函数。</p><pre><code class=\"language-c\">static int a;extern int b;extern void ext();void bar(){  a = 1; // 模块内数据访问  b = 2; // 外部模块数据访问}void foo(){  bar(); // 模块内函数调用  ext(); // 外部模块函数调用}</code></pre><p>以上图为例模块内和模块间的数据访问和函数调用方法，</p><ol>  <li>模块内的函数调用使用相对地址调用</li>  <li>模块内的数据访问使用相对寻址方式</li>  <li>模块外的数据访问，由于无法知道外部数据的具体地址，所以需要借助全局偏移表（GOT）获取外部数据</li>  <li>模块外的函数调用，由于无法知道外部函数的具体地址，所以需要借助全局偏移表（GOT）获取外部函数地址后再调用</li></ol><h3 id=\"这样说来got就是关键中的关键那么got是怎么工作的呢\">这样说来GOT就是关键中的关键，那么GOT是怎么工作的呢？</h3><p>大致的方案得从编译说起，我们知道在使用printf，scanf()，strlen()这样的公用库函数时都需要加载公共库libc.so，但公共库并没有被合并到可执行文件中，也就没有可依赖的地址规则。</p><p>所以编译器在编译这些外部函数的时候，其实并不知道它们的调用地址是多少，无法填充真实地址。但编译器会填充一个地址指向一段动态程序，当这个函数真正被调用时，先调用到动态程序，再由动态程序去寻找真正的调用地址，最后再调用真实地址的函数。</p><p>这种方法就是延迟绑定（PLT），即进程启动加载外部so后并不立刻对任何调用到so函数的指令做重定位，而是当这些外部函数被调用到时才去寻找并且绑定函数与真实地址的关系。</p><p>动态链接对全局和静态数据的访问要进行复杂的GOT定位，然后再间接寻址，对外部模块中的函数调用先定位GOT，然后再进行间接跳转。</p><h3 id=\"got延迟绑定plt运行原理\">GOT延迟绑定（PLT）运行原理</h3><p>从上图中我们可以知道PLT有3个关键点：</p><ol>  <li>跳转到动态绑定程序</li>  <li>查找外部函数地址的程序</li>  <li>GOT表中数据的存储与读取</li></ol><p>我们就从这三个关键点入手说明PLT的运行原理</p><p>当我们在代码里编写外部模块函数，在编译时编译器为我们留下的其实是PLT程序的地址，这个地址就是专门为这个外部函数服务的动态绑定程序，在.plt段里，符号以@plt结尾。</p><p>动态绑定程序中有3条指令：</p><ul>  <li>第一条就是跳转到GOT中去获取真实地址，如果有就直接跳转，没有就再跳转回来到第二条。</li>  <li>第二条和第三条指令是去查找函数真实地址，找到函数真实地址后把数据写入GOT中并跳转到真实地址。</li></ul><p>.plt段里动态绑定程序才是真实的查找函数地址的过程，其查找函数真实地址步骤为：</p><ul>  <li>将重定位表（.rel.plt）下标传入动态链接器_dl_runtime_resove()，</li>  <li>由它来完成符号解析和重定位工作，</li>  <li>再将函数的真实地址写入到GOT表中，最后跳转到真实地址。</li></ul><p>ELF将GOT拆分成两个表，“.got”和“.got.plt”，其中“.got”用来保存全局变量引用地址，“.got.plt”用来保存函数引用地址。</p><p>其中“.got.plt”的前三项有着特殊意义：</p><ul>  <li>第一项保存的是“.dynamic”段地址，该段描述了本模块动态链接相关的信息。</li>  <li>第二项保存的是本模块的ID。</li>  <li>第三项保存的是_dl_runtime_resolve()地址。</li></ul><p>三项中的第二项和第三项由动态链接器在装载模块时将它们填充。第四项也稍有些特殊，通常会将跳转指令的通用程序放在第四项中以减少代码重复，因此“.got.plt”基本上前4项都是确定的内容。</p><h3 id=\"动态链接相关的数据结构\">动态链接相关的数据结构</h3><p>在整个PLT绑定、查找和定位过程中用到了好几个数据段，这里介绍一下。</p><p>.interp段里保存了一个字符串，这个字符串就是可执行文件件所需要的动态链接器的路径，Linux下动态链接器通常都在“/lib/ld-linux.so.2”，它通常是个软连接指向真正的库。</p><p>.dynamic段是ELF动态链接最重要的结构，里面保存了动态链接器所需要的基本信息，比如依赖于哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。</p><p>它有点像ELF文件头，只是ELF文件头中保存的是静态链接时需要的信息，比如符号表、重定位表等，.dynamic可以看成是动态链接下所需要的信息。</p><p>.dynsym段是动态符号表，与.symtab符号表不同的是，.dynsym动态符号表只保存了与链接相关的符号，也就是外部接口符号表，对于那些模块内部的符号则不保存。</p><p>为了在.dynsym中查找到对应的符号，会有一个动态符号字符串表.dynstr和符号哈希表.hash来辅助定位和查找符号字符串，加快了符号查找过程。</p><p>.rel.dyn和.rel.plt段位动态链接时的重定位表，与我们之前在静态链接里介绍的.rel.text和.rel.data的用途类似，存储的是需要重定位的符号和全局数据。</p><p>与.rel.text和.rel.data的区别在于，.rel.dyn实际上只是修正地址的引用，并不是实际数据地址，他修正的位置其实位于.got以及数据段中；同样的，.rel.plt修正的也只是函数地址的引用，而不是实际地址，其真正地址位于.got.plt中。</p><p>了解了这几个段的用途，我们可以把调用动态库的延迟重定位的整个过程串连起来了：</p><ol>  <li>程序调用动态库中函数</li>  <li>跳转到PLT程序集中</li>  <li>从GOT中获取真实函数地址，有则直接跳转</li>  <li>没有则从.rela.plt中获取相关信息并调用_dl_runtime_resolve()查找真实函数地址</li>  <li>_dl_runtime_resolve()根据查找到的so中的.dynsym动态符号表找到真实函数地址</li>  <li>将真实地址填充到GOT中并跳转</li>  <li>库函数调用结束</li></ol><h3 id=\"动态链接器自己重定位\">动态链接器自己重定位</h3><p>我们说动态链接器本身就是一个库文件（ld-linux.so），所以在进程把控制权交给动态链接器前必须先要将这个库装载到进程中，由于此时又没有程序能去重定位这个动态链接器的库，因此动态链接库必须自己来给自己做重定位，这个重定位过程称为“自举”。</p><p>自举的过程可以简单描述为：</p><ol>  <li>通过自己的.dynamic段，找到它自己的重定位表和符号表</li>  <li>再根据重定位表和符号表，重定位所有符号表</li></ol><p>自举期间不能调用函数，因为模块内函数调用必须采用GOT/PLT方式，但GOT/PLT没有被重定位，因此自举代码不可以使用任何全局变量或调用函数。</p><p>动态链接器自举完成后，就可以通过.dynamic段获取所有需要装载的动态库依次装载、解析、重定位。每个需要被装载的动态库，在装载完成后它的符号表都会被合并到全局符号表（Global Symbol Table）中，全局符号表包含了进程中所有动态链接需要的符号。</p><h3 id=\"运行时链接\">运行时链接</h3><p>前面说的静态链接和动态链接都是在程序还未完全启动前做的事情，运行时链接则是在程序进行中加载动态库的一种方式。</p><p>运行时链接的接口有4个，分别是：</p><ol>  <li>dlopen，装载指定动态库</li>  <li>dlsym，获取动态库中的某个符号的地址</li>  <li>dlerror，获取上次调用的错误信息</li>  <li>dlclose，关闭并卸载动态库</li></ol><p>运行时链接与动态链接的一模一样（除了自举部分），区别一个在启动时装载，另一个则在程序运行时装载。</p><p>注意，由于所有加载的动态库中的符号都会合并到全局符号表，因此在加载多个库时如果有重复的符号，则后加载的符号可以根据参数选择是否覆盖前面的符号表，默认是不覆盖的。</p><p>这里作者做了一个试验，因为在Windows中有个rundll的小程序可以直接调用DLL中的函数并返回结果，所以作者想在Linux上也实现一个。于是自己写代码读取动态库so中的函数并调用后打印返回结果，其原理就是利用这4个函数，先dlopen加载指定so，再根据函数名调用dlsym找到函数地址并且调用，最后调用dlerror卸载动态库。</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484788&amp;idx=1&amp;sn=8e4f7f36e4ddf6dd2f7c086463c089de&amp;chksm=fc226073cb55e965e5ab259f04293c48f718a2fd72858b11397852d8ba8c7fab656b0f46e248&amp;token=283688006&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/06/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B031",
            
            
            
            "tags": ["读书笔记","前端技术"],
            
            "date_published": "2021-06-27T00:00:00+08:00",
            "date_modified": "2021-06-27T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/06/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B030",
            "title": "读书笔记(三十) 《C++ Primer》#4",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意。第三是当我们在巩固时创造出了新的知识，那么这些新的知识和旧的知识将同时变成智慧融合到身体中。本系列基于《C++ Primer》学习，由于重点放在“重学”，我略过了滚瓜烂熟的部分，挑出以前常忽略的部分，以及记忆没有那么深刻的部分，特别是那些重要的但没有上心的部分。正文类相关定义注意，this指针是常量指针，因为我们不允许改变this指针中保存的地址。当我们定义类相关的非成员函数时，即如果函数在概念上属于类但不定义在类中，则它一般应与类声明在同一个头文件中。这种方式下，当用户使用接口的任何部分都只需要引用一个文件，举例：//testClass.h//类声明class testClass {  //test class  public:    int testVar;}//类相关的非成员函数int readFrom_testClass(const testClass &amp; item);默认合成的构造函数编译器创建的默认构造函数称为，合成的默认构造函数（synthesized default constructor），它的规则如下：  如果存在类内的初始值，用它来初始化成员。  否则，默认初始化该成员。合成的默认构造函数只适合非常简单的类，其他某些类不能依赖于合成默认构造函数，原因有三：  编译器只有在发现类不包含任何构造函数的情况下才替我们生成一个默认的构造函数。  类中含有内置类型或者复合类型成员的类应该在类的内部初始化这些成员，否则使用默认构造函数可能得到未定义值。  类中含有其他类型成员且成员类型没有默认构造函数，则默认构造函数无法初始化这个成员。当然最好是我们自己定义每个类的构造函数而不是让编译器使用默认构造函数，如果你不能使用类内初始化值，则所有构造函数都应该显式地初始化每个内置类型的成员。Class和Struct的区别与C#、Java不同，C++中Class和Struct几乎一样，只是关键字不同和使用习惯不同而已。唯一的微小区别就是，使用Class的默认访问模式为private，而struct的默认访问模式是public。友元友元允许其他类或函数访问自己的非公有成员，这个大家都知道就不多说了。需要注意的是友元关系不存在传递性，也就是说子类的友元并不能理所当然的访问父类。而且想要所有重载函数成为友元关系，必须为每个重载函数做一次友元声明。不过在编译时，友元的声明仅仅指定了访问的权限，它只是标记编译的语法规则好让编译器在语法检查时能知道友元标记的存在，实际上编译器并没有做任何内存上和寄存器上的修改。构造函数初始值列表class testClass{  public:      testClass(int ii);  private:      int i;      const int ci;      int &amp;ri;}testClass::testClass(intii):    i(ii),ci(ii),ri(i){  //do something}我们在类中常使用以上这种构造函数来初始化成员，其实这就相当于成员的初始化顺序，即先初始化i，然后ci，然后ri。隐式的类构造转换在对象构造时，也会出现隐式的构造情况，例如：class Test_data{   Test_data(const string str);}string test_str = \"test\";Vector&lt;Test_data&gt; item;item.push(test_str);如果构造函数只接受一个实参，则实际上它同时也定义了转换为此类类型的隐式转换机制，我们把这种构造函数称为，转换构造函数（converting constructor）。上面例子中传入的string对象从而引发了Test_data的转换构造函数，构造出对象后再传入，其实这些隐式转换和构造都是在编译时离线计算的，根本不会放到运行时去发生。如果你不想让隐式构造发生，可以通过在构造函数前加 explicit 声明来阻止隐式转换，如下：class Test_data{   explicit Test_data(const string str);}string test_str = \"test\";Vector&lt;Test_data&gt; item;item.push_back(test_str); // 编译错误item.push_back(Test_data(test_str)); // 编译正确声明了explicit的构造函数，只能以直接初始化的形式使用，编译器将不会再进行隐式的自动转换这些构造函数。IO库这里有些零散的知识需要注意下。IO库定义了很多标记，这些标记可以帮助我们访问和操作流，例如由于流可能处于错误状态，我们在操作之前先去检查它是否处于良好状态。其中badbit标记相对用的比较多，它表示系统级错误，例如不可恢复的读写错误。通常情况下，一旦badbit被置位，流就无法再使用了。IO流有缓冲机制，这可以提升IO的性能，当刷新时才将数据写入到文件中。导致缓冲刷新的几种情况为：  程序正常结束，main函数return操作。  缓冲区满时，需要刷新缓冲。  使用操作符endl来显式刷新缓冲区。  使用操作符unitbuf设置流的内部状态，清空缓冲区。  一个输出流被关联到另一个流时，输出流会被刷新。注意，如果程序崩溃了，输出流的缓冲区是不会被刷新的，这也是为什么崩溃时部分数据没有被写入文件的原因。顺序容器顺序容器指，vector，deque，list，array，string，它们都可以用迭代器访问元素。如果我们不需要写访问元素，则应该使用cbegin和cend来获取常量迭代指针。顺序容器中有一个方法比较有趣assign（array除外），它可以用参数所指定的元素（拷贝形式）替换容器中的所有元素。seq.assign(b,e); // 将seq替换为迭代器b到e范围内的元素seq.assign(il); // 将seq替换为容器列表il中的元素seq.assign(il); // 将seq替换为n个t值的元素注意，当我们用一个对象来初始化容器，或者将一个对象插入到容器中时，实际上放入到容器中的是对象的拷贝，而不是对象本身。就像我们将一个对象传递给非引用参数一样，容器中的元素与提供值的对象之间没有任何关联。另外我们也要注意向容器中添加元素或删除元素的操作，可能会使得指向容器的指针、引用、迭代器失效，进而导致运行时错误。泛型算法标准库并没有给每个容器添加大量功能，而是提供了一组算法，这些算法大多是通用算法，可以独立于任何特定的容器。归纳总结下来，泛型算法有4个特点：  大多是通用算法，可以独立于任何特定的容器  虽然独立于任何容器，但有些算法依赖于元素类型（例如累加算法依赖于带有加法运算的对象类型）。  不会直接操作容器，而是运行于迭代器之上，执行的是迭代器的操作。  算法可能改变容器中保存的值，或移动容器中的元素，但永远不会直接添加或者删除元素。lambda函数当定义一个lambda函数时，编译器生成一个与lambda对应的新（未命名的）类类型。也就是说当向一个函数传递一个lambda函数时，编译器同时定义了一个新类型和该类型的一个对象，传递的参数就是此编译器生成的类类型的未命名对象，而不是传入的对象。void func1(){  int v1 = 41;  auto f = [v1] {return v1;}; // 值捕获  v1 = 0;  auto j = f(); // j 为 41  auto f2 = [&amp;v1] {return v1;} // 引用捕获  v1 = 2;  auto j = f2(); // j 为 2}transform(v1.begin(), vi.end(), vi.begin(), [](int i) -&gt; int { if (i &lt; 0) return -i; else return i; }); // lambda函数指定了int返回值和int形参注意，如上代码中，如果lambda形参为引用则需要我们注意实参的生命周期，因为在lambda执行时，如果该对象已经被销毁则可能引起运行时错误。除了使用lambda创建快速创建函数外，也可以使用标准库里bind函数来生成函数，例如：// 格式： auto newCallable = bind(callable, arg_list);void func1(int a, int b){  return a + b;}int aa = 1;int bb = 2;auto newFunc1 = bind(func1, aa, bb); // 生成一个新的可调用对象来适配算法auto wc = find_if(words.begin(), words.end(), newFunc1); // bind生成了一个适配泛型算法的函数bind可以看做是一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484770&amp;idx=1&amp;sn=417618b18d6a0bf34b5fa720031f6312&amp;chksm=fc226065cb55e973587b7a3e372b71acf1def7cb7b04ce3ba2d43a5e4871582f72459bcb962d&amp;token=283688006&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h3 id=\"背景\">背景：</h3><p>我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意。第三是当我们在巩固时创造出了新的知识，那么这些新的知识和旧的知识将同时变成智慧融合到身体中。</p><p>本系列基于《C++ Primer》学习，由于重点放在“重学”，我略过了滚瓜烂熟的部分，挑出以前常忽略的部分，以及记忆没有那么深刻的部分，特别是那些重要的但没有上心的部分。</p><h3 id=\"正文\">正文</h3><h3 id=\"类相关定义\">类相关定义</h3><p>注意，this指针是常量指针，因为我们不允许改变this指针中保存的地址。</p><p>当我们定义类相关的非成员函数时，即如果函数在概念上属于类但不定义在类中，则它一般应与类声明在同一个头文件中。这种方式下，当用户使用接口的任何部分都只需要引用一个文件，举例：</p><pre><code class=\"language-c\">//testClass.h//类声明class testClass {  //test class  public:    int testVar;}//类相关的非成员函数int readFrom_testClass(const testClass &amp; item);</code></pre><p>默认合成的构造函数</p><p>编译器创建的默认构造函数称为，合成的默认构造函数（synthesized default constructor），它的规则如下：</p><ol>  <li>如果存在类内的初始值，用它来初始化成员。</li>  <li>否则，默认初始化该成员。</li></ol><p>合成的默认构造函数只适合非常简单的类，其他某些类不能依赖于合成默认构造函数，原因有三：</p><ol>  <li>编译器只有在发现类不包含任何构造函数的情况下才替我们生成一个默认的构造函数。</li>  <li>类中含有内置类型或者复合类型成员的类应该在类的内部初始化这些成员，否则使用默认构造函数可能得到未定义值。</li>  <li>类中含有其他类型成员且成员类型没有默认构造函数，则默认构造函数无法初始化这个成员。</li></ol><p>当然最好是我们自己定义每个类的构造函数而不是让编译器使用默认构造函数，如果你不能使用类内初始化值，则所有构造函数都应该显式地初始化每个内置类型的成员。</p><h3 id=\"class和struct的区别\">Class和Struct的区别</h3><p>与C#、Java不同，C++中Class和Struct几乎一样，只是关键字不同和使用习惯不同而已。唯一的微小区别就是，使用Class的默认访问模式为private，而struct的默认访问模式是public。</p><h3 id=\"友元\">友元</h3><p>友元允许其他类或函数访问自己的非公有成员，这个大家都知道就不多说了。需要注意的是友元关系不存在传递性，也就是说子类的友元并不能理所当然的访问父类。而且想要所有重载函数成为友元关系，必须为每个重载函数做一次友元声明。</p><p>不过在编译时，友元的声明仅仅指定了访问的权限，它只是标记编译的语法规则好让编译器在语法检查时能知道友元标记的存在，实际上编译器并没有做任何内存上和寄存器上的修改。</p><h3 id=\"构造函数初始值列表\">构造函数初始值列表</h3><pre><code class=\"language-c\">class testClass{  public:      testClass(int ii);  private:      int i;      const int ci;      int &amp;ri;}testClass::testClass(intii):    i(ii),ci(ii),ri(i){  //do something}</code></pre><p>我们在类中常使用以上这种构造函数来初始化成员，其实这就相当于成员的初始化顺序，即先初始化i，然后ci，然后ri。</p><h3 id=\"隐式的类构造转换\">隐式的类构造转换</h3><p>在对象构造时，也会出现隐式的构造情况，例如：</p><pre><code class=\"language-c\">class Test_data{   Test_data(const string str);}string test_str = \"test\";Vector&lt;Test_data&gt; item;item.push(test_str);</code></pre><p>如果构造函数只接受一个实参，则实际上它同时也定义了转换为此类类型的隐式转换机制，我们把这种构造函数称为，转换构造函数（converting constructor）。</p><p>上面例子中传入的string对象从而引发了Test_data的转换构造函数，构造出对象后再传入，其实这些隐式转换和构造都是在编译时离线计算的，根本不会放到运行时去发生。</p><p>如果你不想让隐式构造发生，可以通过在构造函数前加 explicit 声明来阻止隐式转换，如下：</p><pre><code class=\"language-c\">class Test_data{   explicit Test_data(const string str);}string test_str = \"test\";Vector&lt;Test_data&gt; item;item.push_back(test_str); // 编译错误item.push_back(Test_data(test_str)); // 编译正确</code></pre><p>声明了explicit的构造函数，只能以直接初始化的形式使用，编译器将不会再进行隐式的自动转换这些构造函数。</p><h3 id=\"io库\">IO库</h3><p>这里有些零散的知识需要注意下。</p><p>IO库定义了很多标记，这些标记可以帮助我们访问和操作流，例如由于流可能处于错误状态，我们在操作之前先去检查它是否处于良好状态。其中badbit标记相对用的比较多，它表示系统级错误，例如不可恢复的读写错误。通常情况下，一旦badbit被置位，流就无法再使用了。</p><p>IO流有缓冲机制，这可以提升IO的性能，当刷新时才将数据写入到文件中。</p><p>导致缓冲刷新的几种情况为：</p><ol>  <li>程序正常结束，main函数return操作。</li>  <li>缓冲区满时，需要刷新缓冲。</li>  <li>使用操作符endl来显式刷新缓冲区。</li>  <li>使用操作符unitbuf设置流的内部状态，清空缓冲区。</li>  <li>一个输出流被关联到另一个流时，输出流会被刷新。</li></ol><p>注意，如果程序崩溃了，输出流的缓冲区是不会被刷新的，这也是为什么崩溃时部分数据没有被写入文件的原因。</p><h3 id=\"顺序容器\">顺序容器</h3><p>顺序容器指，vector，deque，list，array，string，它们都可以用迭代器访问元素。如果我们不需要写访问元素，则应该使用cbegin和cend来获取常量迭代指针。</p><p>顺序容器中有一个方法比较有趣assign（array除外），它可以用参数所指定的元素（拷贝形式）替换容器中的所有元素。seq.assign(b,e); // 将seq替换为迭代器b到e范围内的元素seq.assign(il); // 将seq替换为容器列表il中的元素seq.assign(il); // 将seq替换为n个t值的元素</p><p>注意，当我们用一个对象来初始化容器，或者将一个对象插入到容器中时，实际上放入到容器中的是对象的拷贝，而不是对象本身。就像我们将一个对象传递给非引用参数一样，容器中的元素与提供值的对象之间没有任何关联。</p><p>另外我们也要注意向容器中添加元素或删除元素的操作，可能会使得指向容器的指针、引用、迭代器失效，进而导致运行时错误。</p><h3 id=\"泛型算法\">泛型算法</h3><p>标准库并没有给每个容器添加大量功能，而是提供了一组算法，这些算法大多是通用算法，可以独立于任何特定的容器。</p><p>归纳总结下来，泛型算法有4个特点：</p><ol>  <li>大多是通用算法，可以独立于任何特定的容器</li>  <li>虽然独立于任何容器，但有些算法依赖于元素类型（例如累加算法依赖于带有加法运算的对象类型）。</li>  <li>不会直接操作容器，而是运行于迭代器之上，执行的是迭代器的操作。</li>  <li>算法可能改变容器中保存的值，或移动容器中的元素，但永远不会直接添加或者删除元素。</li></ol><h3 id=\"lambda函数\">lambda函数</h3><p>当定义一个lambda函数时，编译器生成一个与lambda对应的新（未命名的）类类型。</p><p>也就是说当向一个函数传递一个lambda函数时，编译器同时定义了一个新类型和该类型的一个对象，传递的参数就是此编译器生成的类类型的未命名对象，而不是传入的对象。</p><pre><code class=\"language-c\">void func1(){  int v1 = 41;  auto f = [v1] {return v1;}; // 值捕获  v1 = 0;  auto j = f(); // j 为 41  auto f2 = [&amp;v1] {return v1;} // 引用捕获  v1 = 2;  auto j = f2(); // j 为 2}transform(v1.begin(), vi.end(), vi.begin(), [](int i) -&gt; int { if (i &lt; 0) return -i; else return i; }); // lambda函数指定了int返回值和int形参</code></pre><p>注意，如上代码中，如果lambda形参为引用则需要我们注意实参的生命周期，因为在lambda执行时，如果该对象已经被销毁则可能引起运行时错误。</p><p>除了使用lambda创建快速创建函数外，也可以使用标准库里bind函数来生成函数，例如：</p><pre><code class=\"language-c\">// 格式： auto newCallable = bind(callable, arg_list);void func1(int a, int b){  return a + b;}int aa = 1;int bb = 2;auto newFunc1 = bind(func1, aa, bb); // 生成一个新的可调用对象来适配算法auto wc = find_if(words.begin(), words.end(), newFunc1); // bind生成了一个适配泛型算法的函数</code></pre><p>bind可以看做是一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484770&amp;idx=1&amp;sn=417618b18d6a0bf34b5fa720031f6312&amp;chksm=fc226065cb55e973587b7a3e372b71acf1def7cb7b04ce3ba2d43a5e4871582f72459bcb962d&amp;token=283688006&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/06/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B030",
            
            
            
            "tags": ["读书笔记","前端技术"],
            
            "date_published": "2021-06-26T00:00:00+08:00",
            "date_modified": "2021-06-26T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/06/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B029",
            "title": "读书笔记(二十九) 《装载、链接与库》#2 静态链接过程",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：看此书的起源是我在了解Linux注入技术的时候翻阅到的，由于注入技术需要用到很多ELF格式的内容，很多网络上的技术文章都指向了同一本书。也刚好周围的同事有此书，便翻阅了一下，这一番翻阅打开了我对程序世界的又一扇大门。很快我就自己买了此书并阅读完成，整本书给我很大的震撼，让我对程序从编译到链接到装载有了更深刻的认识。我把我的整个学习过程以及对书本的理解，用自己的语言和自己画的图表达出来，让读者能够更容易接受到我所学的知识。目标：了解编译过程了解动态库和静态库的装载细节了解可执行程序装载和执行过程了解可执行文件和动态库的数据格式疑问：c/c++编译器是如何将cpp编译为可执行文件的？多个c/c++文件是如何编译成一个可执行文件的？操作系统内存是如何初始化和管理的？动态库和静态库的链接和装载过程是怎样的？操作系统的用户态和内核态是如何运作的？正文：前文《链接、装载与库-回顾基础》说了计算机设备的架构，硬盘的存储方式，内存虚拟空间的意义，多线程调度和安全的本质，以及代码编译的整体流程。我们平常用C++代码编译出来的可执行文件、静态库、动态库，看上去它们的不一样的东西，其实它们的数据格式是相同的。现代流行的操作系统分Windows和Linux两种，因此我们主要介绍这两种平台下的文件格式。在Windows下的可执行文件格式称为PE（Portable Executable），在Linux下则称为ELF（Executable Linkable Format），其实它们都是COFF（Common file format）格式的变种。不光是可执行文件，动态链接库（DLL，Dynamic Linking Library）和静态链接库（Static Linking Library）都是按照可执行文件格式存储的。静态链接库稍有不同，它把很多目标文件捆绑在一起形成一个文件，可以简单把它理解为一个包含很多目标文件的文件包。单个目标文件简单的结构介绍int global_init_var = 84; // 已初始化全局变量int global_uninit_var; // 未初始化全局变量//全局函数void func1( int i){    printf(\"%d\\n\",i);}//入口函数int main(void){    static int static_var = 85; // 已初始化静态变量    static int static_var2; // 未初始化静态变量    int a = 1; // 已初始化局部变量    int b; // 未初始化局部变量    func1(static_var + static_var2 + a + b); // 调用全局函数    return 0;}我们先以目标文件为例，来举一个简单的文件ELF结构。目标文件是最常见的编译单位，它将指令代码、数据以Section的形式存储在文件中。上图中我们简单说明了程序、已初始化全局数据、未初始化全局数据在目标文件中的存放位置。其中.data段保存的是已初始化了的全局静态变量和局部静态变量，这些数据是可写可读的，而只读数据则存放在.rodata中，例如const修饰的变量和字符串常量。用.rodata单独保存只读数据能够更加好的保护数据，任何修改.rodata中的数据都会作为非法操作处理。类似的Section段有很多，我们列举一些重要的来说：.bss：包含程序运行时未初始化的数据（全局变量和静态变量）。当程序运行时，这些数据初始化为0。.data和.data1，包含初始化的全局变量和静态变量。.dynamic，包含了动态链接的信息，包括链接器地址、需要的动态库、段地址信息，类型为SHT_DYNAMIC。.dynstr，包含了动态链接用的字符串，通常是和符号表中的符号关联的字符串，类型为SHT_STRTAB。.dynsym，包含动态链接函数符号表和地址，没有地址的则为0，标志SHF_ALLOC，类型为SHT_DYNSYM。.fini，正常结束时要执行的析构程序，类型为SHT_PROGBITS。.got，全局偏移表(global offset table)，类型为SHT_PROGBITS。.hash，包含符号hash表，用于快速查找函数名的。标志SHF_ALLOC，类型为SHT_HASH。.init，程序运行或加载时初始化程序。类型为SHT_PROGBITS。.interp，该节内容是一个字符串，指定了程序链接器的路径名。如果文件中有一个可加载的segment包含该节，属性就包含SHF_ALLOC，否则不包含。类型为SHT_PROGBITS。.plt 过程链接表（Procedure Linkage Table），类型为SHT_PROGBITS。.rodata和.rodata1， 包含只读数据，组成不可写的段。标志SHF_ALLOC，类型为SHT_PROGBITS。.shstrtab，包含section的名字，真正的字符串存储在.shstrtab中，其他都是索引。类型为SHT_STRTAB。.strtab，包含字符串，通常是符号表中符号对应的变量名字和函数名。类型为SHT_STRTAB。.symtab，Symbol Table，符号表。包含了所有符号信息，包括变量、函数、定位、重定位符号定义和引用时需要的信息。符号表是一个数组，Index 0 第一个入口，它的含义是undefined symbol index， STN_UNDEF。.rela.dyn，包含了除PLT以外的 RELA 类型的动态库重定向信息。.rela.plt，包含了PLT中的 RELA 类型的动态库重定向信息.rela.text 代码重定位表.rela.data 数据重定位表.line，调试时的行号表，即源代码行号与编译后指令的对应表如果我们想自定义些Section，可以用__attribute__((section(“name”)))把相应的变量或函数放到“name”作为段名的段中，例如：__attribute__((section(\"GlobalTest\"))) int global = 42;__attribute__((section(\"FuncTest\"))) void foo(){}那么ELF结构在文件中是以怎样的形式存在的呢？下面是ELF文件的大致布局（来源ELF描述文档 http://www.skyfree.org/linux/references/ELF_Format.pdf）左边是ELF的链接视图，可以理解为是目标代码文件的内容布局。右边是ELF的执行视图，可以理解为可执行文件的内容布局。目标代码文件（编译过程中的.o文件）的内容是由Section组成的，而可执行文件（二进制可执行文件或库文件）的内容是由Segment段组成的。ELF header的定义可以在 /usr/include/elf.h 中找到。Elf32_Ehdr是32位 ELF header的结构体。Elf64_Ehdr是64位ELF header的结构体。    （Linker and Libraries Guide：https://docs.oracle.com/cd/E19120-01/open.solaris/819-0690/chapter6-43405/index.html）其中e_ident的前4个字节是魔数，魔数是固定的，它用来确认文件的类型，操作系统在加载可执行文件时会确认魔数是否正确，如果不正确则说明文件不是ELF格式，则拒绝加载。ELF的整体结构现在我们知道了，ELF Header描述了Program header table 和 Section header table，Program header table 又描述了Segment摘要，Section header table 又描述了Section摘要。那么 Program header table 和 Section header table 究竟是怎么去描述Segment和Section摘要的呢？前面我们说ELF Header里已经有了Program header table 和 Section header table的位置的偏移量，有了它们每个table的大小，以及有多少个table，我们就能知道Program header table 和 Section header table的起始地址、每个结构体的位置、以及它们的范围。也就是说，每个Program header table 和 Section header table是一个由固定大小结构体组成的数组，于是可以根据ELF Header来确定它们的数据内容和范围。我们来看下它们的结构体，Program header结构：Section header结构：这里特别从重要的几个Section中挑出几个特别重要的字段来重点说明下。重定位表任何需要重定位的Section都需要一个重定位表，例如.text需要.rel.text来辅助重定位.data需要.rel.data来辅助重定位.rela.dyn，用于动态重定位变量的表.rela.plt，则用于动态重定位函数的表重定位分为两种  一种是静态编译时重定位，在编译时重定位  另一种是动态加载时重定位，在执行时重定位重定位我们放后面详细介绍字符串表字符串主要用于匹配函数和变量名，但不同用途的字符串也会分开存放。.shstrtab，包含section名字的字符串存储在.shstrtab中.strtab，包含符号表中符号对应的变量名字和函数名的字符串.symtab，Symbol Table符号表，包含了所有符号信息，包括变量、函数、定位、重定位符号定义和引用时需要的信息，这里所有的字符串都只有索引指向.strtab中的内容。.dynstr，包含了动态链接用的字符串，通常是和符号表中的符号关联的字符串.hash，包含符号hash表，用于快速查找函数名和变量名字符串表中包含了存储字符串的表、存储索引的表、以及hash表，它们的用途分别是：  存储字符串的表目的是存储真实字符串数据  其他表有需要字符串的都用索引表示以节省内存  hash表则主要用于快速查找和比较字符串符号表符号表主要用于记录函数名、变量名和地址，例如：.symtab，Symbol Table符号表，包含了所有符号信息，包括变量、函数、定位、重定位符号定义和引用时需要的信息.dynsym，包含动态链接函数符号表和地址，没有地址的则为0这两者的区别是，symtab记录了所有符号，包括内部的和外部的函数和变量，而.dynsym则只包含了对外动态加载时需要提供的函数和变量，可以.dynsym是.symtab的阉割版。symtab的数据结构为typedef struct{  Elf32_Word st_name; // 符号名在符号表中的索引  Elf32_Addr st_value; // 符号相对应的值，是地址或者其他值  Elf32_Word st_size; // 符号大小，包含数据的符号，该值为占用大小  unsigned char st_info; // 符号类型和绑定信息  unsigned char st_other; // 无用，值为0  Elf32_Half st_shndx; // 符号所在段的索引} Elf32_Sym;函数签名规则前面说函数名就是符号名，会存储在符号表中，但C++中函数名常常会有相同的时候，因此编译器在编译时会对函数名进行处理，以区别不同范围内的函数。我们称这种改变符号名的机制为函数签名（Function Signature）。签名后的函数名，包含了函数名、它的参数类型、它所在的类和命名空间以及其他信息。签名规则每种编译器都不一样，GCC编译器的规则为，所有符号以“_Z”开头，对于嵌套的名字后面紧跟“N”，然后是各个名称空间和类的名字，每个名字前是名字字符串长度，再以“E”结尾，“E”后面是参数列表，对于int类型来说就是字母“i”，float类型来说就是字母“f”，以此类推。来举几个例子：* int func(int)  签名后--&gt; _Z4funci --&gt; _Z开头，4个字符的函数名func，参数是i整型* float func(float) 签名后--&gt; _Z4funcf --&gt; _Z开头，4个字符的函数名func，参数是f浮点型* int C::func(int) 签名后--&gt; _ZN1C4funcEi --&gt; _Z开头，嵌套1个字符C，接4个字符的函数名func，E结尾，参数是i整型* int C::C2::func(int) 签名后--&gt; _ZN1C2C24funcEi --&gt; _Z开头，嵌套1个字符C，再嵌套2个字符C2，接4个字符的函数名func，E结尾，参数是i整型* int N::func(int) 签名后--&gt; _ZN1N4funcEi --&gt; _Z开头，嵌套1个字符N，接4个字符函数名func，E结尾，参数是i整型* int N::C::func(int) 签名后--&gt; _ZN1N1C4funcEi --&gt; _Z开图，嵌套1个字符N，再嵌套1个字符C，接4个字符func，E结尾，参数是i整型由于不同编译器的签名规则不同，所以当我们要使用C语言写的外部函数时，就需要告诉编译器使用C语言的命名规则extern \"C\"{  int func(int);  int var;}如果我们在C++中没有使用extern “C”申明会如何？如果我们没有正确告知编译器外部引用函数的编译器规则，则在链接器链接时就会因为符号不匹配而无法链接，因此对于C++引用C函数来说，必须使用extern “C”来声明编译器规则。强符号弱符号，强引用弱引用通常我们定义的变量和函数都是强符号和强引用，意思是当符号冲突时会直接覆盖原来的符号，而弱符号和弱引用则是当符号冲突时不覆盖原来的。在编写通用库、共享库程序时，弱符号和弱引用，可以起到替换和被替换的作用。例如库中定义的弱符号被用户定义的强符号覆盖，从而使得程序可以使用自定义版本的库函数；或者扩展某个功能模块时，弱引用被新模块接口覆盖，从而使得程序可以在正常使用的情况下扩展功能。attribute((week)) week_var = 2;attribute((weekref)) void func();Linux提供了几个工具来帮助我们了解ELF格式内容  readelf，可以帮助我们读取ELF文件中Section的内容  objdump，可以帮助我们翻译二进制指令和数据  c++filt，可以帮助我们解析被修饰过的名称  编译时通过加 -g 参数，可以让编译器在产生目标文件时加上调试信息  strip，可以通过这个命令把ELF中的调试信息都去除静态链接静态链接的过程其实就是把目标文件中的数据归档到一个文件中，其归档步骤有两步。第一步，空间与地址分配扫描所有输入的目标文件，获取它们的各Section的数据，合并各段数据并建立映射关系。同时把所有目标文件中的符号和符号定义都收集起来放到全局符号表中。第二步，符号解析与重定位根据第一步收集到的信息，包括Section和符号表信息，进行符号解析与重定位，调整代码中的地址。在重定位时，由于各个符号的在Section内的位置是相对固定的，所以只要计算出Section的偏移量就可以知道合并后的符号实际位置。在第一步完成空间分配后，就可以确定所有符号的虚拟地址了，但这时目标文件内含有其他目标文件函数，则需要另外通过符号表来重定位。由于在完成空间分配后，全局符号表内的符号都确定了地址，因此在重定位时可以使用全局符号表中的地址替换未定位地址。每个目标文件都可能定义一些符号，也可能引用到定义在其他目标文件的符号。链接器在重定位的过程中，每个重定位的入口都是一个符号的引用，当需要对某个符号的引用进行重定位时，就要确定这个符号的目标地址。这时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位。注意：在未确定外部符号地址时，编译器把这部分地址暂时用“0x00000000”和“0xFFFFFFFC”来代替，在链接时再由链接器将计算好的地址填充进来。重定位表我们前面说过每个需要重定位的Section都有一个重定位表，例如“.text”有“.rel.text”，“.data”有“.rel.data”。每个重定位表里的数据为：typedef struct{  Elf32_Addr r_offset; // 相对于当前Section的相对位置  Elf32_Word r_info; // 低8位表示重定位入口类型，高24位表示重定位入口符号的索引}简单来说就是，重定位表数据中有一个需要重定位的位置和一个重定位的符号名字符串索引，有了这两个数据，链接器就能在链接时从全局符号表中找到合并后的真实虚拟地址。在符号地址修正时，也分绝对寻址修正和相对寻址修正，它们的区别是绝对寻址修正后的地址为该符号的实际虚拟地址，相对寻址修正后的地址为符号距离被修正位置的地址差，因此它们分别服务的是不同类型的指令。全局构造和析构表.init段中保存的初始化代码。当一个程序开始运行时在main函数调用之前Glibc的初始化程序会执行这个段中的代码。.fini段中保存的析构代码。当一个进程的main函数正常退出时Glibc会安排执行这个段中的代码。这两个段有特别的目的，.init在main函数前执行，.fini则在main函数后执行，利用这两个特性C++的全局构造和析构函数就由此实现。将不同编译器的编译结果链接那么有没有可能将不同编译器的编译结果链接成一个可执行文件呢？其实可以的，但非常困难。目标文件必须满足以下条件：  目标文件的数据格式兼容  符号签名规则兼容  变量的内存分布方式兼容  函数调用方式兼容  堆栈分布方式兼容  寄存器使用阅读兼容我们把这种链接时的兼容性相关内容称为ABI（Application Binary Interface）。与API不同的是，ABI是指二进制层面的接口兼容性更加严格，而API则只是源代码级别上的的接口。其实不同编译器链接成可执行文件的最大问题就是，各种硬件平台、编程语言、编译器、链接器和操作系统之间的ABI互不兼容。由于ABI的不兼容，导致各个目标文件之间无法互相链接。静态库与链接其实静态库可以简单看成一组目标文件的集合，在制作静态库时只是将所有目标文件打包压缩后归档为一个文件而已。Linux下可以使用“ar”这个工具命令来归档目标文件，“ar”压缩程序将所有目标文件压缩到一起并对其进行编号和索引，以便于查找和检索，就形成了xxx.a静态库文件。Visual C++也提供了类似ar的工具，叫lib.exe，这个程序可以用来创建、提取、查看.lib文件中的内容。在静态库链接时，Linux下的链接器ld会自动寻找需要的静态库，并从中解压出来目标文件，再最终将这些目标文件链接在一起成为可执行文件。从这个规则上看来，我们在编写静态库的时候，最好是每个函数独立存放在一个目标文件中，因此这样可以尽量减少空间浪费，因为没有被用到的目标文件就不会链接到最终的输出文件中。中间件BFD库我们说各种操作系统平台都遵循类似ELF格式的文件格式，虽然是相似的ELF格式但在不同软硬件平台都有着不同的变种。种种差异导致编译器和链接器很难处理不同平台之间的目标文件，因此最好有一种统一的接口来处理不同格式的文件。BFD库（Binary File Dexcriptor library）就是为了这个目的存在的，它的目标就是用一种统一接口来处理不同的目标文件格式。现在GCC编译器、链接器ld、调试器gdb、binutils等工具都是通过BFD库来处理文件，而不直接操作目标文件。这样做的好处是将编译器和链接器与具体的目标文件格式隔离开来，一旦我们需要支持一种新的目标文件格式，只需要在BFD库里添加一种格式就可以了，而不需要再去修改编译器和链接器。已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484763&amp;idx=1&amp;sn=f1b3d678c1309a66d44b64b7ff22a002&amp;chksm=fc22605ccb55e94a53558e85fdbe196fc58612fe20c88f35f8c0f4098e240ef48bcd2da099b0&amp;token=535520395&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h3 id=\"背景\">背景：</h3><p>看此书的起源是我在了解Linux注入技术的时候翻阅到的，由于注入技术需要用到很多ELF格式的内容，很多网络上的技术文章都指向了同一本书。也刚好周围的同事有此书，便翻阅了一下，这一番翻阅打开了我对程序世界的又一扇大门。</p><p>很快我就自己买了此书并阅读完成，整本书给我很大的震撼，让我对程序从编译到链接到装载有了更深刻的认识。</p><p>我把我的整个学习过程以及对书本的理解，用自己的语言和自己画的图表达出来，让读者能够更容易接受到我所学的知识。</p><h3 id=\"目标\">目标：</h3><p>了解编译过程</p><p>了解动态库和静态库的装载细节</p><p>了解可执行程序装载和执行过程</p><p>了解可执行文件和动态库的数据格式</p><h3 id=\"疑问\">疑问：</h3><p>c/c++编译器是如何将cpp编译为可执行文件的？</p><p>多个c/c++文件是如何编译成一个可执行文件的？</p><p>操作系统内存是如何初始化和管理的？</p><p>动态库和静态库的链接和装载过程是怎样的？</p><p>操作系统的用户态和内核态是如何运作的？</p><h3 id=\"正文\">正文：</h3><p>前文《链接、装载与库-回顾基础》说了计算机设备的架构，硬盘的存储方式，内存虚拟空间的意义，多线程调度和安全的本质，以及代码编译的整体流程。</p><p>我们平常用C++代码编译出来的可执行文件、静态库、动态库，看上去它们的不一样的东西，其实它们的数据格式是相同的。</p><p>现代流行的操作系统分Windows和Linux两种，因此我们主要介绍这两种平台下的文件格式。在Windows下的可执行文件格式称为PE（Portable Executable），在Linux下则称为ELF（Executable Linkable Format），其实它们都是COFF（Common file format）格式的变种。</p><p>不光是可执行文件，动态链接库（DLL，Dynamic Linking Library）和静态链接库（Static Linking Library）都是按照可执行文件格式存储的。</p><p>静态链接库稍有不同，它把很多目标文件捆绑在一起形成一个文件，可以简单把它理解为一个包含很多目标文件的文件包。</p><p>单个目标文件简单的结构介绍</p><pre><code class=\"language-c\">int global_init_var = 84; // 已初始化全局变量int global_uninit_var; // 未初始化全局变量//全局函数void func1( int i){    printf(\"%d\\n\",i);}//入口函数int main(void){    static int static_var = 85; // 已初始化静态变量    static int static_var2; // 未初始化静态变量    int a = 1; // 已初始化局部变量    int b; // 未初始化局部变量    func1(static_var + static_var2 + a + b); // 调用全局函数    return 0;}</code></pre><p>我们先以目标文件为例，来举一个简单的文件ELF结构。目标文件是最常见的编译单位，它将指令代码、数据以Section的形式存储在文件中。</p><p>上图中我们简单说明了程序、已初始化全局数据、未初始化全局数据在目标文件中的存放位置。其中.data段保存的是已初始化了的全局静态变量和局部静态变量，这些数据是可写可读的，而只读数据则存放在.rodata中，例如const修饰的变量和字符串常量。用.rodata单独保存只读数据能够更加好的保护数据，任何修改.rodata中的数据都会作为非法操作处理。</p><p>类似的Section段有很多，我们列举一些重要的来说：</p><pre><code class=\"language-c\">.bss：包含程序运行时未初始化的数据（全局变量和静态变量）。当程序运行时，这些数据初始化为0。.data和.data1，包含初始化的全局变量和静态变量。.dynamic，包含了动态链接的信息，包括链接器地址、需要的动态库、段地址信息，类型为SHT_DYNAMIC。.dynstr，包含了动态链接用的字符串，通常是和符号表中的符号关联的字符串，类型为SHT_STRTAB。.dynsym，包含动态链接函数符号表和地址，没有地址的则为0，标志SHF_ALLOC，类型为SHT_DYNSYM。.fini，正常结束时要执行的析构程序，类型为SHT_PROGBITS。.got，全局偏移表(global offset table)，类型为SHT_PROGBITS。.hash，包含符号hash表，用于快速查找函数名的。标志SHF_ALLOC，类型为SHT_HASH。.init，程序运行或加载时初始化程序。类型为SHT_PROGBITS。.interp，该节内容是一个字符串，指定了程序链接器的路径名。如果文件中有一个可加载的segment包含该节，属性就包含SHF_ALLOC，否则不包含。类型为SHT_PROGBITS。.plt 过程链接表（Procedure Linkage Table），类型为SHT_PROGBITS。.rodata和.rodata1， 包含只读数据，组成不可写的段。标志SHF_ALLOC，类型为SHT_PROGBITS。.shstrtab，包含section的名字，真正的字符串存储在.shstrtab中，其他都是索引。类型为SHT_STRTAB。.strtab，包含字符串，通常是符号表中符号对应的变量名字和函数名。类型为SHT_STRTAB。.symtab，Symbol Table，符号表。包含了所有符号信息，包括变量、函数、定位、重定位符号定义和引用时需要的信息。符号表是一个数组，Index 0 第一个入口，它的含义是undefined symbol index， STN_UNDEF。.rela.dyn，包含了除PLT以外的 RELA 类型的动态库重定向信息。.rela.plt，包含了PLT中的 RELA 类型的动态库重定向信息.rela.text 代码重定位表.rela.data 数据重定位表.line，调试时的行号表，即源代码行号与编译后指令的对应表</code></pre><p>如果我们想自定义些Section，可以用__attribute__((section(“name”)))把相应的变量或函数放到“name”作为段名的段中，例如：</p><pre><code class=\"language-c\">__attribute__((section(\"GlobalTest\"))) int global = 42;__attribute__((section(\"FuncTest\"))) void foo(){}</code></pre><p>那么ELF结构在文件中是以怎样的形式存在的呢？</p><h3 id=\"下面是elf文件的大致布局\">下面是ELF文件的大致布局</h3><p>（来源ELF描述文档 http://www.skyfree.org/linux/references/ELF_Format.pdf）</p><p>左边是ELF的链接视图，可以理解为是目标代码文件的内容布局。右边是ELF的执行视图，可以理解为可执行文件的内容布局。目标代码文件（编译过程中的.o文件）的内容是由Section组成的，而可执行文件（二进制可执行文件或库文件）的内容是由Segment段组成的。</p><p>ELF header的定义可以在 /usr/include/elf.h 中找到。Elf32_Ehdr是32位 ELF header的结构体。Elf64_Ehdr是64位ELF header的结构体。    （Linker and Libraries Guide：https://docs.oracle.com/cd/E19120-01/open.solaris/819-0690/chapter6-43405/index.html）</p><p>其中e_ident的前4个字节是魔数，魔数是固定的，它用来确认文件的类型，操作系统在加载可执行文件时会确认魔数是否正确，如果不正确则说明文件不是ELF格式，则拒绝加载。</p><h3 id=\"elf的整体结构\">ELF的整体结构</h3><p>现在我们知道了，ELF Header描述了Program header table 和 Section header table，Program header table 又描述了Segment摘要，Section header table 又描述了Section摘要。</p><h3 id=\"那么-program-header-table-和-section-header-table-究竟是怎么去描述segment和section摘要的呢\">那么 Program header table 和 Section header table 究竟是怎么去描述Segment和Section摘要的呢？</h3><p>前面我们说ELF Header里已经有了Program header table 和 Section header table的位置的偏移量，有了它们每个table的大小，以及有多少个table，我们就能知道Program header table 和 Section header table的起始地址、每个结构体的位置、以及它们的范围。</p><p>也就是说，每个Program header table 和 Section header table是一个由固定大小结构体组成的数组，于是可以根据ELF Header来确定它们的数据内容和范围。</p><p>我们来看下它们的结构体，Program header结构：</p><p>Section header结构：</p><p>这里特别从重要的几个Section中挑出几个特别重要的字段来重点说明下。</p><h3 id=\"重定位表\">重定位表</h3><p>任何需要重定位的Section都需要一个重定位表，例如</p><p>.text需要.rel.text来辅助重定位.data需要.rel.data来辅助重定位.rela.dyn，用于动态重定位变量的表.rela.plt，则用于动态重定位函数的表</p><p>重定位分为两种</p><ol>  <li>一种是静态编译时重定位，在编译时重定位</li>  <li>另一种是动态加载时重定位，在执行时重定位</li></ol><h3 id=\"重定位我们放后面详细介绍\">重定位我们放后面详细介绍</h3><h3 id=\"字符串表\">字符串表</h3><p>字符串主要用于匹配函数和变量名，但不同用途的字符串也会分开存放。</p><p>.shstrtab，包含section名字的字符串存储在.shstrtab中.strtab，包含符号表中符号对应的变量名字和函数名的字符串.symtab，Symbol Table符号表，包含了所有符号信息，包括变量、函数、定位、重定位符号定义和引用时需要的信息，这里所有的字符串都只有索引指向.strtab中的内容。.dynstr，包含了动态链接用的字符串，通常是和符号表中的符号关联的字符串.hash，包含符号hash表，用于快速查找函数名和变量名</p><p>字符串表中包含了存储字符串的表、存储索引的表、以及hash表，它们的用途分别是：</p><ol>  <li>存储字符串的表目的是存储真实字符串数据</li>  <li>其他表有需要字符串的都用索引表示以节省内存</li>  <li>hash表则主要用于快速查找和比较字符串</li></ol><h3 id=\"符号表\">符号表</h3><p>符号表主要用于记录函数名、变量名和地址，例如：</p><p>.symtab，Symbol Table符号表，包含了所有符号信息，包括变量、函数、定位、重定位符号定义和引用时需要的信息.dynsym，包含动态链接函数符号表和地址，没有地址的则为0</p><p>这两者的区别是，symtab记录了所有符号，包括内部的和外部的函数和变量，而.dynsym则只包含了对外动态加载时需要提供的函数和变量，可以.dynsym是.symtab的阉割版。</p><p>symtab的数据结构为</p><pre><code class=\"language-c\">typedef struct{  Elf32_Word st_name; // 符号名在符号表中的索引  Elf32_Addr st_value; // 符号相对应的值，是地址或者其他值  Elf32_Word st_size; // 符号大小，包含数据的符号，该值为占用大小  unsigned char st_info; // 符号类型和绑定信息  unsigned char st_other; // 无用，值为0  Elf32_Half st_shndx; // 符号所在段的索引} Elf32_Sym;</code></pre><h3 id=\"函数签名规则\">函数签名规则</h3><p>前面说函数名就是符号名，会存储在符号表中，但C++中函数名常常会有相同的时候，因此编译器在编译时会对函数名进行处理，以区别不同范围内的函数。</p><p>我们称这种改变符号名的机制为函数签名（Function Signature）。签名后的函数名，包含了函数名、它的参数类型、它所在的类和命名空间以及其他信息。</p><p>签名规则每种编译器都不一样，GCC编译器的规则为，所有符号以“_Z”开头，对于嵌套的名字后面紧跟“N”，然后是各个名称空间和类的名字，每个名字前是名字字符串长度，再以“E”结尾，“E”后面是参数列表，对于int类型来说就是字母“i”，float类型来说就是字母“f”，以此类推。</p><p>来举几个例子：</p><pre><code class=\"language-c\">* int func(int)  签名后--&gt; _Z4funci --&gt; _Z开头，4个字符的函数名func，参数是i整型* float func(float) 签名后--&gt; _Z4funcf --&gt; _Z开头，4个字符的函数名func，参数是f浮点型* int C::func(int) 签名后--&gt; _ZN1C4funcEi --&gt; _Z开头，嵌套1个字符C，接4个字符的函数名func，E结尾，参数是i整型* int C::C2::func(int) 签名后--&gt; _ZN1C2C24funcEi --&gt; _Z开头，嵌套1个字符C，再嵌套2个字符C2，接4个字符的函数名func，E结尾，参数是i整型* int N::func(int) 签名后--&gt; _ZN1N4funcEi --&gt; _Z开头，嵌套1个字符N，接4个字符函数名func，E结尾，参数是i整型* int N::C::func(int) 签名后--&gt; _ZN1N1C4funcEi --&gt; _Z开图，嵌套1个字符N，再嵌套1个字符C，接4个字符func，E结尾，参数是i整型</code></pre><p>由于不同编译器的签名规则不同，所以当我们要使用C语言写的外部函数时，就需要告诉编译器使用C语言的命名规则</p><pre><code>extern \"C\"{  int func(int);  int var;}</code></pre><p>如果我们在C++中没有使用extern “C”申明会如何？如果我们没有正确告知编译器外部引用函数的编译器规则，则在链接器链接时就会因为符号不匹配而无法链接，因此对于C++引用C函数来说，必须使用extern “C”来声明编译器规则。</p><h3 id=\"强符号弱符号强引用弱引用\">强符号弱符号，强引用弱引用</h3><p>通常我们定义的变量和函数都是强符号和强引用，意思是当符号冲突时会直接覆盖原来的符号，而弱符号和弱引用则是当符号冲突时不覆盖原来的。在编写通用库、共享库程序时，弱符号和弱引用，可以起到替换和被替换的作用。例如库中定义的弱符号被用户定义的强符号覆盖，从而使得程序可以使用自定义版本的库函数；或者扩展某个功能模块时，弱引用被新模块接口覆盖，从而使得程序可以在正常使用的情况下扩展功能。<strong>attribute</strong>((week)) week_var = 2;<strong>attribute</strong>((weekref)) void func();</p><p>Linux提供了几个工具来帮助我们了解ELF格式内容</p><ol>  <li>readelf，可以帮助我们读取ELF文件中Section的内容</li>  <li>objdump，可以帮助我们翻译二进制指令和数据</li>  <li>c++filt，可以帮助我们解析被修饰过的名称</li>  <li>编译时通过加 -g 参数，可以让编译器在产生目标文件时加上调试信息</li>  <li>strip，可以通过这个命令把ELF中的调试信息都去除</li></ol><h3 id=\"静态链接\">静态链接</h3><p>静态链接的过程其实就是把目标文件中的数据归档到一个文件中，其归档步骤有两步。</p><h3 id=\"第一步空间与地址分配\">第一步，空间与地址分配</h3><p>扫描所有输入的目标文件，获取它们的各Section的数据，合并各段数据并建立映射关系。同时把所有目标文件中的符号和符号定义都收集起来放到全局符号表中。</p><h3 id=\"第二步符号解析与重定位\">第二步，符号解析与重定位</h3><p>根据第一步收集到的信息，包括Section和符号表信息，进行符号解析与重定位，调整代码中的地址。</p><h3 id=\"在重定位时由于各个符号的在section内的位置是相对固定的所以只要计算出section的偏移量就可以知道合并后的符号实际位置\">在重定位时，由于各个符号的在Section内的位置是相对固定的，所以只要计算出Section的偏移量就可以知道合并后的符号实际位置。</h3><h3 id=\"在第一步完成空间分配后就可以确定所有符号的虚拟地址了但这时目标文件内含有其他目标文件函数则需要另外通过符号表来重定位\">在第一步完成空间分配后，就可以确定所有符号的虚拟地址了，但这时目标文件内含有其他目标文件函数，则需要另外通过符号表来重定位。</h3><h3 id=\"由于在完成空间分配后全局符号表内的符号都确定了地址因此在重定位时可以使用全局符号表中的地址替换未定位地址\">由于在完成空间分配后，全局符号表内的符号都确定了地址，因此在重定位时可以使用全局符号表中的地址替换未定位地址。</h3><p>每个目标文件都可能定义一些符号，也可能引用到定义在其他目标文件的符号。链接器在重定位的过程中，每个重定位的入口都是一个符号的引用，当需要对某个符号的引用进行重定位时，就要确定这个符号的目标地址。这时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位。</p><h3 id=\"注意在未确定外部符号地址时编译器把这部分地址暂时用0x00000000和0xfffffffc来代替在链接时再由链接器将计算好的地址填充进来\">注意：在未确定外部符号地址时，编译器把这部分地址暂时用“0x00000000”和“0xFFFFFFFC”来代替，在链接时再由链接器将计算好的地址填充进来。</h3><h3 id=\"重定位表-1\">重定位表</h3><p>我们前面说过每个需要重定位的Section都有一个重定位表，例如“.text”有“.rel.text”，“.data”有“.rel.data”。</p><p>每个重定位表里的数据为：</p><pre><code class=\"language-c\">typedef struct{  Elf32_Addr r_offset; // 相对于当前Section的相对位置  Elf32_Word r_info; // 低8位表示重定位入口类型，高24位表示重定位入口符号的索引}</code></pre><p>简单来说就是，重定位表数据中有一个需要重定位的位置和一个重定位的符号名字符串索引，有了这两个数据，链接器就能在链接时从全局符号表中找到合并后的真实虚拟地址。</p><p>在符号地址修正时，也分绝对寻址修正和相对寻址修正，它们的区别是绝对寻址修正后的地址为该符号的实际虚拟地址，相对寻址修正后的地址为符号距离被修正位置的地址差，因此它们分别服务的是不同类型的指令。</p><h3 id=\"全局构造和析构表\">全局构造和析构表</h3><p>.init段中保存的初始化代码。当一个程序开始运行时在main函数调用之前Glibc的初始化程序会执行这个段中的代码。.fini段中保存的析构代码。当一个进程的main函数正常退出时Glibc会安排执行这个段中的代码。这两个段有特别的目的，.init在main函数前执行，.fini则在main函数后执行，利用这两个特性C++的全局构造和析构函数就由此实现。</p><h3 id=\"将不同编译器的编译结果链接\">将不同编译器的编译结果链接</h3><p>那么有没有可能将不同编译器的编译结果链接成一个可执行文件呢？其实可以的，但非常困难。</p><p>目标文件必须满足以下条件：</p><ol>  <li>目标文件的数据格式兼容</li>  <li>符号签名规则兼容</li>  <li>变量的内存分布方式兼容</li>  <li>函数调用方式兼容</li>  <li>堆栈分布方式兼容</li>  <li>寄存器使用阅读兼容</li></ol><p>我们把这种链接时的兼容性相关内容称为ABI（Application Binary Interface）。与API不同的是，ABI是指二进制层面的接口兼容性更加严格，而API则只是源代码级别上的的接口。其实不同编译器链接成可执行文件的最大问题就是，各种硬件平台、编程语言、编译器、链接器和操作系统之间的ABI互不兼容。由于ABI的不兼容，导致各个目标文件之间无法互相链接。</p><h3 id=\"静态库与链接\">静态库与链接</h3><p>其实静态库可以简单看成一组目标文件的集合，在制作静态库时只是将所有目标文件打包压缩后归档为一个文件而已。</p><p>Linux下可以使用“ar”这个工具命令来归档目标文件，“ar”压缩程序将所有目标文件压缩到一起并对其进行编号和索引，以便于查找和检索，就形成了xxx.a静态库文件。Visual C++也提供了类似ar的工具，叫lib.exe，这个程序可以用来创建、提取、查看.lib文件中的内容。</p><p>在静态库链接时，Linux下的链接器ld会自动寻找需要的静态库，并从中解压出来目标文件，再最终将这些目标文件链接在一起成为可执行文件。</p><p>从这个规则上看来，我们在编写静态库的时候，最好是每个函数独立存放在一个目标文件中，因此这样可以尽量减少空间浪费，因为没有被用到的目标文件就不会链接到最终的输出文件中。</p><h3 id=\"中间件bfd库\">中间件BFD库</h3><p>我们说各种操作系统平台都遵循类似ELF格式的文件格式，虽然是相似的ELF格式但在不同软硬件平台都有着不同的变种。种种差异导致编译器和链接器很难处理不同平台之间的目标文件，因此最好有一种统一的接口来处理不同格式的文件。BFD库（Binary File Dexcriptor library）就是为了这个目的存在的，它的目标就是用一种统一接口来处理不同的目标文件格式。</p><p>现在GCC编译器、链接器ld、调试器gdb、binutils等工具都是通过BFD库来处理文件，而不直接操作目标文件。这样做的好处是将编译器和链接器与具体的目标文件格式隔离开来，一旦我们需要支持一种新的目标文件格式，只需要在BFD库里添加一种格式就可以了，而不需要再去修改编译器和链接器。</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484763&amp;idx=1&amp;sn=f1b3d678c1309a66d44b64b7ff22a002&amp;chksm=fc22605ccb55e94a53558e85fdbe196fc58612fe20c88f35f8c0f4098e240ef48bcd2da099b0&amp;token=535520395&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/06/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B029",
            
            
            
            "tags": ["读书笔记","前端技术"],
            
            "date_published": "2021-06-20T00:00:00+08:00",
            "date_modified": "2021-06-20T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/06/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B028",
            "title": "读书笔记(二十八) 《C++ Primer》#3",
            "summary": "读书 书 看书 读后感",
            "content_text": "已发布在微信公众号上，点击跳转背景：我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意。第三是当我们在巩固时创造出了新的知识，那么这些新的知识和旧的知识将同时变成智慧融合到身体中。本系列基于《C++ Primer》学习，由于重点放在“重学”，我略过了滚瓜烂熟的部分，挑出以前常忽略的部分，以及记忆没有那么深刻的部分，特别是那些重要的但没有上心的部分。开始左值和右值这两个名词是从C语言继承过来的，原本是为了帮助记忆即：左值可以位于赋值语句的左侧，右值则不能。在C++语言中则没那么简单了，可以简单归纳为：当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。不同运算符对运算对象的要求不同，有的需要左值运算对象、有的则需要右值运算对象。因此有个重要原则：在需要右值的地方可以用左值来代替，但不能把右值当左值（也就是位置）使用。当一个左值被当成右值使用时，实际使用的是它的内容（就是值）。举几个例子：\t赋值运算符，是左值运算，因为结果是值（内容）\t取地址符，是右值运算，因为结果的是指针或地址\t解引用运算符、下标运算符，是左值运算，因为运算结果是值（内容）\t递增运算，是左值运算，因为运算结果是值（内容）关于后置++这里有个小提示，后置++版本会多浪费一个寄存器，但是编译器会帮我们优化掉，不过对于迭代器来说则不同，编译器通常不会优化迭代器的后置++，因此我们在使用迭代器后置++时要注意一下代码的优化。cout&lt;&lt; *iter++ &lt;&lt; endl;==&gt; 优化count&lt;&lt; *iter &lt;&lt; endl;++iter;sizeof运算符sizeof有离线计算和实时运算之分，通常情况下有些值在离线时就能知道的类型的大小，这时编译器都会在编译时就将其替换成固定值。举例说明sizeof运算符的结果取决于其作用类型：  对char类型表达式执行sizeof运算，结果为1。编译器离线计算  对引用类型执行sizeof，结果为被引用对象所占空间大小。编译器离线计算  对指针执行sizeof运算，结果为指针本身空间大小。编译器离线计算  对解引用指针执行sizeof，结果为指针指向的对象的空间大小。编译器离线计算  对数组执行sizeof运算，结果是整个数组所占空间大小。编译器离线计算  对string对象或vector对象执行sizeof运算，结果为该类型固定部分的大小。实时计算空间大小强制类型转换强制类型转换的根本目的就是告诉编译器，该变量的类型改变了，符合后面的逻辑运算，好让在编译器在编译时能够不误解逻辑运算，所以编译器并没有对内存内容做任何的改变，它只是为了迎合编译器。//旧式的强制类型转换type (expr); // 函数形式的强制类型转换(type) expr; // c语言风格的强制类型转换//新式的强制类型转换static_cast&lt;type&gt;(expression); // 静态转换dynamic_cast&lt;type&gt;(expression); // 运行时转换const_cast&lt;type&gt;(expression); // 常量转换reinterpret_cast&lt;type&gt;(expression); // 低阶类型转换强制转换分为，static_cast（静态转换），dynamic_cast（运行时转换），const_cast（常量转换），reinterpret_cast（低阶类型转换）4种  static_cast静态转换，直接将对象转换成指定类型对象。  dynamic_cast运行时转换，通常用于继承对象，运行时转换会先通过RTTI的方式判断是否能进行父子转换，如果可以再进行执行转换。  const_cast常量转换，只能改变运算对象的底层const无法改变具体类型，可以将const变量转换为非const变量，这样编译器就不再阻止我们对该对象进行写操作了。  reinterpret_cast低阶类型转换，通常为运算对象的位模式提供低层次上的解释。例如将int转换为char*等低阶模式。注意：使用reinterpret_cast比较危险的是，使用reinterpret_cast强制转换后编译器不会怀疑所转换的类型，如果类型错误则会因调用混乱而崩溃，而编译器在编译时不会发出任何警告或错误，因此reinterpret_cast通常适合比较底层转换工作。异常处理当异常被抛出时，首先在该函数中寻找匹配的catch子句，如果没有找到则终止该函数并在调用该函数的函数中继续寻找，以此类推沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。如果最终还是没能找到任何匹配的catch子句，程序会转到名为terminate的标准库函数中。该函数的行为与系统有关，一般情况下，执行该函数会导致程序非正常退出。如果当程序没有使用try catch语句且发生了异常，系统会直接调用terminate函数并终止当前程序的执行。分离式编译分离式编译的意思就是，多个源文件在编译中可以只顾自己编译，最后再统一链接到执行文件或库文件中。在分离式编译中，如果我们修改了其中一个源文件，那么只需要重新编译那个改动了的文件，再重新链接就可以。现代大多数编译器提供了分离式编译每个文件的机制，这一过程通常会产生一个后缀名是.obj（windows）或.o(UNIX)的目标文件，再用链接器将所有目标文件链接成可执行文件或库文件。参数传递解释下，实参就是要传递的数据变量，形参就是传递后函数中的参数变量。参数传递分引用传递和值传递  引用传递，通过传递引用的方式避免了对象拷贝。  值传递，则都是通过拷贝对象传递数据的。其中指针形参也是值传递，只不过传递时拷贝的是指针数据而非具体对象。函数设置参数时，我们要注意尽量使用const常量引用或指针作为形参，因为这样既避免了对象拷贝，又可以限制对象的修改。可变形参使用initializer_list类型的形参可以做到传递可变数量的实参。和Vector不一样的是，initializer_list中的元素永远都是常量值。举个例子：void test_func(initializer_list&lt;string&gt; li){  for(auto beg = li.begin(); beg != li.end() ; ++beg)      cout&lt;&lt; *beg &lt;&lt; \" \";}test_func(\"1\",\"3\",\"4\");test_func(\"2\",\"3\");test_func(\"2\",\"4\",\"6\",\"8\",\"10\");值返回和引用返回与值传递和引用传一样，在函数返回时，我们也需要注意拷贝操作。例如字符串拼接后的返回值就会造成对象拷贝的消耗：string test_func(string &amp;a, string &amp;b){   return a + b;}为了避免拷贝我们会使用引用返回或指针，但要注意，使用引用返回或指针时如果返回的是局部对象则会引起内存使用错误。string &amp;test_func(){   string test = \"test\";   return test; // 错误的返回了局部变量，导致内存使用错误}函数重载函数重载的特点是函数名字相同参数列表不同且在同一个作用域。在重载函数调用时，可能与我们想象的不同，其实编译器在离线时就区分了不同重载函数的调用地址。当调用重载函数时，编译器会根据传递的实参类型去比较每个重载函数的参数直到匹配成功或失败。我们知道虽然重载函数名字相同，但参数列表不同，这导致函数签名时的实际名字是不同，也就相当于调用的是不同名字的函数。举例说明重载函数的函数签名后命名不同：int func(int); //  函数签名后--&gt; _Z4funci int func(float); // 函数签名后--&gt; _Z4funcffunc(3); // -&gt; 匹配 _Z4funcifunc(3.5F); // -&gt; 匹配 _Z4funcf重载函数的匹配过程为：  收集所有重载函数  比较实参与所有重载函数的形参，寻找最佳匹配函数  匹配规则为精准匹配和转换匹配两种，精准匹配要求实参与形参高度一致，转换则可以通过const转换、类型提升、算术类型转换来实现匹配。  匹配成功后替换为匹配函数的函数签名至于函数签名的规则，其实每种编译器都不同，不过也是大同小异的。例如上述我们举例代码中的GCC编译器的规则为：  所有符号以“_Z”开头，  对于嵌套的名字后面紧跟“N”，  然后紧跟各个名称空间和类的名字，每个名字前是名字字符串长度，  再以“E”结尾，“E”后面是所有参数，  参数以简写代替，例如对于int类型来说就是字母“i”，float类型来说就是字母“f”，以此类推。内联函数我们知道函数在调用时会先保存当前寄存器、拷贝实参值、并在返回时拷贝恢复，这些都是函数调用的消耗。内联函数则可以避免函数调用的消耗，其原理是就地展开函数，这样能省去了函数调用前和后的一系列操作。我们可以通过内联关键字inline告诉编译器该函数需要在编译器时展开，但这也只是向编译器发出请求而已，如果编译器认为该内敛展开后性价比不高可以选择忽略这个请求。常量表达函数constexpr，我们可以通过constrexpr定义常量表达式的函数，与普通内联函数不同的是，编译器会把constexpr函数的调用替换成实际结果，简单来说就是离线计算好结果并替换调用函数。对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致，基于这个原因，内联函数和constexpr函数通常定义在头文件中。调试辅助指令assert是常见的调试工具，它其实是一个预处理宏，通过判断表达式来终止程序执行。assert的行为依赖于一个名为NDEBUG的预处理变量。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，我们可以使用#define来定义NDEBUG从而关闭调试状态，或者使用编译器的预处理指令cc -D NDEBUG main.c除了assert，C++编译器还定义了多个帮助我们调试的变量，例如：  func，存放的是当前函数名字  FILE，存放的是当前文件名  LINE，存放的是当前代码行号  TIME，存放的是当前文件编译时间  DATA，存放的是当前文件编译日期函数指针函数指针指向的是函数地址，它的类型由它的返回值类型、形参类型共同决定，编译器会检查函数类型与函数指针类型之间的一致性。bool (*point_func)(const string &amp;, const string &amp;);// point_func前面有个*，因此point_func是指针，这里括号不能少。// point_func右侧是形参列表，表示point_func指向的是，两个const string引用为参数、并且返回值是bool的函数类型。bool lenCompare(const string &amp;, const string &amp;);point_func = lenCompare; //指向lenComparepoint_func = &amp;lenCompare; //等价于赋值在指向不同函数类型的指针间不存在转换规则，也就是说，不同类型函数之间无法转换，即我们无法将一个类型函数转换到另一个类型函数指针。在将函数指针用于形参、返回值、重载函数时，都必须遵循函数类型与函数指针一致性的原则，编译器不会自动将函数类型转换成我们想要的类型，因为转换是不允许的。已发布在微信公众号上，点击跳转",
            "content_html": "<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484764&amp;idx=1&amp;sn=edc0beab7722d092571c8f88a9a38bd6&amp;chksm=fc22605bcb55e94d95e3445b7449c42f87450a2fcc8dd16d63f44a242b17e63b6f5051e91dcd&amp;token=535520395&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p><h3 id=\"背景\">背景：</h3><p>我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意。第三是当我们在巩固时创造出了新的知识，那么这些新的知识和旧的知识将同时变成智慧融合到身体中。</p><p>本系列基于《C++ Primer》学习，由于重点放在“重学”，我略过了滚瓜烂熟的部分，挑出以前常忽略的部分，以及记忆没有那么深刻的部分，特别是那些重要的但没有上心的部分。</p><h3 id=\"开始\">开始</h3><h3 id=\"左值和右值\">左值和右值</h3><p>这两个名词是从C语言继承过来的，原本是为了帮助记忆即：左值可以位于赋值语句的左侧，右值则不能。在C++语言中则没那么简单了，可以简单归纳为：当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。</p><p>不同运算符对运算对象的要求不同，有的需要左值运算对象、有的则需要右值运算对象。因此有个重要原则：在需要右值的地方可以用左值来代替，但不能把右值当左值（也就是位置）使用。当一个左值被当成右值使用时，实际使用的是它的内容（就是值）。</p><p>举几个例子：\t赋值运算符，是左值运算，因为结果是值（内容）\t取地址符，是右值运算，因为结果的是指针或地址\t解引用运算符、下标运算符，是左值运算，因为运算结果是值（内容）\t递增运算，是左值运算，因为运算结果是值（内容）</p><h3 id=\"关于后置\">关于后置++</h3><p>这里有个小提示，后置++版本会多浪费一个寄存器，但是编译器会帮我们优化掉，不过对于迭代器来说则不同，编译器通常不会优化迭代器的后置++，因此我们在使用迭代器后置++时要注意一下代码的优化。</p><pre><code class=\"language-C\">cout&lt;&lt; *iter++ &lt;&lt; endl;==&gt; 优化count&lt;&lt; *iter &lt;&lt; endl;++iter;</code></pre><h3 id=\"sizeof运算符\">sizeof运算符</h3><p>sizeof有离线计算和实时运算之分，通常情况下有些值在离线时就能知道的类型的大小，这时编译器都会在编译时就将其替换成固定值。</p><p>举例说明sizeof运算符的结果取决于其作用类型：</p><ul>  <li>对char类型表达式执行sizeof运算，结果为1。编译器离线计算</li>  <li>对引用类型执行sizeof，结果为被引用对象所占空间大小。编译器离线计算</li>  <li>对指针执行sizeof运算，结果为指针本身空间大小。编译器离线计算</li>  <li>对解引用指针执行sizeof，结果为指针指向的对象的空间大小。编译器离线计算</li>  <li>对数组执行sizeof运算，结果是整个数组所占空间大小。编译器离线计算</li>  <li>对string对象或vector对象执行sizeof运算，结果为该类型固定部分的大小。实时计算空间大小</li></ul><h3 id=\"强制类型转换\">强制类型转换</h3><p>强制类型转换的根本目的就是告诉编译器，该变量的类型改变了，符合后面的逻辑运算，好让在编译器在编译时能够不误解逻辑运算，所以编译器并没有对内存内容做任何的改变，它只是为了迎合编译器。</p><pre><code class=\"language-C\">//旧式的强制类型转换type (expr); // 函数形式的强制类型转换(type) expr; // c语言风格的强制类型转换//新式的强制类型转换static_cast&lt;type&gt;(expression); // 静态转换dynamic_cast&lt;type&gt;(expression); // 运行时转换const_cast&lt;type&gt;(expression); // 常量转换reinterpret_cast&lt;type&gt;(expression); // 低阶类型转换</code></pre><h3 id=\"强制转换分为static_cast静态转换dynamic_cast运行时转换const_cast常量转换reinterpret_cast低阶类型转换4种\">强制转换分为，static_cast（静态转换），dynamic_cast（运行时转换），const_cast（常量转换），reinterpret_cast（低阶类型转换）4种</h3><ul>  <li>static_cast静态转换，直接将对象转换成指定类型对象。</li>  <li>dynamic_cast运行时转换，通常用于继承对象，运行时转换会先通过RTTI的方式判断是否能进行父子转换，如果可以再进行执行转换。</li>  <li>const_cast常量转换，只能改变运算对象的底层const无法改变具体类型，可以将const变量转换为非const变量，这样编译器就不再阻止我们对该对象进行写操作了。</li>  <li>reinterpret_cast低阶类型转换，通常为运算对象的位模式提供低层次上的解释。例如将int转换为char*等低阶模式。</li></ul><h3 id=\"注意使用reinterpret_cast比较危险的是使用reinterpret_cast强制转换后编译器不会怀疑所转换的类型如果类型错误则会因调用混乱而崩溃而编译器在编译时不会发出任何警告或错误因此reinterpret_cast通常适合比较底层转换工作\">注意：使用reinterpret_cast比较危险的是，使用reinterpret_cast强制转换后编译器不会怀疑所转换的类型，如果类型错误则会因调用混乱而崩溃，而编译器在编译时不会发出任何警告或错误，因此reinterpret_cast通常适合比较底层转换工作。</h3><h3 id=\"异常处理\">异常处理</h3><p>当异常被抛出时，首先在该函数中寻找匹配的catch子句，如果没有找到则终止该函数并在调用该函数的函数中继续寻找，以此类推沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。如果最终还是没能找到任何匹配的catch子句，程序会转到名为terminate的标准库函数中。该函数的行为与系统有关，一般情况下，执行该函数会导致程序非正常退出。如果当程序没有使用try catch语句且发生了异常，系统会直接调用terminate函数并终止当前程序的执行。</p><h3 id=\"分离式编译\">分离式编译</h3><p>分离式编译的意思就是，多个源文件在编译中可以只顾自己编译，最后再统一链接到执行文件或库文件中。</p><p>在分离式编译中，如果我们修改了其中一个源文件，那么只需要重新编译那个改动了的文件，再重新链接就可以。现代大多数编译器提供了分离式编译每个文件的机制，这一过程通常会产生一个后缀名是.obj（windows）或.o(UNIX)的目标文件，再用链接器将所有目标文件链接成可执行文件或库文件。</p><h3 id=\"参数传递\">参数传递</h3><p>解释下，实参就是要传递的数据变量，形参就是传递后函数中的参数变量。</p><p>参数传递分引用传递和值传递</p><ul>  <li>引用传递，通过传递引用的方式避免了对象拷贝。</li>  <li>值传递，则都是通过拷贝对象传递数据的。其中指针形参也是值传递，只不过传递时拷贝的是指针数据而非具体对象。</li></ul><p>函数设置参数时，我们要注意尽量使用const常量引用或指针作为形参，因为这样既避免了对象拷贝，又可以限制对象的修改。</p><h3 id=\"可变形参\">可变形参</h3><p>使用initializer_list类型的形参可以做到传递可变数量的实参。和Vector不一样的是，initializer_list中的元素永远都是常量值。</p><p>举个例子：</p><pre><code class=\"language-C\">void test_func(initializer_list&lt;string&gt; li){  for(auto beg = li.begin(); beg != li.end() ; ++beg)      cout&lt;&lt; *beg &lt;&lt; \" \";}test_func(\"1\",\"3\",\"4\");test_func(\"2\",\"3\");test_func(\"2\",\"4\",\"6\",\"8\",\"10\");</code></pre><h3 id=\"值返回和引用返回\">值返回和引用返回</h3><p>与值传递和引用传一样，在函数返回时，我们也需要注意拷贝操作。</p><p>例如字符串拼接后的返回值就会造成对象拷贝的消耗：</p><pre><code class=\"language-C\">string test_func(string &amp;a, string &amp;b){   return a + b;}</code></pre><p>为了避免拷贝我们会使用引用返回或指针，但要注意，使用引用返回或指针时如果返回的是局部对象则会引起内存使用错误。</p><pre><code class=\"language-C\">string &amp;test_func(){   string test = \"test\";   return test; // 错误的返回了局部变量，导致内存使用错误}</code></pre><h3 id=\"函数重载\">函数重载</h3><p>函数重载的特点是函数名字相同参数列表不同且在同一个作用域。</p><p>在重载函数调用时，可能与我们想象的不同，其实编译器在离线时就区分了不同重载函数的调用地址。当调用重载函数时，编译器会根据传递的实参类型去比较每个重载函数的参数直到匹配成功或失败。我们知道虽然重载函数名字相同，但参数列表不同，这导致函数签名时的实际名字是不同，也就相当于调用的是不同名字的函数。</p><p>举例说明重载函数的函数签名后命名不同：</p><pre><code class=\"language-C\">int func(int); //  函数签名后--&gt; _Z4funci int func(float); // 函数签名后--&gt; _Z4funcffunc(3); // -&gt; 匹配 _Z4funcifunc(3.5F); // -&gt; 匹配 _Z4funcf</code></pre><p>重载函数的匹配过程为：</p><ol>  <li>收集所有重载函数</li>  <li>比较实参与所有重载函数的形参，寻找最佳匹配函数</li>  <li>匹配规则为精准匹配和转换匹配两种，精准匹配要求实参与形参高度一致，转换则可以通过const转换、类型提升、算术类型转换来实现匹配。</li>  <li>匹配成功后替换为匹配函数的函数签名</li></ol><p>至于函数签名的规则，其实每种编译器都不同，不过也是大同小异的。例如上述我们举例代码中的GCC编译器的规则为：</p><ul>  <li>所有符号以“_Z”开头，</li>  <li>对于嵌套的名字后面紧跟“N”，</li>  <li>然后紧跟各个名称空间和类的名字，每个名字前是名字字符串长度，</li>  <li>再以“E”结尾，“E”后面是所有参数，</li>  <li>参数以简写代替，例如对于int类型来说就是字母“i”，float类型来说就是字母“f”，以此类推。</li></ul><h3 id=\"内联函数\">内联函数</h3><p>我们知道函数在调用时会先保存当前寄存器、拷贝实参值、并在返回时拷贝恢复，这些都是函数调用的消耗。</p><p>内联函数则可以避免函数调用的消耗，其原理是就地展开函数，这样能省去了函数调用前和后的一系列操作。我们可以通过内联关键字inline告诉编译器该函数需要在编译器时展开，但这也只是向编译器发出请求而已，如果编译器认为该内敛展开后性价比不高可以选择忽略这个请求。</p><p>常量表达函数constexpr，我们可以通过constrexpr定义常量表达式的函数，与普通内联函数不同的是，编译器会把constexpr函数的调用替换成实际结果，简单来说就是离线计算好结果并替换调用函数。</p><p>对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致，基于这个原因，内联函数和constexpr函数通常定义在头文件中。</p><h3 id=\"调试辅助指令\">调试辅助指令</h3><p>assert是常见的调试工具，它其实是一个预处理宏，通过判断表达式来终止程序执行。</p><p>assert的行为依赖于一个名为NDEBUG的预处理变量。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，我们可以使用#define来定义NDEBUG从而关闭调试状态，或者使用编译器的预处理指令cc -D NDEBUG main.c</p><p>除了assert，C++编译器还定义了多个帮助我们调试的变量，例如：</p><ul>  <li><strong>func</strong>，存放的是当前函数名字</li>  <li><strong>FILE</strong>，存放的是当前文件名</li>  <li><strong>LINE</strong>，存放的是当前代码行号</li>  <li><strong>TIME</strong>，存放的是当前文件编译时间</li>  <li><strong>DATA</strong>，存放的是当前文件编译日期</li></ul><h3 id=\"函数指针\">函数指针</h3><p>函数指针指向的是函数地址，它的类型由它的返回值类型、形参类型共同决定，编译器会检查函数类型与函数指针类型之间的一致性。</p><pre><code class=\"language-C\">bool (*point_func)(const string &amp;, const string &amp;);// point_func前面有个*，因此point_func是指针，这里括号不能少。// point_func右侧是形参列表，表示point_func指向的是，两个const string引用为参数、并且返回值是bool的函数类型。bool lenCompare(const string &amp;, const string &amp;);point_func = lenCompare; //指向lenComparepoint_func = &amp;lenCompare; //等价于赋值</code></pre><p>在指向不同函数类型的指针间不存在转换规则，也就是说，不同类型函数之间无法转换，即我们无法将一个类型函数转换到另一个类型函数指针。</p><p>在将函数指针用于形参、返回值、重载函数时，都必须遵循函数类型与函数指针一致性的原则，编译器不会自动将函数类型转换成我们想要的类型，因为转换是不允许的。</p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484764&amp;idx=1&amp;sn=edc0beab7722d092571c8f88a9a38bd6&amp;chksm=fc22605bcb55e94d95e3445b7449c42f87450a2fcc8dd16d63f44a242b17e63b6f5051e91dcd&amp;token=535520395&amp;lang=zh_CN#rd\">已发布在微信公众号上，点击跳转</a></p>",
            "url": "http://www.luzexi.com/2021/06/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B028",
            
            
            
            "tags": ["读书笔记","前端技术"],
            
            "date_published": "2021-06-19T00:00:00+08:00",
            "date_modified": "2021-06-19T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://www.luzexi.com/2021/06/16/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A113",
            "title": "给女儿的信(十三) 要赢的是自己",
            "summary": "女儿 教育 亲情",
            "content_text": "Sharon，Anne，爸爸回到深圳了，很想你们哟。这里的天气和杭州一样暖，只是这里没有太多的雨。爸爸又回到了公司开始工作了。想起在家里和你们一起的这几天，爸爸很开心哟，爸爸喜欢和你们一起玩、一起学习。还记得Sharon跟爸爸一起玩拼图游戏的时候吗，Sharon老想着要和爸爸比谁快。爸爸跟你说，不要总想着和别人比，要和自己比。Sharon疑惑的问爸爸，什么是跟自己比。爸爸跟你说，爸爸以前也总是和别人比，但是和别人比总会让爸爸很紧张发挥不出真正的实力，因为爸爸总想赢，太着急了太在意了赢得也不轻松，输了就会很失落。所以当爸爸想着和别人比的时候，情绪波动很大，特别遇到比自己厉害很多的人时心情就更低落了。爸爸后来不和别人比了，因为这样太不好了，转而和自己比。怎么比呢，例如，去年我能看多少本书，今年我就比去年多看几本书。去年我能认识多少字，今年我就比去年的我多认识一些。每天坚持积累一些些，今天的我比昨天的我进步一些些，每天都在跟昨天的自己比，跟过去的自己比，我每次都能战胜过去的自己，我就像是不断战胜自己的勇士那样，充满了斗志。即使这样爸爸有时候也还是会陷入到和别人比较的陷进中去，但爸爸慢慢习惯和自己比赛后，挣脱出这种困境就越来越容易了。由于每天积累看书，帮助爸爸建立起了丰富的知识，让爸爸在工作和生活当中更加轻松自如哟。Sharon、Anne要和爸爸一起加油哟。爱你们。",
            "content_html": "<p>Sharon，Anne，爸爸回到深圳了，很想你们哟。</p><p>这里的天气和杭州一样暖，只是这里没有太多的雨。爸爸又回到了公司开始工作了。</p><p>想起在家里和你们一起的这几天，爸爸很开心哟，爸爸喜欢和你们一起玩、一起学习。</p><p>还记得Sharon跟爸爸一起玩拼图游戏的时候吗，Sharon老想着要和爸爸比谁快。</p><p>爸爸跟你说，不要总想着和别人比，要和自己比。</p><p>Sharon疑惑的问爸爸，什么是跟自己比。</p><p>爸爸跟你说，爸爸以前也总是和别人比，但是和别人比总会让爸爸很紧张发挥不出真正的实力，因为爸爸总想赢，太着急了太在意了赢得也不轻松，输了就会很失落。</p><p>所以当爸爸想着和别人比的时候，情绪波动很大，特别遇到比自己厉害很多的人时心情就更低落了。</p><p>爸爸后来不和别人比了，因为这样太不好了，转而和自己比。</p><p>怎么比呢，例如，去年我能看多少本书，今年我就比去年多看几本书。</p><p>去年我能认识多少字，今年我就比去年的我多认识一些。</p><p>每天坚持积累一些些，今天的我比昨天的我进步一些些，每天都在跟昨天的自己比，跟过去的自己比，我每次都能战胜过去的自己，我就像是不断战胜自己的勇士那样，充满了斗志。</p><p>即使这样爸爸有时候也还是会陷入到和别人比较的陷进中去，但爸爸慢慢习惯和自己比赛后，挣脱出这种困境就越来越容易了。</p><p>由于每天积累看书，帮助爸爸建立起了丰富的知识，让爸爸在工作和生活当中更加轻松自如哟。</p><p>Sharon、Anne要和爸爸一起加油哟。爱你们。</p>",
            "url": "http://www.luzexi.com/2021/06/16/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A113",
            
            
            
            
            
            "date_published": "2021-06-16T00:00:00+08:00",
            "date_modified": "2021-06-16T00:00:00+08:00",
            
                "author":  {
                "name": "Jesse Lu",
                "url": "http://www.luzexi.com",
                "avatar": null
                }
                
            
        }
    
    ]
}