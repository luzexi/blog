<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Hyde &middot; A Jekyll theme
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Hyde
        </a>
      </h1>
      <p class="lead">A brazen two-column <a href="http://jekyllrb.com" target="_blank">Jekyll</a> theme that pairs a prominent sidebar with uncomplicated content. Made by <a href="https://twitter.com/mdo" target="_blank">@mdo</a>.</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>

      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about/">About</a>
          
        
      
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      

      <a class="sidebar-nav-item" href="https://github.com/poole/hyde/archive/v2.1.0.zip">Download</a>
      <a class="sidebar-nav-item" href="https://github.com/poole/hyde">GitHub project</a>
      <span class="sidebar-nav-item">Currently v2.1.0</span>
    </nav>

    <p>&copy; 2015. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/unity3d/%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84/%E6%B8%B8%E6%88%8F%E9%80%9A%E7%94%A8%E6%A8%A1%E5%9D%97/2014/02/15/Unity3D-HTTP%E7%BD%91%E7%BB%9C%E5%B1%82%E5%B0%81%E8%A3%85/">
        Unity3D-HTTP网络层封装
      </a>
    </h1>

    <span class="post-date">15 Feb 2014</span>

    <p>Unity3D-HTTP网络层封装。短连接的C#封装在这里做些分享。我把网络层封装成DLL在项目中使用，所以在设计时要将接口封装的很好。 我又对HTTP部分进行了改造不再使用DDL封装了（所以去除文章部分暂时用横线做标记），所有源码都以git的submodule形式作为项目的模块。源码会再文章的最后给出来。这次改装主要是针对程序员是否能快速理解，快速上手的方面来进行的。随着对HTTP网络层不断的理解加深，我将给出更加全面的HTTP源码模块，我还对本HTTP模块写了测试案例，你们可以看测试案例，进行使用。谢谢各位的关注，再次感谢不断得支持。</p>

<p>一.首先说下网络层需要的一些接口，在游戏里需要用到的网络层都具有大部分的共同点，无论是TCP长连接还是HTTP短连接有部分区别，HTTP的网络事件要相对少一点。</p>

<p>HTTP接口基本为：数据发送Send接口，网络错误事件，数据包回调执行句柄。HTTP网络层的数据包预发送接口被我去除，因为我回想，这个功能完全可以用模块外部的程序代替，而且可以针对每个界面来写，这样更加清晰，而且主要是这个功能障碍了程序员对程序的理解。</p>

<p>二.说明下网络层中几个类的用途和作用。 HTTPSession类，是整个网络层的主类，承载了发送，接受，事件相应的事务。</p>

<p>HTTPPacketRequest类，网络请求数据包基础类。每个请求数据包的最基础的数据，包含一个m_strAction地址变量，这个是因为每个HTTP请求的地址不同而设的变量，每个请求地址前缀都相同比如：http://luzexi.com/ ，而后缀有可能变化，比如author/regist/。所以这个变量要在你创建的时候在构建函数里进行设置。</p>

<p>HTTPPacketAck类，网络回调数据包基础类。每个回调数据包的基础数据，每个数据包都含有几个基础的变量，我现在写的是code错误码 和 desc错误描述，你也可以改成其他你想要的，如果你理解整这段程序。总之，继承这个回调数据类的类中可以放置本次回调的数据，有数据回调时，系统将自动解析成这个类。</p>

<p>HTTPSession类，会话类是网络层的主类，有发送接口和网络主地址，还有一个报错接口。是整个HTTP网络层的接入口。</p>

<p>HttpDummySession类，我还做了虚拟会话，主要是给HTTP和单机切换用，有些游戏想做网络和单机一起兼顾，可以用HTTP虚拟类来实现，不需要改原来写好的HTTP请求，只要你对加个请求句柄处理就可以了。不过一般人不会用到。</p>

<p>三.网络层最重要的是能够快速，方便使用，能够适应变化多端的需求改变。</p>

<p>每个请求类（HTTPPacketRequest子类）和回调类（HTTPPacketAck子类）都是自动生成参数和自动映射回调类实例的，但千万记住，回调过来的数据和HTTPPacketAck子类里的变量名必须一致。</p>

<p>四.关于HTTP的Head数据部分</p>

<p>HEAD部分我已经写好了，但是一个统一的HEAD变量，在session类中你可以找到。因为head部分都是统一的参数变量，动的比较少，所以才这么做。在游戏项目里，可以用HEAD部分的数据也可以不用，因为完全可以用数据包的形式代替。</p>

<p>最后奉上源码：<a href="https://github.com/luzexi/Unity3DNetwork-http">Unity3D-HTTP</a></p>

<p>测试案例：<a href="https://github.com/luzexi/Unity3DNetwork-http-Test">Unity3D-HTTP-Test</a></p>

<p>转载请注明出处:http://www.luzexi.com</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/unity3d/%E6%B8%B8%E6%88%8F%E9%80%9A%E7%94%A8%E6%A8%A1%E5%9D%97/2014/02/15/Unity3D%20AssetBundle%20%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/">
        Unity3D AssetBundle 资源加载注意事项
      </a>
    </h1>

    <span class="post-date">15 Feb 2014</span>

    <p>Unity3D AssetBundle 资源加载注意事项.U3d资源打包以及加载出过很多问题，在这里把所有该注意的东西列出来分享下。</p>

<p>1.由于Unity3D的自身的问题，在资源打包时会遗漏一些引用的资源，导致在游戏加载 AssetBundle 时没有问题，但在把资源实例化时出现资源找不到，或者资源缺少引用资源等问题。</p>

<p>解决办法： 在打包获取资源时，分3个步骤做：1.创建空的临时的预置体Prefab 2.把要打包的资源实例化进场景 3.把实例化后的物体装进刚创建的空的预置体Prefab 4.最后再用该预置体打包成AssetBundle（注意多资源打包最好用BuildAssetBundleExplicitAssetNames接口，没有为什么原先使用BuildAssetBundle出现过很多问题）</p>

<p>2.WWW资源url加载AssetBundle时会遇到版本资源更新的问题。U3D自4.0后就不再有删除某缓存资源的接口，所以资源更新时遇到麻烦。</p>

<p>解决办法： 1.客户端记录由服务器发过来的MD5码，倘若与本地存储的MD5码不同则增加自动增加一个版本号。这个办法方便但会积累很多的旧的无用的资源占用手机，导致用户有可能因为游戏占用太多硬盘资源而删除游戏。 2.客户端记录由服务器发过来的CRC校验码，用CRC校验码来判定当前资源是否需要重新加载，调用接口为static function LoadFromCacheOrDownload(url: string, version: int, crc: uint = 0): WWW; 这个办法可以解决旧资源删除问题，但最主要的问题是资源在打包后由于U3D的资源CRC校验码并不是普通的校验码，所以只能根据他的接口来判定，4.2以及4.2以前都没有获取CRC校验码的接口，所以每次打包资源后，都需要校对校验码。如何校对CRC校验码请自己去搜索资料。</p>

<p>3.如何知道哪些资源包需要加载以及加载地址和版本号。</p>

<p>解决办法： 1.使用XML，将所有需要加载的资源信息写入XML文件。每次游戏开始，先读取该文件。 2.由服务器的逻辑服务器提供需要加载的资源信息。</p>

<p>转载请注明出处：http://www.luzexi.com</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/unity3d/%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84/%E6%B8%B8%E6%88%8F%E9%80%9A%E7%94%A8%E6%A8%A1%E5%9D%97/2013/12/31/%E6%B8%B8%E6%88%8F%E7%89%A9%E5%93%81%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%94%A8%E6%9E%B6%E6%9E%84/">
        游戏物品系统通用架构
      </a>
    </h1>

    <span class="post-date">31 Dec 2013</span>

    <p>游戏物品系统通用架构，物品系统是游戏中最最常用的功能之一，面对各种纷繁复杂的游戏物品系统，在具体项目中如何顺手拈来、驾驭自如？请容我一一到来。在内容前我有必要说明几点，所有内容都是基于我最大的架构思想之下，其中 客户端U3D架构思想的文章地址为 <a href="http://www.luzexi.com/unity3d%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84/comment-page-1/#comment-135">Unity3D游戏架构</a> ，以及服务器架构： <a href="http://www.luzexi.com/%E3%80%8A%E7%8E%8B%E9%80%94%E9%9C%B8%E4%B8%9A%E3%80%8B%E6%88%98%E4%BA%89%E7%AD%96%E7%95%A5%E6%B8%B8%E6%88%8F%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">《王图霸业》战争策略游戏服务器架构</a> 。</p>

<p>直入主题</p>

<p>首先，我们先归纳一下物品的基本属性。
    物品基本属性：名字，描述，数量，最大可叠加数，图标
    装备物品扩展属性：装备位置，攻击力，防御力，暴击率，魔力，血量，等等
    消耗物品扩展属性：BUFF增加，HP增加，最大HP增加，等等</p>

<p>在游戏项目中，把这些物品的扩展属性，单个提取出来组合成各种游戏中需要的物品，如何做到？</p>

<p>1.把所有属性都写进物品数据配置表中？数据表过大，导致最终项目人员更改数据缓慢，错误不断，甚至连写此系统的程序员自己也吃不消。</p>

<p>2.把每个物品都按单各类进行特殊处理？假设物品有100种，那程序员就得写100各类实例，每增加一个写一个，浪费人力浪费时间。</p>

<p>3.以物品基类的继承的形式，将各种物品分类处理，归类，派生？繁琐，分类时间过长，效率过低，程序员最终会为物品该归到哪一类和策划人员而打起来。</p>

<p>如何才能做到物品系统适应不同的游戏需要，又能使得物品配置方便扩展性强？在这里我引入一个Action概念，Action以动作的概念来理解。当物品使用时，就调用不同的Action来达到不同的效果，例如：加血100加魔法200的物品，点击后，该物品执行加血100的Action实例，接着执行加魔200的实例，完毕后我们就能看到我们需要的效果了。所以物品只需要对应N各Action就可以完全做到你想做的，甚至可以做到你想不到的。</p>

<p>我们能发现，其实物品的很多功能是可以用不同单个功能组合起来的，比如加血,比如加魔，比如加BUFF状态，把这些相同功能的Action都做成一个，然后把不同的Action做成一个集合是多么完美的事，既达到了数据持续化存储和更新能力，又可使得物品功能完全由策划人员自行配置，发挥他们的无限想象力。</p>

<p>现在来看看实际中Action是如何编写的。把加血动作写成 类ActionAddHp，类中参数一个:HP，把加魔法动作写成 类ActionAddMP，类中参数一个：MP，这两个Action从数据表中读取相应的参数数据，变成众多Action实例里的一个，由ActionManager管理存储。到此回头看看，所有继承自Action类的扩展类拥有几个共同的属性：ID（唯一标识，用来区分所有Action），RunType（用来区分不同类型的Action），Read接口（用来读取数据），Excute接口（用来执行Action）。我在此之上加上一个Action类型，把所有Action拆分为条件类Action和执行类Action，条件类Action主要用来判断该物品的使用条件是否满足，执行类Action主要用来执行该动作的效果。因此Action基类就成了这样:</p>

<p>using System;<br>
using System.Collections.Generic;<br>
using System.Linq;<br>
using System.Text;  </p>

<p>//  CAction.cs<br>
//  Author: Lu Zexi<br>
//  2013-12-24    </p>

<p>//base action<br>
public abstract class CAction : IAction<br>
{<br>
    private int m_iID;  //id  </p>
<div class="highlight"><pre><code class="language-text" data-lang="text">// id (0-99999) , actionType(0-99) , runType(0-99)  
public CAction(int id, int actionType, int runType)  
{  
    this.m_iID = actionType*10000000 + runType*100000 + id;  
}  

public abstract ActionError Excute(ActionInput input);  

//roll back action  
public virtual ActionError RollBack(ActionInput input)  
{  
    return ActionError.NoError;  
}  

//get id  
public int ID  
{  
    get  
    {  
        return this.m_iID;  
    }  
}  
</code></pre></div>
<p>}</p>

<p>有人会问，那如何让物品对应好几个Action呢？我再引入一个Action事件类，把它定义为类EventAction，他里面存储着16个Action ID，前8个ActionID是条件型动作，后8个ActionID为执行型动作。物品的数据中就有一个EventAction的ID，由这个EventAction来判断该执行那些Action，是否满足物品执行条件。当EventAction执行时，首先执行前8个Action，看看是否满足物品执行条件，如果不满足，则不执行后8个效果，如果满足再去执行后8个Action效果。因此EventAction也有很多各实例，由ID来区分不同的EventAction，由EventActionManager来管理所有事件Action。EventAction类结构：</p>

<p>using System;<br>
using System.Collections.Generic;<br>
using System.Linq;<br>
using System.Text;  </p>

<p>//  EventAction.cs<br>
//  Author: Lu zexi<br>
//  2013-12-24  </p>

<p>/// <summary><br>
/// Action event<br>
/// </summary><br>
public class EventAction<br>
{<br>
    private int m<em>iID; //ID<br>
    private int[] m</em>vecActions; //Action ID list<br>
    private int[] m_vecReqActions; //Require Action ID list  </p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public EventAction()  
{  
    this.m_vecActions = new int[8];  
    this.m_vecReqActions = new int[8];  
}  

// id (0-99999) , actionType(0-99) , runType(0-99)  
public EventAction( int id , int eventType , int runType)  
{  
    this.m_iID = eventType * 10000000 + runType*100000 + id;  
}  

//get id  
public int ID  
{  
    get  
    {  
        return this.m_iID;  
    }  
}  

//set action  
public void SetAction( int[] act )  
{  
    this.m_vecActions = act;  
}  

//set require  
public void SetRequire( int[] req )  
{  
    this.m_vecReqActions = req;  
}  

//excute action  
public ActionError Excute( ActionInput input  )  
{  
    for (int i = 0; i &lt; this.m_vecActions.Length; i++)  
    {  
        CAction action = ActionManager.sInstance.GetAction(this.m_vecActions[i]);  
        if (action != null)  
        {  
            ActionError error = action.Excute(input);  
            if ( error != null &amp;&amp; error.code != ACTION_ERROR_CODE.NONE)  
                return error;  
        }  
    }  
    return ActionError.NoError;  
}  

//action require  
public ActionError Require( ActionInput input)  
{  
    for (int i = 0; i &lt; this.m_vecReqActions.Length; i++)  
    {  
        CAction action = ActionManager.sInstance.GetAction(this.m_vecReqActions[i]);  
        if (action != null)  
        {  
            ActionError error = action.Excute(input);  
            if ( error != null &amp;&amp; error.code != ACTION_ERROR_CODE.NONE)  
                return error;  
        }  
    }  
    return ActionError.NoError;  
}  

//action roll back  
public ActionError RollBack(ActionInput input)  
{  
    for (int i = 0; i &lt; this.m_vecActions.Length; i++)  
    {  
        CAction action = ActionManager.sInstance.GetAction(this.m_vecActions[i]);  
        if (action != null)  
        {  
            ActionError error = action.RollBack(input);  
            if (error != null &amp;&amp; error.code != ACTION_ERROR_CODE.NONE)  
                return error;  
        }  
    }  
    return ActionError.NoError;  
}  
</code></pre></div>
<p>}</p>

<p>以上描述解决了物品中消耗品的问题，物品素材本身就是没有功能的消耗品，在这里我就不介绍了。而下面，我们来看看如何解决物品装备。
装备物品在消耗品上多了几样关于英雄角色的属性，这些属性有的明，有的暗，那我们就把那些明的属性提取出来，例如加增攻击力，增加防御力。而那些暗的属性，再拆分两种，一种是直接写进明的配置表中而不显示在界面上，另一个是直接写进动作Action里，当需要时执行相应EventAction实例。</p>

<p>最后，我们看看整个物品系统数据配置和系统源码。
   物品类：名字，物品类型(消耗品，装备，素材)，描述，数量，最大叠加数量，使用等级,EventActionID,装备位置,攻击力，防御力，HP，MP
   Action表: ID , 描述 , ActionType , RunType , 参数1，参数2...
   EventAction表: ID,描述,
ReqActionID1,ReqActionID2,...ReqActionID8,
ActionID9,ActionID10,...ActionID16.</p>

<p>源码：<a href="https://github.com/luzexi/Unity3DItemSystem">https://github.com/luzexi/Unity3DItemSystem</a></p>

<p>测试案例：<a href="https://github.com/luzexi/Unity3DItemSystem-Test">https://github.com/luzexi/Unity3DItemSystem-Test</a></p>

<p>转载请注明出处：http://www.luzexi.com</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2013/12/28/introducing-hyde/">
        Introducing Hyde
      </a>
    </h1>

    <span class="post-date">28 Dec 2013</span>

    <p>Hyde is a brazen two-column <a href="http://jekyllrb.com">Jekyll</a> theme that pairs a prominent sidebar with uncomplicated content. It&#39;s based on <a href="http://getpoole.com">Poole</a>, the Jekyll butler.</p>

<h3>Built on Poole</h3>

<p>Poole is the Jekyll Butler, serving as an upstanding and effective foundation for Jekyll themes by <a href="https://twitter.com/mdo">@mdo</a>. Poole, and every theme built on it (like Hyde here) includes the following:</p>

<ul>
<li>Complete Jekyll setup included (layouts, config, <a href="/404">404</a>, <a href="/atom.xml">RSS feed</a>, posts, and <a href="/about">example page</a>)</li>
<li>Mobile friendly design and development</li>
<li>Easily scalable text and component sizing with <code>rem</code> units in the CSS</li>
<li>Support for a wide gamut of HTML elements</li>
<li>Related posts (time-based, because Jekyll) below each post</li>
<li>Syntax highlighting, courtesy Pygments (the Python-based code snippet highlighter)</li>
</ul>

<h3>Hyde features</h3>

<p>In addition to the features of Poole, Hyde adds the following:</p>

<ul>
<li>Sidebar includes support for textual modules and a dynamically generated navigation with active link support</li>
<li>Two orientations for content and sidebar, default (left sidebar) and <a href="https://github.com/poole/lanyon#reverse-layout">reverse</a> (right sidebar), available via <code>&lt;body&gt;</code> classes</li>
<li><a href="https://github.com/poole/hyde#themes">Eight optional color schemes</a>, available via <code>&lt;body&gt;</code> classes</li>
</ul>

<p><a href="https://github.com/poole/hyde#readme">Head to the readme</a> to learn more.</p>

<h3>Browser support</h3>

<p>Hyde is by preference a forward-thinking project. In addition to the latest versions of Chrome, Safari (mobile and desktop), and Firefox, it is only compatible with Internet Explorer 9 and above.</p>

<h3>Download</h3>

<p>Hyde is developed on and hosted with GitHub. Head to the <a href="https://github.com/poole/hyde">GitHub repository</a> for downloads, bug reports, and features requests.</p>

<p>Thanks!</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/unity3d/%E6%B8%B8%E6%88%8F%E9%80%9A%E7%94%A8%E6%A8%A1%E5%9D%97/2013/12/14/Unity3D-%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90NGUI%E7%9A%84%E6%B8%B8%E6%88%8FUI%E6%9E%B6%E6%9E%84/">
        Unity3D-深入剖析NGUI的游戏UI架构
      </a>
    </h1>

    <span class="post-date">14 Dec 2013</span>

    <p>Unity3D-NGUI分析，使用NGUI做UI需要注意的几个要点在此我想罗列一下，对我在U3D上做UI的一些总结，最后解剖一下NGUI的源代码，它是如果架构和运作的。</p>

<p>在此前我介绍了自己项目的架构方式，所以在NGUI的利用上也是同样的做法，UI逻辑的程序不被绑定在物体上。那么如何做到GUI输入消息的传递呢，答案是：我封装了一个关于NGUI输入消息的类，由于NGUI的输入消息传递方式是U3D中的SendMessage方式，所以在每个需要接入输入的物体上动态的绑定该封装脚本。在这个消息封装类中，加入消息传递的委托方法后，所有关于该物体的输入消息将通过封装类直接传递到方法上，再通过消息类型的识别就可以脱离传统脚本绑定的束缚了。</p>

<p>在用NGUI制作UI时需要注意的几点：</p>

<p>1.每个GUI以1各UIPanel为标准，过多的UIPanel首先会导致DrawCall的增多，其次是导致UI逻辑的混乱。</p>

<p>2.UITexture不能使用的过于平凡，因为每个UITexture都会增加1各DrawCall，所以一般会作为背景图出现在UI上，小背景，大背景都可以。</p>

<p>3.图集不宜过大，过大的图集，不要把很多个GUI都放在一个图集里，在UI显示时加载资源IO速度会非常慢。我尝试了各种方式来管理图集，例如每个GUI一个图集，大雨300*100宽度的图不做图集，抑或一个系统模块2个图集，甚至我有尝试过以整个游戏为单位划分公共图集，按钮图集，头像图集，问题图集，但这种方式最终以图集过大IO过慢而放弃，这些图集的管理方式都是应项目而适应的，并没有固定的方式，最主要是你怎么理解程序读取资源时的IO操作时间。</p>

<p>4.在开发中，尽量用Free分辨率来测试项目的适配效果，不要到上线才发现适配问题。</p>

<p>适配源码：</p>

<p>float defaultWHRate = 800f / 480f;
float ScreenWHRate = (float)Screen.width / (float)Screen.height;
bool isUseHResize = defaultWHRate &gt;= ScreenWHRate ? false : true;
UIRoot root = GameObject.Find(&quot;ROOT&quot;).GetComponent<UIRoot>();
if (!isUseHResize)
{
    float curScreenH = (float)Screen.width / defaultWHRate;
    float Hrate = curScreenH / Screen.height;
    root.manualHeight =(int)(480f / Hrate);
}
else
{
    root.manualHeight = 480;
}</p>

<p>5.拆分以及固定各个锚点，上，左上，右上，中，左中，右中，下，左下，右下</p>

<p>6.拆分GUI层级，层级越高，显示越靠前。层级的正确拆分能有效管理GUI的显示方式。
/// <summary>
/// GUI层级
/// </summary>
public enum GUILAYER
{
    GUI<em>BACKGROUND = 0, //背景层
    GUI</em>MENU,           //菜单层0
    GUI<em>MENU1,           //菜单层1
    GUI</em>PANEL,          //面板层
    GUI<em>PANEL1,         //面板1层
    GUI</em>PANEL2,         //面板2层
    GUI<em>PANEL3,         //面板3层
    GUI</em>FULL,           //满屏层
    GUI<em>MESSAGE,        //消息层
    GUI</em>MESSAGE1,        //消息层
    GUI<em>GUIDE,           //引导层
    GUI</em>LOADING,        //加载层
}</p>

<p>8.要充分的管理GUI，不然过多的GUI会导致内存加速增长，而每次都销毁不用的GUI则会让IO过于频繁降低运行速度。我的方法是找到两者间的中间态，给予隐藏的GUI一个缓冲带,当每次某各GUI进行隐藏时判断是否有需要销毁的GUI。或者也可以这么做，每时每刻去监控隐藏的GUI，哪些GUI内存时间驻留过长就销毁。关于内存优化问题，可以参考<a href="http://www.luzexi.com/unity3d-texture%E5%9B%BE%E7%89%87%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%88%86%E6%9E%90/" target="_blank">《unity3d-texture图片空间和内存占用分析》</a>和 <a href="http://www.luzexi.com/unity3d%E4%BC%98%E5%8C%96%E4%B9%8B%E8%B7%AF/" target="_blank">《unity3d优化之路》</a></p>

<p>9.另外关于图标，像头像，物品，数量过多的，可以用打成几个图集，按一定规则进行排列，减小文件大小减少一次性读取的IO时间。</p>

<p>10.尽量减少不必要的UI更改，NGUI一旦有UI进行更改，它就得重新绘制MESH和贴图，比起cocos2d耗得CPU大的多。</p>

<p>11.如果可以不用动态字体就不要用动态字体，因为动态字体每次都会做IO操作读取相应的图片，这个是NGUI一个问题，费cpu，费内存。</p>

<p>12.设置脚本执行次序，在U3D的Project setting-&gt;Script Execution Order 中。由于NGUI以UIPanel为主要渲染入口，所以，所有关于游戏渲染处理的程序最好放在渲染之后，也就是UIPanel之后。UIPanel以LateUpdate为接口入口，所以关于渲染方面的程序还得斟酌是否方在LateUpdate里。</p>

<p>13.NGUI对于动态的移动旋转等的UI操作支持性很差，当有这种操作过多的时候，会使得屏幕很卡。解决办法就是，自己用程序生成面片，面片的渲染不再受到NGUI的控制。</p>

<p>以上是我能想起来的注意点，若有没想起来的，在以后的时间想到的也将补充进去。口无遮拦的说了这么多，不剖析一下源码怎么说的过去，之前对NGUI输入消息进行了封装，对2D动画序列帧进行了封装，却一直没能完整剖析它的底层源码，着实遗憾。</p>

<p>NGUI中UIPanel是渲染的关键，他承载了在他下面的子物体的所有渲染工作，每个渲染元素都是由UIWidget继承而来，每个UI物体的渲染都是由面片、材质球、UV点组成，每个种材质由一个UIDrawCall完成渲染工作，UIDrawCall中自己创建Mesh和MeshRender来进行统一的渲染工作。这些都是对NGUI底层的简单的介绍，下面将进行更加细致的分析。</p>

<p>首先我们来看UIWidget这个组件基类，从它拥有的类内部变量就能知道它承担得怎样的责任:</p>

<p>// Cached and saved values
[HideInInspector][SerializeField] protected Material mMat;//材质
[HideInInspector][SerializeField] protected Texture mTex;//贴图
[HideInInspector][SerializeField] Color mColor = Color.white;//颜色
[HideInInspector][SerializeField] Pivot mPivot = Pivot.Center;//对齐位置
[HideInInspector][SerializeField] int mDepth = 0;//深度
protected Transform mTrans;//坐标转换
protected UIPanel mPanel;//相应的UIPanel</p>

<p>protected bool mChanged = true;//是否更改
protected bool mPlayMode = true;//模式</p>

<p>Vector3 mDiffPos;//位置差异
Quaternion mDiffRot;//旋转差异
Vector3 mDiffScale;//缩放差异
int mVisibleFlag = -1;//可见标志</p>

<p>// Widget&#39;s generated geometry
UIGeometry mGeom = new UIGeometry();//多变形实例</p>

<p>UIWidget承担了存储显示内容，颜色调配，显示深度，显示位置，显示大小，显示角度，显示的多边形形状，归属哪个UIPanel。这就是UIWidget所要承担的内容，在UIWidget的所有子类中都具有以上相同的属性和任务。UIWidget和UIPanel的关系非常密切，因为UIPanel承担了UIWidget的所有渲染工作，而UIWidget只是承担了存储需要渲染数据。所以，在UIWidget在更换贴图，材质球，甚至更换UIPanel父节点时它会及时通知UIPanel说：&quot;我更变配置了，你得重新获取我的渲染数据&quot;。</p>

<p>UIWidget中最重要的虚方法为 virtual public void OnFill(BetterList<Vector3> verts, BetterList<Vector2> uvs, BetterList<Color32> cols) { } 它是区分子类的显示内容的重要方法。它的工作就是填写如何显示，显示什么。</p>

<p>UIWidget中在使用OnFill方法的重要的方法是 更新渲染多边型方法：
public bool UpdateGeometry (ref Matrix4x4 worldToPanel, bool parentMoved, bool generateNormals)
{
if (material == null) return false;</p>

<p>if (OnUpdate() || mChanged)
{
mChanged = false;
mGeom.Clear();
OnFill(mGeom.verts, mGeom.uvs, mGeom.cols);</p>

<p>if (mGeom.hasVertices)
{
Vector3 offset = pivotOffset;
Vector2 scale = relativeSize;
offset.x *= scale.x;
offset.y *= scale.y;</p>

<p>mGeom.ApplyOffset(offset);
mGeom.ApplyTransform(worldToPanel * cachedTransform.localToWorldMatrix, generateNormals);
}
return true;
}
else if (mGeom.hasVertices &amp;&amp; parentMoved)
{
mGeom.ApplyTransform(worldToPanel * cachedTransform.localToWorldMatrix, generateNormals);
}
return false;
}</p>

<p>它的作用就是，当需要重新组织多边型展示内容时，进行多边型的重新规划。</p>

<p>接着，我们来看看UINode，这个类很容易被人忽视，而他的作用也很重要。它是在UIPanel被告知有新的UIWidget显示元素时被创建的，它的创建主要是为了监视被创建的UIWidget的位置，旋转，大小是否被更改，若被更改，将由UIPanel进行重新的渲染工作。
HasChanged这是UINode唯一重要的方法之一，它的作用就是被UIPanel用来监视每个元素是否改变了进而进行重新渲染。</p>

<p>public bool HasChanged ()
{</p>

<h1>if UNITY<em>3 || UNITY</em>4_0</h1>

<p>bool isActive = NGUITools.GetActive(mGo) &amp;&amp; (widget == null || (widget.enabled &amp;&amp; widget.isVisible));</p>

<p>if (lastActive != isActive || (isActive &amp;&amp;
(lastPos != trans.localPosition ||
lastRot != trans.localRotation ||
lastScale != trans.localScale)))
{
lastActive = isActive;
lastPos = trans.localPosition;
lastRot = trans.localRotation;
lastScale = trans.localScale;
return true;
}</p>

<h1>else</h1>

<p>if (widget != null &amp;&amp; widget.finalAlpha != mLastAlpha)
{
mLastAlpha = widget.finalAlpha;
trans.hasChanged = false;
return true;
}
else if (trans.hasChanged)
{
trans.hasChanged = false;
return true;
}</p>

<h1>endif</h1>

<p>return false;
}</p>

<p>接着，来看UIDrawCall，它是被NGUI隐藏起来的类。他的内部变量来看看：</p>

<p>Transform        mTrans;            //坐标转换类
Material        mSharedMat;        // 渲染材质
Mesh            mMesh0;            //首个MESH
Mesh            mMesh1;            //用于更换的Mesh
MeshFilter        mFilter;        //绘制的MeshFilter
MeshRenderer    mRen;            //渲染MeshRender组件
Clipping        mClipping;        //裁剪类型
Vector4            mClipRange;        //裁剪范围
Vector2            mClipSoft;        //裁剪缓冲方位
Material        mMat;            //实例化材质
int[]            mIndices;        //做为Mesh三角型索引点</p>

<p>由这些内部变量可知，UIDrawCall是负责NGUI的最重要的渲染类。他制造Mesh制造Material，设置裁剪范围，为NGUI提供渲染底层。
他最重要的方法是：</p>

<p>public void Set (BetterList<Vector3> verts, BetterList<Vector3> norms, BetterList<Vector4> tans, BetterList<Vector2> uvs, BetterList<Color32> cols)
{
int count = verts.size;</p>

<p>// Safety check to ensure we get valid values
if (count &gt; 0 &amp;&amp; (count == uvs.size &amp;&amp; count == cols.size) &amp;&amp; (count % 4) == 0)
{
// Cache all components
if (mFilter == null) mFilter = gameObject.GetComponent<MeshFilter>();
if (mFilter == null) mFilter = gameObject.AddComponent<MeshFilter>();
if (mRen == null) mRen = gameObject.GetComponent<MeshRenderer>();</p>

<p>if (mRen == null)
{
mRen = gameObject.AddComponent<MeshRenderer>();</p>

<h1>if UNITY_EDITOR</h1>

<p>mRen.enabled = isActive;</p>

<h1>endif</h1>

<p>UpdateMaterials();
}
else if (mMat != null &amp;&amp; mMat.mainTexture != mSharedMat.mainTexture)
{
UpdateMaterials();
}</p>

<p>if (verts.size &lt; 65000)
{
int indexCount = (count &gt;&gt; 1) * 3;
bool rebuildIndices = (mIndices == null || mIndices.Length != indexCount);</p>

<p>// Populate the index buffer
if (rebuildIndices)
{
// It takes 6 indices to draw a quad of 4 vertices
mIndices = new int[indexCount];
int index = 0;</p>

<p>for (int i = 0; i &lt; count; i += 4)
{
mIndices[index++] = i;
mIndices[index++] = i + 1;
mIndices[index++] = i + 2;</p>

<p>mIndices[index++] = i + 2;
mIndices[index++] = i + 3;
mIndices[index++] = i;
}
}</p>

<p>// Set the mesh values
Mesh mesh = GetMesh(ref rebuildIndices, verts.size);
mesh.vertices = verts.ToArray();
if (norms != null) mesh.normals = norms.ToArray();
if (tans != null) mesh.tangents = tans.ToArray();
mesh.uv = uvs.ToArray();
mesh.colors32 = cols.ToArray();
if (rebuildIndices) mesh.triangles = mIndices;
mesh.RecalculateBounds();
mFilter.mesh = mesh;
}
else
{
if (mFilter.mesh != null) mFilter.mesh.Clear();
Debug.LogError(&quot;Too many vertices on one panel: &quot; + verts.size);
}
}
else
{
if (mFilter.mesh != null) mFilter.mesh.Clear();
Debug.LogError(&quot;UIWidgets must fill the buffer with 4 vertices per quad. Found &quot; + count);
}
}</p>

<p>在这个方法里，它制造Mesh,MeshFilter,MeshRender,Materials。</p>

<p>最后，我们来说说最重要的UI渲染入口UIPanel。
    UIPanel的渲染步骤：
    1.当有任何形式的UI组件启动渲染时加入UIPanel的渲染队列，当有新的渲染组件需要有新的UIDrawCall时，进行生成新的UIDrawCall.
    2.对所有UIPanel的渲染队列进行检查，是否队列中渲染组件需要重新渲染，包括位移，缩放，更改图片，启用，关闭.
    3.获取渲染组件对应的UIDrawCall，更新Mesh,贴图,UV，位置，大小
    4.对需要更新的UIDrawCall进行重新渲染
    5.最后标记已经渲染的渲染组件，告诉他们已经渲染，为下次判断更新做好准备。删除不再需要渲染的UIDrawCall，销毁渲染冗余。
    注意：所有的渲染都是在LateUpdate下进行，也就是它是进行的延迟渲染。
接口源码：
void LateUpdate ()
{
// Only the very first panel should be doing the update logic
if (list[0] != this) return;</p>

<p>// Update all panels
for (int i = 0; i &lt; list.size; ++i)
{
UIPanel panel = list[i];
panel.mUpdateTime = RealTime.time;
panel.UpdateTransformMatrix();
panel.UpdateLayers();
panel.UpdateWidgets();
}</p>

<p>// Fill the draw calls for all of the changed materials
if (mFullRebuild)
{
UIWidget.list.Sort(UIWidget.CompareFunc);
Fill();
}
else
{
for (int i = 0; i &lt; UIDrawCall.list.size; )
{
UIDrawCall dc = UIDrawCall.list[i];</p>

<p>if (dc.isDirty)
{
if (!Fill(dc))
{
DestroyDrawCall(dc, i);
continue;
}
}
++i;
}
}</p>

<p>// Update the clipping rects
for (int i = 0; i &lt; list.size; ++i)
{
UIPanel panel = list[i];
panel.UpdateDrawcalls();
}
mFullRebuild = false;
}</p>

<p>Fill()接口源码：
/// <summary>
/// Fill the geometry fully, processing all widgets and re-creating all draw calls.
/// </summary></p>

<p>static void Fill ()
{
for (int i = UIDrawCall.list.size; i &gt; 0; )
DestroyDrawCall(UIDrawCall.list[--i], i);</p>

<p>int index = 0;
UIPanel pan = null;
Material mat = null;
UIDrawCall dc = null;</p>

<p>for (int i = 0; i &lt; UIWidget.list.size; )
{
UIWidget w = UIWidget.list[i];</p>

<p>if (w == null)
{
UIWidget.list.RemoveAt(i);
continue;
}</p>

<p>if (w.isVisible &amp;&amp; w.hasVertices)
{
if (pan != w.panel || mat != w.material)
{
if (pan != null &amp;&amp; mat != null &amp;&amp; mVerts.size != 0)
{
pan.SubmitDrawCall(dc);
dc = null;
}</p>

<p>pan = w.panel;
mat = w.material;
}</p>

<p>if (pan != null &amp;&amp; mat != null)
{
if (dc == null) dc = pan.GetDrawCall(index++, mat);
w.drawCall = dc;
if (pan.generateNormals) w.WriteToBuffers(mVerts, mUvs, mCols, mNorms, mTans);
else w.WriteToBuffers(mVerts, mUvs, mCols, null, null);
}
}
else w.drawCall = null;
++i;
}</p>

<p>if (mVerts.size != 0)
pan.SubmitDrawCall(dc);
}</p>

<p>转载请注明出处：http://www.luzexi.com</p>

  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page6">Older</a>
  
  
    
      <a class="pagination-item newer" href="/page4">Newer</a>
    
  
</div>
    </div>

  </body>
</html>
