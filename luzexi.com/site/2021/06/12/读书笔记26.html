<!DOCTYPE html><html lang="en" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title> 读书笔记(二十六) 《C++ Primer》#2 - 技术人生</title><link rel="shortcut icon" href="/public/favicon.ico"><link rel="alternate" type="application/atom+xml" title="技术人生" href="/atom.xml"><link rel="alternate" type="application/json" title="技术人生" href="http://www.luzexi.com/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /><style> *,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0;padding:0}body{font-family:"Arial","Microsoft YaHei","黑体","宋体",sans-serif, system-ui, sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.5;font-size:1.4rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}code,pre{background:#ecedee}code{padding:.1rem}pre code{border:none}pre{padding:1rem;overflow-x:auto}img{max-width:100%}hr{background:#000;height:1px;border:0}header{flex-basis:13rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{font-style:italic;border-left:5px solid #ececec;padding-left:1rem}h1,h2,h3,h4,h5,h6{margin-bottom:.5rem;font-weight:bold;line-height:1.25;color:#313131;text-rendering:optimizeLegibility}h1{font-size:3rem}h2{margin-top:1rem;font-size:1.9rem}h3{margin-top:1.5rem;font-size:1.6rem}h4,h5,h6{margin-top:1rem;font-size:1.4rem}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:0.5rem}.posts ul,header ul{list-style:none}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}main{display:flex;flex-wrap:wrap;max-width:100rem;margin:2rem auto;padding:1rem}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:0.5rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}figcaption{font-size:smaller}.static_post{position:relative;padding-bottom:56.25%;padding-top:35px;height:0;overflow:hidden}.static_post iframe{position:absolute;top:0;left:0;width:100%;height:100%}</style></head><body><main role="main"><header role="banner"> <!--<h1 class="logo">技术人生</h1>--><nav role="navigation"><ul><li><a href="/" >主页</a></li><li><a href="/about" >关于我</a></li><li><a href="/search" >文章搜索</a></li><li><a href="/tag/书籍著作/" >书籍著作</a></li><li><a href="/tag/Unity3D/" >Unity3D</a></li><li><a href="/tag/图解游戏引擎/" >图解游戏引擎</a></li><li><a href="/tag/游戏通用模块/" >游戏通用模块</a></li><li><a href="/tag/前端技术/" >前端技术</a></li><li><a href="/tag/后端技术/" >后端技术</a></li><li><a href="/tag/其他技术/" >其他技术</a></li><li><a href="/tag/金融投资/" >金融投资</a></li><li><a href="/tag/life/" >思路探讨</a></li><li><a href="/tag/英文文章/" >英文文章</a></li><li><a href="/tag/读书笔记/" >读书笔记汇总</a></li><li><a href="/tag/演讲/" >演讲</a></li><li><a href="/tag/给女儿写信/" >给女儿写信</a></li><li><a href="/engineer-shopping" >成长必需品</a></li><li><a href="/friendlink" >友情链接</a></li><li><a href="/atom.xml" >Rss</a></li><li><a href="https://github.com/luzexi" >GitHub</a></li></ul></nav></header><section class="post"><h2>读书笔记(二十六) 《C++ Primer》#2</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484732&amp;idx=3&amp;sn=13204e3fd9171849653497a8c788c649&amp;chksm=fc22603bcb55e92dfe641a5066c21000b70a3a03a61d2c691324b23a20ae3fffeef40a70facd&amp;token=890029854&amp;lang=zh_CN#rd">已发布在微信公众号上，点击跳转</a></p><h2 id="背景">背景：</h2><p>我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意。第三是当我们在巩固时创造出了新的知识，那么这些新的知识和旧的知识将同时变成智慧融合到身体中。</p><p>本系列基于《C++ Primer》学习，由于重点放在“重学”，我略过了滚瓜烂熟的部分挑出以前常忽略的部分，以及记忆没有那么深刻的部分，特别是那些重要的但没有上心的部分。</p><h2 id="开始">开始</h2><h2 id="1const限定">1.const限定</h2><p>关键字const对变量的类型加以限定，因此它的值在初始化后不能被改变。</p><p>const默认情况下只在文件内生效，当需要支持多个文件共享时，则使用extern关键字，不管定义和声明都添加extern关键字，并且只需要定义一次。</p><figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">//a.cpp</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">test_constVar</span> <span class="o">=</span> <span class="n">fcn</span><span class="p">();</span>

<span class="c1">//b.cpp</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">test_constVar</span><span class="p">;</span></code></pre></figure><p>通过添加extern共享const变量。</p><h2 id="const引用常量引用">const引用（常量引用）</h2><p>与普通引用不同的是，常量引用不能被用作它修改它所绑定的对象。</p><figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r1</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>

<span class="n">r1</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span> <span class="c1">//错误，常量引用不能修改绑定对象</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span> <span class="c1">//错误，普通引用无法赋值常量</span></code></pre></figure><p>严格来说，并不存在常量引用。因为引用不是一个对象，所以我们没法让引用本身恒定不变。 事实上，由于c++语言并不允许随意改变引用所绑定的对象，所以从这层意义上理解所有的引用又都算是常量。 引用的对象是常量还是非常量可以决定其所能参与的操作，却无论如何都不会影响到引用和对象的绑定关系。 简单来说，由于绑定对象无法改变，所以要求引用对象也不能改变。</p><p>但const引用可以绑定一个非const对象，其意义为，绑定后const引用无法改变，只能由所绑定的对象来决定内容。</p><h2 id="const指针常量指针">const指针（常量指针）</h2><p>const指针与const引用有同样的规则。 const指针在初始化后无法改变，const指针不能改变所指对象的值，但可以指向非常量变量。 当指向非常量时，const指针所指向的对象的值，只能由对象本身来决定。</p><p>C++11中，用constexpr来表示常量表达式，声明为constexpr的变量是一个常量，编译器会验证变量的值是否为常量表达式并离线计算该值。</p><figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">mf</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//离线计算</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">mf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//离线计算</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">size</span><span class="p">();</span> <span class="c1">// size()必须是constexpr函数</span></code></pre></figure><h2 id="2类型别名">2.类型别名</h2><p>类型别名是某种类型的同义词。</p><p>使用类型别名是为了让复杂的类型名字变得简单明了、易于理解和使用。</p><p>C++11新标准中，使用using来定义类型的别名</p><figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">typedef</span> <span class="kt">double</span> <span class="n">wages</span><span class="p">;</span> <span class="c1">//wages是double的同义词</span>
<span class="k">typedef</span> <span class="n">wages</span> <span class="n">base</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="c1">//base是double的同义词，并且p是double*的同义词</span>
<span class="k">typedef</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pstring</span><span class="p">;</span> <span class="c1">//pstring 是char*的同义词</span>
<span class="k">using</span> <span class="n">It</span> <span class="o">=</span> <span class="n">Item_test</span><span class="p">;</span> <span class="c1">// It 是Item_test的同义词</span>

<span class="c1">//定义</span>
<span class="n">wages</span> <span class="n">test1</span><span class="p">;</span> <span class="c1">//定义double 变量</span>
<span class="n">It</span> <span class="n">item</span><span class="p">;</span> <span class="c1">//定义Item_test 变量</span>
<span class="n">pstring</span> <span class="n">cstr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//定义一个char *</span></code></pre></figure><h2 id="3其他">3.其他</h2><p>auto和decltype都是用来让编译器在离线下自动识别类型的关键字。 其中decltype着重识别结果类型与表达式的关系。</p><p>预处理器能确保头文件多次包含仍能安全工作，它在编译之前被执行。</p><figure class="highlight"><pre><code class="language-c--" data-lang="c++"> <span class="cp">#include、#define、#ifdef、#ifndef都是预处理关键字。</span></code></pre></figure><h2 id="第3章">第3章</h2><h2 id="1string字符串类">1.string字符串类</h2><p>前面说using可以用于类型别名，using也可以用于声明命名空间。 using namespace::name 不过头文件中不应包含using声明，因为这会导致头文件在被拷贝时多次重复声明using。</p><p>string是标准库中的类对象。 string在使用中最容易发生的问题就是拷贝。 特别是等号(=、+)引起的合并和拷贝需要注意。 string在比较时(==、!=、&lt;、&lt;=、&gt;、&gt;=)有比较算法但每个字符都会比较。</p><p>严格来说string对象不属于容器类型，但string支持很多与容器类似的操作，比如下标、迭代器等。</p><h2 id="2vector动态数组">2.vector动态数组</h2><p>vector是标准中的动态数组模版库。 模版本身不是类或函数，可以把模版看成编译器生成的类或函数。编译器根据模版创建类或函数的过程称为实例化。因此使用模版时，我们要指出编译器应把类或函数实例化成何种类型。 因此vector是模版而非类型，由vector生成的类才叫类型。</p><p>vector容器本身就是对象，因此也能通过拷贝初始化。</p><figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span> <span class="c1">// 初始化3个元素，1、2、3</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v2</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 初始化10个元素，都是-1</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v3</span> <span class="o">=</span> <span class="n">v1</span><span class="p">;</span> <span class="c1">// 用拷贝来初始化，将v1中的数据拷贝到v3，完成后v3拥有独立的数据</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v4</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span> <span class="c1">// 提前预备20个值，每个值都是0</span></code></pre></figure><p>由于vector是动态数组，因此如果能在初始化时提前告知vector的话，vector就不用扩容了，运行时性能会更好。</p><h2 id="3迭代器">3.迭代器</h2><p>迭代器有三种不同含意，一是迭代器概念本身，二是容器定义的迭代器类型，三是指某个迭代器对象。</p><p>有时她跟指针很像，但又完全不一样。</p><p>其实迭代器是个由模版封装过的类，根据不同的类型的容器，编译器生成功能相似但命名不同的类。</p><p>迭代器又重写了==、&gt;、&lt;、!=、&lt;=、&gt;=、+=、-=运算符，使得我们在编写代码时更加方便。</p><p>共识：当使用迭代器时如果对容器做了增删操作，则会使得迭代器失效，甚至报错和崩溃。</p><p>迭代器对象是实时生成的，当我们获取迭代器对象时，容器会实时生成一个迭代器对象，我们再通过操作这个迭代器对象达成我们的目的。</p><h2 id="4数组">4.数组</h2><p>一些复杂的数组声明难以理解，因此如果能从数组的名字开始按照由内向外的顺序阅读会更加容易些。</p><figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">// 普通数组含有10个整数</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">ptrs</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">// ptrs是含有10个整数指针的数组</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">Parray</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">;</span> <span class="c1">// Parray指向一个含有10个整数的数组</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">arrRef</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span> <span class="c1">// arrRef引用一个含有10个整数的数组</span>
<span class="kt">int</span> <span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arry</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptrs</span><span class="p">;</span> <span class="c1">//arry是数组的引用，该数组含有10个整数指针</span></code></pre></figure><p>数组真正使用的时候编译器会把它转成指针。 因此指向数组的指针可以使用+、-、==、!=运算符号来操作数组。</p><figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span>
<span class="o">++</span><span class="n">p</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="c1">// e指向arr元素的下一位置</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span> <span class="n">b</span><span class="o">!=</span><span class="n">e</span> <span class="p">;</span> <span class="o">++</span><span class="n">b</span><span class="p">)</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span></code></pre></figure><p>至于多维数组，严格来说C++中没有多维数组，通常所说的多维数组其实是数组的数组，也就是用数组类型组成的数组。</p><p>其中要注意的是在多维数组遍历时，其遍历顺序应该按照数组的整块内存来遍历，否则命中效率比较低。</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247484732&amp;idx=3&amp;sn=13204e3fd9171849653497a8c788c649&amp;chksm=fc22603bcb55e92dfe641a5066c21000b70a3a03a61d2c691324b23a20ae3fffeef40a70facd&amp;token=890029854&amp;lang=zh_CN#rd">已发布在微信公众号上，点击跳转</a></p><span class="meta"><time datetime="2021-06-12T00:00:00+08:00">June 12, 2021</time> &middot; <a href="/tag/读书笔记">读书笔记</a>, <a href="/tag/前端技术">前端技术</a></span> <!--<span class="meta"><time datetime="2021-06-12T00:00:00+08:00">June 12, 2021</time> &middot; <a class="post" href="/tag/读书笔记">读书笔记</a>, <a class="post" href="/tag/前端技术">前端技术</a></span> --><div><p /><p>感谢您的耐心阅读</p><p>Thanks for your reading</p><p /> <script type="text/javascript" src="/assets/js/tctip-1.0.3.min.js"></script> <script> new tctip({ top: '50%', button: { id: 9, type: 'zanzhu' }, list: [ { type: 'alipay', qrImg: '/assets/common/alipay.jpg' }, { type: 'wechat', qrImg: '/assets/common/wechatpay.jpg' }, { type: 'bitcoin', qrContent: '1ErCFmtoQY2KDctjgPALZri3USsMqdSvqh' } ] }).init() </script><li><p><strong><font color="red">版权申明</font></strong></p><p><strong><font color="red">本文为博主原创文章，未经允许不得转载:</font></strong></p><p><a href = "http://www.luzexi.com/2021/06/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B026">读书笔记(二十六) 《C++ Primer》#2</a></p><p><strong><font color="red">Copyright attention</font></strong></p><p><strong><font color="red">Please don't reprint without authorize.</font></strong></p></li><li><p></p><p></p><p><image src="/public/qrcode_for_gzh.jpg" width="344" height="344" /></p><p><strong>微信公众号，文章同步推送，致力于分享一个资深程序员在北上广深拼搏中对世界的理解</strong></p><p></p><p></p><p>QQ交流群: 777859752 (高级程序书友会)</p></li></div><p /><div class="related"><div class="bshare-custom icon-medium-plus"><div class="bsPromo bsPromo2"></div><a title="分享到微信" class="bshare-weixin" href="javascript:void(0);"></a><a title="分享到新浪微博" class="bshare-sinaminiblog"></a><a title="分享到QQ好友" class="bshare-qqim" href="javascript:void(0);"></a><a title="分享到QQ空间" class="bshare-qzone" href="javascript:void(0);"></a><a title="分享到Twitter" class="bshare-twitter" href="javascript:void(0);"></a><a title="分享到Facebook" class="bshare-facebook" href="javascript:void(0);"></a><a title="更多平台" class="bshare-more bshare-more-icon more-style-addthis"></a></div><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/buttonLite.js#style=-1&amp;uuid=36b4f383-d948-41a3-acd5-31ae604e3ad8&amp;pophcol=2&amp;lang=zh"></script><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/bshareC0.js"></script></div><p /><div class="related"><h2>最新发表的文章</h2><ul class="related-posts"><li><h3> <a href="/2023/08/25/%E5%9B%BE%E8%A7%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8A%80%E6%9C%AF1"> 图解游戏引擎 - 虚拟机技术（1） <small>25 Aug 2023</small> </a></h3></li><li><h3> <a href="/2023/08/10/%E5%9B%BE%E8%A7%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-Unity%E7%9A%84UGUI%E5%8E%9F%E7%90%863"> 图解游戏引擎 - Unity引擎的UGUI原理（3） <small>10 Aug 2023</small> </a></h3></li><li><h3> <a href="/2023/07/26/%E5%9B%BE%E8%A7%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-Unity%E7%9A%84UGUI%E5%8E%9F%E7%90%862"> 图解游戏引擎 - Unity引擎的UGUI原理（2） <small>26 Jul 2023</small> </a></h3></li></ul><h2 color='blue' >之后发表的文章</h2><ul class="related-posts"><li><h3> <a href="/2021/06/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B030"> 读书笔记(三十) 《C++ Primer》#4 <small>26 Jun 2021</small> </a></h3></li><li><h3> <a href="/2021/06/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B029"> 读书笔记(二十九) 《装载、链接与库》#2 静态链接过程 <small>20 Jun 2021</small> </a></h3></li><li><h3> <a href="/2021/06/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B028"> 读书笔记(二十八) 《C++ Primer》#3 <small>19 Jun 2021</small> </a></h3></li><li><h3> <a href="/2021/06/16/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A113"> 给女儿写信(十三) 要赢的是自己 <small>16 Jun 2021</small> </a></h3></li><li><h3> <a href="/2021/06/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B027"> 读书笔记(二十七) 《装载、链接与库》#1 回顾基础 <small>14 Jun 2021</small> </a></h3></li><h2>之前发表的文章</h2><ul class="related-posts"><li><h3> <a href="/2021/06/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B025"> 读书笔记(二十五) 《C++ Primer》#1 <small>07 Jun 2021</small> </a></h3></li><li><h3> <a href="/2021/05/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B024"> 读书笔记(二十四) 《如何高效阅读 - 中》 <small>29 May 2021</small> </a></h3></li><li><h3> <a href="/2021/05/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B023"> 读书笔记(二十三) 《如何高效阅读 - 上》 <small>23 May 2021</small> </a></h3></li><li><h3> <a href="/2021/05/14/%E6%80%9D%E8%B7%AF%E6%8E%A2%E8%AE%A865"> 思路探讨(六十五) 人生的框架 <small>14 May 2021</small> </a></h3></li><li><h3> <a href="/2021/05/11/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A112"> 给女儿写信(十二) 关于积分制 <small>11 May 2021</small> </a></h3></li></ul></div></section></main><script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "//hm.baidu.com/hm.js?f3d58556a7396e715b3602ef6754cd91"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script></body></html>
