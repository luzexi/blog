<!DOCTYPE html><html lang="en" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title> 读书笔记(五十一) 《游戏引擎架构》#4 低阶渲染器（4） - 技术人生</title><link rel="shortcut icon" href="/public/favicon.ico"><link rel="alternate" type="application/atom+xml" title="技术人生" href="/atom.xml"><link rel="alternate" type="application/json" title="技术人生" href="http://www.luzexi.com/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /><style> *,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0;padding:0}body{font-family:"Arial","Microsoft YaHei","黑体","宋体",sans-serif, system-ui, sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.5;font-size:1.4rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}code,pre{background:#ecedee}code{padding:.1rem}pre code{border:none}pre{padding:1rem;overflow-x:auto}img{max-width:100%}hr{background:#000;height:1px;border:0}header{flex-basis:13rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{font-style:italic;border-left:5px solid #ececec;padding-left:1rem}h1,h2,h3,h4,h5,h6{margin-bottom:.5rem;font-weight:bold;line-height:1.25;color:#313131;text-rendering:optimizeLegibility}h1{font-size:3rem}h2{margin-top:1rem;font-size:1.9rem}h3{margin-top:1.5rem;font-size:1.6rem}h4,h5,h6{margin-top:1rem;font-size:1.4rem}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:0.5rem}.posts ul,header ul{list-style:none}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}main{display:flex;flex-wrap:wrap;max-width:100rem;margin:2rem auto;padding:1rem}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:0.5rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}figcaption{font-size:smaller}.static_post{position:relative;padding-bottom:56.25%;padding-top:35px;height:0;overflow:hidden}.static_post iframe{position:absolute;top:0;left:0;width:100%;height:100%}</style></head><body><main role="main"><header role="banner"> <!--<h1 class="logo">技术人生</h1>--><nav role="navigation"><ul><li><a href="/" >主页</a></li><li><a href="/about" >关于我</a></li><li><a href="/search" >文章搜索</a></li><li><a href="/tag/书籍著作/" >书籍著作</a></li><li><a href="/tag/Unity3D/" >Unity3D</a></li><li><a href="/tag/游戏通用模块/" >游戏通用模块</a></li><li><a href="/tag/前端技术/" >前端技术</a></li><li><a href="/tag/后端技术/" >后端技术</a></li><li><a href="/tag/其他技术/" >其他技术</a></li><li><a href="/tag/金融投资/" >金融投资</a></li><li><a href="/tag/life/" >思路探讨</a></li><li><a href="/tag/英文文章/" >英文文章</a></li><li><a href="/tag/读书笔记/" >读书笔记汇总</a></li><li><a href="/tag/每日读书笔记/" >每日读书笔记</a></li><li><a href="/tag/给女儿写信/" >给女儿写信</a></li><li><a href="/engineer-shopping" >成长必需品</a></li><li><a href="/friendlink" >友情链接</a></li><li><a href="/atom.xml" >Rss</a></li><li><a href="https://github.com/luzexi" >GitHub</a></li></ul></nav></header><section class="post"><h2>读书笔记(五十一) 《游戏引擎架构》#4 低阶渲染器（4）</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247485096&amp;idx=1&amp;sn=c027b6af4677515ba1e5950aac8ba68d&amp;chksm=fc2263afcb55eab9204898b39fb77ee04f5767ac450507b6192a5c6d5612a45b6d29b1bcee16&amp;token=853743270&amp;lang=zh_CN#rd">已发布在微信公众号上，点击跳转</a></p><h1 id="背景">背景：</h1><p>作为游戏开发从业者，从业务到语言到框架到引擎，积累了一些知识和经验，特别是在看了几遍《游戏引擎架构》后对引擎架构的理解又深入了些。</p><p>近段时间有对引擎剖析的想法，正好借这书本对游戏引擎架构做一个完整分析。</p><p>此书用简明、清楚的方式覆盖了游戏引擎架构的庞大领域，巧妙地平衡了广度与深度，并且提供了足够的细节。</p><p>借助《游戏引擎架构》这本书、结合引擎源码和自己的经验，深入分析游戏引擎的历史、架构、模块，最后通过实践简单引擎开发来完成对引擎知识的掌握。</p><p>游戏引擎知识面深而广，所以对这系列的文章书编写范围做个保护，即不对细节进行过多的阐述，重点剖析的是架构、流程以及模块的运作原理。</p><p>同时《游戏引擎架构》中部分知识太过陈旧的部分，会重新深挖后总结出自己的观点。</p><h1 id="概述">概述：</h1><p>本系列文章对引擎中的重要的模块和库进行详细的分析，我挑选了十五个库和模块来分析：</p><p>1.时间库 2.自定义容器库 3.字符串散列库 4.内存管理框架 5.RTTI与反射模块 6.图形计算库 7.资产管理模块 8.低阶渲染器 9.剔除与合批模块 10.动画模块 11.物理模块 12.UI底层框架 13.性能剖析器的核心部分 14.脚本系统 15.视觉效果模块</p><p>本篇内容为列表中的第8个部分的第1节。</p><h1 id="正文">正文：</h1><p>简单回顾下前文</p><p>前文我们聊了下显卡在计算机硬件主板中的位置与结构，知道了CPU、GPU的通信介质，并简单介绍了手机上的主板结构。本篇开头对上一篇做一些内容补充，PC和手机的不同硬件组织，以及CPU与其他芯片的通信过程。</p><p>下面我们开始这篇内容</p><p>本次内容会围绕GPU来写，从硬件架构到软件驱动再到引擎架构，目标是帮大家理解GPU硬件的运作原理，理解图形接口的架构，理解引擎低阶渲染器的架构。</p><p>目录：</p><ul><li>主板结构中的显卡</li><li>GPU功能发展史</li><li>GPU与CPU的差异</li><li>GPU硬件特点</li><li>图形驱动程序架构</li><li>引擎低阶渲染架构</li></ul><p>内容结构：</p><ul><li>CPU硬件结构</li><li>GPU硬件结构</li><li>GPU手机管线与PC管线的差异</li></ul><p>接着上篇的内容。前面说了CPU、GPU的硬件结构，CPU的构造和GPU的构造，下面我们来聊聊GPU是如何工作的，以及GPU的管线在手机端和PC端的差异。</p><h2 id="nvidia基于fermi管线的架构">NVIDIA基于Fermi管线的架构</h2><p>关于GPU的逻辑管线，这篇Nvidia这篇文章《Life of a triangle - NVIDIA’s logical pipeline》说的很清楚。</p><p>（NVIDIA的整体架构图）</p><p>下面我以此为标准进行翻译并重新剖析。</p><p>为了简单起见，省略了几个细节，假设 drawcall 引用了一些已经充满数据并存在于 GPU DRAM 中的索引和顶点缓冲区，并且仅使用顶点和像素着色器（GL：片段着色器）。</p><p>（从图形API调用到图元处理过程图）</p><p>1.引擎或业务程序调用图形 API（DX 或 GL）中的绘图函数，接着驱动程序会被调用，驱动程序会进行一些验证以检查参数是否“合法”，再将指令写入到GPU可读写的缓冲队列中。在这个地方 CPU 方面可能会出现很多瓶颈，这也是为什么程序员要好好使用 API 以利用当今 GPU 的强大功能的技术很重要的原因。</p><p>（绘制接口调用图）</p><p>2.经过一段时间渲染，画面“刷新”被调用，驱动程序在缓冲区中已经缓冲了足够多的工作命令，接着将其发送给 GPU 进行处理（操作系统会参与）。最后 GPU 的主机接口接收命令并交给GPU前端的处理。</p><p>（绘制队列与刷新图）</p><p>3.接着图元分配器（Primitive Distributor）开始分配工作。为了批量处理索引和三角形，将数据发送给多个图形处理集群（GPC）并行处理。</p><p>（SM整体结构图）</p><p>4.在 GPC 中，每个 SM 的 Poly Morph 引擎负责从三角形索引中获取顶点数据(Vertex Fetch)。</p><p>5.在获取数据后，SM中每32个线程为一捆线程束（Warp），它们被调度去处理这些顶点工作。 线程束（Warp）是典型的单指令多线程（SIMT，SIMD单指令多数据的升级）的实现，也就是32个线程同时执行的指令是一模一样的，只是线程数据不一样，这样的好处就是一个Warp只需要一套逻辑对指令进行解码和执行就可以了，芯片可以做的更小更快。</p><p>（线程束与线程束调度器图）</p><p>6.SM的线程束（Warp）调度器会按照顺序分发指令给整个线程束（Warp），单个线程束（Warp）中的线程会锁步(lock-step)执行各自的指令。线程束（Warp）会使用SIMT的方式来做分支预测，每个线程执行的分支会不同，当线程遇到到错误判断的执行情况会被遮蔽(be masked out)。</p><p>（单个GPU线程与存储设备的关系图）</p><p>被遮蔽的原因是SIMT执行中错误预测，例如当前的指令是if(true)的分支，但是当前线程的数据的条件是false，或者循环的次数不一样（比如for循环次数n不是常量，或被break提前终止了但是别的还在走），因此在Shader中的分支会显著增加时间消耗，在一个线程束（Warp）中的分支除非32个线程都走到同一个里面，否则相当于所有的分支都走了一遍，线程不能独立执行指令而是以线程束（Warp）为单位，而这些线程束中的线程之间才是相互独立的。</p><p>（SIMT线程束做分支预测图）</p><p>7、线程束（Warp）中的指令可以被一次完成，也可能经过多次调度，例如通常SM中的LD/ST(加载存取)单元数量明显少于基础数学操作单元。</p><p>8、由于某些指令比其他指令需要更长的时间才能完成，特别是内存加载，线程束（Warp）调度器可能会简单地切换到另一个没有内存等待的线程束（Warp），这是GPU如何克服内存读取延迟的关键，其操作为简单地切换活动线程组。为了使这种切换更快，调度器管理的所有线程束（Warp）在寄存器列阵（Register File）中都有自己的寄存器。这里就会有个矛盾产生，Shader需要的寄存器越多，给线程束（Warp）留下的空间就越少，于是就会导致能用的线程束（Warp）就越少。此时如果碰到指令在内存获取数据等待就只会等待，而没有其他可以运行的线程束（Warp）可以切换。</p><p>（线程与寄存器列阵关系图）</p><p>（线程束调度器调度线程图）</p><p>9、一旦线程束（Warp）完成了顶点着色器（vertex-shader）的所有指令，运算结果会被Viewport Transform模块处理，三角形会被裁剪然后准备光栅化，此时GPU会使用L1和L2缓存来进行顶点着色起（vertex-shader）和片元着色起（pixel-shader）的数据通信。</p><p>（管线中节点、数据、存储器的关系图）</p><p>10、接下来这些三角形将被分割，通过 Work Distribution Crossbar 将三角形再分配给多个GPC，三角形的范围决定着它将被分配到哪个光栅引擎(raster engines)，每个光栅引擎（raster engines）覆盖了多个屏幕上的图块（tile），这等于把三角形的渲染分配到多个图块（tile）上面。也就是说在像素阶段前就把三角形划分成了方块格式范围，三角形处理分成许多较小的工作。</p><p>（三角形被拆分成多个块派发到多个光栅引擎图）</p><p>（图块拆分任务派发图）</p><p>11、SM上的属性安装器（Attribute Setup）保证了从顶点着色器（vertex-shader）生成的数据，经过插值后，在片元着色器（pixel-shade）上是可读的。</p><p>12、GPC上的光栅引擎(raster engines)处理它接收到的三角形，并为它负责的那些部分生成像素信息（同时会处理裁剪Clipping、背面剔除和Early-Z剔除）。</p><p>13、再次做批量处理，32个像素线程被分成一组（或者说8个2x2的像素块），这是在像素着色器上面的最小工作单元（2x2 四边形允许我们计算诸如纹理 mip 贴图过滤之类的导数–四边形内纹理坐标的大变化会导致更高的 mip）。在这个像素线程内，如果没有被任何三角形覆盖就会被剔除。SM中的线程束（Warp）调度器会管理像素着色器的任务。</p><p>（2x2像素组传入到线程束处理像素着色器的图）</p><p>14、接下来是同样的线程束调度策略，和顶点着色器（vertex-shader）中的逻辑步骤完全一样，但是变成了在像素着色器线程中执行。 由于不耗费任何性能从2x2四边形中获取一个像素，这使得锁步执行非常便利，于是所有的线程可以保证指令可以在同一点同步执行。</p><p>（线程束锁步执行图）</p><p>15、最后一步，现在像素着色器已经完成了颜色的计算和深度值的计算。在这个点上，我们必须考虑三角形的调用API顺序，然后才将数据移交给ROP(render output unit，渲染输出单元)，一个ROP内部有很多ROP单元，在ROP单元中处理深度测试和帧缓冲（framebuffer）的混合等，深度和颜色的设置必须是原子操作，否则两个不同的三角形在同一个像素点就会有冲突和错误。NVIDIA 通常应用内存压缩，以减少内存带宽要求，从而增加“有效”带宽。</p><p>（像素着色器后的像素处理过程图）</p><p>以上这些信息有助于我们理解 GPU 中的一些工作和数据流，还可以帮助我们理解CPU与GPU之间的交互。</p><h2 id="总结cpu和gpu的交互">总结CPU和GPU的交互</h2><p>GPU是设备，设备都有驱动，CPU可以直接执行二进制指令集，对于GPU设备，图形接口有opengl，directx标准及库封装，计算有cuda和opencl封装。程序代码调用这些图形或计算库，这些库调用驱动，驱动再来对接操作GPU设备，CPU与GPU直接的通信是遵循总线和内存的规则。</p><p>原则上CPU、内存外的设备都属于IO设备，通过总线连上来，它们必须遵守IO总线规范，如显卡就走pcie总线，这里还有ionmu，统一内存等，来共享资源，缩短路径，提升效率等。</p><p>这里专门说下驱动，计算机有专门的程序接口指定一个计算任务到GPU上，这个接口程序就是驱动程序。CPU给GPU下发任务时通过调用驱动程序，不同GPU厂商实现自己的驱动，并且提供了各种的编程接口。图形计算上实现了OpenGL标准接口规范的图形库，它会调用各厂商的驱动，用户可以通过GLSL编写计算任务进行通用计算。后来的CUDA编程模型专门推出用于编写通用计算任务的接口，于是OpenGL就专门用于图形渲染了。而CUDA则是通过kenel函数来编写计算任务，通过cudaLaunch接口来下发任务。</p><p>（从图形库到驱动到GPU指令队列的图）</p><p>从硬件角度看：</p><p>（从硬件角度看指令和数据处理流程图）</p><p>1.GPU设备的配置空间物理地址映射到虚拟地址，可以被程序直接访问；同时建立任务队列缓冲，声明中断等等；</p><p>2.CPU在进程内准备数据和缓冲，基于虚拟地址VA、VM将其转换为显存的物理地址IPA。驱动程序获取任务，再将任务信息填充至任务队列内。</p><p>3.根据虚拟内存绑定的地址信息，将任务队列的指针更新至GPU设备侧，这个端口称为doorbell寄存器；</p><p>4.设备接收到doorbell操作，会触发中断，再读取主存中的任务队列，包括队列内的信息和其指向的任务数据，GPU设备侧读取该数据。</p><p>5.完成后，再将数据发送给CPU侧。一般来说，GPU设备侧发送至CPU的读写请求使用的是虚拟地址，由CPU的IOMMU或SMMU转换为物理地址。</p><h2 id="gpu手机管线与pc管线的差异">GPU手机管线与PC管线的差异</h2><p>为什么要了解手机与PC管线的差异？ PC的能耗和发热比手机端可以更大一些，因此PC与手机在硬件架构上有天然的不同，进而使得它们在GPU管线上也有很大的差异，这使得我们在优化手机端时必须了解这种差异再做针对性的做优化。</p><h2 id="tbdrtile-base-deffered-rendering是现代移动端gpu的设计架构它同传统pc上irimmediate-rendering架构的gpu在硬件设计上有很大的差别">TBDR(Tile-Base-Deffered-Rendering)是现代移动端GPU的设计架构，它同传统PC上IR（Immediate-Rendering）架构的GPU在硬件设计上有很大的差别。</h2><p>为什么呢？因为功耗是Mobile设备设计的第一考虑因素，而带宽是功耗的第一杀手。</p><p>我们来看PC的GPU管线，即传统的IR（Immediate-Rendering）模式：</p><p>（IMR管线图：源自网络）</p><p>IMR（Immediate Mode Rendering）模式中，GPU直接在主存或显存上读写深度缓存（Depth Buffer）和帧缓存（Frame Buffer），这导致带宽消耗很大，如果在手机上耗电和发热都无法承受。</p><p>手机使用统一内存架构，CPU和GPU都通过总线来访问主存。GPU需要获取三角形数据（Geometry Data）、贴图数据（Texture Data）以及帧缓存（Frame Buffer），它们都在主存中。如果GPU直接从主存频繁地访问这些数据，就会导致带宽消耗大，成为性能瓶颈。</p><h2 id="tbrtile-based-rendering管线">TBR（Tile-Based-Rendering）管线</h2><p>基于以上所述原因，手机GPU使用自己的缓存区（SRAM），例如On-Chip深度缓存（On-Chip Depth Buffer）和On-Chip颜色缓存（On-Chip Color Buffer），它们与存取主存相比，速度更快，功耗更低。但它们的存储空间很小。（SRAM不需要充电来保持存储记忆，因此SRAM的读写基本不耗电，缺点是价格昂贵）</p><p>如果手机直接读写帧缓存（Frame Buffer）就相当于让一辆火车在你家和公司之间来回奔跑，非常耗电。于是手机端想要拆分绘制内容，每次只绘制一小部分，再把所有绘制完成的部分拼起来。</p><p>把帧缓存（Frame Buffer）拆分成很多个小块，使得每个小块可以被GPU附近的SRAM容纳，块的多少取决于GPU硬件的SRAM大小。这样GPU就可以分批的一块块的在SRAM上读写帧缓存（Frame Buffer），一整块都读写完毕后，再整体转移回主存上。</p><p>这种模式就叫做TBR（Tile-Based-Rendering），整体管线如下图：</p><p>（TBR管线图：源自网络）</p><p>屏幕分块后的大小一般为16x16或32x32像素 ，在几何阶段之后再执行分块(Tiling)，接着将各个块（Tile）逐个光栅化，最后写入帧缓存中（Frame Buffer）中 。</p><p>这里有一些细节要注意，TBR在接受每个指令（CommandBuffer）时并不立即绘制，而是先对这些数据做顶点处理，把顶点处理的结果暂时保存在主存上，等到非得刷新整个帧缓存时，才真正的用这批数据做光栅化。</p><p>因此，TBR的管线实际可以认为被切分成两部分，前半部分为顶点数据部分，后半部分为片元数据部分：</p><p>（TBR把管线切分为光栅化前和光栅化后）</p><h3 id="顶点数据先被处理并存储在frame-data中等到必须刷新时例如帧缓存置换调用glflush调用glfinish调用glreadpixels读取帧缓存像素时调用glcopytexiamge拷贝贴图时调用glbitframebuffer获取帧缓存时调用queryingocclusion解绑帧缓存时等等才被集中的拿去处理光栅化">顶点数据先被处理并存储在Frame Data中，等到必须刷新时（例如帧缓存置换，调用glflush，调用glfinish，调用glreadpixels读取帧缓存像素时，调用glcopytexiamge拷贝贴图时，调用glbitframebuffer获取帧缓存时，调用queryingocclusion，解绑帧缓存时等等）才被集中的拿去处理光栅化。</h3><h3 id="那么为什么pc不使用tbr呢">那么为什么PC不使用TBR呢？</h3><p>实际上直接对主存或显存（这里也有多级缓存）进行整块数据的读写速度是最快的，而TBR需要一块块的绘制，然后再回拷给主存。可以简单的认为TBR牺牲了执行效率，换来了相对更难解决的带宽功耗。如果哪一天手机上解决了带宽的功耗问题，或者说SRAM足够大了，可能就没有TBR了。</p><h2 id="tbdrtile-based-deferred-rendering管线">TBDR（Tile-based deferred rendering）管线</h2><p>TBR会把顶点数据处理完毕后存储在Frame Data中，那么就会有很多厂商针对Frame Data做优化。</p><p>TBDR整体的管线图如下：</p><p>（TBDR管线图：源自网络）</p><p>我们看到相比TBR，TBDR在光栅化（Raster）后多了一个HSR（Hidden Surface Removal）处理，这部分处理主要剔除无需绘制的元素，减少重绘（Overdraw）数量（高通通过优化划分块（Tile）之后执行顶点着色器（Vertex Shader）之前的节点来达到此目的，称为LRZ）。例如提前对不透明像素做深度测试并剔除，剔除被模板裁剪掉的像素等等，总之它们不会进入到像素着色器阶段（Pixel Shader）。</p><p>因此在TBDR上，不透明物体的排序没有太大意义，Early-Z这种策略也不存在IOS上。这些GPU硬件巧妙的利用TBR的Frame Data队列实现了一种延迟渲染，尽可能只渲染那些会最终影响帧缓存（Frame Buffer）的像素。</p><h3 id="tbdr和软件上的延迟渲染相比有什么区别呢">TBDR和软件上的延迟渲染相比有什么区别呢？</h3><p>软件层面的延迟渲染与TBDR不同。软件层面的延迟渲染是针对一个Drawcall，对于从后到前的不透明物体绘制是每次都要绘制的，而硬件层面的延迟渲染，处理的是一整批Drawcall，剔除这一整批Drawcall中不会绘制的像素最后再渲染。可以说现在大部分的移动端的GPU都使用TBDR架构。</p><h3 id="参考资料">参考资料：</h3><p>《How Shader Cores Work》 https://engineering.purdue.edu/~smidkiff/KKU/files/GPUIntro.pdf</p><p>《CPU体系结构》 https://my.oschina.net/fileoptions/blog/1633021</p><p>《深入理解CPU的分支预测(Branch Prediction)模型》 https://zhuanlan.zhihu.com/p/22469702</p><p>《分析Unity在移动设备的GPU内存机制（iOS篇）》 https://www.jianshu.com/p/68b41a8d0b37</p><p>《PC与Mobile硬件架构对比》 https://www.cnblogs.com/kekec/p/14487050.html</p><p>《针对移动端TBDR架构GPU特性的渲染优化》 https://gameinstitute.qq.com/community/detail/123220</p><p>《A look at the PowerVR graphics architecture: Tile-based rendering》 https://www.imaginationtech.com/blog/a-look-at-the-powervr-graphics-architecture-tile-based-rendering/</p><p>《A look at the PowerVR graphics architecture: Deferred rendering》 https://www.imaginationtech.com/blog/the-dr-in-tbdr-deferred-rendering-in-rogue/</p><p>《深入GPU硬件架构及运行机制》 https://www.cnblogs.com/timlly/p/11471507.html</p><p>《深入浅出计算机组成原理》 https://time.geekbang.org/column/article/105401?code=7VZ-Md9oM7vSBSE6JyOgcoQhDWTOd-bz5CY8xqGx234%3D</p><p>《Nvidia Geforce RTX-series is born》 https://www.fudzilla.com/reviews/47224-nvidia-geforce-rtx-series-is-born?start=2</p><p>《渲染管线与GPU（Shading前置知识）》 https://zhuanlan.zhihu.com/p/336999443</p><p>《剖析虚幻渲染体系（12）- 移动端专题Part 1（UE移动端渲染分析）》 https://www.cnblogs.com/timlly/p/15511402.html</p><p>《tpc-texture-processing-cluster》 https://gputoaster.wordpress.com/2010/12/11/tpc-texture-processing-cluster/</p><p>《Life of a triangle - NVIDIA’s logical pipeline》 https://developer.nvidia.com/content/life-triangle-nvidias-logical-pipeline</p><p>《Rasterisation wiki》 https://en.wikipedia.org/wiki/Rasterisation</p><p>《PolyMorph engine and Data Caches by Hilbert Hagedoorn》 https://www.guru3d.com/articles-pages/nvidia-gf100-(fermi)-technology-preview,3.html</p><p>《NVIDIA GPU的一些解析》 https://zhuanlan.zhihu.com/p/258196004</p><p>《tensor-core-performance-the-ultimate-guide》 https://developer.download.nvidia.cn/video/gputechconf/gtc/2019/presentation/s9926-tensor-core-performance-the-ultimate-guide.pdf</p><p>《Understanding the Understanding the graphics pipeline》 https://www.seas.upenn.edu/~cis565/LECTURES/Lecture2%20New.pdf</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&amp;mid=2247485096&amp;idx=1&amp;sn=c027b6af4677515ba1e5950aac8ba68d&amp;chksm=fc2263afcb55eab9204898b39fb77ee04f5767ac450507b6192a5c6d5612a45b6d29b1bcee16&amp;token=853743270&amp;lang=zh_CN#rd">已发布在微信公众号上，点击跳转</a></p><span class="meta"><time datetime="2021-12-12T00:00:00+08:00">December 12, 2021</time> &middot; <a href="/tag/读书笔记">读书笔记</a>, <a href="/tag/前端技术">前端技术</a></span> <!--<span class="meta"><time datetime="2021-12-12T00:00:00+08:00">December 12, 2021</time> &middot; <a class="post" href="/tag/读书笔记">读书笔记</a>, <a class="post" href="/tag/前端技术">前端技术</a></span> --><div><p /><p>感谢您的耐心阅读</p><p>Thanks for your reading</p><p /> <script type="text/javascript" src="/assets/js/tctip-1.0.3.min.js"></script> <script> new tctip({ top: '50%', button: { id: 9, type: 'zanzhu' }, list: [ { type: 'alipay', qrImg: '/assets/common/alipay.jpg' }, { type: 'wechat', qrImg: '/assets/common/wechatpay.jpg' }, { type: 'bitcoin', qrContent: '1ErCFmtoQY2KDctjgPALZri3USsMqdSvqh' } ] }).init() </script><li><p><strong><font color="red">版权申明</font></strong></p><p><strong><font color="red">本文为博主原创文章，未经允许不得转载:</font></strong></p><p><a href = "http://www.luzexi.com/2021/12/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B051">读书笔记(五十一) 《游戏引擎架构》#4 低阶渲染器（4）</a></p><p><strong><font color="red">Copyright attention</font></strong></p><p><strong><font color="red">Please don't reprint without authorize.</font></strong></p></li><li><p></p><p></p><p><image src="/public/qrcode_for_gzh.jpg" /></p><p><strong>微信公众号，文章同步推送，致力于分享一个资深程序员在北上广深拼搏中对世界的理解</strong></p><p></p><p></p><p>QQ交流群: 777859752 (高级程序书友会)</p></li></div><p /><div class="related"><div class="bshare-custom icon-medium-plus"><div class="bsPromo bsPromo2"></div><a title="分享到微信" class="bshare-weixin" href="javascript:void(0);"></a><a title="分享到新浪微博" class="bshare-sinaminiblog"></a><a title="分享到QQ好友" class="bshare-qqim" href="javascript:void(0);"></a><a title="分享到QQ空间" class="bshare-qzone" href="javascript:void(0);"></a><a title="分享到Twitter" class="bshare-twitter" href="javascript:void(0);"></a><a title="分享到Facebook" class="bshare-facebook" href="javascript:void(0);"></a><a title="更多平台" class="bshare-more bshare-more-icon more-style-addthis"></a></div><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/buttonLite.js#style=-1&amp;uuid=36b4f383-d948-41a3-acd5-31ae604e3ad8&amp;pophcol=2&amp;lang=zh"></script><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/bshareC0.js"></script></div><p /><div class="related"><h2>最新发表的文章</h2><ul class="related-posts"><li><h3> <a href="/2022/11/17/%E8%85%BE%E8%AE%AF%E7%9B%B4%E6%92%AD%E5%88%86%E4%BA%AB-%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6%E5%89%96%E6%9E%90"> 腾讯技术工程分享 - 游戏技术框架剖析 <small>17 Nov 2022</small> </a></h3></li><li><h3> <a href="/2022/11/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B067"> 读书笔记(六十七) 游戏引擎架构#6 - 渲染管线 <small>09 Nov 2022</small> </a></h3></li><li><h3> <a href="/2022/10/26/%E6%BC%94%E8%AE%B2-%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B"> UWA Day 行业大会分享《如何快速进阶主程》 <small>26 Oct 2022</small> </a></h3></li></ul><h2 color='blue' >之后发表的文章</h2><ul class="related-posts"><li><h3> <a href="/2022/01/23/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A121"> 给女儿写信(二十一) 早上运动的力量 <small>23 Jan 2022</small> </a></h3></li><li><h3> <a href="/2022/01/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B053"> 读书笔记(五十三) 《如何做好PPT》- PPT设计的艺术 <small>10 Jan 2022</small> </a></h3></li><li><h3> <a href="/2022/01/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B052"> 读书笔记(五十二) 《如何精彩演讲》#3 如何即兴演讲 <small>06 Jan 2022</small> </a></h3></li><li><h3> <a href="/2022/01/03/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A120"> 给女儿写信(二十) 观察自己的情绪 <small>03 Jan 2022</small> </a></h3></li><li><h3> <a href="/2021/12/29/%E6%96%B0%E4%B9%A6%E5%8F%91%E5%94%AE"> 新书发售《Unity3D高级编程-主程手记》 <small>29 Dec 2021</small> </a></h3></li><h2>之前发表的文章</h2><ul class="related-posts"><li><h3> <a href="/2021/12/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B049"> 读书笔记(五十) 《如何精彩演讲》#2 克服演讲时的恐惧 <small>05 Dec 2021</small> </a></h3></li><li><h3> <a href="/2021/11/27/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A119"> 给女儿写信(十九) 说出自己的感受积极化解情绪 <small>27 Nov 2021</small> </a></h3></li><li><h3> <a href="/2021/11/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B050"> 读书笔记(四十九) 《游戏引擎架构》#4 低阶渲染器（3） <small>22 Nov 2021</small> </a></h3></li><li><h3> <a href="/2021/11/08/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B048"> 读书笔记(四十八) 《游戏引擎架构》#4 低阶渲染器（2） <small>08 Nov 2021</small> </a></h3></li><li><h3> <a href="/2021/11/01/%E7%BB%99%E5%A5%B3%E5%84%BF%E7%9A%84%E4%BF%A118"> 给女儿写信(十八) 面对困难时该如何去做 <small>01 Nov 2021</small> </a></h3></li></ul></div></section></main><script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "//hm.baidu.com/hm.js?f3d58556a7396e715b3602ef6754cd91"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script></body></html>
