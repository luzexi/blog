---
layout: post
status: publish
published: false
title: 读书笔记(十八) 《C++性能优化指南》三
description: "读书 书 看书 读后感"
excerpt_separator: ===
tags:
- 读书笔记
---

## 热点代码

这里作者带我们聊一聊关于代码细节的优化，虽然语句的细节优化并不能带来非常明显的提升，但是也是非常有必要的优化步骤，尤其在那些追求极致高性能或精小的组件中，代码细节的优化决定了组件与组件之间的差异。

语句细节的优化，其实质是对CPU指令的优化。语句级别的优化可以被认为是从执行指令流中移除指令的过程。

### 语句的细节优化，其实质是执行指令数量的优化，指令跳转次数的优化，向栈中保存临时寄存器次数的优化，以及内存分配次数的优化。

为什么呢？

执行指令数量减少了可以减少CPU在执行程序时的耗时我们很好理解，指令跳转则是因为指令也是被放在内存中的数据，因此它也会被高速缓存cache，长距离跳转会让高速缓存失效，静态函数调用和非成员函数调用通常都是长距离指令跳转的典型案例。

即使一个空函数，在调用时也会有性能开销，有时为了极致的优化，我们应该最大限度的减少调用函数的频率，特别是频率最高的那几个。

这是因为在函数被调用时会保存当前函数的数据，包括参数、局部变量、当前指令地址、临时寄存器和标记寄存器等，每次调用一个函数会做如下处理：

		1.当调用函数时，先保存当前函数的临时变量、参数、临时寄存器、标记寄存器。
		
		2.将这些每个要保存的数据都复制到栈中。
		
		3.当前执行的地址复制到栈中。

		4.将指令指针寄存器IP指向要执行的函数体的第一句

		5.执行函数体中的指令

		6.将函数调用结果保存到寄存器

		7.从栈中推出要返回的地址，并复制给指令寄存器IP

		8.推出栈中的临时寄存器、参数、局部变量、标记寄存器都重新还原回去

		9.继续执行剩下的指令直到遇到下一个函数。

如果遇到成员函数是虚函数的，还得先从虚表中偏移并取出函数地址再调用，这里又多了2次计算，即先取出虚表地址、再根据虚表地址偏移获得真正的函数地址、最后再才能跳转过去。如果是多重继承、或者是多重继承的继承类中的虚函数成员，则需要再加一次地址偏移计算。

inline内联是减少函数调用的最佳方式，内联函数并不像一般函数那样会保存数据并且跳转指令，因为编译器会就地展开内联函数中的指令，因此没有推栈入栈保存数据到栈和跳转指令到函数再返回的步骤，取而代之的是就地直接执行指令。

这样看来减少函数调用(或让函数内联)的同时也减少了入栈、出栈、复制数据的指令数量，也减少了指令跳转的丢失高速缓存的概率。

不必要的内存分配也是在代码细节中常犯的错误，尤其指向堆内存分配，当函数中需要某个容器或者类实例时，常会临时向堆内存申请一次以用来计算。

我们来看看以上这说的4个细节的具体例子：

``` c++

for(int i = 0 ; i<strlen(str) ; i++)
	...

//改为

for(int i = 0, n = strlen(str) ; i<n ; i++)
	...

```

#### 这里不一定有优化，因为编译器可能会识别这类循环并将实时计算移出去，不过不能保证编译器一定会这么干，所以我们最好做人为的优化，保证不重复计算。

``` c++

void function()
{
	list = new list();
	for(int i = 0 ; i<n ; i++)
	{
		list.Add(xx);
	}

	return;
}

//改为

public static list = new list(); //改为全局变量

void function()
{
	list.Clear();
	for(int i = 0 ; i<n ; i++)
	{
		list.Add(xx);
	}

	return;
}

```

#### 函数中临时的堆内存分配，改为全局的共用内存，只要分配一次，每次使用前先清理就能节省开销。

``` c++

int k = 0;
for(int i = 0 ; i<100 ; i++)
{
	int j = sin(100) + cos(50);
	k = j*i;
}

//改为

int k = 0;
int j = sin(100) + cos(5);
for(int i = 0 ; i<100 ; i++)
{
	k = j*i;
}

```

#### 移除循环中不变的计算，减少不必要的指令，可能会被编译器优化掉。

``` c++
for(int i = 0 ; i<10 ; i++)
{
	int b = Add(3,5);
	...
}

//改为

int b = 0
for(int i = 0 ; i<10 ; i++)
{
	b = 3 + 5;
	...
}

//或者将Add函数内联

inline Add(a,b)
{
	...
}

```

#### 用内联或者手动内联的方式，减少循环中的函数调用开销。

``` c++

string str = "a";

str = "<p>" + str + "</p>";

//改为

str = string.format("<p>{0}</p>",str);

```

#### 减少字符串内存分配次数，将原来要分配两次的字符串，改为只要分配1次。或者用更好的内存管理方式管理内存

``` c++

for(int i = 0 ; i<1000 ; i++)
{
	test();
}

//改为

test();

void test()
{
	for(int i = 0 ; i<1000 ;i++)
	{
		...
	}
}

```

#### 将1000次调用函数的开销改为1次。

``` c++

if(x == a)
{
	...
}
else if(xx == a)
{
	...
}
else if(xxx == a)
{
	...
}
else ...

//改为

switch(a)
{
	case x:
		break;
	case xx:
		break;
	case xxx:
		break;
}

```

#### 通常switch都会被编译器优化为索引的方式去跳转，因此用switch比if效率高的多，也不用我们自己对数据排序。

最后说下异常try catch的开销，在早期C++的try catch机制会在栈帧上包含一个异常上下文，这些上下文会随着异常抛出或者作用范围结束而销毁，增加性能开销。现在则不同了，开销没有开销，只是会在开始try时多几个指令更改中断程序的指向，退出时再改回来。如果太多try catch的调用仍然会多出很多额外的消耗。

### 我们做个小结，我们说语句的细节优化，实质是减少执行指令数量，减少指令跳转次数，减少函数调用，以及减少内存分配次数。我们用代码细节来解释有哪些细节是可以遵从我们的原理来优化的，这些细节的优化，在性能要求比较高的组件上会比较有用，而在比较庞大的业务逻辑面前则显得微不足道。特别是业务逻辑上，我们更多运用的是调整实现方式，或调整数据结构的方式，或调整业务逻辑策略的方式来实现业务上的优化。具体的业务逻辑优化总结以后面再专门写一篇业务逻辑优化来学习和总结下，这里举几个简单的例子，例如计算缓存机制，事件机制代替更新机制，分线程算力分摊，预加载预分配策略，摄像机内外业务逻辑裁剪策略等，涵盖内容比较多这里暂不暂开讨论。

## IO

文件IO底层机制的几种方式，磁盘运行原理

同步读取和异步读取

减少读取次数

预先知道文件有多大，先分配同样大小的内存，减少读取次数

写入文件，减少flash调用次数

分帧读取，增强画面体验

## 并发

由于设备资源并不总是运行，是因为某些程序并没有使用到某些资源，这使得资源的闲置造成了浪费，如果能在当某个程序在执行指令时，另一个设备在满负荷运作，这样就相当于提高了运行效率。我们希望计算机资源包括IO资源运行的饱和度能达到100%，这样我们在执行各种程序时就能让计算机满负荷奔跑，而不只是某个CPU和内存。

资源有，多个cpu，硬盘，网卡，显卡，声卡

并发的挑战是找到足够多的独立任务来充分地使用所有可用的计算机资源，让资源都能满负荷的执行，提高整体运行效率。

线程、进程在Linux中的运行机制，时间片概念

操作系统会维护一份当前正在执行的程序和系统任务的列表，并为每个程序都分配时间。

进程并发的优点是隔离了两个进程之间的关系，缺点是启动、停止和切换都比线程慢的多。

线程的开关虽然比进程消耗小，但它的消耗还是太大，线程池对优化起的作用。

线程交叉执行的可能结果

为什么线程交叉执行内存写入时，会得到不一样的结果？

线程同步的方案，互斥量、锁、

原子性，什么是原子性，为什么要用原子性。

内存对齐时与不对齐时同步问题

内存栅栏是什么？为什么要用内存栅栏？它是怎么工作的？

加入更多SIMD指令

线程数量的多少取决于什么？

线程间的合作，消息传递机制，管道和循环管道

无锁容器的原理

如何让在做互斥时，让线程之间的配合更搞笑，

	减少锁区间的执行指令

什么是线程惊群？如何避免？


减少竞争线程的方法

	复制多分资源，减少争夺

	分割资源，分块读取

	锁的范围更小，局限在容器的某个节点上，而不是整个容器

	散列容器，无锁处理















