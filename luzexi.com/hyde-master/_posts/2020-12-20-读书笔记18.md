---
layout: post
status: publish
published: false
title: 读书笔记(十八) 《C++性能优化指南》三
description: "读书 书 看书 读后感"
excerpt_separator: ===
tags:
- 读书笔记
---

## 热点代码

这里作者带我们聊一聊关于代码细节的优化，虽然语句的细节优化并不能带来非常明显的提升，但是也是非常有必要的优化步骤，尤其在那些追求极致高性能或精小的组件中，代码细节的优化决定了组件与组件之间的差异。

语句细节的优化，其实质是对CPU指令的优化。语句级别的优化可以被认为是从执行指令流中移除指令的过程。

语句的细节优化，其实质是执行指令数量的优化，指令跳转次数的优化，向栈中保存临时寄存器次数的优化，以及内存分配次数的优化。

为什么呢？

执行指令数量减少了可以减少CPU在执行程序时的耗时我们很好理解，指令跳转则是因为指令也是被放在内存中的数据，因此它也会被高速缓存cache，长距离跳转会让高速缓存失效，因此我们要减少过长的if...else，至少让频率高的内容放在前面。

其实减少向栈中保存寄存器的意义就在于减少执行指令和跳转的开销。

这是因为在函数被调用时会保存当前函数的数据，包括参数、局部变量、当前指令地址、临时寄存器和标记寄存器等，每次调用一个函数会做如下处理：

		1.当调用函数时，先保存当前函数的临时变量、参数、临时寄存器、标记寄存器。
		
		2.将这些每个要保存的数据都复制到栈中。
		
		3.当前执行的地址复制到栈中。

		4.将指令指针寄存器IP指向要执行的函数体的第一句

		5.执行函数体中的指令

		6.将函数调用结果保存到寄存器

		7.从栈中推出要返回的地址，并复制给指令寄存器IP

		8.推出栈中的临时寄存器、参数、局部变量、标记寄存器都重新还原回去

		9.继续执行剩下的指令直到遇到下一个函数。

如果遇到成员函数是虚函数的，还得先从虚表中偏移并取出函数地址再调用，这里又多了2次计算，即先取出虚表地址、再根据虚表地址偏移获得真正的函数地址、最后再才能跳转过去。如果是多重继承、或者是多重继承的继承类中的虚函数成员，则需要再加一次地址偏移计算。

inline内联是减少函数调用的最佳方式，内联函数并不像一般函数那样会保存数据并且跳转指令，因为编译器会就地展开内联函数中的指令，因此没有推栈入栈保存数据到栈和跳转指令到函数再返回的步骤，取而代之的是就地直接执行指令。

这样看来减少函数调用(或让函数内联)的同时也减少了入栈、出栈、复制数据的指令数量，也减少了指令跳转的丢失高速缓存的概率。

不必要的内存分配也是在代码细节中常犯的错误，尤其指向堆内存分配，当函数中需要某个容器或者类实例时，常会临时向堆内存申请一次以用来计算。

我们来看看以上这说的4个细节的具体例子：

``` c++

for(int i = 0 ; i<strlen(str) ; i++)
	...

//改为

for(int i = 0, n = strlen(str) ; i<n ; i++)
	...

```

这里不一定有优化，因为编译器可能会识别这类循环并将实时计算移出去，不过不能保证编译器一定会这么干，所以我们最好做人为的优化，保证不重复计算。

``` c++

void function()
{
	list = new list();
	for(int i = 0 ; i<n ; i++)
	{
		list.Add(xx);
	}

	return;
}

//改为

public static list = new list(); //改为全局变量

void function()
{
	list.Clear();
	for(int i = 0 ; i<n ; i++)
	{
		list.Add(xx);
	}

	return;
}

```

函数中临时的堆内存分配，改为全局的共用内存，只要分配一次，每次使用前先清理就能节省开销。

``` c++

if(a > 0)
{
	...
}

return;

//改为

if(a <= 0) return;

...

```

减少不必要的指令跳转

``` c++

int k = 0;
for(int i = 0 ; i<10 ; i++)
{
	int j = sin(100) + cos(50);
	k = j*i;
}

//改为

int k = 0;
int j = sin(100) + cos(5);
for(int i = 0 ; i<10 ; i++)
{
	k = j*i;
}

```

移除循环中不变的计算，减少不必要的指令，可能会被编译器优化掉。

``` c++
for(int i = 0 ; i<10 ; i++)
{
	int b = Add(3,5);
	...
}

//改为

int b = 0
for(int i = 0 ; i<10 ; i++)
{
	b = 3 + 5;
	...
}

//或者将Add函数内联

inline Add(a,b)
{
	...
}

```

用内联或者手动内联的方式，减少循环中的函数调用开销。

``` c++

string str = "a";

str = "<p>" + str + "</p>";

//改为

str = string.format("<p>{0}</p>",str);

```

减少字符串内存分配次数，将原来要分配两次的字符串，改为只要分配1次。

``` c++

for(int i = 0 ; i<10 ; i++)
{
	test();
}

//改为

test();

void test()
{
	for(int i = 0 ; i<10 ;i++)
	{
		...
	}
}

```

将10次调用函数的开销改为1次。


模板代替虚函数



函数开销的原理，以及继承中的函数调用，以及多重继承的函数调用

表达式运算优化

switch 和 if

异常try catch的开销和运行机制

## IO

文件IO底层机制的几种方式，磁盘运行原理

同步读取和异步读取

减少读取次数

预先知道文件有多大，先分配同样大小的内存，减少读取次数

写入文件，减少flash调用次数

分帧读取，增强画面体验

## 并发

由于设备资源并不总是运行，是因为某些程序并没有使用到某些资源，这使得资源的闲置造成了浪费，如果能在当某个程序在执行指令时，另一个设备在满负荷运作，这样就相当于提高了运行效率。我们希望计算机资源包括IO资源运行的饱和度能达到100%，这样我们在执行各种程序时就能让计算机满负荷奔跑，而不只是某个CPU和内存。

资源有，多个cpu，硬盘，网卡，显卡，声卡

并发的挑战是找到足够多的独立任务来充分地使用所有可用的计算机资源，让资源都能满负荷的执行，提高整体运行效率。

线程、进程在Linux中的运行机制，时间片概念

操作系统会维护一份当前正在执行的程序和系统任务的列表，并为每个程序都分配时间。

进程并发的优点是隔离了两个进程之间的关系，缺点是启动、停止和切换都比线程慢的多。

线程的开关虽然比进程消耗小，但它的消耗还是太大，线程池对优化起的作用。

线程交叉执行的可能结果

为什么线程交叉执行内存写入时，会得到不一样的结果？

线程同步的方案，互斥量、锁、

原子性，什么是原子性，为什么要用原子性。

内存对齐时与不对齐时同步问题

内存栅栏是什么？为什么要用内存栅栏？它是怎么工作的？

加入更多SIMD指令

线程数量的多少取决于什么？

线程间的合作，消息传递机制，管道和循环管道

无锁容器的原理

如何让在做互斥时，让线程之间的配合更搞笑，

	减少锁区间的执行指令

什么是线程惊群？如何避免？


减少竞争线程的方法

	复制多分资源，减少争夺

	分割资源，分块读取

	锁的范围更小，局限在容器的某个节点上，而不是整个容器

	散列容器，无锁处理















