---
layout: post
status: publish
published: false
title: 读书笔记(十八) 《C++性能优化指南》三
description: "读书 书 看书 读后感"
excerpt_separator: ===
tags:
- 读书笔记
---

## 热点代码

这里作者带我们聊一聊关于代码细节的优化，虽然语句的细节优化并不能带来非常明显的提升，但是也是非常有必要的优化步骤，尤其在那些追求极致高性能或精小的组件中，代码细节的优化决定了组件与组件之间的差异。

语句细节的优化，其实质是对CPU指令的优化。语句级别的优化可以被认为是从执行指令流中移除指令的过程。

### 语句的细节优化，其实质是执行指令数量的优化，指令跳转次数的优化，向栈中保存临时寄存器次数的优化，以及内存分配次数的优化。

为什么呢？

执行指令数量减少了可以减少CPU在执行程序时的耗时我们很好理解，指令跳转则是因为指令也是被放在内存中的数据，因此它也会被高速缓存cache，长距离跳转会让高速缓存失效，静态函数调用和非成员函数调用通常都是长距离指令跳转的典型案例。

即使一个空函数，在调用时也会有性能开销，有时为了极致的优化，我们应该最大限度的减少调用函数的频率，特别是频率最高的那几个。

这是因为在函数被调用时会保存当前函数的数据，包括参数、局部变量、当前指令地址、临时寄存器和标记寄存器等，每次调用一个函数会做如下处理：

		1.当调用函数时，先保存当前函数的临时变量、参数、临时寄存器、标记寄存器。
		
		2.将这些每个要保存的数据都复制到栈中。
		
		3.当前执行的地址复制到栈中。

		4.将指令指针寄存器IP指向要执行的函数体的第一句

		5.执行函数体中的指令

		6.将函数调用结果保存到寄存器

		7.从栈中推出要返回的地址，并复制给指令寄存器IP

		8.推出栈中的临时寄存器、参数、局部变量、标记寄存器都重新还原回去

		9.继续执行剩下的指令直到遇到下一个函数。

如果遇到成员函数是虚函数的，还得先从虚表中偏移并取出函数地址再调用，这里又多了2次计算，即先取出虚表地址、再根据虚表地址偏移获得真正的函数地址、最后再才能跳转过去。如果是多重继承、或者是多重继承的继承类中的虚函数成员，则需要再加一次地址偏移计算。

inline内联是减少函数调用的最佳方式，内联函数并不像一般函数那样会保存数据并且跳转指令，因为编译器会就地展开内联函数中的指令，因此没有推栈入栈保存数据到栈和跳转指令到函数再返回的步骤，取而代之的是就地直接执行指令。

这样看来减少函数调用(或让函数内联)的同时也减少了入栈、出栈、复制数据的指令数量，也减少了指令跳转的丢失高速缓存的概率。

不必要的内存分配也是在代码细节中常犯的错误，尤其指向堆内存分配，当函数中需要某个容器或者类实例时，常会临时向堆内存申请一次以用来计算。

我们来看看以上这说的4个细节的具体例子：

``` c++

for(int i = 0 ; i<strlen(str) ; i++)
	...

//改为

for(int i = 0, n = strlen(str) ; i<n ; i++)
	...

```

#### 这里不一定有优化，因为编译器可能会识别这类循环并将实时计算移出去，不过不能保证编译器一定会这么干，所以我们最好做人为的优化，保证不重复计算。

``` c++

void function()
{
	list = new list();
	for(int i = 0 ; i<n ; i++)
	{
		list.Add(xx);
	}

	return;
}

//改为

public static list = new list(); //改为全局变量

void function()
{
	list.Clear();
	for(int i = 0 ; i<n ; i++)
	{
		list.Add(xx);
	}

	return;
}

```

#### 函数中临时的堆内存分配，改为全局的共用内存，只要分配一次，每次使用前先清理就能节省开销。

``` c++

int k = 0;
for(int i = 0 ; i<100 ; i++)
{
	int j = sin(100) + cos(50);
	k = j*i;
}

//改为

int k = 0;
int j = sin(100) + cos(5);
for(int i = 0 ; i<100 ; i++)
{
	k = j*i;
}

```

#### 移除循环中不变的计算，减少不必要的指令，可能会被编译器优化掉。

``` c++
for(int i = 0 ; i<10 ; i++)
{
	int b = Add(3,5);
	...
}

//改为

int b = 0
for(int i = 0 ; i<10 ; i++)
{
	b = 3 + 5;
	...
}

//或者将Add函数内联

inline Add(a,b)
{
	...
}

```

#### 用内联或者手动内联的方式，减少循环中的函数调用开销。

``` c++

string str = "a";

str = "<p>" + str + "</p>";

//改为

str = string.format("<p>{0}</p>",str);

```

#### 减少字符串内存分配次数，将原来要分配两次的字符串，改为只要分配1次。或者用更好的内存管理方式管理内存

``` c++

for(int i = 0 ; i<1000 ; i++)
{
	test();
}

//改为

test();

void test()
{
	for(int i = 0 ; i<1000 ;i++)
	{
		...
	}
}

```

#### 将1000次调用函数的开销改为1次。

``` c++

if(x == a)
{
	...
}
else if(xx == a)
{
	...
}
else if(xxx == a)
{
	...
}
else ...

//改为

switch(a)
{
	case x:
		break;
	case xx:
		break;
	case xxx:
		break;
}

```

#### 通常switch都会被编译器优化为索引的方式去跳转，因此用switch比if效率高的多，也不用我们自己对数据排序。

最后说下异常try catch的开销，在早期C++的try catch机制会在栈帧上包含一个异常上下文，这些上下文会随着异常抛出或者作用范围结束而销毁，增加性能开销。现在则不同了，开销没有开销，只是会在开始try时多几个指令更改中断程序的指向，退出时再改回来。如果太多try catch的调用仍然会多出很多额外的消耗。

### 小结一下，我们说语句的细节优化，实质是减少执行指令数量，减少指令跳转次数，减少函数调用，以及减少内存分配次数。我们用代码细节来解释有哪些细节是可以遵从我们的原理来优化的，这些细节的优化，在性能要求比较高的组件上会比较有用，而在比较庞大的业务逻辑面前则显得微不足道。特别是业务逻辑上，我们更多运用的是调整实现方式，或调整数据结构的方式，或调整业务逻辑策略的方式来实现业务上的优化。具体的业务逻辑优化总结以后面再专门写一篇业务逻辑优化来学习和总结下，这里举几个简单的例子，例如计算缓存机制，事件机制代替更新机制，分线程算力分摊，预加载预分配策略，摄像机内外业务逻辑裁剪策略等，涵盖内容比较多这里暂不暂开讨论。

## IO

文件IO底层机制的几种方式，磁盘运行原理

一个操作系统可以支持多种底层不同的文件系统（比如NTFS, FAT, ext3, ext4），为了给内核和用户进程提供统一的文件系统视图，Linux在用户进程和底层文件系统之间加入了一个抽象层，即虚拟文件系统(Virtual File System, VFS)，进程所有的文件操作都通过VFS，由VFS来适配各种底层不同的文件系统，完成实际的文件操作。

虚拟文件系统主要模块

1、超级块（super_block），用于保存一个文件系统的所有元数据，相当于这个文件系统的信息库，为其他的模块提供信息。因此一个超级块可代表一个文件系统。文件系统的任意元数据修改都要修改超级块。超级块对象是常驻内存并被缓存的。

2、目录项模块，管理路径的目录项。比如一个路径 /home/foo/hello.txt，那么目录项有home, foo, hello.txt。目录项的块，存储的是这个目录下的所有的文件的inode号和文件名等信息。其内部是树形结构，操作系统检索一个文件，都是从根目录开始，按层次解析路径中的所有目录，直到定位到文件。

3、inode模块，管理一个具体的文件，是文件的唯一标识，一个文件对应一个inode。通过inode可以方便的找到文件在磁盘扇区的位置。同时inode模块可链接到address_space模块，方便查找自身文件数据是否已经缓存。

4、打开文件列表模块，包含所有内核已经打开的文件。已经打开的文件对象由open系统调用在内核中创建，也叫文件句柄。打开文件列表模块中包含一个列表，每个列表表项是一个结构体struct file，结构体中的信息用来表示打开的一个文件的各种状态参数。

5、file_operations模块。这个模块中维护一个数据结构，是一系列函数指针的集合，其中包含所有可以使用的系统调用函数，例如open、read、write、mmap等。每个打开文件（打开文件列表模块的一个表项）都可以连接到file_operations模块，从而对任何已打开的文件，通过系统调用函数，实现各种操作。

6、address_space模块，它表示一个文件在页缓存中已经缓存了的物理页。它是页缓存和外部设备中文件系统的桥梁。如果将文件系统可以理解成数据源，那么address_space可以说关联了内存系统和文件系统。

读文件

1、进程调用库函数向内核发起读文件请求；

2、内核通过检查进程的文件描述符定位到虚拟文件系统的已打开文件列表表项；

3、调用该文件可用的系统调用函数read()

3、read()函数通过文件表项链接到目录项模块，根据传入的文件路径，在目录项模块中检索，找到该文件的inode；

4、在inode中，通过文件内容偏移量计算出要读取的页；

5、通过inode找到文件对应的address_space；

6、在address_space中访问该文件的页缓存树，查找对应的页缓存结点：

（1）如果页缓存命中，那么直接返回文件内容；

（2）如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页；重新进行第6步查找页缓存；

7、文件内容读取成功。



写文件

前5步和读文件一致，在address_space中查询对应页的页缓存是否存在：

6、如果页缓存命中，直接把文件内容修改更新在页缓存的页中。写文件就结束了。这时候文件修改位于页缓存，并没有写回到磁盘文件中去。

7、如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页。此时缓存页命中，进行第6步。

8、一个页缓存中的页如果被修改，那么会被标记成脏页。脏页需要写回到磁盘中的文件块。有两种方式可以把脏页写回磁盘：

（1）手动调用sync()或者fsync()系统调用把脏页写回

（2）pdflush进程会定时把脏页写回到磁盘

同时注意，脏页不能被置换出内存，如果脏页正在被写回，那么会被设置写回标记，这时候该页就被上锁，其他写请求被阻塞直到锁释放。

---

内核使用task_struct来表示单个进程的描述符，其中包含维护一个进程的所有信息。task_struct结构体中维护了一个 files的指针（和“已打开文件列表”上的表项是不同的指针）来指向结构体files_struct，files_struct中包含文件描述符表和打开的文件对象信息。

1、多个进程可以同时指向一个打开文件对象（文件列表表项）。

2、一个进程可以多次打开一个文件，生成不同的文件描述符，每个文件描述符指向不同的文件列表表项。但是由于是同一个文件，inode唯一，所以这些文件列表表项都指向同一个inode。



同步读取和异步读取

减少读取次数

预先知道文件有多大，先分配同样大小的内存，减少读取次数

写入文件，减少flash调用次数

分帧读取，增强画面体验

## 并发

由于设备资源并不总是运行，是因为某些程序并没有使用到某些资源，这使得资源的闲置造成了浪费，如果能在当某个程序在执行指令时，另一个设备在满负荷运作，这样就相当于提高了运行效率。我们希望计算机资源包括IO资源运行的饱和度能达到100%，这样我们在执行各种程序时就能让计算机满负荷奔跑，而不只是某个CPU和内存。

资源有，多个cpu，硬盘，网卡，显卡，声卡

并发的挑战是找到足够多的独立任务来充分地使用所有可用的计算机资源，让资源都能满负荷的执行，提高整体运行效率。

线程、进程在Linux中的运行机制，时间片概念

操作系统会维护一份当前正在执行的程序和系统任务的列表，并为每个程序都分配时间。

进程并发的优点是隔离了两个进程之间的关系，缺点是启动、停止和切换都比线程慢的多。

线程的开关虽然比进程消耗小，但它的消耗还是太大，线程池对优化起的作用。

线程交叉执行的可能结果

为什么线程交叉执行内存写入时，会得到不一样的结果？

线程同步的方案，互斥量、锁、

原子性，什么是原子性，为什么要用原子性。

内存对齐时与不对齐时同步问题

内存栅栏是什么？为什么要用内存栅栏？它是怎么工作的？

加入更多SIMD指令

线程数量的多少取决于什么？

线程间的合作，消息传递机制，管道和循环管道

无锁容器的原理

如何让在做互斥时，让线程之间的配合更搞笑，

	减少锁区间的执行指令

什么是线程惊群？如何避免？


减少竞争线程的方法

	复制多分资源，减少争夺

	分割资源，分块读取

	锁的范围更小，局限在容器的某个节点上，而不是整个容器

	散列容器，无锁处理




参考资料：

《从内核文件系统看文件读写过程》https://www.cnblogs.com/huxiao-tee/p/4657851.html


