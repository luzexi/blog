---
layout: post
status: publish
published: false
title: 《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(二) - 渲染管线2
description: "unity3d 高级编程 主程 shader 漫反射 镜面反射 自发光 球面反射"
excerpt_separator: ===
tags:
- 书籍著作
- Unity3D
- 前端技术
---

继上篇讲解了渲染管线的应用阶段、几何阶段和光栅化阶段，这一节我们来讲讲最后的逐片元操作阶段，以及着色器中我们常见的一些概念和原理。

###### 逐片元操作(Per-Fragment Operations)是OpenGL的说法，在DirectX称为输出合并阶段(Output-Merger)，其实只是说法不同而已包含的内容都是相同的，包括了，剪切测试(Scissor test)，多重采样的片元操作，模板测试(Stencil Test)、深度测试(Depth Test)、混合(blending)、以及最后的逻辑操作。

这几个节点都是以片元为基础的元素操作动作，它们都决定了片元的去留问题。所以逐片元操作阶段是解决片元的可见性问题的一个重要阶段，如果片元在这几个节点上任意一个节点没有通过测试，那么它就会被丢弃并且之后的测试或操作都不会被执行，如果执行全部通过就会进入帧缓存。每个节点实际测试的过程是个比较复杂的过程，而且不同的图形接口实现的细节也不一样，但我们要理解到它们的基本原理和大致的过程相对简单一些。

所有这些测试和操作其实都可以看做是以开关形式存在，因为他们的操作命令大都包含了On和Off操作指令，在OpenGL里以glEnable()和glDisable()来表示功能是否被开启或关闭。

第一个可见性测试就是剪切测试(Scissor)，它主要针对的是片元是否在窗口范围内的测试判断，如果片元不在窗口范围内则被丢弃。

这个窗口范围是一个矩形的区域，我们称它为剪切盒。实际上有很多个剪切盒存在，只是默认情况下所有渲染测试都在第一个剪切盒上完成，要访问其他剪切盒就需要几何着色器。

Unity3D的Shader并没有开放这个剪切测试的功能，因为它的实际应用实在太少，所以我们在这里也只是简单介绍一下，至少大家知道了有这么个测试存在。

第二步是多重采样的片元操作。什么是多重采样呢？

多重采样不是只有一个样本时那样计算的是在单个像素上的信息，而是分散取得多个样本，这些样本可能是附近的几个位置也可能是其他算法。因此在多重采样中，每个片元都有多种颜色，多个深度值和多组纹理坐标，而不是只有一种（具体有多少个取决于子像素的样本数目）。

如果没有开启多重采样的片元操作，多重采样在计算片元的覆盖比例时，不会考虑alpha值的影响。

一旦开启多重采样的片元操作，我们就可以用片元的alpha值来影响采样的覆盖率计算。

Unity3D的Shader也同样没有开放多重采样的片元操作功能，至少我们知道了有多重采样的存在，像素不是单单只是它本身的颜色和深度，而是由附近的像素一起决定的。

第三步模板测试(Stencil Test)，模板测试说的简单点其实就是比大小，关键就是怎么比，与谁比。

在模板测试中模板缓存是必要的内存块，因为是片元与片元之间的比较，所以开发者需要指定一个引用参考值(Reference value)，这个参考值代表了当前物体的所有片元的参考值，这个参考值与模板缓存(Stencil Buffer)中当前片元的模板值进行比较，因为模板缓存中当前片元的模板参考值可能是被别人写入过的一个值，根据比较的结果做判断是否抛弃片元，判断可以是大于、等于、小于等，一旦判断失败片元将被抛弃反之则继续向下传递，判断成功后也可以有相应对模板缓存的操作，操作可以有，替换旧的片元，增加一定的参考值，参考值置零等等。

我们来看看到底有多少种判断，和，多少种对模板缓存的操作。

		Greater	大于模板缓存时判断通过
		GEqual	大于等于模板缓存时判断通过
		Less	小于模板缓存时判断通过
		LEqual	小于等于模板缓存时判断通过
		Equal	等于模板缓存时判断通过
		NotEqual	不等于模板缓存时判断通过
		Always	总是通过
		Never	总是不通过

上述这些都是对于是否通过测试的判断种类，其实就是简单的比大小。在Unity3D的Shader中的完整的模板测试写法如下：

		Stencil {
		    Ref 2 //指定的引用参考值
		    Comp Equal //比较操作
		    ReadMask 255 //读取模板缓存时的掩码
		    WriteMask 255 //写入模板缓存是的掩码
		    Pass Keep //通过后对模板缓存的操作
		    ZFail IncrSat //如果深度测试失败时对模板缓存的操作
		}

其中 Pass 的操作种类有：

		Keep	不做任何改变，保留当前缓存中的参考值
		Zero	当前Buffer中置零
		Replace	将当前的参考值写入缓存中
		IncrSat	增加当前的参考值到缓存中，最大为255
		DecrSat	减少当前的参考值到缓存中，最小为0
		Invert	翻转当前缓存中的值
		IncrWrap	增加当前的参考值到缓存中，如果到最值255时则变为0
		DecrWrap	减少当前的参考值到缓存中，如果到最小为0时则变为255

没想到一个简简单单的比大小其实也能玩出这么多花样来吧。不止如此，除了比较和通过后的操作指令外，还有读取缓存掩码，写入缓存掩码，如深度测试失败时对模板缓存区的操作指令，这些都是为了能让模板测试变化出更多的花样来。用一幅图就能理解模板测试的美妙：

		缺图

图中三个球一起叠加在一起，却只显示了一个球的，并且在这个球上显示了三个球叠加的部分。因为其他两个球的模板测试并没有通过，但叠加部分则通过了模板测试。

###### 如果片元幸运的通过了模板测试，则会来到第四步，深度测试。有没觉得这个片元很像书本上描述精子通过重重困难终于来到了卵子的的位置，我记得在课本上总是这么介绍，刚好片元也是如此。

深度测试主要目的是将被覆盖的片元丢弃，或者说将需要覆盖的片元绘制在屏幕上，其实这两个操作是根据物体渲染队列的前后关系操作的。

深度测试工作分为两块，一块是比较即ZTest，一块是写入即ZWrite，只有比较通过的才有写入的资格。

他们是怎么比较的呢？还记得前面的模板测试么，比大小，然后写入缓存，深度测试的方法和模板测试用的方法简直就是一个妈生出的俩个孩儿
。深度测试的 ZTest 对应模板测试的 Comp，深度测试的 ZWrite 对应模板测试的 Pass，先比较缓存中的值再操作缓存，两者简直一模一样。

与模板测试不同的是深度测试用的是深度值，而不是固定某个值。什么是深度值？哪来的深度值？

还记得前面顶点着色器中介绍的，顶点在变化坐标空间后z轴被翻转成为了视口前方的轴，x、y轴则成为了视口平面上的方向轴。是的，正是因为那次坐标系的转换和后面的归一化，使得所有顶点的坐标都在一个立方体的空间内，x、y成为了屏幕相对参考坐标，而z则成为了前后关系的参考值。然后光栅化插值后z坐标也进入了片元中，最后到了深度测试时片元就可以用z值来作为深度值的判断依据了。

如果输入片元的深度值即z值可以通过制定的深度测试环节，那么它就可以替换当前深度缓存中已经有的深度值。

###### 可以更加白话一点表达深度测试，一般情况下都是用LEqual 作为深度测试判断依据，即哪个片元离摄像机越近就用那个，其他类型判断依据也可以解释的类似与摄像机距离有关。

幸运的片元冲破重重阻碍来到了第五步混合阶段。

###### 混合阶段实质上并没有丢弃任何片元，但却可以让片元消失不见。

如果一个片元通过了上面的测试，那么它就有资格与当前颜色缓冲中的内容进行混合了。最简单的混合方式就是直接覆盖已有的颜色缓冲中的值，实际上这样不算混合，只是覆盖而已，我们需要两个片元的真正混合。

那么为什么要混合？由于物体都是一个接一个的被渲染在缓冲中的，当前物体被渲染后面临着前面的物体已经被铺在缓冲中的情况，如果没有开启混合，当前的片元则会直接覆盖掉当前所在的缓冲中的片元，两个片元并没有做任何关联性的操作，如果这时开启混合则可以对这两个片元在颜色上做更多的操作，这可能是我们所期待的。

其实大多数情况混合与片元的 alpha 值有关，但不是硬性要求一定要与alpha有关，也可以只与颜色有关，只是这种类型比较多而已。

alpha 是颜色的第四个分量，OpenGL中片元的颜色都会带有 alpha 无论你是否需要它，无论是否你显性地设置了它。

但是 alpha 太抽象，我们无法从肉眼看到它，只能在脑袋中想象它。alpha 代表了片元的透明程度，我们可以用它实现各种半透明物体的模拟就像玻璃那样。

说白了，混合就是当前物体的片元与前面渲染过的物体的片元之间的颜色上的操作，那么混合有哪些操作呢？我们来看下Unity3D中的混合指令：

		Blend SrcFactor DstFactor

		Blend SrcFactor DstFactor, SrcFactorA DstFactorA

这里有两种操作方式，第一种是混合颜色包括alpha，另一种是分开混合即RGB颜色和RGB颜色混合(alpha不参与)用一种方式，alpha和alpha混合则用另一种方式。

其中 SrcFactor 这个变量会与前面已经渲染过的物体的片元的颜色相乘，DstFactor 则会与刚刚通过测试的物体片元上的颜色相乘，SrcFactorA 会与已经渲染过的物体片元上的 alpha相乘，DstFactorA 则会与刚刚通过测试的物体片元上的 alpha 相乘。

SrcFactor、DstFactor、SrcFactorA、DstFactorA 这四个变量的可以选择为：

		One	代表1，就相当于完整的一个数据
		Zero	代表0，就相当于抹去了整个数据
		SrcColor	The value of this stage is multiplied by the source color value.
		SrcAlpha	The value of this stage is multiplied by the source alpha value.
		DstColor	The value of this stage is multiplied by frame buffer source color value.
		DstAlpha	The value of this stage is multiplied by frame buffer source alpha value.
		OneMinusSrcColor	The value of this stage is multiplied by (1 - source color).
		OneMinusSrcAlpha	The value of this stage is multiplied by (1 - source alpha).
		OneMinusDstColor	The value of this stage is multiplied by (1 - destination color).
		OneMinusDstAlpha	The value of this stage is multiplied by (1 - destination alpha).




### 渲染顺序

opaque, alpha test，alpha blend

### Mipmap的原理

### Alpha Test

其过程比较简单，在片元着色器中判断该片元 Alpha 值是否小于了某个阈值，一旦判定小于某个阈值就立刻选择丢弃。这样做好处是，当某个模型需要很多顶点来描述曲折的面时我们可以用 Alpha 来代替，

### Early-Z GPU优化技术


### ShadowMap阴影是如何运作的


