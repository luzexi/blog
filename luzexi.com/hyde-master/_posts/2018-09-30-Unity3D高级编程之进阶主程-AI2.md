---
layout: post
status: publish
published: false
title: 《Unity3D高级编程之进阶主程》第八章 行为树构建AI
description: "unity3d 高级编程 主程 地图 navmesh 寻路"
excerpt_separator: ===
tags:
- 书籍著作
- Unity3D
- 前端技术
---

前面讲了用状态机来构建游戏中的怪物AI，由于它易于理解，容易被人类接受，扩展性和耦合性都很好，所以状态机的用途很广泛。但是状态机也有很大的缺点，就是不能处理和模仿太复杂的智能行为，比如模拟一个人类奔赴一场大型战役中，对战场中的各种繁多的突发事件做出符合人类模式的处理，这种方式状态机就无能为力，由于突发情况太多，组合起来的突发情况更多，做出反应的方式也变化多端，用人类思维逻辑去编写每个状态就会进入指数级的复杂度，说白了就是人类大脑无法应付这么复杂的逻辑。

行为树很好的弥补了状态机的缺点，它简化了逻辑拼凑的方式，让简单头脑的人类能更容易编写和控制机器人的智能行为。这其实也是AI架构的关键点，能够让简单头脑的人类制作复杂的人工智能的行为方式。人工智能的行为方式，都是由人类头脑指定的行为方式，是人类头脑所预期的，而非不可控的。

行为树的优势就在这里，能够通过一些简单的人类能够应付的操作，来达到人类所预期的机器人行为方式。下面我们来详细介绍行为树的组成。

行为树(Behavior Tree)具有如下的特性：

它只有4大类型的N节点：

1，Composite Node 复合节点

复合节点可详细的分为3种：

一种是Selector Node，选择节点。当执行本类型节点时，它将从头到尾迭代执行自己的子节点，如果遇到一个子节点执行后返回True则停止迭代，本Node向自己的上层的父节点也返回True，否则所有子节点都返回False，那么本Node向自己的父节点返回False。

一种是Sequence Node，顺序节点。当执行本类型Node时，它将从头到尾依次迭代执行自己的子节点，如遇到一个Child Node 子节点执行后返回False，那停止迭代，本Node向自己的Parent Node父节点也返回False；否则所有Child Node都返回True，那本Node向自己的Parent Node返回True。

还有一种是Parallel Node，并发节点，并发执行它的所有Child Node子节点。

向Parent Node父节点返回的值和Parallel Node所采取的具体策略相关：

Parallel Selector Node: 执行完所有子节点，有一个False则返回False，全True才返回True。

Parallel Sequence Node: 执行完所有子节点，有一个True则返回True，全False才返回False。

Parallel Hybird Node: 执行完所有子节点，指定数量的Child Node返回True或False后才决定结果。

并行节点提供了并发性，由于它可以在线程或协程级别提供并发操作，所以在性能上面有能够充分利用CPU提高性能。

通常情况下，Parallel Node下会并行挂多个Action子树，或者挂多个Condition Node以提供实时性。

Parallel Node增加性能和方便性的同时，也增加实现和维护复杂度。

除此以外为了进一步提高AI的复杂度和随机性，Selector 和 Sequence可以进一步提供非线性迭代的加权随机变种。比如，Weight Random Selector，每次执行不同的起点，提供了每次执行不同的First True Child Node的可能。而Weight Random Sequence则每次执行顺序不同，提供了不同的迭代顺序的方式。这在AI术语中称为partial-order，能使AI避免总出现可预期的结果，让结果更加的随机化。


2，Decorator Node 修饰节点

Decorator Node，它的功能正如它的字面意思：它将它的Child Node执行后返回的结果值做额外修饰处理后，再返回给它的Parent Node。比如反向修饰Decorator Not：将结果反置后返回上级处理，失败修饰Decorator FailUtil：将失败修改后返回上级处理，计数修饰Decorator Counter：将结果计数后返回上级处理，时间修饰Decorator Time：将时间修改后返回上级处理。也可以作为日志处理Decorator Log，动画修饰处理Decorator Animation，甚至Decorator Nothing什么都不干。

3，Condition Node 条件节点

Condition Node相对比较简单，条件满足则返回Ture，否则返回False。

4，Action Node 行动节点

Action Node，通常都是最后的叶子节点，它完成具体的一次(或一个step)的行为，视需求返回值。而当行为需要分step/Node间进行时，可引入Blackboard进行简单数据交互。

任何Node被执行后，必须向其上层的父节点报告执行结果：成功True或失败False。这简单的成功或失败汇报原则被很巧妙地用于控制整棵树的决策方向。

整棵行为树中，只有Condition Node和Action Node才能成为Leaf Node，而也

只有Leaf Node才是需要特别定制的Node；Composite Node和Decorator Node均

用于控制行为树中的决策走向。(所以有些资料中也统称Condition Node和Action

Node为Behavior Node，而Composite Node和Decorator Node为Decider Node。)

更强大的是可以加入Stimulus和Impulse，通过Precondition来判断masks开关。

通过上述的各种Nodes几乎可以实现所有的决策控制：if, while, and, or,

not, counter, time, random, weight random, util...



2，行为树AI

http://www.luzexi.com/%E6%B8%B8%E6%88%8F%E9%80%9A%E7%94%A8%E6%A8%A1%E5%9D%97/2013/01/26/%E4%BD%BF%E7%94%A8%E8%A1%8C%E4%B8%BA%E6%A0%91(Behavior-Tree)%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8FAI.html

行为树和决策树的区别

https://blog.csdn.net/ecidevilin/article/details/78061693


