---
layout: post
status: publish
published: false
title: 《Unity3D高级编程之进阶主程》第六章，网络层(六) - 网络同步方案
description: "unity3d 高级编程 主程 network tcp udp"
excerpt_separator: ===
tags:
- 书籍著作
- Unity3D
- 前端技术
---

当前网络游戏在网络同步方面有三种方式，即状态同步，预测信息同步，帧同步。三种方式并不是互相排斥的，很多时候我们在开发的时候，为了能都让游戏显得更加逼真，会让多种的同步方案一起使用。魔兽世界这种开放世界的多人在线RPG游戏，就使用了状态同步和预测信息同步两种方案，绝地求生、和平精英等战地竞技类游戏，也同时使用了状态同步与预测信息同步方案，而传奇世界、热血传奇等传奇类游戏因为不需要预测信息就只使用状态同步，王者荣耀等一批5v5地图类竞技游戏则使用了帧同步方案。

同步方案的目标是在针对多人游戏中如何用更少的信息同步量来逼真的’模拟‘其他玩家的一举一动，让我们在玩游戏的时候能知道其他人的位置、动作、以及状态。这里有个关键词’模拟‘，我们获取的信息由于网络因素的关系通常都是延后的，如何通过这些延迟的信息来模拟是关键的关键。

在同步的解决方案中不仅涉及到信息同步还涉及到同步的范围，比如魔兽世界、绝地求生、和平精英、传奇世界、热血传奇，如果这些游戏同步地图上所有玩家的信息，那么同步的数据量太大，不仅客户端承载不了渲染压力和信息通信压力，服务器也同样承受巨大的数据传输压力。所以要缩小同步数据的范围，怎么来选择这个范围呢，容我们慢慢道来。

### 状态同步

为什么要状态同步？如果每帧(每秒30帧)都同步信息，传输的信息量就太大了，而且信息到位也不及时，为了能更逼真的模拟其他玩家的行为，我们把每个人的行为动作都切分成若干个状态。比如站立状态，所有人都一样，站在某个位置不断循环播放某个动画，只要告诉玩家说我在某个位置进入了站立状态，只要状态不变，我们就知道这个玩家就是一直在原地播放站立动画。

在状态同步里，人身上每个状态就相当于一个固定的行为模式，这个固定行为模式就像个黑盒，只要给到需要的数据，就能表现出固定的行为，比如攻击，就是播放一个攻击动画，并在某个时间点判定攻击效果，比如打坐休息，就是循环播放一个动画，并每隔一个是时间段加一次血量，又比如行走，就是从某点到某点做A星的寻路操作，并边播放行走动画边跟随路线移动到各个路线节点，最终移动到目的地。

这些状态只要给予需要的固定数据就能展现出相同的画面效果。如果我们要让这些状态连贯起来拼凑成一个可操控的人，我们可以向这个人发送各种各样的指令，告诉它你应该触发这状态，应该触发那状态，指令中包含了状态需要的数据。

在状态同步中，服务器端扮演了幕后操纵布娃娃的那个人，而客户端里渲染的对象就是那个布娃娃，服务器端发出指令说ID为5的布娃娃开始攻击，客户端里那个ID为5的布娃娃就开始进入攻击状态并且播放攻击动画。

当动画播放到一半服务器端又发来指令说，被攻击的那个ID的怪兽受到500点伤害，这时客户端就会在指定的怪物头上冒出500点的伤害值并且让怪物进入受伤状态播放受伤动画。

当攻击动画播放完毕时，服务器又发来指令说继续攻击，ID为5的布娃娃就又开始了攻击状态，这次攻击到一半服务器发来指令说，这个怪物受到600点伤害并且死了，于是客户端在怪物头上冒出600点伤害的数字并且让怪物进入死亡状态播放死亡动画。布娃娃也在播放完攻击动画后，进入了空闲状态播放站立动画。

服务器扮演着发送指令操控布娃娃的角色，这个布娃娃也包括玩家自己的角色，即玩家操控着’我‘自己的在游戏中的人物，也同样需要经过服务器的同意，并发送指令给玩家进行信息同步和模拟。

有时候也未必要一定要经过服务器同意，为了让玩家能够在网络环境糟糕的时候也能够看起来比较顺畅，玩家可以随意操控自己的角色，并不受限于服务器的延迟指令，但是在稍后的服务器校验时再对玩家进行矫正，比如我们玩传奇世界是状态同步，在网络很卡时我们任然能不停的移动，但是过一段时间，服务器把正确的数据发送到客户端后，客户端进行了位置和状态的矫正。

状态同步的特点是状态是固定的，除非状态改变，否则相同的状态数据得到的是相同的状态结果。

### 预测信息同步

在一些竞技游戏中，人物的行动速度和旋转速度需要不断的变化，要实时更新这些信息，状态同步已经不能满足需求了，因为我们无法为不同的移动速度，不同的旋转速度，以及不同的加速度，不同的旋转加速度，定义很多个状态来描述。

对于状态同步来说，服务器只能告诉客户端，某个人从某个点移动到了某个点，以多少速度移动，旋转了多少角度，然后就进入了移动状态。但这个移动状态的速度和角度是不变的，而我们需要更多的变化。于是状态同步已经不能满足这种快速变化的移动和旋转的需求了。

但是状态同步还可以用于除移动和旋转意外的同步，因为除了移动和旋转，其他信息都没有这样快速、多样的变化，并且它们仍旧遵守原有的规则，完全可以继续用状态来划分，所以状态同步常常与预测信息同步同时存在。

预测信息同步方案的主要特点是，位置、旋转信息都是由客户端决定的，由客户端将自身的位置、旋转信息发给服务器端，再由服务器端分发给其他玩家，当其他玩家收到位置、旋转信息后预测其当前的位置，速度，加速度，以及旋转角度，旋转速度，旋转加速度并进行模拟和展示。

在这种竞技性比较强的游戏中，通常都需要玩家不停的改变移动速度和旋转角度来体现其控制的角色灵活性。比较常见为枪战类游戏CS，玩家不停在变化自己的移动和旋转的速度以适应战术的需要。或者跑跑卡丁车中，玩家要在高速移动下，不停的调整自己的方向和速度，让自己能够躲过众多障碍，以及在碰撞到障碍后的处理部分，同时在急弯处旋转自己的车进行漂移等。还有在类似魔兽世界这种开放世界下的RPG游戏，需要不停的改变自己的速度与旋转角度来让战斗显得更加丰富和灵活。

为了能更加逼真的同步模拟这种变化频率很高的人物移动和旋转，我们不得不让客户端来决定其位置和旋转角度。

为了能更加顺畅的模拟玩家在游戏中的移动旋转的表现，每个玩家的客户端会在1秒内发送15-30次左右自身的移动和旋转数据给服务器端。

也只有这样，才能让其他客户端不停的更新玩家的位置和旋转信息。

不过只是单纯的更新位置和旋转数据，就会导致玩家在屏幕中不停的闪跳，于是预测速度和加速度，让模拟的对象按速度和加速的形式在屏幕中运动，会让

### 帧同步



https://blog.csdn.net/qq_31967569/article/details/81660040

http://www.skywind.me/blog/archives/1343

状态同步，帧同步的详解。

https://blog.csdn.net/david_dai_1108/article/details/73437736

如何选择同步方式，是帧同步，还是状态同步。

能够忍受客户端计算，允许客户端做回撤，以及在网络卡时位移和动作任然进行，就用帧同步。否则希望安全性更高，由服务器控制的，则用状态同步。

网络流量大小，状态同步大，帧同步小。

回放文件大小，状态同步大，帧同步小。

安全性，状态同步好，帧同步弱。

服务器压力大小，状态同步大，帧同步小。

战斗校验，状态同步校验容易，帧同步校验难

网络卡顿表现，瞬移掉血，回撤。

实现，状态验证与插值预测，所有碰撞位移都要程序自己控制；还要写状态的回撤。

六．  长连接和短连接的优缺点
（https://www.zhihu.com/question/39849641/answer/83774680）
tcp:
tcp的好处就是“可靠”，会将体积大的数据包进行分片，保证不会让ip协议进行分片。
会检测数据包是否丢包，丢包重传，有序地发送数据包等等，
坏处就是数据包头比较臃肿，至少有20+的字节（不要小看这20+字节),
在丢包重传时，会阻塞后面的数据包，而且tcp需要保持连接状态才能进行通讯，
在连接数较多时，服务器光在handle这些连接状态上就要消耗不少的性能。
题主所说的“长连接”应该指的是tcp socket，tcp socket是操作系统为tcp协议的实现（说白了就是操作系统为tcp提供的api) 

http: http处于应用层，是基于tcp的实现。它继承了tcp的所有优点。
跟tcp有些不同,http不会一直的保持连接状态，
在早期的http 1.0时期，http请求在得到响应后会立即断开连接，
这样就导致了每次的http请求都必须去进行tcp握手（在数据报文很小时，握手时间甚至会超过数据传送时间），
在1.1版本后使用同一个连接进行多次的http请求，在一段时间内没有再次进行http请求时，会自动断开，
这样就减轻了服务器维护大量链接所产生的开销问题，但是http是应用层，它会产生新的数据报头，在数据包的容量上会更大。

udp: udp 是“不可靠”的：不会丢包重传，会导致ip分片从而丢包，数据包不会按序送达，
只保证到达的包数据是完整的，它的好处就是,不会产生tcp丢包时的队列阻塞，
数据报头较小，只有8个字节，是一个无连接协议。

手游用什么协议？有啥优缺点
tcp：
优点就是tcp的功能太强大了，基本上没有tcp做不了的事，而且基于tcp的第三方库也非常多而且稳定，
开发起来比较顺心。但tcp的缺点也很多，数据报头有20+字节，在一些动作类游戏中，需要非常频繁地与服务器进行交互，
而且通常一个操作指令会很小（基本上都小于20个字节 :P),这就代表一半的带宽开销被用在了数据报头上。
其次就是tcp需要保持连接状态，这个在pc上可能不是问题，在手机上问题就大了。
手机信号不稳定，ios操作系统会将后台非特殊进程挂起，导致游戏断线需要断线重连，也就是重新登陆一次，
做过网游的同学都知道，游戏登陆操作对服务器的开销往往是最大的。
再一个就是tcp丢包重传的特性引起的，每次发送数据包需要check是否包已到达，
队列后的数据包需要等待前一个数据包成功发送后才能进行发送，这样会导致严重的lag，
在手机信号不好时尤为明显。由于大量的tcp连接会带来开销，基于tcp的游戏通常在线人数会有limit,
当然，使用分布式架构或者游戏滚服会解决掉这个问题（tcp分布式架构人人都会做，做的好不好，这个得看功力）。

http：
因为http不需要持续地保持连接，是一个无状态的连接，不会产生tcp所产生的断线重连的问题，
服务器也不需要维护过多的连接。缺点就是需要经常的进行tcp握手操作（不会影响玩家体验），
而且由于http的无状态性，通常游戏数据需要实时保存，不过现在的内存数据库 nosql的兴起和计算机性能的提升，这块劣势已经不存在，
而且越来越多的游戏都采用实时数据保存，防止游戏服务器宕机数据回档的风险。
再一个就是服务器无法主动向客户端推送数据，导致在某些功能上会无法实现。
由于http的无状态性，需要做心跳处理，基于http的游戏服务器可以横向扩展（每一个游戏服务器进程就是一个单纯的逻辑计算器），
数据库架构设计的好的话，一个游戏服很容易实现1亿+的玩家同服的情况。

udp：
优点就是“快”和“小”，udp不会产生tcp的数据包队列阻塞的问题，而且报头数据量很小，
在某些对速度和网络io量有较大要求的玩法时，这2个优点显得尤为重要，而且udp是无连接的，不会产生断线问题，也可以横向扩展。
缺点就是udp的不可靠性，一些实现可靠的udp协议的第三方库很少，而且往往满足不了自己项目的需求，所以要实现可靠的udp要自己动手造一遍轮子，
需要一定的网络基础知识和敢于踩坑的精神 。

推荐方案
方案1 ：完全使用udp，几个项目下来，觉得使用udp做手游服务端真的是perfect match。
没有断线问题，流量小，响应速度快。无奈手游环境开发商们心态比较浮躁，都以稳定来追求利益最大化，市面上完全使用udp的游戏非常少。 

方案2 ：http+udp，这种相对保守一些，逻辑相关的使用http协议，保证游戏逻辑不会出通讯上的问题，推送类的使用udp，
比如聊天，世界公告等等，这些就算你的udp协议写的烂，也不会产生严重问题。
如果实时性要求非常高的战斗功能，请使用udp。

方案 3：tcp+udp，这种方式为了加强连接的可靠性，tcp断了可以用udp继续游戏，两种连接来加强连接的可靠性。在手游MMORPG类型的长连接的游戏中更为合适。




八．  网络加密与压缩
短连接可以用md5前面的所有参数作为校验依据，防止篡改。
加密方式
支持IP6以符合苹果审核，用域名
九．  优化
*短连接用www，做队列，单任务作业，合并请求和回调(每个请求有编号，对应回调)
*长连接自己写，协议可以用protobuff，缩小协议长度
*短连接用md5，token验证参数正确性
*两边加密可以把公钥写在so文件里
*长连接自己写，做队列，锁，多任务作业