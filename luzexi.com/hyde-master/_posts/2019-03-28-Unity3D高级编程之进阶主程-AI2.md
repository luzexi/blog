---
layout: post
status: publish
published: true
title: 《Unity3D高级编程之进阶主程》第八章 AI(2)-用行为树构建AI
description: "unity3d 高级编程 主程 地图 navmesh 寻路"
excerpt_separator: ===
tags:
- 书籍著作
- Unity3D
- 前端技术
---

前面讲了用状态机来构建游戏中的怪物AI，由于它易于理解，容易被人类接受，扩展性和耦合性都很好，所以状态机的用途很广泛。但是状态机也有很大的缺点，就是不能处理和模仿太复杂的智能行为，比如模拟一个人类奔赴一场大型战役中，对战场中的各种繁多的突发事件做出符合人类模式的处理，这种方式状态机就无能为力，由于突发情况太多，组合起来的突发情况更多，做出反应的方式也变化多端，用人类思维逻辑去编写每个状态，状态的数量就会如指数级攀升无法应付，不止人类大脑无法应付这么复杂的逻辑编写，这样复杂的逻辑也很难有效维护。

===

行为树很好的弥补了状态机的缺点，它简化了逻辑拼凑的方式，让脑容量有限的人类能更容易编写和控制机器人的智能行为。这也是AI架构的关键点，能够让人更加简单容易的制作复杂的人工智能的行为，可以说是‘化繁为简’。

‘化繁为简’是我们的大部分编程时的重点，尤其在AI设计上，人工智能的行为方式大都是由人类头脑指定的行为方式，是人类头脑所预期的行为。制作出人类所预期的AI行为逻辑，并且制作的方式和过程又在人类大脑的承受范围内的是我们所预期的。状态机的方式制作AI理论上可以实现任何AI，但复杂到一定程度人脑无法承受，其实就是低效的或者说低阶的AI。行为树的优势就在这里，能够通过一些简单的操作制作出达到人类所预期的足够复杂的机器人行为方式。

行为树的本质是树状节点，每个节点可以选择某种类型的功能节点，也可以选择某个叶子节点即没有子节点功能，功能节点以各种逻辑顺序来选择继续访问下面的子节点或者直接停止并返回结果给父节点，子节点的结果将给父节点作为参考以便继续运行相关逻辑，因此行为树本身就是一种树形的父子节点之间的逻辑结构，我们可以理解为节点逻辑，通过扩展节点的功能来实现复杂的行为逻辑。

下面我们来详细介绍行为树的组成。

行为树(Behavior Tree)具有如下的特性，它有4大类型的节点：

###### 1，Composite Node 复合节点

复合节点可详细的分为3种：

一种是Selector Node，即选择节点，它的节点规则是当执行本类型节点时，它将从头到尾迭代执行自己的子节点，如果遇到一个子节点执行后返回True则停止迭代，本节点向自己的上层父节点也返回True，否则所有子节点都返回False，那么本节点才向自己的父节点返回False。

另一种是Sequence Node，即顺序节点，它的节点规则是当执行本类型节点时，它将从头到尾依次迭代执行自己的子节点，如果其中一个子节点执行后返回False那么就立即停止迭代，同时本节点向自己的父节点也返回False，相反如果所有子节点都返回True，则本节点就向自己的父节点返回True。

还有一种是Parallel Node，即并发节点，它的节点规则是并发执行它的所有子节点。并发节点又分为三种策略，这与它们向父节点返回的值和并行节点所采取的具体策略有关即如下：

Parallel Selector Node，即并行选择节点，它的节点规则为执行完所有子节点，如果有一个子节点返回False则自己向父节点返回False，只有当所有子节点全返回True时自己才向父节点返回True。

Parallel Sequence Node，即并行顺序节点，它的节点规则为执行完所有子节点，如果有一个子节点返回True则自己向父节点返回True，否则只有当全部子节点返回False时自己才向父节点返回False。

Parallel Hybird Node，即并行混合节点，它的节点规则为执行完所有子节点，按指定数量的节点返回True或False后才决定返回结果。

并行节点提供了并发性，由于它可以在线程或协程级别提供并发操作，所以在性能上面有能够充分利用CPU提高性能。通常情况下，Parallel Node下会并行挂多个Action子树，或者挂多个条件节点以提供实时性。并行节点增加性能和方便性的同时，也增加了维护的复杂度。

除此以外为了进一步提高AI的复杂度和随机性，Selector 和 Sequence可以进一步提供非线性迭代的加权随机变种。比如，Weight Random Selector 即随机权重选择节点，每次执行不同的起点，提供了每次执行不同的First True Child Node的可能。而Weight Random Sequence 即随机权重顺序节点，则每次执行顺序不同，以提供了不同的随机迭代顺序，能使AI避免总出现可预期的结果让结果更加的随机化。

###### 2，Decorator Node 修饰节点

Decorator Node，即修饰节点，修饰节点的功能为将它的子节点执行后返回的结果值做额外修饰处理后再返回给它的父节点。

这里举几个修饰节点的例子便于读书者们理解，下面这些修饰节点都可以自定义创造出来，节点功能可以为五花八门，它们共同点为修饰子节点的结果，或者通过子节点的结果来运行逻辑。

		反向修饰 Decorator Not，它的节点功能为将结果反置后返回上级处理，即当子节点为True时返回给自己父节点的则为False，反之子节点返回False时自己返回给父节点为True。

		直到失败修饰 Decorator FailureUntil，它的节点功能为子节点运行在指定的次数到达前一直向上级返回失败，指定次数后一直向上级返回成功。

		总是失败修饰 Decorator Fail，它的节点功能为无论子节点返回的结果是否为True都向上级返回False。

		计数修饰 Decorator Counter，它的节点功能为只运行子节点n次，运行计数超过n次后不再运行。

		时间修饰 Decorator Time，它的节点功能为在指定时间内运行子节点后都返回True，超出这个时间范围无论子节点返回什么结果都向上级返回False。		

		甚至Decorator Nothing 它的功能就是什么都不干，用来提前占个位置为后面的功能预留。

除了以上这些我们还可以创造出来更多种类型的节点，例如用来调试的日志(log)节点，告知开发者当前节点的位置及相关信息，或者循环修饰节点，循环执行子节点n次等等，我们可以根据项目的需求来增加必要的修饰节点逻辑。

888

###### 3，Condition Node 条件节点

Condition Node相对比较简单，条件满足则返回Ture，否则返回False。

各式各样的条件节点，都继承基础条件节点并且返回Ture或False。

比较常用的条件节点例如，血量判断条件，距离判断条件，状态判断条件，时间间隔判断条件等。

###### 4，Action Node 行动节点

Action Node，通常都是最后的叶子节点，它完成具体的一次(或一个step)的行为，视需求返回值。

Action Node可以是执行一次的，也可以视为分步执行很多次的行为。例如，向前进这个行为，可以一直被执行，直到条件不满足。

也就是说，通过扩展Action Node完全可以不需要借助外在程序或接口，自主定义角色行为。

常用的Action Node节点的例如，行走到目标地点Action，跟踪目标Action，转换角色方向Action，撤退Action，攻击Action，防御Action，释放技能Action等等。

###### 在行为树中任何Node被执行后，必须向其上层的父节点报告执行结果：成功True或失败False。这简单的成功或失败汇报原则被很巧妙地用于控制整棵树的决策方向。

行为树能够支撑起对复杂逻辑的AI的原因就是由于使用了这些简单的节点去搭建整个AI模型。由于人脑可以很容易的写出这些简单的单个节点的逻辑，使得节点的功能性扩展变得非常容易，而拼装这些节点，就像是一个搭积木的过程，人脑能搭建多复杂的积木，就能搭建起多复杂的AI。

整棵行为树中，只有Condition Node和Action Node才能成为Leaf Node叶子节点，而也只有Leaf Node才是需要特别定制的Node。而Composite Node和Decorator Node均用于控制行为树中的决策走向。所以有些资料中也统称Condition Node和Action Node为Behavior Node行为节点，而Composite Node和Decorator Node为Decider Node决策节点。

在行为树之前，还有决策树这个被遗忘了的AI解决方案。决策树和行为树一样都是树形结构，都是由节点构成。决策的构成是由树形结构的头部开始，从上往下一路判断该往哪走，最后一定会执行到叶子节点，在决策树中只有叶子节点才决定了如何行动，而且在决定后的行动中，无法中途退出，要等到档次行为执行完毕或者被打断后才能开始下一次决策。

从理念上讲，决策树就是为了制定决策，而行为树是为了控制行为，是两个不同的理念，行为树更加注重变化，而决策树则注重选择。因此行为树可以定制比决策树更加复杂的AI逻辑，而实现的难易程度行为树并没有增加多少，所以决策树被冷落也是情理之中。

###### 行为树比状态机更容易编写复杂的AI逻辑就是由于单一节点的易扩展性，以及整个AI树的可搭建能力都是在人脑的可及范围内。但是，再厉害的人脑也有搭建复杂度的极限，无论你对搭建行为树这项技能有多么精通，都有到一个极限的状态，也就是搭建的复杂度超出人类大脑的时候，人类就完全无法继续搭建了，或者说无法完成。例如，如果想完全模拟人类的思维判断逻辑，对不同的人，对不同的事，对不同的景色，对不同的物体，不同的路面，以及以上混合组合的不同组合，就完全超出了人类大脑搭建的极限。像这种特别复杂，完全不能由人类大脑自主搭建的方式形成的AI，就需要引入‘机器学习’这个概念了。由于情况太多，太复杂，唯有‘机器自主学习’才能适应这些复杂的情况时，‘Machine learning机器学习’，‘Deep learning深度学习’，‘Artificial Neural Network神经网络’，就成了解决这些问题的方案。


参考:

《使用行为树(Behavior Tree)实现游戏AI》by AKara 2010


