---
layout: post
status: publish
published: false
title: 读书笔记(十六) 《C++性能优化》
description: "读书 书 看书 读后感"
excerpt_separator: ===
tags:
- 读书笔记
---

这本书给我的感受是，有技巧有细节也有许多不足，作者介绍了大部分程序上性能优化的方案和思路，也从原理上讲了性能问题的根本原理，但没能做得通俗易懂、深入浅出，书本有几处地方在故弄玄虚以及凑字数，也许是我的功力不足没能理解，这部分无法理解的杂乱无章的内容，可以留到以后再慢慢回顾。

我写下的都是我的理解，以及我从书中学到的知识，或许过几年回头看会是另一番情景，但现在我需要把它们拎出来总结一下。

作者是一个有30多年编程经历的人，对编程依然保持的狂热兴趣，注意，他从未去过微软、谷歌等知名公司，这本书就是在这样的一个前提下写下的。

作者认为我们在优化程序的时候，很多时候都是靠‘猜测’而不是实际的去测试，这是一个比较大的问题。实际上我们并不知道某段程序是否有性能问题，因为有可能编译器已经将它优化了，或者某段程序在我们优化后是否真的有性能提升，因为很多时候我们只是肉眼去代码或是用脑袋去猜，不知道性能问题出在哪里就花费很多时间去优化这是不行的。而且我们也不能因为优化程序性能而破坏了程序的稳定性，如果从中制造出Bug导致产品崩溃那是非常得不偿失的。

另外也提出了一个比较重要的理念，即大部分性能问题的分布都是‘90/10规则’，也就是说，90%的性能问题出在10%的代码上。因此我们在做性能优化时，应该提高效率，即找出这影响90%性能问题的那10%的代码，并且优化它，它们就时性能热点。当然这10%的代码并不是集中在某处，而是分散在各个模块中，需要我们去找出来。

原书内容比较繁杂，我把它归类为，计算机执行原理、性能测试、字符串问题、算法、内存分配、热点代码、IO、并发，这八个方面。下面就让我们来讲讲我从书本中学到的对性能优化的理解。

### 计算机执行原理

这里需要点汇编的知识点，想要详细了解的同学可以看《汇编语言》，以及我对它的总结。

代码从被编译到成为可执行文件也就是机器码，这个过程就是一个从本文字符串翻译成机器码的过程，当我们执行它们的时候，它可机器码被放入了内存，内存中也有分块，包括数据段、栈段、指令段。

CPU在执行指令时是从内存中将指令送入CPU的，而执行指令的速度通常比读取内存的快很多，因此读取指令也成为了瓶颈的一种。CPU在读取指令时也并不会一行一行的读取，因为这样效率太差，取而代之的是它会把一大块内容读取到高速缓存从而加快执行速度，指令会顺序执行直到结束或有跳转。

而内存芯片也有自己的工作原理，相当于另一个CPU，它只有在顺序访问时才能在一个周期内完成，而访问一个非连续的位置则会花费6到10个周期。

这里就涉及到了内存在访问时的形式，每次访问内存都是以某个大小为单位，例如x86机器，每次访问内存时都是以4个字节为单位访问，一个int整数位4个字节需要一次访问，但如果这个int整数内存没有对齐，那么可能就需要访问两次才能获得这个值，因为构成这个内存的物理结构可能是垮了两个物理内存字。

作者没有细说，但我们来举个例子：

``` c
[-][-][x][x][x][x][-][-]
```

例如上面这个非对齐的内存空间，‘x’表示某个int变量占用的4个字节，‘-’表示其他，当CPU读取这个int整数时，其实是先读取

``` c
[-][-][x][x]
```

再读取

```
[x][x][-][-]
```

拼接完成后

```
[x][x][x][x]
```

最后交给寄存器


通常我们一个操作系统中有多个程序需要同时内存访问，而内存总线就只有一个，内存芯片必须一个个去完成CPU分配给它的任务，有时甚至是经常不连续的内存访问，由此看来，内存的读写负担是相当重的。如果未来有更多的处理器内存增加，而内存接口和读取速度没有增加的话，那么其实这些内核对性能的改善效果也是趋于递减的。

那么怎么加快内存访问和指令执行效率呢





