---
layout: post
status: publish
published: false
title: 《Unity3D高级编程之进阶主程》第十章，地图与寻路(一) A星算法
description: "unity3d 高级编程 主程 地图 navmesh 寻路"
excerpt_separator: ===
tags:
- 书籍著作
- Unity3D
- 前端技术
---

寻路一直是游戏项目中的热门功能，寻路算法用的最多的就是A星算法，其他也有，比如 Dijkstra算法 与 Floyd 算法，但是他们的在时间和空间上的复杂度都太高，Dijkstra算法时间复杂度为O(N^2)，空间复杂度也是O(N^2)，Floyd的时间复杂度更高有O(N^3)，空间复杂度也在O(N^2)，这种复杂度的算法寻路算法如果应用在游戏中稍微大一点的范围、大面积、稍微高一点的频率的寻路需求是CPU是无法承受的。

A星算法其实并不是最短路径算法，它找到的路径并不是最短的，它的目标首先是能以最快的速度找到通往目的地的路，它的时间复杂度为O(NLogN)，最差的情况是从起点出发把所有的格子都走了一遍，最后才找到目的地。

用一句话概括A星：用最贪婪的方法寻找目的地。

怎么个贪婪法呢，我们要拿方格来描述A星算法，因为用方格描述A星寻路的方式很容易理解。

```
		[][][][][]
		[][][][][]
		[][s][][][]
		[][][][][]
		[][][][][e]
```

上图中s为start起点(3,2)，e为end终点(5,5)。

用最贪婪的方法去找目的地：在所有得到的点中，找到与目的地e距离最短的那个，就是离目的地e最接近的，继续用这个点向前探索，直到找到目的地。

简单来说从s点开始取出它周围的4个点，上，下，左，右，计算下它们与终点e的距离，哪个离e的距离最短，就取那个点的周围4个元素继续进行同样的操作，直到找到目的地e。

```
		[-][-][-][-][-]
		[-][1][2][3][-]
		[1][s][1][2][3]
		[-][1][2][3][4]
		[-][-][-][4][e]
```

如上图中，s开始取到周围的4个点标记为1，计算距离，并推入到一个队列，把这个队列按到e点距离值从小到大排序一下，取出离e点距离最短的点，再从该元素周围取出4个元素标记为2，推入到队列，并对它们计算与e的最短距离，再排序一下，取出离e点距离最近的那个标记为3，依次重复这种操作，直到找到e目的地。所有被标记过的都不能再被重复标记。

我们来看看复杂点的A星寻路例子：

```
		[-][-][-][-][-]
		[s][+][+][-][-]
		[-][+][e][-][-]
		[-][+][-][-][-]
		[-][-][-][-][-]
```

从s出发到e，图中‘+’为障碍物，用贪婪的A星寻路会怎么找到e呢，如下图：

```
		[1][-][-][-][-]
		[s][+][+][-][10]
		[1][+][e][10][9]
		[2][+][+][+][8]
		[3][4][5][6][7]
```

1.先取s周围的点标记1

2.取标记里最近的且没被取过的点，即下面这个1点，取它周围点标记为2

3.取标记里最近的且没被取过的点，即点3也可以是上面的1，但我们定个规则一样的距离以下面为标准，取它周围的点标记为点4

4.离e点最近的还是4，继续取它周围的标记为5

5.离e点最近的还是5，继续取周围点标记为6

6.离e点最近的还是6，取它周围的点标记为7

7.离e点最近的还是7，取它最近的点标记为8

8.离e点最近的是8，取它周围的点标记为9

9.离e点最近的是9，取它周围的点标记为10

10.离e点最近的为左边的10，取它周围的点时发现到达目的地e，结束。

上述过程明晰的阐述了A星算法贪婪的全过程，即只选择当前的最优选择，因为只关注当前的最优解，就忽视了对全局的最优解，走‘弯路’是常有的事。

体现在代码上为如下伪代码：

```
		function find_path(s,e)
		{
			open = new list(); //没有被取到过的点
			close = new list(); //已经被取过的点

			open.add(s); //从s点开始

			for(!open.IsEmpty()) //重复遍历直到没有点可以取
			{
				open.sort(); //排序一下

				p = open.pop(); //把最近的点推出来

				if(p == e)
				{
					//找到终点
					break;
				}

				p1 = p.left(); //取左边的点
				p2 = p.right(); //取右边的点
				p3 = p.top(); //取上边的点
				p4 = p.down(); //取下边的点

				//是否已经被取过
				if(p1 != null && p1.IsNotInClose())
				{
					//加入到没被取过的列表里
					open.add(p1);
				}

				//是否已经被取过
				if(p2 != null && p2.IsNotInClose())
				{
					//加入到没被取过的列表里
					open.add(p2);
				}

				//是否已经被取过
				if(p3 != null && p3.IsNotInClose())
				{
					//加入到没被取过的列表里
					open.add(p3);
				}

				//是否已经被取过
				if(p4 != null && p4.IsNotInClose())
				{
					//加入到没被取过的列表里
					open.add(p4);
				}

				//p点已经被取过了
				close.add(p);
			}
		}
```

上述伪代码完整的诠释了A星寻路的全过程。

当地图很大的时候，或者使用A星算法的寻路频率很高的时候，普通的A星算法也会消耗大量的CPU，导致性能下降。接下来我们讲讲A星寻路在遇到性能瓶颈时的优化方案。

一、长距离导航

当距离很大，中间有很多障碍物时，A星的算法就会遇到瓶颈，不断加入的可行走点使得排序速度越来越慢，最后可能造成CPU阻塞无法动弹。

当寻路距离太大时怎么办？

其实路径不是非得实时计算出来才好，我们可以把一些常用的路径，在离线下算好放在数据文件中，游戏开启时放在内存里，当需要寻路到那个节点或者那个节点附近时，就可以取出来直接使用，而不再需要计算。

比如 A到B 我们已经算法路径并存放在了内存里，当我们在A附近，要寻路到B附近时，就可以先寻路到A，再调出A到B的路径，再计算B到目的的路径。

以这种方式来规避一些计算量特别大，或者计算频率特别高的寻路算法调用，在大型世界的RPG游戏里特别常用。

二、A星的排序算法优化

每次插入open列表的点后，open就不再是有序的队列了，所以每次开始拿去最小值时都需要重新排序。

那么是不是可以不排序，其实可以不排序，而使用插入的方法，让队列永远保持有序状态。

因为open队列在插入前是有序的，所以我们可以选用二分查找算法来找到插入的位置。

每次插入时都使用二分查找算法查找插入点，那么每次的插入复杂度为O(logN)，比快排一次的O(NlogN)要快很多。

三、优化排序判断依据的预测值计算方法

前面用图所举的例子中，都是以当前点p与终点e之间的距离来作为预测值的，这种方法简单但也不科学，导致A星寻找更好的点位时总是要绕很大的弯路。

我们可以改变一下这个策略，选用一个更科学的方法，比如 F = G + H 的方法。

F 为预测值，G为起点s到当前点p的距离，H为当前点p到终点e的距离，它们相加为F值。

这个方法相当于，原来只关注当前点到终点的距离，变为关注起点s经过当前点p路径到终点e的距离，虽然还是贪婪的简单预测算法，但比起原来只关注当前点p与终点e的距离，更加科学化，能更快的找到更好更近的点位。




1，Navmesh算法。

2，生成Navmesh网格，多层网格数据输出。

http://blianchen.blog.163.com/blog/static/13105629920103211052958/
http://blianchen.blog.163.com/blog/static/13105629920103614613291/
http://blianchen.blog.163.com/blog/static/131056299201037102315211/
http://blianchen.blog.163.com/blog/static/13105629920103811451196/
http://blianchen.blog.163.com/blog/static/13105629920103911258517/
http://blianchen.blog.163.com/blog/static/131056299201031293039882/

3，导入导出，自动生成Navmesh网格，再手工调节。

RecastNavigation-NavMesh生成原理
https://blog.csdn.net/you_lan_hai/article/details/77428858

navmesh高度结构
http://critterai.org/projects/cainav/doc/html/6fb3041b-e9be-4f03-868b-dcac944df19b.htm

关于 Unity NavMesh 数据的导出和使用
http://www.cnblogs.com/yaukey/p/3585226.html

可以用路点+navmesh的形式做图。因为路点消耗少，在城市道路上，在没有怪物的情况下可以做到很少的消耗。而在战斗中则需要整个地面有寻路路线，就需要navmesh的作用。

4，地图编辑器。

5，A星寻路算法。

四叉树找人。

6，寻路算法优化

		长路径使用导航点（导航点的路径绘制可以用编辑器配置，并导出路点数据），

		插入成为有序序列，

		2分查找或二叉堆，

		预处理F价值，

		open和close不重置而用markindex代替，

		运算符简化 *2变<<1，/2变>>1

https://blog.csdn.net/ymiku/article/details/45957107 有序优化与二叉堆优化

https://blog.csdn.net/hrn1216/article/details/51465270 最小堆 图解

https://www.cnblogs.com/pelephone/archive/2012/09/27/astar-fastest.html 其他优化

优化大多是用空间换时间，把过程的计算量放到初始存入内存。下面直接进入正题吧。

一、障碍邻点的预计算。

判断周围格子是否有障碍还有计算格子的cost价值，如果在每次寻路的时候才去算就太浪费了，因为每次寻路的时候每个格子相邻的障碍是不会变的，价值cost也不变，我们大可以把这块计算抽出放到初始地图的时候计算。步骤如下:

1.给节点添加邻节点数组nodeLinks，和邻节点价值组costLinks。(也可建一个linkNode对象，对象里面有节点和价值两属性，反正两数组是个映对关系),保证nodeLinks[i]的价值是costLinks[i]

2.地图初始好的时候遍历每个格子，计算出其周围的所有非障碍的格子，并加入节点邻数组中存起。计算每个邻节点的价值，映对存入节点价值组。

3.寻路的时候判断节点四周有哪些格子直接从当前计算的节点的nodeLinks属性取即可，不需要再计算。

预计算可节省很多性能，不过缺点是初始的时候很慢。 

 

二、Array数组优化

Array的indexOf和shift方法是很吃性能的，很多人的A星在while里面有这两个东西，这是那几百毫秒慢下的原因。怀疑的同学可以自己写个1万次的大循环调用这两个方法看看。要判断节点是否在开户组里面，普通人的做法是用indexOf，其实这个方式可以换成以下处理

1.给节点添加isOpen:Boolean属性

2.每次push节点到打开数组的里面设节点的isOpen为true

3.节点移出打开列表时，将节点的isOpen属性设为false

4.判断节点是否在开启列表时只需要判断isOpen即可

判断关闭同理，另外还有会用上indexOf的地方是二叉堆里面，干掉方式略。

将关闭组添加到通过父节点添加到返回路径时，很多人会用shift，把节点一个个添到path数组里面，这也是个慢的因素。可以换成push方式，push不会改变索引，所以效率很高。将关闭节点组数据通过push加入路径后，再调用reverse把数组倒置，结果跟用shift一样，不过用时可大不一样。

 

三、打开关闭标记，换掉不用重置

用isOpen来替代indexOf大大提升了一步性能，可是每次寻路完之后会有个问题，那就是要把节点重置，就是把所有打开和关闭列表里面的节点的isOpen,isClose设false。呵呵，虽然这个重置吃的性能相当小，不过本着追求精神，我又找出了更变态的方式。步骤如下

1.每次A星计算设一唯一自增标记markIndex,每计算一次寻路，这个整型属性+1

2.把节点里面的isOpen和isClose布尔属性改成openMark,closeMark整型属性。

3.加入列表时把openmark设为本次计算的自动标记markIndex，移出列表设为-1（或随便一个不等于markIndex的数)

4.判断是否在打开列表中只需判断if(openMark==markIndex)即可

5.某次寻路计算完之后markIndex+1

因为自增标记每次计算都不一样，所以节点的openMark不需要重置，下次也能继续用。这个方式带来的性能提升很微小不多，不追求那几十毫秒的大可无视。

 

四、减少while里面get/set/function

get/set的性能其实很高，不过在项目中，大量的格子一经过while方法就是数万次的运算，虽然每次性能相差很少，但量一大起来效率就明显了。不信的人可以写个大循环在里面用getter和public属性的方式对比一下，性能相差三四倍。如果节点的f,g,h,x,y这些属性用了接口get/set，那个运算毫秒相差就很明显了。function 是代码设计不可省的东西，这一步优化只适合在A星的while中用，正常项目中可省不得。

 

五、位运算，再提一提微小的性能

在二叉堆中的除以2，num/2==num*0.5==num >> 1，这三个种计算方式最快的明显是第三种，虽然可读性差些，不过效率还是有点提升滴。另外num*2 == num<<1;也可提升些性能

7，地形实时变更
8，地形场景的制作与优化。
9，地形地图烘培

10，场景优化技巧
	2.	LOD优化方案。
	3.	合并贴图，合并材质球。
	4.	阴影与优化。 -- 假阴影面片，阴影绘制区域管理
	5.  用Shader顶点变更来替换固定动画，把动画由CPU转移到GPU。



### 8.人物技能编辑器

人物位移，

特效释放

时间轴

事件机制


9.	人物动作与技能编辑器

