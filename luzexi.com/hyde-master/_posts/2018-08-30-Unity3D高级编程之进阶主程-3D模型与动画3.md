---
layout: post
status: publish
published: false
title: 《Unity3D高级编程之进阶主程》第五章，3D模型与动画(三) - 
description: "unity3d 高级编程 主程 ui ugui 原理 使用详解"
excerpt_separator: ===
tags:
- 书籍著作
- Unity3D
- 前端技术
---

###	如何对3D模型表面进行实时变更。(https://zhuanlan.zhihu.com/p/28471808 捏脸，骨骼点移动，旋转，缩放，Mesh大小差值实时生成)
对3D模型Mesh实时改变在很多场景中也是很有用的。比如Mesh地形挖坑，捏脸，物体切割，还有像《白猫计划》中的泡泡摇杆等。

6.	如何用状态机模拟人物行为动作。

什么是状态机？

状态机有两种，一种是有限状态机，一种是无限状态机。有限状态机运用的地方比较多，而无限状态机我还没看见过有在游戏项目中运用的。所以我们这里讲的状态机都是有限状态机。
状态机，简单描述下，实例本身有很多种状态，实例从一种状态切换到另一种状态的动作就是状态机转换，而转换是有条件的，这个条件就是状态机之间的连线。

打个比方，人有三个状态健康，感冒，康复中。触发的条件有淋雨（t1），吃药（t2），打针（t3），休息（t4）。所以状态机就是健康-（t4休息）->健康；健康-（t1淋雨）->感冒；感冒-（t3打针）->健康；感冒-（t2吃药）->康复中；康复中-（t4休息）->健康，等等。就是这样状态在不同的条件下跳转到自己或不同状态的图。

状态机可归纳为4个要素，即现态、条件、动作、次态。这样的归纳，主要是出于对状态机的内在因果关系的考虑。“现态”和“条件”是因，“动作”和“次态”是果。详解如下：
①现态：是指当前所处的状态。
②条件：又称为“事件”，当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移。
③动作：条件满足后执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接迁移到新状态。
④次态：条件满足后要迁往的新状态。“次态”是相对于“现态”而言的，“次态”一旦被激活，就转变成新的“现态”了。

注意，在进入状态和退出状态时，会发生进入事件和退出事件，这个是状态启动运作和停止运作的关键点。在满足转换条件后，先退出状态，向当前状态发起退出事件，告诉当前状态机，你将停止运行，停止运行前状态需要做什么赶快做吧，然后再向新状态发起进入事件，告诉新状态，你将要开始运作了，运作前的准备工作可以做起来了。这样每次状态的切换都能合理的告诉每个状态需要的信息和准备工作。

状态机在游戏中哪些地方会使用到？

所有能够构成独立状态的系统或者功能都能使用状态机来表现：
1.	场景切换。场景是独立的，只能有一个场景展示在游戏中，所以场景的切换可以用状态机来表示。比如当前是登录场景，点击登录后切换到游戏场景，这时需要把登录场景的UI销毁，这是登录场景状态退出时做的事，然后进入到游戏场景，要先把游戏场景的UI创建出来，这是游戏场景状态在启动时要做的事。
2.	人物行为状态切换。人物只能在当前做一个行为构成独立状态，比如人物跑步行为是一个状态，但人物边跑步边吃东西也会有，所以把人物跑步且吃东西另外创建一个状态来运行。
3.	宝箱，机关等具有多动画的元素都可以构成独立的状态。每个动画的播放都可以成为一个状态。
4.	AI。用状态机来封装AI是最常用的，每个AI状态都是独立运行的。比如激怒状态，此状态中会不断向周围的敌人发起攻击，如果20秒后恢复到平静状态不再攻击，又比如巡逻状态，在某个点周围或者按一定路线进行走动，如果5米内发现敌人，就进去激怒状态等等。

如何在人物行为动作中使用状态机？

先按常见的需求把人物行为动作划分一下：
1.	休息状态。原地不动，并且重复做一个休息的动画。
2.	攻击状态。播放攻击动画，并且对目标或前方进行攻击。
3.	技能状态。技能稍微复杂点，因为每个技能都不一样，所以技能状态里面的逻辑可以由不同的技能类来实现。比如建个技能基类class SkillBase，里面有几个统一的接口，然后子类对基类进行继承后，细化技能的细节。
4.	防御状态。播放防御动画，当受到攻击时，不切换受伤状态。
5.	受伤状态。播放受伤动画，完毕后自动进入休息状态。
6.	行走与跑步状态。播放行走或跑步动画，并根据操作输入移动方向。
7.	跳跃状态。播放跳跃动画，并上下移动人物进行跳跃，下落时底部受到碰撞就进入休息状态。
8.	死亡状态。播放死亡动画，并且不再受到任何指令而转入任何状态。

然后我们可以对每个具体的状态进行编写了，例如：
Class BaseState{
	Public virtual void OnEnter(){}
	Public virtual void OnExit(){}
	Public virtual void Update(){}
}
Class IdleState{
	Public override void OnEnter(){
		role.playAnimation(“idle”,loop);
}
}
Class HurtState{
	Public override void OnEnter(){
		role.playAnimation(“hurt”,Once);
}
Public override void Update(){
	If(!Role.IsPlayingAnimation(“hurt”)){
		HurtFinish();
}
}
Public override void OnExit(){
	GotoIdleState();
}

}

Class AttackState{
	Public override void OnEnter(){
		Role.playAnimation(“attack”,once);
}
Public override void Update(){
	If(!Role.IsPlayingAnimation(“attack”)){
		AttackStateFinish();
}
}
Public override void OnExit(){
	GotoIdleState();
}
}
Class MoveState{
	Public override void OnEnter(){
		Role.playAnimation(“walk”,loop);
}
Public override void Update(){
	Move();
}
Public override void OnExit(){
	GotoIdleState();
}
}
上述代码表达了对状态的描述，比如空闲状态，在没有收到任何指令时只循环播放Idle动画其他什么都不干；攻击状态，进入时播放攻击动画，并在动画结束后返回Idle状态并等待指令；移动状态在进入时播放walk动画并移动，在退出时进入Idle状态。
嗯，有了状态，就需要有个管理状态的类。
以下是伪代码：
Class RoleStateController{
	Private IdleState idleState;
	Private MoveState moveState;
	Private AttackState attackState;
Private HurtState hurtState;

	Private BaseState currentState;
	
	Public void OnHurt(){
		ReduceHP();
		If(currentState != hurtState){
			ChangeToHurtState();
}
}
	Public void InputAttack(){
		If(currentState  == hurtState) return;	//受伤状态下不可攻击
		If(currentState == attackState) return;	//攻击状态还没结束时不可重新开始攻击
		ChangeToAttackState();
}
	Public void InputMove(){}
}
这样就完美了，有了状态机的管理，就可以对各种逻辑的控制，比如硬值，受伤中不可行走和攻击，攻击中不可移动等。