
---
layout: post
status: publish
published: false
title: 《Unity3D高级编程之进阶主程》第十章，地图与寻路(四) 地图的制作与优化
description: "unity3d 高级编程 主程 地图 navmesh 寻路"
excerpt_separator: ===
tags:
- 书籍著作
- Unity3D
- 前端技术
---

### 地图的制作与优化

这里就不说场景制作在美术层面上的技巧了，我们来说说技术层面的。上节把地图编辑器说了一遍，这节就是地图编辑器之上说说，地图的制作与优化。

地图离不开地形，地形其实是地图的关键，地形的制作分为几种：

### 一种是手动拼接的地形。

手动拼接的地形比较常见，由3D人员制作出来的3D模型作为地面的地形放置在场景中，相当于是一个模型落在场景上一样，只是这个3D模型很可能是有碰撞体的，碰撞体Mesh Collider 可以根据项目的需要进行测试碰撞。也有可能会使用Unity3D内置的地形，也一样相当于一个3D模型放置在场景中，只是我们并不建议使用Unity3D内置的地形罢了。其他3D物体也是用同种方式来放置到场景中，只是放置的手法可能不同，有的可能通过嵌入到prefab的方式，而有的可能通过地图编辑器加入到地图数据文件中，再从加载的地图文件数据的过程中实例化出来。

手动拼接的好处在于地形和地图是可以完全表达美术风格的，地形设计师和场景制作人员能根据自己的喜好和想象中的画面来自由得定制场景，他们可以任意的移动、旋转、缩放，甚至更换、修整、完善等，这能让他们对场景画面的把控有很大的自由度。

能自由发挥当然是好事，但也带来了诸多不可控性，由于场景内物件没有统一的标准，因此在场景制作时常常会大量使用，小块的地形，甚至带有动画的地形，特效，以及半透明效果来增强画面的效果，画面效果增强的同时导致性能急剧降低。

### 另一种是地图地形的程序拼接方式。

用程序拼接地图，这样所有的地图都由程序而生成了一个或者几个模型的结构，进而铺满整个地面。

这种方式来制作地图最常见的要属2D的RPG游戏了，2D角色扮演类游戏中，几乎整个屏幕的地形都需要用地图编辑器来建立和拼合的，当需要这类地图出现时时，程序会将地图数据加载进来后，对每一块的地图都进行动态的拼合，这样一来，整个地图就只有一个drawcall，因为它只是同一个模型。

###### 2D角色扮演类游戏中，动态拼合整个地图怎么做到的呢，其实很简单。

整个地图就是一个矩形，每个地图的地形方块就是这个大矩形中的一个格子，而每个格子都由2个三角形构成，既然我们能计算出每个方块的位置，我们就能计算每个三角的顶点和位置。

我们知道的是，整个地图有多大，也就是整个矩形有多大，每个方块矩形有多大，也就是每个格子有多大。我们知道有多少格子，有多大的格子，就能计算出，总共有多少个顶点，每个顶点的位置在什么地方，也就能知道三角形该怎么拼接了。

拼接完三角形，再把地图的UV接上去，因为每块地形的图都不一样，所以我们需要在离线时就把所有的地形图都拼成一张图，即以图集的方式存储地图的方块。当我们需要将图接到网格上时，读取那个方块的UV点赋值给顶点就可以了。

伪代码：

		//生成地图
		void Generate_map()
		{
			//遍历每块矩形的方块位置
			for i to width_count then
				for j to height_count then
					mesh = generate_trangle_by_rectangle(i,j,_type, texture_info)
					CombineAdd(mesh)
				end
			end
		}

		//生成矩形方块所需要的，4个顶点，4个索引，2个三角形，2个三角形的顶点索引，以及三角形的uv位置。
		void generate_trangle_by_rectangle(int _x, int _y, int _type, texture_info _tex)
		{
			//矩形的4个顶点
			point1 = vector2( (_x - 0.5) * width, (_y + 0.5) * height)
			point2 = vector2( (_x + 0.5) * width, (_y + 0.5) * height)
			point3 = vector2( (_x + 0.5) * width, (_y - 0.5) * height)
			point4 = vector2( (_x - 0.5) * width, (_y - 0.5) * height)

			//顶点增加后的索引位置
			point_index1 = add_point(point1)
			point_index2 = add_point(point2)
			point_index3 = add_point(point3)
			point_index4 = add_point(point4)

			//三角形的生成时的顶点
			trangle1 = [point1, point2, point3]
			trangle2 = [point3, point4, point1]

			//三角形顶点的索引信息
			trangle_index1 = [point_index1, point_index2, point_index3]
			trangle_index2 = [point_index3, point_index4, point_index1]

			//4个uv点位的信息
			point_uv1 = vector2(_tex.uv_x, _tex.uv_y)
			point_uv2 = vector2(_tex.uv_x + _tex.width, _tex.uv_y)
			point_uv3 = vector2(_tex.uv_x + _tex.width, _tex.uv_y + _tex.height)
			point_uv4 = vector2(_tex.uv_x, _tex.uv_y + _tex.height)

			Mesh mesh = new Mesh()
			mesh.trangles = [trangle1 , tangle2]
			mesh.trangles_index = [trangle_index1 , trangle_index2]
			mesh.uvs = [point_uv1, point_uv2, point_uv3, point_uv4]

			return mesh
		}

上述代码中，对所有地图中的方块都进行遍历，在遍历中生成了每个方块所需要的顶点，顶点索引，uv点，进而生成三角形，三角形的索引。在生成完毕后，将这些生成的数据，与前面生成的数据进行合并，使得整个地图是一个一体化的网格，只产生一个drawcall。

用程序拼接地图的好处是可以任意的通过地图编辑器来改变地形地貌，拼接完成的地图在渲染上的代价也相当的小，而且假如想换个地图的地形，只要更换贴图就可以了，什么样的贴图就可以产生什么样的地图。

同时也带来了很多弊端，必须要有成形的地图编辑器支撑，前期工具的工作量比较大，稍微提高了一点点门槛，并且地图元素仅限于贴图中的元素，当地图元素增加到一定范围，就要扩大地图的贴图时就要重新排列地图信息。

###### 3D RPG角色扮演类游戏中，也时常常使用这种技巧来绘制游戏地图，曾经在日本风靡一时的《白猫计划》就是这样做的。

这种程序拼合的地图，策划设计师、关卡设计师可以在地图编辑器上，任意的绘制、拼接、同种类型的不同样式的地图（即在同一张贴图内容中的模型和地图元素），因此大大缩短了大量的场景试错时间。它能大量的生成出不同样式的地图，而不需要制作大量的不同类型的3D模型，大大缩短了项目时间进度，深受游戏制作人的喜爱。

那么在3D地图中是怎么拼接方块地形的呢？看上去比2D更加复杂的事情，其实更加简单。

首先，在3D地形模型制作时需要规范的一下，3D模型的长宽必须和地图方块的长宽是一致的。3D地图中，不需要我们自己来拼接三角形了，因为已经有了固定的地形模型，但对每个地形模型就需要有规范。假如规定每块地形都是 1 x 1，那么在制作和拆分地形模型时就要按规定来，每个3D地形模型都必须以 1 x 1 的标准来定制，否则不可用。当然并不一定要 1 x 1，也可以是2 x 2、 3 x 3等等，只是当标准制定完毕后，地形模型的制作必须要按照标准来做，每个元素都相当于一个地图块。

其次，所有地形模型的贴图都必须并在一张贴图上制作。因为只有这样才能在合并模型后让这么多 1 x 1 的小方块只需要1个drawcall渲染调用就可以了绘制所有的地图。也只有这样，才能解决太多模型需要渲染导致的爆量drawcall问题。

最后，在3D地形模型制作时也是相当考量的，因为这个地图都被拆分成了N种类型的地形方块，所以在制作的初期需要对整个地形有哪些类型的需求，需要有一个交流探讨的过程。

并且在读取地图编辑器编辑的数据后，生成地图时也时常需要增加些许逻辑，比如当左边是某个模型时，为了能与它完美的拼接，当前这个格子上的模型必须是迎合它的那个，就像我们在制作和拆分城墙时那样，当城墙处于拐角处时，我们需要用拐角模型代替，还要判断它的左右前后有没有城墙，这4种情况都有不同的4种拐角城墙所代替，就是为了完美契合周围的环境而进行的额外的处理。

### 常规场景的性能优化

上面几节阐述了地图的拼接方式，其中程序拼接的方式确实大大降低了drawcall的数量，提升了渲染的性能，但只针对可拆分的地图类型项目，对大多数游戏类型来说地图是不可拆分成小块的。因此我们还是需要更多的针对常规场景讲解优化的方法和技巧。

首先我们要清楚的是，是什么造成了场景的低渲染效率。我们在这里罗列一下主要的几个问题：

		1.渲染面数太多，GPU压力太大。

		2.渲染管线调用次数太多，即drawcall太多，GPU压力太大

		3.贴图太多太大，显存的带宽负荷太重

		4.动画太多，蒙皮的计算量太大

其实还有很多很多问题需要解决，比如实时阴影导致的drawcall太多，渲染压力太大，以及透贴太多，overdraw重绘问题比较严重，还有单个物体需要的Pass渲染次数太多，一个物体需要绘制多次才能完成等等。这些问题也是很重要的，但这节我们重点解决这最重要的4个问题。

### 1.渲染面数太多，GPU压力太大。

渲染面数太多分两种，一种是整个场景3D物体太多导致的面数多，一种是同屏展示的面数太多。

###### 前一种Unity3D引擎会裁切掉在摄像头之外的物体，不让他们进入到渲染管线以减少消耗，虽然裁切也会消耗小部分CPU，但毕竟比起渲染整个物体要小的多。

在进入渲染管线前每个3D物体能计算出一个包围盒，即Bounds，这个包围盒由8个顶点组成，加上旋转矩阵就能计算出一个每个顶点是否在摄像头的锥形体范围内。如果有一个点在锥形体内，就认为不可被裁剪，如果8个顶点都不在摄像头的锥形体范围内，就认为是不需要被渲染的，于是就被裁剪掉。

这种Unity3D引擎上的裁剪，帮助我们屏蔽掉了很多不需要渲染的物体，虽然裁剪也会花去些许CPU，但比起要绘制一个3D物体来说要少的多的多。

这种裁剪的好处是，使得我们只要关心摄像头范围内的面片就可以了，当然如果是合并的模型，一旦这个模型很大，覆盖了整个场景，就不会被裁剪，因为它的包围盒就是最大边界的立方体。

除了Unity3D引擎内的裁剪，GPU也会对每个三角形进行裁剪，不过三角形的裁剪要比8个顶点的包围盒裁剪要费的多。所以我们尽量还是能用包围盒裁剪就用包围盒裁剪方式，将更少的三角形面片带入GPU。

###### 后一种同屏面数太多的情况，就是因为3D模型都在摄像头范围内，要么就是模型太多，要么就是模型面数太多，要么就是摄像头太远而显示距离太大造成的。

最简单直接的方法就是，拉近摄像头，或者拉近摄像头显示距离，让更少的模型进入视野内。当视野范围内的物体少了，需要渲染的模型面数也就少了，自然CPU和GPU的消耗也就少了。虽然这是最拙劣的办法，但也是我们需要考虑进去的情况。

其次是减少模型面数，或者减少模型在场景中的数量，降低不必要的高品质。3D模型面数的降低，不是一两天就能完成的事，一个模型面数的降低也伴随着画面质量的降低，又要面数低又要品质高那是痴人做梦，所以我们要有一个容忍度，即前面几章提到的，要将模型面数在研发期间控制在一定范围内。模型数量在场景中的数量的降低，更更直接的去除了许许多多本来需要渲染的三角面，自然就省去了诸多CPU和GPU消耗，但也伴随着场景变得空旷不饱满不生动。

###### 那么有没一种方法可以不更重制3D模型面数，不减少模型在场景里的数量，不缩短摄像头显示距离，也能优化性能的。有。

世上没有免费的午餐，想降低CPU消耗，就得用增大内存来换。

LOD，即Level of detail，就是此道。用内存换CPU。

我们把每个3D模型，做成多个不同细节级别的模型，当摄像头拉远时，启用形状相似面数更少细节的模型，当摄像头拉近时，则启用形状相似面数更多细节的模型。

这样即使众多的模型在摄像头范围内需要渲染，也只有几个模型在靠近摄像头的，而大部分都是远离摄像头的。

远离摄像头的3D模型面数很少，即使数量众多，它们所展示的低等级的面数的总和也是可以接受的。

我们常提到的 Mipmap 也是这种方式在运作，对于距离远的物体，启用更小的纹理贴图，而与摄像头距离近的物体则使用更大的纹理贴图。

天下没有免费的午餐，提升了CPU和GPU的性能，就会增大内存的消耗，如果内存消耗太多也是得不偿失的，因此在考虑怎么分级、分多少级的细节级别上也需要深思熟虑。

### 2.渲染管线太多，即drawcall太多，渲染管线太多

除了面数带来的GPU计算压力，渲染管线太多也是造成GPU压力的一大问题。

渲染管线太多的问题，大都是因为场景中的模型物体太多，或者使用的Shader中的管线太多，或者这两者同时造成的。

其实这个问题是最好解决的，‘干掉’在场景中众多的模型物体，以及‘注释掉’Shader中不必要的管线。

当然这是最粗暴的做法，无疑将美术设计师，场景设计师的辛勤工作的成果给抛弃了。

我们能不能在不毁坏场景的前提下，做些优化呢。可以的。

关键点就在于‘合并’二字。

为什么呢？因为一个屏幕内需要渲染的面片数量是一定的，即我们不减模型在场景中的数量，不减单个模型面数的情况下，一个画面上需要渲染的面数是固定的。但是，我们每次调用管线渲染（即drawcall）给的面片数量比较少，调用的次数比较多，我们能否合并这些面片数据，然后一次性得传递给管线，将原来需要很多次的管线调用变成一次，只有这样才能大大降低drawcall的数量，降低渲染管线的数量。

那减少了渲染管线即drawcall的数量有什么好处呢？

减少了渲染管线的数量，即降低了drawcall的数量后，尽管并没有减少任何需要渲染的面片数量，只是每次传递给渲染管线的顶点和面片数增多了，传递的次数减少了，但是这个面片数据进入GPU后，就可以并行处理了，而不再是像以前那样这么多drawcall，每次渲染一个画面时drawcall的队伍都要排的老长老长的，都等在那排着队等待一个个的交给GPU处理，效率低下。

合并后就不再是这样了，排队的数量少了，队伍很短，虽然每个排队的‘人’都很‘胖’（即数据量很多），但是一旦进入处理阶段，4-8条生产线并行处理这些数据，比前面排着老长得队伍一个个处理要来的高效的多。

所以我们要想方设法的合并各种模型。怎么合并？

分实时合并与非实时合并两种方法。

其中实时合并也会消耗大量的CPU，因为它要读取多个模型，并创建新模型数据，不断的创建新模型数据，就会导致CPU的消耗。这里不再详细介绍，前面章节已经介绍过了，简单点说就是，把相同材质球，相同贴图的模型，读取它们的模型数据，生成一个新的合并后的模型，然后隐藏原有的模型。如果很多模型材质球效果一样，但贴图不一样，我们可以在线下手动合并它们的贴图后再放到线上合并。

非实时合并则全是线下的手动合并，即大家常说的静态合并。Unity3D静态批处理的规则比较严格，即要求相同材质球相同贴图还要形同模型，而且内存消耗比较大，因此我们还是建议使用自己手动合并的方式，即手动拼接场景中静态不动的、有相同材质球、相同贴图的模型，手动拼接成一个模型，也可以用插件来操作，比如 MeshBaker。

静态合并Mesh的好处就是，游戏中不需要实时消耗CPU去合并模型，节省了不少CPU，也降低了很多Drawcall的数量。

当然过犹不及么，如果把所有的在场景内的物体全部合成为一个模型，整个地图，无论摄像头能不能看到的地方都合并了，那么GPU的压力也同样很大，因为这样的话我们前面提到的引擎自身做的第一层包围盒裁剪就不生效了。渲染时会一股脑的将整个模型数据塞进渲染管线中，GPU在裁剪时的压力就会很大，因为它要裁剪整个地图的所有模型面片，计算量也是巨大的。

因此我们在静态合并时也要适度，即合并周围距离不太远的、可以合并的模型。这样即减少 Drawcall 次数，也同时降低了GPU裁剪的压力。

### 3.贴图太多太大，显存的带宽负荷太重

贴图太多，宽带压力太大，导致的问题，主要是因为GPU在渲染时，需要将内存的纹理拷贝到显存中去才能使用在GPU中。所以拷贝的消耗和显存的消耗也是很大的。不过，显存只存在于主机和PC游戏中，在手机中没有显存的概念，只有内存，因此都是内存和内存的拷贝。

在手机中只有内存与内存的拷贝，那么岂不是内存中的贴图纹理有两份？是的，如果引擎没有做额外处理的话，按照常理GPU的工作流程确实会是拷贝一份纹理到另外一段内存中，导致一份纹理占用了两份内存。但是毕竟引擎还是做了很多优化的，Unity3D就做了这方面的优化，当贴图没有勾选Read/Write 时Unity3D就认为该贴图是不会被改变的，当GPU需要该贴图时只是把原来在内存中的值传进去，而不是拷贝整个纹理，而当我们 勾选了 Read/Write 后Unity3D就认为该贴图是会被改变的，因此当GPU需要该贴图去渲染的时候，则会重新拷贝一份纹理贴图，这份纹理贴图专门给GPU渲染使用，避免GPU的纹理贴图随时被更改。

因此我们在贴图设置时，首先要注意 Read/Write 选项是否需要被开启，绝大部分贴图是不需要被开启的，这些贴图被开启后造成的2倍内存也是不必要的。

贴图太大太多，最好的办法是缩小贴图和压缩贴图。

看起来挺简单的，其实我们在实际项目中，我们不可能随意的去缩小和压缩贴图，这样很容易导致项目因贴图质量太糟糕而影响画面效果。

我们需要针对每个部分的贴图逐一去了解和设置，其实每个功能部分的贴图都有其用途。比如UI中的贴图分，图集和Icon图片，图集一般都是无损质量，因为要保障画面，也不需要 Mipmap采样，Icon图也是一样。虽然也不是不能压缩，不过压缩后确实UI的质量会遭到比较显著的降低，针对低端机时确实可以这样去做，因为无损的贴图在内存上和压缩的贴图通常有5-10倍的差距。

又比如3D模型的贴图，这些模型纹理贴图，通常都是2的幂次存在，因为2的幂次的纹理在GPU中处理起来比较顺手，而他们也通常是可以压缩的，并且带有 Mipmap 采样生成标记的。要压缩多少，压缩到什么比例才适合，每个项目都不一样，因人而异，大部分时候我们都是指压缩到中位数即Normal Compress普通压缩。

贴图的大小确实比较重要，每个项目在开始时都要好好的规范一下，因为只有遵守良好的规范，项目才能将内存限制在可控范围内。

幸运的是，美术设计师无论将贴图做的多大，我们都可以在Unity3D里重新设置成我们需要的大小，Unity3D会将所有贴图都重新制作导出成用户指定大小的贴图和格式。因此即使前期贴图太大而导致的问题，也可以在Unity3D的项目中将贴图设置回我们想要的大小。

### 4.动画太多，蒙皮的计算量太大

动画确实是最令人头疼的，因为它是动态的，而且时时刻刻都是动态的，不像3D物件，虽然它们会出现消失，但大部分情况下还是静止不同的。而动画则不同，它们时时刻刻都在你眼前动来动去，即使不再屏幕上，大部分时候也需要一直保持动的状态。

对于动画的优化，其实上几个章节中有讲的比较详细，这里只是简单的点一下。

动画的消耗点最大的地方是CPU的蒙皮计算，如果有100个动画在屏幕中播放，由于每帧对蒙皮的计算都是全局性的，因此CPU会极大的消耗在蒙皮计算上。

蒙皮计算，其实质就是骨骼与顶点的计算，骨骼动画用骨骼点去影响顶点，每帧都需要计算骨骼点与顶点的偏移、缩放与旋转。


顶点动画代替草和树的摇摆


### 烘培

去除点光源

### 人物动作技能编辑器



10，场景优化技巧
	2.	LOD优化方案。
	3.	合并贴图，合并材质球。
	4.	阴影与优化。 -- 假阴影面片，阴影绘制区域管理
	5.  用Shader顶点变更来替换固定动画，把动画由CPU转移到GPU。

### 6.动态障碍下的寻路

动态障碍在多人RPG在线游戏的上运用的比较多，因为多人同时在同屏玩游戏时有挤压的效果会有更多的竞技感。那么在各种类型的网格模式下，是怎么做到呢？

二维数组中的寻路最容易做动态障碍，因为每个格子都代表了一个寻路点，只要填上一个障碍数据就能

三角网格寻路则使用物理检测碰撞辅助寻路。




RecastNavigation-NavMesh生成原理
https://blog.csdn.net/you_lan_hai/article/details/77428858

navmesh高度结构
http://critterai.org/projects/cainav/doc/html/6fb3041b-e9be-4f03-868b-dcac944df19b.htm

关于 Unity NavMesh 数据的导出和使用
http://www.cnblogs.com/yaukey/p/3585226.html

可以用路点+navmesh的形式做图。因为路点消耗少，在城市道路上，在没有怪物的情况下可以做到很少的消耗。而在战斗中则需要整个地面有寻路路线，就需要navmesh的作用。

### 资源加载的多种方式


### 8.人物技能编辑器

人物位移，

特效释放

时间轴

事件机制

9.	人物动作与技能编辑器
