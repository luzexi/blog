---
layout: post
status: publish
published: true
title: 《Unity3D高级编程之进阶主程》第四章，UI(四) - UGUI核心源码剖析
description: "unity3d 高级编程 主程 ugui 源码 graphic 剖析"
excerpt_separator: ===
tags:
- 书籍著作
- Unity3D
- 前端技术
---

前文回顾 [UI(一)](http://luzexi.com/2018/07/25/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-UI1.html)

对NGUI和UGUI进行了比较，讲述了如何选择UI系统作为项目的UI框架。

前文回顾 [UI(二)](http://luzexi.com/2018/07/25/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-UI2.html)

UGUI的原理，以及组件使用详解。

前文回顾 [UI(三)](http://luzexi.com/2018/07/26/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-UI3.html)

UGUI源码中输入事件模块源码剖析。

此篇我们来讲解下，UGUI渲染部分的核心源码。

===

### UGUI渲染核心源码剖析

我们先来看下核心部分的文件结构，如下图：

![ugui-core](/assets/book/4/ugui3.png)

从图中可以看出，由文件夹拆分的模块有，Culling, Layout, MaterialModifiers, SpecializedCollections, Utility, VertexModifiers，这几个模块很容易看出来是什么作用.

### Culling文件夹

![ugui-core](/assets/book/4/ugui4.png)

Culling里都是对模型裁剪的工具类，大都用在 Mask 遮罩上。

里面四个文件，其中一个是静态类，一个是接口类，每个文件都只有不超过50行的代码。

看了下里面的内容，基本都是辅助工具函数或者接口定义函数，所以认定为Culling 文件夹里的都是裁剪用的工具函数。

### Layout文件夹

![ugui-core](/assets/book/4/ugui5.png)

从图中文件夹结构可以看出，Layout 主要做的都是布局方面的事，横向布局，纵向布局，方格布局等等。

总共12个文件，有9个带有 Layout 字样，这些带有 Layout 字样的文件或者类，都是处理布局的。

除了处理布局类意外，其余3个文件，CanvasScaler，AspectRatioFitter，ContentSizeFitter 是调整自适应的。

而且ContentSizeFitter，AspectRatioFitter 类在核心代码中并没有被用到，它们是独立存在的。

ContentSizeFitter，AspectRatioFitter 从都带有 Fitter 字样可以了解到，它们的功能都是处理自适应的。

看了两者代码后明白它们做的事情是按指定规则，指定比例缩放长宽。代码量都在100行多点。

相对于它们两个，CanvasScaler 做的功能更重要点，它操作Canvas 画布针对不同屏幕进行自适应调整。

下面代码是CanvasScaler的核心部分。

{% highlight c# %}

protected virtual void HandleScaleWithScreenSize()
{
    Vector2 screenSize = new Vector2(Screen.width, Screen.height);

    float scaleFactor = 0;
    switch (m_ScreenMatchMode)
    {
        case ScreenMatchMode.MatchWidthOrHeight:
        {
            // We take the log of the relative width and height before taking the average.
            // Then we transform it back in the original space.
            // the reason to transform in and out of logarithmic space is to have better behavior.
            // If one axis has twice resolution and the other has half, it should even out if widthOrHeight value is at 0.5.
            // In normal space the average would be (0.5 + 2) / 2 = 1.25
            // In logarithmic space the average is (-1 + 1) / 2 = 0
            float logWidth = Mathf.Log(screenSize.x / m_ReferenceResolution.x, kLogBase);
            float logHeight = Mathf.Log(screenSize.y / m_ReferenceResolution.y, kLogBase);
            float logWeightedAverage = Mathf.Lerp(logWidth, logHeight, m_MatchWidthOrHeight);
            scaleFactor = Mathf.Pow(kLogBase, logWeightedAverage);
            break;
        }
        case ScreenMatchMode.Expand:
        {
            scaleFactor = Mathf.Min(screenSize.x / m_ReferenceResolution.x, screenSize.y / m_ReferenceResolution.y);
            break;
        }
        case ScreenMatchMode.Shrink:
        {
            scaleFactor = Mathf.Max(screenSize.x / m_ReferenceResolution.x, screenSize.y / m_ReferenceResolution.y);
            break;
        }
    }

    SetScaleFactor(scaleFactor);
    SetReferencePixelsPerUnit(m_ReferencePixelsPerUnit);
}

{% endhighlight %}

从代码中可以看出不同 ScreenMathMode 模式下，对屏幕的适应算法的不同。

### MaterialModifiers, SpecializedCollections, Utility

文件夹结构如下图：

![ugui-core](/assets/book/4/ugui6.png)

这三块相对比较简单。IMaterialModifier是一个接口类为Mask 遮罩修改Material提供接口。IndexedSet是一个容器。ListPool是List对象池。ObjectPool是对象池。VertexHelper 是用来存储生成 Mesh 网格需要的所有数据，不过 VertexHelper 只负责存储，不负责计算和生成。

### VertexModifiers

文件夹结构如下图：

![ugui-core](/assets/book/4/ugui7.png)

VertexModifiers 模块，主要用于修改网格图形，在UI元素网格生成后再对其进行修改。

其中 BaseMeshEffect 是抽象基类，提供所有在修改UI元素网格时所需的变量和接口。

IMeshModifier 是关键接口，在下面的渲染核心类中 Graphic 中会获取所有这个接口的组件，然后调用 ModifyMesh 接口来达到改变网格图像的效果。

Outline，Shadow，PositionAsUV1 都继承了 BaseMeshEffect 基类，并实现了关键接口 ModifyMesh。

其中 Outline 继承自 Shadow， 他们有一个共同的关键核心代码如下：

{% highlight c# %}

protected void ApplyShadowZeroAlloc(List<UIVertex> verts, Color32 color, int start, int end, float x, float y)
{
    UIVertex vt;

    var neededCpacity = verts.Count * 2;
    if (verts.Capacity < neededCpacity)
        verts.Capacity = neededCpacity;

    for (int i = start; i < end; ++i)
    {
        vt = verts[i];
        verts.Add(vt);

        Vector3 v = vt.position;
        v.x += x;
        v.y += y;
        vt.position = v;
        var newColor = color;
        if (m_UseGraphicAlpha)
            newColor.a = (byte)((newColor.a * verts[i].color.a) / 255);
        vt.color = newColor;
        verts[i] = vt;
    }
}

{% endhighlight %}

此函数作用是，在原有的定点基础上，加入新的定点，并且这些新的定点是在原来的定点的上修改了位置的偏移量和定点颜色，使得在原来的图形基础上，描绘一些新的样式。比如外描边或者阴影。

### 核心渲染类

上面讲解完了这些用来辅助核心渲染的模块之后，我们来看看核心渲染类的奥秘所在。

我们常用的组件 Image，RawImage，Mask，RectMask2D，Text，InputField 中，Image，RawImage，Text 都是继承了 MaskableGraphic ，而 MaskableGraphic 又继承自 Graphic 类，所以核心最底层的类就是 Graphic 类。另外 CanvasUpdateRegistry 是存储和管理所有可绘制元素的管理类是哥蛮重要的类，我们下面会提到。

Graphic 核心部分有两个地方，第一个如下：

{% highlight c# %}

public virtual void SetAllDirty()
{
    SetLayoutDirty();
    SetVerticesDirty();
    SetMaterialDirty();
}

public virtual void SetLayoutDirty()
{
    if (!IsActive())
        return;

    LayoutRebuilder.MarkLayoutForRebuild(rectTransform);

    if (m_OnDirtyLayoutCallback != null)
        m_OnDirtyLayoutCallback();
}

public virtual void SetVerticesDirty()
{
    if (!IsActive())
        return;

    m_VertsDirty = true;
    CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(this);

    if (m_OnDirtyVertsCallback != null)
        m_OnDirtyVertsCallback();
}

public virtual void SetMaterialDirty()
{
    if (!IsActive())
        return;

    m_MaterialDirty = true;
    CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(this);

    if (m_OnDirtyMaterialCallback != null)
        m_OnDirtyMaterialCallback();
}

{% endhighlight %}

这是 Graphic 通知 LayoutRebuilder 布局管理类进行重新布局，以及通知 CanvasUpdateRegistry 绘制物体管理进行重新构建Mesh网格，而 LayoutRebuilder 最终还是通过 CanvasUpdateRegistry 来实现重新布局的。所以重构物体管理类 CanvasUpdateRegistry 很重要。他掌握着重构的生死。

CanvasUpdateRegistry 被通知重新绘制后，并没有立即重新重构，而是将需要重构的原件加入到容器中，等待下一帧时统一重构。

注意，CanvasUpdateRegistry 只负责重构Mesh网格，并不负责渲染和合并。另外，所有重构完毕的Mesh都将被移出重构列表。

{% include advertisement_content.html %}

- - -

Graphic 另一个重要的核心代码如下：

{% highlight c# %}

private void DoMeshGeneration()
{
    if (rectTransform != null && rectTransform.rect.width >= 0 && rectTransform.rect.height >= 0)
        OnPopulateMesh(s_VertexHelper);
    else
        s_VertexHelper.Clear(); // clear the vertex helper so invalid graphics dont draw.

    var components = ListPool<Component>.Get();
    GetComponents(typeof(IMeshModifier), components);

    for (var i = 0; i < components.Count; i++)
        ((IMeshModifier)components[i]).ModifyMesh(s_VertexHelper);

    ListPool<Component>.Release(components);

    s_VertexHelper.FillMesh(workerMesh);
    canvasRenderer.SetMesh(workerMesh);
}

{% endhighlight %}

此段代码是 Graphic 创建Mesh的部分，先创建自己的Mesh，然后调用所有需要修改Mesh的修改者进行修改后放入 CanvasRenderer 。

CanvasRenderer 是每个绘制元素都必须有的组件，它时画布渲染的连接组件，通过 CanvasRenderer 我们才能把网格绘制到 Canvas 画布上去。

这里使用静态的 s_VertexHelper 是为了节省内存和CPU消耗，所有Graphic 元素都要用的临时变量，设置为静态。还有 workerMesh 也是静态变量，目的和 s_VertexHelper 一样，都是为了节省临时变量的内存消耗和CPU消耗，因为 Graphic 很多所以这么做是需要的。

Image, RawImage, Text 都override重写了 OnPopulateMesh 函数。

		protected override void OnPopulateMesh(VertexHelper toFill)

原因是他们需要有自己自定义的网格样式，已达到构建不同类型的网格。

看样子CanvasRenderer 和 Canvas 才是合并Mesh网格的关键，但 CanvasRenderer 和 Canvas 并没有开源出来。

我试图通过查找反编译的代码查看相关内容，也没有找到，原因是Unity3D加强了反编译的防护工作，我们无法完整的得到核心的代码。

但仔细一想，也差不多能想个大概。合并部分无非就是每次重构时获取 Canvas 下面所有的 CanvasRenderer 实例，将它们的 Mesh 合并起来，其实也没有什么可变化的操作。关键还是要看，如何在重构Mesh时，减少重构数量和次数。

- - -

我们继续看 Mask 遮罩部分的核心代码：

{% highlight c# %}

var maskMaterial = StencilMaterial.Add(baseMaterial, 1, StencilOp.Replace, CompareFunction.Always, m_ShowMaskGraphic ? ColorWriteMask.All : 0);
StencilMaterial.Remove(m_MaskMaterial);
m_MaskMaterial = maskMaterial;

var unmaskMaterial = StencilMaterial.Add(baseMaterial, 1, StencilOp.Zero, CompareFunction.Always, 0);
StencilMaterial.Remove(m_UnmaskMaterial);
m_UnmaskMaterial = unmaskMaterial;
graphic.canvasRenderer.popMaterialCount = 1;
graphic.canvasRenderer.SetPopMaterial(m_UnmaskMaterial, 0);

return m_MaskMaterial;

{% endhighlight %}

Mask 组件使用Shader 渲染管线方式来裁切不需要显示的部分，也就是说，所有在 Mask 组件后面的物体都会进行裁切。

但是 RectMask2D 不一样的哦。RectMask2D 只针对 UGUI 中的可绘制可裁切物体进行裁切。

我们来看 RectMask2D 核心部分源码：

{% highlight c# %}

public virtual void PerformClipping()
{
    // if the parents are changed
    // or something similar we
    // do a recalculate here
    if (m_ShouldRecalculateClipRects)
    {
        MaskUtilities.GetRectMasksForClip(this, m_Clippers);
        m_ShouldRecalculateClipRects = false;
    }

    // get the compound rects from
    // the clippers that are valid
    bool validRect = true;
    Rect clipRect = Clipping.FindCullAndClipWorldRect(m_Clippers, out validRect);
    if (clipRect != m_LastClipRectCanvasSpace)
    {
        for (int i = 0; i < m_ClipTargets.Count; ++i)
            m_ClipTargets[i].SetClipRect(clipRect, validRect);

        m_LastClipRectCanvasSpace = clipRect;
        m_LastClipRectValid = validRect;
    }

    for (int i = 0; i < m_ClipTargets.Count; ++i)
        m_ClipTargets[i].Cull(m_LastClipRectCanvasSpace, m_LastClipRectValid);
}

{% endhighlight %}

上述源码中，

		MaskUtilities.GetRectMasksForClip(this, m_Clippers);

获取了所有有关联的 RectMask2D 遮罩，然后

		Rect clipRect = Clipping.FindCullAndClipWorldRect(m_Clippers, out validRect);

计算了需要裁切的部分，实际上是计算了不需要裁切的部分，其他部分都进行裁切。最后

{% highlight c# %}

		for (int i = 0; i < m_ClipTargets.Count; ++i)
            m_ClipTargets[i].SetClipRect(clipRect, validRect);

{% endhighlight %}

对所有需要裁切的UI元素，进行裁切操作。

SetClipRect 函数是裁切操作的源码，如下：

{% highlight c# %}

public virtual void SetClipRect(Rect clipRect, bool validRect)
{
    if (validRect)
        canvasRenderer.EnableRectClipping(clipRect);
    else
        canvasRenderer.DisableRectClipping();
}

{% endhighlight %}

最后操作是在 CanvasRenderer 中进行的。前面说过 CanvasRenderer 是被反编译闭屏的，我们无法得知内容。但是我们可以想象，在裁切时的多做，计算两个四边形的相交点，再组合成裁切后的多边形，差不多是一个数学计算的过程。

### 至此我们把 UGUI 的核心代码部分都剖析完毕了。其实也并没有什么高深的算法，或者技术。所有核心部分都围绕着，如何构建Mesh，如何重构Mesh，以及如何裁切的问题上。倘若想仔细阅读Unity3D源码，可以去如下地址获得。

[UGUI源码地址](https://bitbucket.org/Unity-Technologies/ui/downloads/?tab=downloads)

[Unity3D开源代码地址](https://github.com/Unity-Technologies/UnityCsReference/tree/master/Runtime)
