---
layout: post
status: publish
published: false
title: 《Unity3D高级编程之进阶主程》第五章，资源加载与释放
description: "unity3d 高级编程 主程 "
excerpt_separator: ===
tags:
- 书籍著作
- Unity3D
- 前端技术
---

我们在计算机上编程，始终逃不过计算机的体系范围。对于计算机来说不过是进程，线程，CPU，CPU缓存，内存，硬盘，GPU，GPU显存，我们在编程和优化时始终围绕着这个几个关键点在做文章。

从计算机宏观的角度上来看，计算机本身的内容就这么些，假如我们暂时不去细想具体的逻辑细节，我们可以从大体上明白我们需要做的工作与这些内容有多大的关系。

我们制作的软件运行在进程上，所以进程是我们的载体，线程可以分担进程的负担，有利于我们更大限度的利用多核CPU，这样就有不只一个CPU为我们工作。

在PC下CPU的负荷是由多个进程的消耗所组成的但我们只需要关心我们自己进程的消耗，它大部分都是由业务逻辑、算法，内存分配与回收等程序运行所造成的消耗。

CPU缓存的存在增加了CPU执行命令的命中率，使得CPU执行效率提高。只是CPU只认机器码由1和0组成的命令组合，于是在CPU之上又有了汇编这种语言做中间件，使得我们能够不用去记住0和1的世界，只是这个中间件还需要操作寄存器等直面硬件的事务让我们觉得还是太繁琐。对于庞大的软件系统来说人类无法承受如此庞大复杂度系统下的调试之苦，于是就有了更高级的语言+编译器来让编程变得更加简单，编译器它翻译了我们能容易识别的各种语言包括C++、Java、C#等，它先翻译成中间语言再将中间语言翻译成的二进制码被CPU识别。

这些高级语言能够让人类更加专注于编写复杂和庞大的软件系统，从而解放了我们直面硬件的痛苦。Unity3D引擎从这层意义上来说也是做了同样的事情，它将大部分对OpenGL/DirectX等图形接口底层的调用都封装好了等我们去用，解放了我们需要学习枯燥复杂的底层的时间，可以将更多的注意力放在对业务逻辑的框架结构和逻辑上。但是在我们制作过程中始终绕不过去的是硬件的工作流程和方式，如果我们想要编写更加优秀的程序，就得学习和理解这些底层原理，也只有这样才能明白我们在编写具体框架逻辑中对计算机是有利还是有弊。

内存是除了CPU缓存外最快的数据存取地点了，所以要想更快的取得内容就要更多的借助内存，不过也不能无止境的使用内存，比如我们的移动设备，在手机中内存还不是那么廉价或者说容量还不足以可以肆无忌惮的任意使用，即使是PC上内存已经足够大了也要考虑到其他软件进程的内存消耗，不能只顾自己进程的霸占更多内存。

硬盘在现代已经是很廉价了，硬盘占用的大小已经很少被大家所诟病，不过背后却需要考虑宽带问题。虽然硬盘廉价，但宽带并没有那么廉价，大部分对磁盘的占用都需要从网络上下载下来，这种宽带的占用量其实是紧张的，因此我们经常需要约束对硬盘的占用量，就是为了考虑下载时更多的节省宽带的占用量。

GPU对CPU的优势是对图形图像的处理比CPU更加强大，它的主要架构和运行模式都是为图形图像而生的，CPU常将大部分图形图像处理都交给GPU去做。从前都是CPU自己处理图形图像，但现代社会中GPU已经不像是以前那么昂贵了，成本已经到了平民化的水平，GPU也已经完全普及在各大设备中。即使是GPU普及的情况下，但GPU的性能好坏也是参差不齐，我们依旧要尽最大的努力去学习和理解GPU的运作原理，以在利用GPU算力时尽可能得发挥其最大优势，以及降低无用的等待与消耗。

虽然移动设备架构的设计没有将显存加入进去，但显存在PC上却是运用的玲离尽致，显存也确实让GPU在工作效率上升了一个台阶，就像CPU的缓存一样，显存让GPU得到数据和处理数据的效率更高。

###### 前面的章节说了这么多关于算法、框架、结构、数学、图形学等，我希望能用更大的角度来观察总结我们所天天需要接触的编程工作。每条语句，每个结构，每个编码都能知道我们现在所要围绕的是哪个节点，是否能通过节点优化来让当前程序的执行更加高效，让程序跑在设备上时更加流畅。

###### 前面说了这些关于计算机本身的事，寓意是想从宏观的角度看问题，抛开具体的架构、系统逻辑、框架结构等细节来看看我们所面对的工作到底是个怎样的世界。从根本上看我所说这些并不是什么特别具体底层的东西，但是也可以从另一个角度了解我们所面对的编程工作，对我们未来的技术方向会有很大的帮助。

### 前面讲了很多关于计算机本质的东西，这节我们主要来讲一下关于资源的内容。

### 资源加载的多种方式

虽然资源的格式并不一定要依照引擎来，但如果自己另开辟一种格式来做为资源加载确实耗时耗力，性价比很难适合，但也要按项目的需求来，如果是那种资源保密性要求很强的，也是有必要的。

这我们还是主要来说说以Unity3D自身格式为重点的资源加载方式。

我们可以把资源加载分为阻塞式和非阻塞式。到底什么是阻塞式什么是非阻塞式呢？

简单来说，阻塞就是当前资源加载完了才能执行下一条语句，非阻塞就是开另一个线程加载资源，当前的主线程可以继续执行程序，当加载完毕时再通知主线程。

在Unity3D中阻塞式的加载主要有：

		1.Resource.Load

Resource.Load是传统的资源加载方式，Unity3D通过Resources这个名字的文件夹来加载资源。

在移动设备下，Unity3D打包了Resources文件夹的所有资源文件成为1个或几个资源文件(是资源文件合并成1个或几个资源包文件)放入包内，当调用Resource.Load时从这几个资源文件中加载。

这个资源包文件会被Unity3D在打包时压缩，保证了包体的大小会适度的减少，压缩的另一面是解压，因此在通过Resource.Load加载时也增加了解压的CPU损耗。这也是很多项目不乐意使用Resources的缘由，解压消耗带给他们不必要的开销，因为CPU资源比硬盘资源珍贵的多。

		2.File read + AssetBundle.CreateFromMemory + AssetBundle.Load

我们也可以先通过文件操作加载资源文件，再通过AssetBundle.CreateFromMemory的方式把byte数据转换成AssetBundle格式，再通过AssetBundle.Load从AssetBundle中加载某个资源。

这种方式看起来费时费力，但是这种方式可以加入我们些许自定义功能。比如能在加载AssetBundle前做加解密操作，加载AssetBundle前自主加载了文件，文件的数据的加解密方式就可以自由的把控，我们可以先用文件操作获得数据后解密，再转换成AssetBundle实例，最后交给资源控制程序处理。

不过获得加解密AssetBundle的能力，是需要付出代价的，代价就是内存和GC(内存的分配与销毁)。

由于用文件操作时完全读入了整个文件的数据，导致当前还不需要的资源也一并读入内存，增大了内存消耗，另外转换成AssetBundle后的byte数据也不再由用处，等待GC的消耗动作，大大增加了内存分配和销毁的CPU负荷。

		3.AssetBundle.CreateFromFile + AssetBundle.Load

我们还可以使用通过直接加载文件变成AssetBundle的方式，再通过AssetBundle.Load接口来获得资源。

这种加载方式最大的好处是按需分配内存。AssetBundle.CreateFromFile并不会把所有资源文件整个加载进内存中，而是先加载数据头，通过数据头中的数据去识别各个资源在文件中的偏移位置，当调用AssetBundle.Load时，根据数据头中对应资源偏移量的记录，找到资源位置，加载数据进入内存，因此我们说它是按需分配内存的。


在Unity3D中非阻塞式的加载有：

		1.WWW + AssetBundle.Load
		2.WWW + AssetBundle.LoadAsync
		3.AssetBundle.CreateFromFile + AssetBundle.LoadAsync
		4.File Read all + AssetBundle.CreateFromMemory + AssetBundle.Load
		5.File Read all + AssetBundle.CreateFromMemory + AssetBundle.LoadAsync
		6.File Read async + AssetBundle.CreateFromMemory + AssetBundle.Load
		7.File Read async + AssetBundle.CreateFromMemory + AssetBundle.Load
		8.File Read async + AssetBundle.CreateFromMemory + AssetBundle.LoadAsync

这种几种方式主要是由几种非阻塞形式组合而成。


### Assetbundle的加载与释放

### 引用计数，智能指针

### 颗粒度的拆分


