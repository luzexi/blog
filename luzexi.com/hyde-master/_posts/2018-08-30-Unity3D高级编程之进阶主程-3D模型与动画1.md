---
layout: post
status: publish
published: false
title: 《Unity3D高级编程之进阶主程》第五章，3D模型与动画(一)
description: "unity3d 高级编程 主程 ui ugui 原理 使用详解"
excerpt_separator: ===
tags:
- 书籍著作
- Unity3D
- 前端技术
---


### 3D模型大小，面数，贴图大小，骨骼数量在游戏中的规范。

为什么说资源的规范在项目中是极其重要的？

看到过有很多项目都没有重视资源规范，他们还在最求高的运行效率，却不懂资源的规范是运行效率的前提。

有的游戏项目，一个人物模型就有几万个面，一个建筑就有几十万个面，不堪入目。

贴图也有很糟糕的，到处都是1024和2048大小的贴图。骨骼数量有的甚至到了几百。在这样恶劣的资源环境情况下，项目的运行效率怎么可能高。

资源的好坏直接导致了项目的好坏，模型太大，面数太多，贴图太大，会导致包体过大，骨骼数量太多，导致CPU在动画上消耗过多。

资源过大过重，还会导致CPU消耗在资源加载上面的时间过多过长，导致画面帧率下降，卡顿严重等问题。

我们来简单设想下就能明白这个道理，CPU加载一个文件要花去多少时间呢，打个比方，加载1MB要0.01秒，卸载要0.005秒，那么100MB的加载卸载就要1.5秒，一个项目在10秒内要加载卸载300MB资源会发生什么，你的卡顿时间会达到4.5秒，将近一半的时间在画面卡住状态。

假如这个项目是手机游戏项目，在这么恶劣的情况下发布出去，将会带来大量差评。花钱打广告去购买流量也是浪费钱，因为可玩性实在太差，没有玩家愿意耐下心来玩你的卡顿感这么糟糕的游戏。

这里只是打个比方，并没有去验证确切的数据，但为了让大家能够引起足够的重视，我觉得夸大点也无妨。

对于美术资源来说，模型面数不是越多越好，越细越好，而是在一定数量的限制下，能做到最大限度的美化。同样贴图也不是越大越好，精度越高越好，而是在一定大小的限制下，做到最大限度的不失真。在骨骼动画中

资源规范能有效的限制美术人员在制作美术资源时无度的扩张。

如何规范3D美术资源？
关于模型的大小，一般都会按正常的尺寸进行制作，比如规定1个单位空间就是1米。也有例外的时候，不过也是按这个放大缩小的，比如1个单位空间为1厘米，或10米等。
下面介绍几个方法，
1.	根据运用的场景而不同。
像汤姆猫这种强调单一主角的场景，主要资源全部投入到主角一个人的，对主角进行精细化的雕琢是很有必要的。这种场景的人物模型做到1万面也不为过，主角的骨骼也可以做得很精细，骨骼数量可以达到50-100个，贴图大小也可以在512*512左右，如果需要1024*1024的贴图我觉得问题也不是很大，只是如果需求中有换装时，需要考虑下包体大小。
如果是第三人称视角的RPG游戏，由于视角与角色的距离有限，同时看到的场景范围有限，可以使用动态场景地图加载的方式控制内存使用量，主要是同屏单位数量会决定模型面数。比如人模模型面数控制在3000-4000面，骨骼数量控制在20-30个，至于建筑模型面数因为大小差异太多无法统一，不过我们可以用整体面数统计法来规范资源。贴图完全可以控制在256*256以下，比如主贴图为256*256，副贴图为128*128。
如果做的是《我的世界》，《魔兽世界》这种超大型的游戏场景，可以从高空俯瞰整个场景的这种，规范的太小会失真，规范的太大就会消耗太多内存和CPU的，这已经不是规范资源能解决的问题了，而是用其他方法手段，比如LOD，只要处理好LOD就能把渲染压力和渲染质量平衡好。后面章节中会具体介绍LOD在优化中的运用。

2.	使用反推计算来得出规范。
对于一些模型物体大小差异很多大的，无法统一模型与贴图面数的，我们可以用全场景总面数来控制。比如地形场景控制在6万面左右，然后开始部署，地形模型总共3万面左右，数量多的小件模型在100面以下平均50面，中型建筑在500-1500面平均下1000面好了，大型建筑在2000-5000面以下平均3000面。这样除了地形模型，剩下的还有3万面，小件模型可以放100件也就是5千面，中型建筑可以放10件1万面，大型建筑5件，1万面，总共3万面差不多满足了6万面左右的需求。贴图大小也需要规范下，小件，128*128以下，中型建筑，256*256以下，大型建筑，512*512以下。

从上面阐述的反推计算方法来做，一整个地形场景的模型规范就很容易得出来了。

3.	参考其他同类项目。
我们也可以参考其他同类游戏的资源制作规范，比如解包他们的游戏包体，对资源进行解密解压等。也可以从他们具体游戏中观察如何应对面数和贴图问题。毕竟网络信息的开放的，我们可以充分利用起来。

4.	实际测试。
无论什么方法，都敌不过实际测试。如果可以在项目前加入实际的压力测试环节，或者在项目进行中加入渲染压力测试的环境，会更有利于对美术资源的规范。
专门有人做渲染压力的实际测试是很奢侈的，因为需要专门派遣一个人来完成这件事情，对于现在情况下，人才缺乏而且成本高的问题，一般很少会有项目能有这实力专门派人去做各种渲染测试。所以我们只能边做边测，遇到具体问题寻找自己的答案，比如寻找是否有情况特别恶劣的模型，整体面数是否大大超出预想等，然后再提出自己的方案来个个击破。


2.	Animation和Animator的选择。（https://blog.uwa4d.com/archives/Simple_PA_Animation.html）
首先说明Unity3D引擎已经不再对Animation动画系统进行维护。但不维护也并不是说一定不能用，很久旧的项目任然用的很好，而且Animation系统也基本上是完善好了的。那么为什么要用新系统Animator呢？
原因如下几个方面，
1.	Animator系统使用多线程计算，比Animation的单线程性能要高出一点。
2.	Unity3D本身就自带对Animator系统的优化选项“Optimize GameObject”。
3.	Animator功能更加强大，比如Retargeting功能能让不同角色使用同一套动画资源，比如游戏中的角色的空闲动画，就可以使用同一个动画文件省去了动画资源内存的开销。比如状态机的接入，让动画可以在不同的条件下自动的切换等。
不过Animator也有缺点，
1.	如果针对单个模型物体绑定单个动画的话，稍微繁琐一点。比如，场景有一棵树，它只会播放不停的摇的动画，我们需要对这棵树绑定Animator组件，然后创建一个AnimatorController放入Animator，还得在AnimatorController里设置一个State来绑定动画文件，才能完成整个自动播放动画的操作。
2.	如果从单个动画内存角度来讲，Animator的内存占有量比Animation大一些，因为Animator需要AnimatorController支持，比旧版的Animation多了一个数据文件支撑动画系统。
而Animation因为Unity3D引擎不再维护了，所以很多人选择了Animator。其实我很喜欢Animation，但有时也不得不抛弃它去投奔新主子的怀抱。

3.	Unity3D 3D模型中SubMesh的意义?
简单来说一个Mesh可以有多个SubMesh， 一个SubMesh对应着一个Material， 一个SubMesh由多个Triangle构成。在美术人员制作3D模型过程中，可以将SubMesh拆分成独立的Mesh，也可以并成多个SubMesh。

那么为什么美术人员在制作3D模型时，要制作成多个SubMesh呢，因为他们希望一个模型中一部分Mesh用一种材质球，另一部分用另一种材质球。这只是一个制作3D模型的方法和途径而已，跟成分独立的Mesh相比，多个SubMesh可以有整体的动作配合，又能针对不同部分的Mesh选择有针对性的材质球。而一个独立Mesh只能有一个动画，而且和其他独立的Mesh配合起来也比较麻烦。
Mesh中多个SubMesh在动作和拆分材质球渲染上确实有很好的优势，但缺点是难以和其他Mesh合并。

4.	如何对3D模型表面进行实时变更。(https://zhuanlan.zhihu.com/p/28471808 捏脸，骨骼点移动，旋转，缩放，Mesh大小差值实时生成)
对3D模型Mesh实时改变在很多场景中也是很有用的。比如Mesh地形挖坑，捏脸，物体切割，还有像《白猫计划》中的泡泡摇杆等。

5.	合并3D模型。

为什么要合并3D模型？
我们所做项目中，场景中的3D的物体很多，每个3D物体都会有一个材质球，每个材质球导致产生一个Drawcall（也就是一个渲染调用），导致很多3D物体产生很多Drawcall，CPU消耗在渲染上过多，使得画面卡顿感强烈。
大部分项目都会遇到这样的问题，因为场景中要摆放的3D物体很多，包括人物，建筑，路标，景观，树木等。这些3D物体，都需要用材质球渲染，一样的物体使用相同的材质球，不一样的物体使用不同的材质球。使用相同材质球的3D物体，我们可以借助Unity3D的动态批处理和静态批处理这些优化问题。

来介绍下Unity3D中动态批处理和静态批处理：
1.	动态批处理
Unity3D可以自动批处理移动中的物体成为同一个drawcall，如果是他们使用的是同一个材质球并且满足一些条件。动态批处理是自动完成的，你不需要增加额外的操作。条件是，
*动态批处理的物体的顶点数目要在一定范围之内，所以动态批处理只能应用在少于900个顶点的Mesh中。
	*如果你的Shader使用顶点坐标，法线，单独的UV，那么你可以批处理300个顶点内的网格，而如果你的Shader使用顶点坐标，法线，UV0，UV1和切线，则只能有180个顶点了。
	*注意：这个限制范围可能在未来被改变。
*如果物体不在同一个缩放单位上，将不会进行动态批处理（比如物体A的scale是1，物体B的scale是2，他们是不会被一起处理的）
*使用不同的材质球不会被动态批处理，即使他们看起来一样。异常原因在于阴影渲染处理。
*多通道Shader会中断动态批处理。
	*大多数Unity3D的Shader都支持多个灯光的前置渲染，有效增加渲染通道。Drawcall是“额外像素灯光”是无法批处理渲染的。
	*Legacy Deferred(灯光前置通道)传统延迟渲染路径已经被动态处理关闭，因为它必须绘制物体两次。

因为他要消耗CPU转换所有物体的顶点到世界空间，所以它唯一的优势是如果它的工作能让Drawcall变少。Drawcall的资源需求取决于很多因素，主要被图形API使用。例如，一个控制台或流行的API像Apple Metal这样的，Drawcall的开销会普遍很低，经常动态批处理没有任何优势。

2.	静态批处理
静态批处理允许引擎去降低Drawcall，无论他们多大但是需要使用同一个材质球。他通常比动态批处理有用（他不需要转换顶点到CPU），但静态批处理会消耗更多的内存。
为了让静态批处理的优势更大，你需要去确认指定的物体是否是静态的不能动，也不能旋转或者缩放。如果是这样的话，给这物体在面板上标记一个静态的标记。

使用静态批处理需要增加内存来存储合并的模型。如果一些物体在静态批处理前共用一个模型，就会复制每个物体的模型，在Editor里或者在实时运行状态下都会做这个操作。他可能不总是一个好的办法，有时你需要减少对物体的静态处理来减少内存的使用量，但牺牲了渲染性能。例如，森林级别里的树木都标记为静态会让内存急剧增加。

静态批处理将所有静态物体放入世界空间，并且为他们构建一个大的顶点集合以及索引缓存。然后，可见的物体就会被同一批处理，一系列的Drawcall被减少。技术上他没有节省3D API Drawcall数量，但他节省了他们之间的状态改变导致的消耗。在大多数平台上，批处理被限制在6万4千个顶点和6万4千个索引，所以倘若超过这个数量需要拆分开来。
以上是官方描述的批处理规则。下面来总结下：
1.	动态批处理条件是，使用同一材质球，顶点数量不超过900个，有法线的不超过300个顶点，有两个UV的不超过150个顶点，缩放大小要一致，Shader不能有多通道。
2.	静态批处理条件是，必须是点上静态标记的物体，不能动，不能旋转，不能缩放，不能有动画。
动态批处理的规则是极其严格的，在具体的场景中，很少有能用到的地方，因为顶点限制太少，还不能放大缩小。
静态批处理的用处多一点，但物体不能移动，旋转，缩放，即使偶尔一下也不行。这个限制也太死板，用到的地方也只有场景的固定物体了。那些偶尔动态的就完全不适用了，比如动态建筑，动态小件等，因为我们在构建场景时，常常是动态的，所以偶尔动态一下是必要的。
动态批处理限制太大，静态批处理又不满足我们的需求，所以我们就要自己手动合并模型来模拟批处理了。也只有我自己程序合并的模型才能体现自定义动态批处理的用途。比如构建场景后的动态建筑，动态小件合并，人物模型更换装备，发型，首饰，衣裤等导致多个模型挂载的需要合并模型来优化渲染。

如何合并3D模型？
合并3D模型，需要依靠Unity3D的API，需要用到Unity3D的几个类。
Mesh类，有个CombineMeshes的接口提供了合并3D模型的入口。
MeshFilter类，是承载Mesh数据的类。
MeshRenderer类，是个渲染绘制Mesh的类。
在使用这个接口前我们首先需要弄明白几个概念：
1.	SubMesh的意义。前文用专门的一章来解释它的意义。这里简单阐述下，SubMesh需要额外的材质球，而普通的Mesh共用一个材质球。
2.	MeshFilter和MeshRenderer中的，mesh和shareMesh，material和shareMaterial的区别。mesh和material一样都是实例型的，一旦对mesh和material进行任何操作都会额外复制一份后再进行重新赋值，即使只是get操作也同样会发生复制效果，所以说对mesh和material进行操作后就会变成另一个实例，虽然看上去一样，但其实已经不一样了。sharedMesh和sharedMaterial不一样，他们是共享型的，几个3D模型会共用同一个指定的sharedMesh和sharedMaterial，无论你怎么修改sharedMesh或sharedMaterial里面的实例，都不会改变很多3D模型使用指定的一个sharedMesh和sharedMaterial，而改变后这些共同指向同一个Mesh和Material资源的3D模型会变成同一个效果。
3.	materials和sharedMaterials，跟前面一样materials是实例型，sharedMaterials是共享型。materials只要操作就会复制一份一模一样的，sharedMaterial操作后其他指向这个材质球的都会改变。而materials和material，与sharedMaterials和sharedMaterial的区别是，materials和sharedMaterials可以针对不同的subMesh，而material和sharedMaterial只针对主Mesh，相当于material和sharedMaterial等于materials[0]和sharedMaterials[0]一样。
4.	Mesh，MeshFilter，MeshRenderer的关系。
Mesh是数据资源，他可以有自己的资源文件，比如XXX.FBX，数据资源里存储着顶点，uv，顶点颜色，三角形，切线，法线，骨骼，骨骼权重等提供渲染必要的数据。
MeshFilter是一个承载Mesh数据的类，Mesh被实例化后存储在MeshFilter，MeshFilter也有两个实力型和共享型的变量，mesh和sharedMesh，对mesh的操作将复制一份同样的数据重新赋值，而对sharedMesh操作将改变所有指向这个资源的渲染。
MeshRenderer是渲染功能类，它会提取MeshFilter中的Mesh数据，结合自身的materials或者sharedMaterials进行渲染。
5.	CombineInstance合并数据实例。合并时我们需要为每个需要合并的Mesh 创建一个CombineInstance实例，并往里面放入，mesh，subMesh的索引，lightmap的缩放和偏移，以及realtimeLightmap的缩放和偏移(如果有的话)，和世界坐标矩阵。然后通过Mesh.CombineMeshes接口进行合并。


以上概念理清楚了，写起代码来就简单了。

建立合并实例数组
CombineInstance[] combine = new CombineInstance[mMeshFilter.Count];

填入合并数据
for(int i = 0 ; i< mMeshFilter.Count ; i++)
{
    combine[i].mesh = mMeshFilter[i].sharedMesh;
    combine[i].transform = mMeshFilter.transform.localToWorldMatrix;
     combine[i].subMeshIndex = i; //标识Material的索引位置，可以为0，1，2等
}

合并所有Mesh为单独一个
new_meshFilter.sharedMesh.CombineMeshes(combine);

或者，合并后保留SubMesh
new_meshFilter.sharedMesh.CombineMeshes(combine,false);

CombineMeshes接口定义为
public void CombineMeshes(CombineInstance[] combine, bool mergeSubMeshes = true, bool useMatrices = true, bool hasLightmapData = false);

完整代码为：
CombineInstance[] combine = new CombineInstance[mMeshFilter.Count];

for(int i = 0 ; i< mMeshFilter.Count ; i++)
{
    combine[i].mesh = mMeshFilter[i].sharedMesh;
    combine[i].transform = mMeshFilter.transform.localToWorldMatrix;
    combine[i].subMeshIndex = i;//标识Material的索引位置，可以为0，1，2等
}

new_meshFilter.sharedMesh.CombineMeshes(combine);


6.	如何用状态机模拟人物行为动作。

什么是状态机？

状态机有两种，一种是有限状态机，一种是无限状态机。有限状态机运用的地方比较多，而无限状态机我还没看见过有在游戏项目中运用的。所以我们这里讲的状态机都是有限状态机。
状态机，简单描述下，实例本身有很多种状态，实例从一种状态切换到另一种状态的动作就是状态机转换，而转换是有条件的，这个条件就是状态机之间的连线。

打个比方，人有三个状态健康，感冒，康复中。触发的条件有淋雨（t1），吃药（t2），打针（t3），休息（t4）。所以状态机就是健康-（t4休息）->健康；健康-（t1淋雨）->感冒；感冒-（t3打针）->健康；感冒-（t2吃药）->康复中；康复中-（t4休息）->健康，等等。就是这样状态在不同的条件下跳转到自己或不同状态的图。

状态机可归纳为4个要素，即现态、条件、动作、次态。这样的归纳，主要是出于对状态机的内在因果关系的考虑。“现态”和“条件”是因，“动作”和“次态”是果。详解如下：
①现态：是指当前所处的状态。
②条件：又称为“事件”，当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移。
③动作：条件满足后执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接迁移到新状态。
④次态：条件满足后要迁往的新状态。“次态”是相对于“现态”而言的，“次态”一旦被激活，就转变成新的“现态”了。

注意，在进入状态和退出状态时，会发生进入事件和退出事件，这个是状态启动运作和停止运作的关键点。在满足转换条件后，先退出状态，向当前状态发起退出事件，告诉当前状态机，你将停止运行，停止运行前状态需要做什么赶快做吧，然后再向新状态发起进入事件，告诉新状态，你将要开始运作了，运作前的准备工作可以做起来了。这样每次状态的切换都能合理的告诉每个状态需要的信息和准备工作。

状态机在游戏中哪些地方会使用到？

所有能够构成独立状态的系统或者功能都能使用状态机来表现：
1.	场景切换。场景是独立的，只能有一个场景展示在游戏中，所以场景的切换可以用状态机来表示。比如当前是登录场景，点击登录后切换到游戏场景，这时需要把登录场景的UI销毁，这是登录场景状态退出时做的事，然后进入到游戏场景，要先把游戏场景的UI创建出来，这是游戏场景状态在启动时要做的事。
2.	人物行为状态切换。人物只能在当前做一个行为构成独立状态，比如人物跑步行为是一个状态，但人物边跑步边吃东西也会有，所以把人物跑步且吃东西另外创建一个状态来运行。
3.	宝箱，机关等具有多动画的元素都可以构成独立的状态。每个动画的播放都可以成为一个状态。
4.	AI。用状态机来封装AI是最常用的，每个AI状态都是独立运行的。比如激怒状态，此状态中会不断向周围的敌人发起攻击，如果20秒后恢复到平静状态不再攻击，又比如巡逻状态，在某个点周围或者按一定路线进行走动，如果5米内发现敌人，就进去激怒状态等等。

如何在人物行为动作中使用状态机？

先按常见的需求把人物行为动作划分一下：
1.	休息状态。原地不动，并且重复做一个休息的动画。
2.	攻击状态。播放攻击动画，并且对目标或前方进行攻击。
3.	技能状态。技能稍微复杂点，因为每个技能都不一样，所以技能状态里面的逻辑可以由不同的技能类来实现。比如建个技能基类class SkillBase，里面有几个统一的接口，然后子类对基类进行继承后，细化技能的细节。
4.	防御状态。播放防御动画，当受到攻击时，不切换受伤状态。
5.	受伤状态。播放受伤动画，完毕后自动进入休息状态。
6.	行走与跑步状态。播放行走或跑步动画，并根据操作输入移动方向。
7.	跳跃状态。播放跳跃动画，并上下移动人物进行跳跃，下落时底部受到碰撞就进入休息状态。
8.	死亡状态。播放死亡动画，并且不再受到任何指令而转入任何状态。

然后我们可以对每个具体的状态进行编写了，例如：
Class BaseState{
	Public virtual void OnEnter(){}
	Public virtual void OnExit(){}
	Public virtual void Update(){}
}
Class IdleState{
	Public override void OnEnter(){
		role.playAnimation(“idle”,loop);
}
}
Class HurtState{
	Public override void OnEnter(){
		role.playAnimation(“hurt”,Once);
}
Public override void Update(){
	If(!Role.IsPlayingAnimation(“hurt”)){
		HurtFinish();
}
}
Public override void OnExit(){
	GotoIdleState();
}

}

Class AttackState{
	Public override void OnEnter(){
		Role.playAnimation(“attack”,once);
}
Public override void Update(){
	If(!Role.IsPlayingAnimation(“attack”)){
		AttackStateFinish();
}
}
Public override void OnExit(){
	GotoIdleState();
}
}
Class MoveState{
	Public override void OnEnter(){
		Role.playAnimation(“walk”,loop);
}
Public override void Update(){
	Move();
}
Public override void OnExit(){
	GotoIdleState();
}
}
上述代码表达了对状态的描述，比如空闲状态，在没有收到任何指令时只循环播放Idle动画其他什么都不干；攻击状态，进入时播放攻击动画，并在动画结束后返回Idle状态并等待指令；移动状态在进入时播放walk动画并移动，在退出时进入Idle状态。
嗯，有了状态，就需要有个管理状态的类。
以下是伪代码：
Class RoleStateController{
	Private IdleState idleState;
	Private MoveState moveState;
	Private AttackState attackState;
Private HurtState hurtState;

	Private BaseState currentState;
	
	Public void OnHurt(){
		ReduceHP();
		If(currentState != hurtState){
			ChangeToHurtState();
}
}
	Public void InputAttack(){
		If(currentState  == hurtState) return;	//受伤状态下不可攻击
		If(currentState == attackState) return;	//攻击状态还没结束时不可重新开始攻击
		ChangeToAttackState();
}
	Public void InputMove(){}
}
这样就完美了，有了状态机的管理，就可以对各种逻辑的控制，比如硬值，受伤中不可行走和攻击，攻击中不可移动等。
