---
layout: post
status: publish
published: true
title: 读书笔记(二十五) 《C++ Primer》#1
description: "读书 书 看书 读后感"
excerpt_separator: ===
tags:
- 读书笔记
- 前端技术
---

[已发布在微信公众号上，点击跳转](https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&mid=2247484732&idx=2&sn=cbf9e354ddf1157c9913d7e4fc3ad41f&chksm=fc22603bcb55e92dd8e5fdd6210f007c072f1208ecf85a081f0273f26e54ff95ad9d219d2094&token=890029854&lang=zh_CN#rd)

## 背景：

我为什么要重学C++？第一是巩固核心，软件编程有三大核心，语言、操作系统、框架设计，语言首当其冲，核心能力大都看不见摸不着只有你自己知道的东西。第二是将分散的知识串联起来，这样就能产生新的知识和新的创意，将这些知识变成智慧融合到身体中。

本系列基于《C++ Primer》学习，重学的时候，我略过了滚瓜烂熟的部分，挑出以前忽略的，以及记忆没有那么深刻的，特别是那些重要的但以前没有上心的部分。

## 开始

使用命令行界面来学习c++会更好一些，这种学习方式可以让你将精力集中在c++语言本身上，一旦掌握了语言，使用和学习IDE编辑器通常也更容易些。

.h文件作为头文件只是程序员的习惯，头文件后缀并没有特定的规范，通常为了方便查看都以.h为后缀。

编译器一般不关心文件名的形式，但有的IDE对此有特定要求。

## c++基础

c++是一种静态数据类型语言，它的类型检查发生在编译时。因此，编译器必须知道程序中每一个变量对应的数据类型。

c++提供了一组内置数据类型、相应的运算符、以及为数不多的程序流控制语句，这些元素共同构成了c++语言的基本形态。

仅就c++的基本形态来说，它是一种简单的编程语言。

但其强大的能力显示于它对程序员自定义数据结构的支持，程序员可以通过自主定义新的数据结构来使语言满足他们各自的需求。

省略掉一些简单变量类型的内容，将一些特别需要注意，以及大家常忽略又比较重要的内容提取出来。

类型转换

1. char在一些机器上是有符号的，另一些机器上则是无符号的。

2. 当我们赋值给一个无符号类型的变量一个超出它范围的值时，结果是总数取模后的余数。

3. 当我们赋值给带符号类型一个超出他范围的值时，结果是未定义（不可预测）。

4. 切勿混用有符号和无符号的类型，如果表达式里既有带符号又有无符号类型，带符号的数会自动转换成无符号，如果是个负数则会出现异常结果。

无法预知的行为源于编译器无须检查的错误。在某些情况或某些编译器下，含有无法预知行为的程序也能正确执行。

不可移植通常都是程序依赖了环境，或操作系统环境或编译器环境，程序应该尽量避免依赖于实现环境的行为。例如我们把 int 的尺寸看成一个固定不变的值，这样的程序就称为不可移植。

## 变量

何为对象？对象就是指一块能存储数据并具有某种类型的内存空间。

初始化是一个复杂的过程，很多程序员对于初始化的认识，停留在=等号赋值的认知上。事实上它完全不是这样的。

它有构造、拷贝、赋值三种途径，且有默认构造、未初始化、定义与声明三个容易出错的地方。

初始化并不一定被默认执行，这是因为并对象不一定有默认构造函数，且有些编译器构造的默认构造函数并不一定会去初始化变量，这导致一个未被初始化的变量在拷贝和访问时就会引发错误，因此我们最好自己主动的去初始化每个变量。

c++支持分离式编译，允许将程序分为若干个文件，每个文件可被独立编译。

因此我们可以把变量的定义和声明区分开来，即在某个文件中定义，在另一些文件中声明后再使用。

变量能且只能定义一次，但可以被多次声明，在声明时不能重复初始化：

{% highlight c++ %}
// a.cpp
int global_index = 5; //定义

// b.cpp
extern int global_index; //声明
global_index += 5;

// c.cpp
extern int global_index; //声明
global_index -= 2;
如上代码中，a.cpp中定义了global_index并初始化为5，在b.cpp和c.cpp中使用。
{% endhighlight %}

## 复合类型

复合类型有两种，即引用和指针。

引用特点：

		引用本身不是对象，而它必须绑定一个对象。

		引用在定义时必须被初始化，它不能为空。

		引用在初始化后，与它的值绑定在一起，并且无法再重新绑定到另外的对象上。

指针特点：

		指针本身就有自己的对象概念，存放的是对象的地址，可为null也可以为具体的指针值。

		指针无须在定义时初始化（未初始化有风险），可以为空，也可以指向某个对象，也可能是无效的野指针。

引用和指针通过，取地址符（&），解引用（*）来操作，我们来举个例子：

{% highlight c++ %}
int dval = 5; // 初始化
int &tval = dval; // 绑定dval

int *pd = &dval; // 取地址，赋值给指针

*pd = 3; // 此时dval 为3，tval也为3，*pd也为3
{% endhighlight %}

特殊指针：
		
		1.c++11中引入了nullptr的空指针类型，以前用的NULL空指针，其实质是一个宏预处理，NULL定义在cstdlib中值为0。
		
		2.void*也是特殊指针，可用于存放任意对象地址。但不能操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，它仅仅是内存空间。


[已发布在微信公众号上，点击跳转](https://mp.weixin.qq.com/s?__biz=MzU1ODY1ODY2NA==&mid=2247484732&idx=2&sn=cbf9e354ddf1157c9913d7e4fc3ad41f&chksm=fc22603bcb55e92dd8e5fdd6210f007c072f1208ecf85a081f0273f26e54ff95ad9d219d2094&token=890029854&lang=zh_CN#rd)


