---
layout: post
status: publish
published: true
title: 读书笔记(十二) 《深度探索C++对象》
description: "读书 书 看书 读后感"
excerpt_separator: ===
tags:
- 读书笔记
---


看此书的起因是自己想更加深刻的了解底层，最底层的莫不过于汇编了，但只有汇编还不够，因为它需要上层工具语言编译器的支持，编译器怎么去编译程序的，决定了汇编的执行方向，理论上说汇编只是执行编译器编译后的程序内容，因此我认为编译器是关键所在。

我们大多数人自认为自己已经把面向对象语言已经烂熟于心了，其实台面下的机制，如编译器合成的默认构造函数、对象内存布局等都不是很了解。我也是一样，我对编译器一块知识一直不是清晰，所以想通过这本书来了解我们平时编程时的底层的工作原理是什么。

作者说第一句话就打动了我，让我认真看完了全书，他说“我的经验告诉我，如果一个程序员了解底层实现模型，他就能够写出效率较高的代码，自信心也比较高。一个人不应该用猜的方式，或者等待某位大师的宣判，才确定何时提供一个copy constructor 而何时不需要。这类问题的解答应该来自于我们自身对对象模型的了解。“

不管我们是在使用C#、Java、C++，它们都是面相对象的编程语言，因此底层的原理都会又些相似性，特别是内存布局上。我也是抱着这种用C++内存布局去理解其他语言的心态去学习和研究这部分内容的。

### 对象的内存布局

一个普通的class，有成员变量、成员函数，静态变量，静态函数，关于它们我们可以话一张图，拿一个简单的Point来举例：

		class Point

		成员变量 float x

		成员函数 int PointCount()

		静态变量 static int sMaxCount

		静态函数 static int GetMaxCount()

假如我们实例化一个Point，即 Point * pt = new Point，Point的内存中为：

		float x

没错，内存中只有一个浮点数变量的空间大小，那么其他的包括成员函数、静态变量、静态函数都不在Point实例内存中，它们在哪呢？

#### 它们被编译器编写在了代码段和数据段中，可以被所有Point实例共享的内存使用。

我们知道一个可执行程序的内存分布，分为数据段、代码段、栈段，这三个基本都是静态不会被改变的空间段，其他还有中断表、堆内存空间等。

class的成员函数、静态函数无论是否public还是private修饰，都会被放入代码段中，静态变量则被放入数据段中无论是否public还是private，而成员变量例如Point中的x，无论它是public还是private都会被放入动态内存分配的内存块中。

#### 当class有继承和多态后则有所不同

当class有了继承后，通常都会有多态出现，即虚函数。让我们来举个例子说明：

``` c++
class Point
{
public:
	float x;
	virtual int PointCount();
	virtual void PrintPoint();
}

class Point2D : public Point
{
public:
	float y;
	virtual int PointCount();
	virtual void PrintPoint();
}

Point pt = new Point2D();
```

加上继承和多态后，内存布局就有所变化，由于基类和子类都有虚函数，子类重载了函数后，我们在内存中就需要有一张表来存放所有虚函数，以便正确调用。

如上Point和Point2D的关系，可以将一个Point2D实例内存看作如下结构：

		- virtual table 虚表地址 -------->   虚表空间
											- PointCount()地址
											- PrintPoint()地址
		- x
		- y

和普通class不同的是，当我们有了多态后，我们的一个实例内存中除了数据外，还多了一个变量指向这个类的虚表空间，这个虚表空间已经被编译器编写在了数据段中，是一个静态的并且专门为Point2D制定的空间，这个空间中存放着指向类中所有虚函数地址，空间不会随着多个实例化而增多因为它只有一个，但每个Point2D实例的虚表指针指向着它（Point实例也是类似的内存布局）。

这里不得不讲一下struct和class的区别，其实它在不同语言中的语义和用途不太一样，如果是在C++中可能大部分struct都是用来兼容C的，但在其他语言则不同。如在

编译器编译中很多时候都会将许多我们看来是动态的访问变为静态，例如部分强制转换、前面Point中的静态函数（程序在执行时就会直接跳到代码段的GetMaxCount这个函数的地址上而不会通过实例内存去找）、Templete会在编译期就将代码和指令生成完毕，以及一些编译器对代码的优化会直接将某个公式计算好以数字的形式呈现在机器码里，还有很多排错机制，其实编译器帮我们干了很多本该我们需要检查和手动指定的工作。









