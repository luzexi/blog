---
layout: post
status: publish
published: false
title: 《Unity3D高级编程之进阶主程》第六章，网络层(二)
description: "unity3d 高级编程 主程 network tcp udp"
excerpt_separator: ===
tags:
- 书籍著作
- Unity3D
- 前端技术
---

### Unity3D如何实现Socket TCP长连接。

长连接，需要处理几种情况：
1.建立连接
2.接收的数据块判定
3.断线检测
4.发送数据合并
5.接收数据缓冲
6.线程死锁

因为TCP本身已经有数据包可靠性确认，以及丢包重发机制，数据包的大小也没有限时，所以在TCP的连接中不需要我们再做包体的校验，切割包体，以及重发数据包了。省掉了很大一部分麻烦。
我们只需要做的就是建立连接，发送，以及接收。
但是，如果不对发送数据进行合并，就会有很多小的数据分批发送，导致发送效率低下。所以我们下文中会提到关于发送合并的问题。

(API库介绍)
c#的.net库就有socket的提供，所以我们从c#的.net库讲起把。
理论上你不会去用阻塞方式连接和接收，因为你不会让你的游戏卡住不动，甚至崩溃。所以连接，接受，断开，都是异步的线程操作。
BeginConnect，开始连接
BeginReceive，开始接收信息
BeginDisconnect，开始断开
Disconnect(Boolean)，立刻断开连接

前三个都是异步，后一个是阻塞。最后一个阻塞式可以在游戏退出事件时调用，但APP没有退出事件，所以最后一个一般都在Unity3D Eitor下或者windows版本上调用。

(线程锁)
显而易见，基本上所有的操作都是线程级别的，Unity3D是在主线程上运作的，所以这里就涉及到了主线程和子线程的资源线程锁的问题。当主线程以及各个自线程在运作时，都需要某个内存块，或者资源时，就会同时去读取或者写入资源，这时就会造成死锁的情况。因此在调用有冲突的资源时，需要做锁的操作。

例如
接收线程接收到网络数据后将数据推进队列
lock(obj){
	mQueue.Push(data);
}
或者主线程在读取网络数据时的锁操作
Lock(obj){
	data = mQueue.Pop();
}

每次对线程共享的资源进行操作时，都需要先进行锁确认的操作，以避免线程争夺资源而造成死锁。

(缓冲队列的运用)
主线程要读取接收好的信息来处理调用相关的句柄，而子线程要接收信息，他们两个怎么配合呢？接收线程会源源不断的接收到数据，而且同一时间接收到的数据会有很多个，所以需要用队列来进行存储和缓冲, 这样就有了队列的想法。负责接收的子线程把接收好的网络数据放入队列，主线程去检查队列里是否有数据。有的话取一个出来处理下，没有的话继续轮训等待。

比如主线程会每帧检查一下是否有收到信息，收到就处理下。当没有信息来的时候子线程是子线程上阻塞等待的直到有消息过来才会调用接收消息的回调函数。

例如下面伪代码
/////////////////////////////////////////////////////////
//接收线程等待接收数据并推入队列
try
{
  socket.BeginReceive( Receive_Callback );
}
catch (Exception e)
{
    Log(LogerType.ERROR, e.StackTrace);
    DisConnect();
}

void Receive_CallBack(IAsyncResult  _result)
{
	PushNetworkData(_result); //将数据推入队列
	Receive();	//继续接收数据消息
}

///////////////////////////////////////////////////////////////
//主线程处理数据队列里的数据

void Update()
{
	While(   (data = PopNetworkData() )!= null)
	{
		DealNetworkData(data);
}
}

上面的伪代码中，首先有子线程的等待接收数据，接收到以后就立即将数据推入队列。另一面，主线程一直在轮询是否有已经接收到的网络数据，如果有就立即全部处理完。

(双队列结构)
这里介绍一下双队列数据结构。它能增加些许多线程中队列的读写效率。
双队列是一种高效的内存数据结构，在多线程编程中，能保证生产者线程的写入和消费者的读出尽量做到最低的影响，避免了共享队列的锁开销。

具体什么意思呢？其实很简单的。
多个线程都需要对队列读写，接收数据的网络线程会将数据写入队列，而处理数据的主线程会读取队列并删除顶头的一个，两者都会读写队列，导致资源争夺。加入了线程锁的机制后，仍然没能很好的解决两个线程同时操作一个队列的问题。例如假如处理数据的主线程需要花很久的时间去处理网络数据，这时接收数据的线程就卡住了。
现在我们用双队列的形式来让线程处理队列时解放出来，各自处理调用各自的队列处理。当接收数据线程接收到数据时，直接推入接收数据的队列，当处理数据的线程轮询时，先将接收数据的队列拷贝到处理数据的队列中，再进行处理，这样就解放了两边的冲突时间了，各自只要处理自己的队列就可以了。

如下伪代码
/////////////////////////////////////////////
//接收数据线程
void Receive_CallBack(Data _result)
{
	Pushdata(_result);
}

/////////////////////////////////////////
//处理数据的主线程
	void SwitchQueue()
	{
		lock(obj)
		{
			Swap(receiveQueue, produceQueue);
}
}

void Update()
{
	SwitchQueue();
	while( (data = PopQueue()) != null )
	{
		Deal_with_network_data(data);
}
}

当主线程需要处理数据时，先切换队列，防止对队列占用过多时间，切换完毕后，再对队列中的全部数据进行处理。这样一来，锁的时间变短了，原本要在处理期间全程上锁导致其他线程无法使用，现在只在切换那一瞬间锁上资源，其他时间各线程都能顺畅得各自做自己的工作，大大提高了锁的效率。

(发送数据)
我们发送数据时需要队列来做缓冲，以及合并操作，因为发送的数据如果太大的话，会导致发送效率很差，万一其中一个数据发送失败，TCP就会全盘否定这次发送的内容，而将所有的包都重新发送。相反，另一个极端是，如果一个个发送，一个发送确认完毕后再发送下一个，效率也会很差，因为太慢了，通常MMO游戏在战斗时，发送的数据包数量都在每秒100-200个左右，加入发送过慢，将导致巨大的延迟。

我们需要建立发送缓冲来保证发送的有序和高效，这样就有了发送队列和发送数据的合并。每次当你调用发送接口时会把数据包塞入发送队列，发送程序就开始轮训是否有需要发送的信息在队列里，有的话就发送，没有的话就继续轮训等待。

发送时，合并队列里的所有数据包，准备一次性发送多个数据包以提高效率。不过，我们需要对这种合并做个限制，倘若数据包太大，也会导致效率差，因为发送过程中，只要丢失一个数据就要全盘重新发送，如果数据包很大的话，发送本来就很缓慢的情况下，又重新整体重新发送，就会使得发送效率大大降低。
所以，我们既要合并数据包，又要让数据包不能那么大，这样才能保证发送的效率比较高。比如，我们做个合并后的数据包大小，不得超过10K。这样每个数据包大小都处于10K以下的大小，除非单个包大于10K就让他单独发送，且每次发送包含了多个数据包，这样发送效率就有了一定的保证。

(协议数据定义)
那么协议数据怎么定义呢？
什么是协议，简单来说就是客户端和服务器端商讨后达成一个对数据格式的协定，比如，两边都用Json格式的协议来传输数据。这样两边在发送和收到数据时，都能按照一定的规则识别数据了。

我们在TCP socket里也一样需要对协议进行商讨。在商讨协议的过程中，关键点是什么呢？
1.	客户端和服务器都能接受的格式。并不是所有的格式都适合，选择中意的，前后端都能接受的协议格式才是最重要的，因为合作最重要，个人力量和一个协议格式的力量与团体来说都是渺小的。
2.	数据包体大小最小化。尽可能的减少包体大小，选择一些能节省包大小空间的格式，比如google protocol buffer。或者对包主体部分使用压缩算法，我不建议只加压缩算法而不改变协议本身，因为会导致对压缩算法过度依赖而省略了协议本身的浪费空间，比如你用了压缩算法后发现xml或json格式的协议也还过得去就不再更改协议本身了，这样就会导致后期数据量大时数据包变得很大很沉重，传输效率降低。但很多老项目和一些为了加快速度而不去更改协议的项目情况时常发生，所以只启用压缩算法而不改变协议本身很多时候也是无奈之举。
3.	需要有一定的校验能力。当数据包体不完整时，或者本身包体后面连接着另外的数据包时，能够有校验能力，和识别完整包体范围的能力。很多时候我们在传输数据的时候，收到的并不是一个完整的包体，或者因为网络关系，收到了错误的，甚至被攥改过的数据，我们要有能力去校验他们。
4.	加密。为了保证网络数据包不被篡改和查看，导致外挂破坏整个游戏平衡，我们需要对发送的网络数据包中的主体部分进行加密。加密算法很多，这里不一一介绍，最简单方式就是对数据做异或处理，发送时做异或处理一次，收到时做一次异或处理，这样就能简单加密解密数据。当然这种方式比较单板，因为密钥Key是同一个，而且密钥KEY会暴露在客户端会被查看到，于是非对称加密可能会是加密的首选，这样前后端两边的密钥Key不同且各自保存，当后端密钥泄漏时，也可以随时替换。

我们这里主要聊一下网络数据包的校验能力，各种包体的协议格式下面的章节中会具体讲解，加密也同样会在最后的几节部分做出详细的介绍。

在接收数据的时候，有时候会是一个不完整的包，或者一个包后面跟着另一段不完整的包，怎么办，怎么识别哪里是头，哪里是尾？嗯，这就有了数据格式的意义，通常的长连接数据格式，以头和数据块，两部分组成，比如头用4个字节组成，这4个字节是数据块得大小size，这样后面数据块得大小就能知道了，因为每次拿到网络数据的时候我先取4个字节，然后就知道了后面数据块大小，再读取size大小的数据块，这样就拿到了数据信息。
再做的复杂点，可以分成，头、固定标识信息、数据块，三个部分。头，存储包体大小信息；标识信息，存储例如句柄编号，序列号，特殊命令编号，校验码等的标识信息；数据块，存储具体的数据信息。

TCP本身有做一些校验的工作，但为了防止数据被人为攥改、网络错误、以及逻辑本身的错误检测，我们需要做额外的校验工作。
通常方法有几种
1.	MD5校验。这种校验方式比较直接，将数据块整个用MD5散列函数生成一个校验字符串，将校验字符串保存在数据包中。当服务器收到数据包时，也做同样的操作，将数据块用MD5散列函数生成一个校验字符串，与数据包中的校验字符串进行比较，如果一致，则认为校验通过，否则就认为被人为修改过。
2.	奇偶校验。奇偶校验与MD5有点类似，只是所用的函数方法不同。对每个数据进行异或赋值成一个变量，将这个变量保存在数据包中。当服务器收到数据包时，也做同样的操作，将数据快中的数据进行异或赋值成一个变量，然后将这个变量值与数据包中的校验值进行比较，如果数据一致则认为校验正确，否则则认为数据被人攥改过。
这个校验算法类似于：
unsigned uCRC=0;//校验初始值
for(int i=0;i<DataLenth;i++) uCRC^=Data[i];
3.	CRC循环冗余校验。循环冗余校验是利用除法及余数的原理来进行错误检测的.将接收到的码组进行除法运算，如果除尽，则说明数据校验正确；如果未除尽，则表明数据被认为攥改过。
该算法过程如下：
1.	前后端约定一个除数。
2.	将数据块用除数取余。
3.	将余数保存在数据包中。
4.	服务器收到数据后，将余数和数据块相加，并进行取余操作。
5.	余数为0则认为校验正确，否则则认为数据被攥改过。

(断线检测)
TCP本身就是强连接，所以自身就有断线的检测机制，但是它本身的检测机制还不够用，对断线的判断不够准确，所以我们需要加强断线检测机制，让断线判断变的更加准确和即使。

为了能有效检测TCP连接是否正常，我们需要服务器和客户端达成一个协议来检测连接。我们可以取名叫心跳包协议，在心跳包协议中，每秒服务器向客户端发送一个心跳包，包内包含了服务器时间，服务器状态等信息，然后再由客户端发送给服务器一个心跳回应包，包内包含客户端的一些信息例如客户端状态，用户信息等，这样客户端和服务器就都知道连接是有响应的，当前是连接正常。
相反，倘若没有收到心跳包和心跳回应包，就表示连接存在问题了，有可能已经断开。为了规避一些时候网络的波动，我们可以设置一个有效判断断开连接的时间间隔，比如，10秒内没有收到心跳包和心跳回应包，就表示连接已经断开，这时服务器和客户端主动断开连接，再根据游戏的逻辑寻求再次连接。

这就是TCP长连接程序的发送和接收数据的流程。但知道流程可能还不够，网络层可以说是最最独立的一个层级，我们完全可以把网络层独立出来写一个网络库。嗯，你需要自己试试，再参考下我的代码  https://github.com/luzexi/Unity3DSocket

