---
layout: post
status: publish
published: false
title: 《Unity3D高级编程之进阶主程》第六章，网络层(四) - 实现HTTP
description: "unity3d 高级编程 主程 network tcp udp http"
excerpt_separator: ===
tags:
- 书籍著作
- Unity3D
- 前端技术
---

七．  Unity3D的HTTP连接如何实现
短连接可以用.NET库来写，也可以用U3D的内置API的WWW来写。差别不是很大，大部分.NET库可以实现的，WWW也同样能够实现。区别主要还是WWW用协程做，.NET库用线程做，协程方便点，不用做锁的操作，线程麻烦点，要锁要队列要缓存。另外WWW里面已经实现了IP6转换，而使用 .Net则还需要自己解析IP6地址。

其实两边都要缓存和队列，如果没有缓存和队列，当数据量大时会出现很多问题。所以缓存机制在网络层是不可或缺的。

www也有post和get两种方式：
GET:
public WWW(string url); 
POST:
public WWW(string url, WWWForm form); 或
public WWW(string url, byte[] postData);
有时你需要发送head信息可以用
public WWW(string url, byte[] postData, Dictionary<string,string> headers);

最简单的就是设计个类，比如建个名称为HTTPRequest的类，每次请求服务器都调用这个类的方法来处理一个请求的操作。把地址，参数，回调传进去，等待服务器相应和回调。

短连接接口少，大概就是请求接口（包括，地址，参数，参数里包括，GET和POST，HEAD和BODY），回调接口，发生错误接口（错误包括超时，无响应，404，错误页面等）。只要做好这几个接口的封装基本就能搞定单个HTTP请求的组件需求。

接下来我们详细讲解下HTTP实现的几个关键点和难点，以及相关注意事项。这里以WWW为API来实现，核心部分的通信。

（基本发送与接收）
使用WWW发送接收很方便，可以用协程也可以在逻辑更新中进行判断收发过程。
在协程中不太可控，因为协程结束时随着函数调用结束而结束的，而我们需要时常暂停，继续等操作，协程确实不太方便。所以一般我都是把WWW的收发判断移到逻辑更新中Update里去的，这样做容易理解，也容易实现，更容易掌控。

下面是WWW的收发过程：
1.建立实例开始连接和发送请求www = new WWW( URL )，以及设置好，这次请求回应的回调句柄。
2.判断是否完成连接和发送请求，用www.isDone判断是否完成连接与发送。

伪码如下：
void StartRequest(string url, Callback _callback)
{
    www = new WWW(url);
    Callback =  _callback;
}

void Update()
{
    if(www != null)
    {
        if(www.isDone)
        {
            ProcessResponse(www);
            www.Despot();
            www = null;
}
}
}
3.处理数据，先判断有错误存在，如果不是则对数据进行处理，HTTP回应的数据都是文本数据，比如Json格式的，Xml格式的，等等。对数据进行解析后变为具体的类实例，再传给相应的函数句柄进行调用。所以这里数据格式协议也是关键。

void ProcessResponse(WWW _www)
{
    if(_www.error != null)
    {
        NetworkErrorReport(_www.error);
        return;
}
CallbackResponse(_www.text);
}

以上就是用WWW做HTTP请求的基本步骤。看似简单的连接，发送，接收过程，里面需要我们做的事情也不少。这里主要是针对，游戏逻辑中，大量多次，频繁发送HTTP请求的问题的延伸和提出的解决方案。

（多次或者连续发送HTTP请求引起的问题）
多次或者连续请求HTTP是很常见的操作，比如客户端向服务器请求角色信息，并且请求军团信息，并且请求每日任务信息，然后再显示主界面。这种连续的多次的请求HTTP，会同时触发请求线程想服务器做请求操作，而得到服务器返回时，却不知道哪个在先哪个在后，例如军团信息先得到响应，然后再是每日任务信息得到了响应，再是角色信息得到了响应，因为是多个线程发起的多个连接，所以并不能确定响应的顺序也是同请求的顺序是一样的，导致在显示主界面时需要花更多的逻辑去判断请求信息是否得到回应。
所以客户端更希望是，在多次请求发出后，收到的响应也是按原来请求的顺序响应的。所以我主张只开一个线程处理请求，用排队的方式处理请求和响应。

伪码如下：
void RequestHttp(string url)
{
    PushRequest(url);
}
void Update()
{
    If( IsHttpFinished() )
    {
        Request  req = PopRequest();
        StartHttpRequest(req);
}
Else
{
    WaitingforRequestProcess();
}
}

从伪码看出，所有请求都会被推入到队列中，然后当请求空闲时立即开始Http请求。这样就每次都只进行一次请求，请求完毕后再进行下一次，确保了请求顺序和回应顺序的一致性。
但是问题又出来了，每次只发送一个请求，导致请求的数量太多，时间间隔太大，效率不够，当你连续请求10个的时候，由于网络延迟，有可能会等3-5秒，这是让人无法接受的。就单单一个操作造成的10个连续请求能让人等这么久，那么如果操作多了或者频繁了，请求得到的响应就更加久了，需要等待的时间也更加长，导致游戏体验非常差。当然这是在网络状况差的情况下发生，一般情况都不会有延迟感觉。那么为了优化这个问题，我们可以对多个请求进行合并，比如我现在10个请求，合并成一个，响应的结果中包含了这10个请求的数据。这样就快了不少，因为请求减少了，原本10个请求，现在变成了一个，即使网络环境差，丢包需要重发，也只要重发单个数据包就可以了，而不是每丢一次重发一个。

以上在多次连续发送HTTP请求的情况下出现的问题，下面将详细介绍这些解决方案的细节。

（发送队列和接收队列）
队列在请求和响应中起到了缓冲的作用，当连续使用HTTP请求，连续收到HTTP响应的时候，能够依次处理相应的逻辑。
因为全程是在主线程里发生的，所以并不需要线程锁之类的操作。发送时，向队列推送请求实例，在逻辑更新时，判断是否有请求在队列里，有的话推出来，做HTTP请求操作，并将请求的相关信息存起来，当得到服务器响应时，调用请求信息中的回调函数，处理回调句柄。

发送请求伪码
void RequestHttp(Request req)
{
    ListRequest.Push(req);
}

void Update()
{
    If( IsHttpFinished() )
    {
        Request  req = ListRequest.Pop();
        mCurrentRequest = req;
        StartHttpRequest(req);
}
Else
{
    If( HttpIsDone())
{
    ProcessResponse(data);
}
}
}

void ProcessResponse(Response data)
{
    If(mCurrentRequest != null
&& mCurrentRequest.Callback != null)
    {
        mCurrentRequest.Callback(data);
}
}

以上阐述了，在发送HTTP请求时的推入队列操作和在收到请求后的句柄响应操作。

（加速请求与响应，压缩和减少发送次数）
每次发送一个请求，都要等待前面的数据包的回调后才能进行，当数据包频繁发送时，就容易引起巨量延迟的问题。

怎么办？
能不能加快响应速度？可以。压缩数据，以降低宽带使用率，减少丢包时重发的数据包大小，从而提高发送和接受的速度。

具体步骤挺简单的，就是找一个压缩算法，或者压缩组件，比如zip，LZMA等，客户端在发送请求钱，对发送的数据进行压缩，当服务器收到请求数据后，先对请求数据进行解压操作，然后再提取请求数据。客户端得到服务器响应请求的时候也是同样的步骤，先对响应数据进行解压，然后再对响应数据进行解析。

压缩的操作实现起来比较简单，但能得到的效果确实不那么好。因为关键的响应速度还是靠网络环境和服务器的响应时间，宽度的问题只是次要问题，没有网络环境和服务器响应速度的支持，光减少数据大小来提高响应速度，效果肯定让人失望。

能不能减少请求次数？可以，合并数据包，让多次发送的请求数据合并到一个包内，作为一次发送的数据包，相应时也是一样，多个相应数据包在同一个相应数据包内，分别做了客户端可识别的标记。

如何实现呢？
我们以json为例，客户端请求是json格式，服务器响应也是json格式。每次请求，客户端都会发送格式给服务器，服务器收到后解析json格式数据，然后提取变量。
我们在合并请求的时候可以这么做。多个json请求格式，推入一个大的json框中，为每个json数据加一个序列号，代表请求顺序，如下：

请求1
{
    "request-order" : 1,
    "data1" : "i am text",
    "data2" : "i am num",
}

请求2
{
    "request-order" : 2,
    "book" : "i am text",
    "chat" : "i am num",
    "level" : 1，
}

请求3
{
    "request-order" : 3,
    "image" : "i am text",
    "doc" : "i am num",
}

合并后
{
    "order" : 1,
    "data":
    [
        {
            "request-order" : 1,
            "data1" : "i am text",
            "data2" : "i am num",
        }
        ,
        {
            "request-order" : 2,
            "book" : "i am text",
            "chat" : "i am num",
            "level" : 1;
        }
        ,
        {
            "request-order" : 3,
            "image" : "i am text",
            "doc" : "i am num",
        }
    ],
}

合并后多个json被推入数组中发送给服务器，服务器拿到数据后对data中的数据进行提取和处理，处理顺序按照request-order来做，所有响应数据都被推入同一个json实例中，并且附上请求数据中的request-order，再把整个响应数据发送给客户端，当客户端收到数据时，就可以通过request-order知道响应数据的顺序了，再按照响应顺序进行解析和回调。

相应合例子如下。

响应数据1
{
    "response-order" : 1,
    "data1" : "i am text",
    "data2" : "i am num",
    "status" : "success", 
}

响应数据2
{
    "response-order" : 2,
    "data1" : "i am text",
    "data2" : "i am num",
    "status" : "success",
}

响应数据3
{
    "response-order" : 3
    "data1" : "i am text",
    "data2" : "i am num",
    "status" : "success",
}

合并响应数据
{
    "order" : 1,
    "data":
    [
        {
            "response-order" : 1,
            "data1" : "i am text",
            "data2" : "i am num",
            "status" : "success", 
        }
        ,
        {
            "response-order" : 2,
            "data1" : "i am text",
            "data2" : "i am num",
            "status" : "success",
        }
        ,
        {
            "response-order" : 3
            "data1" : "i am text",
            "data2" : "i am num",
            "status" : "success",
        }
    ]
}

合并响应数据后，客户端先提取data数据中的所有数据，先进行排序，以respose-order为基准，从小到大排序，最小的次序先处理，解析，回调。

整个过程就是这样的，对多个请求进行合并后，减少了不少HTTP请求的次数，对速度的提升也是很有效果的。这里还有一些细节问题，比如多少个开始进行合并，或者多少时间内合并一次。我的经验是，为了让HTTP最大效率的得到提升，每次请求得到响应后就应该立即进行下一次HTTP请求，不要有等待合并间隔，反而减低了连接效率。但每次合并数量可以做一些限制，比如有1000个请求，我们不能统统合并了，为了保证发送数据大小和回调数据大小合适，也保证服务器不会以下为了处理1000个数据请求而当机，我们必须限制合并的个数，比如每次最多合并10个请求数据包，来保证减少连接次数减少的情况下，服务器不会在瞬间压力过大。

（其他注意点）
其他注意点，比如数据的解析与回调，针对不同格式的数据解析的步骤也是不一样的，协议后对存储的回调函数进行调用。还有当需要多服务器操作时，需要增加可选择的服务器地址。还有数据超时的重发机制，比如重发3次还是超时，再做弹框的提醒等，都是具体项目中具体应用的逻辑。
可以参考，https://github.com/luzexi/Unity3DNetwork-http


八．  网络加密与压缩
短连接可以用md5前面的所有参数作为校验依据，防止篡改。
加密方式
支持IP6以符合苹果审核，用域名
九．  优化
*短连接用www，做队列，单任务作业，合并请求和回调(每个请求有编号，对应回调)
*长连接自己写，协议可以用protobuff，缩小协议长度
*短连接用md5，token验证参数正确性
*两边加密可以把公钥写在so文件里
*长连接自己写，做队列，锁，多任务作业