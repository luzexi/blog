---
layout: post
status: publish
published: false
title: 《Unity3D高级编程之进阶主程》第四章，UI(三)
description: "unity3d 高级编程 c# 主程 算法 设计模式 动态库 底层算法"
excerpt_separator: ===
tags:
- 书籍著作
- Unity3D
- 前端技术
---

# 第四章，UI(三)

前文回顾 [UI(一)](http://luzexi.com/2018/07/25/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-UI1.html)

前文回顾 [UI(二)]()


### UGUI源码剖析

UGUI的源码是Unity3D官方公开的，这里我们来剖析一下UGUI在Unity2017中的源码部分。

![ugui文件夹](/assets/book/4/ugui1.png)

这是UGUI内核源码的文件夹结构图。从图中可以看出，它把UGUI分成了，三块，输入事件，动画，核心渲染。其中动画部分相对比较简单，用了tween补间动画的形式，对颜色，位置，大小进行了渐进操作。我们重点来看看输入事件和核心渲染两块。

### 输入事件源码

输入事件源码的整个文件结构图如下：

![ugui事件文件夹结构](/assets/book/4/ugui2.png)

从图中文件夹结构可以看出他有四部分构成，事件数据类，输入事件捕获类，射线碰撞类，事件逻辑处理及回调类。

###### 事件数据类

事件数据类部分相对比较简单，主要定义和存储了，事件发生时的点位，事件对应的物体，事件的位移大小，事件的类型，以及事件的设备类型等。

{% highlight c# %}

public class PointerEventData : BaseEventData
{
    public GameObject pointerEnter { get; set; }

    // The object that received OnPointerDown
    private GameObject m_PointerPress;
    // The object last received OnPointerDown
    public GameObject lastPress { get; private set; }
    // The object that the press happened on even if it can not handle the press event
    public GameObject rawPointerPress { get; set; }
    // The object that received OnDrag
    public GameObject pointerDrag { get; set; }

    public RaycastResult pointerCurrentRaycast { get; set; }
    public RaycastResult pointerPressRaycast { get; set; }

    public List<GameObject> hovered = new List<GameObject>();

    public bool eligibleForClick { get; set; }

    public int pointerId { get; set; }

    // Current position of the mouse or touch event
    public Vector2 position { get; set; }
    // Delta since last update
    public Vector2 delta { get; set; }
    // Position of the press event
    public Vector2 pressPosition { get; set; }
    // World-space position where a ray cast into the screen hits something
    [Obsolete("Use either pointerCurrentRaycast.worldPosition or pointerPressRaycast.worldPosition")]
    public Vector3 worldPosition { get; set; }
    // World-space normal where a ray cast into the screen hits something
    [Obsolete("Use either pointerCurrentRaycast.worldNormal or pointerPressRaycast.worldNormal")]
    public Vector3 worldNormal { get; set; }
    // The last time a click event was sent out (used for double-clicks)
    public float clickTime { get; set; }
    // Number of clicks in a row. 2 for a double-click for example.
    public int clickCount { get; set; }

    public Vector2 scrollDelta { get; set; }
    public bool useDragThreshold { get; set; }
    public bool dragging { get; set; }

    public InputButton button { get; set; }
}

{% endhighlight %}

事件数据类，主要用途是在各种事件发生时，或者两个前后事件发生后，相应数据的存储。为事件逻辑做好数据工作。数据类的主要核心是 PointerEventData 类，它存储了大部分的逻辑需要的数据，包括按下时的位置，松开与按下的时间差，拖动的位移差等等，几乎承载了所有数据。

###### 输入事件捕获源码



###### 射线碰撞类源码

射线检测类部分主要做的工作是从摄像头指定的位置上，做射线碰撞检测，并获取碰撞结果。再把结果返回给事件处理逻辑类，由事件处理逻辑处理事件。

射线检测部分总共就3个类，里面也就几十行代码，主要还是 2D 碰撞检测 和 3D碰撞检测的一点点小小区别。用 Physics2D 还是 Physics 的区别，以及在2D碰撞结果里预留了2D的层级次序以便在后面的碰撞结果排序时，以这个层级次序为依据做排序，而3D的碰撞检测结果则是以距离大小为依据排序的。

主要的数据结构是 RaycastResult 类，这里承载了所有碰撞检测结果的依据。包括了距离，世界点位，屏幕点位，2D层级次序，碰撞物体等。为后面事件处理提供了数据上的依据。

###### 事件逻辑处理

事件主逻辑处理部分看似复杂，主要的逻辑都集中在 EventSystem 类中，其他都是对它起辅助作用的。

比如，EventInterfaces，EventTrigger，EventTriggerType 都是定义事件回调函数，而 ExecuteEvents 是执行事件回调的。RaycasterManager 是管理碰撞测试的。这些类都是几十行代码就完结了的，并没有多少东西在里面，它们的主要作用是为 EventSystem 主逻辑服务。

EventSystem 主逻辑里也并不复杂总，共300行代码基本上都在处理由射线碰撞检测后引起的各类事件，判断事件是否成立，成立则发起事件回调，不成立则继续轮训检查，等待相关事件的发生。

EventSystem 是事件处理模块中唯一继承 MonoBehavior 并且有在 Update 帧循环中做轮训的。也就是说，所有UI事件的发生都是通过 EventSystem 轮训检查到的。所以我们说他时重点，但也并不复杂，因为架构师在架构时，已经将它们各自的职能分的很清楚了，所以我们看起来也并没有那么难。

### 渲染核心源码



### NGUI的初级和高级使用详解

### NGUI源码剖析

