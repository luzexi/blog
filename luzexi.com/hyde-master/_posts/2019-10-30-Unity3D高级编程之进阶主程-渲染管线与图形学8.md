---
layout: post
status: publish
published: false
title: 《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(三) - 渲染原理与知识3
description: "unity3d 高级编程 主程 shader 漫反射 镜面反射 自发光 球面反射"
excerpt_separator: ===
tags:
- 书籍著作
- Unity3D
- 前端技术
---


### GPU Instancing 的来龙去脉

GPU Instancing 翻译过来是GPU多实例化渲染，它其实是GPU的一个功能，Unity3D将它变得更简单实用，在OpenGL和DirectX里多实例化的渲染都有相应的接口。

前面讲过一些关于Unity3D的动态合批(Dynamic batching)与静态合批(Static batching)的功能，GPU Instancing其实与他们一样都是为了减少Drawcall而存在。

有了动态合批和静态合批为什么还需要 GPU Instancing呢，究竟他们之间有什么区别呢，我们不妨来简单回顾一下Unity3D动态合批(Dynamic batching)与静态合批(Static batching)。

开启动态合批(Dynamic batching)时，Unity3D会检测视野范围内的非动画物体，如果符合合批条件的就进行合批操作，也就是将他们的网格合并后与材质球一并扔给GPU去绘制。

需要符合什么条件呢：

		1，900个顶点以下的模型。

		2，如果我们使用了顶点坐标，法线，UV，那么就只能最多300个顶点。

		3，如果我们使用了UV0，UV1，和切线，又更少了，只能最多150个顶点。

		4，如果两个模型缩放大小不同，不能被合批的，即模型之间的缩放必须一致。

		5，如果是不同的材质球实例同样不能被合批，即使他们一模一样。即材质球属性不能被修改，材质球对象实例必须是同一个。

		6，如果他们有lightmap的数据，必须是相同的才有机会合批。

		7，多个pass的Shader是绝对不会被合批。

		8，延迟渲染是无法被合批。

条件很苛刻，一不小心就无法符合合并条件。

动态合批(Dynamic batching)这个功能的目标是以最小的代价合并小型网格模型，减少Drawcall调用。

很多人会想既然合并了为什么不把所有的模型都合并呢，这样不是更省事。如果把各种情况的中大型网格都合并进来，就需要消耗巨大的CPU资源，而且在摄像机移动过程中，每帧都要进行合并网格的消耗，CPU算力消耗太大，得不偿失。于是Unity3D就对这种极其消耗CPU算力的功能做了如此多的的限制，就是为了性价比更高。

开启静态合批(Static batching)时，Unity3D会在离线状态下生成合并网格，所有被标记为静态物体的模型，只要拥有相同实例的材质球都会被一并合并成网格。

静态合批有诸多有点，但也存在不少缺陷。首先静态物体不能被移动，也只有这样离线状态下生成网格才有效，其次这样生成的离线网格导致网格数据量是翻倍的，内存占用量扩大。

### High Dynamic Range 是什么？

### 多重采样(Multisampling)与反走样(Antialiasing)

		Quality Settings
		
		AntiAliasing	This sets the level of antialiasing that will be used. The options are 2x, 4x and 8x multi-sampling.

### 颜色缓存与高清屏意味着什么

### 2幂次纹理的读取与纹理压缩

### 闪烁的根源：坐标系变化后的z精度问题

### 什么是Overdraw

### 什么是卷积，卷积对后渲染的意义是什么

### 什么是PBR，现在为什么对PBR如此重视

PBR管线不是仅仅是为了画面上的效果，更为了大量重复工作规定了规范可流水线操作。

### 什么是渲染管线的升级，为什么要升级渲染管线

### SPR(Scriptable Render Pipeline)可编程管线，什么是高清管线HDRP(High-Definition Rendering Pipeline)，Unity3D中的轻量渲染管线LWRP与传统管线有什么差别，以及最近升级的通用管线

### 着色器编译原理

### 为什么要用CG来写Shader而不是其他的

