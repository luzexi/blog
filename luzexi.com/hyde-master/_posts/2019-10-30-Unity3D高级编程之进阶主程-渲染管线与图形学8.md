---
layout: post
status: publish
published: false
title: 《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(三) - 渲染原理与知识3
description: "unity3d 高级编程 主程 shader 漫反射 镜面反射 自发光 球面反射"
excerpt_separator: ===
tags:
- 书籍著作
- Unity3D
- 前端技术
---

### GPU Instancing 的来龙去脉

GPU Instancing 初次听到这个名词时还有点疑惑，其实翻译过来应该是GPU多实例化渲染，它其实是GPU的一个功能，Unity3D将它变得更简单实用，在OpenGL和DirectX里多实例化的渲染都有相应的接口。

前面讲过一些关于Unity3D的动态合批(Dynamic batching)与静态合批(Static batching)的功能，GPU Instancing其实与他们一样都是为了减少Drawcall而存在。

有了动态合批和静态合批为什么还需要 GPU Instancing呢，究竟他们之间有什么区别呢，我们不妨来简单回顾一下Unity3D动态合批(Dynamic batching)与静态合批(Static batching)。

开启动态合批(Dynamic batching)时，Unity3D会检测视野范围内的非动画物体(怎么检测的呢，就是通过遍历所有渲染模型，计算包围盒在视锥体中的位置，如果完全不在视锥体中则抛弃)，如果符合合批条件的就进行合批操作，就是将他们的网格合并后与材质球一并扔给GPU去绘制。

需要符合什么条件呢：

		1，900个顶点以下的模型。

		2，如果我们使用了顶点坐标，法线，UV，那么就只能最多300个顶点。

		3，如果我们使用了UV0，UV1，和切线，又更少了，只能最多150个顶点。

		4，如果两个模型缩放大小不同，不能被合批的，即模型之间的缩放必须一致。

		5，如果是不同的材质球实例同样不能被合批，即使他们一模一样。即材质球属性不能被修改，材质球对象实例必须是同一个。

		6，如果他们有lightmap的数据，必须是相同的才有机会合批。

		7，多个pass的Shader是绝对不会被合批。

		8，延迟渲染是无法被合批。

条件比较苛刻，一不小心就无法达到合并条件。为什么它要使用这么苛刻的条件呢，我们来了解下设计动态合批这个功能的意图。

动态合批(Dynamic batching)这个功能的目标是以最小的代价合并小型网格模型，减少Drawcall调用。

很多人会想既然合并了为什么不把所有的模型都合并呢，这样不是更省事。如果把各种情况的中大型网格都合并进来，就需要消耗巨大的CPU资源，而且在摄像机移动过程中，每帧都要进行合并网格的消耗，CPU算力消耗太大，得不偿失。于是Unity3D就对这种极其消耗CPU算力的功能做了如此多的的限制，就是为了性价比更高。

与动态合批不同，开启静态合批(Static batching)时，Unity3D会在离线状态下就生成合并网格，所有被标记为静态物体的模型，只要拥有相同实例的材质球都会被一并合并成网格。

静态合批有诸多优点，但也存在不少弊端。被合批的是静态物体，它们是不能被移动旋转和缩放的，也只有这样我们在离线状态下生成的网格才是有效的（离线的网格数据不需要重新计算），生成的离线数据被放在Vertex buffer和Index buffer中。

静态合批生成的离线网格将导致存放在内存的网格数据量剧增，因为在静态合批中每个模型都会独立生成一份网格数据，无论他们所使用的网格是否相同，也就是说场景中有多少个静态模型就有多少个网格，与原本只需要一个网格就能渲染所有相同模型的情况不一样了。

好处是静态合批后同一实例(实例必须相同，因为材质球的参数不能变)材质调用Drawcall的数量合并了，另外合批也不会额外消耗CPU算力因为它们是在离线时生成的合批数据(也就是网格数据)，在实时渲染时如果该模型在视锥体范围内，那些早就被生成的网格将被整体提交(整体网格过大时则会导致CPU和GPU的带宽消耗过大)，而三角形索引则被部分提取出来合并后提交，最后再一并发送给GPU进行渲染。

简而言之，动态合批为了平衡CPU消耗和GPU性能优化，将实时合批条件限制在比较狭窄的范围内。静态合批则牺牲了大量的内存和带宽，以使得合批工作能够快速有效的进行。

### Texture Array

### Graphics Command Buffers

### High Dynamic Range 是什么？

### 多重采样(Multisampling)与反走样(Antialiasing)

		Quality Settings
		
		AntiAliasing	This sets the level of antialiasing that will be used. The options are 2x, 4x and 8x multi-sampling.

### 闪烁的根源：坐标系变化后的z精度问题

### 什么是Overdraw，怎么解决Overdraw问题

### 什么是卷积，卷积对后渲染的作用

### 什么是PBR，现在为什么对PBR如此重视

PBR管线不是仅仅是为了画面上的效果，更为了大量重复工作规定了规范可流水线操作。

### 什么是渲染管线的升级，为什么要升级渲染管线

### SPR(Scriptable Render Pipeline)可编程管线，什么是高清管线HDRP(High-Definition Rendering Pipeline)，Unity3D中的轻量渲染管线LWRP与传统管线有什么差别，以及最近升级的通用管线

### 着色器编译过程

### 2幂次纹理的读取与纹理压缩

<!-- ### 为什么要用CG来写Shader而不是其他的 -->

