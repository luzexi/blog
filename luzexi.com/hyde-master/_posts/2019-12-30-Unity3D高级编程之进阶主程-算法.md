---
layout: post
status: publish
published: false
title: 《Unity3D高级编程之进阶主程》 第一章，程序逻辑优化技巧
description: "unity3d 高级编程 主程 算法"
excerpt_separator: ===
tags:
- 书籍著作
- Unity3D
- 前端技术
---

我们常常说起优化，总是不免想到渲染，Drawcall，Overdraw，引擎算法，底层组件，以及大型的整套的解决方案等，却很少关注普通业务逻辑中问题，其实不只是算法能大幅度提高业务逻辑的效率，普普通通的业务代码也同样可以有质的飞越。

一行普通的代码，高手写和普通人写可能就会不一样，优秀程序员常关注代码对性能的影响，普通人只关注是否能完成功能，这样日积月累代码质量就会形成差距。这节我们就来讲讲，在我们平时的业务逻辑编程中，我们应该怎么去优化这些不起眼但却蕴含着巨大潜力的性能问题。

### 使用List和Dictionary时提高效率

前面几节我们讲解了List、Dictionary的源码，知道了它的实质都是数组，Dictionary有两个数组，一个数组存索引一个数组存数据，我们遍历List和Dictionary都是在遍历数组。

了解底层的逻辑有助于我们更好的运用的它们，比如当我们使用List插入时，我们知道其实就是向数组中写入元素并遍历其后面的数据依次向后移动的过程。了解了这些，每次当我们使用List的Insert时都会注意一些。还有Contains函数，它是一个以遍历形式来寻找结果的函数，每次使用它都会从头到尾遍历一下直到寻找到结果，Remove也是一样，都是以遍历的形式存在。如果我们在代码中使用它们的频率比较高，就会带来很多不必要的性能消耗，这是我们很多人常常不注意的。我们常常因为不了解或图方便而使用了这些接口而并没有考虑它们带来的性能损耗。

Dictionary也有诸多问题，首先它是一个使用哈希冲突解决关键字的字典组件，因此哈希值与容器中数组的映射关键和GetHashCode获取哈希值的函数比较关键。哈希冲突与数组大小有很大关系，数组越大哈希冲突率就越小，因此我们在写程序时应该注意设置Dictionary的初始大小，尽量设置一个合理的大小，而不是什么不做，任由它自己扩容，这不但让哈希冲突变得频繁，而且扩容时数组的回收也加重了GC的负担。除了之外，在C#中所有类都继承自Object类，Dictionary使用Object的GetHashCode来获取类实例的哈希值，而GetHashCode是用算法将内存地址转化为哈希值的过程，因此我们可以认为它只是一个算法，并没有做任何值做缓存，每次调用它都会计算一次哈希值，这是比较隐形的性能损耗。如果频繁使用GetHasCode作为关键字来提取Value，那么我们应该关注下GetHashCode的算力损耗，是否可以用唯一ID的方式来代替GetHashCode算法。

### 提高缓存命中率

Struct和Class的区别也常常被人遗忘，Struct结构是值类型，与Class不同的是它传递时并不是靠引用(指针)形式来传递，而是直接内存拷贝。如果我们稍不注意也会让Struct损耗大量内存拷贝带来的CPU损耗。在编程中它的好处是让数组内存连续，一个Struct数组是内存连续的，而一个Class数组则只是引用(指针)变量空间连续，这是大不同的。一个连续的内存空间，在CPU缓存中可以提高命中率，而非连续空间的内存则缓存的命中率会更低，CPU缓存命中率的高低很影响存取效率。也会有些极端的利用连续空间提高CPU缓存命中率的做法，把所有的数值都集合起来用数组的形式存放，而每个对象上只存一个索引，存取都通过索引和数组来操作。我们来看一个例子就知道是怎么回事。

``` c#
class A
{
	public int a;
	public float b;
	public bool c;
}

class B
{
	public int index;
}

class C
{
	public static int[] a = new int{2, 3, 5, 6};
	public static float[] b = new float{2.1f, 3.4f, 1.5f, 5.4f};
	public static bool[] c = new bool{false, true, false, true};
}

public void main()
{
	A[] arrayA = new A[3]{new A(), new A(), new A()};

	print("A class this is a {0} b {1} c {3}",Aa.a, Aa.ba, Aa.c);
	
	Class B = new B()
	B.index = 2;

	print("B class this is a {0} b {1} c {3}",C.a[B.index], C.b[B.index], C.c[B.index]);
}
```

上述代码中A类使用了我们非常熟悉的面向对象的编程方式，把所有属性变量都放在自己身上，数据的集合则以引用的方式存储在数组上，而B则将数据集中存储在了C类中。当两者都对数据进行存取时，A类数据的内存是分散的，因为每次分配A实例时都是从内存中找一块空地来分配，arrayA中只是引用空间连续而非内存连续，而B类的数据是连续的，因为它将所有同类的数据集中在了值类型的数组中，值类型的数组分配内存是一定是内存连续的，这样就能提高内存连续性提高CPU在存取时有大的概率让数据进入缓存后命中。我们所说的大部分的缓存机制都是将最近使用过的数据存入最近的最快的空间中，离CPU最近的就是一级和二级缓存，它们是珍贵的，我们应该充分利用他们。

### 尽可能的使用对象池

说到类实例，我们应该清楚的明白，内存分配和消耗对我们程序的影响，这也是提高程序效率的关键所在。我们知道我们使用的C#语言，使用垃圾回收机制，即使Unity3D在发布后将C#转为了C++也依然使用垃圾回收机制来执行分配和销毁内存。作为高级程序员，我们应该要感受到，在创建类实例时内存分配的耗时，以及垃圾回收时的艰难。尽可能的用对象池来重复利用已经创建的对象，这有助于减少内存配合时的耗时，避免大部分垃圾回收带来的CPU损耗。

以我的经验来看，最容易被我们忽略的应该是 new List<T> 这种类型的使用，我们在平时编程时会大量使用动态数组，并且随时将它抛弃，因为它太容易使用以及丢弃了。类似的 Dictionary<int,List<T>> 也是众多被忽略的内存分配消耗之一，被装进Dictionary字典中的List常被随意的丢弃(Remove掉)，没去注意它是否能被再次利用。

其实C#中一个简单的通用对象池就能解决问题，但我们常常嫌弃它，并觉得麻烦。我的编程经验中，图方便图好用的往往要付出性能损耗的代价，而性能高的代码通常都有点反人性，尽量不要被人性所驱使了，这在任何时候都是非常有用的道理。

``` C#
internal class ObjectPool<T> where T : new()
{
    private readonly Stack<T> m_Stack = new Stack<T>();
    private readonly UnityAction<T> m_ActionOnGet;
    private readonly UnityAction<T> m_ActionOnRelease;

    public int countAll { get; private set; }
    public int countActive { get { return countAll - countInactive; } }
    public int countInactive { get { return m_Stack.Count; } }

    public ObjectPool(UnityAction<T> actionOnGet, UnityAction<T> actionOnRelease)
    {
        m_ActionOnGet = actionOnGet;
        m_ActionOnRelease = actionOnRelease;
    }

    public T Get()
    {
        T element;
        if (m_Stack.Count == 0)
        {
            element = new T();
            countAll++;
        }
        else
        {
            element = m_Stack.Pop();
        }
        if (m_ActionOnGet != null)
            m_ActionOnGet(element);
        return element;
    }

    public void Release(T element)
    {
        if (m_Stack.Count > 0 && ReferenceEquals(m_Stack.Peek(), element))
            Debug.LogError("Internal error. Trying to destroy object that is already released to pool.");
        if (m_ActionOnRelease != null)
            m_ActionOnRelease(element);
        m_Stack.Push(element);
    }
}

internal static class ListPool<T>
{
    // Object pool to avoid allocations.
    private static readonly ObjectPool<List<T>> s_ListPool = new ObjectPool<List<T>>(null, l => l.Clear());

    public static List<T> Get()
    {
        return s_ListPool.Get();
    }

    public static void Release(List<T> toRelease)
    {
        s_ListPool.Release(toRelease);
    }
}
```

这两个对象池的类都是从Unity的UI库中提取出来的，都是非常实用的对象池工具，我们应该尽可能的利用他们。

### 计算机程序执行原理

为了能更好的理解优化的原理，我们应该再来深入些底层了解下，计算机是如何执行一个EXE文件的。

888

### 代码规范与编译优化细节

### 计算机执行程序的内存结构与执行流程

### 计算机指令执行原理，从汇编讲起，寄存器，栈与堆，函数，标记，汇编指令

### 业务逻辑的优化方法论



========================


###### 什么是算法？简单来说，所谓算法就是定义良好的计算过程，即一系列计算步骤，通过这些步骤，将输入的数据转换成输出数据。我们也可以把算法看做是一种工具，用来解决一个具有良好规格说明的计算问题。

如果说一个算法对其每一个输入实例，都能输出正确的结果并停止，则称它是正确的。一个正确的算法解决了给定的计算问题，不正确的算法对于某些输入来说，可能根本不会停止或者停止时给出了错误的结果。

然而在实际应用过程中，对不正确算法的看法其实有点不同，如果这些算法的错误率可以得到控制的话，它们有时也是有用的，例如我们写出了一个很高效的算法使得鸡蛋很快煮熟，但这个算法有概率将鸡蛋煮烂，如果能将这个煮烂的概率降低到我们可以接受的程度，鸡蛋损失的成本是我们能接受的范围，在实际应用中是可行的。

实际上每一种计算机编程问题都有很多种解决方案，这些解决方案可以是简单粗暴的数数，也可以是精心设计的步骤或流程。

如果计算机无限快，那么对于某个问题来说，任何一个解决它的算法都是可以的。你很可能希望自己的实现能够符合良好的软件工程实践要求，但往往最后都会采用最容易实现的方法。这是人性导致的，并不是你一个人的问题。回到现实，现代的计算机已经可以做得很快，但还不能做到无限快，它的处理速度还是有限的。存储器也是一样，现代的存储器已经做到了很便宜，但绝不会是免费的，并且依然会随着读写速度的快慢和空间大小的递增价格成指数级上涨。

如此说来计算机的算力依然是一种有限的资源，存储空间也依然是一种有限的资源，这些有限的资源必须被有效地使用，才能使得设备更快更好更流畅的运转。

###### 算法的代价和计算规模

任何算法都会在某种特定输入数据的情况下效率非常高，也就是说不同的数据环境和数据规模算法的运行时间会有很大的差异，如果只是针对特定的输入数据类型的话，我们就无法比较算法与算法之间的效率。

为了能比较算法与算法之间的优劣，也为了能让我们大体对算法的运算代价有一定的了解，预估和计算算法的空间和时间代价变得十分重要。特别是运算时间的代价，会用上界和下界渐进函数来表达，比如插入排序的运行时间介于N到N^2的之间，最大为N^2，最小为N，因为它处于N的线性函数和二次函数的范围内，也就是运行时间至少是一个常数乘上函数g(N)的时间。

如果把算法的代价表达成一个等式，则等式中有常亮，有线性运算，有幂次运算，也有指数运算，例如一个冒泡排序，我们在冒泡排序前加入对数据的检测合法性，于是就有了 T(N) = O(N) + O(N^2) 的表达式，等号右边 O(N) 为线性检测时间代价，O(N^2)为冒泡排序的时间代价，当数据规模大到O(N^2)的规模与O(N)的规模相差巨大时O(N)完全可以忽略掉，即 T(N) = O(N^2)。

###### 这种用法有助于我们略去一个等式中无关紧要的细节，把关注点集中在算法中最糟糕的部分。把最糟糕的部分提取出来加以优化就能让算法得到质的飞跃。

###### 算法的疑惑

算分首先是为了解决问题而产生的，其次是为了提高效率。为了解决各种各样纷繁复杂的问题，算法理念和分析技巧分为了很多种，这些技巧与理念都是为了将来当我们遇到问题时，可以运用并创造出新的算法的基础。



游戏中运用的大多数算法，我们再书本中都已经讲到，包括寻路算法，三角形网格构建算法，


<!-- ###### 同一种问题不同的情况下针对不同的算法有不同效率。 -->

<!-- 那么算法能帮我们解决哪些问题呢？包括数据排序，数据查找和检索，寻找最短路径，线性规划，数值算法和数论理论等等等，很多很多我们将在这节一一做以分析。 -->

参考文献:

《算法导论》



