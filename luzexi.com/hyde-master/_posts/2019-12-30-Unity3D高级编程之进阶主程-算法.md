---
layout: post
status: publish
published: false
title: 《Unity3D高级编程之进阶主程》 第一章，程序逻辑优化技巧
description: "unity3d 高级编程 主程 算法"
excerpt_separator: ===
tags:
- 书籍著作
- Unity3D
- 前端技术
---

我们常常说起优化，总是不免想到渲染，Drawcall，Overdraw，引擎算法，底层组件，以及大型的整套的解决方案等，却很少关注普通业务逻辑中问题，其实不只是算法能大幅度提高业务逻辑的效率，普普通通的业务代码也同样可以有质的飞越。

一行普通的代码，高手写和普通人写可能就会不一样，优秀程序员常关注代码对性能的影响，普通人只关注是否能完成功能，这样日积月累代码质量就会形成差距。这节我们就来讲讲，在我们平时的业务逻辑编程中，我们应该怎么去优化这些不起眼但却蕴含着巨大潜力的性能问题。

### 使用List和Dictionary时提高效率

前面几节我们讲解了List、Dictionary的源码，知道了它的实质都是数组，Dictionary有两个数组，一个数组存索引一个数组存数据，我们遍历List和Dictionary都是在遍历数组。

了解底层的逻辑有助于我们更好的运用的它们，比如当我们使用List插入时，我们知道其实就是向数组中写入元素并遍历其后面的数据依次向后移动的过程。了解了这些，每次当我们使用List的Insert时都会注意一些。还有Contains函数，它是一个以遍历形式来寻找结果的函数，每次使用它都会从头到尾遍历一下直到寻找到结果，Remove也是一样，都是以遍历的形式存在。如果我们在代码中使用它们的频率比较高，就会带来很多不必要的性能消耗，这是我们很多人常常不注意的。我们常常因为不了解或图方便而使用了这些接口而并没有考虑它们带来的性能损耗。

Dictionary也有诸多问题，首先它是一个使用哈希冲突解决关键字的字典组件，因此哈希值与容器中数组的映射关键和GetHashCode获取哈希值的函数比较关键。哈希冲突与数组大小有很大关系，数组越大哈希冲突率就越小，因此我们在写程序时应该注意设置Dictionary的初始大小，尽量设置一个合理的大小，而不是什么不做，任由它自己扩容，这不但让哈希冲突变得频繁，而且扩容时数组的回收也加重了GC的负担。除了之外，在C#中所有类都继承自Object类，Dictionary使用Object的GetHashCode来获取类实例的哈希值，而GetHashCode是用算法将内存地址转化为哈希值的过程，因此我们可以认为它只是一个算法，并没有做任何值做缓存，每次调用它都会计算一次哈希值，这是比较隐形的性能损耗。如果频繁使用GetHasCode作为关键字来提取Value，那么我们应该关注下GetHashCode的算力损耗，是否可以用唯一ID的方式来代替GetHashCode算法。

### 巧用Struct

Struct和Class的区别常常被人遗忘，Struct结构是值类型，它与Class不同的是Struct传递时并不是靠引用(指针)形式来传递而是靠复制，我们可以通俗的认为它是通过内存拷贝来实现传递(真实的情况是通过字节对齐规则循环多次复制内存)，也就是说我们在传递Struct时，其实是在不断的克隆数据。

``` c#
struct A
{
	public int gold;
}

public void main()
{
	A a = new A();
	a.gold = 1;
	A b = a;
	b.gold = 2;
}
```

我们来简单举个例子，上述Struct中有一个整数变量gold，实例a的gold值为1，将a赋值给b后，b的gold设置为2，此时a中的gold依然为1，因为a和b是两份不同的内存。

Struct这样值类型对我们做性能优化有什么好处呢？首先如果Struct被定义于函数中的局部变量，则Struct的值类型变量分配的内存是在栈上的，栈是连续内存，并且在函数调用结束后，栈的回收非常快速和简单只要将尾指针置零就可以了(并非真正意义上的释放内存)，这样我们即不会产生内存碎片，也不需要内存垃圾回收，CPU读取数据对连续内存也非常友好高效。

除了上述这些，Struct数组也对我们提高内存访问速度有所帮助。我们要明白由于Struct是值类型，所以它的内存也与值类型一样是连续的，Class数组则只是引用(指针)变量空间连续，这是大不同的。连续内存在CPU读取数据时，CPU的缓存可以帮助我们提高命中率，因为CPU在读取内存时会把一个大块内容放入缓存，当下次读取时先从缓存中找如果命中则不需要再向内存读取数据(缓存比内存快100倍)，而非连续内存则在缓存使用时的命中率比较低，因此CPU缓存命中率的高低很影响CPU效率。

但是也不是所有Struct都能提高缓存命中率，如果Struct太大超过了缓存拷贝的数据块，则缓存就不再起作用了，因为拷贝进去的数据只有1个甚至半个Struct。于是就有很多架构就抛弃了Struct，彻底使用值类型连续空间的方式来提高CPU缓存命中率，把所有的数值都集合起来用数组的形式存放，而具体对象上则只存放一个索引值，当需要存取时都通过索引来操作数组。我们来看一个例子就知道是怎么回事。

``` c#
class A
{
	public int a;
	public float b;
	public bool c;
}

class B
{
	public int index;
}

class C
{
	private static C _instance;
	public static C instance
	{
		get
		{
			if(null == _instance)
			{
				_instance = new C();
				return _instance;
			}
			return _instance;
		}
	}

	public int[] a = new int{2, 3, 5, 6};
	public float[] b = new float{2.1f, 3.4f, 1.5f, 5.4f};
	public bool[] c = new bool{false, true, false, true};
}

public void main()
{
	A[] arrayA = new A[3]{new A(), new A(), new A()};

	print("A class this is a {0} b {1} c {3}",Aa.a, Aa.ba, Aa.c);
	
	B b = new B()
	b.index = 2;

	C c = C.instance;

	print("B class this is a {0} b {1} c {3}",c.a[b.index], c.b[b.index], c.c[b.index]);
}
```

上述代码中A类使用了我们非常熟悉的面向对象的编程方式，把所有属性变量都放在自己身上，数据的集合则以引用的方式存储在数组上，而B则将数据集中存储在了C类中。当两者都对数据进行存取时，A类数据的内存是分散的，因为每次分配A实例时都是从内存中找一块空地来分配并不保证相邻，arrayA中只是引用连续而非内存连续，而B类的数据是连续内存的数组，因为它将所有同类的数据集中在了值类型的数组中，值类型的数组分配内存是一定是内存连续的，这样就能更多的利用缓存提高CPU读取数据的命中率。缓存机制是将最近使用过的数据存入最近的最快的空间中，离CPU最近的就是一级和二级缓存，它们是珍贵的，我们应该充分利用他们。

### 尽可能的使用对象池

说到类实例，我们应该清楚的明白，内存分配和消耗对我们程序的影响，这也是提高程序效率的关键所在。Unity3D使用的C#语言，它使用垃圾回收机制回收内存，即使Unity3D在发布后将C#转为了C++也依然使用垃圾回收机制来执行分配和销毁内存。作为高级程序员，我们应该要感受到，在创建类实例时内存分配的CPU耗时，以及垃圾回收时的艰难。

垃圾回收有多艰难呢？我们来解释一下，我们在C#中随意的new创建类实例，由不管它们的死活所以的丢弃或置空引用变量，类实例不断的被引用和间接引用，又不断被抛弃，垃圾回收器就要负责仔仔细细的收拾我们的烂摊子。内存不可能永远被分配而不回收，于是垃圾回收只能在当内存不够用的时候去到处问和检查(意思是遍历所有已分配的内存块)，看看哪个类实例完全被遗弃了就捡回来(意思是完全没有被人引用了)，将内存回收掉。因此当我们业务逻辑越庞大数据量越多时，垃圾回收需要检查的内容也越来越多，如果回收后依然内存不足，就得向系统请求分配更多内存。

垃圾回收过程如此艰难，它每次回收时都会占用大量CPU算力，因此我们应该尽可能的用对象池来重复利用已经创建的对象，这有助于减少内存配合时的耗时，也减少堆内存的内存块数量，最终减少了垃圾回收时带来的CPU损耗。

除了new 某个类创建内存导致的GC耗时增加外，以我的经验来看，很容易被我们忽略的是 new List<T> 这种类型的使用，我们在平时编程时会大量使用动态数组，并且随时将它抛弃，因为它太容易使用以及丢弃了。类似的 Dictionary<int,List<T>> 也是众多被忽略的内存分配消耗之一，被装进Dictionary字典中的List常被随意的丢弃(Remove掉)，没去注意它是否能被再次利用。

C#中一个简单的通用对象池就能解决问题，但我们常常嫌弃它，并觉得麻烦。在我的编程经验中，图方便图好用的往往要付出性能损耗的代价，而性能高的代码通常都有点反人性，我们应该尽量找到一个平衡点，即有高的代码可读性，也尽量不要被人性所驱使了去做一些图方便的事，这在任何时候都是非常有用的价值的。

``` C#
internal class ObjectPool<T> where T : new()
{
    private readonly Stack<T> m_Stack = new Stack<T>();
    private readonly UnityAction<T> m_ActionOnGet;
    private readonly UnityAction<T> m_ActionOnRelease;

    public int countAll { get; private set; }
    public int countActive { get { return countAll - countInactive; } }
    public int countInactive { get { return m_Stack.Count; } }

    public ObjectPool(UnityAction<T> actionOnGet, UnityAction<T> actionOnRelease)
    {
        m_ActionOnGet = actionOnGet;
        m_ActionOnRelease = actionOnRelease;
    }

    public T Get()
    {
        T element;
        if (m_Stack.Count == 0)
        {
            element = new T();
            countAll++;
        }
        else
        {
            element = m_Stack.Pop();
        }
        if (m_ActionOnGet != null)
            m_ActionOnGet(element);
        return element;
    }

    public void Release(T element)
    {
        if (m_Stack.Count > 0 && ReferenceEquals(m_Stack.Peek(), element))
            Debug.LogError("Internal error. Trying to destroy object that is already released to pool.");
        if (m_ActionOnRelease != null)
            m_ActionOnRelease(element);
        m_Stack.Push(element);
    }
}

internal static class ListPool<T>
{
    // Object pool to avoid allocations.
    private static readonly ObjectPool<List<T>> s_ListPool = new ObjectPool<List<T>>(null, l => l.Clear());

    public static List<T> Get()
    {
        return s_ListPool.Get();
    }

    public static void Release(List<T> toRelease)
    {
        s_ListPool.Release(toRelease);
    }
}
```

这两个对象池的类都是从Unity的UI库中提取出来的，都是非常实用的对象池工具，我们应该尽可能的使用他们。上述对象池使用了栈队列，将废弃的对象存储起来，并在需要时从栈队列中推出实例交给使用者。对象池并不复杂，麻烦的是使用，程序中对所有需要创建对象实例、销毁对象实例、移除对象实例的部分都需要用对象池去调用。

我们来举几个使用上述ObjectPool和ListPool对象池的例子：

``` C#
public class A
{
	public int a;
	public float b;
}



public void Main()
{
	Dictionary<int,A> dic2 = new Dictionary<int, A>(16);
	for(int i = 0 ; i<1000 ; i++)
	{
		A a = ObjectPool<A>.Get(); //从对象池中获取对象
		a.a = i;
		a.b = 3.5f;

		A item = null;
		if(dic.TryGetValue(a.a, out item))
		{
			ObjectPool<A>.Release(item); //值会被覆盖，所以覆盖前收回对象
		}

		dic[a.a] = a;

		int removeKey = Random.RangeInt(0,10);
		if(dic.TryGetValue(removeKey, out item))
		{
			ObjectPool<A>.Release(item); //移除时收回对象
			dic.Remove(removeKey);
		}
	}

	Dictionary<int,List<A>> dic2 = new Dictionary<int, List<A>>(1000);
	for(int i = 0 ; i<1000 ; i++)
	{
		List<A> arrayA = ListPool<A>.Get(); // 从对象池中分配List内存空间

		dic2.Add(i,arrayA);

		List<A> item = null;
		int removeKey = Random.RangeInt(0,1000);
		if(dic.TryGetValue(removeKey, out item))
		{
			ListPool<A>.Release(item); // 移除时收回对象
			dic.Remove(removeKey);
		}
	}

}
```

上述代码中，A类和List<A>需要被创建1000次，每次创建都使用对象池，并在字典Dictionary移除时将对象送回对象池。这样我们就可以不断利用被回收的对象池，然不用总是创建新的对象，所有被遗弃的对象都会被存储起来，并不会被垃圾回收程序回收，最终内存不断被重复利用，减少内存分配和释放所带来的消耗。

888

### 字符串导致的性能问题

字符串它在C#中比较特殊，虽然它是引用类型单却比较时是一个字符一个字符的比较。

### 计算机程序执行原理

为了能更好的理解优化的原理，我们应该再来深入些底层了解下，计算机是如何执行一个EXE文件的。

888

### 代码规范与编译优化细节

### 计算机执行程序的内存结构与执行流程

### 计算机指令执行原理，从汇编讲起，寄存器，栈与堆，函数，标记，汇编指令

### 业务逻辑的优化方法论



========================


###### 什么是算法？简单来说，所谓算法就是定义良好的计算过程，即一系列计算步骤，通过这些步骤，将输入的数据转换成输出数据。我们也可以把算法看做是一种工具，用来解决一个具有良好规格说明的计算问题。

如果说一个算法对其每一个输入实例，都能输出正确的结果并停止，则称它是正确的。一个正确的算法解决了给定的计算问题，不正确的算法对于某些输入来说，可能根本不会停止或者停止时给出了错误的结果。

然而在实际应用过程中，对不正确算法的看法其实有点不同，如果这些算法的错误率可以得到控制的话，它们有时也是有用的，例如我们写出了一个很高效的算法使得鸡蛋很快煮熟，但这个算法有概率将鸡蛋煮烂，如果能将这个煮烂的概率降低到我们可以接受的程度，鸡蛋损失的成本是我们能接受的范围，在实际应用中是可行的。

实际上每一种计算机编程问题都有很多种解决方案，这些解决方案可以是简单粗暴的数数，也可以是精心设计的步骤或流程。

如果计算机无限快，那么对于某个问题来说，任何一个解决它的算法都是可以的。你很可能希望自己的实现能够符合良好的软件工程实践要求，但往往最后都会采用最容易实现的方法。这是人性导致的，并不是你一个人的问题。回到现实，现代的计算机已经可以做得很快，但还不能做到无限快，它的处理速度还是有限的。存储器也是一样，现代的存储器已经做到了很便宜，但绝不会是免费的，并且依然会随着读写速度的快慢和空间大小的递增价格成指数级上涨。

如此说来计算机的算力依然是一种有限的资源，存储空间也依然是一种有限的资源，这些有限的资源必须被有效地使用，才能使得设备更快更好更流畅的运转。

###### 算法的代价和计算规模

任何算法都会在某种特定输入数据的情况下效率非常高，也就是说不同的数据环境和数据规模算法的运行时间会有很大的差异，如果只是针对特定的输入数据类型的话，我们就无法比较算法与算法之间的效率。

为了能比较算法与算法之间的优劣，也为了能让我们大体对算法的运算代价有一定的了解，预估和计算算法的空间和时间代价变得十分重要。特别是运算时间的代价，会用上界和下界渐进函数来表达，比如插入排序的运行时间介于N到N^2的之间，最大为N^2，最小为N，因为它处于N的线性函数和二次函数的范围内，也就是运行时间至少是一个常数乘上函数g(N)的时间。

如果把算法的代价表达成一个等式，则等式中有常亮，有线性运算，有幂次运算，也有指数运算，例如一个冒泡排序，我们在冒泡排序前加入对数据的检测合法性，于是就有了 T(N) = O(N) + O(N^2) 的表达式，等号右边 O(N) 为线性检测时间代价，O(N^2)为冒泡排序的时间代价，当数据规模大到O(N^2)的规模与O(N)的规模相差巨大时O(N)完全可以忽略掉，即 T(N) = O(N^2)。

###### 这种用法有助于我们略去一个等式中无关紧要的细节，把关注点集中在算法中最糟糕的部分。把最糟糕的部分提取出来加以优化就能让算法得到质的飞跃。

###### 算法的疑惑

算分首先是为了解决问题而产生的，其次是为了提高效率。为了解决各种各样纷繁复杂的问题，算法理念和分析技巧分为了很多种，这些技巧与理念都是为了将来当我们遇到问题时，可以运用并创造出新的算法的基础。



游戏中运用的大多数算法，我们再书本中都已经讲到，包括寻路算法，三角形网格构建算法，


<!-- ###### 同一种问题不同的情况下针对不同的算法有不同效率。 -->

<!-- 那么算法能帮我们解决哪些问题呢？包括数据排序，数据查找和检索，寻找最短路径，线性规划，数值算法和数论理论等等等，很多很多我们将在这节一一做以分析。 -->

参考文献:

《算法导论》



