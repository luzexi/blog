---
layout: post
status: publish
published: false
title: 《Unity3D高级编程之进阶主程》 第一章，程序逻辑优化技巧
description: "unity3d 高级编程 主程 算法"
excerpt_separator: ===
tags:
- 书籍著作
- Unity3D
- 前端技术
---

我们常常说起优化，总是不免想到渲染，Drawcall，Overdraw，引擎算法，底层组件，以及大型的整套的解决方案等，却很少关注普通业务逻辑中问题，其实不只是算法能大幅度提高业务逻辑的效率，普普通通的业务代码也同样可以有质的飞越。

一行普通的代码，高手写和普通人写可能就会不一样，优秀程序员常关注代码对性能的影响，普通人只关注是否能完成功能，这样日积月累代码质量就会形成差距。这节我们就来讲讲，在我们平时的业务逻辑编程中，我们应该怎么去优化这些不起眼但却蕴含着巨大潜力的性能问题。

前面几节我们讲解了List、Dictionary的源码，知道了它的实质都是数组，Dictionary有两个数组，一个数组存索引一个数组存数据，我们遍历List和Dictionary都是在遍历数组。

了解底层的逻辑有助于我们更好的运用的它们，比如当我们使用List插入时，我们知道其实就是向数组中写入元素并遍历其后面的数据依次向后移动的过程。了解了这些，每次当我们使用List的Insert时都会注意一些。还有Contains函数，它是一个以遍历形式来寻找结果的函数，每次使用它都会从头到尾遍历一下直到寻找到结果，Remove也是一样，都是以遍历的形式存在。如果我们在代码中使用它们的频率比较高，就会带来很多不必要的性能消耗，这是我们很多人常常不注意的。我们常常因为不了解或图方便而使用了这些接口而并没有考虑它们带来的性能损耗。

Dictionary也有诸多问题，首先它是一个使用哈希冲突解决关键字的字典组件，因此哈希值与容器中数组的映射关键和GetHashCode获取哈希值的函数比较关键。哈希冲突与数组大小有很大关系，数组越大哈希冲突率就越小，因此我们在写程序时应该注意设置Dictionary的初始大小，尽量设置一个合理的大小，而不是什么不做，任由它自己扩容，这不但让哈希冲突变得频繁，而且扩容时数组的回收也加重了GC的负担。除了之外，在C#中所有类都继承自Object类，Dictionary使用Object的GetHashCode来获取类实例的哈希值，而GetHashCode是用算法将内存地址转化为哈希值的过程，因此我们可以认为它只是一个算法，并没有做任何的缓存机制，每次调用它都会重新计算一次哈希值，这是我们比较隐形的性能损耗。在我们编码的过程中，常常出现用类实例当作Dictionary字典的关键字Key，如果频繁使用GetHasCode作为关键字来提取Value，那么我们应该关注下GetHashCode的算力损耗。

888


### struct 和 class

### cpu cash缓存命中机制

### 连续内容构建机制

### 代码规范与编译优化细节

### 计算机执行程序的内存结构与执行流程

### 计算机指令执行原理，从汇编讲起，寄存器，栈与堆，函数，标记，汇编指令

### 业务逻辑的优化方法论



========================


###### 什么是算法？简单来说，所谓算法就是定义良好的计算过程，即一系列计算步骤，通过这些步骤，将输入的数据转换成输出数据。我们也可以把算法看做是一种工具，用来解决一个具有良好规格说明的计算问题。

如果说一个算法对其每一个输入实例，都能输出正确的结果并停止，则称它是正确的。一个正确的算法解决了给定的计算问题，不正确的算法对于某些输入来说，可能根本不会停止或者停止时给出了错误的结果。

然而在实际应用过程中，对不正确算法的看法其实有点不同，如果这些算法的错误率可以得到控制的话，它们有时也是有用的，例如我们写出了一个很高效的算法使得鸡蛋很快煮熟，但这个算法有概率将鸡蛋煮烂，如果能将这个煮烂的概率降低到我们可以接受的程度，鸡蛋损失的成本是我们能接受的范围，在实际应用中是可行的。

实际上每一种计算机编程问题都有很多种解决方案，这些解决方案可以是简单粗暴的数数，也可以是精心设计的步骤或流程。

如果计算机无限快，那么对于某个问题来说，任何一个解决它的算法都是可以的。你很可能希望自己的实现能够符合良好的软件工程实践要求，但往往最后都会采用最容易实现的方法。这是人性导致的，并不是你一个人的问题。回到现实，现代的计算机已经可以做得很快，但还不能做到无限快，它的处理速度还是有限的。存储器也是一样，现代的存储器已经做到了很便宜，但绝不会是免费的，并且依然会随着读写速度的快慢和空间大小的递增价格成指数级上涨。

如此说来计算机的算力依然是一种有限的资源，存储空间也依然是一种有限的资源，这些有限的资源必须被有效地使用，才能使得设备更快更好更流畅的运转。

###### 算法的代价和计算规模

任何算法都会在某种特定输入数据的情况下效率非常高，也就是说不同的数据环境和数据规模算法的运行时间会有很大的差异，如果只是针对特定的输入数据类型的话，我们就无法比较算法与算法之间的效率。

为了能比较算法与算法之间的优劣，也为了能让我们大体对算法的运算代价有一定的了解，预估和计算算法的空间和时间代价变得十分重要。特别是运算时间的代价，会用上界和下界渐进函数来表达，比如插入排序的运行时间介于N到N^2的之间，最大为N^2，最小为N，因为它处于N的线性函数和二次函数的范围内，也就是运行时间至少是一个常数乘上函数g(N)的时间。

如果把算法的代价表达成一个等式，则等式中有常亮，有线性运算，有幂次运算，也有指数运算，例如一个冒泡排序，我们在冒泡排序前加入对数据的检测合法性，于是就有了 T(N) = O(N) + O(N^2) 的表达式，等号右边 O(N) 为线性检测时间代价，O(N^2)为冒泡排序的时间代价，当数据规模大到O(N^2)的规模与O(N)的规模相差巨大时O(N)完全可以忽略掉，即 T(N) = O(N^2)。

###### 这种用法有助于我们略去一个等式中无关紧要的细节，把关注点集中在算法中最糟糕的部分。把最糟糕的部分提取出来加以优化就能让算法得到质的飞跃。

###### 算法的疑惑

算分首先是为了解决问题而产生的，其次是为了提高效率。为了解决各种各样纷繁复杂的问题，算法理念和分析技巧分为了很多种，这些技巧与理念都是为了将来当我们遇到问题时，可以运用并创造出新的算法的基础。



游戏中运用的大多数算法，我们再书本中都已经讲到，包括寻路算法，三角形网格构建算法，


<!-- ###### 同一种问题不同的情况下针对不同的算法有不同效率。 -->

<!-- 那么算法能帮我们解决哪些问题呢？包括数据排序，数据查找和检索，寻找最短路径，线性规划，数值算法和数论理论等等等，很多很多我们将在这节一一做以分析。 -->

参考文献:

《算法导论》



