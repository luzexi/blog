---
layout: post
status: publish
published: false
title: 第四章，UI(七)
description: "unity3d 高级编程 c# 主程 UI ugui ngui ui框架"
excerpt_separator: ===
tags:
- 书籍著作
- Unity3D
- 前端技术
---

# 第四章，UI(七) - 优化UI(一)

前文回顾 [UI(一)](http://luzexi.com/2018/07/25/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-UI1.html)

对NGUI和UGUI进行了比较，讲述了如何选择UI系统作为项目的UI框架。

前文回顾 [UI(二)](http://luzexi.com/2018/07/25/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-UI2.html)

UGUI的原理，以及组件使用详解。

前文回顾 [UI(三)](http://luzexi.com/2018/07/26/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-UI3.html)

UGUI源码中输入事件模块源码剖析。

前文回顾 [UI(四)](http://luzexi.com/2018/07/27/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-UI4.html)

UGUI渲染核心源码剖析

这篇我们来聊聊，如何优化UI，以及优化UI的方法。

===

### ① UI动静分离。

什么是UI动静分离？

动就是左右上下移动，或放大缩小频率比较高的UI，静就是静止不动的，或者说动的比较少的UI。

我们在做项目中，避免不了一些UI会动，从左边移到右边，或从上面移到下面，或者一个小范围的移动，这些一直在动的，或者说有时会动的UI就属于行动中的UI。

那么为什么要将他们分离开来呢？

因为UGUI和NGUI一样，都是用模型构建UI画面的，在构建后都做了合并Mesh的有优化操作，而不合并会导致无数drawcall进而导致CPU，GPU消耗过大，游戏画面卡顿。所以合并是对的，但现在问题是，UI元素一动就重新合并，不需要重新合并的内容也一并合进去了，导致原来合并Mesh的好事变坏事。所以要将行动的UI元素和静态不动的UI元素分离开来，让合并的范围缩小，只合并那些会动的UI元素，而那些不动的UI元素就不让他做重新合并Mesh的操作了。

那么如何分离他们呢？
UGUI和NGUI都有自己的合并节点，UGUI是Canvas，NGUI是UIPanel。以合并节点为关键点，进行拆分。将会动的UI元素放入专门为它们准备的合并节点上，而将静止不动的UI留在原来的合并节点上。这样一来，当会动的UI元素来回移动的时候，就不会再重构静态的UI了，毕竟静态的UI元素占UI的大多数，而动态的UI元素只是小部分，因此减少了不少的CPU消耗。

### ② 拆分过大的UI。

为什么要拆分过大的UI？

项目的制作过程是个比较长的过程，在这个过程中UI的大小总是会随着项目时间的积累而不断扩大。很多时候我们总是莫名其妙的感觉，怎么这个UI界面，前段时间还好好的，现在打开会变得如何缓慢呢？！嗯，问题就在于，随着项目的推进，UI经手的人越来越多，添加的内容也越来越多，有的甚至一个Prefab里，装着2-3个界面，只是在显示时隐藏了其他的几个而已。最后导致，UI过大，实例化，初始化，过慢的问题。所以我们要想办法拆分这些，过大的UI界面。

如何拆分？

首先，把隐藏的UI界面拆分出来，成为独立运作的界面。只在需要是调用实例化。

其次，如果界面内容还是很多，我们可以把2次显示的内容拆出来，比如，一个界面打开时会显示一些内容(例如动画)，完毕后或者点击后才能看到另外的内容，这个另外的内容视为2次显示内容，可以拆分出来成为独立的界面。

### ③ UI预加载。

为什么要进行UI的预加载？

我们在UI实例化时，需要将Prefab实例化到场景中，这期间还会有Mesh的合并，组件的初始化，渲染初始化，图片的加载，界面逻辑的初始化等程序调用，消耗掉了很多CPU。这导致了在我们打开某个界面时，出现卡顿的现象，就是CPU消耗过重的表现。如何优化呢，上面讲的拆分UI是一个方面，但只能用在一些冗余比较大的界面上，而一些容易比较小，难以拆分的UI界面，就很难用这个方法达到优化到顺畅的效果。甚至有的UI界面即使拆分后，任然会消耗很多CPU，出现卡顿的现象。如何优化呢，加载图片的数量是不能减少的，不能因为要优化我就把图给删了吧。UI上的元素也是不能减少的，也不能因为要优化，把UI元素给去掉吧，影响美观。初始化程序也是必不可少的，虽然从某种程度上说初始化程序里也有糟糕的程序，但这部分我们总是可以在Unity3D分析器Profile找出原因，所以可以先放下不管。所以从分析上来看，我们已经不能从内部优化UI的实例化问题了，这导致了我们需要通过外部的方法进行优化，也就是我们的UI预加载。

如何进行UI预加载？ 
第一种方法，最直接的方法，在游戏开始前加载UI资源但不实例化，比如把Resources.Load(“ui”)这句放在进游戏画面之前。这样当点击按钮后，弹出UI界面时就少了一点加载资源的时间，把CPU消耗重心放在了实例化和初始化上。

第二种方法，在第一种方法的基础上，CPU还是消耗太严重，那么就将UI实例化和初始化也提前到游戏开始前。但在实例化和初始化后，对UI界面进行了隐藏，当需要他出现时，再显示出来，而不是重新实例化，当关闭时，也同样只是隐藏，而不是销毁。这样一来在打开和关闭时，只消耗了少量CPU在展示和隐藏上。

第三种方法，Unity3D 5.x的新功能Preload，在平台设置里，有这个功能，可以把需要预加载的Prefab加入到列表中去。他会将这些Prefab在进入APP或者说打开应用展示LOGO界面时进行预加载。不可否认，这个功能及其好用，让我在几个项目中收益，因为他在整个APP初始化时，同时预加载了指定的Prefab，而且是在前置的碎片时间，很难让人感觉到加载的停顿感。

最后，我要提醒一下，所有的预加载，都会出现另一个问题，CPU集中消耗带来的卡顿。我们预加载并没有削减CPU，所以CPU消耗的总量是不变的，因为需要加载的图片数是不变的，实例化的面片数是不变的，以及初始化程序需要消耗的时间是不变的，都是不变的。我们只是把他们提前了，然后拆分到各个时间碎片里去，让人感觉不到很大的CPU消耗，或者说卡顿感。但是，如果你将这些预加载，集中在某个位置，比如全部集中在游戏开始前，或者进度条的某个位置，也同样会有强烈的卡顿感，因为CPU在这个点进行了集中的消耗。


④	UI图集Alpha分离。http://www.maosongliang.com/archives/310
为什么要对UI图集进行Alpha分离？
在我们项目制作完成后，对项目进行打APP包时，会发现包体大小并适合运营，因为APP包体太大，导致用户下载的意愿减低，首先下载率就会受到影响，其次APP包体太大会导致卸载率的增大，进而导致次日留存，3日留存，7日留存率的降低，所以运营人员时常要求控制APP包体大小到XX 兆以内。而UI图集的压缩是减少APP包体大小的一部分，也是比较重要的一部分。因为包内的资源，以UI图集为重要组成部分。所以压缩UI图集是必要的手段。而在我们对图集进行压缩后，在屏幕上显示又不尽如人意，会有模糊，锯齿，线条等劣质的画面出现，这是因为我们在使用压缩模式ECT或PVRTC时将透明通道也一并压缩进去了，导致了渲染的扭曲。所以我们要把透明通道alpha分离出来单独压缩。

如何分离UI图集的Alpha呢？
这里主要是针对NGUI的方案，而UGUI由于是内部集成，所以Alpha分离在高版本的UGUI中已经帮你完成了，而低版本的UGUI分离起来又很困难。所以我们针对NGUI来讲一讲。
首先，用TexturePacker在打图集时将原来打成2张的图集，改成打成一张RGB888的png和一张Alpha8的png。RGB888的PNG图没有alpha，而所有的alpha通道都在Alpha8的PNG里。
然后，我们需要改下NGUI的shader，把原来的只绑定一张主图的shader改成需要绑定一张主图和一张Alpha图的shader。需要修改哪些呢，需要修改，Unlit – Transparent Colored.shader，Unlit – Transparent Colored 1.shader，Unlit – Transparent Colored 2.shader，Unlit – Transparent Colored 3.shader这4个。修改的内容很简单，加入_AlphaTex ("Alpha (A)", 2D) = "black" {}变量，用来可以绑定Alpha图。然后在frag函数中，有对alpha与主图alpha操作的内容，都替换成Alpha图的alpha值。这样就启用了Alpha图的Alpha，而主图还是承担了主要色彩内容。
最后，以上都完成后，选中一个创建好的图集prefab会发现Inspector窗口下的预览窗口以及Sprite选择窗口中看到的sprite都是没有alpha通道的，这是因为用于显示的texture是atlas.mainTexture，这个mainTexture就是那张RGB888的图集。我们可以在编辑器模式下动态生成一个rgba32的texture来替换它，rgb和alpha通道的值分别取自rgb888图集和alpha8图集。这需要修改一下NGUI的编辑类，UIAtlas.cs，UIAtlasInspector.cs，SpriteSelector.cs，NGUITools.cs，UISpriteInspector.cs中的绘制图片时都启用新生成的图，就是上面所说的，用RGB888和Alpha合成的动态图。
因为代码比较长，我贴出来也你们也未必能看明白，所以我只说了下需要修改的部分，以及修改的方向和原理。
⑤	UI字体拆分。
为什么要拆分UI字体？
项目中，字体其实占了很大的空间，如果是几个字体一起展示在屏幕上，会在展示的一瞬间出现比较严重的卡顿现象。所以如果在特定的场景内，我们需要更快的速度，而对字体需求又不是那么严格，那么我们可以拆分字体，让加载字体的速度更快，让场景加载的速度更快。

如何拆分UI字体？
因为特殊的原因，场景中，对字体的需求不是那么严格，但又必须有字体的支持，这时我们就要拆分字体。把字体中的常用字拆出来，另外生成一个字体文件，让字体文件变小，加载变快。比如在登陆场景中，我们只需要几个数字和字母，所以我们大可以从字体中提取数字和26个字母成立一个新的字体在场景中应用。这样登陆场景就省去了大的字体的加载。又比如，注册登陆后，取名字的场景，我们既要对取名字进行限制，也需要对场景加载速度进行控制，这时用拆分UI字体的方法就恰到好处。将字体中常用的3000字拆出来，生成新的字体进而用到场景中去。
注意，这种拆字体，是为了特殊场景所用的，这其实是一种用空间换时间的方法，增大了空间大小，在读取文件时减少了CPU消耗。
⑥	Scroll View中优化item滚动。
Scroll View的优化，在上面的UI架构中有讲到过，因为在类似背包的界面中，会有巨量的元素存在在窗口中进行渲染，所以在生成和滑动时，会消耗巨量的CPU来重构Mesh，进而导致游戏运行缓慢，出现卡顿现象。要优化这种情况，就必须对滚动菜单进行改造，将原来的所有元素都必须实例化的问题，改为只实例化需要显示的，然后在滑动的期间，判断是否有不需要展示的UI元素，将他们填补到需要显示的位置的上去，再对该元素进行重新的设置，让它显示为需要显示的元素的样子。
表现上看起来是这样的，在窗口中有10排元素显示在那里，其中5排是展示在中央的窗口上的，顶上2排因为超出了窗口无法可见，同样的下面3排也是因为超出了窗口无法可见，在整个10排元素，整体向上滑动期间，顶上2排变成了3排，底下变成了2排，其中最顶上的1排超过了重置的位置，于是就移动到了下面去了，这样整体10排元素，又变成了顶上2排，底下3排的局面，于是这样不断反复，我们只是不断在移动顶上或底下的1排元素，但看起来像是，很顺畅地在移动整个500个元素一样。

⑦	UGUI图在改变颜色或Alpha后，导致对Mesh重构的优化。
为什么在UGUI的图元素在改变颜色或Alpha后会导致Mesh的重构？
首先我们要明白，Mesh的合并机制。拥有相同的材质球的Mesh合并在一起才能达到最佳效果，一个材质球对应一个图集，所以在相同图集内的图片才需要合并在一起。当图片需要混合的颜色进行改变时会怎样呢？就需要拆分出一个另外的材质球来进行渲染，多出来个材质球，当然就需要对UI的Mesh进行重构了。如果在动画里，每一帧都对颜色或Alpha进行改变，那么UGUI每一帧都会对Mesh进行重构一次。这个效率实在太糟糕，导致UGUI的UI颜色动画非常卡。

如何对此做优化？
很简单，我们不希望Mesh重构导致UI颜色动画消耗掉太多CPU，那么我们就自己建一个材质球，提前告诉UGUI：我用我自己的特殊的材质球渲染，你不用关心这个元素的材质球问题了。然后，当颜色动画，对颜色进行改变时，我们直接对我们自定义的材质球进行颜色的改变。这样UGUI就不需要重构Mesh了，因为材质球问题，我们帮他解决了。

如何操作？
首先，我们需要把UGUI的Shader下载下来。
然后，建立一个自己的材质球，并且材质球里使用下载下来的UGUI的Shader。
再次，把这个材质球放入Image或RawImage的Material上去，与Image或RawImage绑定。
接着，写个类比如class ImageColor继承MonoBehaviour，里面有个public 的颜色变量，比如public Color mColor，类里面只干一件事，在update里一直判断是否需要更改颜色，如果颜色被更改，就把颜色赋值给Material。
最后，把动画文件中的颜色部分从更改Image或RawImage的颜色变为更改ImageColor的颜色变量。这样UGUI颜色动画在播放的时候就不会消耗这么大量的CPU了。

不过要注意下，因为启用了自定义的材质球，当alpha不是1的时候，会与原有的UGUI产生的材质球的透贴形成不同的渲染排序，因为当两张透贴放在一起渲染时，会因为Shader的渲染渲染排序不一样而前后不一样。这是在具体项目制作中会碰到的问题。解决办法也很简单，改变一下自定义的Shader渲染排序就可以了。

⑧	UI展示与关闭的优化。
UI的展示与关闭动作最常见，需要看界面时打开，看完了关闭。但打开和关闭也会消耗一定的CPU。因为打开需要实例化和初始化，关闭需要销毁GameObject。
所以这里也有些策略可寻，
①	前面提过利用碎片时间的预加载，会让展示速度更加快，因为提交消耗了一部分需要消耗的CPU。
②	在关闭时隐藏GameObject，而不是销毁。在以后再次显示时，直接显示，并再次初始化。这里初始化很必要，因为需要让UI回到原来的状态，不过也会因界面的不同而不同，有些界面不需要我们回到原始状态。
③	移出屏幕。移出屏幕并不会让CPU消耗全部消失，但会减少一部分，不过GPU在这个界面上的消耗就会基本消失。当需要显示时再移入屏幕，并且如果需要的话，进行初始化回到原来的状态。
这里总结下，2、3两个方法，相同点是，都是用内存换CPU，关闭界面时不减少内存，而减少了CPU的消耗。而不同点是，方法2在关闭期间CPU消耗比方法3的更少，在打开时CPU消耗比方法3的却更多。方法3比较平均的消耗了CPU，而方法2消耗的CPU波幅稍微大了点。两者方法的消耗比起来，并没有差很多，具体项目中的具体情况我们可以利用这些差异进行优化，让UI跑起来更舒服，比如关闭的时间长的界面用方法2，关闭时间相对短的用方法3。

⑨	对象池的运用。
什么是对象池，以及为什么要用对象池？
对象池，顾名思义就是，对象的池子，这样描述起来比较形象。对象池里寄存着一些废弃的对象，当计算机程序需要该种对象时，可以向对象池申请，对废弃的对象再利用。这样就省去了实例化的CPU消耗，实例化消耗包括，模型文件读取，贴图文件读取，建模，渲染，逻辑初始化，销毁物体等。在对象用完后，再将对象隐藏并放入对象池。
对象池的方法，就是用内存换CPU的方法。在内存中保留了模型和贴图，再次利用时就省去了实例化和销毁的CPU消耗。

在UI界面中，有时会出现，需要不断跳出不同的物体。这时，实例化和销毁是最大的消耗，物体不断冒出来，又不断消失。CPU大部分浪费在了实例化和销毁上，而渲染的比重只占了很小一部分。这时运用对象池就能解决大部分浪费的问题，将要销毁的实例对象，隐藏并放入对象池，然后再需要他们时再放出来重新初始化。

如何用好对象池？
对象池是个能用内存换CPU的方法，但因为他是用内存付出代价的，所以用的不恰当的话，还是会引起不少内存问题的。所以一定要用在重复利用量大的对象上。
这里我总结了几个对象池运用的方向：
1.	只在重复实例化，不断销毁的对象上使用。因为重复实例化和销毁操作的对象上，消耗大量CPU，在此类对象上使用对象池效果极佳，而在很少或较少做重复和销毁操作的对象上，则会浪费内存，得不偿失。
2.	每个实例对象上要绑定对象池类，让不同对象类型继承基类对象，在初始化时可以做初始化重载，分别对待不同类型的对象。让不同对象的初始化方法都不同。
3.	主动使用对象池接口进行销毁操作。在销毁物体时使用对象池提供的销毁接口，让对象池决定，是真销毁，还是隐藏对象。
4.	场景结束时要即使销毁整个对象池，避免无意义的内存驻留。当场景结束后，在对象池内的物体，已经不再适合新的场景了，或者说面临的环境情况与旧场景不同了所以需要及时清理对象池，把内存空出来，给新场景使用。

⑩	UI贴图设置的优化。
为什么要关心UI贴图设置？
首先我们得知道，Unity3D会重置全部贴图格式。可以理解为，无论你是JPG，PNG，PSD等，只要放在Unity3D中，Unity3D就会读取图片内容，然后重新生成一个自己格式的图，用自己生成的图，在Unity3D中使用。所以其实不必关心用什么格式。
Unity3D中图片的设置也有很多讲究，因为关系到，重新生成的图片的格式，最终将决定加载入引擎的是什么样的图片，所以我们不得不要研究下贴图的设置。

如何优化UI贴图设置？
这里以NGUI和UGUI为例分别讨论。NGUI的UI贴图使用传统的贴图方式，基本都使用Editor GUI and Legacy GUI，有时也会用其他方式但很少见。
里面需要注意的是，
1.	Alpha是否需要。如果需要透明通道，则要把透明通道点开。
2.	是否需要进行2次方大小的大小纠正。Non Power of 2，对UI贴图来说使用的不多。
3.	读写权限要勾掉。常会默认勾选，导致内存量大增。因为此选项会使贴图在内存中存储两份，所以内存会有比不勾选大1倍。
4.	Mipmap要勾掉。Mipmap是对3D远近视觉的优化，当摄像头离物体远时，不需要高清的图片，而选择使用Mipmap生成的贴图小的模糊图像，从而减轻GPU压力。但是UI里没有远近之分，所以不需要Mipmap这个选项，而且Mipmap会导致内存和磁盘空间加大，完全没有必要在UI里勾选。
5.	压缩方式选择。压缩方式的选择，主要是为了减少包体的大小，在清晰度足够的情况下，我们可以选择一些压缩方式来减少包体大小。最高的色彩度是无压缩，其次是RGBA16色彩少了点且有透明通道，再次是RGB24和RGB16色彩少了点却没了透明通道，最后是算法级别的压缩，RGBA ECT2 8bits和RGBA PVRTC 4bits，带透明通道的压缩算法，以及不带透明通道的压缩算法，RGB ECT2 4bits和RGB PVRTC 4bits。这样逐级下来，压缩的越来越厉害，画质越来越差。前面有介绍过关于UI贴图Alpha分离的方法，这方法就是压缩的极致和平衡，既要画质又要紧最大极限压缩，缩小包体大小。
UGUI使用的是Sprite模式，需要注意的是，Packing Tag，可以自由选择图集的拼接情况，从而优化图集的拼接。
最后注意，UI的选项优化，可以写个脚本，在放入UI贴图时，自动选择统一的设置，这样辅助你更改UI贴图，省去了下次检查时，从头检查一遍的苦恼。不过说是这么说，其实在实际项目中，你也不得不从头检查一遍所有贴图的设置情况，来确认是否是你所期望的设置，因为也不是所有贴图都是一种统一的设置，更多时候特殊部分会区别对待。
⑪	内存泄露。http://blog.csdn.net/wetest_tencent/article/details/52318607
内存泄露是个敏感的词汇，在各大项目中，都会对内存泄露进行检验，一旦涉及到内存泄露所有内存，大家都会格外重视。其实在整个项目各个地方都有可能，我把内存泄露放在UI章节里是因为UI逻辑占去了游戏项目的大部分，所以内存泄露在UI逻辑中是重灾区。

什么是内存泄露？ 
内存泄漏，简单来说就是由程序向系统申请内存，使用完毕后并没有将内存还给系统的过程。系统本身的内存是有限的，如果内存泄漏一直被调用，就会耗尽系统内存，最终导致奔溃。就像你一直向银行借钱不还一样，银行一直容忍你的不道德行为，但银行是有底线的，最终会切断你的资金来源，一下子收回全部资金，那个时候，你就崩溃了。计算机系统也是一样，他不会无限制的让程序申请到内存，当申请内存影响到系统运行时就会停止。

为什么会内存泄露？
内存泄漏还分两种，一种是程序上的内存泄漏，另一种是资源上的内存泄漏。虽然资源上的内存泄漏也跟程序有关，但跟程序上的自身内存泄漏还是有区别的。

程序上的内存泄漏主要是因为Mono的垃圾回收机制并没有识别“垃圾”的原因造成的。那为什么会没有识别呢，根源还是在编程时的疏忽，在编程时一些不好的习惯，错误的想法，不清晰的逻辑，导致申请的内存或指向内存的引用，没有有效的释放，导致垃圾回收机制没能识别出释放此块内存的理由。
而资源上的内存泄漏，主要是因为在人为的申请资源，使用完毕后并没有释放，导致资源内存长期驻留在内存里。

程序上的内存泄漏，排查难度比较大，可以说是属于预防型为主。
而资源上的内存泄漏，就完全是属于人为的过错或疏忽，关键是容易排查，我们在排查中重点排查的对象就是资源的内存泄漏。资源内存泄漏，主要排查的内容就是，资源在不需要使用时或者说还没有使用时，却已经驻留在内存里的情况。

什么是垃圾回收机制？
Unity3D是使用基于Mono的C#作为脚本语言，它是基于Garbage Collection（简称GC）机制的内存托管语言。那么既然是内存托管了，为什么还会存在内存泄漏呢？因为GC本身并不是万能的，GC能做的是通过一定的算法找到“垃圾”，并且自动将“垃圾”占用的内存回收。

找“垃圾”的算法有两种，一种是用引用计数的方式，另一种是跟踪收集的方式。
引用计数，简单的说，就是当被分配的内存块地址赋值给引用时，增加计数1，相反当引用清除内存块地址时，减少计数1。当引用计数变为0时，表明没有人再需要此内存块了，所以可以把内存块归还给系统，此时这个内存块就是垃圾回收机制要找的“垃圾”。

跟踪收集，简单的说，就是遍历一遍引用内存块地址的根变量，以及与之相关联的变量，对内存资源没有引用的内存块，进行标记，标记为“垃圾”，在回收时还给系统。

那为什么有了这么智能的垃圾回收机制，还会有内存泄漏呢？首先引用计数方式，它很难解决对象之间相互循环引用的问题。所以现代计算机语言中已经很少使用这种方式去做了，可能有些C++智能指针还在这么做。其次跟踪收集，并不是万能的，很多时候会有环状的引用链存在，以及包括在编码时错误操作的泄漏，这些编码的泄漏问题在实际编码过程中是非常隐蔽且难以查找的，都需要人工去仔细的检查引用变量是否释放引用，工作量比较巨大且繁琐，特别是程序侧的内存泄漏，尤其难找。

资源侧的内存泄漏是最大的，大到几百MB甚至几个G，不过万幸的是相对程序侧来说资源侧的内存泄漏查找相对比较容易。下面就会介绍一些关于Unity3D内存运作，泄漏排查，预防泄漏的经验，来帮助大家在实际项目中，针对内存泄漏理解，排查，和预防。

Unity3D内存是如何运作的？
C#代码所占用的内存又称为Mono内存，这是因为Unity是通过Mono来跨平台解析并运行C#代码的，在Android系统上，游戏的lib目录下存在的libmono.so文件，就是Mono在Android系统上的实现。C#代码通过Mono解析执行，所需要的内存自然也是由Mono来进行分配管理。

Mono堆内存的占用，是只会增加不会减少的。具体来说，可以将Mono堆，理解为一个内存池，每次Mono内存的申请，都会在池内进行分配；释放的时候，也是归还给池，而不会归还给操作系统。如果某次分配，发现池内内存不够了，则会对池进行扩建——向操作系统申请更多的内存扩大池以满足该次的内存分配。需要注意的是，每次对池的扩建，都是一次较大的内存分配，每次扩建，都会将池扩大6-10M左右。

分配在Mono堆内存上的，其内存占用量一般较小，主要目的是程序员在处理程序逻辑时使用；而Unity的资源，是通过Unity的C++层，分配在Native堆内存上的那部分内存。与Mono堆内存是分开来管理的。

Mono通过垃圾回收机制（Garbage Collect，简称GC）对内存进行管理。Mono内存分为两部分，已用内存（used）和堆内存（heap），已用内存指的是Mono实际需要使用的内存，堆内存指的是Mono向操作系统申请的内存，两者的差值就是Mono的空闲内存。当Mono需要分配内存时，会先查看空闲内存是否足够，如果足够的话，直接在空闲内存中分配，否则Mono会进行一次GC以释放更多的空闲内存，如果GC之后仍然没有足够的空闲内存，则Mono会向操作系统申请内存，并扩充堆内存。

除了空闲内存不足时Mono会自动调用GC外，也可以在代码中调用GC.Collect()手动进行GC，但是，GC本身是比较耗时的操作，而且由于GC会暂停那些需要Mono内存分配的线程（C#代码创建的线程和主线程），因此无论是否在主线程中调用，GC都会导致游戏一定程度的卡顿，需要谨慎处理。另外，GC释放的内存只会留给Mono使用，并不会交还给操作系统，因此Mono堆内存是只增不减的。

如何排查内存泄露？
Mono内存泄漏排查，
游戏中大部分Mono内存泄漏的情况都是由于静态对象的引用引起的，静态对象是GC的根节点，因此对于静态对象的使用需要特别注意，尽量少用静态对象，对于不再需要的对象将其引用设置为null，使其可以被GC及时回收，但是由于游戏代码过于复杂，对象间的引用关系层层嵌套，真正操作起来难度很大。

资源内存泄漏排查，
资源内存泄漏，方式主要有，
1.	典型的泄漏情况，存在该释放却没有释放的错误引用，导致回收机制认为目标对象不是“垃圾”，以至于不能被回收。主要发生对象贴图，模型。
2.	在触发了资源卸载之后，才清除对资源引用，错过了GC回收点，导致本应该被GC回收的资源内存，并没有将回收回去。
3.	资源内存拷贝，导致的泄漏。在逻辑中拷贝了一份资源，例如贴图拷贝后修改像素再次放入UI中，或者无形中Unity3D默认拷贝了一份资源，例如Material需要独立出来修改参数，于是就拷贝了一份，最后都因为没有即使清除引用和销毁导致内存泄漏。

将引用解开就可以避免内存泄漏了，似乎是个很简单的问题。但是由于实际项目的逻辑复杂度往往超出想象，引用关系也不是简单的一层两层（有时候往往会多达十几层，甚至数十层才连接到最终的引用对象），并且可能存在交叉引用、环状引用等复杂情况，单纯从代码review的角度，是很难正确地解开引用的。如何查找导致泄漏的引用，是修复泄漏的难点和重点。所以我们需要借助一些工具来查找内存泄漏。
Unity3D的MemoryProfiler是个查内存泄漏的利器，他是由官方开发的专门用于Unity3D 5.x以上版本的内存快照工具。(https://bitbucket.org/Unity-Technologies/memoryprofiler)他可以快照内存的信息，并可以以文件形式保存和加载。这样我们可以在不同的节点进行内存快照，再经过两者的对比找出内存泄漏的资源，定位了泄漏的资源点，就可以根据此方向，从程序逻辑中寻找泄漏点。
比较遗憾的是，MemoryProfiler并没有提供两次（或多次）内存快照的比较功能。所以更多的是需要人工去核实。
 
从图中可以看出整体上的内存占用规模，包括，音效，字体，Assetbundle，动画，模型，粒子，贴图，Shader等。也可以点击整个模块细致的检查，模块中的各个点位资源的信息。比如我选中的Texture模块中的一个贴图，他就会展示出此贴图的信息，包括，名字，图案，材质球，关联了哪些脚本等。

我们也可以借助Unity3D自带的Memory Profiler，这是个比较老的工具，但对于资深程序员来说却能用的很顺手。他会记录CPU使用情况，精准定位CPU耗时节点，也可以记录Mono堆内存和资源内存的使用情况，并且详细记录下了内存中资源的详细情况。
 

当我们检查到当前场景，不需要用到的资源时，这个资源就是泄漏的点。我们可以顺藤摸瓜根据Profiler提供的信息，在代码中寻找线索。寻找的过程还是很枯燥的，这是肯定的，但当我们寻找出一个资源泄漏点时，可以举一反三的找出更多的资源泄漏点。

在平时项目中，我们找到这些泄漏的资源的方法，最直观的方法，就是在每次游戏状态切换的时候，做一次内存采样，并且将内存中的资源一一点开查看，判断它是否是当前游戏状态真正需要的。这种方法最大的问题，就是耗时耗力，资源数量太多眼睛容易看花看漏。

这里介绍两种寻找资源内存泄漏的技巧： 
1） 通过资源名来识别。即在美术资源（如贴图、材质）命名的时候，就将其所属的游戏状态放在文件名中，如某贴图叫做bg.png，在房间中使用，则修改为Room_bg.png。这样在Profile工具里一坨内存资源里面，混入了一个Room大头的资源，可以很容易地识别出来，也方便利用程序来识别。这个方法但也不是万能的，因为在项目制作过程当中，一张图需要被用到各个场景中去，很可能也不只一两个，有时甚至四五个场景中都会用，只用前缀来代替使用场景的指定，很多时候也会造成另一种误区。甚至，由于项目的复杂度扩展到一定程度，包括人员更替，在检查资源泄漏时，用前缀来判断使用场景点不太靠谱，因为你根本就不知道这张图在哪使用了。所以说技巧只能辅助你，并不是说一定能有效。
2） 我们可以通过Unity提供的接口Resources.FindObjectsOfTypeAll()进行资源的Dump，可以根据需求Dump贴图、材质、模型或其他资源类型，只需要将Type作为参数传入即可。Dump成功之后我们将这些信息结果保存成一份文本文件，这样可以用对比工具对多次Dump之后的结果进行比较，找到新增的资源，那么这些资源就是潜在的泄漏对象，需要重点追查。

另外还有一个比较好用的工具是UWA的GOT，他会逐帧记录资源内存和Mono堆内存的使用情况，并且可以在快照之间进行相互比较，得出新增或减少的资源名称。有了内存快照之间的对比，就大大加快了我们查找内存泄漏的问题。不过遗憾的是，GOT工具并没有Editor版本，不能在Unity3D Editor上实时查找内存泄漏问题。假如有更好的工具，或者我们自己也可以写一个快照对比工具，简单的实现下也不会花太多时间的，让功能更贴近我们的需求，这样在查找资源内存泄漏时就更加的方便了。

另外，在Github有一个在Editor下可以对内存快照进行比较的工具。
https://github.com/PerfAssist/PA_ResourceTracker
它是将Unity Memory Profiler改造后，加了快照比较，搜索，内存分配跟踪的功能，在原来Unity Memory Profiler的快照功能上提升了不少实用性。我们可以用这个工具来方便得快照内存以及比较内存的使用情况，借此来查找内存泄漏情况。确实是一个内存泄漏查找利器。但它也有一个小缺点，实时性并不是很好，每次都需要手动快照，没有将每帧的内存变化记录下来。

于是我写了一个简单的工具，来查看实时的贴图在内存中的变化。
https://github.com/luzexi/Unity3DMemoryCompare
这个工具以Resources.FindObjectsOfTypeAll()接口为核心，每帧都对内存遍历，对当下这一帧新加入的贴图，和移除的贴图，以及他们的大小，名称，当前帧数，都打印在log中，让开发者能知道当下到底哪些贴图被加入进来的，而又有哪些贴图被移除了。这样能让开发者更好的明白当下，或者前几帧的情况。

最后，把工具结合起来用，会达到最佳的效果。用原生态profiler和Unity Memory Profiler初步定位，修复一下很明显就能看到的内存泄漏问题。再用快照比较功能将内存泄漏定位的更加准确些，一些细小的泄漏就能查找出来。最后再用实时的内存贴图比较功能进行检验，看看整个过程，是否如我们所期望的那样进行加载和卸载，可以找出一些前面没有被定位到的内存泄漏的问题。接下来，就是继续重复前面的步骤，直到将内存泄漏完全消灭。

这里对各类资源内存释放的接口进行归类一下，(参考http://blog.csdn.net/zhliu1991/article/details/45113629 )
Destroy: 主要用于销毁克隆对象，也可以用于场景内的静态物体，不会自动释放该对象的所有引用。虽然也可以用于资源类型,但是概念不一样要小心，如果用于销毁从文件加载的资源对象会销毁相应的资源文件！但是如果销毁的资源是Copy的或者用脚本动态生成的，只会销毁内存对象。
AssetBundle.Unload(false):释放AssetBundle文件内存镜像。
AssetBundle.Unload(true):释放AssetBundle文件内存镜像同时销毁所有已经Load的资源内存对象。
Reources.UnloadAsset(Object):显式的释放已加载的资源对象，只能卸载磁盘文件加载的资源对象。
Resources.UnloadUnusedAssets:用于释放所有没有引用的资源对象。
GC.Collect()强制垃圾收集器立即释放内存。 Unity3D的GC功能不算好，没把握的时候就强制调用一下。

如何预防内存泄露？

上面全面介绍了内存泄露的原理以及发生的情况，这里对内存泄露的预防做一个总结，虽然预防的效果并不是非常明显，但有这个意识去预防，就会让检查内存泄露时更加省心。
1.	减少使用静态变量，静态变量的使用一定要慎重。尤其是单例模式中，一个静态实例类中的变量需要更加的注意即使销毁或置空。
2.	在资源使用的class的基类中加入，纯虚函数abstract。在架构上，多添加析构的abstract接口，提醒团队成员，要注意清理自己产生的“垃圾”。
3.	强化生命周期的概念，无论是代码对象还是资源，都有它存在的生命周期，在生命周期结束后就要被释放。如果可能，需要在功能设计文档中对生命周期加以描述。
4.	加强资源的管理，资源管理越集中，越容易查出泄露问题，即使成员们把加载和卸载接口分散在项目逻辑的各个角落，也能在统一的管理类中轻而易举的查出来泄露问题，反之越分散，越麻烦。

⑫	区别针对高低端机型的优化。

为什么要区分高低端机型？

我们在做游戏时，画质和流畅度是非常重要的，而市面上的设备并不是统一的一种设备，纷繁复杂的设备市场，各种厂商都会推出不同型号不同性能的设备来满足大众的需求。

一款游戏的画质和流畅度是决定游戏是否能畅销的关键，而画质和流畅度又需要靠设备来支撑，高低性能的设备会导致游戏产生不同的性能效果，这是最让人头疼的。我们辛苦开发的游戏，却不能在设备上顺畅的跑起来，导致画质糟糕，画面过慢，卡顿，甚至崩溃等问题，影响了游戏的可玩性，也影响了游戏在市场上的前景。

为了让市场上的高低机型的设备都能让游戏流畅的跑起来，我们需要让游戏对高低机型区别对待。在高端机型中使用画质好的画面，而在低端机型中使用差一点的画质，因为低端机型内存低，CPU性能差，设备中部件之间配合并没那么好，所以如果还是运行高端的画质会比较不流畅。

如何处理高低端机型的画质问题？

高低端机型的区分对待，我们可以从几个方面入手：
1.	UI贴图质量区分对待。针对高低端不同的机型，分别使用两套UI贴图，其中一套是针对高端机型的，无任何压缩，无缩小，另一套是针对低端机型的，对UI贴图进行了压缩，且缩小了UI贴图的大小。我们会在下面详细的讲如何在游戏中用NGUI和UGUI无缝的切换高低质量的UI画面。

2.	特效使用情况区分对待。针对高低端不同的机型，分别使用不同的特效，或者非关键部位不使用特效。特效在项目中使用的最常见也最频繁，高质量的特效能直接导致低端机型的卡顿，所以在低端机型中更换低质量的特效，或者甚至在非关键部位不使用特效能让游戏在低端机型上跑得更加顺畅些。

3.	阴影使用情况区分对待。针对高低端不同的机型，分别使用不同质量的阴影，或者不使用阴影。场景中的模型物体越多，面数就越多，阴影的计算与渲染量就越多。在低端机型上保持顺畅是第一，如果能不使用阴影那是最好的，直接省去了阴影的计算。但假如一定要使用，那我们也有办法减低阴影计算和渲染的消耗。

下面是针对高低端机型对阴影处理的几个方法：

方法1，用Unity3D提供的阴影渲染设置接口，QualitySettings.shadowResolution设置渲染质量，QualitySettings.shadows设置有无和模式，以及QualitySettings.shadowProjection投射质量，QualitySettings.shadowDistance阴影显示距离，QualitySettings.shadowCascades接受灯光的数量等。在高端机型上使用高质量阴影渲染设置，而在中端机型上使用中端阴影渲染设置，在低端机型上使用低端阴影渲染设置，甚至关闭阴影渲染设置。

方法2，关闭传统的阴影渲染设置，使用简单的底部圆形黑色阴影面片代替。这样就省去了阴影计算的CPU消耗，而且还能看见阴影在底部。用一些简单的阴影面片替换了阴影计算的CPU消耗，用内存换了CPU。

方法3，关闭部分模型的阴影计算。
使用简单的圆形面片代替阴影在真实感上效果还是差了点，如果我们既需要实时的阴影效果，又不想消耗过多的CPU，怎么办？
我们可以对部分模型使用简单的阴影面片代替，对另一部分比较重要的模型使用实时阴影渲染。这就需要我们将场景中的所有可被计算阴影的模型集中起来管理了。我们将场景中的Render全部收集起来，把需要实时阴影计算的模型打开Render. receiveShadows选项，对另一些不需要实时阴影计算的模型关闭Render. receiveShadows选项，并选择使用简单阴影模型代替。

4.	抗噪声，LOD，像素光数量使用情况区分对待。针对高低端不同的机型，分别使用不同质量的抗锯齿效果和不同级别的LOD效果，或者直接不使用抗锯齿和LOD效果。
Unity3D渲染设置专门有针对抗噪声，LOD，像素光数量限制的选项，我们可以在程序里调用。QualitySettings.antiAliasing，QualitySettings.lodBias，QualitySettings.maximumLODLevel，QualitySettings.pixelLightCount等。我们可以使用这些接口在高中低端机上分别进行设置，让不同性能的机子拥有不同画质的设置。

5.	整体贴图渲染质量区分对待。针对高低端不同的机型，分别使用不同的贴图渲染质量。Unity3D有对贴图渲染质量的设置，QualitySettings.masterTextureLimit，这个API厉害了，默认是0，就是不对贴图渲染进行限制，假如设置1，就是只渲染1/2大小的画质，相当于压缩了所有要渲染的贴图的大小至原先的1/2大小，假如设置2，就是1/4画质，以此类推。对所有贴图进行渲染限制，是个大杀器，能直接让CPU和GPU消耗降下来，但画质也遭到了毁灭性的打击，我们需要它在低端机型上发挥作用，但也要谨慎使用。

那么怎么用程序区分机子是高低端呢？
有几个方法：
1.	IOS，毕竟IOS的型号是有限的，我们可以把其中一些型号的机子归类为高端，其中一些型号的机子归类为中端，另一些型号的机子归类为低端。Unity3D中的API有可以用的接口，例如UnityEngine.iOS.Device.generation == UnityEngine.iOS.DeviceGeneration.iPhone6，等以此类推。
2.	Android等其他机型，我们可以用内存大小，系统版本号，屏幕分辨率大小，平均帧率等因素判断是高端机还是低端机。
比如，3G内存或以上为高端机，1G或以下肯定是低端，其他为中端。
又比如，Android 7.0以上为高端，Android 5.0以下都是低端，其他为中端。
如上描述通过一些简单的规则将高低端机型区分开来。

我们也可以通过平均帧率来判定高低端机型，在游戏中加入统计平均帧率的程序，将机型型号和平均帧率发送给服务器，由服务器记录各机型型号的平均帧率，再统计出来一份报表给客户端，客户端根据这份统计报表决定，哪些机型型号是高端设备，哪些是低端设备。最后再通过高低端设备画质不同的方法，来优化高低端设备的游戏流畅度。

在上面对高低端机型优化的方法中，UI贴图质量的区别对待是个比较重要的操作手法，我们下面进行详细的介绍。

在开发游戏时免不了要针对不同机型的做不同的处理，让游戏在高画质和低画质之间切换，在判定高低端设备后，可以实时切换游戏品质让游戏更加流畅。这能给客户端在渠道发行后提高些许留存率。
NGUI和UGUI切换方式有所不同，NGUI基于图集Atlas，UGUI基于Image Unity3D4.6.1后的Sprite 2D。

两种方式都基于两套图和两套Prefab。共同特点就是在开发期间Prefab，用脚本工具去生成相应的SD Prefab。
我们把高清UI和标清UI做成两个不同的Prefab，两个UI的功能是相同的，只是相对应的图集质量不同。
然后我们在高端机型中运行高清UI，在中低端机型中运行标清UI，使得高低端机型都能流畅的跑游戏，而且拥有相同的功能。

制作高清和标清的UI细节如下：

1.	一套UI图分两套图，一套高清一套低清，高清(HD) Prefab指向高清图，(标清SD)Prefab指向低清图。
这里NGUI和UGUI的方法不同。NGUI可以制作两个Atlas prefab，可以通过修改内核将Atlas实时更换掉，也可以复制并制作另一个SD UI Prefab只改变Atlas部分的指向标清画质的Atlas。UGUI稍微复杂一点，但原理差不多，虽然不能实时改变图集来切换高清画质和标清画质，但也可以通过制作一个SD Prefab来达到高清和标清切换的目的。步骤是，首先复制所有图片到SD文件夹，并加上前缀sd，这样好辨认，然后复制一个相同UI Prefab命名为SD UI Prefab，再把复制过来的SD UI Prefab里的图都换成SD里的图。这样高清和标清UI Prefab都有相同的逻辑，只是指向的图不同而已。


2.	程序在选择SD还是HD时，只要关注Prefab名就可以了。Prefab名字在高清和标清之间只是前缀不一样，其他都一样，所以加载时很容易区分开来。

3.	最后，NGUI和UGUI制作SD Prefab的流程可以通过写一个脚本程序一键搞定，就不用这么麻烦，通过手动一个个复制，一个个修改了。在开发过程中，我们只要维护好HD UI Prefab就可以了，在打包前用脚本一键构建SD UI Prefab能节省不少时间，提高不少效率。这样，在制作过程中，我们不用再关心SD的事情，把精力集中在做好UI上就可以了，因为脚本程序已经帮我们全部搞定了。


最后总结：两套图一高一低，需要维护两套，使用脚本工具根据HD的Prefab生成SD的Prefab。

⑬	UI图集拼接的优化。

为什么要优化UI图集拼接？
UI图集概念在Unity3D的UI中是必不可少的。UI图在整个项目中也占了举足轻重的作用。所以UI图集的大小，个数，也一定程度上决定了项目打包后的大小和运行效率。
没有优化过UI图集的项目，会浪费很多空间，包括硬盘空间和内存空间，同时也会浪费CPU的工作效率。所以优化UI图集拼接也是很重要的。

如何优化图集拼接？
下面介绍几个方法。
1.	充分利用图集空间。在我们大小图拼接在一起制作成图集时，尽量不要让图集空出太多碎片空间。碎片空间怎么来的呢，基本上由大图与大图拼接而来，因为大图需要大块的拼接空间，所以会有几张大图拼接在一起形成图集的情况，导致很多浪费的空白空间在图集内。我们要把大图拆分开来拼接，或者把大图分离出去不放入图集内，而使用单独的图片做渲染。在拼接时，大图穿插小图，让空间更充分的利用。
2.	图集大小控制。假设我们图集的大小不加以控制，就会形成例如2048*2048甚至4096*4096的图。这会导致什么问题呢，在游戏加载UI时异常的卡顿，而且卡顿的时间很长，内存消耗过快，导致糟糕的用户体验甚至崩溃。我们需要规范图集大小，例如我们通常规定图集大小标准在1024*1024，这样不仅在制作时要考虑让大小图充分利用空白空间，也让UI在加载时，只加载需要的图集，让加载速度更快。
3.	图片的拼接归类。在没有图片拼接归类的情况下，通常会在加载UI时加载了一些不必要的图集，导致加速速度过慢，内存消耗过大的问题。比如背包界面的一部分图片，放在了大厅图集里，导致，在加载大厅UI时，也把背包界面的图集一并加载了进来，导致加速速度缓慢，内存飙升。我们要人为的规范他们，把图集分类，例如，通常我们分为，常用图集（里面包含了一些各个界面都会用到的常用图片），功能类图集（比如大厅界面图集，背包界面图集，任务界面图集等），链接类图集（链接两种界面的图集，比如只在大厅界面与背包界面都会用的，特别需要拆分出来单独成为一张图集）

最终我们优化图集拼接的目的是，减少图集大小，减少图集数量，减少一次性加载图集数量，让游戏运行的更稳，更快。

⑭	GC的优化。 https://www.cnblogs.com/zblade/p/6445578.html ，https://unity3d.com/de/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069

什么是GC？为什么要优化GC？

GC(garbage collection)就是垃圾回收机制。前面在内存泄漏章节中对垃圾回收机制做过详细的介绍。这里就简单介绍下。
在游戏运行的时候，数据主要存储在内存中，当游戏的数据在不需要的时候，存储当前数据的内存就可以被回收以再次使用。内存垃圾是指当前废弃数据所占用的内存，垃圾回收（GC）是指将废弃的内存重新回收再次使用的过程。

在进行垃圾回收（GC）时，会检查内存上的每个存储变量，然后对每个变量检查其引用是否处于激活状态，如果变量的引用不处于激活状态，则会被标记为可回收，被标记的变量会在接下去的程序中被移除，其所占的内存也会被回收到堆内存中。所以GC操作是一个相当耗时的操作，堆内存上变量或者引用越多则其检查的操作会更多，耗时也更长。

引用变量的多少和层数，只是GC耗时的其中一个因素。其他关键的耗时因素，还有内存分配和申请系统内存的耗时，回收内存的耗时以及垃圾回收（GC）接口被调用的次数，都是非常关键的GC耗时因素。

下面我们来看内存分配和申请系统内存是如何影响耗时的。

在内存泄漏中详细讲述过Unity3D内存管理的机制，我们这里就简单再介绍下。
　　1）Unity3D内部有两个内存管理池：堆内存和堆栈内存。堆栈内存(stack)主要用来存储较小的和短暂的数据，堆内存(heap)主要用来存储较大的和存储时间较长的数据。

　　2）Unity3D中的变量只会在堆栈或者堆内存上进行内存分配，变量要么存储在堆栈内存上，要么处于堆内存上。

　　3）只要变量处于激活状态，则其占用的内存会被标记为使用状态，则该部分的内存处于被分配的状态。

　　4）一旦变量不再激活，则其所占用的内存不再需要，该部分内存可以被回收到内存池中被再次使用，这样的操作就是内存回收。处于堆栈上的内存回收及其快速，处于堆上的内存并不是及时回收的，此时其对应的内存依然会被标记为使用状态。

5) 垃圾回收主要是指堆上的内存分配和回收，Unity3D中会定时对堆内存进行GC操作。
 6) Unity3D中堆内存只会增加，不会减少，也就是当堆内存不足时只会向系统申请更多内存，而不会空闲时还给系统，除非应用结束重新开始。

由于Unity3D在堆内存不足时会向系统申请新的内存以扩充堆内存，这种向系统申请新内存的方式是比较耗时的。我们平时的游戏项目中，常常由于堆内存中的申请与回收导致大量的碎片内存，而当大块的内存需要使用时，这些碎片内存却无法用于大块内存需求，此时就会引起一个耗时的操作，就是向系统申请更多的内存，申请的次数越多越频繁，GC的耗时也就越多。

垃圾回收（GC）接口被调用的次数也是关键因素。
经常有游戏项目中，不断频繁的调用垃圾回收（GC）接口，每次调用都会重新检查所有内存变量是否被激活，并且标记需要回收的内存块并且在后面回收，这样就在逻辑中产生了很多不必要的检查，和并不集中的销毁导致的内存命中率下降，最终导致浪费了宝贵的CPU资源。

GC的调用次数以及时机是非常关键的，GC操作会需要大量的时间来运行，如果堆内存上有大量的变量或者引用需要检查，则检查的操作会十分缓慢，这就会使得游戏运行缓慢。其次GC可能会在关键时候运行，例如在CPU处于游戏的性能运行关键时刻，此时任何一个额外的操作都可能会带来极大的影响，使得游戏帧率下降。

另外一个GC带来的问题是堆内存的碎片化。当一个内存单元从堆内存上分配出来，其大小取决于其存储的变量的大小。当该内存被回收到堆内存上的时候，有可能使得堆内存被分割成碎片化的单元。也就是说堆内存总体可以使用的内存单元较大，但是单独的内存单元较小，在下次内存分配的时候不能找到合适大小的存储单元，这也会触发GC操作或者堆内存扩展操作。堆内存碎片会造成两个结果，一个是游戏占用的内存会越来越大，一个是GC会更加频繁地被触发。

如何主动减少GC的消耗？

主要有三个操作会触发垃圾回收：
　　 1） 在堆内存上进行内存分配操作而内存不够的时候都会触发垃圾回收来利用闲置的内存；
　　 2） GC会自动的触发，不同平台运行频率不一样；
　　 3） GC可以被强制执行。

特别是在堆内存上进行内存分配时内存单元不足够的时候，GC会被频繁触发，这就意味着频繁在堆内存上进行内存分配和回收会触发频繁的GC操作。
在Unity3D中，值类型变量都在堆栈上进行内存分配，而引用类型和其他类型的变量都在堆内存上分配。所以值类型的分配和释放,在其生命周期后会被立即收回，例如函数中的临时变量Int，其对应函数调用完后会立即回收。而引用类型的分配和释放，是在其生命周期后或被清除后，在GC的时候才回收，例如函数中的临时变量List<Int>，在函数调用结束后并不会立刻被回收，而是要等到下次GC时才被回收至堆内存。

大体上来说，我们可以通过三种方法来降低GC的影响：
　　1）减少GC的运行次数；
　　2）减少单次GC的运行时间；
　　3）将GC的运行时间延迟，避免在关键时候触发，比如可以在场景加载的时候调用GC。

我们可以采用三种策略：
　　1）对游戏进行重构，减少堆内存的分配和引用的分配。更少的变量和引用会减少GC操作中的检测个数从而提高GC的运行效率。
　　2）降低堆内存分配和回收的频率，尤其是在关键时刻。也就是说更少的事件触发GC操作，同时也降低堆内存的碎片化。
　　3）我们可以试着测量GC和堆内存扩展的时间，使其按照可预测的顺序执行。当然这样操作的难度极大，但是这会大大降低GC的影响。

减少内存垃圾的一些方法：
1.	缓存变量，达到重复利用的目的，减少不必要的内存垃圾。
比如，Update或OnTriggerEnter中使用 MeshRenderer meshrender = gameObject.GetComponent<MeshRenderer>()来处理模型渲染类，就会造成不必要的内存垃圾。我们可以在Start或Awake中先缓存起来，然后在Update或OnTriggerEnter中使用。这样我们已经缓存的变量内存一直存在在那，而不会被反复的销毁和分配。

优化前
void OnTriggerEnter(Collider other)
{
    MeshRenderer meshRenderer = gameObject.GetComponent<MeshRenderer>();
    ExampleFunction(meshRenderer);
}

优化后
private MeshRenderer mMeshRenderer;
 
void Start()
{
   mMeshRenderer = gameObject.GetComponent<MeshRenderer>();
}
 
void OnTriggerEnter(Collider other)
{
    ExampleFunction(mMeshRenderer);
}

2.	减少逻辑调用。堆内存分配，最坏的情况就是在其反复调用的函数中进行堆内存分配，例如Update()和LateUpdate()函数这种每帧都调用的函数，这会造成大量的内存垃圾。我们要想方设法减少逻辑调用。
我们可以利用时间因素，对比是否改变的情况等将Update和LateUpdate中的逻辑调用减少到最低程度。

例如，用时间因素，决定是否调用逻辑的案例

优化前，每一帧都在调用逻辑。
void Update()
{
    ExampleFunction(transform.position.x);
}

优化后，调用逻辑的间隔延迟到1秒。
private float timeSinceLastCalled =  0;
private float delay = 1f;
void Update()
{
    timSinceLastCalled += Time.deltaTime;
    if(timeSinceLastCalled > delay)
    {
         ExampleFunction();
         timeSinceLastCalled = 0f;
    }
}

例如，用对比情况，决定是否调用逻辑的案例

优化前，每帧都在调用逻辑。
void Update()
{
    ExampleFunction(transform.position.x);
}

优化后，只在坐标X改变的情况下才调用逻辑。
private float previousTransformPositionX;

void Update()
{
    if(transform.position.x != previousTransformPositionX)
    {
        ExampleFunction (transform.position.x);    
        previousTransformPositionX = transform.position.x;
    }
}
通过这样细小的改变，我们可以使得代码运行的更快同时减少内存垃圾的产生。案例中，我们只使用了几个变量的代价，却节省了很多CPU消耗。

3.	清除链表，而不是不停的生成新的链表。
在堆内存上进行链表的分配的时候，如果该链表需要多次反复的分配，我们可以采用链表的clear函数来清空链表从而替代反复多次的创建分配链表。

优化前，每帧都会分配一个链表的内存进行调用。
void Update()
{
    List myList = new List();
    ExampleFunction(myList);       
}

优化后，不再重复分配链表内存，而是将他清理后再使用。
private List myList = new List();
void Update()
{
    myList.Clear();
    ExampleFunction(myList);
}

4.	对象池。
用对象池技术保留废弃的内存变量，在当重复利用时不再需要重新分配内存而是利用对象池内的旧有的对象。

因为即便我们在代码中尽可能地减少堆内存的分配行为，但是如果游戏有大量的对象需要产生和销毁，依然会造成频繁的GC。对象池技术可以通过重复使用对象来降低堆内存的分配和回收频率。对象池在游戏中广泛的使用，特别是在游戏中需要频繁的创建和销毁相同的游戏对象的时候，例如枪的子弹这种会频繁生成和销毁的对象。
5.	字符串。
在C#中，字符串是引用类型变量而不是值类型变量，即使看起来它是存储字符串的值的。这就意味着字符串会造成一定的内存垃圾，由于代码中经常使用字符串，所以我们需要对其格外小心。

C#中的字符串是不可变更的，也就是说其内部的值在创建后是不可被变更的。每次在对字符串进行操作的时候（例如运用字符串的“加”操作），C#会新建一个字符串用来存储新的字符串，使得旧的字符串被废弃，这样就会造成内存垃圾。

我们可以采用以下的一些方法来最小化字符串的影响：

1）	减少不必要的字符串的创建，如果一个字符串被多次利用，我们可以创建并缓存该字符串。
例如项目中常用到的，将文字字符串存储在数据表中，然后由程序去读取数据表，从而将所有常用的字符串存储在内存里。这样的话，成员们在调用字符串时就可以直接调用我们存储的字符串了，而不需要去新建一个字符串来操作。

2）减少不必要的字符串操作。
例如如果在Text组件中，有一部分字符串需要经常改变，但是其他部分不会，则我们可以将其分为两个部分的组件，对于不变的部分就设置为类似常量字符串即可。
优化前，每帧都会重新创建一个字符串来设置时间文字。
public Text timerText;
private float timer;
void Update()
{
    timer += Time.deltaTime;
    timerText.text = "Time:"+ timer.ToString();
}

优化后，不再操作字符串，而是赋值给文字组件显示，从而减少了内存垃圾。
public Text timerHeaderText;
public Text timerValueText;
private float timer;
void Start()
{
    timerHeaderText.text = "TIME:";
}
 
void Update()
{
   timerValueText.text = timer.ToString();
}

　　3）如果我们需要实时的操作字符串，我们可以采用StringBuilderClass来代替，StringBuilder专为不需要进行内存分配而设计，从而减少字符串产生的内存垃圾。
不过此类方法还是要选择性使用，因为在实际项目中，如果大量的使用StringBuilder，又会产生很多new的操作，导致内存垃圾的产生，同时原本工作量小的字符串操作，又会变成工作量大的StringBuilder函数调用。所以只能在小范围特定区域使用，比如，特别频繁的操作字符串的情况下，不断增加，改变字符串的地方。例如，游戏中有对字符串逐步显示的需求，像写文章一样一个个或者一片片的显示，而不是全部一下子显示的需求时，用StringBuilder就恰到好处。

　　4）移除游戏中的Debug.Log()函数的代码，尽管该函数可能输出为空，对该函数的调用依然会执行，该函数会创建至少一个字符（空字符）的字符串。如果游戏中有大量的该函数的调用，这会造成内存垃圾的增加。

6.	协程。
调用 StartCoroutine()会产生少量的内存垃圾，因为Unity3D会生成实体来管理协程。任何在游戏关键时刻调用的协程都需要特别的注意，特别是包含延迟回调的协程。

yield在协程中不会产生堆内存分配，但是如果yield带有参数返回，则会造成不必要的内存垃圾，例如：
yield return 0;
由于需要返回0，引发了装箱操作，所以会产生内存垃圾。这种情况下，为了避免内存垃圾，我们可以这样返回：
yield return null;
另外一种对协程的错误使用是每次返回的时候都new同一个变量，例如：

while(!isComplete)
{
    yield return new WaitForSeconds(1f);
}
我们可以采用缓存来避免这样的内存垃圾产生：

WaitForSeconds delay = new WaiForSeconds(1f);
while(!isComplete)
{
    yield return delay;
}

7.	Foreach循环。
在Unity3D 5.5以前的版本中，在foreach的迭代中都会生成内存垃圾，主要来自于其后的装箱操作。每次在foreach迭代的时候，都会在堆内存上生产一个System.Object用来实现迭代循环操作。如果游戏工程不能升级到5.5以上，则可以用for或者while循环来解决这个问题。

8.	函数引用。
函数的引用，无论是指向匿名函数还是显式函数，在Unity3D中都是引用类型变量，这都会在堆内存上进行分配。
特别是System.Action匿名函数在项目中使用的特别频繁，匿名函数调用完成后都会增加内存的使用和堆内存的分配。具体函数的引用和终止都取决于操作平台和编译器设置，但是如果想减少GC最好减少函数的引用，特别是匿名函数。

9.	LINQ和常量表达式。
由于LINQ和常量表达式以装箱的方式实现，所以在使用的时候最好进行性能测试。如果可以尽量使用其他方式代替LINQ，以家少LINQ对内存垃圾的增加。

10.	主动调用GC操作。
如果我们知道堆内存在被分配后并没有被使用，我们希望可以主动地调用GC操作，或者在GC操作并不影响游戏体验的时候（例如场景切换，或读进度条的时候），我们可以主动的调用GC操作System.GC.Collect()。通过主动的调用，我们可以主动驱使GC操作来回收堆内存。让体验不好的时间段放在察觉不到的地方，或者不会被明显察觉的地方。