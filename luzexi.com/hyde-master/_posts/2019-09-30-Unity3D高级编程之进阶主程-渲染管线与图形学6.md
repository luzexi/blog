---
layout: post
status: publish
published: false
title: 《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(三) - 渲染原理与知识1
description: "unity3d 高级编程 主程 shader 漫反射 镜面反射 自发光 球面反射"
excerpt_separator: ===
tags:
- 书籍著作
- Unity3D
- 前端技术
---

前面的几篇非常详尽的讲述了渲染管线的整个流程以及渲染管线上的每个节点的来龙去脉。这节我们来说说，一些渲染概念和原理，以及上几章中对渲染管线上没有说到的细节，或者在现代GPU中已经被优化的流程。

### 为什么要有渲染顺序

前面章节中我们介绍了深度测试这个模块，它用片元的深度值与深度缓存中的值比较得到测试结果，再决定是否要写入深度缓存中，如果判断失败则抛弃片元不再继续下面的流程。这其中涉及到了 ZTest On/Off 状态开关，和，ZWrite On/Off 状态开关，其中ZTest 用于控制是否开启测试，ZWrite 用于控制是否写入深度缓存。

渲染管线中的深度测试节点最大的好处是帮助我们尽早的发现不需要渲染的片元，并抛弃它们以节省GPU消耗提高效率。

其实大部分情况下我们都使用 ZTest LEqual 做判断，即离摄像机越近的物体越容易遮挡住离得远的物体。

从这个角度看渲染机制，如果能先把离屏幕近的物体放前面渲染，那么后面的物体虽然不能完全在CPU层面判定它是否被掩盖而剔除，但能在深度测试的机制下早早的抛弃掉很多片元，会提升不少的GPU效率。

于是渲染顺序就成了关键，Unity3D引擎对所有不透明物体在渲染前做了排序工作，即离摄像机近的排在前面渲染，离的远的排在后面渲染，这个渲染队列又有了新的排序规则。

那么半透明物体怎么办呢？因为半透明物体需要Blend混合，ZWrtie开关一般都是关的，因为如果开启来的话半透明部分在深度测试时就变成了完全的遮挡，从而没有了半透的效果。因此它需要在所有不透明物体渲染后再渲染才能真正发挥出它半透明的效果。

在Unity3D引擎在提交渲染时增加了这么条规则，即对所有半透明物体的渲染都排在了不透明物体的后面，这样就确保了半透明物体能在不透明物体渲染完毕后才开始渲染，以保证半透明物体的渲染效果。

记住所有的渲染效果都是引擎自主排列的，而不是由GPU排列的，GPU只知道渲染、测试、裁切，完全不会去管物体的前后次序，这也是为什么称它叫“流水线”的原因，就像工厂里的作业流水线一样，每个工人都只是一个节点的螺丝钉，他们很多时候只要记住一个动作就可以“无脑”的重复劳动。

那么怎么标记物体是不透明还是半透明呢，Unity3D引擎为了解决这个问题，将渲染顺序放在Shader中实现，即 Queue 标签来决定我们的模型将归于哪个渲染队列。

Unity3D在内部使用了一系列整数索引来表示渲染的次序，且索引越小越表示排在前面被渲染。

因此我们可以把所有的物体分成，最底层物体、不透明物体、半透明物体、以及最上层物体，这四种类型。



opaque, alpha test，alpha blend

### Mipmap的原理

### Alpha Test

其过程比较简单，在片元着色器中判断该片元 Alpha 值是否小于了某个阈值，一旦判定小于某个阈值就立刻选择丢弃。这样做好处是，当某个模型需要很多顶点来描述曲折的面时我们可以用 Alpha 来代替，

### Early-Z GPU优化技术

### ShadowMap阴影是如何生成的

### 显存的存在

显存经常被我们忽视，因为近几年流行的都是手机端的游戏项目，其实它在PC端存在的意义很大。一个显卡除了有图像给处理单元GPU外，还拥有自己的内存，即显存VRAM(Video Random Access Memory)。

GPU可以在显存中存储任何数据，例如图像缓存、深度缓存、模板缓存、着色器实例等。

除了这几个必要的缓存外，显卡中还存放着渲染时需要用到的贴图纹理、顶点缓存等，这些内容都是需要从CPU内存中拷贝过来的，在调用渲染前，应用程序可以调用图形应用接口OpenGL将数据从普通内存中拷贝到显卡内存中，这个过程只存在于PC端和主机端，因为它们都拥有显卡的存在。

因此PC端在渲染前还有进一步拷贝数据的过程，显存并不多即使现代显存成本变低的情况下任然捉襟见肘，所以内存之间的拷贝还存在命中率的问题，如果算法预测数据会被命中则不进行销毁，下次需要拷贝数据时如果已经存在在显存中了就不需要再次拷贝。

手机端就没有这样的拷贝过程。手机端是ARM架构，芯片中嵌入了各种各样的硬件系统，包括SoC(即芯片级系统，包含了完整系统并有嵌入软件的全部内容)、图像处理GPU、音频等。而显存由于种种限制没有被设计加入到ARM中去，因此在手机端中CPU和GPU共用同一个内存控制器，也就是说CPU和GPU是共用内存带宽的，没有独立显存只有普通内存，不过即便这样GPU也有自己的独立内存部分，例如上面的缓存和后面的可写数据的拷贝都需要一份独立的“共享显存”。

手机端没有独立显存也就没有拷贝的过程，如果贴图或顶点数据是只读状态的话完全没有必要为渲染而重新拷贝一份，而是可以直接读取引用的来获取数据，但当它们被开启可写状态时则必须重新拷贝一份在内存中，因为原数据随时会被CPU更改，而当时可能GPU还在渲染中，两个并行的脑袋不能共享一份可写的数据。

### GPU Instancing 是什么？

### 多重采样(Multisampling)与反走样(Antialiasing)

		Quality Settings
		
		AntiAliasing	This sets the level of antialiasing that will be used. The options are 2x, 4x and 8x multi-sampling.

### 颜色缓存与高清屏意味着什么

### 2幂次纹理的读取与纹理压缩

### 闪烁的根源：坐标系变化后的z精度问题

### 什么是overdraw

### lightmap原理

### 什么是卷积，卷积对后渲染的意义是什么

### 什么是PBR，现在为什么对PBR如此重视

### 什么是渲染管线的升级，为什么要升级渲染管线

### SPR(Scriptable Render Pipeline)可编程管线，什么是高清管线HDRP(High-Definition Rendering Pipeline)，Unity3D中的轻量渲染管线LWRP与传统管线有什么差别，以及最近升级的通用管线

### 着色器编译原理

### 为什么要用CG来写Shader而不是其他的

