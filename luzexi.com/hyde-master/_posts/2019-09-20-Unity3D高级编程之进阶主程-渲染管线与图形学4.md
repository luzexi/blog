---
layout: post
status: publish
published: false
title: 《Unity3D高级编程之进阶主程》第七章，渲染管线与图形学(二) - 渲染管线1
description: "unity3d 高级编程 主程 shader 漫反射 镜面反射 自发光 球面反射"
excerpt_separator: ===
tags:
- 书籍著作
- Unity3D
- 前端技术
---

计算机的世界里其实是很纯粹的，没有什么高深的技术，无非就是进程、线程、内存、硬盘、CPU。

在现代社会的实际编程中，很多时候引擎或者框架帮我们屏蔽了底层上的操作使得程序员只需要将所有精力放在上层应用就可以了，因此数学和算法很多时候成了重点，这是符合社会进步规律的，我们需要站在巨人的肩膀上才能走得比巨人更快更远。

Unity3D就是帮助我们快速建立程序结构的好引擎，有了Unity3D我们才能在较低门槛的情况下，创造出自己的想法和创意，让’我‘里面有的内在才能快速和有效的得到放大。

除了进程、线程、内存、硬盘、CPU这些通常我们程序员在编程时都要接触的因素外，对于我们前端程序员来说又多了一个GPU的因素，因此我们需要学习和考虑的问题比一般写程序更加多一些也更加复杂一些，Unity3D虽然封装了所有引擎需要的GPU接口功能但我们还是必须要了解渲染管线是如何处理的，最终是如何将渲染数据渲染要屏幕上的等等这些底层的知识和原理。

### OpenGL、DirectX究竟是什么

OpenGL 和 DirectX 其实是一回事，它们都是图形渲染的应用程序编程接口，它们都是一种可以对图形硬件设备特性进行访问的软件库。它们的区别只是接口不一样，并且，分别由不同的两个开发群体开发出来的两套程序。

为什么会是两个不同群体开发出来的两套差不多功能的软件，并且还同时运行在现有的世界中呢？

OpenGL是由SGI(Silicon Graphics 美国硅图公司)开发的，而DirectX是由微软开发的，由于市场竞争的关系两家公司做了同样的事，最后导致现在的局面。从现在的局面我们可以想象在当初，还没有形成统一的硬件渲染接口时，各家公司的编程方式有多混乱，情况有多复杂，对标准统一接口的标准竞争有多激烈。在这种严峻的情况下才使得两家公司为了各自的利益，一直在不断维护和升级着各自的驱动接口直到今天。

幸运的是 Unity3D 已经帮我们封装好了 OpenGL 和 DirectX 的接口，我们无需关心到底是调用 OpenGL 还是 DirectX。

###### OpenGL究竟处在哪个位置

Unity3D通过调用 OpenGL 来渲染图像，OpenGL 定义各种标准接口就是为了让像 Unity3D 这样的应用程序在面对不同类型的显卡硬件时可以不必慌张，也就是说由于 OpenGL 的存在，Unity3D完全不需要去关心硬件到底是哪个厂家生产的，它的驱动是什么。其实与其说OpenGL在标准接口中适配了硬件厂商的驱动程序，不如说硬件厂商的驱动程序适配了OpenGL，事实上确实是这样。

当Unity3D在渲染调用时去设置OpenGL的渲染状态，OpenGL就会去检查显卡驱动程序里是否有该功能，如果有就会调用，如果是那些比较特殊的渲染接口，有些硬件驱动是没有的则不调用。

如果把GPU硬件看做是最底层的那个模块的话，显卡驱动就是在硬件之上的模块，是用来将指令翻译成机器语言并调用硬件的那个程序。

显然OpenGL是在驱动程序之上的应用程序，我们可以把它看做是适配不同驱动程序的中间件。如下图：

![opengl](/assets/book/7/render-pipeline1.png)

上图中很清晰的表达OpenGL所处的位置，应用程序(如Unity3D)向OpenGL发送渲染指令，告诉OpenGL我的某个模型数据需要渲染或者说某个状态要设置，OpenGL发送指令给显卡驱动程序，显卡驱动程序将指令翻译为机器码后，将指令机器码发送到GPU，GPU先从显存中获得需要的数据再根据指令做处理。

我们看到这个过程中显卡驱动程序只是做了传递指令消息的工作，指令从OpenGL那里发起到GPU接受到指令，显卡驱动只是起到了翻译的作用。因此我们在平常的讨论中，常常将显卡驱动程序的工作忽略掉，而用 OpenGL 与 GPU 的互动代替之。甚至有时会将OpenGL也忽略掉用GPU代替，或把GPU忽略掉用OpenGL代替，因为GPU的工作是机械式的它俩的工作完全可以看做一个整体。

当然这里GPU不只会处理一次，OpenGL会通过显卡驱动发送很多次指令给GPU，让它处理一连串的操作，每次指令都有可能不一样，经过一系列的处理过程后，最终形成了一张屏幕大小的图像存放在缓存中，这时GPU才向屏幕输出最终画面。

下面我们就来详细介绍一下渲染管线。

### 究竟渲染管线是什么？

上面所说的 OpenGL 通过驱动程序向 GPU 发送很多个指令，其实为了渲染很多个模型每一帧都会发送很多个指令，这一系列指令加起来，才形成一整个渲染过程，拥有完整的一个画面。

渲染管线就是指令中完成一个绘制命令(drawcall)的流水线。这条流水线中有很多个环节，每个环节都自己干自己的事，就像工厂里的流水作业一样，每个节点的工人都会拧属于自己的螺丝，完全不会去管前面节点发生了什么事情，不过在现代GPU中也会做些流程上的优化，比如调整节点的顺序，但节点还是自顾自的工作，这部分会在后面的文章中提到。

从严肃的理论描述来说渲染管线：是一系列数据处理的过程，这个过程最终的目的是将应用程序的数据转换到最终输出的缓存上最后输出到屏幕。

我们说的再白话一点。渲染管线从接受到渲染命令后开始，分几个阶段处理了这些数据，这几个阶段分别是应用阶段，几何阶段，光栅化阶段，经过这几个阶段处理最终输出到屏幕上。

		缺图片

图中每个阶段都有各自细分的流程，我们来一一讲述下。

###### 应用阶段

应用阶段其实就是我们执行Unity3D引擎和代码的过程，在逻辑代码过程中，我们实例化了很多个模型或者UI（UGUI的UI也是模型，跟渲染场景中的3d模型从根本上是没有区别的），这些模型有贴图，有材质球，有网格，对于引擎来说，这个阶段在代码执行完毕后它知道了哪些模型需要被渲染，有哪些光源存在，摄像头的位置大小，于是就知道该如何通知GPU去渲染。

引擎除了知道有哪些东西需要被提交到GPU渲染外，在提交前还对这些数据做了很多优化，从而提高渲染性能。

最典型的就要属





