---
layout: post
status: publish
published: true
title: 使用行为树(Behavior Tree)实现游戏AI
author:
  display_name: 陆泽西
  login: luzexi
  email: jesse_luzexi@163.com
  url: http://www.luzexi.com
author_login: luzexi
author_email: jesse_luzexi@163.com
author_url: http://www.luzexi.com
wordpress_id: 13
wordpress_url: http://42.121.122.71/blog/?p=13
date: !binary |-
  MjAxMy0wMS0yNiAxOTowOTozMyArMDgwMA==
date_gmt: !binary |-
  MjAxMy0wMS0yNiAxMTowOTozMyArMDgwMA==
categories:
- 游戏通用模块
tags:
- AI
- 游戏
- 行为树
---
<p>使用行为树(Behavior Tree)实现游戏AI<br />
by AKara 2010-12-09 @ http:&#47;&#47;blog.csdn.net&#47;akara @ akaras@163.com</p>
<p>---------------------------------------------------------------------</p>
<p>谈到游戏AI，很明显智能体拥有的知识条目越多，便显得更智能，但维护<br />
庞大数量的知识条目是个噩梦：使用有限状态机(FSM)，分层有限状态机(HFSM)，<br />
决策树(Decision Tree)来实现游戏AI总有那么些不顺意。</p>
<p>试试Next-Gen AI的行为树(Behavior Tree)吧。</p>
<p>虽说Next-Gen AI，但距其原型提出已有约10年时间，而微软Halo系列估计<br />
已用了超过8年了，Spore和一些著名游戏也早已使用行为树作为它们的AI结构。<br />
如从未接触，那wikipedia(http:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Behavior_Trees)<br />
绝对是入门好资料。</p>
<p>---------------------------------------------------------------------</p>
<p>先贴本文最具价值图(配色可花了不少时间)</p>
<p><a href="http:&#47;&#47;www.luzexi.com&#47;wp-content&#47;uploads&#47;2013&#47;01&#47;213345_1292157838h3CY.jpg"><img class="alignnone size-full wp-image-20" src="http:&#47;&#47;www.luzexi.com&#47;wp-content&#47;uploads&#47;2013&#47;01&#47;213345_1292157838h3CY.jpg" alt="213345_1292157838h3CY" width="444" height="768" &#47;><&#47;a></p>
<p>为显美观：BT被横放，Node层次被刻意减少，Dec被刻意安插，Cond被刻意捏造。<br />
PS：其实真正的高效的Node Group剔除应多加一层Sequence Node。</p>
<p>---------------------------------------------------------------------</p>
<p>行为树(Behavior Tree)具有如下的特性：</p>
<p>它只有4大类型的Node：<br />
* Composite Node<br />
* Decorator Node<br />
* Condition Node<br />
* Action Node</p>
<p>任何Node被执行后，必须向其Parent Node报告执行结果：成功 &#47; 失败。<br />
这简单的成功 &#47; 失败汇报原则被很巧妙地用于控制整棵树的决策方向。</p>
<p>---------------------------------------------------------------------</p>
<p>先看Composite Node，其实它按复合性质还可以细分为3种：<br />
* Selector Node<br />
当执行本类型Node时，它将从begin到end迭代执行自己的Child Node：<br />
如遇到一个Child Node执行后返回True，那停止迭代，<br />
本Node向自己的Parent Node也返回True；否则所有Child Node都返回False，<br />
那本Node向自己的Parent Node返回False。</p>
<p>* Sequence Node<br />
当执行本类型Node时，它将从begin到end迭代执行自己的Child Node：<br />
如遇到一个Child Node执行后返回False，那停止迭代，<br />
本Node向自己的Parent Node也返回False；否则所有Child Node都返回True，<br />
那本Node向自己的Parent Node返回True。</p>
<p>* Parallel Node<br />
并发执行它的所有Child Node。<br />
而向Parent Node返回的值和Parallel Node所采取的具体策略相关：<br />
Parallel Selector Node: 一False则返回False，全True才返回True。<br />
Parallel Sequence Node: 一True则返回True，全False才返回False。<br />
Parallel Hybird Node: 指定数量的Child Node返回True或False后才决定结果。</p>
<p>Parallel Node提供了并发，提高性能。<br />
不需要像Selector&#47;Sequence那样预判哪个Child Node应摆前，哪个应摆后，<br />
常见情况是：<br />
(1)用于并行多棵Action子树。<br />
(2)在Parallel Node下挂一棵子树，并挂上多个Condition Node，<br />
以提供实时性和性能。<br />
Parallel Node增加性能和方便性的同时，也增加实现和维护复杂度。</p>
<p>PS：上面的Selector&#47;Sequence准确来说是Liner Selector&#47;Liner Sequence。<br />
AI术语中称为strictly-order：按既定先后顺序迭代。</p>
<p>Selector和Sequence可以进一步提供非线性迭代的加权随机变种。<br />
Weight Random Selector提供每次执行不同的First True Child Node的可能。<br />
Weight Random Sequence则提供每次不同的迭代顺序。<br />
AI术语中称为partial-order，能使AI避免总出现可预期的结果。</p>
<p>---------------------------------------------------------------------</p>
<p>再看Decorator Node，它的功能正如它的字面意思：它将它的Child Node执行<br />
后返回的结果值做额外处理后，再返回给它的Parent Node。很有些AOP的味道。</p>
<p>比如Decorator Not&#47;Decorator FailUtil&#47;Decorator Counter&#47;Decorator Time...<br />
更geek的有Decorator Log&#47;Decorator Ani&#47;Decorator Nothing...</p>
<p>---------------------------------------------------------------------</p>
<p>然后是很直白的Condition Node，它仅当满足Condition时返回True。</p>
<p>---------------------------------------------------------------------</p>
<p>最后看Action Node，它完成具体的一次(或一个step)的行为，视需求返回值。<br />
而当行为需要分step&#47;Node间进行时，可引入Blackboard进行简单数据交互。</p>
<p>---------------------------------------------------------------------</p>
<p>整棵行为树中，只有Condition Node和Action Node才能成为Leaf Node，而也<br />
只有Leaf Node才是需要特别定制的Node；Composite Node和Decorator Node均<br />
用于控制行为树中的决策走向。(所以有些资料中也统称Condition Node和Action<br />
Node为Behavior Node，而Composite Node和Decorator Node为Decider Node。)</p>
<p>更强大的是可以加入Stimulus和Impulse，通过Precondition来判断masks开关。</p>
<p>通过上述的各种Nodes几乎可以实现所有的决策控制：if, while, and, or,<br />
not, counter, time, random, weight random, util...</p>
<p>---------------------------------------------------------------------</p>
<p>总的来说，行为树具有如下几种优点，确实是实现AI框架的利器，甚至是一种<br />
通用的可维护的复杂流程管理利器：</p>
<p>> 静态性<br />
越复杂的功能越需要简单的基础，否则最后连自己都玩不过来。</p>
<p>静态是使用行为树需要非常着重的一个要点：即使系统需要某些"动态"性。</p>
<p>其实诸如Stimulus这类动态安插的Node看似强大，<br />
但却破坏了本来易于理解的静态性，弊大于利。<br />
Halo3相对于Halo2对BT AI的一个改进就是去除Stimulus的动态性。<br />
取而代之的做法是使用Behavior Masks，Encounter Attitude，Inhibitions。<br />
原则就是保持全部Node静态，只是根据事件和环境来检查是否启用Node。</p>
<p>静态性直接带来的好处就是整棵树的规划无需再运行时动态调整，为很多优化<br />
和预编辑都带来方便。</p>
<p>> 直观性<br />
行为树可以方便地把复杂的AI知识条目组织得非常直观。<br />
默认的Composite Node的从begin往end的Child Node迭代方式就像是处理一个<br />
预设优先策略队列，也非常符合人类的正常思考模式：先最优再次优。</p>
<p>行为树编辑器对优秀的程序员来说也是唾手可得。</p>
<p>> 复用性<br />
各种Node，包括Leaf Node，可复用性都极高。<br />
实现NPC AI的个性区别甚至可以通过在一棵共用的行为树上不同的位置来<br />
安插Impulse来达到目的。</p>
<p>当然，当NPC需要一个完全不同的大脑，比如70级大BOSS，<br />
与其绞尽脑汁在一棵公用BT安插Impulse，不如重头设计一棵专属BT。</p>
<p>> 扩展性<br />
虽然上述Node之间的组合和搭配使用几乎覆盖所有AI需求。<br />
但也可以容易地为项目量身定做新的Composite Node或Decorator Node。<br />
还可以积累一个项目相关的Node Lib，长远来说非常有价值。</p>
